commit 0021a145fb5238ca2f565b98bb3d66d825dfbec5
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Apr 16 18:53:52 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Apr 16 18:53:52 2009 -0800

C# Port:
* More Capitalized method names

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6043]

diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
index 2f6ea3f..31499c3 100644
--- a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
@@ -45,7 +45,7 @@ namespace Antlr3.Targets
string literal )
{

-            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
return c.ToString();
}

@@ -59,7 +59,7 @@ namespace Antlr3.Targets
return ttype.ToString();
}

-            string name = generator.grammar.getTokenDisplayName( ttype );
+            string name = generator.grammar.GetTokenDisplayName( ttype );

// If name is a literal, return the token type instead
if ( name[0] == '\'' )
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
index b390bc9..7e99676 100644
--- a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
@@ -117,7 +117,7 @@ namespace Antlr3.Targets
*/
public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator codegen, string literal )
{
-            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
string prefix = "'";
if ( codegen.grammar.MaxCharValue > 255 )
prefix = "L'";
@@ -135,7 +135,7 @@ namespace Antlr3.Targets
*/
public override string GetTargetStringLiteralFromANTLRStringLiteral( CodeGenerator codegen, string literal )
{
-            StringBuilder buf = Grammar.getUnescapedStringFromGrammarStringLiteral( literal );
+            StringBuilder buf = Grammar.GetUnescapedStringFromGrammarStringLiteral( literal );
string prefix = "\"";
if ( codegen.grammar.MaxCharValue > 255 )
prefix = "L\"";
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs b/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
index 43b5332..9bbc7f7 100644
--- a/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
@@ -62,7 +62,7 @@ namespace Antlr3.Targets
public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator, string literal )
{
StringBuilder buf = new StringBuilder();
-            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
if ( c < Label.MIN_CHAR_VALUE )
{
return "0";
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs b/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
index a7e7234..eb4d48e 100644
--- a/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
@@ -89,7 +89,7 @@ namespace Antlr3.Targets
/** If we have a label, prefix it with the recognizer's name */
public override string GetTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
{
-            string name = generator.grammar.getTokenDisplayName( ttype );
+            string name = generator.grammar.GetTokenDisplayName( ttype );
// If name is a literal, return the token type instead
if ( name[0] == '\'' )
{
@@ -103,7 +103,7 @@ namespace Antlr3.Targets
/** Target must be able to override the labels used for token types. Sometimes also depends on the token text.*/
string GetTokenTextAndTypeAsTargetLabel( CodeGenerator generator, string text, int tokenType )
{
-            string name = generator.grammar.getTokenDisplayName( tokenType );
+            string name = generator.grammar.GetTokenDisplayName( tokenType );
// If name is a literal, return the token type instead
if ( name[0] == '\'' )
{
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs b/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs
index 34be616..7bb0d50 100644
--- a/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs
@@ -46,8 +46,8 @@ namespace Antlr3.Targets
targetCharValueEscape['$'] = "\\$";
targetCharValueEscape['@'] = "\\@";
targetCharValueEscape['%'] = "\\%";
-            AttributeScope.tokenScope.addAttribute( "self", null );
-            RuleLabelScope.predefinedLexerRulePropertiesScope.addAttribute( "self", null );
+            AttributeScope.tokenScope.AddAttribute( "self", null );
+            RuleLabelScope.predefinedLexerRulePropertiesScope.AddAttribute( "self", null );
}

public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator,
@@ -55,7 +55,7 @@ namespace Antlr3.Targets
{
StringBuilder buf = new StringBuilder( 10 );

-            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
if ( c < Label.MIN_CHAR_VALUE )
{
buf.Append( "\\x{0000}" );
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
index caad321..416037b 100644
--- a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
@@ -61,7 +61,7 @@ namespace Antlr3.Targets
return ttype.ToString();
}

-            string name = generator.grammar.getTokenDisplayName( ttype );
+            string name = generator.grammar.GetTokenDisplayName( ttype );

// If name is a literal, return the token type instead
if ( name[0] == '\'' )
@@ -76,7 +76,7 @@ namespace Antlr3.Targets
CodeGenerator generator,
string literal )
{
-            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
return ( (char)c ).ToString();
}

diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs b/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
index b1b6af4..d8256fb 100644
--- a/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
@@ -73,11 +73,11 @@ namespace Antlr3.Targets

public override string GetTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
{
-            string name = generator.grammar.getTokenDisplayName( ttype );
+            string name = generator.grammar.GetTokenDisplayName( ttype );
// If name is a literal, return the token type instead
if ( name[0] == '\'' )
{
-                return generator.grammar.computeTokenNameFromLiteral( ttype, name );
+                return generator.grammar.ComputeTokenNameFromLiteral( ttype, name );
}
return name;
}
diff --git a/Antlr3.Test/BaseTest.cs b/Antlr3.Test/BaseTest.cs
index 83e175c..0da5592 100644
--- a/Antlr3.Test/BaseTest.cs
+++ b/Antlr3.Test/BaseTest.cs
@@ -92,7 +92,7 @@ namespace AntlrUnitTests
// new output dir for each test
tmpdir = Path.GetFullPath( Path.Combine( Path.GetTempPath(), "antlr-" + currentTimeMillis() ) );

-            ErrorManager.resetErrorState();
+            ErrorManager.ResetErrorState();

// force reset of static caches
new StringTemplateGroup( "" );
@@ -323,7 +323,7 @@ namespace AntlrUnitTests
*/
AntlrTool antlr = new AntlrTool( optionsA );
antlr.Process();
-                IANTLRErrorListener listener = ErrorManager.getErrorListener();
+                IANTLRErrorListener listener = ErrorManager.GetErrorListener();
if ( listener is ErrorQueue )
{
ErrorQueue equeue = (ErrorQueue)listener;
@@ -677,7 +677,7 @@ namespace AntlrUnitTests
*/
assertEquals( expectedMessage.arg, foundMsg.arg );
assertEquals( expectedMessage.arg2, foundMsg.arg2 );
-            ErrorManager.resetErrorState(); // wack errors for next test
+            ErrorManager.ResetErrorState(); // wack errors for next test
}

public /*static*/ class StreamVacuum //: Runnable
diff --git a/Antlr3.Test/ErrorQueue.cs b/Antlr3.Test/ErrorQueue.cs
index 648b362..58234c5 100644
--- a/Antlr3.Test/ErrorQueue.cs
+++ b/Antlr3.Test/ErrorQueue.cs
@@ -45,22 +45,22 @@ namespace AntlrUnitTests
internal List<Message> errors = new List<Message>();
internal List<Message> warnings = new List<Message>();

-        public virtual void info( string msg )
+        public virtual void Info( string msg )
{
infos.Add( msg );
}

-        public virtual void error( Message msg )
+        public virtual void Error( Message msg )
{
errors.Add( msg );
}

-        public virtual void warning( Message msg )
+        public virtual void Warning( Message msg )
{
warnings.Add( msg );
}

-        public virtual void error( ToolMessage msg )
+        public virtual void Error( ToolMessage msg )
{
errors.Add( msg );
}
diff --git a/Antlr3.Test/TestASTConstruction.cs b/Antlr3.Test/TestASTConstruction.cs
index 534860f..5f5f67d 100644
--- a/Antlr3.Test/TestASTConstruction.cs
+++ b/Antlr3.Test/TestASTConstruction.cs
@@ -52,7 +52,7 @@ namespace AntlrUnitTests
"a : A;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT A <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -64,7 +64,7 @@ namespace AntlrUnitTests
"B : 'a';" );
string expecting =
"(rule A ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT B <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "A" ).tree.ToStringTree();
+            string found = g.GetRule( "A" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -76,7 +76,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -88,7 +88,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -100,7 +100,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -112,7 +112,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -124,7 +124,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -136,7 +136,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -147,7 +147,7 @@ namespace AntlrUnitTests
"a : 'a'*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -158,7 +158,7 @@ namespace AntlrUnitTests
"B : 'b'*;" );
string expecting =
"(rule B ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "B" ).tree.ToStringTree();
+            string found = g.GetRule( "B" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -169,7 +169,7 @@ namespace AntlrUnitTests
"a : 'while'*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'while' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -180,7 +180,7 @@ namespace AntlrUnitTests
"B : 'while'*;" );
string expecting =
"(rule B ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'while' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "B" ).tree.ToStringTree();
+            string found = g.GetRule( "B" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -191,7 +191,7 @@ namespace AntlrUnitTests
"a : 'a'+;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -202,7 +202,7 @@ namespace AntlrUnitTests
"B : 'b'+;" );
string expecting =
"(rule B ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "B" ).tree.ToStringTree();
+            string found = g.GetRule( "B" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -213,7 +213,7 @@ namespace AntlrUnitTests
"a : 'a'?;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -224,7 +224,7 @@ namespace AntlrUnitTests
"B : 'b'?;" );
string expecting =
"(rule B ARG RET scope (BLOCK (ALT (? (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "B" ).tree.ToStringTree();
+            string found = g.GetRule( "B" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -235,7 +235,7 @@ namespace AntlrUnitTests
"ID : 'a'..'z'+;" );
string expecting =
"(rule ID ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (.. 'a' 'z') <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "ID" ).tree.ToStringTree();
+            string found = g.GetRule( "ID" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -246,7 +246,7 @@ namespace AntlrUnitTests
"a : x=ID;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -257,7 +257,7 @@ namespace AntlrUnitTests
"a : x=ID?;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -268,7 +268,7 @@ namespace AntlrUnitTests
"a : x=ID*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -280,7 +280,7 @@ namespace AntlrUnitTests
"b : ID;\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (= x b) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -291,7 +291,7 @@ namespace AntlrUnitTests
"a : x=(A|B);\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (= x (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -302,7 +302,7 @@ namespace AntlrUnitTests
"a : x=~(A|B);\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -313,7 +313,7 @@ namespace AntlrUnitTests
"a : x+=~(A|B);\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -324,7 +324,7 @@ namespace AntlrUnitTests
"a : x+=~(A|B)+;\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (+= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -336,7 +336,7 @@ namespace AntlrUnitTests
"b : ID;\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (= x b) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -347,7 +347,7 @@ namespace AntlrUnitTests
"a : x+=ID*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (+= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -358,7 +358,7 @@ namespace AntlrUnitTests
"a : x+='int'*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (+= x 'int') <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -371,7 +371,7 @@ namespace AntlrUnitTests
"b : ID;\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (+= x b) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -383,7 +383,7 @@ namespace AntlrUnitTests
"a : ('*'^)* ;\n" );  // bug: the synpred had nothing in it
string expecting =
"(rule synpred1_Expr ARG RET scope (BLOCK (ALT '*' <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "synpred1_Expr" ).tree.ToStringTree();
+            string found = g.GetRule( "synpred1_Expr" ).tree.ToStringTree();
assertEquals( expecting, found );
}

@@ -395,7 +395,7 @@ namespace AntlrUnitTests
"a : ({blort} 'x')* ;\n" );  // bug: the synpred had nothing in it
string expecting =
"(rule synpred1_Expr ARG RET scope (BLOCK (ALT blort 'x' <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.getRule( "synpred1_Expr" ).tree.ToStringTree();
+            string found = g.GetRule( "synpred1_Expr" ).tree.ToStringTree();
assertEquals( expecting, found );
}

diff --git a/Antlr3.Test/TestAttributes.cs b/Antlr3.Test/TestAttributes.cs
index 48f6e68..242ee71 100644
--- a/Antlr3.Test/TestAttributes.cs
+++ b/Antlr3.Test/TestAttributes.cs
@@ -72,7 +72,7 @@ namespace AntlrUnitTests
new CommonToken( ANTLRParser.ACTION, action ), 0 );
string expecting = action;
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, "<action>" );
@@ -93,14 +93,14 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 0 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -114,7 +114,7 @@ namespace AntlrUnitTests
string expecting = "i; i.x; u; u.x";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a[User u, int i]\n" +
@@ -122,12 +122,12 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -144,7 +144,7 @@ namespace AntlrUnitTests
string expecting = "x, (*a).foo(21,33), 3.2+1, '\\n', \"a,oo\\nick\", {bl, \"fdkj\"eck}";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// now check in actual grammar.
Grammar g = new Grammar(
@@ -154,11 +154,11 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
-            string rawTranslation = translator.translate();
+            string rawTranslation = translator.Translate();
assertEquals( expecting, rawTranslation );

assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
@@ -167,7 +167,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestBracketArgParsing() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// now check in actual grammar.
Grammar g = new Grammar(
@@ -177,9 +177,9 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
-            Rule r = g.getRule( "a" );
+            Rule r = g.GetRule( "a" );
AttributeScope parameters = r.parameterScope;
var attrs = parameters.Attributes;
assertEquals( "attribute mismatch", "String[] ick", attrs.ElementAt( 0 ).Decl.ToString() );
@@ -199,7 +199,7 @@ namespace AntlrUnitTests
string expecting = "34, '{', \"it's<\", '\"', \"\\\"\", 19";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// now check in actual grammar.
Grammar g = new Grammar(
@@ -209,11 +209,11 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
-            string rawTranslation = translator.translate();
+            string rawTranslation = translator.Translate();
assertEquals( expecting, rawTranslation );

//IList<String> expectArgs = new List<String>() {
@@ -247,7 +247,7 @@ namespace AntlrUnitTests
string expecting = "(*a).foo(21,33,\",\")";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// now check in actual grammar.
Grammar g = new Grammar(
@@ -257,11 +257,11 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
-            string rawTranslation = translator.translate();
+            string rawTranslation = translator.Translate();
assertEquals( expecting, rawTranslation );

assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
@@ -273,7 +273,7 @@ namespace AntlrUnitTests
string expecting = "34<50";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// now check in actual grammar.
Grammar g = new Grammar(
@@ -283,12 +283,12 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
assertEquals( expecting, rawTranslation );

assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
@@ -300,14 +300,14 @@ namespace AntlrUnitTests
string expecting = "foo.get(\"ick\");";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string grammar =
"parser grammar T;\n" +
"a[HashMap<String,String> foo]\n" +
"        : {" + action + "}\n" +
"        ;";
Grammar g = new Grammar( grammar );
-            Rule ra = g.getRule( "a" );
+            Rule ra = g.GetRule( "a" );
var attrs = ra.parameterScope.Attributes;
assertEquals( "attribute mismatch", "HashMap<String,String> foo", attrs.ElementAt( 0 ).Decl.ToString() );
assertEquals( "parameter name mismatch", "foo", attrs.ElementAt( 0 ).Name );
@@ -315,12 +315,12 @@ namespace AntlrUnitTests

AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -336,14 +336,14 @@ namespace AntlrUnitTests
string expecting = "foo.get(\"ick\"); x=3;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string grammar =
"parser grammar T;\n" +
"a[HashMap<String,String> foo, int x, List<String> duh]\n" +
"        : {" + action + "}\n" +
"        ;";
Grammar g = new Grammar( grammar );
-            Rule ra = g.getRule( "a" );
+            Rule ra = g.GetRule( "a" );
var attrs = ra.parameterScope.Attributes;

assertEquals( "attribute mismatch", "HashMap<String,String> foo", attrs.ElementAt( 0 ).Decl.ToString().Trim() );
@@ -360,12 +360,12 @@ namespace AntlrUnitTests

AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -378,12 +378,12 @@ namespace AntlrUnitTests
[TestMethod]
public void TestGenericsAsReturnValue() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string grammar =
"parser grammar T;\n" +
"a returns [HashMap<String,String> foo] : ;\n";
Grammar g = new Grammar( grammar );
-            Rule ra = g.getRule( "a" );
+            Rule ra = g.GetRule( "a" );
var attrs = ra.returnScope.Attributes;
assertEquals( "attribute mismatch", "HashMap<String,String> foo", attrs.ElementAt( 0 ).Decl.ToString() );
assertEquals( "parameter name mismatch", "foo", attrs.ElementAt( 0 ).Name );
@@ -399,7 +399,7 @@ namespace AntlrUnitTests
string expecting = "x, (A1!=null?A1.getText():null)+\"3242\", (*A1).foo(21,33), 3.2+1, '\\n', \"a,oo\\nick\", {bl, \"fdkj\"eck}";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// now check in actual grammar.
Grammar g = new Grammar(
@@ -409,12 +409,12 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -436,19 +436,19 @@ namespace AntlrUnitTests
string expecting = "(x!=null?x.foo:0)";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : x=b {" + action + "} ;\n" +
"b returns [int foo] : B {$b.start} ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -468,19 +468,19 @@ namespace AntlrUnitTests
string expecting = "(x!=null?input.toString(x.start,x.stop):null)";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : x=b {" + action + "} ;\n" +
"b : B ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -496,7 +496,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a[User u, int i]\n" +
@@ -508,7 +508,7 @@ namespace AntlrUnitTests
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -528,7 +528,7 @@ namespace AntlrUnitTests
string expecting = "x";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a returns [int i]\n" +
@@ -537,14 +537,14 @@ namespace AntlrUnitTests
"b : x=a {" + action + "} ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -560,7 +560,7 @@ namespace AntlrUnitTests
string expecting = "x";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a returns [int i1]\n" +
@@ -569,14 +569,14 @@ namespace AntlrUnitTests
"b : x=a {" + action + "} ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -592,7 +592,7 @@ namespace AntlrUnitTests
string expecting = "retval.i; retval.i.x; retval.u; retval.u.x";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a returns [User u, int i]\n" +
@@ -600,12 +600,12 @@ namespace AntlrUnitTests
"        ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -624,7 +624,7 @@ namespace AntlrUnitTests
string expecting2 = "obj = rule32;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"rule1 returns [ Object obj ]\n" +
@@ -639,7 +639,7 @@ namespace AntlrUnitTests
";" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
int i = 0;
string action = action1;
@@ -649,7 +649,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator( generator, "rule1",
new CommonToken( ANTLRParser.ACTION, action ), i + 1 );
string rawTranslation =
-                        translator.translate();
+                        translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -667,7 +667,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a returns [User u, int i]\n" +
@@ -678,7 +678,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -700,19 +700,19 @@ namespace AntlrUnitTests
string expecting = "id; f; (id!=null?id.getText():null); id.getText(); id.dork (id!=null?id.getType():0); (id!=null?id.getLine():0); (id!=null?id.getCharPositionInLine():0); (id!=null?id.getChannel():0); (id!=null?id.getTokenIndex():0);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : id=ID f=FLOAT {" + action + "}\n" +
"  ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -730,7 +730,7 @@ namespace AntlrUnitTests
"             (r!=null?((Object)r.tree):null); (r!=null?r.x:0); (r!=null?((Token)r.stop):null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a returns [int x]\n" +
@@ -741,7 +741,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // codegen phase sets some vars we need
StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -754,14 +754,14 @@ namespace AntlrUnitTests
[TestMethod]
public void TestAmbiguRuleRef() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : A a {$a.text} | B ;" );
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

// error(132): <string>:2:9: reference $a is ambiguous; rule a is enclosing rule and referenced in the production
@@ -774,7 +774,7 @@ namespace AntlrUnitTests
string expecting = "(r!=null?r.x:0); (r!=null?((MYTOKEN)r.start):null); (r!=null?((MYTOKEN)r.stop):null); (r!=null?((Object)r.tree):null); (r!=null?r.x:0); (r!=null?((MYTOKEN)r.stop):null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"options {TokenLabelType=MYTOKEN;}\n" +
@@ -786,7 +786,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // codegen phase sets some vars we need

StringTemplate codeST = generator.RecognizerST;
@@ -803,7 +803,7 @@ namespace AntlrUnitTests
string expecting = "(r!=null?r.x:0); (r!=null?((Token)r.start):null); (r!=null?((Token)r.stop):null); (r!=null?((Object)r.tree):null); (r!=null?r.x:0); (r!=null?((Object)r.tree):null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"b : r=a {###" + action + "!!!}\n" +
@@ -813,7 +813,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // codegen phase sets some vars we need

StringTemplate codeST = generator.RecognizerST;
@@ -830,7 +830,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a[int z] returns [int x]\n" +
@@ -843,7 +843,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -864,7 +864,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a\n" +
@@ -878,7 +878,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -899,7 +899,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a[int z] returns [int x]\n" +
@@ -912,7 +912,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -933,7 +933,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a[int z] returns [int x]\n" +
@@ -946,7 +946,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();

int expectedMsgID = ErrorManager.MSG_ISOLATED_RULE_SCOPE;
object expectedArg = "r";
@@ -962,7 +962,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a returns [int x]:\n" +
@@ -974,7 +974,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();

int expectedMsgID = ErrorManager.MSG_ISOLATED_RULE_SCOPE;
object expectedArg = "a";
@@ -989,7 +989,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"@members {'+action+'}\n" +
@@ -1000,7 +1000,7 @@ namespace AntlrUnitTests
null,
new CommonToken( ANTLRParser.ACTION, action ), 0 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1020,7 +1020,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"@members {'+action+'}\n" +
@@ -1031,7 +1031,7 @@ namespace AntlrUnitTests
null,
new CommonToken( ANTLRParser.ACTION, action ), 0 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1054,7 +1054,7 @@ namespace AntlrUnitTests
string expecting = "((Symbols_scope)Symbols_stack.peek()).names.add((id!=null?id.getText():null));";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope Symbols {\n" +
@@ -1066,12 +1066,12 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1086,7 +1086,7 @@ namespace AntlrUnitTests
string action = "$Symbols::names.add($id.text);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a scope Symbols; : (id=ID ';' {" + action + "} )+\n" +
@@ -1094,7 +1094,7 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -1115,7 +1115,7 @@ namespace AntlrUnitTests
"((Symbols_scope)Symbols_stack.elementAt(Symbols_stack.size()-1-1)).names.add((id!=null?id.getText():null));";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope Symbols {\n" +
@@ -1127,12 +1127,12 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1149,7 +1149,7 @@ namespace AntlrUnitTests
"((Symbols_scope)Symbols_stack.elementAt(0)).names.add((id!=null?id.getText():null));";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope Symbols {\n" +
@@ -1161,12 +1161,12 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
assertEquals( expecting, rawTranslation );
@@ -1181,7 +1181,7 @@ namespace AntlrUnitTests
"((Symbols_scope)Symbols_stack.elementAt(3)).names.add((id!=null?id.getText():null));";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope Symbols {\n" +
@@ -1193,12 +1193,12 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
assertEquals( expecting, rawTranslation );
@@ -1212,7 +1212,7 @@ namespace AntlrUnitTests
string expecting = "((foo_bar_scope)foo_bar_stack.peek()).a_b;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope foo_bar {\n" +
@@ -1223,12 +1223,12 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1245,7 +1245,7 @@ namespace AntlrUnitTests
string expecting = "((Symbols_scope)Symbols_stack.peek()).x;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope Symbols {\n" +
@@ -1260,12 +1260,12 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1281,7 +1281,7 @@ namespace AntlrUnitTests
string expecting = "public void foo() {((Symbols_scope)Symbols_stack.peek()).names.add('foo');}";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope Symbols {\n" +
@@ -1293,12 +1293,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1314,7 +1314,7 @@ namespace AntlrUnitTests
string expecting = "public void foo() {((a_scope)a_stack.peek()).name;}";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"@members {" + action + "}\n" +
@@ -1324,13 +1324,13 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
null,
new CommonToken( ANTLRParser.ACTION, action ), 0 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1346,7 +1346,7 @@ namespace AntlrUnitTests
string expecting = "((a_scope)a_stack.peek()).n;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a\n" +
@@ -1356,12 +1356,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1377,7 +1377,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a\n" +
@@ -1387,7 +1387,7 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_ISOLATED_RULE_ATTRIBUTE;
@@ -1405,7 +1405,7 @@ namespace AntlrUnitTests
string expecting = "a_stack;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a\n" +
@@ -1416,12 +1416,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1437,7 +1437,7 @@ namespace AntlrUnitTests
string expecting = "((a_scope)a_stack.peek()).n;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a\n" +
@@ -1448,12 +1448,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1469,7 +1469,7 @@ namespace AntlrUnitTests
string expecting = "Symbols_stack;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope Symbols {\n" +
@@ -1484,12 +1484,12 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1505,7 +1505,7 @@ namespace AntlrUnitTests
string expecting = "((a_scope)a_stack.peek()).n;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a\n" +
@@ -1517,12 +1517,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1538,19 +1538,19 @@ namespace AntlrUnitTests
string expecting = "i;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a[int i]: {" + action + "}\n" +
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1566,19 +1566,19 @@ namespace AntlrUnitTests
string expecting = "retval.i;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a returns [int i, int j]: {" + action + "}\n" +
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1594,19 +1594,19 @@ namespace AntlrUnitTests
string expecting = "retval.i = 1;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a returns [int i, int j]: {" + action + "}\n" +
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1622,14 +1622,14 @@ namespace AntlrUnitTests
//String expecting = "";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : 'a' {" + action + "}\n" +
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_ISOLATED_RULE_SCOPE;
@@ -1646,7 +1646,7 @@ namespace AntlrUnitTests
string action = "$x;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : x=b {" + action + "}\n" +
@@ -1654,7 +1654,7 @@ namespace AntlrUnitTests
"b : 'b' ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_ISOLATED_RULE_SCOPE;
@@ -1684,7 +1684,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator(generator,"a",
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
-                    translator.translate();
+                    translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup(".", typeof(AngleBracketTemplateLexer));
StringTemplate actionST = new StringTemplate(templates, rawTranslation);
@@ -1713,7 +1713,7 @@ namespace AntlrUnitTests
ActionTranslator translator = new ActionTranslator(generator,"a",
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup(".", typeof(AngleBracketTemplateLexer));
StringTemplate actionST = new StringTemplate(templates, rawTranslation);
@@ -1729,7 +1729,7 @@ namespace AntlrUnitTests
string expecting = "retval.st;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"options {output=template;}\n" +
@@ -1737,12 +1737,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1758,7 +1758,7 @@ namespace AntlrUnitTests
string expecting = "(b1!=null?((Token)b1.start):null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : b {###" + action + "!!!} ;\n" +
@@ -1769,7 +1769,7 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates

StringTemplate codeST = generator.RecognizerST;
@@ -1786,7 +1786,7 @@ namespace AntlrUnitTests
string expecting = "((b_scope)b_stack.peek()).n;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"s : b ;\n" +
@@ -1797,12 +1797,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1818,7 +1818,7 @@ namespace AntlrUnitTests
string expecting = "retval.st =null;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"options {output=template;}\n" +
@@ -1826,12 +1826,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1847,7 +1847,7 @@ namespace AntlrUnitTests
string expecting = "input.toString(retval.start,input.LT(-1))";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"options {output=template;}\n" +
@@ -1855,12 +1855,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1876,14 +1876,14 @@ namespace AntlrUnitTests
string expecting = "((Token)retval.start);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : {###" + action + "!!!}\n" +
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -1903,7 +1903,7 @@ namespace AntlrUnitTests
string expecting2 = "(INT2!=null?INT2.getText():null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ID {" + action + "}\n" +
@@ -1913,12 +1913,12 @@ namespace AntlrUnitTests
"INT : '0';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1930,7 +1930,7 @@ namespace AntlrUnitTests
"a",
new CommonToken( ANTLRParser.ACTION, action2 ), 2 );
rawTranslation =
-                translator.translate();
+                translator.Translate();
templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
actionST = new StringTemplate( templates, rawTranslation );
@@ -1949,7 +1949,7 @@ namespace AntlrUnitTests
string expecting2 = "(c2!=null?input.toString(c2.start,c2.stop):null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : b {" + action + "}\n" +
@@ -1959,12 +1959,12 @@ namespace AntlrUnitTests
"c : '0';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -1976,7 +1976,7 @@ namespace AntlrUnitTests
"a",
new CommonToken( ANTLRParser.ACTION, action2 ), 2 );
rawTranslation =
-                translator.translate();
+                translator.Translate();
templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
actionST = new StringTemplate( templates, rawTranslation );
@@ -1993,7 +1993,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a\n" +
@@ -2003,14 +2003,14 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2031,7 +2031,7 @@ namespace AntlrUnitTests
string expecting = action;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"scope Symbols {\n" +
@@ -2041,14 +2041,14 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2069,7 +2069,7 @@ namespace AntlrUnitTests
string expecting = "$n;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a\n" +
@@ -2086,7 +2086,7 @@ namespace AntlrUnitTests
"b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2104,7 +2104,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRuleAndTokenLabelTypeMismatch() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : id='foo' id=b\n" +
@@ -2121,7 +2121,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestListAndTokenLabelTypeMismatch() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ids+='a' ids='b'\n" +
@@ -2138,7 +2138,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestListAndRuleLabelTypeMismatch() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {output=AST;}\n" +
@@ -2156,7 +2156,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestArgReturnValueMismatch() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a[int i] returns [int x, int i]\n" +
@@ -2177,20 +2177,20 @@ namespace AntlrUnitTests
string expecting = "list_ids.size();";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : ids+=ID ( COMMA ids+=ID {" + action + "})* ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2206,21 +2206,21 @@ namespace AntlrUnitTests
string expecting = "list_ids.size();";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ids+='if' ( ',' ids+=ID {" + action + "})* ;" +
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2236,21 +2236,21 @@ namespace AntlrUnitTests
string expecting = "list_ids.size();";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ids+=('a'|'b') ( ',' ids+=ID {" + action + "})* ;" +
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2266,7 +2266,7 @@ namespace AntlrUnitTests
string expecting = "list_ids.size();";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ids+=. ( ',' ids+=ID {" + action + "})* ;" +
@@ -2277,10 +2277,10 @@ namespace AntlrUnitTests
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2296,7 +2296,7 @@ namespace AntlrUnitTests
string expecting = "ID1; (ID1!=null?ID1.getText():null); ID1.getText()";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ID {" + action + "} ;" +
@@ -2309,10 +2309,10 @@ namespace AntlrUnitTests
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2328,7 +2328,7 @@ namespace AntlrUnitTests
string expecting = "(r1!=null?((Token)r1.start):null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : r {###" + action + "!!!} ;" +
@@ -2336,7 +2336,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

StringTemplate codeST = generator.RecognizerST;
@@ -2353,7 +2353,7 @@ namespace AntlrUnitTests
string expecting = "(x!=null?((Token)x.start):null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : x=r {###" + action + "!!!} ;" +
@@ -2361,7 +2361,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

StringTemplate codeST = generator.RecognizerST;
@@ -2378,7 +2378,7 @@ namespace AntlrUnitTests
string expecting = "(x!=null?((Token)x.start):null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {output=AST;}\n" +
@@ -2387,7 +2387,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

StringTemplate codeST = generator.RecognizerST;
@@ -2404,7 +2404,7 @@ namespace AntlrUnitTests
string expecting = "(x!=null?x.getText():null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : x=ID {" + action + "} ;" +
@@ -2412,13 +2412,13 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2434,7 +2434,7 @@ namespace AntlrUnitTests
string expecting = "(x!=null?x.getText():null);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : x+=ID {" + action + "} ;" +
@@ -2442,13 +2442,13 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2461,7 +2461,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRuleLabelWithoutOutputOption() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar T;\n" +
"s : x+=a ;" +
@@ -2471,7 +2471,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT;
@@ -2517,7 +2517,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestMissingArgs() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : r ;" +
@@ -2525,7 +2525,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_MISSING_RULE_ARGS;
@@ -2539,7 +2539,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestArgsWhenNoneDefined() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : r[32,34] ;" +
@@ -2547,7 +2547,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_RULE_HAS_NO_ARGS;
@@ -2561,14 +2561,14 @@ namespace AntlrUnitTests
[TestMethod]
public void TestReturnInitValue() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : r ;\n" +
"r returns [int x=0] : 'a' {$x = 4;} ;\n" );
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );

-            Rule r = g.getRule( "r" );
+            Rule r = g.GetRule( "r" );
AttributeScope retScope = r.returnScope;
var parameters = retScope.Attributes;
assertNotNull( "missing return action", parameters );
@@ -2581,14 +2581,14 @@ namespace AntlrUnitTests
[TestMethod]
public void TestMultipleReturnInitValue() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : r ;\n" +
"r returns [int x=0, int y, String s=new String(\"foo\")] : 'a' {$x = 4;} ;\n" );
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );

-            Rule r = g.getRule( "r" );
+            Rule r = g.GetRule( "r" );
AttributeScope retScope = r.returnScope;
var parameters = retScope.Attributes;
assertNotNull( "missing return action", parameters );
@@ -2601,14 +2601,14 @@ namespace AntlrUnitTests
[TestMethod]
public void TestCStyleReturnInitValue() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : r ;\n" +
"r returns [int (*x)()=NULL] : 'a' ;\n" );
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );

-            Rule r = g.getRule( "r" );
+            Rule r = g.GetRule( "r" );
AttributeScope retScope = r.returnScope;
var parameters = retScope.Attributes;
assertNotNull( "missing return action", parameters );
@@ -2621,7 +2621,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestArgsWithInitValues() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : r[32,34] ;" +
@@ -2629,7 +2629,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_ARG_INIT_VALUES_ILLEGAL;
@@ -2643,7 +2643,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestArgsOnToken() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ID[32,34] ;" +
@@ -2651,7 +2651,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_ARGS_ON_TOKEN_REF;
@@ -2665,7 +2665,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestArgsOnTokenInLexer() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : 'z' ID[32,34] ;" +
@@ -2673,7 +2673,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_RULE_HAS_NO_ARGS;
@@ -2689,21 +2689,21 @@ namespace AntlrUnitTests
string action = "$i.text";
string expecting = "(i!=null?i.getText():null)";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : 'z' i=ID {" + action + "};" +
"fragment ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2719,21 +2719,21 @@ namespace AntlrUnitTests
string action = "$ID.text";
string expecting = "(ID1!=null?ID1.getText():null)";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : 'z' ID {" + action + "};" +
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2749,21 +2749,21 @@ namespace AntlrUnitTests
string action = "$ID";
string expecting = "ID1";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : 'z' ID {" + action + "};" +
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2777,14 +2777,14 @@ namespace AntlrUnitTests
[TestMethod]
public void TestCharLabelInLexer() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : x='z' ;\n" );

AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates

assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
@@ -2793,14 +2793,14 @@ namespace AntlrUnitTests
[TestMethod]
public void TestCharListLabelInLexer() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : x+='z' ;\n" );

AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
}
@@ -2808,14 +2808,14 @@ namespace AntlrUnitTests
[TestMethod]
public void TestWildcardCharLabelInLexer() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : x=. ;\n" );

AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
}
@@ -2823,14 +2823,14 @@ namespace AntlrUnitTests
[TestMethod]
public void TestWildcardCharListLabelInLexer() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : x+=. ;\n" );

AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
}
@@ -2838,7 +2838,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestMissingArgsInLexer() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"A : R ;" +
@@ -2846,7 +2846,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_MISSING_RULE_ARGS;
@@ -2863,20 +2863,20 @@ namespace AntlrUnitTests
string action = "$text $type $line $pos $channel $index $start $stop";
string expecting = "getText() _type state.tokenStartLine state.tokenStartCharPositionInLine _channel -1 state.tokenStartCharIndex (getCharIndex()-1)";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : 'r' {" + action + "};\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2892,21 +2892,21 @@ namespace AntlrUnitTests
string action = "$a $b.text $c $d.text";
string expecting = "a (b!=null?b.getText():null) c (d!=null?d.getText():null)";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : a='c' b='hi' c=. d=DUH {" + action + "};\n" +
"DUH : 'd' ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2922,20 +2922,20 @@ namespace AntlrUnitTests
string action = "$text $type=1 $line=1 $pos=1 $channel=1 $index";
string expecting = "getText() _type=1 state.tokenStartLine=1 state.tokenStartCharPositionInLine=1 _channel=1 -1";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar t;\n" +
"R : 'r' {" + action + "};\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -2949,27 +2949,27 @@ namespace AntlrUnitTests
[TestMethod]
public void TestArgsOnTokenInLexerRuleOfCombined() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : R;\n" +
"R : 'z' ID[32] ;\n" +
"ID : 'a';\n" );

-            string lexerGrammarStr = g.getLexerGrammar();
+            string lexerGrammarStr = g.GetLexerGrammar();
System.IO.StringReader sr = new System.IO.StringReader( lexerGrammarStr );
Grammar lexerGrammar = new Grammar();
lexerGrammar.FileName = "<internally-generated-lexer>";
-            lexerGrammar.importTokenVocabulary( g );
-            lexerGrammar.parseAndBuildAST( sr );
-            lexerGrammar.defineGrammarSymbols();
-            lexerGrammar.checkNameSpaceAndActions();
+            lexerGrammar.ImportTokenVocabulary( g );
+            lexerGrammar.ParseAndBuildAST( sr );
+            lexerGrammar.DefineGrammarSymbols();
+            lexerGrammar.CheckNameSpaceAndActions();
sr.Close();

AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, lexerGrammar, "Java" );
-            lexerGrammar.setCodeGenerator( generator );
+            lexerGrammar.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_RULE_HAS_NO_ARGS;
@@ -2983,27 +2983,27 @@ namespace AntlrUnitTests
[TestMethod]
public void TestMissingArgsOnTokenInLexerRuleOfCombined() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : R;\n" +
"R : 'z' ID ;\n" +
"ID[int i] : 'a';\n" );

-            string lexerGrammarStr = g.getLexerGrammar();
+            string lexerGrammarStr = g.GetLexerGrammar();
StringReader sr = new StringReader( lexerGrammarStr );
Grammar lexerGrammar = new Grammar();
lexerGrammar.FileName = "<internally-generated-lexer>";
-            lexerGrammar.importTokenVocabulary( g );
-            lexerGrammar.parseAndBuildAST( sr );
-            lexerGrammar.defineGrammarSymbols();
-            lexerGrammar.checkNameSpaceAndActions();
+            lexerGrammar.ImportTokenVocabulary( g );
+            lexerGrammar.ParseAndBuildAST( sr );
+            lexerGrammar.DefineGrammarSymbols();
+            lexerGrammar.CheckNameSpaceAndActions();
sr.Close();

AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, lexerGrammar, "Java" );
-            lexerGrammar.setCodeGenerator( generator );
+            lexerGrammar.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_MISSING_RULE_ARGS;
@@ -3022,7 +3022,7 @@ namespace AntlrUnitTests
string expecting = "id_tree;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : id=ID {" + action + "} ;\n" +
@@ -3035,10 +3035,10 @@ namespace AntlrUnitTests
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -3054,7 +3054,7 @@ namespace AntlrUnitTests
string expecting = "ID1_tree;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ID {" + action + "} ;" +
@@ -3062,13 +3062,13 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -3082,7 +3082,7 @@ namespace AntlrUnitTests
//String expecting = "";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ID ID {" + action + "};" +
@@ -3090,7 +3090,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_NONUNIQUE_REF;
@@ -3106,7 +3106,7 @@ namespace AntlrUnitTests
//String expecting = "";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"a : ID ID {" + action + "};" +
@@ -3114,7 +3114,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_NONUNIQUE_REF;
@@ -3130,7 +3130,7 @@ namespace AntlrUnitTests
string expecting = "((field_scope)field_stack.peek()).x = retval.st;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"field\n" +
@@ -3139,13 +3139,13 @@ namespace AntlrUnitTests
"    ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"field",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -3160,7 +3160,7 @@ namespace AntlrUnitTests
string action = "$rule.tree = null;";
string expecting = "retval.tree = null;";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"rule\n" +
@@ -3168,13 +3168,13 @@ namespace AntlrUnitTests
"    ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -3189,7 +3189,7 @@ namespace AntlrUnitTests
string action = "$rule.i = 42; $i = 23;";
string expecting = "i = 42; i = 23;";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"rule[int i]\n" +
@@ -3197,13 +3197,13 @@ namespace AntlrUnitTests
"    ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -3217,7 +3217,7 @@ namespace AntlrUnitTests
public void TestIllegalAssignToOwnRulenameAttr() /*throws Exception*/ {
string action = "$rule.stop = 0;";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"rule\n" +
@@ -3225,13 +3225,13 @@ namespace AntlrUnitTests
"    ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();

int expectedMsgID = ErrorManager.MSG_WRITE_TO_READONLY_ATTR;
object expectedArg = "rule";
@@ -3246,7 +3246,7 @@ namespace AntlrUnitTests
string action = "$tree = null; $st = null; $start = 0; $stop = 0; $text = 0;";
string expecting = "retval.tree = null; retval.st = null;   ";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"rule\n" +
@@ -3254,13 +3254,13 @@ namespace AntlrUnitTests
"    ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();

int expectedMsgID = ErrorManager.MSG_WRITE_TO_READONLY_ATTR;
var expectedErrors = new List<object>( 3 );
@@ -3286,7 +3286,7 @@ namespace AntlrUnitTests
public void TestIllegalAssignRuleRefAttr() /*throws Exception*/ {
string action = "$other.tree = null;";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"options { output = AST;}" +
@@ -3297,13 +3297,13 @@ namespace AntlrUnitTests
"    ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();

int expectedMsgID = ErrorManager.MSG_WRITE_TO_READONLY_ATTR;
object expectedArg = "other";
@@ -3317,7 +3317,7 @@ namespace AntlrUnitTests
public void TestIllegalAssignTokenRefAttr() /*throws Exception*/ {
string action = "$ID.text = \"test\";";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"ID\n" +
@@ -3327,13 +3327,13 @@ namespace AntlrUnitTests
"    ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();

int expectedMsgID = ErrorManager.MSG_WRITE_TO_READONLY_ATTR;
object expectedArg = "ID";
@@ -3348,7 +3348,7 @@ namespace AntlrUnitTests
string action = "$tree.scope = localScope;";
string expecting = "(()retval.tree).scope = localScope;";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"options { output=AST; }" +
@@ -3363,13 +3363,13 @@ namespace AntlrUnitTests
";" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -3383,7 +3383,7 @@ namespace AntlrUnitTests
string action = "$a.line == $b.line";
string expecting = "(a!=null?a.getLine():0) == (b!=null?b.getLine():0)";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"lexer grammar a;\n" +
"RULE:\n" +
@@ -3393,13 +3393,13 @@ namespace AntlrUnitTests
);
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();
ActionTranslator translator = new ActionTranslator( generator,
"RULE",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -3413,7 +3413,7 @@ namespace AntlrUnitTests
string action = "if ($rule::foo == \"foo\" || 1) { System.out.println(\"ouch\"); }";
string expecting = "if (((rule_scope)rule_stack.peek()).foo == \"foo\" || 1) { System.out.println(\"ouch\"); }";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"rule\n" +
@@ -3429,13 +3429,13 @@ namespace AntlrUnitTests
);
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();
ActionTranslator translator = new ActionTranslator( generator,
"twoIDs",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
// check that we didn't use scopeSetAttributeRef int translation!
bool foundScopeSetAttributeRef = false;
for ( int i = 0; i < translator.chunks.Count; i++ )
@@ -3464,7 +3464,7 @@ namespace AntlrUnitTests
string expecting = "(r!=null?r.x:0); (r!=null?((CommonTree)r.start):null); $r.stop";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"tree grammar t;\n" +
"options {ASTLabelType=CommonTree;}\n" +
@@ -3476,7 +3476,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // codegen phase sets some vars we need
StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -3500,7 +3500,7 @@ namespace AntlrUnitTests
"              input.getTreeAdaptor().getTokenStopIndex(retval.start))";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"tree grammar t;\n" +
"options {ASTLabelType=CommonTree;}\n" +
@@ -3510,7 +3510,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // codegen phase sets some vars we need
StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -3526,7 +3526,7 @@ namespace AntlrUnitTests
string expecting = "int x = ((b_scope)b_stack.peek()).n;";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"s : b ;\n" +
@@ -3537,12 +3537,12 @@ namespace AntlrUnitTests
"  ;\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
diff --git a/Antlr3.Test/TestCharDFAConversion.cs b/Antlr3.Test/TestCharDFAConversion.cs
index 27c3475..8e57894 100644
--- a/Antlr3.Test/TestCharDFAConversion.cs
+++ b/Antlr3.Test/TestCharDFAConversion.cs
@@ -58,7 +58,7 @@ namespace AntlrUnitTests
Grammar g = new Grammar(
"lexer grammar t;\n" +
"A : 'a'..'z' '@' | 'k' '$' ;" );
-            g.createLookaheadDFAs();
+            g.CreateLookaheadDFAs();
string expecting =
".s0-'k'->.s1\n" +
".s0-{'a'..'j', 'l'..'z'}->:s2=>1\n" +
@@ -74,7 +74,7 @@ namespace AntlrUnitTests
"A : 'a'..'z' '@'\n" +
"  | ('k'|'9'|'p') '$'\n" +
"  ;\n" );
-            g.createLookaheadDFAs();
+            g.CreateLookaheadDFAs();
// must break up a..z into {'a'..'j', 'l'..'o', 'q'..'z'}
string expecting =
".s0-'9'->:s3=>2\n" +
@@ -92,7 +92,7 @@ namespace AntlrUnitTests
"A : ('a'..'z'|'0'..'9') '@'\n" +
"  | ('k'|'9'|'p') '$'\n" +
"  ;\n" );
-            g.createLookaheadDFAs( false );
+            g.CreateLookaheadDFAs( false );
// must break up a..z into {'a'..'j', 'l'..'o', 'q'..'z'} and 0..9
// into 0..8
string expecting =
@@ -178,7 +178,7 @@ namespace AntlrUnitTests
".s1-<EOT>->:s2=>1\n";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

checkDecision( g, 1, expecting, new int[] { 2 } );

@@ -240,8 +240,8 @@ namespace AntlrUnitTests
DFAOptimizer optimizer = new DFAOptimizer( g );
optimizer.Optimize();
FASerializer serializer = new FASerializer( g );
-            DFA dfa = g.getLookaheadDFA( 1 );
-            string result = serializer.serialize( dfa.startState );
+            DFA dfa = g.GetLookaheadDFA( 1 );
+            string result = serializer.Serialize( dfa.startState );
expecting = ".s0-'x'->:s1=>1\n";
assertEquals( expecting, result );
}
@@ -371,7 +371,7 @@ namespace AntlrUnitTests
":s0=>2\n";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

checkDecision( g, 1, expecting, new int[] { 1 } );

@@ -399,7 +399,7 @@ namespace AntlrUnitTests
"        ;\n" +
"fragment\n" +
"ESC     :       '\\\\' . ;" );
-            g.createLookaheadDFAs();
+            g.CreateLookaheadDFAs();
string expecting =
".s0-'\\\\'->:s2=>2\n" +
".s0-'{'->:s1=>1\n" +
@@ -424,7 +424,7 @@ namespace AntlrUnitTests
"        ;\n" +
"fragment\n" +
"ESC     :       '\\\\' . ;" );
-            g.createLookaheadDFAs();
+            g.CreateLookaheadDFAs();
string expecting =
".s0-'\\\\'->.s3\n" +
".s0-'{'->:s2=>1\n" +
@@ -445,7 +445,7 @@ namespace AntlrUnitTests
"lexer grammar T;\n" +
"A : 'a' | ~B {;} ;\n" +
"fragment B : 'a' ;\n" );
-            g.createLookaheadDFAs();
+            g.CreateLookaheadDFAs();
string expecting =
".s0-'a'->:s1=>1\n" +
".s0-{'\\u0000'..'`', 'b'..'\\uFFFF'}->:s2=>2\n";
@@ -458,7 +458,7 @@ namespace AntlrUnitTests
"lexer grammar T;\n" +
"A : B | ~B {;} ;\n" +
"fragment B : 'a'|'b' ;\n" );
-            g.createLookaheadDFAs();
+            g.CreateLookaheadDFAs();
string expecting =
".s0-'a'..'b'->:s1=>1\n" +
".s0-{'\\u0000'..'`', 'c'..'\\uFFFF'}->:s2=>2\n";
@@ -471,7 +471,7 @@ namespace AntlrUnitTests
"lexer grammar T;\n" +
"A : 'x' ('a' | ~B {;}) ;\n" +
"B : 'a' ;\n" );
-            g.createLookaheadDFAs();
+            g.CreateLookaheadDFAs();
string expecting =
".s0-'a'->:s1=>1\n" +
".s0-{'\\u0000'..'`', 'b'..'\\uFFFF'}->:s2=>2\n";
@@ -556,15 +556,15 @@ namespace AntlrUnitTests
if ( g.CodeGenerator == null )
{
CodeGenerator generator = new CodeGenerator( null, g, "Java" );
-                g.setCodeGenerator( generator );
-                g.buildNFA();
-                g.createLookaheadDFAs( false );
+                g.CodeGenerator = generator;
+                g.BuildNFA();
+                g.CreateLookaheadDFAs( false );
}

-            DFA dfa = g.getLookaheadDFA( decision );
+            DFA dfa = g.GetLookaheadDFA( decision );
assertNotNull( "unknown decision #" + decision, dfa );
FASerializer serializer = new FASerializer( g );
-            string result = serializer.serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.startState );
//System.out.print(result);
var nonDetAlts = dfa.UnreachableAlts;
//System.out.println("alts w/o predict state="+nonDetAlts);
diff --git a/Antlr3.Test/TestCompositeGrammars.cs b/Antlr3.Test/TestCompositeGrammars.cs
index 0884ec8..1ea1e74 100644
--- a/Antlr3.Test/TestCompositeGrammars.cs
+++ b/Antlr3.Test/TestCompositeGrammars.cs
@@ -46,7 +46,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestWildcardStillWorks() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string grammar =
"parser grammar S;\n" +
"a : B . C ;\n"; // not qualified ID
@@ -199,7 +199,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestDelegatesSeeSameTokenType2() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar S;\n" + // A, B, C token type order
"tokens { A; B; C; }\n" +
@@ -225,9 +225,9 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

string expectedTokenIDToTypeMap = "[A=4, B=5, C=6, WS=7]";
string expectedStringLiteralToTypeMap = "{}";
@@ -247,7 +247,7 @@ namespace AntlrUnitTests
//Assert.Inconclusive( "May be failing on just my port..." );
// for now, we don't allow combined to import combined
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"grammar S;\n" + // A, B, C token type order
"tokens { A; B; C; }\n" +
@@ -265,9 +265,9 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

assertEquals( "unexpected errors: " + equeue, 1, equeue.errors.Count );
string expectedError = "error(161): " + tmpdir.ToString().replaceFirst( "\\-[0-9]+", "" ) + "/M.g:2:8: combined grammar M cannot import combined grammar S";
@@ -278,7 +278,7 @@ namespace AntlrUnitTests
public void TestSameStringTwoNames() /*throws Exception*/ {
Assert.Inconclusive( "May be failing on just my port..." );
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar S;\n" +
"tokens { A='a'; }\n" +
@@ -301,9 +301,9 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

string expectedTokenIDToTypeMap = "[A=4, WS=6, X=5]";
string expectedStringLiteralToTypeMap = "{'a'=4}";
@@ -333,7 +333,7 @@ namespace AntlrUnitTests
public void TestSameNameTwoStrings() /*throws Exception*/ {
Assert.Inconclusive( "May be failing on just my port..." );
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar S;\n" +
"tokens { A='a'; }\n" +
@@ -355,9 +355,9 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

string expectedTokenIDToTypeMap = "[A=4, T__6=6, WS=5]";
string expectedStringLiteralToTypeMap = "{'a'=4, 'x'=6}";
@@ -386,7 +386,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestImportedTokenVocabIgnoredWithWarning() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar S;\n" +
"options {tokenVocab=whatever;}\n" +
@@ -404,9 +404,9 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

object expectedArg = "S";
int expectedMsgID = ErrorManager.MSG_TOKEN_VOCAB_IN_DELEGATE;
@@ -426,7 +426,7 @@ namespace AntlrUnitTests
public void TestImportedTokenVocabWorksInRoot() /*throws Exception*/ {
Assert.Inconclusive( "May be failing on just my port..." );
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar S;\n" +
"tokens { A='a'; }\n" +
@@ -448,9 +448,9 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

string expectedTokenIDToTypeMap = "[A=99, WS=101]";
string expectedStringLiteralToTypeMap = "{'a'=100}";
@@ -468,7 +468,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestSyntaxErrorsInImportsNotThrownOut() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar S;\n" +
"options {toke\n";
@@ -484,9 +484,9 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

// whole bunch of errors from bad S.g file
assertEquals( "unexpected errors: " + equeue, 5, equeue.errors.Count );
@@ -495,7 +495,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestSyntaxErrorsInImportsNotThrownOut2() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar S;\n" +
": A {System.out.println(\"S.x\");} ;\n";
@@ -511,9 +511,9 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

// whole bunch of errors from bad S.g file
assertEquals( "unexpected errors: " + equeue, 3, equeue.errors.Count );
@@ -618,25 +618,25 @@ namespace AntlrUnitTests
writeFile( tmpdir, "M.g", master );

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            composite.assignTokenTypes();
-            composite.defineGrammarSymbols();
-            composite.createNFAs();
-            g.createLookaheadDFAs( false );
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            composite.AssignTokenTypes();
+            composite.DefineGrammarSymbols();
+            composite.CreateNFAs();
+            g.CreateLookaheadDFAs( false );

// predict only alts from M not S
string expectingDFA =
".s0-'a'->.s1\n" +
".s0-{'\\n', ' '}->:s3=>2\n" +
".s1-<EOT>->:s2=>1\n";
-            Antlr3.Analysis.DFA dfa = g.getLookaheadDFA( 1 );
+            Antlr3.Analysis.DFA dfa = g.GetLookaheadDFA( 1 );
FASerializer serializer = new FASerializer( g );
-            string result = serializer.serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.startState );
assertEquals( expectingDFA, result );

// must not be a "unreachable alt: Tokens" error
@@ -659,12 +659,12 @@ namespace AntlrUnitTests
writeFile( tmpdir, "M.g", master );

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, System.IO.Path.Combine( tmpdir, "M.g" ), composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();

assertEquals( "unexpected errors: " + equeue, 1, equeue.errors.Count );
assertEquals( "unexpected errors: " + equeue, 0, equeue.warnings.Count );
@@ -702,7 +702,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestKeywordVSIDGivesNoWarning() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"lexer grammar S;\n" +
"A : 'abc' {System.out.println(\"S.A\");} ;\n" +
@@ -726,7 +726,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestWarningForUndefinedToken() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"lexer grammar S;\n" +
"A : 'abc' {System.out.println(\"S.A\");} ;\n";
@@ -753,7 +753,7 @@ namespace AntlrUnitTests
[TestMethod]
public void Test3LevelImport() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar T;\n" +
"a : T ;\n";
@@ -774,10 +774,10 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
-            g.composite.defineGrammarSymbols();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();
+            g.composite.DefineGrammarSymbols();

string expectedTokenIDToTypeMap = "[M=6, S=5, T=4]";
string expectedStringLiteralToTypeMap = "{}";
@@ -800,7 +800,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestBigTreeOfImports() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar T;\n" +
"x : T ;\n";
@@ -838,10 +838,10 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
-            g.composite.defineGrammarSymbols();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();
+            g.composite.DefineGrammarSymbols();

string expectedTokenIDToTypeMap = "[A=8, B=6, C=7, M=9, S=5, T=4]";
string expectedStringLiteralToTypeMap = "{}";
@@ -864,7 +864,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRulesVisibleThroughMultilevelImport() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string slave =
"parser grammar T;\n" +
"x : T ;\n";
@@ -885,10 +885,10 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/M.g", composite );
-            composite.setDelegationRoot( g );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
-            g.composite.defineGrammarSymbols();
+            composite.SetDelegationRoot( g );
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();
+            g.composite.DefineGrammarSymbols();

string expectedTokenIDToTypeMap = "[M=6, S=5, T=4]";
string expectedStringLiteralToTypeMap = "{}";
diff --git a/Antlr3.Test/TestDFAConversion.cs b/Antlr3.Test/TestDFAConversion.cs
index 098c924..20f1fee 100644
--- a/Antlr3.Test/TestDFAConversion.cs
+++ b/Antlr3.Test/TestDFAConversion.cs
@@ -539,9 +539,9 @@ namespace AntlrUnitTests

DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

-            HashSet<Rule> leftRecursive = g.getLeftRecursiveRules();
+            HashSet<Rule> leftRecursive = g.GetLeftRecursiveRules();
//Set expectedRules =
//    new HashSet() {{add("a"); add("b");}};
var expectedRules = new HashSet<string>();
@@ -550,7 +550,7 @@ namespace AntlrUnitTests

assertTrue( expectedRules.SequenceEqual( ruleNames( leftRecursive ) ) );

-            g.createLookaheadDFAs( false );
+            g.CreateLookaheadDFAs( false );

Message msg = (Message)equeue.warnings[0];
assertTrue( "expecting left recursion cycles; found " + msg.GetType().Name,
@@ -576,9 +576,9 @@ namespace AntlrUnitTests

DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

-            var leftRecursive = g.getLeftRecursiveRules();
+            var leftRecursive = g.GetLeftRecursiveRules();
//Set expectedRules =
//    new HashSet() {{add("a"); add("b");}};
var expectedRules = new HashSet<string>();
@@ -586,7 +586,7 @@ namespace AntlrUnitTests
expectedRules.Add( "b" );
assertTrue( expectedRules.SequenceEqual( ruleNames( leftRecursive ) ) );

-            g.createLookaheadDFAs( false );
+            g.CreateLookaheadDFAs( false );

Message msg = (Message)equeue.warnings[0];
assertTrue( "expecting left recursion cycles; found " + msg.GetType().Name,
@@ -616,9 +616,9 @@ namespace AntlrUnitTests

DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

-            var leftRecursive = g.getLeftRecursiveRules();
+            var leftRecursive = g.GetLeftRecursiveRules();
var expectedRules = new HashSet<string>() { "a", "b", "d", "e" };

assertTrue( expectedRules.SequenceEqual( ruleNames( leftRecursive ) ) );
@@ -760,7 +760,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestNoStartRule() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : A a | X;" ); // single rule 'a' refers to itself; no start rule
@@ -768,7 +768,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

Message msg = (Message)equeue.warnings[0];
@@ -801,7 +801,7 @@ namespace AntlrUnitTests
"parser grammar t;\n" +
"s : a ;\n" +
"a : a A | B;" );
-            var leftRecursive = g.getLeftRecursiveRules();
+            var leftRecursive = g.GetLeftRecursiveRules();
//Set expectedRules = new HashSet() {{add("a");}};
var expectedRules = new HashSet<string>();
expectedRules.Add( "a" );
@@ -816,7 +816,7 @@ namespace AntlrUnitTests
"a : b | A ;\n" +
"b : c ;\n" +
"c : a | C ;\n" );
-            var leftRecursive = g.getLeftRecursiveRules();
+            var leftRecursive = g.GetLeftRecursiveRules();
//Set expectedRules = new HashSet() {{add("a"); add("b"); add("c");}};
var expectedRules = new HashSet<string>();
expectedRules.Add( "a" );
@@ -835,7 +835,7 @@ namespace AntlrUnitTests
"c : a | C ;\n" +
"x : y | X ;\n" +
"y : x ;\n" );
-            var leftRecursive = g.getLeftRecursiveRules();
+            var leftRecursive = g.GetLeftRecursiveRules();
//Set expectedRules =
//    new HashSet() {{add("a"); add("b"); add("c"); add("x"); add("y");}};
var expectedRules = new HashSet<string>();
@@ -855,7 +855,7 @@ namespace AntlrUnitTests
"a : (A|)+ B;\n" );
// before I added a visitedStates thing, it was possible to loop
// forever inside of a rule if there was an epsilon loop.
-            var leftRecursive = g.getLeftRecursiveRules();
+            var leftRecursive = g.GetLeftRecursiveRules();
var expectedRules = new HashSet<Rule>();
assertTrue( expectedRules.SequenceEqual( leftRecursive ) );
}
@@ -1530,13 +1530,13 @@ namespace AntlrUnitTests
{
DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// mimic actions of org.antlr.Tool first time for grammar g
if ( g.NumberOfDecisions == 0 )
{
-                g.buildNFA();
-                g.createLookaheadDFAs( false );
+                g.BuildNFA();
+                g.CreateLookaheadDFAs( false );
}
NonRegularDecisionMessage msg = getNonRegularDecisionMessage( equeue.errors );
assertTrue( "expected fatal non-LL(*) msg", msg != null );
@@ -1554,13 +1554,13 @@ namespace AntlrUnitTests
{
DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// mimic actions of org.antlr.Tool first time for grammar g
if ( g.NumberOfDecisions == 0 )
{
-                g.buildNFA();
-                g.createLookaheadDFAs( false );
+                g.BuildNFA();
+                g.CreateLookaheadDFAs( false );
}
RecursionOverflowMessage msg = getRecursionOverflowMessage( equeue.errors );
assertTrue( "missing expected recursion overflow msg" + msg, msg != null );
@@ -1624,16 +1624,16 @@ namespace AntlrUnitTests
{
DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

// mimic actions of org.antlr.Tool first time for grammar g
if ( g.NumberOfDecisions == 0 )
{
-                g.buildNFA();
-                g.createLookaheadDFAs( false );
+                g.BuildNFA();
+                g.CreateLookaheadDFAs( false );
}
CodeGenerator generator = new CodeGenerator( newTool(), g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;

if ( equeue.size() != expectingNumWarnings )
{
@@ -1643,10 +1643,10 @@ namespace AntlrUnitTests
assertEquals( "unexpected number of expected problems",
expectingNumWarnings, equeue.size() );

-            DFA dfa = g.getLookaheadDFA( decision );
+            DFA dfa = g.GetLookaheadDFA( decision );
assertNotNull( "no DFA for decision " + decision, dfa );
FASerializer serializer = new FASerializer( g );
-            string result = serializer.serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.startState );

var unreachableAlts = dfa.UnreachableAlts;

diff --git a/Antlr3.Test/TestDFAMatching.cs b/Antlr3.Test/TestDFAMatching.cs
index fc7f36f..19aea83 100644
--- a/Antlr3.Test/TestDFAMatching.cs
+++ b/Antlr3.Test/TestDFAMatching.cs
@@ -53,9 +53,9 @@ namespace AntlrUnitTests
Grammar g = new Grammar(
"lexer grammar t;\n" +
"A : {;}'a' | 'b' | 'c';" );
-            g.buildNFA();
-            g.createLookaheadDFAs( false );
-            DFA dfa = g.getLookaheadDFA( 1 );
+            g.BuildNFA();
+            g.CreateLookaheadDFAs( false );
+            DFA dfa = g.GetLookaheadDFA( 1 );
checkPrediction( dfa, "a", 1 );
checkPrediction( dfa, "b", 2 );
checkPrediction( dfa, "c", 3 );
@@ -67,9 +67,9 @@ namespace AntlrUnitTests
Grammar g = new Grammar(
"lexer grammar t;\n" +
"A : {;}'a'..'z' | ';' | '0'..'9' ;" );
-            g.buildNFA();
-            g.createLookaheadDFAs( false );
-            DFA dfa = g.getLookaheadDFA( 1 );
+            g.BuildNFA();
+            g.CreateLookaheadDFAs( false );
+            DFA dfa = g.GetLookaheadDFA( 1 );
checkPrediction( dfa, "a", 1 );
checkPrediction( dfa, "q", 1 );
checkPrediction( dfa, "z", 1 );
@@ -82,9 +82,9 @@ namespace AntlrUnitTests
Grammar g = new Grammar(
"lexer grammar t;\n" +
"A : 'a' 'b' | 'a' 'c' | 'd' 'e' ;" );
-            g.buildNFA();
-            g.createLookaheadDFAs( false );
-            DFA dfa = g.getLookaheadDFA( 1 );
+            g.BuildNFA();
+            g.CreateLookaheadDFAs( false );
+            DFA dfa = g.GetLookaheadDFA( 1 );
checkPrediction( dfa, "ab", 1 );
checkPrediction( dfa, "ac", 2 );
checkPrediction( dfa, "de", 3 );
@@ -97,9 +97,9 @@ namespace AntlrUnitTests
"lexer grammar t;\n" +
"A : (DIGIT)+ '.' DIGIT | (DIGIT)+ ;\n" +
"fragment DIGIT : '0'..'9' ;\n" );
-            g.buildNFA();
-            g.createLookaheadDFAs( false );
-            DFA dfa = g.getLookaheadDFA( 3 );
+            g.BuildNFA();
+            g.CreateLookaheadDFAs( false );
+            DFA dfa = g.GetLookaheadDFA( 3 );
checkPrediction( dfa, "32", 2 );
checkPrediction( dfa, "999.2", 1 );
checkPrediction( dfa, ".2", NFA.INVALID_ALT_NUMBER );
diff --git a/Antlr3.Test/TestInterpretedLexing.cs b/Antlr3.Test/TestInterpretedLexing.cs
index 1722a00..90b2b25 100644
--- a/Antlr3.Test/TestInterpretedLexing.cs
+++ b/Antlr3.Test/TestInterpretedLexing.cs
@@ -87,13 +87,13 @@ namespace AntlrUnitTests
Grammar g = new Grammar(
"lexer grammar t;\n" +
"A : 'a' | 'b' | 'c';" );
-            int Atype = g.getTokenType( "A" );
+            int Atype = g.GetTokenType( "A" );
Interpreter engine = new Interpreter( g, new ANTLRStringStream( "a" ) );
engine = new Interpreter( g, new ANTLRStringStream( "b" ) );
-            IToken result = engine.scan( "A" );
+            IToken result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
engine = new Interpreter( g, new ANTLRStringStream( "c" ) );
-            result = engine.scan( "A" );
+            result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
}

@@ -103,9 +103,9 @@ namespace AntlrUnitTests
"lexer grammar t;\n" +
"A : 'a' B 'c' ;\n" +
"B : 'b' ;\n" );
-            int Atype = g.getTokenType( "A" );
+            int Atype = g.GetTokenType( "A" );
Interpreter engine = new Interpreter( g, new ANTLRStringStream( "abc" ) ); // should ignore the x
-            IToken result = engine.scan( "A" );
+            IToken result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
}

@@ -115,12 +115,12 @@ namespace AntlrUnitTests
"lexer grammar t;\n" +
"INT : (DIGIT)+ ;\n" +
"fragment DIGIT : '0'..'9';\n" );
-            int INTtype = g.getTokenType( "INT" );
+            int INTtype = g.GetTokenType( "INT" );
Interpreter engine = new Interpreter( g, new ANTLRStringStream( "12x" ) ); // should ignore the x
-            IToken result = engine.scan( "INT" );
+            IToken result = engine.Scan( "INT" );
assertEquals( result.Type, INTtype );
engine = new Interpreter( g, new ANTLRStringStream( "1234" ) );
-            result = engine.scan( "INT" );
+            result = engine.Scan( "INT" );
assertEquals( result.Type, INTtype );
}

@@ -129,26 +129,26 @@ namespace AntlrUnitTests
Grammar g = new Grammar(
"lexer grammar t;\n" +
"A : ('0'..'9'|'a'|'b')+ ;\n" );
-            int Atype = g.getTokenType( "A" );
+            int Atype = g.GetTokenType( "A" );
Interpreter engine = new Interpreter( g, new ANTLRStringStream( "a" ) );
-            IToken result = engine.scan( "A" );
+            IToken result = engine.Scan( "A" );
engine = new Interpreter( g, new ANTLRStringStream( "a" ) );
-            result = engine.scan( "A" );
+            result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
engine = new Interpreter( g, new ANTLRStringStream( "1234" ) );
-            result = engine.scan( "A" );
+            result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
engine = new Interpreter( g, new ANTLRStringStream( "aaa" ) );
-            result = engine.scan( "A" );
+            result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
engine = new Interpreter( g, new ANTLRStringStream( "aaaa9" ) );
-            result = engine.scan( "A" );
+            result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
engine = new Interpreter( g, new ANTLRStringStream( "b" ) );
-            result = engine.scan( "A" );
+            result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
engine = new Interpreter( g, new ANTLRStringStream( "baa" ) );
-            result = engine.scan( "A" );
+            result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
}

@@ -157,10 +157,10 @@ namespace AntlrUnitTests
Grammar g = new Grammar(
"lexer grammar t;\n" +
"A : ('0'..'9')+ '.' ('0'..'9')* | ('0'..'9')+ ;\n" );
-            int Atype = g.getTokenType( "A" );
+            int Atype = g.GetTokenType( "A" );
ICharStream input = new ANTLRStringStream( "1234.5" );
Interpreter engine = new Interpreter( g, input );
-            IToken result = engine.scan( "A" );
+            IToken result = engine.Scan( "A" );
assertEquals( result.Type, Atype );
}

@@ -170,9 +170,9 @@ namespace AntlrUnitTests
"grammar p;\n" +
"a : (INT|FLOAT|WS)+;\n" );
Grammar g = new Grammar();
-            g.importTokenVocabulary( pg );
+            g.ImportTokenVocabulary( pg );
g.FileName = "<string>";
-            g.setGrammarContent(
+            g.SetGrammarContent(
"lexer grammar t;\n" +
"INT : (DIGIT)+ ;\n" +
"FLOAT : (DIGIT)+ '.' (DIGIT)* ;\n" +
diff --git a/Antlr3.Test/TestInterpretedParsing.cs b/Antlr3.Test/TestInterpretedParsing.cs
index 857c4d4..13c7f7c 100644
--- a/Antlr3.Test/TestInterpretedParsing.cs
+++ b/Antlr3.Test/TestInterpretedParsing.cs
@@ -56,9 +56,9 @@ namespace AntlrUnitTests
"assign : ID ASSIGN expr SEMI ;\n" +
"expr : INT | FLOAT | ID ;\n" );
Grammar g = new Grammar();
-            g.importTokenVocabulary( pg );
+            g.ImportTokenVocabulary( pg );
g.FileName = Grammar.IGNORE_STRING_IN_GRAMMAR_FILE_NAME + "string";
-            g.setGrammarContent(
+            g.SetGrammarContent(
"lexer grammar t;\n" +
"WHILE : 'while';\n" +
"LCURLY : '{';\n" +
@@ -74,10 +74,10 @@ namespace AntlrUnitTests
Interpreter lexEngine = new Interpreter( g, input );

CommonTokenStream tokens = new CommonTokenStream( lexEngine );
-            tokens.SetTokenTypeChannel( g.getTokenType( "WS" ), 99 );
+            tokens.SetTokenTypeChannel( g.GetTokenType( "WS" ), 99 );
//System.out.println("tokens="+tokens.toString());
Interpreter parseEngine = new Interpreter( pg, tokens );
-            ParseTree t = parseEngine.parse( "prog" );
+            ParseTree t = parseEngine.Parse( "prog" );
string result = t.ToStringTree();
string expecting =
"(<grammar p> (prog while x { (assign i = (expr 1) ;) (assign y = (expr 3.42) ;) (assign z = (expr y) ;) } <EOF>))";
@@ -94,8 +94,8 @@ namespace AntlrUnitTests
"expr : INT | FLOAT | ID ;\n" );
Grammar g = new Grammar();
g.FileName = Grammar.IGNORE_STRING_IN_GRAMMAR_FILE_NAME + "string";
-            g.importTokenVocabulary( pg );
-            g.setGrammarContent(
+            g.ImportTokenVocabulary( pg );
+            g.SetGrammarContent(
"lexer grammar t;\n" +
"WHILE : 'while';\n" +
"LCURLY : '{';\n" +
@@ -111,10 +111,10 @@ namespace AntlrUnitTests
Interpreter lexEngine = new Interpreter( g, input );

CommonTokenStream tokens = new CommonTokenStream( lexEngine );
-            tokens.SetTokenTypeChannel( g.getTokenType( "WS" ), 99 );
+            tokens.SetTokenTypeChannel( g.GetTokenType( "WS" ), 99 );
//System.out.println("tokens="+tokens.toString());
Interpreter parseEngine = new Interpreter( pg, tokens );
-            ParseTree t = parseEngine.parse( "prog" );
+            ParseTree t = parseEngine.Parse( "prog" );
string result = t.ToStringTree();
string expecting =
"(<grammar p> (prog while x { (assign i = (expr 1) MismatchedTokenException(5!=9))))";
@@ -130,9 +130,9 @@ namespace AntlrUnitTests
"assign : ID ASSIGN expr SEMI ;\n" +
"expr : INT | FLOAT | ID ;\n" );
Grammar g = new Grammar();
-            g.importTokenVocabulary( pg );
+            g.ImportTokenVocabulary( pg );
g.FileName = "<string>";
-            g.setGrammarContent(
+            g.SetGrammarContent(
"lexer grammar t;\n" +
"WHILE : 'while';\n" +
"LCURLY : '{';\n" +
@@ -148,10 +148,10 @@ namespace AntlrUnitTests
Interpreter lexEngine = new Interpreter( g, input );

CommonTokenStream tokens = new CommonTokenStream( lexEngine );
-            tokens.SetTokenTypeChannel( g.getTokenType( "WS" ), 99 );
+            tokens.SetTokenTypeChannel( g.GetTokenType( "WS" ), 99 );
//System.out.println("tokens="+tokens.toString());
Interpreter parseEngine = new Interpreter( pg, tokens );
-            ParseTree t = parseEngine.parse( "prog" );
+            ParseTree t = parseEngine.Parse( "prog" );
string result = t.ToStringTree();
string expecting =
"(<grammar p> (prog while x { (assign i = (expr MismatchedSetException(9!={5,10,11})))))";
@@ -167,9 +167,9 @@ namespace AntlrUnitTests
"assign : ID ASSIGN expr SEMI ;\n" +
"expr : {;}INT | FLOAT | ID ;\n" );
Grammar g = new Grammar();
-            g.importTokenVocabulary( pg );
+            g.ImportTokenVocabulary( pg );
g.FileName = "<string>";
-            g.setGrammarContent(
+            g.SetGrammarContent(
"lexer grammar t;\n" +
"WHILE : 'while';\n" +
"LCURLY : '{';\n" +
@@ -185,10 +185,10 @@ namespace AntlrUnitTests
Interpreter lexEngine = new Interpreter( g, input );

CommonTokenStream tokens = new CommonTokenStream( lexEngine );
-            tokens.SetTokenTypeChannel( g.getTokenType( "WS" ), 99 );
+            tokens.SetTokenTypeChannel( g.GetTokenType( "WS" ), 99 );
//System.out.println("tokens="+tokens.toString());
Interpreter parseEngine = new Interpreter( pg, tokens );
-            ParseTree t = parseEngine.parse( "prog" );
+            ParseTree t = parseEngine.Parse( "prog" );
string result = t.ToStringTree();
string expecting =
"(<grammar p> (prog while x { (assign i = (expr NoViableAltException(9@[4:1: expr : ( INT | FLOAT | ID );])))))";
diff --git a/Antlr3.Test/TestLexer.cs b/Antlr3.Test/TestLexer.cs
index 5896b6e..d8bc9b3 100644
--- a/Antlr3.Test/TestLexer.cs
+++ b/Antlr3.Test/TestLexer.cs
@@ -274,7 +274,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // codegen phase sets some vars we need
StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
diff --git a/Antlr3.Test/TestMessages.cs b/Antlr3.Test/TestMessages.cs
index 70a4562..81c1a85 100644
--- a/Antlr3.Test/TestMessages.cs
+++ b/Antlr3.Test/TestMessages.cs
@@ -55,7 +55,7 @@ namespace AntlrUnitTests
{
string action = "$other.tree = null;";
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar a;\n" +
"options { output = AST;}" +
@@ -66,13 +66,13 @@ namespace AntlrUnitTests
"    ;" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();

int expectedMsgID = ErrorManager.MSG_WRITE_TO_READONLY_ATTR;
object expectedArg = "other";
diff --git a/Antlr3.Test/TestNFAConstruction.cs b/Antlr3.Test/TestNFAConstruction.cs
index 5068810..7674f48 100644
--- a/Antlr3.Test/TestNFAConstruction.cs
+++ b/Antlr3.Test/TestNFAConstruction.cs
@@ -824,7 +824,7 @@ namespace AntlrUnitTests
Grammar g = new Grammar(
"grammar t;\n" +
"A : '{' ~('}')* '}';\n" );
-            string result = g.getLexerGrammar();
+            string result = g.GetLexerGrammar();
string expecting =
"lexer grammar t;" + NewLine +
"" + NewLine +
@@ -1256,10 +1256,10 @@ namespace AntlrUnitTests

private void checkRule( Grammar g, string rule, string expecting )
{
-            g.buildNFA();
-            State startState = g.getRuleStartState( rule );
+            g.BuildNFA();
+            State startState = g.GetRuleStartState( rule );
FASerializer serializer = new FASerializer( g );
-            string result = serializer.serialize( startState );
+            string result = serializer.Serialize( startState );

//System.out.print(result);
assertEquals( expecting, result );
diff --git a/Antlr3.Test/TestRewriteAST.cs b/Antlr3.Test/TestRewriteAST.cs
index 5eb7275..e4cfa15 100644
--- a/Antlr3.Test/TestRewriteAST.cs
+++ b/Antlr3.Test/TestRewriteAST.cs
@@ -925,7 +925,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestWeirdRuleRef() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string grammar =
"grammar T;\n" +
"options {output=AST;}\n" +
@@ -938,7 +938,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

// $a is ambig; is it previous root or ref to a ref in alt?
@@ -1239,7 +1239,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestUnknownRule() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

string grammar =
"grammar T;\n" +
@@ -1253,7 +1253,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_RULE_REF;
@@ -1268,7 +1268,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestKnownRuleButNotInLHS() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

string grammar =
"grammar T;\n" +
@@ -1283,7 +1283,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS;
@@ -1298,7 +1298,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestUnknownToken() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

string grammar =
"grammar T;\n" +
@@ -1312,7 +1312,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE;
@@ -1327,7 +1327,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestUnknownLabel() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

string grammar =
"grammar T;\n" +
@@ -1341,7 +1341,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE;
@@ -1356,7 +1356,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestUnknownCharLiteralToken() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

string grammar =
"grammar T;\n" +
@@ -1370,7 +1370,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE;
@@ -1385,7 +1385,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestUnknownStringLiteralToken() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

string grammar =
"grammar T;\n" +
@@ -1399,7 +1399,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE;
diff --git a/Antlr3.Test/TestRewriteTemplates.cs b/Antlr3.Test/TestRewriteTemplates.cs
index 9540229..c39f4a1 100644
--- a/Antlr3.Test/TestRewriteTemplates.cs
+++ b/Antlr3.Test/TestRewriteTemplates.cs
@@ -258,7 +258,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRewriteRuleAndRewriteModeOnSimpleElements() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"tree grammar TP;\n" +
"options {ASTLabelType=CommonTree; output=template; rewrite=true;}\n" +
@@ -271,7 +271,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 0, equeue.warnings.Count );
@@ -280,7 +280,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRewriteRuleAndRewriteModeIgnoreActionsPredicates() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"tree grammar TP;\n" +
"options {ASTLabelType=CommonTree; output=template; rewrite=true;}\n" +
@@ -294,7 +294,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 0, equeue.warnings.Count );
@@ -303,7 +303,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRewriteRuleAndRewriteModeNotSimple() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"tree grammar TP;\n" +
"options {ASTLabelType=CommonTree; output=template; rewrite=true;}\n" +
@@ -314,7 +314,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 2, equeue.warnings.Count );
@@ -323,7 +323,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRewriteRuleAndRewriteModeRefRule() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"tree grammar TP;\n" +
"options {ASTLabelType=CommonTree; output=template; rewrite=true;}\n" +
@@ -335,7 +335,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 2, equeue.warnings.Count );
diff --git a/Antlr3.Test/TestSemanticPredicates.cs b/Antlr3.Test/TestSemanticPredicates.cs
index 72c4c5d..f600322 100644
--- a/Antlr3.Test/TestSemanticPredicates.cs
+++ b/Antlr3.Test/TestSemanticPredicates.cs
@@ -271,16 +271,16 @@ namespace AntlrUnitTests

DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
CodeGenerator generator = new CodeGenerator( newTool(), g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
if ( g.NumberOfDecisions == 0 )
{
-                g.buildNFA();
-                g.createLookaheadDFAs( false );
+                g.BuildNFA();
+                g.CreateLookaheadDFAs( false );
}

-            DFA dfa = g.getLookaheadDFA( 1 );
+            DFA dfa = g.GetLookaheadDFA( 1 );
assertEquals( null, dfa ); // can't analyze.

/*
@@ -390,13 +390,13 @@ namespace AntlrUnitTests
".s4-{p2}?->:s3=>2\n";
DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
CodeGenerator generator = new CodeGenerator( newTool(), g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
if ( g.NumberOfDecisions == 0 )
{
-                g.buildNFA();
-                g.createLookaheadDFAs( false );
+                g.BuildNFA();
+                g.CreateLookaheadDFAs( false );
}

assertEquals( "unexpected number of expected problems", 0, equeue.size() );
@@ -426,13 +426,13 @@ namespace AntlrUnitTests
".s6-':'->:s4=>2\n";
DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
CodeGenerator generator = new CodeGenerator( newTool(), g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
if ( g.NumberOfDecisions == 0 )
{
-                g.buildNFA();
-                g.createLookaheadDFAs( false );
+                g.BuildNFA();
+                g.CreateLookaheadDFAs( false );
}

assertEquals( "unexpected number of expected problems", 0, equeue.size() );
@@ -599,7 +599,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestIncompleteSemanticHoistedContext() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : b | B;\n" +
@@ -613,7 +613,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestIncompleteSemanticHoistedContextk2() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : b | A B;\n" +
@@ -628,7 +628,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestIncompleteSemanticHoistedContextInFOLLOW() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"options {k=1;}\n" + // limit to k=1 because it's LL(2); force pred hoist
@@ -643,7 +643,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestIncompleteSemanticHoistedContextInFOLLOWk2() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : (A B)? ;\n" + // need FOLLOW
@@ -659,7 +659,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestIncompleteSemanticHoistedContextInFOLLOWDueToHiddenPred() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : (A B)? ;\n" + // need FOLLOW
@@ -685,7 +685,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestIncompleteSemanticHoistedContext2() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : b | B;\n" +
@@ -846,14 +846,14 @@ namespace AntlrUnitTests
{
DecisionProbe.verbose = true; // make sure we get all error info
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
CodeGenerator generator = new CodeGenerator( newTool(), g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
// mimic actions of org.antlr.Tool first time for grammar g
if ( g.NumberOfDecisions == 0 )
{
-                g.buildNFA();
-                g.createLookaheadDFAs( false );
+                g.BuildNFA();
+                g.CreateLookaheadDFAs( false );
}

if ( equeue.size() != expectingNumWarnings )
@@ -864,9 +864,9 @@ namespace AntlrUnitTests
assertEquals( "unexpected number of expected problems",
expectingNumWarnings, equeue.size() );

-            DFA dfa = g.getLookaheadDFA( decision );
+            DFA dfa = g.GetLookaheadDFA( decision );
FASerializer serializer = new FASerializer( g );
-            string result = serializer.serialize( dfa.startState );
+            string result = serializer.Serialize( dfa.startState );
//System.out.print(result);
var unreachableAlts = dfa.UnreachableAlts;

diff --git a/Antlr3.Test/TestSymbolDefinitions.cs b/Antlr3.Test/TestSymbolDefinitions.cs
index 76698db..edda3e0 100644
--- a/Antlr3.Test/TestSymbolDefinitions.cs
+++ b/Antlr3.Test/TestSymbolDefinitions.cs
@@ -144,7 +144,7 @@ namespace AntlrUnitTests
"" + NewLine +
"// $ANTLR src \"<string>\" 3" + NewLine +
"E: 'x' '0' ;";
-            assertEquals( implicitLexer, g.getLexerGrammar() );
+            assertEquals( implicitLexer, g.GetLexerGrammar() );
}

[TestMethod]
@@ -243,7 +243,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRefToRuleWithNoReturnValue() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

string grammarStr =
"grammar P;\n" +
@@ -254,7 +254,7 @@ namespace AntlrUnitTests

AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
StringTemplate recogST = generator.GenRecognizer();
string code = recogST.ToString();
assertTrue( "not expecting label", code.IndexOf( "x=b();" ) < 0 );
@@ -267,7 +267,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestParserStringLiterals() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : 'begin' b ;\n" +
@@ -282,7 +282,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestParserCharLiterals() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : '(' b ;\n" +
@@ -297,11 +297,11 @@ namespace AntlrUnitTests
[TestMethod]
public void TestEmptyNotChar() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar foo;\n" +
"a : (~'x')+ ;\n" );
-            g.buildNFA();
+            g.BuildNFA();
object expectedArg = "'x'";
int expectedMsgID = ErrorManager.MSG_EMPTY_COMPLEMENT;
GrammarSemanticsMessage expectedMessage =
@@ -312,11 +312,11 @@ namespace AntlrUnitTests
[TestMethod]
public void TestEmptyNotToken() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar foo;\n" +
"a : (~A)+ ;\n" );
-            g.buildNFA();
+            g.BuildNFA();
object expectedArg = "A";
int expectedMsgID = ErrorManager.MSG_EMPTY_COMPLEMENT;
GrammarSemanticsMessage expectedMessage =
@@ -327,11 +327,11 @@ namespace AntlrUnitTests
[TestMethod]
public void TestEmptyNotSet() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar foo;\n" +
"a : (~(A|B))+ ;\n" );
-            g.buildNFA();
+            g.BuildNFA();
object expectedArg = null;
int expectedMsgID = ErrorManager.MSG_EMPTY_COMPLEMENT;
GrammarSemanticsMessage expectedMessage =
@@ -342,7 +342,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestStringLiteralInParserTokensSection() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"tokens {\n" +
@@ -360,7 +360,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestCharLiteralInParserTokensSection() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"tokens {\n" +
@@ -378,7 +378,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestCharLiteralInLexerTokensSection() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"lexer grammar t;\n" +
"tokens {\n" +
@@ -395,7 +395,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRuleRedefinition() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : A | B;\n" +
@@ -411,7 +411,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestLexerRuleRedefinition() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"lexer grammar t;\n" +
"ID : 'a' ;\n" +
@@ -427,7 +427,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestCombinedRuleRedefinition() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"grammar t;\n" +
"x : ID ;\n" +
@@ -444,7 +444,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestUndefinedToken() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"grammar t;\n" +
"x : ID ;" );
@@ -459,7 +459,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestUndefinedTokenOkInParser() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"x : ID ;" );
@@ -469,7 +469,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestUndefinedRule() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"grammar t;\n" +
"x : r ;" );
@@ -484,7 +484,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestLexerRuleInParser() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"X : ;" );
@@ -499,7 +499,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestParserRuleInLexer() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"lexer grammar t;\n" +
"a : ;" );
@@ -514,7 +514,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRuleScopeConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"grammar t;\n" +
"scope a {\n" +
@@ -533,7 +533,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestTokenRuleScopeConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"grammar t;\n" +
"scope ID {\n" +
@@ -552,7 +552,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestTokenScopeConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"grammar t;\n" +
"tokens { ID; }\n" +
@@ -572,7 +572,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestTokenRuleScopeConflictInLexerGrammar() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"lexer grammar t;\n" +
"scope ID {\n" +
@@ -591,7 +591,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestTokenLabelScopeConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"scope s {\n" +
@@ -610,7 +610,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRuleLabelScopeConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"scope s {\n" +
@@ -630,7 +630,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestLabelAndRuleNameConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : c=b \n" +
@@ -648,7 +648,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestLabelAndTokenNameConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a : ID=b \n" +
@@ -666,7 +666,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestLabelAndArgConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a[int i] returns [int x]: i=ID \n" +
@@ -682,7 +682,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestLabelAndParameterConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a[int i] returns [int x]: x=ID \n" +
@@ -698,7 +698,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestLabelRuleScopeConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a\n" +
@@ -719,7 +719,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRuleScopeArgConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a[int n]\n" +
@@ -740,7 +740,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRuleScopeReturnValueConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a returns [int n]\n" +
@@ -761,7 +761,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestRuleScopeRuleNameConflict() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"parser grammar t;\n" +
"a\n" +
@@ -782,7 +782,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestBadGrammarOption() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
AntlrTool antlr = newTool();
Grammar g = new Grammar( antlr,
"grammar t;\n" +
@@ -799,7 +799,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestBadRuleOption() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"grammar t;\n" +
"a\n" +
@@ -816,7 +816,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestBadSubRuleOption() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue ); // unique listener per thread
+            ErrorManager.SetErrorListener( equeue ); // unique listener per thread
Grammar g = new Grammar(
"grammar t;\n" +
"a : ( options {k=3; language=Java;}\n" +
@@ -834,7 +834,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestTokenVocabStringUsedInLexer() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string tokens =
"';'=4\n";
mkdir( tmpdir );
@@ -848,8 +848,8 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/B.g", composite );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

string expectedTokenIDToTypeMap = "[SEMI=4]";
string expectedStringLiteralToTypeMap = "{';'=4}";
@@ -867,7 +867,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestTokenVocabStringUsedInCombined() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
string tokens =
"';'=4\n";
mkdir( tmpdir );
@@ -881,8 +881,8 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool( new string[] { "-lib", tmpdir } );
CompositeGrammar composite = new CompositeGrammar();
Grammar g = new Grammar( antlr, tmpdir + "/B.g", composite );
-            g.parseAndBuildAST();
-            g.composite.assignTokenTypes();
+            g.ParseAndBuildAST();
+            g.composite.AssignTokenTypes();

string expectedTokenIDToTypeMap = "[SEMI=4]";
string expectedStringLiteralToTypeMap = "{';'=4}";
@@ -904,7 +904,7 @@ namespace AntlrUnitTests
//throws Exception
{
// make sure expected += labels are there
-            Rule r = g.getRule( ruleName );
+            Rule r = g.GetRule( ruleName );
StringTokenizer st = new StringTokenizer( tokenLabelsStr, ", " );
ICollection<string> tokenLabels = null;
while ( st.hasMoreTokens() )
@@ -948,7 +948,7 @@ namespace AntlrUnitTests
string tokensStr )
//throws Exception
{
-            var tokens = g.getTokenDisplayNames();
+            var tokens = g.GetTokenDisplayNames();

// make sure expected tokens are there
//StringTokenizer st = new StringTokenizer( tokensStr, ", " );
@@ -957,13 +957,13 @@ namespace AntlrUnitTests
{
//String tokenName = st.nextToken();
assertTrue( "token " + tokenName + " expected",
-                           g.getTokenType( tokenName ) != Label.INVALID );
+                           g.GetTokenType( tokenName ) != Label.INVALID );
tokens.Remove( tokenName );
}
// make sure there are not any others (other than <EOF> etc...)
foreach ( string tokenName in tokens )
{
-                Assert.IsTrue( g.getTokenType( tokenName ) < Label.MIN_TOKEN_TYPE, "unexpected token name " + tokenName );
+                Assert.IsTrue( g.GetTokenType( tokenName ) < Label.MIN_TOKEN_TYPE, "unexpected token name " + tokenName );
}

// make sure all expected rules are there
@@ -973,7 +973,7 @@ namespace AntlrUnitTests
foreach ( string ruleName in rulesStr.Split( new string[] { ", " }, StringSplitOptions.RemoveEmptyEntries ) )
{
//String ruleName = st.nextToken();
-                assertNotNull( "rule " + ruleName + " expected", g.getRule( ruleName ) );
+                assertNotNull( "rule " + ruleName + " expected", g.GetRule( ruleName ) );
n++;
}
var rules = g.Rules;
diff --git a/Antlr3.Test/TestTemplates.cs b/Antlr3.Test/TestTemplates.cs
index dd0b3cd..1588194 100644
--- a/Antlr3.Test/TestTemplates.cs
+++ b/Antlr3.Test/TestTemplates.cs
@@ -57,7 +57,7 @@ namespace AntlrUnitTests
LINE_SEP + "  new STAttrMap().put(\"name\", (ID1!=null?ID1.getText():null)));";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -70,14 +70,14 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -94,7 +94,7 @@ namespace AntlrUnitTests
string expecting = "x = templateLib.getInstanceOf(\"foo\");";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -107,14 +107,14 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -132,7 +132,7 @@ namespace AntlrUnitTests
LINE_SEP + "  new STAttrMap().put(\"name\", (ID1!=null?ID1.getText():null)));";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -145,14 +145,14 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -169,7 +169,7 @@ namespace AntlrUnitTests
string expecting = "x = new StringTemplate(templateLib,(ID1!=null?ID1.getText():null));";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -182,13 +182,13 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -205,7 +205,7 @@ namespace AntlrUnitTests
string expecting = "(x).setAttribute(\"y\", z);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -218,14 +218,14 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -242,7 +242,7 @@ namespace AntlrUnitTests
string expecting = "(foo((ID1!=null?ID1.getText():null)).getST()).setAttribute(\"y\", z);";

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -255,13 +255,13 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
-                translator.translate();
+                translator.Translate();
StringTemplateGroup templates =
new StringTemplateGroup( ".", typeof( AngleBracketTemplateLexer ) );
StringTemplate actionST = new StringTemplate( templates, rawTranslation );
@@ -275,7 +275,7 @@ namespace AntlrUnitTests
[TestMethod]
public void TestSetAttrOfExprInMembers() /*throws Exception*/ {
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -290,7 +290,7 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates

assertNoErrors( equeue );
@@ -302,7 +302,7 @@ namespace AntlrUnitTests
//String expecting = null;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -315,7 +315,7 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_INVALID_TEMPLATE_ACTION;
@@ -331,7 +331,7 @@ namespace AntlrUnitTests
//String expecting = null;

ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );
Grammar g = new Grammar(
"grammar t;\n" +
"options {\n" +
@@ -344,7 +344,7 @@ namespace AntlrUnitTests
"ID : 'a';\n" );
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_INVALID_TEMPLATE_ACTION;
diff --git a/Antlr3.Test/TestTreeGrammarRewriteAST.cs b/Antlr3.Test/TestTreeGrammarRewriteAST.cs
index 2a6a3ab..af268ab 100644
--- a/Antlr3.Test/TestTreeGrammarRewriteAST.cs
+++ b/Antlr3.Test/TestTreeGrammarRewriteAST.cs
@@ -249,7 +249,7 @@ namespace AntlrUnitTests
public void TestNoWildcardAsRootError() /*throws Exception*/
{
ErrorQueue equeue = new ErrorQueue();
-            ErrorManager.setErrorListener( equeue );
+            ErrorManager.SetErrorListener( equeue );

string treeGrammar =
"tree grammar TP;\n" +
@@ -261,7 +261,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
antlr.SetOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
-            g.setCodeGenerator( generator );
+            g.CodeGenerator = generator;
generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 1, equeue.errors.Count );
diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index 19176cc..52fa8db 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -241,7 +241,7 @@ namespace Antlr3.Analysis
this.decisionNumber = decisionNumber;
this._decisionNFAStartState = decisionStartState;
nfa = decisionStartState.nfa;
-            _nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            _nAlts = nfa.grammar.GetNumberOfAltsForDecisionNFA( decisionStartState );
//setOptions( nfa.grammar.getDecisionOptions(getDecisionNumber()) );
InitAltRelatedInfo();

@@ -532,7 +532,7 @@ namespace Antlr3.Analysis
}
if ( snum != NumberOfStates )
{
-                ErrorManager.internalError( "DFA " + decisionNumber + ": " +
+                ErrorManager.InternalError( "DFA " + decisionNumber + ": " +
_decisionNFAStartState.Description + " num unique states " + NumberOfStates +
"!= num renumbered states " + snum );
}
@@ -816,7 +816,7 @@ namespace Antlr3.Analysis

if ( smax < 0 || smin > Label.MAX_CHAR_VALUE || smin < 0 )
{
-                ErrorManager.internalError( "messed up: min=" + _min + ", max=" + _max );
+                ErrorManager.InternalError( "messed up: min=" + _min + ", max=" + _max );
}
}

@@ -944,7 +944,7 @@ namespace Antlr3.Analysis
public virtual int Predict( IIntStream input )
{
Interpreter interp = new Interpreter( nfa.grammar, input );
-            return interp.predict( this );
+            return interp.Predict( this );
}

/** Add a new DFA state to this DFA if not already present.
@@ -1010,7 +1010,7 @@ namespace Antlr3.Analysis
return false;
}
NFAState nfaStart = NFADecisionStartState;
-            Rule r = nfa.grammar.getLocallyDefinedRule( Grammar.ARTIFICIAL_TOKENS_RULENAME );
+            Rule r = nfa.grammar.GetLocallyDefinedRule( Grammar.ARTIFICIAL_TOKENS_RULENAME );
NFAState TokensRuleStart = r.startState;
NFAState TokensDecisionStart =
(NFAState)TokensRuleStart.transition[0].target;
@@ -1027,13 +1027,13 @@ namespace Antlr3.Analysis
{ // cache for speed
return _userK;
}
-            _userK = nfa.grammar.getUserMaxLookahead( decisionNumber );
+            _userK = nfa.grammar.GetUserMaxLookahead( decisionNumber );
return _userK;
}

public virtual bool GetAutoBacktrackMode()
{
-            return nfa.grammar.getAutoBacktrackMode( decisionNumber );
+            return nfa.grammar.GetAutoBacktrackMode( decisionNumber );
}

public virtual void SetUserMaxLookahead( int k )
@@ -1152,7 +1152,7 @@ namespace Antlr3.Analysis
foreach ( SemanticContext semctx in synpreds )
{
// JSystem.@out.println("synpreds: "+semctx);
-                            nfa.grammar.synPredUsedInDFA( this, semctx );
+                            nfa.grammar.SynPredUsedInDFA( this, semctx );
}
}
}
@@ -1220,8 +1220,8 @@ namespace Antlr3.Analysis

public virtual bool GetIsGreedy()
{
-            GrammarAST blockAST = nfa.grammar.getDecisionBlockAST( decisionNumber );
-            Object v = nfa.grammar.getBlockOption( blockAST, "greedy" );
+            GrammarAST blockAST = nfa.grammar.GetDecisionBlockAST( decisionNumber );
+            Object v = nfa.grammar.GetBlockOption( blockAST, "greedy" );
if ( v != null && v.Equals( "false" ) )
{
return false;
@@ -1257,7 +1257,7 @@ namespace Antlr3.Analysis
{
return "";
}
-            return serializer.serialize( startState, false );
+            return serializer.Serialize( startState, false );
}

#if false
diff --git a/Antlr3/Analysis/DFAOptimizer.cs b/Antlr3/Analysis/DFAOptimizer.cs
index da0f39e..a28d1ac 100644
--- a/Antlr3/Analysis/DFAOptimizer.cs
+++ b/Antlr3/Analysis/DFAOptimizer.cs
@@ -145,7 +145,7 @@ namespace Antlr3.Analysis
decisionNumber <= _grammar.NumberOfDecisions;
decisionNumber++ )
{
-                DFA dfa = _grammar.getLookaheadDFA( decisionNumber );
+                DFA dfa = _grammar.GetLookaheadDFA( decisionNumber );
Optimize( dfa );
}
}
diff --git a/Antlr3/Analysis/DecisionProbe.cs b/Antlr3/Analysis/DecisionProbe.cs
index e010e7f..8609862 100644
--- a/Antlr3/Analysis/DecisionProbe.cs
+++ b/Antlr3/Analysis/DecisionProbe.cs
@@ -449,12 +449,12 @@ namespace Antlr3.Analysis
for ( int a = firstAlt; a <= alt; a++ )
{
NFAState s =
-                    dfa.nfa.grammar.getNFAStateForAltOfDecision( nfaStart, a );
+                    dfa.nfa.grammar.GetNFAStateForAltOfDecision( nfaStart, a );
path.Add( s );
}

// add first state of actual alt
-            NFAState altStart = dfa.nfa.grammar.getNFAStateForAltOfDecision( nfaStart, alt );
+            NFAState altStart = dfa.nfa.grammar.GetNFAStateForAltOfDecision( nfaStart, alt );
NFAState isolatedAltStart = (NFAState)altStart.transition[0].target;
path.Add( isolatedAltStart );

@@ -496,7 +496,7 @@ namespace Antlr3.Analysis
// if we take too long to terminate
if ( _nonLLStarDecision && !dfa.AutoBacktrackMode )
{
-                ErrorManager.nonLLStarDecision( this );
+                ErrorManager.NonLLStarDecision( this );
}

if ( AnalysisTimedOut )
@@ -504,7 +504,7 @@ namespace Antlr3.Analysis
// only report early termination errors if !backtracking
if ( !dfa.AutoBacktrackMode )
{
-                    ErrorManager.analysisAborted( this );
+                    ErrorManager.AnalysisAborted( this );
}
// now just return...if we bailed out, don't spew other messages
return;
@@ -525,7 +525,7 @@ namespace Antlr3.Analysis
IDictionary<int, ICollection<IToken>> insufficientAltToLocations = GetIncompletelyCoveredAlts( d );
if ( insufficientAltToLocations != null && insufficientAltToLocations.Count > 0 )
{
-                        ErrorManager.insufficientPredicates( this, d, insufficientAltToLocations );
+                        ErrorManager.InsufficientPredicates( this, d, insufficientAltToLocations );
}
// don't report problem if resolved
if ( resolvedStates == null || !resolvedStates.Contains( d ) )
@@ -536,7 +536,7 @@ namespace Antlr3.Analysis
StripWildCardAlts( disabledAlts );
if ( disabledAlts.Count > 0 )
{
-                            ErrorManager.nondeterminism( this, d );
+                            ErrorManager.Nondeterminism( this, d );
}
}
}
@@ -548,7 +548,7 @@ namespace Antlr3.Analysis
//Console.Error.WriteLine( "no emanating edges for states: " + danglingStates );
foreach ( DFAState d in danglingStates )
{
-                    ErrorManager.danglingState( this, d );
+                    ErrorManager.DanglingState( this, d );
}
}

@@ -570,7 +570,7 @@ namespace Antlr3.Analysis
if ( delegatedTokensAlt != null )
{
isInheritedTokensRule = true;
-                                ErrorManager.grammarWarning( ErrorManager.MSG_IMPORTED_TOKENS_RULE_EMPTY,
+                                ErrorManager.GrammarWarning( ErrorManager.MSG_IMPORTED_TOKENS_RULE_EMPTY,
dfa.nfa.grammar,
null,
dfa.nfa.grammar.name,
@@ -583,7 +583,7 @@ namespace Antlr3.Analysis
}
else
{
-                        ErrorManager.unreachableAlts( this, unreachableAlts );
+                        ErrorManager.UnreachableAlts( this, unreachableAlts );
}
}
}
@@ -601,7 +601,7 @@ namespace Antlr3.Analysis
int lastAlt =
(int)sortedDisableAlts[sortedDisableAlts.Count - 1];
GrammarAST blockAST =
-                dfa.nfa.grammar.getDecisionBlockAST( dfa.decisionNumber );
+                dfa.nfa.grammar.GetDecisionBlockAST( dfa.decisionNumber );
//JSystem.@out.println("block with error = "+blockAST.toStringTree());
GrammarAST lastAltAST = null;
if ( blockAST.GetChild( 0 ).Type == ANTLRParser.OPTIONS )
@@ -656,7 +656,7 @@ namespace Antlr3.Analysis
var targetRules = targetToCallSiteMap.Keys;
var callSiteStates = targetToCallSiteMap.Values;
DFAState sampleBadState = (DFAState)altToDFAState.get( altI );
-                ErrorManager.recursionOverflow( this,
+                ErrorManager.RecursionOverflow( this,
sampleBadState,
altI,
targetRules,
@@ -1039,7 +1039,7 @@ namespace Antlr3.Analysis
{
NFAState decisionState = dfa.NFADecisionStartState;
NFAState altState =
-                dfa.nfa.grammar.getNFAStateForAltOfDecision( decisionState, alt );
+                dfa.nfa.grammar.GetNFAStateForAltOfDecision( decisionState, alt );
NFAState decisionLeft = (NFAState)altState.transition[0].target;
RuleClosureTransition ruleCallEdge =
(RuleClosureTransition)decisionLeft.transition[0];
diff --git a/Antlr3/Analysis/LL1DFA.cs b/Antlr3/Analysis/LL1DFA.cs
index fc1b225..48d8784 100644
--- a/Antlr3/Analysis/LL1DFA.cs
+++ b/Antlr3/Analysis/LL1DFA.cs
@@ -58,7 +58,7 @@ namespace Antlr3.Analysis
DFAState s0 = NewState();
startState = s0;
nfa = decisionStartState.nfa;
-            NumberOfAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            NumberOfAlts = nfa.grammar.GetNumberOfAltsForDecisionNFA( decisionStartState );
this.decisionNumber = decisionNumber;
this.NFADecisionStartState = decisionStartState;
InitAltRelatedInfo();
@@ -85,7 +85,7 @@ namespace Antlr3.Analysis
DFAState s0 = NewState();
startState = s0;
nfa = decisionStartState.nfa;
-            NumberOfAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( decisionStartState );
+            NumberOfAlts = nfa.grammar.GetNumberOfAltsForDecisionNFA( decisionStartState );
this.decisionNumber = decisionNumber;
this.NFADecisionStartState = decisionStartState;
InitAltRelatedInfo();
@@ -172,7 +172,7 @@ namespace Antlr3.Analysis
int walkAlt =
decisionStartState.TranslateDisplayAltToWalkAlt( alt );
NFAState altLeftEdge =
-                nfa.grammar.getNFAStateForAltOfDecision( decisionStartState, walkAlt );
+                nfa.grammar.GetNFAStateForAltOfDecision( decisionStartState, walkAlt );
NFAState altStartState = (NFAState)altLeftEdge.transition[0].target;
//JSystem.@out.println("alt "+alt+" start state = "+altStartState.stateNumber);
if ( altStartState.transition[0].IsSemanticPredicate )
@@ -189,7 +189,7 @@ namespace Antlr3.Analysis
*/
if ( ctx.IsSyntacticPredicate )
{
-                            nfa.grammar.synPredUsedInDFA( this, ctx );
+                            nfa.grammar.SynPredUsedInDFA( this, ctx );
}
return (SemanticContext.Predicate)altStartState.transition[0].label.SemanticContext;
}
diff --git a/Antlr3/Analysis/Label.cs b/Antlr3/Analysis/Label.cs
index a278589..1df1e45 100644
--- a/Antlr3/Analysis/Label.cs
+++ b/Antlr3/Analysis/Label.cs
@@ -413,7 +413,7 @@ namespace Antlr3.Analysis
case SET:
return _labelSet.ToString( g );
default:
-                return g.getTokenDisplayName( label );
+                return g.GetTokenDisplayName( label );
}
}

diff --git a/Antlr3/Analysis/NFA.cs b/Antlr3/Analysis/NFA.cs
index 73e1ccd..fab8d61 100644
--- a/Antlr3/Analysis/NFA.cs
+++ b/Antlr3/Analysis/NFA.cs
@@ -73,17 +73,17 @@ namespace Antlr3.Analysis

public int GetNewNFAStateNumber()
{
-            return grammar.composite.getNewNFAStateNumber();
+            return grammar.composite.GetNewNFAStateNumber();
}

public void AddState( NFAState state )
{
-            grammar.composite.addState( state );
+            grammar.composite.AddState( state );
}

public NFAState GetState( int s )
{
-            return grammar.composite.getState( s );
+            return grammar.composite.GetState( s );
}
}
}
diff --git a/Antlr3/Analysis/NFAConversionThread.cs b/Antlr3/Analysis/NFAConversionThread.cs
index a8ce3ab..b4d48ed 100644
--- a/Antlr3/Analysis/NFAConversionThread.cs
+++ b/Antlr3/Analysis/NFAConversionThread.cs
@@ -57,10 +57,10 @@ namespace Antlr3.Analysis
{
for ( int decision = i; decision <= j; decision++ )
{
-                NFAState decisionStartState = grammar.getDecisionNFAStartState( decision );
+                NFAState decisionStartState = grammar.GetDecisionNFAStartState( decision );
if ( decisionStartState.NumberOfTransitions > 1 )
{
-                    grammar.createLookaheadDFA( decision, true );
+                    grammar.CreateLookaheadDFA( decision, true );
}
}
// now wait for others to finish
@@ -70,7 +70,7 @@ namespace Antlr3.Analysis
}
catch ( OperationCanceledException e )
{
-                ErrorManager.internalError( "what the hell? DFA interruptus", e );
+                ErrorManager.InternalError( "what the hell? DFA interruptus", e );
}
}
}
diff --git a/Antlr3/Analysis/NFAState.cs b/Antlr3/Analysis/NFAState.cs
index ff8e623..eb67ef5 100644
--- a/Antlr3/Analysis/NFAState.cs
+++ b/Antlr3/Analysis/NFAState.cs
@@ -190,7 +190,7 @@ namespace Antlr3.Analysis
{
if ( ( (NFAState)e.target ).incidentEdgeLabel != null )
{
-                        ErrorManager.internalError( "Clobbered incident edge" );
+                        ErrorManager.InternalError( "Clobbered incident edge" );
}
( (NFAState)e.target ).incidentEdgeLabel = e.label;
}
@@ -259,7 +259,7 @@ namespace Antlr3.Analysis
ErrorManager.internalError("can't get DFA for decision "+decisionNumber);
}
*/
-            int nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA( nfaStart );
+            int nAlts = nfa.grammar.GetNumberOfAltsForDecisionNFA( nfaStart );
switch ( nfaStart.decisionStateType )
{
case LOOPBACK:
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index 6345418..33d8e19 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -172,7 +172,7 @@ namespace Antlr3.Analysis
_dfa.NFADecisionStartState.decisionStateType == NFAState.LOOPBACK )
{
int numAltsIncludingExitBranch = _dfa.nfa.grammar
-                        .getNumberOfAltsForDecisionNFA( _dfa.NFADecisionStartState );
+                        .GetNumberOfAltsForDecisionNFA( _dfa.NFADecisionStartState );
altNum = numAltsIncludingExitBranch;
Closure( (NFAState)alt.transition[0].target,
altNum,
@@ -794,7 +794,7 @@ namespace Antlr3.Analysis
int walkAlt =
_dfa.NFADecisionStartState.TranslateDisplayAltToWalkAlt( alt );
NFAState altLeftEdge =
-                            _dfa.nfa.grammar.getNFAStateForAltOfDecision( _dfa.NFADecisionStartState, walkAlt );
+                            _dfa.nfa.grammar.GetNFAStateForAltOfDecision( _dfa.NFADecisionStartState, walkAlt );
/*
JSystem.@out.println("state "+p.stateNumber+" alt "+alt+" walkAlt "+walkAlt+" trans to "+transition0.target);
JSystem.@out.println("DFA start state "+dfa.decisionNFAStartState.stateNumber);
@@ -1556,7 +1556,7 @@ namespace Antlr3.Analysis
// notify grammar that we've used the preds contained in semCtx
if ( semCtx.IsSyntacticPredicate )
{
-                            _dfa.nfa.grammar.synPredUsedInDFA( _dfa, semCtx );
+                            _dfa.nfa.grammar.SynPredUsedInDFA( _dfa, semCtx );
}
}
else if ( nondeterministicAlts.Contains( configuration.alt ) )
@@ -1723,7 +1723,7 @@ namespace Antlr3.Analysis
{
if ( s.associatedASTNode == null || s.associatedASTNode.token == null )
{
-                                ErrorManager.internalError( "no AST/token for nonepsilon target w/o predicate" );
+                                ErrorManager.InternalError( "no AST/token for nonepsilon target w/o predicate" );
}
else
{
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index 38f8e39..e21ae96 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -109,7 +109,7 @@ namespace Antlr3
if ( !exitNow )
{
antlr.Process();
-                Environment.ExitCode = ( ErrorManager.getNumErrors() > 0 ) ? 1 : 0;
+                Environment.ExitCode = ( ErrorManager.GetNumErrors() > 0 ) ? 1 : 0;
}
}

@@ -126,7 +126,7 @@ namespace Antlr3
{
if ( verbose )
{
-                ErrorManager.info( "ANTLR Parser Generator  Version " + VERSION );
+                ErrorManager.Info( "ANTLR Parser Generator  Version " + VERSION );
showBanner = false;
}

@@ -155,7 +155,7 @@ namespace Antlr3
haveOutputDir = true;
if ( System.IO.File.Exists( outputDirectory ) )
{
-                            ErrorManager.error( ErrorManager.MSG_OUTPUT_DIR_IS_FILE, outputDirectory );
+                            ErrorManager.Error( ErrorManager.MSG_OUTPUT_DIR_IS_FILE, outputDirectory );
LibraryDirectory = ".";
}
}
@@ -178,7 +178,7 @@ namespace Antlr3
}
if ( !System.IO.Directory.Exists( libDirectory ) )
{
-                            ErrorManager.error( ErrorManager.MSG_DIR_NOT_FOUND, LibraryDirectory );
+                            ErrorManager.Error( ErrorManager.MSG_DIR_NOT_FOUND, LibraryDirectory );
LibraryDirectory = ".";
}
}
@@ -241,7 +241,7 @@ namespace Antlr3
else
{
i++;
-                        ErrorManager.setFormat( args[i] );
+                        ErrorManager.SetFormat( args[i] );
}
}
else if ( args[i] == "-Xgrtree" )
@@ -379,8 +379,8 @@ namespace Antlr3
public virtual bool BuildRequired( string grammarFileName )
{
BuildDependencyGenerator bd = new BuildDependencyGenerator( this, grammarFileName );
-            IList<string> outputFiles = bd.getGeneratedFileList();
-            IList<string> inputFiles = bd.getDependenciesFileList();
+            IList<string> outputFiles = bd.GetGeneratedFileList();
+            IList<string> inputFiles = bd.GetDependenciesFileList();
DateTime grammarLastModified = File.GetLastWriteTime( grammarFileName );
foreach ( string outputFile in outputFiles )
{
@@ -420,7 +420,7 @@ namespace Antlr3
// before setting options. The banner won't display that way!
if ( Verbose && showBanner )
{
-                ErrorManager.info( "ANTLR Parser Generator  Version " + VERSION );
+                ErrorManager.Info( "ANTLR Parser Generator  Version " + VERSION );
showBanner = false;
}

@@ -430,7 +430,7 @@ namespace Antlr3
}
catch ( Exception e )
{
-                ErrorManager.error( ErrorManager.MSG_INTERNAL_ERROR, e );
+                ErrorManager.Error( ErrorManager.MSG_INTERNAL_ERROR, e );
}

foreach ( string grammarFileName in GrammarFileNames )
@@ -447,7 +447,7 @@ namespace Antlr3
}
catch ( Exception e )
{
-                        ErrorManager.error( ErrorManager.MSG_INTERNAL_ERROR, e );
+                        ErrorManager.Error( ErrorManager.MSG_INTERNAL_ERROR, e );
}
}

@@ -466,22 +466,22 @@ namespace Antlr3
Console.Out.WriteLine( "output: " + outputFiles );
Console.Out.WriteLine( "dependents: " + dependents );
#endif
-                        Console.Out.WriteLine( dep.getDependencies() );
+                        Console.Out.WriteLine( dep.GetDependencies() );
continue;
}

Grammar grammar = GetRootGrammar( grammarFileName );
// we now have all grammars read in as ASTs
// (i.e., root and all delegates)
-                    grammar.composite.assignTokenTypes();
-                    grammar.composite.defineGrammarSymbols();
-                    grammar.composite.createNFAs();
+                    grammar.composite.AssignTokenTypes();
+                    grammar.composite.DefineGrammarSymbols();
+                    grammar.composite.CreateNFAs();

GenerateRecognizer( grammar );

if ( PrintGrammar )
{
-                        grammar.printGrammar( Console.Out );
+                        grammar.PrintGrammar( Console.Out );
}

if ( Report )
@@ -489,19 +489,19 @@ namespace Antlr3
GrammarReport report2 = new GrammarReport( grammar );
Console.Out.WriteLine( report2.ToString() );
// print out a backtracking report too (that is not encoded into log)
-                        Console.Out.WriteLine( report2.getBacktrackingReport() );
+                        Console.Out.WriteLine( report2.GetBacktrackingReport() );
// same for aborted NFA->DFA conversions
-                        Console.Out.WriteLine( report2.getAnalysisTimeoutReport() );
+                        Console.Out.WriteLine( report2.GetAnalysisTimeoutReport() );

if ( Profile )
{
Stats.WriteReport( GrammarReport.GRAMMAR_STATS_FILENAME,
-                                              report2.toNotifyString() );
+                                              report2.ToNotifyString() );
}
}

// now handle the lexer if one was created for a merged spec
-                    string lexerGrammarStr = grammar.getLexerGrammar();
+                    string lexerGrammarStr = grammar.GetLexerGrammar();
//JSystem.@out.println("lexer grammar:\n"+lexerGrammarStr);
if ( grammar.type == Grammar.COMBINED && lexerGrammarStr != null )
{
@@ -531,14 +531,14 @@ namespace Antlr3
FileInfo lexerGrammarFullFile = new FileInfo( System.IO.Path.Combine( GetFileDirectory( lexerGrammarFileName ), lexerGrammarFileName ) );
lexerGrammar.FileName = lexerGrammarFullFile.ToString();

-                            lexerGrammar.importTokenVocabulary( grammar );
-                            lexerGrammar.parseAndBuildAST( sr );
+                            lexerGrammar.ImportTokenVocabulary( grammar );
+                            lexerGrammar.ParseAndBuildAST( sr );

sr.Close();

-                            lexerGrammar.composite.assignTokenTypes();
-                            lexerGrammar.composite.defineGrammarSymbols();
-                            lexerGrammar.composite.createNFAs();
+                            lexerGrammar.composite.AssignTokenTypes();
+                            lexerGrammar.composite.DefineGrammarSymbols();
+                            lexerGrammar.composite.CreateNFAs();

GenerateRecognizer( lexerGrammar );
}
@@ -558,18 +558,18 @@ namespace Antlr3
{
if ( exceptionWhenWritingLexerFile )
{
-                        ErrorManager.error( ErrorManager.MSG_CANNOT_WRITE_FILE,
+                        ErrorManager.Error( ErrorManager.MSG_CANNOT_WRITE_FILE,
lexerGrammarFileName, e );
}
else
{
-                        ErrorManager.error( ErrorManager.MSG_CANNOT_OPEN_FILE,
+                        ErrorManager.Error( ErrorManager.MSG_CANNOT_OPEN_FILE,
grammarFileName );
}
}
catch ( Exception e )
{
-                    ErrorManager.error( ErrorManager.MSG_INTERNAL_ERROR, grammarFileName, e );
+                    ErrorManager.Error( ErrorManager.MSG_INTERNAL_ERROR, grammarFileName, e );
}
#if false
finally
@@ -590,9 +590,9 @@ namespace Antlr3
foreach ( string gfile in GrammarFileNames )
{
GrammarSpelunker grammar = new GrammarSpelunker( inputDirectory, gfile );
-                grammar.parse();
-                string vocabName = grammar.getTokenVocab();
-                string grammarName = grammar.getGrammarName();
+                grammar.Parse();
+                string vocabName = grammar.TokenVocab;
+                string grammarName = grammar.GrammarName;
// Make all grammars depend on any tokenVocab options
if ( vocabName != null )
g.AddEdge( gfile, vocabName + CodeGenerator.VOCAB_FILE_EXTENSION );
@@ -622,7 +622,7 @@ namespace Antlr3
Grammar grammar = new Grammar( this, grammarFileName, composite );
if ( TestMode )
grammar.DefaultRuleModifier = "public";
-            composite.setDelegationRoot( grammar );
+            composite.SetDelegationRoot( grammar );

string f = null;

@@ -651,7 +651,7 @@ namespace Antlr3
}

StringReader reader = new StringReader( System.IO.File.ReadAllText( f ) );
-            grammar.parseAndBuildAST( reader );
+            grammar.ParseAndBuildAST( reader );
composite.watchNFAConversion = internalOption_watchNFAConversion;
return grammar;
}
@@ -665,11 +665,11 @@ namespace Antlr3
*/
protected virtual void GenerateRecognizer( Grammar grammar )
{
-            string language = (string)grammar.getOption( "language" );
+            string language = (string)grammar.GetOption( "language" );
if ( language != null )
{
CodeGenerator generator = new CodeGenerator( this, grammar, language );
-                grammar.setCodeGenerator( generator );
+                grammar.CodeGenerator = generator;
generator.Debug = Debug;
generator.Profile = Profile;
generator.Trace = Trace;
@@ -688,7 +688,7 @@ namespace Antlr3
GenerateDFAs( grammar );
}

-                IList<Grammar> delegates = grammar.getDirectDelegates();
+                IList<Grammar> delegates = grammar.GetDirectDelegates();
for ( int i = 0; delegates != null && i < delegates.Count; i++ )
{
Grammar @delegate = (Grammar)delegates[i];
@@ -705,13 +705,13 @@ namespace Antlr3
{
for ( int d = 1; d <= g.NumberOfDecisions; d++ )
{
-                DFA dfa = g.getLookaheadDFA( d );
+                DFA dfa = g.GetLookaheadDFA( d );
if ( dfa == null )
{
continue; // not there for some reason, ignore
}
DOTGenerator dotGenerator = new DOTGenerator( g );
-                string dot = dotGenerator.getDOT( dfa.startState );
+                string dot = dotGenerator.GetDOT( dfa.startState );
string dotFileName = g.name + "." + "dec-" + d;
if ( g.implicitLexer )
{
@@ -723,7 +723,7 @@ namespace Antlr3
}
catch ( IOException ioe )
{
-                    ErrorManager.error( ErrorManager.MSG_CANNOT_GEN_DOT_FILE,
+                    ErrorManager.Error( ErrorManager.MSG_CANNOT_GEN_DOT_FILE,
dotFileName,
ioe );
}
@@ -733,14 +733,14 @@ namespace Antlr3
protected virtual void GenerateNFAs( Grammar g )
{
DOTGenerator dotGenerator = new DOTGenerator( g );
-            ICollection<Rule> rules = g.getAllImportedRules();
+            ICollection<Rule> rules = g.GetAllImportedRules();
rules.addAll( g.Rules );

foreach ( Rule r in rules )
{
try
{
-                    string dot = dotGenerator.getDOT( r.startState );
+                    string dot = dotGenerator.GetDOT( r.startState );
if ( dot != null )
{
WriteDOTFile( g, r, dot );
@@ -748,7 +748,7 @@ namespace Antlr3
}
catch ( IOException ioe )
{
-                    ErrorManager.error( ErrorManager.MSG_CANNOT_WRITE_FILE, ioe );
+                    ErrorManager.Error( ErrorManager.MSG_CANNOT_WRITE_FILE, ioe );
}
}
}
@@ -767,7 +767,7 @@ namespace Antlr3

private static void Version()
{
-            ErrorManager.info( "ANTLR Parser Generator  Version " + new AntlrTool().VERSION );
+            ErrorManager.Info( "ANTLR Parser Generator  Version " + new AntlrTool().VERSION );
}

private static void Help()
@@ -1344,11 +1344,11 @@ namespace Antlr3
{
get
{
-                return ErrorManager.getMessageFormat().ToString();
+                return ErrorManager.GetMessageFormat().ToString();
}
set
{
-                ErrorManager.setFormat( value );
+                ErrorManager.SetFormat( value );
}
}

@@ -1360,7 +1360,7 @@ namespace Antlr3
{
get
{
-                return ErrorManager.getNumErrors();
+                return ErrorManager.GetNumErrors();
}
}

diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index b75b3d4..e9e4db2 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -298,7 +298,7 @@ namespace Antlr3.Codegen

if ( targetType == null )
{
-                        ErrorManager.error( ErrorManager.MSG_CANNOT_CREATE_TARGET_GENERATOR, targetName );
+                        ErrorManager.Error( ErrorManager.MSG_CANNOT_CREATE_TARGET_GENERATOR, targetName );
return;
}
}
@@ -318,7 +318,7 @@ namespace Antlr3.Codegen
//JSystem.@out.println("targets="+templateDirs.toString());
IStringTemplateGroupLoader loader =
new CommonGroupLoader( templateDirs,
-                                      ErrorManager.getStringTemplateErrorListener() );
+                                      ErrorManager.GetStringTemplateErrorListener() );
StringTemplateGroup.RegisterGroupLoader( loader );
StringTemplateGroup.RegisterDefaultLexer( typeof( AngleBracketTemplateLexer ) );

@@ -328,14 +328,14 @@ namespace Antlr3.Codegen
baseTemplates = coreTemplates;
if ( coreTemplates == null )
{
-                ErrorManager.error( ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES,
+                ErrorManager.Error( ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES,
language );
return;
}

// dynamically add subgroups that act like filters to apply to
// their supergroup.  E.g., Java:Dbg:AST:ASTParser::ASTDbg.
-            string outputOption = (string)grammar.getOption( "output" );
+            string outputOption = (string)grammar.GetOption( "output" );
if ( outputOption != null && outputOption.Equals( "AST" ) )
{
if ( debug && grammar.type != Grammar.LEXER )
@@ -439,7 +439,7 @@ namespace Antlr3.Codegen
}

// CREATE NFA FROM GRAMMAR, CREATE DFA FROM NFA
-            if ( ErrorManager.doNotAttemptAnalysis() )
+            if ( ErrorManager.DoNotAttemptAnalysis() )
{
return null;
}
@@ -447,7 +447,7 @@ namespace Antlr3.Codegen


// some grammar analysis errors will not yield reliable DFA
-            if ( ErrorManager.doNotAttemptCodeGen() )
+            if ( ErrorManager.DoNotAttemptCodeGen() )
{
return null;
}
@@ -471,9 +471,9 @@ namespace Antlr3.Codegen
headerFileST.Name = "dummy-header-file";
}

-            bool filterMode = grammar.getOption( "filter" ) != null &&
-                                  grammar.getOption( "filter" ).Equals( "true" );
-            bool canBacktrack = grammar.composite.getRootGrammar().atLeastOneBacktrackOption ||
+            bool filterMode = grammar.GetOption( "filter" ) != null &&
+                                  grammar.GetOption( "filter" ).Equals( "true" );
+            bool canBacktrack = grammar.composite.GetRootGrammar().atLeastOneBacktrackOption ||
grammar.SyntacticPredicates != null ||
filterMode;

@@ -495,7 +495,7 @@ namespace Antlr3.Codegen
// level 1 not 0.
gateST = templates.GetInstanceOf( "filteringActionGate" );
}
-            grammar.setSynPredGateIfNotAlready( gateST );
+            grammar.SetSynPredGateIfNotAlready( gateST );

headerFileST.SetAttribute( "actions", actions );
outputFileST.SetAttribute( "actions", actions );
@@ -513,7 +513,7 @@ namespace Antlr3.Codegen
// turn on memoize attribute at grammar level so we can create ruleMemo.
// each rule has memoize attr that hides this one, indicating whether
// it needs to save results
-            string memoize = (string)grammar.getOption( "memoize" );
+            string memoize = (string)grammar.GetOption( "memoize" );
outputFileST.SetAttribute( "memoize",
( grammar.atLeastOneRuleMemoizes ||
( memoize != null && memoize.Equals( "true" ) ) &&
@@ -555,9 +555,9 @@ namespace Antlr3.Codegen
outputFileST.SetAttribute( "recognizer", recognizerST );
headerFileST.SetAttribute( "recognizer", recognizerST );
outputFileST.SetAttribute( "actionScope",
-                                      grammar.getDefaultActionScope( grammar.type ) );
+                                      grammar.GetDefaultActionScope( grammar.type ) );
headerFileST.SetAttribute( "actionScope",
-                                      grammar.getDefaultActionScope( grammar.type ) );
+                                      grammar.GetDefaultActionScope( grammar.type ) );

string targetAppropriateFileNameString =
target.GetTargetStringLiteralFromString( grammar.FileName );
@@ -583,7 +583,7 @@ namespace Antlr3.Codegen
}
catch ( RecognitionException re )
{
-                    ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                    ErrorManager.Error( ErrorManager.MSG_BAD_AST_STRUCTURE,
re );
}
}
@@ -632,7 +632,7 @@ namespace Antlr3.Codegen
}
catch ( IOException ioe )
{
-                ErrorManager.error( ErrorManager.MSG_CANNOT_WRITE_FILE,
+                ErrorManager.Error( ErrorManager.MSG_CANNOT_WRITE_FILE,
VocabFileName,
ioe );
}
@@ -658,7 +658,7 @@ namespace Antlr3.Codegen
// get any action from the scope to get error location
var scopeActions = action.Value;
GrammarAST actionAST = scopeActions.Values.Cast<GrammarAST>().First();
-                    ErrorManager.grammarError(
+                    ErrorManager.GrammarError(
ErrorManager.MSG_INVALID_ACTION_SCOPE, grammar,
actionAST.Token, scope,
grammar.GrammarTypeString );
@@ -733,12 +733,12 @@ namespace Antlr3.Codegen
{
// compute follow for this element and, as side-effect, track
// the rule LOOK sensitivity.
-                follow = grammar.FIRST( followingNFAState );
+                follow = grammar.First( followingNFAState );
}

if ( follow == null )
{
-                ErrorManager.internalError( "no follow state or cannot compute follow" );
+                ErrorManager.InternalError( "no follow state or cannot compute follow" );
follow = new LookaheadSet();
}
if ( follow.Member( Label.EOF ) )
@@ -999,7 +999,7 @@ namespace Antlr3.Codegen
// make constants for the token types
foreach ( string tokenID in grammar.TokenIDs )
{
-                int tokenType = grammar.getTokenType( tokenID );
+                int tokenType = grammar.GetTokenType( tokenID );
if ( tokenType == Label.EOF ||
tokenType >= Label.MIN_TOKEN_TYPE )
{
@@ -1016,7 +1016,7 @@ namespace Antlr3.Codegen
{
for ( int t = Label.MIN_TOKEN_TYPE; t <= grammar.MaxTokenType; t++ )
{
-                string tokenName = grammar.getTokenDisplayName( t );
+                string tokenName = grammar.GetTokenDisplayName( t );
if ( tokenName != null )
{
tokenName = target.GetTargetStringLiteralFromString( tokenName, true );
@@ -1039,7 +1039,7 @@ namespace Antlr3.Codegen
{
if ( grammar.type == Grammar.LEXER )
{
-                string name = grammar.getTokenDisplayName( ttype );
+                string name = grammar.GetTokenDisplayName( ttype );
return target.GetTargetCharLiteralFromANTLRCharLiteral( this, name );
}
return target.GetTokenTypeAsTargetLabel( this, ttype );
@@ -1061,7 +1061,7 @@ namespace Antlr3.Codegen
// make constants for the token names
foreach ( string tokenID in grammar.TokenIDs )
{
-                int tokenType = grammar.getTokenType( tokenID );
+                int tokenType = grammar.GetTokenType( tokenID );
if ( tokenType >= Label.MIN_TOKEN_TYPE )
{
vocabFileST.SetAttribute( "tokens.{name,type}", tokenID, tokenType );
@@ -1071,7 +1071,7 @@ namespace Antlr3.Codegen
// now dump the strings
foreach ( string literal in grammar.StringLiterals )
{
-                int tokenType = grammar.getTokenType( literal );
+                int tokenType = grammar.GetTokenType( literal );
if ( tokenType >= Label.MIN_TOKEN_TYPE )
{
vocabFileST.SetAttribute( "tokens.{name,type}", literal, tokenType );
@@ -1089,7 +1089,7 @@ namespace Antlr3.Codegen
return TranslateArgAction( ruleName, actionTree );
}
ActionTranslator translator = new ActionTranslator( this, ruleName, actionTree );
-            IList chunks = translator.translateToChunks();
+            IList chunks = translator.TranslateToChunks();
chunks = target.PostProcessAction( chunks, actionTree.token );
return chunks;
}
@@ -1115,7 +1115,7 @@ namespace Antlr3.Codegen
new ActionTranslator( this, ruleName,
actionToken,
actionTree.outerAltNum );
-                    IList chunks = translator.translateToChunks();
+                    IList chunks = translator.TranslateToChunks();
chunks = target.PostProcessAction( chunks, actionToken );
StringTemplate catST = new StringTemplate( templates, "<chunks>" );
catST.SetAttribute( "chunks", chunks );
@@ -1270,21 +1270,21 @@ namespace Antlr3.Codegen
}
catch ( RecognitionException /*re*/ )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
+                    ErrorManager.GrammarError( ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
grammar,
actionToken,
templateActionText );
}
catch ( Exception tse )
{
-                    ErrorManager.internalError( "can't parse template action", tse );
+                    ErrorManager.InternalError( "can't parse template action", tse );
}
}

{
// then translate via codegen.g
CodeGenTreeWalker gen = new CodeGenTreeWalker( new Antlr.Runtime.Tree.CommonTreeNodeStream( rewriteTree ) );
-                gen.init( grammar );
+                gen.Init( grammar );
gen.currentRuleName = ruleName;
gen.outerAltNum = outerAltNum;
StringTemplate st = null;
@@ -1294,7 +1294,7 @@ namespace Antlr3.Codegen
}
catch ( RecognitionException re )
{
-                    ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                    ErrorManager.Error( ErrorManager.MSG_BAD_AST_STRUCTURE,
re );
}
return st;
@@ -1309,8 +1309,8 @@ namespace Antlr3.Codegen
int outerAltNum )
{
//JSystem.@out.println("error $"+x+"::"+y);
-            Rule r = grammar.getRule( x );
-            AttributeScope scope = grammar.getGlobalScope( x );
+            Rule r = grammar.GetRule( x );
+            AttributeScope scope = grammar.GetGlobalScope( x );
if ( scope == null )
{
if ( r != null )
@@ -1320,14 +1320,14 @@ namespace Antlr3.Codegen
}
if ( scope == null )
{
-                ErrorManager.grammarError( ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
+                ErrorManager.GrammarError( ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
grammar,
actionToken,
x );
}
-            else if ( scope.getAttribute( y ) == null )
+            else if ( scope.GetAttribute( y ) == null )
{
-                ErrorManager.grammarError( ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE,
+                ErrorManager.GrammarError( ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE,
grammar,
actionToken,
x,
@@ -1345,7 +1345,7 @@ namespace Antlr3.Codegen
if ( enclosingRule == null )
{
// action not in a rule
-                ErrorManager.grammarError( ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE,
+                ErrorManager.GrammarError( ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE,
grammar,
actionToken,
x,
@@ -1354,21 +1354,21 @@ namespace Antlr3.Codegen
}

// action is in a rule
-            Grammar.LabelElementPair label = enclosingRule.getRuleLabel( x );
+            Grammar.LabelElementPair label = enclosingRule.GetRuleLabel( x );

-            if ( label != null || enclosingRule.getRuleRefsInAlt( x, outerAltNum ) != null )
+            if ( label != null || enclosingRule.GetRuleRefsInAlt( x, outerAltNum ) != null )
{
// $rulelabel.attr or $ruleref.attr; must be unknown attr
string refdRuleName = x;
if ( label != null )
{
-                    refdRuleName = enclosingRule.getRuleLabel( x ).referencedRuleName;
+                    refdRuleName = enclosingRule.GetRuleLabel( x ).referencedRuleName;
}
-                Rule refdRule = grammar.getRule( refdRuleName );
-                AttributeScope scope = refdRule.getAttributeScope( y );
+                Rule refdRule = grammar.GetRule( refdRuleName );
+                AttributeScope scope = refdRule.GetAttributeScope( y );
if ( scope == null )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_UNKNOWN_RULE_ATTRIBUTE,
+                    ErrorManager.GrammarError( ErrorManager.MSG_UNKNOWN_RULE_ATTRIBUTE,
grammar,
actionToken,
refdRuleName,
@@ -1376,7 +1376,7 @@ namespace Antlr3.Codegen
}
else if ( scope.isParameterScope )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_INVALID_RULE_PARAMETER_REF,
+                    ErrorManager.GrammarError( ErrorManager.MSG_INVALID_RULE_PARAMETER_REF,
grammar,
actionToken,
refdRuleName,
@@ -1384,7 +1384,7 @@ namespace Antlr3.Codegen
}
else if ( scope.isDynamicRuleScope )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_INVALID_RULE_SCOPE_ATTRIBUTE_REF,
+                    ErrorManager.GrammarError( ErrorManager.MSG_INVALID_RULE_SCOPE_ATTRIBUTE_REF,
grammar,
actionToken,
refdRuleName,
@@ -1403,7 +1403,7 @@ namespace Antlr3.Codegen
if ( enclosingRule == null )
{
// action not in a rule
-                ErrorManager.grammarError( ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE,
+                ErrorManager.GrammarError( ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE,
grammar,
actionToken,
x );
@@ -1411,28 +1411,28 @@ namespace Antlr3.Codegen
}

// action is in a rule
-            Grammar.LabelElementPair label = enclosingRule.getRuleLabel( x );
-            AttributeScope scope = enclosingRule.getAttributeScope( x );
+            Grammar.LabelElementPair label = enclosingRule.GetRuleLabel( x );
+            AttributeScope scope = enclosingRule.GetAttributeScope( x );

if ( label != null ||
-                 enclosingRule.getRuleRefsInAlt( x, outerAltNum ) != null ||
+                 enclosingRule.GetRuleRefsInAlt( x, outerAltNum ) != null ||
enclosingRule.name.Equals( x ) )
{
-                ErrorManager.grammarError( ErrorManager.MSG_ISOLATED_RULE_SCOPE,
+                ErrorManager.GrammarError( ErrorManager.MSG_ISOLATED_RULE_SCOPE,
grammar,
actionToken,
x );
}
else if ( scope != null && scope.isDynamicRuleScope )
{
-                ErrorManager.grammarError( ErrorManager.MSG_ISOLATED_RULE_ATTRIBUTE,
+                ErrorManager.GrammarError( ErrorManager.MSG_ISOLATED_RULE_ATTRIBUTE,
grammar,
actionToken,
x );
}
else
{
-                ErrorManager.grammarError( ErrorManager.MSG_UNKNOWN_SIMPLE_ATTRIBUTE,
+                ErrorManager.GrammarError( ErrorManager.MSG_UNKNOWN_SIMPLE_ATTRIBUTE,
grammar,
actionToken,
x );
@@ -1447,7 +1447,7 @@ namespace Antlr3.Codegen
public virtual string GetRecognizerFileName( string name, int type )
{
StringTemplate extST = templates.GetInstanceOf( "codeFileExtension" );
-            string recognizerName = grammar.getRecognizerName();
+            string recognizerName = grammar.GetRecognizerName();
return recognizerName + extST.ToString();
/*
String suffix = "";
diff --git a/Antlr3/Codegen/Target.cs b/Antlr3/Codegen/Target.cs
index a2205d0..2f3bf3a 100644
--- a/Antlr3/Codegen/Target.cs
+++ b/Antlr3/Codegen/Target.cs
@@ -114,10 +114,10 @@ namespace Antlr3.Codegen
Grammar grammar )
{
// Build NFAs from the grammar AST
-            grammar.buildNFA();
+            grammar.BuildNFA();

// Create the DFA predictors for each decision
-            grammar.createLookaheadDFAs();
+            grammar.CreateLookaheadDFAs();
}

/** Is scope in @scope::name {action} valid for this kind of grammar?
@@ -165,7 +165,7 @@ namespace Antlr3.Codegen
/** Target must be able to override the labels used for token types */
public virtual string GetTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
{
-            string name = generator.grammar.getTokenDisplayName( ttype );
+            string name = generator.grammar.GetTokenDisplayName( ttype );
// If name is a literal, return the token type instead
if ( name[0] == '\'' )
{
@@ -189,7 +189,7 @@ namespace Antlr3.Codegen
{
StringBuilder buf = new StringBuilder();
buf.Append( '\'' );
-            int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
+            int c = Grammar.GetCharValueFromGrammarCharLiteral( literal );
if ( c < Label.MIN_CHAR_VALUE )
{
return "'\u0000'";
diff --git a/Antlr3/Grammars/ANTLR.g3 b/Antlr3/Grammars/ANTLR.g3
index f2158ab..f586d4c 100644
--- a/Antlr3/Grammars/ANTLR.g3
+++ b/Antlr3/Grammars/ANTLR.g3
@@ -198,13 +198,13 @@ grammar_![Grammar g]
}
@after
{
-	cleanup( $tree );
+	Cleanup( $tree );
}
:	//hdr:headerSpec
( ACTION )?
( cmt=DOC_COMMENT  )?
-		gr=grammarType gid=id {Grammar.setName($gid.text);} SEMI
-		(	optionsSpec {opts = $optionsSpec.opts; Grammar.setOptions(opts, $optionsSpec.start);}
+		gr=grammarType gid=id {Grammar.SetName($gid.text);} SEMI
+		(	optionsSpec {opts = $optionsSpec.opts; Grammar.SetOptions(opts, $optionsSpec.start);}
)?
(ig=delegateGrammars)?
(ts=tokensSpec)?
@@ -277,8 +277,8 @@ delegateGrammars
;

delegateGrammar
-	:	lab=id ASSIGN^ g=id {Grammar.importGrammar($g.tree, $lab.text);}
-	|	g2=id               {Grammar.importGrammar($g2.tree,null);}
+	:	lab=id ASSIGN^ g=id {Grammar.ImportGrammar($g.tree, $lab.text);}
+	|	g2=id               {Grammar.ImportGrammar($g2.tree,null);}
;

tokensSpec
@@ -352,7 +352,7 @@ rule
EOR[$SEMI,"<end-of-rule>"])
)
{
-		((GrammarAST)$tree.GetChild(0)).setBlockOptions( $optionsSpec.opts );
+		((GrammarAST)$tree.GetChild(0)).BlockOptions = $optionsSpec.opts;
}
;

@@ -390,7 +390,7 @@ block
// 2nd alt and optional branch ambig due to
// linear approx LL(2) issue.  COLON ACTION
// matched correctly in 2nd alt.
-			(optionsSpec {((GrammarAST)$tree.GetChild(0)).setOptions(Grammar,$optionsSpec.opts);})?
+			(optionsSpec {((GrammarAST)$tree.GetChild(0)).SetOptions(Grammar,$optionsSpec.opts);})?
( ruleActions )?
COLON
|	ACTION COLON
@@ -400,13 +400,13 @@ block
{
stream_alternative.Add( $r.tree );
if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
-				prefixWithSynPred($a.tree);
+				PrefixWithSynPred($a.tree);
}
(	OR a=alternative r=rewrite
{
stream_alternative.Add( $r.tree );
if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
-					prefixWithSynPred($a.tree);
+					PrefixWithSynPred($a.tree);
}
)*

@@ -424,15 +424,15 @@ altList[IDictionary<string, object> opts]
:	( -> BLOCK[$start,"BLOCK"] )
{
blkRoot = (GrammarAST)$tree.GetChild(0);
-			blkRoot.setBlockOptions( $opts );
+			blkRoot.BlockOptions = $opts;
currentBlockAST = blkRoot;
}
(	a1=alternative r1=rewrite
-			{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred($a1.tree);}
+			{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred($a1.tree);}
-> $a1 $r1?
)
(	OR a2=alternative r2=rewrite
-			{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred($a2.tree);}
+			{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred($a2.tree);}
-> $altList $a2 $r2?
)*
-> ^({blkRoot} $altList EOB["<end-of-block>"])
@@ -550,7 +550,7 @@ ebnf
// ignore for lexer rules in combined
-> {GrammarType == COMBINED_GRAMMAR && char.IsUpper(currentRuleName[0])}? ^(SYNPRED[$start,"=>"] block)
// create manually specified (...)=> predicate; convert to sempred
-			-> {createSynSemPredFromBlock($block.tree, SYN_SEMPRED)}
+			-> {CreateSynSemPredFromBlock($block.tree, SYN_SEMPRED)}
|	ROOT
-> ^(ROOT block)
|	BANG
@@ -579,7 +579,7 @@ terminal
{
if ( atTreeRoot )
{
-				ErrorManager.syntaxError(
+				ErrorManager.SyntaxError(
ErrorManager.MSG_WILDCARD_AS_ROOT,Grammar,$wi,null,null);
}
}
@@ -596,14 +596,14 @@ defaultNodeOption[GrammarAST terminalAST]
StringBuffer buf = new StringBuffer();
}
:	i=id {buf.Append($i.text);} (WILDCARD i2=id {buf.Append("."+$i2.text);})*
-		{terminalAST.setTerminalOption(Grammar,Grammar.defaultTokenOption,buf.ToString());}
+		{terminalAST.SetTerminalOption(Grammar,Grammar.defaultTokenOption,buf.ToString());}
;

elementOption[GrammarAST terminalAST]
:	a=id ASSIGN^ (b=id|s=STRING_LITERAL)
{
object v = ($b.tree!=null)?$b.text:$s.text;
-		terminalAST.setTerminalOption(Grammar,$a.text,v);
+		terminalAST.SetTerminalOption(Grammar,$a.text,v);
}
;

@@ -627,7 +627,7 @@ currentBlockAST = save;
{
alt = (GrammarAST)$tree.GetChild(0);
if ( !inRewrite )
-				prefixWithSynPred(alt);
+				PrefixWithSynPred(alt);
}
(	QUESTION
-> OPTIONAL[$elemAST.Token,"?"]
@@ -907,7 +907,7 @@ DOLLAR : '$' ;
STRAY_BRACKET
:	']'
{
-			ErrorManager.syntaxError(
+			ErrorManager.SyntaxError(
ErrorManager.MSG_SYNTAX_ERROR,
null,
state.token,
@@ -923,7 +923,7 @@ CHAR_LITERAL
)*
'\''
{
-			StringBuffer s = Grammar.getUnescapedStringFromGrammarStringLiteral($text);
+			StringBuffer s = Grammar.GetUnescapedStringFromGrammarStringLiteral($text);
if ( s.Length > 1 )
{
$type = STRING_LITERAL;
diff --git a/Antlr3/Grammars/ANTLRLexer.cs b/Antlr3/Grammars/ANTLRLexer.cs
index 40de780..c35d572 100644
--- a/Antlr3/Grammars/ANTLRLexer.cs
+++ b/Antlr3/Grammars/ANTLRLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-04-10 15:22:15
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-04-16 21:27:00

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -1590,7 +1590,7 @@ public partial class ANTLRLexer : Lexer
if ( state.backtracking == 0 )
{

-							ErrorManager.syntaxError(
+							ErrorManager.SyntaxError(
ErrorManager.MSG_SYNTAX_ERROR,
null,
state.token,
@@ -1668,7 +1668,7 @@ public partial class ANTLRLexer : Lexer
if ( state.backtracking == 0 )
{

-							StringBuffer s = Grammar.getUnescapedStringFromGrammarStringLiteral(Text);
+							StringBuffer s = Grammar.GetUnescapedStringFromGrammarStringLiteral(Text);
if ( s.Length > 1 )
{
_type = STRING_LITERAL;
diff --git a/Antlr3/Grammars/ANTLRParser.cs b/Antlr3/Grammars/ANTLRParser.cs
index 533efac..a7bf467 100644
--- a/Antlr3/Grammars/ANTLRParser.cs
+++ b/Antlr3/Grammars/ANTLRParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-04-10 15:22:14
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-04-16 21:26:59

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -325,7 +325,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_id.Add(gid.Tree);
if ( state.backtracking == 0 )
{
-				Grammar.setName((gid!=null?input.ToString(gid.start,gid.stop):null));
+				Grammar.SetName((gid!=null?input.ToString(gid.start,gid.stop):null));
}
SEMI2=(IToken)Match(input,SEMI,Follow._SEMI_in_grammar_337); if (state.failed) return retval;
if ( state.backtracking == 0 ) stream_SEMI.Add(SEMI2);
@@ -351,7 +351,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec3.Tree);
if ( state.backtracking == 0 )
{
-					opts = (optionsSpec3!=null?optionsSpec3.opts:default(IDictionary<string, object>)); Grammar.setOptions(opts, (optionsSpec3!=null?((IToken)optionsSpec3.start):null));
+					opts = (optionsSpec3!=null?optionsSpec3.opts:default(IDictionary<string, object>)); Grammar.SetOptions(opts, (optionsSpec3!=null?((IToken)optionsSpec3.start):null));
}

}
@@ -545,7 +545,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-					cleanup( ((GrammarAST)retval.tree) );
+					Cleanup( ((GrammarAST)retval.tree) );

}
}
@@ -1790,7 +1790,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) adaptor.AddChild(root_0, g.Tree);
if ( state.backtracking == 0 )
{
-					Grammar.importGrammar((g!=null?((GrammarAST)g.tree):null), (lab!=null?input.ToString(lab.start,lab.stop):null));
+					Grammar.ImportGrammar((g!=null?((GrammarAST)g.tree):null), (lab!=null?input.ToString(lab.start,lab.stop):null));
}

}
@@ -1808,7 +1808,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) adaptor.AddChild(root_0, g2.Tree);
if ( state.backtracking == 0 )
{
-					Grammar.importGrammar((g2!=null?((GrammarAST)g2.tree):null),null);
+					Grammar.ImportGrammar((g2!=null?((GrammarAST)g2.tree):null),null);
}

}
@@ -2827,7 +2827,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-						((GrammarAST)((GrammarAST)retval.tree).GetChild(0)).setBlockOptions( (optionsSpec45!=null?optionsSpec45.opts:default(IDictionary<string, object>)) );
+						((GrammarAST)((GrammarAST)retval.tree).GetChild(0)).BlockOptions = (optionsSpec45!=null?optionsSpec45.opts:default(IDictionary<string, object>));

}

@@ -3460,7 +3460,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec64.Tree);
if ( state.backtracking == 0 )
{
-						((GrammarAST)((GrammarAST)retval.tree).GetChild(0)).setOptions(Grammar,(optionsSpec64!=null?optionsSpec64.opts:default(IDictionary<string, object>)));
+						((GrammarAST)((GrammarAST)retval.tree).GetChild(0)).SetOptions(Grammar,(optionsSpec64!=null?optionsSpec64.opts:default(IDictionary<string, object>)));
}

}
@@ -3531,7 +3531,7 @@ public partial class ANTLRParser : Parser

stream_alternative.Add( (r!=null?((GrammarAST)r.tree):null) );
if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
-								prefixWithSynPred((a!=null?((GrammarAST)a.tree):null));
+								PrefixWithSynPred((a!=null?((GrammarAST)a.tree):null));

}
// Grammars\\ANTLR.g3:405:3: ( OR a= alternative r= rewrite )*
@@ -3571,7 +3571,7 @@ public partial class ANTLRParser : Parser

stream_alternative.Add( (r!=null?((GrammarAST)r.tree):null) );
if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
-											prefixWithSynPred((a!=null?((GrammarAST)a.tree):null));
+											PrefixWithSynPred((a!=null?((GrammarAST)a.tree):null));

}

@@ -3748,7 +3748,7 @@ public partial class ANTLRParser : Parser
{

blkRoot = (GrammarAST)((GrammarAST)retval.tree).GetChild(0);
-							blkRoot.setBlockOptions( opts );
+							blkRoot.BlockOptions = opts;
currentBlockAST = blkRoot;

}
@@ -3769,7 +3769,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_rewrite.Add(r1.Tree);
if ( state.backtracking == 0 )
{
-				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred((a1!=null?((GrammarAST)a1.tree):null));
+				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a1!=null?((GrammarAST)a1.tree):null));
}


@@ -3841,7 +3841,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_rewrite.Add(r2.Tree);
if ( state.backtracking == 0 )
{
-						if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred((a2!=null?((GrammarAST)a2.tree):null));
+						if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a2!=null?((GrammarAST)a2.tree):null));
}


@@ -6125,7 +6125,7 @@ public partial class ANTLRParser : Parser
}
else // 553:4: ->
{
-					adaptor.AddChild(root_0, createSynSemPredFromBlock((block117!=null?((GrammarAST)block117.tree):null), SYN_SEMPRED));
+					adaptor.AddChild(root_0, CreateSynSemPredFromBlock((block117!=null?((GrammarAST)block117.tree):null), SYN_SEMPRED));

}

@@ -6764,7 +6764,7 @@ public partial class ANTLRParser : Parser

if ( atTreeRoot )
{
-									ErrorManager.syntaxError(
+									ErrorManager.SyntaxError(
ErrorManager.MSG_WILDCARD_AS_ROOT,Grammar,wi,null,null);
}

@@ -7082,7 +7082,7 @@ public partial class ANTLRParser : Parser

if ( state.backtracking == 0 )
{
-				terminalAST.setTerminalOption(Grammar,Grammar.defaultTokenOption,buf.ToString());
+				terminalAST.SetTerminalOption(Grammar,Grammar.defaultTokenOption,buf.ToString());
}

}
@@ -7201,7 +7201,7 @@ public partial class ANTLRParser : Parser
{

object v = ((b!=null?((GrammarAST)b.tree):null)!=null)?(b!=null?input.ToString(b.start,b.stop):null):(s!=null?s.Text:null);
-						terminalAST.setTerminalOption(Grammar,(a!=null?input.ToString(a.start,a.stop):null),v);
+						terminalAST.SetTerminalOption(Grammar,(a!=null?input.ToString(a.start,a.stop):null),v);

}

@@ -7345,7 +7345,7 @@ public partial class ANTLRParser : Parser

alt = (GrammarAST)((GrammarAST)retval.tree).GetChild(0);
if ( !inRewrite )
-								prefixWithSynPred(alt);
+								PrefixWithSynPred(alt);

}
// Grammars\\ANTLR.g3:632:3: ( QUESTION -> OPTIONAL[$elemAST.Token,\"?\"] | STAR -> CLOSURE[$elemAST.Token,\"*\"] | PLUS -> POSITIVE_CLOSURE[$elemAST.Token,\"+\"] )
diff --git a/Antlr3/Grammars/ANTLRParserHelper.cs b/Antlr3/Grammars/ANTLRParserHelper.cs
index 0088d6b..49a32e4 100644
--- a/Antlr3/Grammars/ANTLRParserHelper.cs
+++ b/Antlr3/Grammars/ANTLRParserHelper.cs
@@ -213,7 +213,7 @@ namespace Antlr3.Grammars
TreeAdaptor = new grammar_Adaptor( this );
}

-        protected virtual GrammarAST setToBlockWithSet( GrammarAST b )
+        protected virtual GrammarAST SetToBlockWithSet( GrammarAST b )
{
/*
* alt = ^(ALT["ALT"] {b} EOA["EOA"])
@@ -224,7 +224,7 @@ namespace Antlr3.Grammars
adaptor.AddChild( alt, b );
adaptor.AddChild( alt, adaptor.Create( EOA, "<end-of-alt>" ) );

-            prefixWithSynPred( alt );
+            PrefixWithSynPred( alt );

GrammarAST block = (GrammarAST)adaptor.Create( BLOCK, "BLOCK" );
adaptor.AddChild( block, alt );
@@ -236,12 +236,12 @@ namespace Antlr3.Grammars
/** Create a copy of the alt and make it into a BLOCK; all actions,
*  labels, tree operators, rewrites are removed.
*/
-        protected virtual GrammarAST createBlockFromDupAlt( GrammarAST alt )
+        protected virtual GrammarAST CreateBlockFromDupAlt( GrammarAST alt )
{
/*
* ^(BLOCK["BLOCK"] {GrammarAST.dupTreeNoActions(alt)} EOB["<end-of-block>"])
*/
-            GrammarAST nalt = GrammarAST.dupTreeNoActions( alt, null );
+            GrammarAST nalt = GrammarAST.DupTreeNoActions( alt, null );

GrammarAST block = (GrammarAST)adaptor.Create( BLOCK, "BLOCK" );
adaptor.AddChild( block, nalt );
@@ -254,13 +254,13 @@ namespace Antlr3.Grammars
*  (xxx)=>xxx
*  but only if they didn't specify one manually.
*/
-        protected virtual void prefixWithSynPred( GrammarAST alt )
+        protected virtual void PrefixWithSynPred( GrammarAST alt )
{
// if they want backtracking and it's not a lexer rule in combined grammar
-            string autoBacktrack = (string)Grammar.getBlockOption( currentBlockAST, "backtrack" );
+            string autoBacktrack = (string)Grammar.GetBlockOption( currentBlockAST, "backtrack" );
if ( autoBacktrack == null )
{
-                autoBacktrack = (string)Grammar.getOption( "backtrack" );
+                autoBacktrack = (string)Grammar.GetOption( "backtrack" );
}
if ( autoBacktrack != null && autoBacktrack.Equals( "true" ) &&
!( GrammarType == COMBINED_GRAMMAR &&
@@ -268,18 +268,18 @@ namespace Antlr3.Grammars
alt.GetChild( 0 ).Type != SYN_SEMPRED )
{
// duplicate alt and make a synpred block around that dup'd alt
-                GrammarAST synpredBlockAST = createBlockFromDupAlt( alt );
+                GrammarAST synpredBlockAST = CreateBlockFromDupAlt( alt );

// Create a BACKTRACK_SEMPRED node as if user had typed this in
// Effectively we replace (xxx)=>xxx with {synpredxxx}? xxx
-                GrammarAST synpredAST = createSynSemPredFromBlock( synpredBlockAST,
+                GrammarAST synpredAST = CreateSynSemPredFromBlock( synpredBlockAST,
BACKTRACK_SEMPRED );

// insert BACKTRACK_SEMPRED as first element of alt
//synpredAST.getLastSibling().setNextSibling( alt.getFirstChild() );
//synpredAST.addChild( alt.getFirstChild() );
//alt.setFirstChild( synpredAST );
-                GrammarAST[] children = alt.getChildrenAsArray();
+                GrammarAST[] children = alt.GetChildrenAsArray();
adaptor.SetChild( alt, 0, synpredAST );
for ( int i = 0; i < children.Length; i++ )
{
@@ -291,10 +291,10 @@ namespace Antlr3.Grammars
}
}

-        protected virtual GrammarAST createSynSemPredFromBlock( GrammarAST synpredBlockAST, int synpredTokenType )
+        protected virtual GrammarAST CreateSynSemPredFromBlock( GrammarAST synpredBlockAST, int synpredTokenType )
{
// add grammar fragment to a list so we can make fake rules for them later.
-            string predName = Grammar.defineSyntacticPredicate( synpredBlockAST, currentRuleName );
+            string predName = Grammar.DefineSyntacticPredicate( synpredBlockAST, currentRuleName );
// convert (alpha)=> into {synpredN}? where N is some pred count
// during code gen we convert to function call with templates
string synpredinvoke = predName;
@@ -304,7 +304,7 @@ namespace Antlr3.Grammars
return p;
}

-        public virtual GrammarAST createSimpleRuleAST( string name, GrammarAST block, bool fragment )
+        public virtual GrammarAST CreateSimpleRuleAST( string name, GrammarAST block, bool fragment )
{
GrammarAST modifier = null;
if ( fragment )
@@ -342,7 +342,7 @@ namespace Antlr3.Grammars
//    ErrorManager.internalError( "can't get token???", tse );
//}
IToken token = ex.token;
-            ErrorManager.syntaxError(
+            ErrorManager.SyntaxError(
ErrorManager.MSG_SYNTAX_ERROR,
Grammar,
token,
@@ -350,16 +350,16 @@ namespace Antlr3.Grammars
ex );
}

-        public virtual void cleanup( GrammarAST root )
+        public virtual void Cleanup( GrammarAST root )
{
if ( GrammarType == LEXER_GRAMMAR )
{
-                string filter = (string)Grammar.getOption( "filter" );
+                string filter = (string)Grammar.GetOption( "filter" );
GrammarAST tokensRuleAST =
-                    Grammar.addArtificialMatchTokensRule(
+                    Grammar.AddArtificialMatchTokensRule(
root,
Grammar.lexerRuleNamesInCombined,
-                        Grammar.getDelegateNames(),
+                        Grammar.GetDelegateNames(),
filter != null && filter.Equals( "true" ) );
}
}
diff --git a/Antlr3/Grammars/ANTLRTreePrinter.cs b/Antlr3/Grammars/ANTLRTreePrinter.cs
index bd44dd7..2acb02a 100644
--- a/Antlr3/Grammars/ANTLRTreePrinter.cs
+++ b/Antlr3/Grammars/ANTLRTreePrinter.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLRTreePrinter.g3 2009-03-23 17:53:59
+// $ANTLR 3.1.2 Grammars\\ANTLRTreePrinter.g3 2009-04-16 20:58:22

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -333,7 +333,7 @@ public partial class ANTLRTreePrinter : TreeParser

}

-			return normalize(buf.ToString());
+			return Normalize(buf.ToString());

}

@@ -1924,7 +1924,7 @@ public partial class ANTLRTreePrinter : TreeParser
retval.start = input.LT(1);


-		int numAlts = countAltsForBlock(((GrammarAST)retval.start));
+		int numAlts = CountAltsForBlock(((GrammarAST)retval.start));

try
{
@@ -3007,8 +3007,8 @@ public partial class ANTLRTreePrinter : TreeParser
spred=(GrammarAST)Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1333);

string name = (spred!=null?spred.Text:null);
-							GrammarAST predAST=grammar.getSyntacticPredicate(name);
-							block(predAST, true);
+							GrammarAST predAST=grammar.GetSyntacticPredicate(name);
+							Block(predAST, true);
@out("=>");


@@ -3732,6 +3732,7 @@ public partial class ANTLRTreePrinter : TreeParser
// $ANTLR end "ast_suffix"
#endregion Rules

+
#region Follow sets
public static class Follow
{
diff --git a/Antlr3/Grammars/ANTLRTreePrinter.g3 b/Antlr3/Grammars/ANTLRTreePrinter.g3
index 165a488..89d24d8 100644
--- a/Antlr3/Grammars/ANTLRTreePrinter.g3
+++ b/Antlr3/Grammars/ANTLRTreePrinter.g3
@@ -99,7 +99,7 @@ toString[Grammar g, bool showActions] returns [string s=null]
|	single_rewrite
|	EOR {s="EOR";}
)
-		{return normalize(buf.ToString());}
+		{return Normalize(buf.ToString());}
;

// --------------
@@ -245,7 +245,7 @@ ruleScopeSpec
block[bool forceParens]
@init
{
-int numAlts = countAltsForBlock($start);
+int numAlts = CountAltsForBlock($start);
}
:	^(	BLOCK
{
@@ -350,8 +350,8 @@ element
|	spred=SYN_SEMPRED
{
string name = $spred.text;
-			GrammarAST predAST=grammar.getSyntacticPredicate(name);
-			block(predAST, true);
+			GrammarAST predAST=grammar.GetSyntacticPredicate(name);
+			Block(predAST, true);
@out("=>");
}
|	^(BACKTRACK_SEMPRED .*) // don't print anything (auto backtrack stuff)
diff --git a/Antlr3/Grammars/ANTLRTreePrinterHelper.cs b/Antlr3/Grammars/ANTLRTreePrinterHelper.cs
index 0bb4fb5..e4ad768 100644
--- a/Antlr3/Grammars/ANTLRTreePrinterHelper.cs
+++ b/Antlr3/Grammars/ANTLRTreePrinterHelper.cs
@@ -45,12 +45,12 @@ namespace Antlr3.Grammars
protected bool showActions;
protected StringBuilder buf = new StringBuilder( 300 );

-        public ANTLRTreePrinter.block_return block( GrammarAST t, bool forceParens )
+        public ANTLRTreePrinter.block_return Block( GrammarAST t, bool forceParens )
{
ANTLRTreePrinter other = new ANTLRTreePrinter( new CommonTreeNodeStream( t ) );
return other.block( forceParens );
}
-        public int countAltsForBlock(GrammarAST t)
+        public int CountAltsForBlock(GrammarAST t)
{
int n = 0;
for ( int i = 0; i < t.ChildCount; i++ )
@@ -78,7 +78,7 @@ namespace Antlr3.Grammars
{
token = ( (NoViableAltException)ex ).token;
}
-            ErrorManager.syntaxError(
+            ErrorManager.SyntaxError(
ErrorManager.MSG_SYNTAX_ERROR,
grammar,
token,
@@ -95,7 +95,7 @@ namespace Antlr3.Grammars
*
*  ( A | B | C )*
*/
-        public static string normalize( string g )
+        public static string Normalize( string g )
{
// the trim appears to take just the last \n off
return string.Join( " ", g.Split( new char[] { ' ' }, System.StringSplitOptions.RemoveEmptyEntries ) ).Trim();
diff --git a/Antlr3/Grammars/ActionAnalysisLexer.cs b/Antlr3/Grammars/ActionAnalysisLexer.cs
index 0572016..abbeec4 100644
--- a/Antlr3/Grammars/ActionAnalysisLexer.cs
+++ b/Antlr3/Grammars/ActionAnalysisLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ActionAnalysisLexer.g3 2009-04-10 15:22:12
+// $ANTLR 3.1.2 Grammars\\ActionAnalysisLexer.g3 2009-04-16 20:58:18

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -169,34 +169,34 @@ public partial class ActionAnalysisLexer : Lexer
{
// ref to enclosing rule.
refdRuleName = (x!=null?x.Text:null);
-								scope = enclosingRule.getLocalAttributeScope((y!=null?y.Text:null));
+								scope = enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null));
}
-							else if ( enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null )
+							else if ( enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null )
{
// ref to rule label
-								Grammar.LabelElementPair pair = enclosingRule.getRuleLabel((x!=null?x.Text:null));
+								Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel((x!=null?x.Text:null));
pair.actionReferencesLabel = true;
refdRuleName = pair.referencedRuleName;
-								Rule refdRule = grammar.getRule(refdRuleName);
+								Rule refdRule = grammar.GetRule(refdRuleName);
if ( refdRule!=null )
{
-									scope = refdRule.getLocalAttributeScope((y!=null?y.Text:null));
+									scope = refdRule.GetLocalAttributeScope((y!=null?y.Text:null));
}
}
-							else if ( enclosingRule.getRuleRefsInAlt(x.Text, outerAltNum)!=null )
+							else if ( enclosingRule.GetRuleRefsInAlt(x.Text, outerAltNum)!=null )
{
// ref to rule referenced in this alt
refdRuleName = (x!=null?x.Text:null);
-								Rule refdRule = grammar.getRule(refdRuleName);
+								Rule refdRule = grammar.GetRule(refdRuleName);
if ( refdRule!=null )
{
-									scope = refdRule.getLocalAttributeScope((y!=null?y.Text:null));
+									scope = refdRule.GetLocalAttributeScope((y!=null?y.Text:null));
}
}
if ( scope!=null &&
(scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
{
-								grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+								grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
//System.out.println("referenceRuleLabelPredefinedAttribute for "+refdRuleName);
}

@@ -229,15 +229,15 @@ public partial class ActionAnalysisLexer : Lexer
int ID1Start84 = GetCharIndex();
mID(); if (state.failed) return ;
ID1 = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, ID1Start84, GetCharIndex()-1);
-			if ( !((enclosingRule!=null && enclosingRule.getRuleLabel((ID1!=null?ID1.Text:null))!=null)) )
+			if ( !((enclosingRule!=null && enclosingRule.GetRuleLabel((ID1!=null?ID1.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "X", "enclosingRule!=null && enclosingRule.getRuleLabel($ID.text)!=null");
+				throw new FailedPredicateException(input, "X", "enclosingRule!=null && enclosingRule.GetRuleLabel($ID.text)!=null");
}
if ( state.backtracking==1 )
{

-							Grammar.LabelElementPair pair = enclosingRule.getRuleLabel((ID1!=null?ID1.Text:null));
+							Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel((ID1!=null?ID1.Text:null));
pair.actionReferencesLabel = true;

}
@@ -269,19 +269,19 @@ public partial class ActionAnalysisLexer : Lexer
int ID2Start106 = GetCharIndex();
mID(); if (state.failed) return ;
ID2 = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, ID2Start106, GetCharIndex()-1);
-			if ( !((enclosingRule!=null && enclosingRule.getLocalAttributeScope((ID2!=null?ID2.Text:null))!=null)) )
+			if ( !((enclosingRule!=null && enclosingRule.GetLocalAttributeScope((ID2!=null?ID2.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "Y", "enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null");
+				throw new FailedPredicateException(input, "Y", "enclosingRule!=null && enclosingRule.GetLocalAttributeScope($ID.text)!=null");
}
if ( state.backtracking==1 )
{

-							AttributeScope scope = enclosingRule.getLocalAttributeScope((ID2!=null?ID2.Text:null));
+							AttributeScope scope = enclosingRule.GetLocalAttributeScope((ID2!=null?ID2.Text:null));
if ( scope!=null &&
(scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
{
-								grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+								grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
//System.out.println("referenceRuleLabelPredefinedAttribute for "+(ID2!=null?ID2.Text:null));
}

diff --git a/Antlr3/Grammars/ActionAnalysisLexer.g3 b/Antlr3/Grammars/ActionAnalysisLexer.g3
index 32524aa..0a28e6c 100644
--- a/Antlr3/Grammars/ActionAnalysisLexer.g3
+++ b/Antlr3/Grammars/ActionAnalysisLexer.g3
@@ -97,34 +97,34 @@ X_Y
{
// ref to enclosing rule.
refdRuleName = $x.text;
-				scope = enclosingRule.getLocalAttributeScope($y.text);
+				scope = enclosingRule.GetLocalAttributeScope($y.text);
}
-			else if ( enclosingRule.getRuleLabel($x.text)!=null )
+			else if ( enclosingRule.GetRuleLabel($x.text)!=null )
{
// ref to rule label
-				Grammar.LabelElementPair pair = enclosingRule.getRuleLabel($x.text);
+				Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel($x.text);
pair.actionReferencesLabel = true;
refdRuleName = pair.referencedRuleName;
-				Rule refdRule = grammar.getRule(refdRuleName);
+				Rule refdRule = grammar.GetRule(refdRuleName);
if ( refdRule!=null )
{
-					scope = refdRule.getLocalAttributeScope($y.text);
+					scope = refdRule.GetLocalAttributeScope($y.text);
}
}
-			else if ( enclosingRule.getRuleRefsInAlt(x.Text, outerAltNum)!=null )
+			else if ( enclosingRule.GetRuleRefsInAlt(x.Text, outerAltNum)!=null )
{
// ref to rule referenced in this alt
refdRuleName = $x.text;
-				Rule refdRule = grammar.getRule(refdRuleName);
+				Rule refdRule = grammar.GetRule(refdRuleName);
if ( refdRule!=null )
{
-					scope = refdRule.getLocalAttributeScope($y.text);
+					scope = refdRule.GetLocalAttributeScope($y.text);
}
}
if ( scope!=null &&
(scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
{
-				grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+				grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
//System.out.println("referenceRuleLabelPredefinedAttribute for "+refdRuleName);
}
}
@@ -132,22 +132,22 @@ X_Y

/** $x	x is an isolated rule label.  Just record that the label was referenced */
X
-	:	'$' ID {enclosingRule!=null && enclosingRule.getRuleLabel($ID.text)!=null}?
+	:	'$' ID {enclosingRule!=null && enclosingRule.GetRuleLabel($ID.text)!=null}?
{
-			Grammar.LabelElementPair pair = enclosingRule.getRuleLabel($ID.text);
+			Grammar.LabelElementPair pair = enclosingRule.GetRuleLabel($ID.text);
pair.actionReferencesLabel = true;
}
;

/** $y	y is a return value, parameter, or predefined property of current rule */
Y
-	:	'$' ID {enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null}?
+	:	'$' ID {enclosingRule!=null && enclosingRule.GetLocalAttributeScope($ID.text)!=null}?
{
-			AttributeScope scope = enclosingRule.getLocalAttributeScope($ID.text);
+			AttributeScope scope = enclosingRule.GetLocalAttributeScope($ID.text);
if ( scope!=null &&
(scope.isPredefinedRuleScope||scope.isPredefinedLexerRuleScope) )
{
-				grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+				grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
//System.out.println("referenceRuleLabelPredefinedAttribute for "+$ID.text);
}
}
diff --git a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
index 5e33b3d..6c52684 100644
--- a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
+++ b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
@@ -46,12 +46,12 @@ namespace Antlr3.Grammars
: this( new ANTLRStringStream( actionAST.token.Text ) )
{
this.grammar = grammar;
-            this.enclosingRule = grammar.getLocallyDefinedRule( ruleName );
+            this.enclosingRule = grammar.GetLocallyDefinedRule( ruleName );
this.actionToken = actionAST.token;
this.outerAltNum = actionAST.outerAltNum;
}

-        public void analyze()
+        public void Analyze()
{
//System.Console.Out.WriteLine( "###\naction=" + actionToken );
IToken t;
diff --git a/Antlr3/Grammars/ActionTranslator.cs b/Antlr3/Grammars/ActionTranslator.cs
index a695022..ae12afd 100644
--- a/Antlr3/Grammars/ActionTranslator.cs
+++ b/Antlr3/Grammars/ActionTranslator.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ActionTranslator.g3 2009-04-16 18:07:28
+// $ANTLR 3.1.2 Grammars\\ActionTranslator.g3 2009-04-16 21:08:59

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -207,29 +207,29 @@ public partial class ActionTranslator : Lexer
Match(';'); if (state.failed) return ;
if ( !((enclosingRule!=null &&
(x!=null?x.Text:null).Equals(enclosingRule.name) &&
-				                         enclosingRule.getLocalAttributeScope((y!=null?y.Text:null))!=null)) )
+				                         enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         $x.text.Equals(enclosingRule.name) &&\r\n\t                         enclosingRule.getLocalAttributeScope($y.text)!=null");
+				throw new FailedPredicateException(input, "SET_ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         $x.text.Equals(enclosingRule.name) &&\r\n\t                         enclosingRule.GetLocalAttributeScope($y.text)!=null");
}
if ( state.backtracking==1 )
{

StringTemplate st = null;
-							AttributeScope scope = enclosingRule.getLocalAttributeScope((y!=null?y.Text:null));
+							AttributeScope scope = enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null));
if ( scope.isPredefinedRuleScope )
{
if ( (y!=null?y.Text:null).Equals("st") || (y!=null?y.Text:null).Equals("tree") )
{
-									st = template("ruleSetPropertyRef_"+(y!=null?y.Text:null));
-									grammar.referenceRuleLabelPredefinedAttribute((x!=null?x.Text:null));
+									st = Template("ruleSetPropertyRef_"+(y!=null?y.Text:null));
+									grammar.ReferenceRuleLabelPredefinedAttribute((x!=null?x.Text:null));
st.SetAttribute("scope", (x!=null?x.Text:null));
st.SetAttribute("attr", (y!=null?y.Text:null));
-									st.SetAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+									st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
}
else
{
-									ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+									ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
(x!=null?x.Text:null),
@@ -239,7 +239,7 @@ public partial class ActionTranslator : Lexer
else if ( scope.isPredefinedLexerRuleScope )
{
// this is a better message to emit than the previous one...
-								ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+								ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
(x!=null?x.Text:null),
@@ -247,16 +247,16 @@ public partial class ActionTranslator : Lexer
}
else if ( scope.isParameterScope )
{
-								st = template("parameterSetAttributeRef");
-								st.SetAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
-								st.SetAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+								st = Template("parameterSetAttributeRef");
+								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
+								st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
}
else
{ // must be return value
-								st = template("returnSetAttributeRef");
+								st = Template("returnSetAttributeRef");
st.SetAttribute("ruleDescriptor", enclosingRule);
-								st.SetAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
-								st.SetAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
+								st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
}

}
@@ -295,48 +295,48 @@ public partial class ActionTranslator : Lexer
y = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, yStart113, GetCharIndex()-1);
if ( !((enclosingRule!=null &&
(x!=null?x.Text:null).Equals(enclosingRule.name) &&
-				                         enclosingRule.getLocalAttributeScope((y!=null?y.Text:null))!=null)) )
+				                         enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         $x.text.Equals(enclosingRule.name) &&\r\n\t                         enclosingRule.getLocalAttributeScope($y.text)!=null");
+				throw new FailedPredicateException(input, "ENCLOSING_RULE_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         $x.text.Equals(enclosingRule.name) &&\r\n\t                         enclosingRule.GetLocalAttributeScope($y.text)!=null");
}
if ( state.backtracking==1 )
{

-							if ( isRuleRefInAlt((x!=null?x.Text:null)) )
+							if ( IsRuleRefInAlt((x!=null?x.Text:null)) )
{
-								ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+								ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
grammar,
actionToken,
(x!=null?x.Text:null));
}
StringTemplate st = null;
-							AttributeScope scope = enclosingRule.getLocalAttributeScope((y!=null?y.Text:null));
+							AttributeScope scope = enclosingRule.GetLocalAttributeScope((y!=null?y.Text:null));
if ( scope.isPredefinedRuleScope )
{
-								st = template("rulePropertyRef_"+(y!=null?y.Text:null));
-								grammar.referenceRuleLabelPredefinedAttribute((x!=null?x.Text:null));
+								st = Template("rulePropertyRef_"+(y!=null?y.Text:null));
+								grammar.ReferenceRuleLabelPredefinedAttribute((x!=null?x.Text:null));
st.SetAttribute("scope", (x!=null?x.Text:null));
st.SetAttribute("attr", (y!=null?y.Text:null));
}
else if ( scope.isPredefinedLexerRuleScope )
{
// perhaps not the most precise error message to use, but...
-								ErrorManager.grammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
+								ErrorManager.GrammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
grammar,
actionToken,
(x!=null?x.Text:null));
}
else if ( scope.isParameterScope )
{
-								st = template("parameterAttributeRef");
-								st.SetAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
+								st = Template("parameterAttributeRef");
+								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
}
else
{ // must be return value
-								st = template("returnAttributeRef");
+								st = Template("returnAttributeRef");
st.SetAttribute("ruleDescriptor", enclosingRule);
-								st.SetAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
+								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
}

}
@@ -395,17 +395,17 @@ public partial class ActionTranslator : Lexer

Match('='); if (state.failed) return ;
if ( !((enclosingRule!=null && input.LA(1)!='=' &&
-				                         (enclosingRule.getTokenLabel((x!=null?x.Text:null))!=null||
-				                          isTokenRefInAlt((x!=null?x.Text:null))) &&
-				                         AttributeScope.tokenScope.getAttribute((y!=null?y.Text:null))!=null)) )
+				                         (enclosingRule.GetTokenLabel((x!=null?x.Text:null))!=null||
+				                          IsTokenRefInAlt((x!=null?x.Text:null))) &&
+				                         AttributeScope.tokenScope.GetAttribute((y!=null?y.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_TOKEN_SCOPE_ATTR", "enclosingRule!=null && input.LA(1)!='=' &&\r\n\t                         (enclosingRule.getTokenLabel($x.text)!=null||\r\n\t                          isTokenRefInAlt($x.text)) &&\r\n\t                         AttributeScope.tokenScope.getAttribute($y.text)!=null");
+				throw new FailedPredicateException(input, "SET_TOKEN_SCOPE_ATTR", "enclosingRule!=null && input.LA(1)!='=' &&\r\n\t                         (enclosingRule.GetTokenLabel($x.text)!=null||\r\n\t                          IsTokenRefInAlt($x.text)) &&\r\n\t                         AttributeScope.tokenScope.GetAttribute($y.text)!=null");
}
if ( state.backtracking==1 )
{

-							ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+							ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
(x!=null?x.Text:null),
@@ -446,37 +446,37 @@ public partial class ActionTranslator : Lexer
mID(); if (state.failed) return ;
y = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, yStart190, GetCharIndex()-1);
if ( !((enclosingRule!=null &&
-				                         (enclosingRule.getTokenLabel((x!=null?x.Text:null))!=null||
-				                          isTokenRefInAlt((x!=null?x.Text:null))) &&
-				                         AttributeScope.tokenScope.getAttribute((y!=null?y.Text:null))!=null &&
+				                         (enclosingRule.GetTokenLabel((x!=null?x.Text:null))!=null||
+				                          IsTokenRefInAlt((x!=null?x.Text:null))) &&
+				                         AttributeScope.tokenScope.GetAttribute((y!=null?y.Text:null))!=null &&
(grammar.type!=Grammar.LEXER ||
-				                         getElementLabel((x!=null?x.Text:null)).elementRef.token.Type==ANTLRParser.TOKEN_REF ||
-				                         getElementLabel((x!=null?x.Text:null)).elementRef.token.Type==ANTLRParser.STRING_LITERAL))) )
+				                         GetElementLabel((x!=null?x.Text:null)).elementRef.token.Type==ANTLRParser.TOKEN_REF ||
+				                         GetElementLabel((x!=null?x.Text:null)).elementRef.token.Type==ANTLRParser.STRING_LITERAL))) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "TOKEN_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         (enclosingRule.getTokenLabel($x.text)!=null||\r\n\t                          isTokenRefInAlt($x.text)) &&\r\n\t                         AttributeScope.tokenScope.getAttribute($y.text)!=null &&\r\n\t                         (grammar.type!=Grammar.LEXER ||\r\n\t                         getElementLabel($x.text).elementRef.token.Type==ANTLRParser.TOKEN_REF ||\r\n\t                         getElementLabel($x.text).elementRef.token.Type==ANTLRParser.STRING_LITERAL)");
+				throw new FailedPredicateException(input, "TOKEN_SCOPE_ATTR", "enclosingRule!=null &&\r\n\t                         (enclosingRule.GetTokenLabel($x.text)!=null||\r\n\t                          IsTokenRefInAlt($x.text)) &&\r\n\t                         AttributeScope.tokenScope.GetAttribute($y.text)!=null &&\r\n\t                         (grammar.type!=Grammar.LEXER ||\r\n\t                         GetElementLabel($x.text).elementRef.token.Type==ANTLRParser.TOKEN_REF ||\r\n\t                         GetElementLabel($x.text).elementRef.token.Type==ANTLRParser.STRING_LITERAL)");
}
if ( state.backtracking==1 )
{

string label = (x!=null?x.Text:null);
-							if ( enclosingRule.getTokenLabel((x!=null?x.Text:null))==null )
+							if ( enclosingRule.GetTokenLabel((x!=null?x.Text:null))==null )
{
// $tokenref.attr  gotta get old label or compute new one
-								checkElementRefUniqueness((x!=null?x.Text:null), true);
-								label = enclosingRule.getElementLabel((x!=null?x.Text:null), outerAltNum, generator);
+								CheckElementRefUniqueness((x!=null?x.Text:null), true);
+								label = enclosingRule.GetElementLabel((x!=null?x.Text:null), outerAltNum, generator);
if ( label==null )
{
-									ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+									ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
grammar,
actionToken,
"$"+(x!=null?x.Text:null)+"."+(y!=null?y.Text:null));
label = (x!=null?x.Text:null);
}
}
-							StringTemplate st = template("tokenLabelPropertyRef_"+(y!=null?y.Text:null));
+							StringTemplate st = Template("tokenLabelPropertyRef_"+(y!=null?y.Text:null));
st.SetAttribute("scope", label);
-							st.SetAttribute("attr", AttributeScope.tokenScope.getAttribute((y!=null?y.Text:null)));
+							st.SetAttribute("attr", AttributeScope.tokenScope.GetAttribute((y!=null?y.Text:null)));

}

@@ -545,7 +545,7 @@ public partial class ActionTranslator : Lexer
if ( state.backtracking==1 )
{

-							pair = enclosingRule.getRuleLabel((x!=null?x.Text:null));
+							pair = enclosingRule.GetRuleLabel((x!=null?x.Text:null));
refdRuleName = (x!=null?x.Text:null);
if ( pair!=null )
{
@@ -553,16 +553,16 @@ public partial class ActionTranslator : Lexer
}

}
-			if ( !(((enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null || isRuleRefInAlt((x!=null?x.Text:null))) &&
-				      getRuleLabelAttribute(enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null?enclosingRule.getRuleLabel((x!=null?x.Text:null)).referencedRuleName:(x!=null?x.Text:null),(y!=null?y.Text:null))!=null)) )
+			if ( !(((enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null || IsRuleRefInAlt((x!=null?x.Text:null))) &&
+				      GetRuleLabelAttribute(enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null?enclosingRule.GetRuleLabel((x!=null?x.Text:null)).referencedRuleName:(x!=null?x.Text:null),(y!=null?y.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&\r\n\t      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
+				throw new FailedPredicateException(input, "SET_RULE_SCOPE_ATTR", "(enclosingRule.GetRuleLabel($x.text)!=null || IsRuleRefInAlt($x.text)) &&\r\n\t      GetRuleLabelAttribute(enclosingRule.GetRuleLabel($x.text)!=null?enclosingRule.GetRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
}
if ( state.backtracking==1 )
{

-							ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+							ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
(x!=null?x.Text:null),
@@ -614,18 +614,18 @@ public partial class ActionTranslator : Lexer
if ( state.backtracking==1 )
{

-						pair = enclosingRule.getRuleLabel((x!=null?x.Text:null));
+						pair = enclosingRule.GetRuleLabel((x!=null?x.Text:null));
refdRuleName = (x!=null?x.Text:null);
if ( pair!=null ) {
refdRuleName = pair.referencedRuleName;
}

}
-			if ( !(((enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null || isRuleRefInAlt((x!=null?x.Text:null))) &&
-				      getRuleLabelAttribute(enclosingRule.getRuleLabel((x!=null?x.Text:null))!=null?enclosingRule.getRuleLabel((x!=null?x.Text:null)).referencedRuleName:(x!=null?x.Text:null),(y!=null?y.Text:null))!=null)) )
+			if ( !(((enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null || IsRuleRefInAlt((x!=null?x.Text:null))) &&
+				      GetRuleLabelAttribute(enclosingRule.GetRuleLabel((x!=null?x.Text:null))!=null?enclosingRule.GetRuleLabel((x!=null?x.Text:null)).referencedRuleName:(x!=null?x.Text:null),(y!=null?y.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&\r\n\t      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
+				throw new FailedPredicateException(input, "RULE_SCOPE_ATTR", "(enclosingRule.GetRuleLabel($x.text)!=null || IsRuleRefInAlt($x.text)) &&\r\n\t      GetRuleLabelAttribute(enclosingRule.GetRuleLabel($x.text)!=null?enclosingRule.GetRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null");
}
if ( state.backtracking==1 )
{
@@ -634,11 +634,11 @@ public partial class ActionTranslator : Lexer
if ( pair==null )
{
// $ruleref.attr  gotta get old label or compute new one
-								checkElementRefUniqueness((x!=null?x.Text:null), false);
-								label = enclosingRule.getElementLabel((x!=null?x.Text:null), outerAltNum, generator);
+								CheckElementRefUniqueness((x!=null?x.Text:null), false);
+								label = enclosingRule.GetElementLabel((x!=null?x.Text:null), outerAltNum, generator);
if ( label==null )
{
-									ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+									ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
grammar,
actionToken,
"$"+(x!=null?x.Text:null)+"."+(y!=null?y.Text:null));
@@ -646,19 +646,19 @@ public partial class ActionTranslator : Lexer
}
}
StringTemplate st;
-							Rule refdRule = grammar.getRule(refdRuleName);
-							AttributeScope scope = refdRule.getLocalAttributeScope((y!=null?y.Text:null));
+							Rule refdRule = grammar.GetRule(refdRuleName);
+							AttributeScope scope = refdRule.GetLocalAttributeScope((y!=null?y.Text:null));
if ( scope.isPredefinedRuleScope )
{
-								st = template("ruleLabelPropertyRef_"+(y!=null?y.Text:null));
-								grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+								st = Template("ruleLabelPropertyRef_"+(y!=null?y.Text:null));
+								grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
st.SetAttribute("scope", label);
st.SetAttribute("attr", (y!=null?y.Text:null));
}
else if ( scope.isPredefinedLexerRuleScope )
{
-								st = template("lexerRuleLabelPropertyRef_"+(y!=null?y.Text:null));
-								grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+								st = Template("lexerRuleLabelPropertyRef_"+(y!=null?y.Text:null));
+								grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
st.SetAttribute("scope", label);
st.SetAttribute("attr", (y!=null?y.Text:null));
}
@@ -668,10 +668,10 @@ public partial class ActionTranslator : Lexer
}
else
{
-								st = template("ruleLabelRef");
+								st = Template("ruleLabelRef");
st.SetAttribute("referencedRule", refdRule);
st.SetAttribute("scope", label);
-								st.SetAttribute("attr", scope.getAttribute((y!=null?y.Text:null)));
+								st.SetAttribute("attr", scope.GetAttribute((y!=null?y.Text:null)));
}

}
@@ -704,26 +704,26 @@ public partial class ActionTranslator : Lexer
mID(); if (state.failed) return ;
ID1 = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, ID1Start328, GetCharIndex()-1);
if ( !((enclosingRule!=null &&
-				            getElementLabel((ID1!=null?ID1.Text:null))!=null &&
-					        enclosingRule.getRuleLabel((ID1!=null?ID1.Text:null))==null)) )
+				            GetElementLabel((ID1!=null?ID1.Text:null))!=null &&
+					        enclosingRule.GetRuleLabel((ID1!=null?ID1.Text:null))==null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "LABEL_REF", "enclosingRule!=null &&\r\n\t            getElementLabel($ID.text)!=null &&\r\n\t\t        enclosingRule.getRuleLabel($ID.text)==null");
+				throw new FailedPredicateException(input, "LABEL_REF", "enclosingRule!=null &&\r\n\t            GetElementLabel($ID.text)!=null &&\r\n\t\t        enclosingRule.GetRuleLabel($ID.text)==null");
}
if ( state.backtracking==1 )
{

StringTemplate st;
-							Grammar.LabelElementPair pair = getElementLabel((ID1!=null?ID1.Text:null));
+							Grammar.LabelElementPair pair = GetElementLabel((ID1!=null?ID1.Text:null));
if ( pair.type==Grammar.RULE_LIST_LABEL ||
pair.type==Grammar.TOKEN_LIST_LABEL ||
pair.type == Grammar.WILDCARD_TREE_LIST_LABEL )
{
-								st = template("listLabelRef");
+								st = Template("listLabelRef");
}
else
{
-								st = template("tokenLabelRef");
+								st = Template("tokenLabelRef");
}
st.SetAttribute("label", (ID1!=null?ID1.Text:null));

@@ -756,26 +756,26 @@ public partial class ActionTranslator : Lexer
int ID2Start352 = GetCharIndex();
mID(); if (state.failed) return ;
ID2 = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, ID2Start352, GetCharIndex()-1);
-			if ( !((grammar.type!=Grammar.LEXER && enclosingRule!=null && isTokenRefInAlt((ID2!=null?ID2.Text:null)))) )
+			if ( !((grammar.type!=Grammar.LEXER && enclosingRule!=null && IsTokenRefInAlt((ID2!=null?ID2.Text:null)))) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "ISOLATED_TOKEN_REF", "grammar.type!=Grammar.LEXER && enclosingRule!=null && isTokenRefInAlt($ID.text)");
+				throw new FailedPredicateException(input, "ISOLATED_TOKEN_REF", "grammar.type!=Grammar.LEXER && enclosingRule!=null && IsTokenRefInAlt($ID.text)");
}
if ( state.backtracking==1 )
{

-							string label = enclosingRule.getElementLabel((ID2!=null?ID2.Text:null), outerAltNum, generator);
-							checkElementRefUniqueness((ID2!=null?ID2.Text:null), true);
+							string label = enclosingRule.GetElementLabel((ID2!=null?ID2.Text:null), outerAltNum, generator);
+							CheckElementRefUniqueness((ID2!=null?ID2.Text:null), true);
if ( label==null )
{
-								ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+								ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
grammar,
actionToken,
(ID2!=null?ID2.Text:null));
}
else
{
-								StringTemplate st = template("tokenLabelRef");
+								StringTemplate st = Template("tokenLabelRef");
st.SetAttribute("label", label);
}

@@ -810,26 +810,26 @@ public partial class ActionTranslator : Lexer
ID3 = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, ID3Start376, GetCharIndex()-1);
if ( !((grammar.type==Grammar.LEXER &&
enclosingRule!=null &&
-				             isRuleRefInAlt((ID3!=null?ID3.Text:null)))) )
+				             IsRuleRefInAlt((ID3!=null?ID3.Text:null)))) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "ISOLATED_LEXER_RULE_REF", "grammar.type==Grammar.LEXER &&\r\n\t             enclosingRule!=null &&\r\n\t             isRuleRefInAlt($ID.text)");
+				throw new FailedPredicateException(input, "ISOLATED_LEXER_RULE_REF", "grammar.type==Grammar.LEXER &&\r\n\t             enclosingRule!=null &&\r\n\t             IsRuleRefInAlt($ID.text)");
}
if ( state.backtracking==1 )
{

-							string label = enclosingRule.getElementLabel((ID3!=null?ID3.Text:null), outerAltNum, generator);
-							checkElementRefUniqueness((ID3!=null?ID3.Text:null), false);
+							string label = enclosingRule.GetElementLabel((ID3!=null?ID3.Text:null), outerAltNum, generator);
+							CheckElementRefUniqueness((ID3!=null?ID3.Text:null), false);
if ( label==null )
{
-								ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+								ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
grammar,
actionToken,
(ID3!=null?ID3.Text:null));
}
else
{
-								StringTemplate st = template("lexerRuleLabel");
+								StringTemplate st = Template("lexerRuleLabel");
st.SetAttribute("label", label);
}

@@ -889,30 +889,30 @@ public partial class ActionTranslator : Lexer
expr = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, exprStart409, GetCharIndex()-1);
Match(';'); if (state.failed) return ;
if ( !((enclosingRule!=null
-																&& enclosingRule.getLocalAttributeScope((ID4!=null?ID4.Text:null))!=null
-																&& !enclosingRule.getLocalAttributeScope((ID4!=null?ID4.Text:null)).isPredefinedLexerRuleScope)) )
+																&& enclosingRule.GetLocalAttributeScope((ID4!=null?ID4.Text:null))!=null
+																&& !enclosingRule.GetLocalAttributeScope((ID4!=null?ID4.Text:null)).isPredefinedLexerRuleScope)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_LOCAL_ATTR", "enclosingRule!=null\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& enclosingRule.getLocalAttributeScope($ID.text)!=null\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& !enclosingRule.getLocalAttributeScope($ID.text).isPredefinedLexerRuleScope");
+				throw new FailedPredicateException(input, "SET_LOCAL_ATTR", "enclosingRule!=null\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& enclosingRule.GetLocalAttributeScope($ID.text)!=null\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t&& !enclosingRule.GetLocalAttributeScope($ID.text).isPredefinedLexerRuleScope");
}
if ( state.backtracking==1 )
{

StringTemplate st;
-							AttributeScope scope = enclosingRule.getLocalAttributeScope((ID4!=null?ID4.Text:null));
+							AttributeScope scope = enclosingRule.GetLocalAttributeScope((ID4!=null?ID4.Text:null));
if ( scope.isPredefinedRuleScope )
{
if ((ID4!=null?ID4.Text:null).Equals("tree") || (ID4!=null?ID4.Text:null).Equals("st"))
{
-									st = template("ruleSetPropertyRef_"+(ID4!=null?ID4.Text:null));
-									grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+									st = Template("ruleSetPropertyRef_"+(ID4!=null?ID4.Text:null));
+									grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
st.SetAttribute("scope", enclosingRule.name);
st.SetAttribute("attr", (ID4!=null?ID4.Text:null));
-									st.SetAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+									st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
}
else
{
-									ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+									ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
(ID4!=null?ID4.Text:null),
@@ -921,16 +921,16 @@ public partial class ActionTranslator : Lexer
}
else if ( scope.isParameterScope )
{
-								st = template("parameterSetAttributeRef");
-								st.SetAttribute("attr", scope.getAttribute((ID4!=null?ID4.Text:null)));
-								st.SetAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+								st = Template("parameterSetAttributeRef");
+								st.SetAttribute("attr", scope.GetAttribute((ID4!=null?ID4.Text:null)));
+								st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
}
else
{
-								st = template("returnSetAttributeRef");
+								st = Template("returnSetAttributeRef");
st.SetAttribute("ruleDescriptor", enclosingRule);
-								st.SetAttribute("attr", scope.getAttribute((ID4!=null?ID4.Text:null)));
-								st.SetAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+								st.SetAttribute("attr", scope.GetAttribute((ID4!=null?ID4.Text:null)));
+								st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));
}

}
@@ -962,39 +962,39 @@ public partial class ActionTranslator : Lexer
int ID5Start432 = GetCharIndex();
mID(); if (state.failed) return ;
ID5 = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, ID5Start432, GetCharIndex()-1);
-			if ( !((enclosingRule!=null && enclosingRule.getLocalAttributeScope((ID5!=null?ID5.Text:null))!=null)) )
+			if ( !((enclosingRule!=null && enclosingRule.GetLocalAttributeScope((ID5!=null?ID5.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "LOCAL_ATTR", "enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null");
+				throw new FailedPredicateException(input, "LOCAL_ATTR", "enclosingRule!=null && enclosingRule.GetLocalAttributeScope($ID.text)!=null");
}
if ( state.backtracking==1 )
{

StringTemplate st;
-							AttributeScope scope = enclosingRule.getLocalAttributeScope((ID5!=null?ID5.Text:null));
+							AttributeScope scope = enclosingRule.GetLocalAttributeScope((ID5!=null?ID5.Text:null));
if ( scope.isPredefinedRuleScope )
{
-								st = template("rulePropertyRef_"+(ID5!=null?ID5.Text:null));
-								grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+								st = Template("rulePropertyRef_"+(ID5!=null?ID5.Text:null));
+								grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
st.SetAttribute("scope", enclosingRule.name);
st.SetAttribute("attr", (ID5!=null?ID5.Text:null));
}
else if ( scope.isPredefinedLexerRuleScope )
{
-								st = template("lexerRulePropertyRef_"+(ID5!=null?ID5.Text:null));
+								st = Template("lexerRulePropertyRef_"+(ID5!=null?ID5.Text:null));
st.SetAttribute("scope", enclosingRule.name);
st.SetAttribute("attr", (ID5!=null?ID5.Text:null));
}
else if ( scope.isParameterScope )
{
-								st = template("parameterAttributeRef");
-								st.SetAttribute("attr", scope.getAttribute((ID5!=null?ID5.Text:null)));
+								st = Template("parameterAttributeRef");
+								st.SetAttribute("attr", scope.GetAttribute((ID5!=null?ID5.Text:null)));
}
else
{
-								st = template("returnAttributeRef");
+								st = Template("returnAttributeRef");
st.SetAttribute("ruleDescriptor", enclosingRule);
-								st.SetAttribute("attr", scope.getAttribute((ID5!=null?ID5.Text:null)));
+								st.SetAttribute("attr", scope.GetAttribute((ID5!=null?ID5.Text:null)));
}

}
@@ -1058,22 +1058,22 @@ public partial class ActionTranslator : Lexer
mATTR_VALUE_EXPR(); if (state.failed) return ;
expr = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, exprStart473, GetCharIndex()-1);
Match(';'); if (state.failed) return ;
-			if ( !((resolveDynamicScope((x!=null?x.Text:null))!=null &&
-									     resolveDynamicScope((x!=null?x.Text:null)).getAttribute((y!=null?y.Text:null))!=null)) )
+			if ( !((ResolveDynamicScope((x!=null?x.Text:null))!=null &&
+									     ResolveDynamicScope((x!=null?x.Text:null)).GetAttribute((y!=null?y.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "SET_DYNAMIC_SCOPE_ATTR", "resolveDynamicScope($x.text)!=null &&\r\n\t\t\t\t\t\t     resolveDynamicScope($x.text).getAttribute($y.text)!=null");
+				throw new FailedPredicateException(input, "SET_DYNAMIC_SCOPE_ATTR", "ResolveDynamicScope($x.text)!=null &&\r\n\t\t\t\t\t\t     ResolveDynamicScope($x.text).GetAttribute($y.text)!=null");
}
if ( state.backtracking==1 )
{

-							AttributeScope scope = resolveDynamicScope((x!=null?x.Text:null));
+							AttributeScope scope = ResolveDynamicScope((x!=null?x.Text:null));
if ( scope!=null )
{
-								StringTemplate st = template("scopeSetAttributeRef");
+								StringTemplate st = Template("scopeSetAttributeRef");
st.SetAttribute("scope", (x!=null?x.Text:null));
-								st.SetAttribute("attr",  scope.getAttribute((y!=null?y.Text:null)));
-								st.SetAttribute("expr",  translateAction((expr!=null?expr.Text:null)));
+								st.SetAttribute("attr",  scope.GetAttribute((y!=null?y.Text:null)));
+								st.SetAttribute("expr",  TranslateAction((expr!=null?expr.Text:null)));
}
else
{
@@ -1115,21 +1115,21 @@ public partial class ActionTranslator : Lexer
int yStart514 = GetCharIndex();
mID(); if (state.failed) return ;
y = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, yStart514, GetCharIndex()-1);
-			if ( !((resolveDynamicScope((x!=null?x.Text:null))!=null &&
-									     resolveDynamicScope((x!=null?x.Text:null)).getAttribute((y!=null?y.Text:null))!=null)) )
+			if ( !((ResolveDynamicScope((x!=null?x.Text:null))!=null &&
+									     ResolveDynamicScope((x!=null?x.Text:null)).GetAttribute((y!=null?y.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "DYNAMIC_SCOPE_ATTR", "resolveDynamicScope($x.text)!=null &&\r\n\t\t\t\t\t\t     resolveDynamicScope($x.text).getAttribute($y.text)!=null");
+				throw new FailedPredicateException(input, "DYNAMIC_SCOPE_ATTR", "ResolveDynamicScope($x.text)!=null &&\r\n\t\t\t\t\t\t     ResolveDynamicScope($x.text).GetAttribute($y.text)!=null");
}
if ( state.backtracking==1 )
{

-							AttributeScope scope = resolveDynamicScope((x!=null?x.Text:null));
+							AttributeScope scope = ResolveDynamicScope((x!=null?x.Text:null));
if ( scope!=null )
{
-								StringTemplate st = template("scopeAttributeRef");
+								StringTemplate st = Template("scopeAttributeRef");
st.SetAttribute("scope", (x!=null?x.Text:null));
-								st.SetAttribute("attr",  scope.getAttribute((y!=null?y.Text:null)));
+								st.SetAttribute("attr",  scope.GetAttribute((y!=null?y.Text:null)));
}
else
{
@@ -1224,9 +1224,9 @@ public partial class ActionTranslator : Lexer
if ( state.backtracking==1 )
{

-							StringTemplate st = template("scopeAttributeRef");
+							StringTemplate st = Template("scopeAttributeRef");
st.SetAttribute("scope",    (x!=null?x.Text:null));
-							st.SetAttribute("attr",     resolveDynamicScope((x!=null?x.Text:null)).getAttribute((y!=null?y.Text:null)));
+							st.SetAttribute("attr",     ResolveDynamicScope((x!=null?x.Text:null)).GetAttribute((y!=null?y.Text:null)));
st.SetAttribute("negIndex", (expr!=null?expr.Text:null));

}
@@ -1273,9 +1273,9 @@ public partial class ActionTranslator : Lexer
if ( state.backtracking==1 )
{

-							StringTemplate st = template("scopeAttributeRef");
+							StringTemplate st = Template("scopeAttributeRef");
st.SetAttribute("scope", (x!=null?x.Text:null));
-							st.SetAttribute("attr",  resolveDynamicScope((x!=null?x.Text:null)).getAttribute((y!=null?y.Text:null)));
+							st.SetAttribute("attr",  ResolveDynamicScope((x!=null?x.Text:null)).GetAttribute((y!=null?y.Text:null)));
st.SetAttribute("index", (expr!=null?expr.Text:null));

}
@@ -1363,15 +1363,15 @@ public partial class ActionTranslator : Lexer
int ID6Start673 = GetCharIndex();
mID(); if (state.failed) return ;
ID6 = new CommonToken(input, TokenConstants.InvalidTokenType, TokenConstants.DefaultChannel, ID6Start673, GetCharIndex()-1);
-			if ( !((resolveDynamicScope((ID6!=null?ID6.Text:null))!=null)) )
+			if ( !((ResolveDynamicScope((ID6!=null?ID6.Text:null))!=null)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
-				throw new FailedPredicateException(input, "ISOLATED_DYNAMIC_SCOPE", "resolveDynamicScope($ID.text)!=null");
+				throw new FailedPredicateException(input, "ISOLATED_DYNAMIC_SCOPE", "ResolveDynamicScope($ID.text)!=null");
}
if ( state.backtracking==1 )
{

-							StringTemplate st = template("isolatedDynamicScopeRef");
+							StringTemplate st = Template("isolatedDynamicScopeRef");
st.SetAttribute("scope", (ID6!=null?ID6.Text:null));

}
@@ -1768,12 +1768,12 @@ public partial class ActionTranslator : Lexer
if ( state.backtracking==1 )
{

-							StringTemplate st = template("actionSetAttribute");
+							StringTemplate st = Template("actionSetAttribute");
string action = (a!=null?a.Text:null);
action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
-							st.SetAttribute("st", translateAction(action));
+							st.SetAttribute("st", TranslateAction(action));
st.SetAttribute("attrName", (ID7!=null?ID7.Text:null));
-							st.SetAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+							st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));

}

@@ -1838,10 +1838,10 @@ public partial class ActionTranslator : Lexer
if ( state.backtracking==1 )
{

-							StringTemplate st = template("actionSetAttribute");
+							StringTemplate st = Template("actionSetAttribute");
st.SetAttribute("st", (x!=null?x.Text:null));
st.SetAttribute("attrName", (y!=null?y.Text:null));
-							st.SetAttribute("expr", translateAction((expr!=null?expr.Text:null)));
+							st.SetAttribute("expr", TranslateAction((expr!=null?expr.Text:null)));

}

@@ -1937,10 +1937,10 @@ public partial class ActionTranslator : Lexer
if ( state.backtracking==1 )
{

-							StringTemplate st = template("actionStringConstructor");
+							StringTemplate st = Template("actionStringConstructor");
string action = (a!=null?a.Text:null);
action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
-							st.SetAttribute("stringExpr", translateAction(action));
+							st.SetAttribute("stringExpr", TranslateAction(action));

}

@@ -2304,7 +2304,7 @@ public partial class ActionTranslator : Lexer
{

chunks.Add(Text);
-								ErrorManager.grammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
+								ErrorManager.GrammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
grammar,
actionToken,
Text);
diff --git a/Antlr3/Grammars/ActionTranslator.g3 b/Antlr3/Grammars/ActionTranslator.g3
index db2c8bb..1c40a58 100644
--- a/Antlr3/Grammars/ActionTranslator.g3
+++ b/Antlr3/Grammars/ActionTranslator.g3
@@ -91,24 +91,24 @@ SET_ENCLOSING_RULE_SCOPE_ATTR
:	'$' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
{enclosingRule!=null &&
$x.text.Equals(enclosingRule.name) &&
-	                         enclosingRule.getLocalAttributeScope($y.text)!=null}?
+	                         enclosingRule.GetLocalAttributeScope($y.text)!=null}?
//{JSystem.@out.println("found \$rule.attr");}
{
StringTemplate st = null;
-			AttributeScope scope = enclosingRule.getLocalAttributeScope($y.text);
+			AttributeScope scope = enclosingRule.GetLocalAttributeScope($y.text);
if ( scope.isPredefinedRuleScope )
{
if ( $y.text.Equals("st") || $y.text.Equals("tree") )
{
-					st = template("ruleSetPropertyRef_"+$y.text);
-					grammar.referenceRuleLabelPredefinedAttribute($x.text);
+					st = Template("ruleSetPropertyRef_"+$y.text);
+					grammar.ReferenceRuleLabelPredefinedAttribute($x.text);
st.SetAttribute("scope", $x.text);
st.SetAttribute("attr", $y.text);
-					st.SetAttribute("expr", translateAction($expr.text));
+					st.SetAttribute("expr", TranslateAction($expr.text));
}
else
{
-					ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+					ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
$x.text,
@@ -118,7 +118,7 @@ SET_ENCLOSING_RULE_SCOPE_ATTR
else if ( scope.isPredefinedLexerRuleScope )
{
// this is a better message to emit than the previous one...
-				ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+				ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
$x.text,
@@ -126,59 +126,59 @@ SET_ENCLOSING_RULE_SCOPE_ATTR
}
else if ( scope.isParameterScope )
{
-				st = template("parameterSetAttributeRef");
-				st.SetAttribute("attr", scope.getAttribute($y.text));
-				st.SetAttribute("expr", translateAction($expr.text));
+				st = Template("parameterSetAttributeRef");
+				st.SetAttribute("attr", scope.GetAttribute($y.text));
+				st.SetAttribute("expr", TranslateAction($expr.text));
}
else
{ // must be return value
-				st = template("returnSetAttributeRef");
+				st = Template("returnSetAttributeRef");
st.SetAttribute("ruleDescriptor", enclosingRule);
-				st.SetAttribute("attr", scope.getAttribute($y.text));
-				st.SetAttribute("expr", translateAction($expr.text));
+				st.SetAttribute("attr", scope.GetAttribute($y.text));
+				st.SetAttribute("expr", TranslateAction($expr.text));
}
}
;
ENCLOSING_RULE_SCOPE_ATTR
:	'$' x=ID '.' y=ID	{enclosingRule!=null &&
$x.text.Equals(enclosingRule.name) &&
-	                         enclosingRule.getLocalAttributeScope($y.text)!=null}?
+	                         enclosingRule.GetLocalAttributeScope($y.text)!=null}?
//{JSystem.@out.println("found \$rule.attr");}
{
-			if ( isRuleRefInAlt($x.text) )
+			if ( IsRuleRefInAlt($x.text) )
{
-				ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+				ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
grammar,
actionToken,
$x.text);
}
StringTemplate st = null;
-			AttributeScope scope = enclosingRule.getLocalAttributeScope($y.text);
+			AttributeScope scope = enclosingRule.GetLocalAttributeScope($y.text);
if ( scope.isPredefinedRuleScope )
{
-				st = template("rulePropertyRef_"+$y.text);
-				grammar.referenceRuleLabelPredefinedAttribute($x.text);
+				st = Template("rulePropertyRef_"+$y.text);
+				grammar.ReferenceRuleLabelPredefinedAttribute($x.text);
st.SetAttribute("scope", $x.text);
st.SetAttribute("attr", $y.text);
}
else if ( scope.isPredefinedLexerRuleScope )
{
// perhaps not the most precise error message to use, but...
-				ErrorManager.grammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
+				ErrorManager.GrammarError(ErrorManager.MSG_RULE_HAS_NO_ARGS,
grammar,
actionToken,
$x.text);
}
else if ( scope.isParameterScope )
{
-				st = template("parameterAttributeRef");
-				st.SetAttribute("attr", scope.getAttribute($y.text));
+				st = Template("parameterAttributeRef");
+				st.SetAttribute("attr", scope.GetAttribute($y.text));
}
else
{ // must be return value
-				st = template("returnAttributeRef");
+				st = Template("returnAttributeRef");
st.SetAttribute("ruleDescriptor", enclosingRule);
-				st.SetAttribute("attr", scope.getAttribute($y.text));
+				st.SetAttribute("attr", scope.GetAttribute($y.text));
}
}
;
@@ -187,12 +187,12 @@ ENCLOSING_RULE_SCOPE_ATTR
SET_TOKEN_SCOPE_ATTR
:	'$' x=ID '.' y=ID WS? '='
{enclosingRule!=null && input.LA(1)!='=' &&
-	                         (enclosingRule.getTokenLabel($x.text)!=null||
-	                          isTokenRefInAlt($x.text)) &&
-	                         AttributeScope.tokenScope.getAttribute($y.text)!=null}?
+	                         (enclosingRule.GetTokenLabel($x.text)!=null||
+	                          IsTokenRefInAlt($x.text)) &&
+	                         AttributeScope.tokenScope.GetAttribute($y.text)!=null}?
//{JSystem.@out.println("found \$tokenlabel.attr or \$tokenref.attr");}
{
-			ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+			ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
$x.text,
@@ -205,32 +205,32 @@ SET_TOKEN_SCOPE_ATTR
*/
TOKEN_SCOPE_ATTR
:	'$' x=ID '.' y=ID	{enclosingRule!=null &&
-	                         (enclosingRule.getTokenLabel($x.text)!=null||
-	                          isTokenRefInAlt($x.text)) &&
-	                         AttributeScope.tokenScope.getAttribute($y.text)!=null &&
+	                         (enclosingRule.GetTokenLabel($x.text)!=null||
+	                          IsTokenRefInAlt($x.text)) &&
+	                         AttributeScope.tokenScope.GetAttribute($y.text)!=null &&
(grammar.type!=Grammar.LEXER ||
-	                         getElementLabel($x.text).elementRef.token.Type==ANTLRParser.TOKEN_REF ||
-	                         getElementLabel($x.text).elementRef.token.Type==ANTLRParser.STRING_LITERAL)}?
+	                         GetElementLabel($x.text).elementRef.token.Type==ANTLRParser.TOKEN_REF ||
+	                         GetElementLabel($x.text).elementRef.token.Type==ANTLRParser.STRING_LITERAL)}?
// {JSystem.@out.println("found \$tokenlabel.attr or \$tokenref.attr");}
{
string label = $x.text;
-			if ( enclosingRule.getTokenLabel($x.text)==null )
+			if ( enclosingRule.GetTokenLabel($x.text)==null )
{
// \$tokenref.attr  gotta get old label or compute new one
-				checkElementRefUniqueness($x.text, true);
-				label = enclosingRule.getElementLabel($x.text, outerAltNum, generator);
+				CheckElementRefUniqueness($x.text, true);
+				label = enclosingRule.GetElementLabel($x.text, outerAltNum, generator);
if ( label==null )
{
-					ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+					ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
grammar,
actionToken,
"\$"+$x.text+"."+$y.text);
label = $x.text;
}
}
-			StringTemplate st = template("tokenLabelPropertyRef_"+$y.text);
+			StringTemplate st = Template("tokenLabelPropertyRef_"+$y.text);
st.SetAttribute("scope", label);
-			st.SetAttribute("attr", AttributeScope.tokenScope.getAttribute($y.text));
+			st.SetAttribute("attr", AttributeScope.tokenScope.GetAttribute($y.text));
}
;

@@ -247,7 +247,7 @@ string refdRuleName=null;
}
:	'$' x=ID '.' y=ID WS? '=' {enclosingRule!=null && input.LA(1)!='='}?
{
-			pair = enclosingRule.getRuleLabel($x.text);
+			pair = enclosingRule.GetRuleLabel($x.text);
refdRuleName = $x.text;
if ( pair!=null )
{
@@ -257,11 +257,11 @@ string refdRuleName=null;
// supercomplicated because I can't exec the above action.
// This asserts that if it's a label or a ref to a rule proceed but only if the attribute
// is valid for that rule's scope
-		{(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&
-	      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null}?
+		{(enclosingRule.GetRuleLabel($x.text)!=null || IsRuleRefInAlt($x.text)) &&
+	      GetRuleLabelAttribute(enclosingRule.GetRuleLabel($x.text)!=null?enclosingRule.GetRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null}?
//{JSystem.@out.println("found set \$rulelabel.attr or \$ruleref.attr: "+$x.text+"."+$y.text);}
{
-			ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+			ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
$x.text,
@@ -278,7 +278,7 @@ RULE_SCOPE_ATTR
}
:	'$' x=ID '.' y=ID {enclosingRule!=null}?
{
-		pair = enclosingRule.getRuleLabel($x.text);
+		pair = enclosingRule.GetRuleLabel($x.text);
refdRuleName = $x.text;
if ( pair!=null ) {
refdRuleName = pair.referencedRuleName;
@@ -287,19 +287,19 @@ RULE_SCOPE_ATTR
// supercomplicated because I can't exec the above action.
// This asserts that if it's a label or a ref to a rule proceed but only if the attribute
// is valid for that rule's scope
-		{(enclosingRule.getRuleLabel($x.text)!=null || isRuleRefInAlt($x.text)) &&
-	      getRuleLabelAttribute(enclosingRule.getRuleLabel($x.text)!=null?enclosingRule.getRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null}?
+		{(enclosingRule.GetRuleLabel($x.text)!=null || IsRuleRefInAlt($x.text)) &&
+	      GetRuleLabelAttribute(enclosingRule.GetRuleLabel($x.text)!=null?enclosingRule.GetRuleLabel($x.text).referencedRuleName:$x.text,$y.text)!=null}?
//{JSystem.@out.println("found \$rulelabel.attr or \$ruleref.attr: "+$x.text+"."+$y.text);}
{
string label = $x.text;
if ( pair==null )
{
// \$ruleref.attr  gotta get old label or compute new one
-				checkElementRefUniqueness($x.text, false);
-				label = enclosingRule.getElementLabel($x.text, outerAltNum, generator);
+				CheckElementRefUniqueness($x.text, false);
+				label = enclosingRule.GetElementLabel($x.text, outerAltNum, generator);
if ( label==null )
{
-					ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+					ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
grammar,
actionToken,
"\$"+$x.text+"."+$y.text);
@@ -307,19 +307,19 @@ RULE_SCOPE_ATTR
}
}
StringTemplate st;
-			Rule refdRule = grammar.getRule(refdRuleName);
-			AttributeScope scope = refdRule.getLocalAttributeScope($y.text);
+			Rule refdRule = grammar.GetRule(refdRuleName);
+			AttributeScope scope = refdRule.GetLocalAttributeScope($y.text);
if ( scope.isPredefinedRuleScope )
{
-				st = template("ruleLabelPropertyRef_"+$y.text);
-				grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+				st = Template("ruleLabelPropertyRef_"+$y.text);
+				grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
st.SetAttribute("scope", label);
st.SetAttribute("attr", $y.text);
}
else if ( scope.isPredefinedLexerRuleScope )
{
-				st = template("lexerRuleLabelPropertyRef_"+$y.text);
-				grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
+				st = Template("lexerRuleLabelPropertyRef_"+$y.text);
+				grammar.ReferenceRuleLabelPredefinedAttribute(refdRuleName);
st.SetAttribute("scope", label);
st.SetAttribute("attr", $y.text);
}
@@ -329,10 +329,10 @@ RULE_SCOPE_ATTR
}
else
{
-				st = template("ruleLabelRef");
+				st = Template("ruleLabelRef");
st.SetAttribute("referencedRule", refdRule);
st.SetAttribute("scope", label);
-				st.SetAttribute("attr", scope.getAttribute($y.text));
+				st.SetAttribute("attr", scope.GetAttribute($y.text));
}
}
;
@@ -341,21 +341,21 @@ RULE_SCOPE_ATTR
/** $label	either a token label or token/rule list label like label+=expr */
LABEL_REF
:	'$' ID {enclosingRule!=null &&
-	            getElementLabel($ID.text)!=null &&
-		        enclosingRule.getRuleLabel($ID.text)==null}?
+	            GetElementLabel($ID.text)!=null &&
+		        enclosingRule.GetRuleLabel($ID.text)==null}?
// {JSystem.@out.println("found \$label");}
{
StringTemplate st;
-			Grammar.LabelElementPair pair = getElementLabel($ID.text);
+			Grammar.LabelElementPair pair = GetElementLabel($ID.text);
if ( pair.type==Grammar.RULE_LIST_LABEL ||
pair.type==Grammar.TOKEN_LIST_LABEL ||
pair.type == Grammar.WILDCARD_TREE_LIST_LABEL )
{
-				st = template("listLabelRef");
+				st = Template("listLabelRef");
}
else
{
-				st = template("tokenLabelRef");
+				st = Template("tokenLabelRef");
}
st.SetAttribute("label", $ID.text);
}
@@ -363,21 +363,21 @@ LABEL_REF

/** $tokenref in a non-lexer grammar */
ISOLATED_TOKEN_REF
-	:	'$' ID	{grammar.type!=Grammar.LEXER && enclosingRule!=null && isTokenRefInAlt($ID.text)}?
+	:	'$' ID	{grammar.type!=Grammar.LEXER && enclosingRule!=null && IsTokenRefInAlt($ID.text)}?
//{JSystem.@out.println("found \$tokenref");}
{
-			string label = enclosingRule.getElementLabel($ID.text, outerAltNum, generator);
-			checkElementRefUniqueness($ID.text, true);
+			string label = enclosingRule.GetElementLabel($ID.text, outerAltNum, generator);
+			CheckElementRefUniqueness($ID.text, true);
if ( label==null )
{
-				ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+				ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
grammar,
actionToken,
$ID.text);
}
else
{
-				StringTemplate st = template("tokenLabelRef");
+				StringTemplate st = Template("tokenLabelRef");
st.SetAttribute("label", label);
}
}
@@ -387,21 +387,21 @@ ISOLATED_TOKEN_REF
ISOLATED_LEXER_RULE_REF
:	'$' ID	{grammar.type==Grammar.LEXER &&
enclosingRule!=null &&
-	             isRuleRefInAlt($ID.text)}?
+	             IsRuleRefInAlt($ID.text)}?
//{JSystem.@out.println("found \$lexerruleref");}
{
-			string label = enclosingRule.getElementLabel($ID.text, outerAltNum, generator);
-			checkElementRefUniqueness($ID.text, false);
+			string label = enclosingRule.GetElementLabel($ID.text, outerAltNum, generator);
+			CheckElementRefUniqueness($ID.text, false);
if ( label==null )
{
-				ErrorManager.grammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
+				ErrorManager.GrammarError(ErrorManager.MSG_FORWARD_ELEMENT_REF,
grammar,
actionToken,
$ID.text);
}
else
{
-				StringTemplate st = template("lexerRuleLabel");
+				StringTemplate st = Template("lexerRuleLabel");
st.SetAttribute("label", label);
}
}
@@ -420,25 +420,25 @@ ISOLATED_LEXER_RULE_REF
*/
SET_LOCAL_ATTR
:	'$' ID WS? '=' expr=ATTR_VALUE_EXPR ';' {enclosingRule!=null
-													&& enclosingRule.getLocalAttributeScope($ID.text)!=null
-													&& !enclosingRule.getLocalAttributeScope($ID.text).isPredefinedLexerRuleScope}?
+													&& enclosingRule.GetLocalAttributeScope($ID.text)!=null
+													&& !enclosingRule.GetLocalAttributeScope($ID.text).isPredefinedLexerRuleScope}?
//{JSystem.@out.println("found set \$localattr");}
{
StringTemplate st;
-			AttributeScope scope = enclosingRule.getLocalAttributeScope($ID.text);
+			AttributeScope scope = enclosingRule.GetLocalAttributeScope($ID.text);
if ( scope.isPredefinedRuleScope )
{
if ($ID.text.Equals("tree") || $ID.text.Equals("st"))
{
-					st = template("ruleSetPropertyRef_"+$ID.text);
-					grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+					st = Template("ruleSetPropertyRef_"+$ID.text);
+					grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
st.SetAttribute("scope", enclosingRule.name);
st.SetAttribute("attr", $ID.text);
-					st.SetAttribute("expr", translateAction($expr.text));
+					st.SetAttribute("expr", TranslateAction($expr.text));
}
else
{
-					ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
+					ErrorManager.GrammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
actionToken,
$ID.text,
@@ -447,48 +447,48 @@ SET_LOCAL_ATTR
}
else if ( scope.isParameterScope )
{
-				st = template("parameterSetAttributeRef");
-				st.SetAttribute("attr", scope.getAttribute($ID.text));
-				st.SetAttribute("expr", translateAction($expr.text));
+				st = Template("parameterSetAttributeRef");
+				st.SetAttribute("attr", scope.GetAttribute($ID.text));
+				st.SetAttribute("expr", TranslateAction($expr.text));
}
else
{
-				st = template("returnSetAttributeRef");
+				st = Template("returnSetAttributeRef");
st.SetAttribute("ruleDescriptor", enclosingRule);
-				st.SetAttribute("attr", scope.getAttribute($ID.text));
-				st.SetAttribute("expr", translateAction($expr.text));
+				st.SetAttribute("attr", scope.GetAttribute($ID.text));
+				st.SetAttribute("expr", TranslateAction($expr.text));
}
}
;
LOCAL_ATTR
-	:	'$' ID {enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null}?
+	:	'$' ID {enclosingRule!=null && enclosingRule.GetLocalAttributeScope($ID.text)!=null}?
//{JSystem.@out.println("found \$localattr");}
{
StringTemplate st;
-			AttributeScope scope = enclosingRule.getLocalAttributeScope($ID.text);
+			AttributeScope scope = enclosingRule.GetLocalAttributeScope($ID.text);
if ( scope.isPredefinedRuleScope )
{
-				st = template("rulePropertyRef_"+$ID.text);
-				grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
+				st = Template("rulePropertyRef_"+$ID.text);
+				grammar.ReferenceRuleLabelPredefinedAttribute(enclosingRule.name);
st.SetAttribute("scope", enclosingRule.name);
st.SetAttribute("attr", $ID.text);
}
else if ( scope.isPredefinedLexerRuleScope )
{
-				st = template("lexerRulePropertyRef_"+$ID.text);
+				st = Template("lexerRulePropertyRef_"+$ID.text);
st.SetAttribute("scope", enclosingRule.name);
st.SetAttribute("attr", $ID.text);
}
else if ( scope.isParameterScope )
{
-				st = template("parameterAttributeRef");
-				st.SetAttribute("attr", scope.getAttribute($ID.text));
+				st = Template("parameterAttributeRef");
+				st.SetAttribute("attr", scope.GetAttribute($ID.text));
}
else
{
-				st = template("returnAttributeRef");
+				st = Template("returnAttributeRef");
st.SetAttribute("ruleDescriptor", enclosingRule);
-				st.SetAttribute("attr", scope.getAttribute($ID.text));
+				st.SetAttribute("attr", scope.GetAttribute($ID.text));
}
}
;
@@ -507,17 +507,17 @@ LOCAL_ATTR
*/
SET_DYNAMIC_SCOPE_ATTR
:	'$' x=ID '::' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
-						   {resolveDynamicScope($x.text)!=null &&
-						     resolveDynamicScope($x.text).getAttribute($y.text)!=null}?
+						   {ResolveDynamicScope($x.text)!=null &&
+						     ResolveDynamicScope($x.text).GetAttribute($y.text)!=null}?
//{JSystem.@out.println("found set \$scope::attr "+ $x.text + "::" + $y.text + " to " + $expr.text);}
{
-			AttributeScope scope = resolveDynamicScope($x.text);
+			AttributeScope scope = ResolveDynamicScope($x.text);
if ( scope!=null )
{
-				StringTemplate st = template("scopeSetAttributeRef");
+				StringTemplate st = Template("scopeSetAttributeRef");
st.SetAttribute("scope", $x.text);
-				st.SetAttribute("attr",  scope.getAttribute($y.text));
-				st.SetAttribute("expr",  translateAction($expr.text));
+				st.SetAttribute("attr",  scope.GetAttribute($y.text));
+				st.SetAttribute("expr",  TranslateAction($expr.text));
}
else
{
@@ -528,16 +528,16 @@ SET_DYNAMIC_SCOPE_ATTR

DYNAMIC_SCOPE_ATTR
:	'$' x=ID '::' y=ID
-						   {resolveDynamicScope($x.text)!=null &&
-						     resolveDynamicScope($x.text).getAttribute($y.text)!=null}?
+						   {ResolveDynamicScope($x.text)!=null &&
+						     ResolveDynamicScope($x.text).GetAttribute($y.text)!=null}?
//{JSystem.@out.println("found \$scope::attr "+ $x.text + "::" + $y.text);}
{
-			AttributeScope scope = resolveDynamicScope($x.text);
+			AttributeScope scope = ResolveDynamicScope($x.text);
if ( scope!=null )
{
-				StringTemplate st = template("scopeAttributeRef");
+				StringTemplate st = Template("scopeAttributeRef");
st.SetAttribute("scope", $x.text);
-				st.SetAttribute("attr",  scope.getAttribute($y.text));
+				st.SetAttribute("attr",  scope.GetAttribute($y.text));
}
else
{
@@ -569,9 +569,9 @@ DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
:	'$' x=ID '[' '-' expr=SCOPE_INDEX_EXPR ']' '::' y=ID
// {JSystem.@out.println("found \$scope[-...]::attr");}
{
-			StringTemplate st = template("scopeAttributeRef");
+			StringTemplate st = Template("scopeAttributeRef");
st.SetAttribute("scope",    $x.text);
-			st.SetAttribute("attr",     resolveDynamicScope($x.text).getAttribute($y.text));
+			st.SetAttribute("attr",     ResolveDynamicScope($x.text).GetAttribute($y.text));
st.SetAttribute("negIndex", $expr.text);
}
;
@@ -580,9 +580,9 @@ DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
:	'$' x=ID '[' expr=SCOPE_INDEX_EXPR ']' '::' y=ID
// {JSystem.@out.println("found \$scope[...]::attr");}
{
-			StringTemplate st = template("scopeAttributeRef");
+			StringTemplate st = Template("scopeAttributeRef");
st.SetAttribute("scope", $x.text);
-			st.SetAttribute("attr",  resolveDynamicScope($x.text).getAttribute($y.text));
+			st.SetAttribute("attr",  ResolveDynamicScope($x.text).GetAttribute($y.text));
st.SetAttribute("index", $expr.text);
}
;
@@ -598,10 +598,10 @@ SCOPE_INDEX_EXPR
* 			which would be ambiguous.  See TestAttributes.testAmbiguousRuleRef()
*/
ISOLATED_DYNAMIC_SCOPE
-	:	'$' ID {resolveDynamicScope($ID.text)!=null}?
+	:	'$' ID {ResolveDynamicScope($ID.text)!=null}?
// {JSystem.@out.println("found isolated \$scope where scope is a dynamic scope");}
{
-			StringTemplate st = template("isolatedDynamicScopeRef");
+			StringTemplate st = Template("isolatedDynamicScopeRef");
st.SetAttribute("scope", $ID.text);
}
;
@@ -656,12 +656,12 @@ SET_EXPR_ATTRIBUTE
:	'%' a=ACTION '.' ID WS? '=' expr=ATTR_VALUE_EXPR ';'
// {JSystem.@out.println("found \%{expr}.y = z;");}
{
-			StringTemplate st = template("actionSetAttribute");
+			StringTemplate st = Template("actionSetAttribute");
string action = $a.text;
action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
-			st.SetAttribute("st", translateAction(action));
+			st.SetAttribute("st", TranslateAction(action));
st.SetAttribute("attrName", $ID.text);
-			st.SetAttribute("expr", translateAction($expr.text));
+			st.SetAttribute("expr", TranslateAction($expr.text));
}
;

@@ -673,10 +673,10 @@ SET_ATTRIBUTE
:	'%' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
// {JSystem.@out.println("found \%x.y = z;");}
{
-			StringTemplate st = template("actionSetAttribute");
+			StringTemplate st = Template("actionSetAttribute");
st.SetAttribute("st", $x.text);
st.SetAttribute("attrName", $y.text);
-			st.SetAttribute("expr", translateAction($expr.text));
+			st.SetAttribute("expr", TranslateAction($expr.text));
}
;

@@ -691,10 +691,10 @@ TEMPLATE_EXPR
:	'%' a=ACTION
// {JSystem.@out.println("found \%{expr}");}
{
-			StringTemplate st = template("actionStringConstructor");
+			StringTemplate st = Template("actionStringConstructor");
string action = $a.text;
action = action.Substring( 1, action.Length - 2 ); // stuff inside {...}
-			st.SetAttribute("stringExpr", translateAction(action));
+			st.SetAttribute("stringExpr", TranslateAction(action));
}
;

@@ -738,7 +738,7 @@ UNKNOWN_SYNTAX
|	'%' (ID|'.'|'('|')'|','|'{'|'}'|'"')*
{
chunks.Add(Text);
-			ErrorManager.grammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
+			ErrorManager.GrammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
grammar,
actionToken,
Text);
diff --git a/Antlr3/Grammars/ActionTranslatorHelper.cs b/Antlr3/Grammars/ActionTranslatorHelper.cs
index ff8959b..d29f607 100644
--- a/Antlr3/Grammars/ActionTranslatorHelper.cs
+++ b/Antlr3/Grammars/ActionTranslatorHelper.cs
@@ -65,7 +65,7 @@ namespace Antlr3.Grammars
{
this.generator = generator;
this.grammar = generator.grammar;
-            this.enclosingRule = grammar.getLocallyDefinedRule( ruleName );
+            this.enclosingRule = grammar.GetLocallyDefinedRule( ruleName );
this.actionToken = actionAST.token;
this.outerAltNum = actionAST.outerAltNum;
}
@@ -78,7 +78,7 @@ namespace Antlr3.Grammars
{
this.generator = generator;
grammar = generator.grammar;
-            this.enclosingRule = grammar.getRule( ruleName );
+            this.enclosingRule = grammar.GetRule( ruleName );
this.actionToken = actionToken;
this.outerAltNum = outerAltNum;
}
@@ -86,7 +86,7 @@ namespace Antlr3.Grammars
/** Return a list of strings and StringTemplate objects that
*  represent the translated action.
*/
-        public IList translateToChunks()
+        public IList TranslateToChunks()
{
// JSystem.@out.println("###\naction="+action);
IToken t;
@@ -97,9 +97,9 @@ namespace Antlr3.Grammars
return chunks;
}

-        public string translate()
+        public string Translate()
{
-            IList theChunks = translateToChunks();
+            IList theChunks = TranslateToChunks();
//JSystem.@out.println("chunks="+a.chunks);
StringBuilder buf = new StringBuilder();
for ( int i = 0; i < theChunks.Count; i++ )
@@ -111,7 +111,7 @@ namespace Antlr3.Grammars
return buf.ToString();
}

-        public IList translateAction( string action )
+        public IList TranslateAction( string action )
{
string rname = null;
if ( enclosingRule != null )
@@ -122,36 +122,36 @@ namespace Antlr3.Grammars
new ActionTranslator( generator,
rname,
new CommonToken( ANTLRParser.ACTION, action ), outerAltNum );
-            return translator.translateToChunks();
+            return translator.TranslateToChunks();
}

-        public bool isTokenRefInAlt( string id )
+        public bool IsTokenRefInAlt( string id )
{
-            return enclosingRule.getTokenRefsInAlt( id, outerAltNum ) != null;
+            return enclosingRule.GetTokenRefsInAlt( id, outerAltNum ) != null;
}
-        public bool isRuleRefInAlt( string id )
+        public bool IsRuleRefInAlt( string id )
{
-            return enclosingRule.getRuleRefsInAlt( id, outerAltNum ) != null;
+            return enclosingRule.GetRuleRefsInAlt( id, outerAltNum ) != null;
}
-        public Grammar.LabelElementPair getElementLabel( string id )
+        public Grammar.LabelElementPair GetElementLabel( string id )
{
-            return enclosingRule.getLabel( id );
+            return enclosingRule.GetLabel( id );
}

-        public void checkElementRefUniqueness( string @ref, bool isToken )
+        public void CheckElementRefUniqueness( string @ref, bool isToken )
{
IList refs = null;
if ( isToken )
{
-                refs = enclosingRule.getTokenRefsInAlt( @ref, outerAltNum );
+                refs = enclosingRule.GetTokenRefsInAlt( @ref, outerAltNum );
}
else
{
-                refs = enclosingRule.getRuleRefsInAlt( @ref, outerAltNum );
+                refs = enclosingRule.GetRuleRefsInAlt( @ref, outerAltNum );
}
if ( refs != null && refs.Count > 1 )
{
-                ErrorManager.grammarError( ErrorManager.MSG_NONUNIQUE_REF,
+                ErrorManager.GrammarError( ErrorManager.MSG_NONUNIQUE_REF,
grammar,
actionToken,
@ref );
@@ -161,24 +161,24 @@ namespace Antlr3.Grammars
/** For \$rulelabel.name, return the Attribute found for name.  It
*  will be a predefined property or a return value.
*/
-        public Attribute getRuleLabelAttribute( string ruleName, string attrName )
+        public Attribute GetRuleLabelAttribute( string ruleName, string attrName )
{
-            Rule r = grammar.getRule( ruleName );
-            AttributeScope scope = r.getLocalAttributeScope( attrName );
+            Rule r = grammar.GetRule( ruleName );
+            AttributeScope scope = r.GetLocalAttributeScope( attrName );
if ( scope != null && !scope.isParameterScope )
{
-                return scope.getAttribute( attrName );
+                return scope.GetAttribute( attrName );
}
return null;
}

-        AttributeScope resolveDynamicScope( string scopeName )
+        AttributeScope ResolveDynamicScope( string scopeName )
{
-            if ( grammar.getGlobalScope( scopeName ) != null )
+            if ( grammar.GetGlobalScope( scopeName ) != null )
{
-                return grammar.getGlobalScope( scopeName );
+                return grammar.GetGlobalScope( scopeName );
}
-            Rule scopeRule = grammar.getRule( scopeName );
+            Rule scopeRule = grammar.GetRule( scopeName );
if ( scopeRule != null )
{
return scopeRule.ruleScope;
@@ -186,7 +186,7 @@ namespace Antlr3.Grammars
return null; // not a valid dynamic scope
}

-        protected StringTemplate template( string name )
+        protected StringTemplate Template( string name )
{
StringTemplate st = generator.Templates.GetInstanceOf( name );
chunks.Add( st );
diff --git a/Antlr3/Grammars/AssignTokenTypesWalker.cs b/Antlr3/Grammars/AssignTokenTypesWalker.cs
index 6a657a3..8660961 100644
--- a/Antlr3/Grammars/AssignTokenTypesWalker.cs
+++ b/Antlr3/Grammars/AssignTokenTypesWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\AssignTokenTypesWalker.g3 2009-03-23 17:54:01
+// $ANTLR 3.1.2 Grammars\\AssignTokenTypesWalker.g3 2009-04-16 21:09:05

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -236,7 +236,7 @@ public partial class AssignTokenTypesWalker : TreeParser
{

if ( state.backtracking == 0 )
-				init(g);
+				Init(g);

try
{
@@ -805,7 +805,7 @@ public partial class AssignTokenTypesWalker : TreeParser
// check for grammar-level option to import vocabulary
if ( currentRuleName==null && key.Equals("tokenVocab") )
{
-							grammar.importTokenVocabulary(ID1,(string)(optionValue2!=null?optionValue2.value:default(Object)));
+							grammar.ImportTokenVocabulary(ID1,(string)(optionValue2!=null?optionValue2.value:default(Object)));
}


@@ -1233,7 +1233,7 @@ public partial class AssignTokenTypesWalker : TreeParser
// Grammars\\AssignTokenTypesWalker.g3:221:4: t= TOKEN_REF
{
t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec438);
-				trackToken(t);
+				TrackToken(t);

}
break;
@@ -1244,7 +1244,7 @@ public partial class AssignTokenTypesWalker : TreeParser

Match(input, TokenConstants.Down, null);
t2=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec465);
-				trackToken(t2);
+				TrackToken(t2);
// Grammars\\AssignTokenTypesWalker.g3:224:4: (s= STRING_LITERAL |c= CHAR_LITERAL )
int alt16=2;
int LA16_0 = input.LA(1);
@@ -1269,7 +1269,7 @@ public partial class AssignTokenTypesWalker : TreeParser
// Grammars\\AssignTokenTypesWalker.g3:224:6: s= STRING_LITERAL
{
s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_tokenSpec482);
-					trackString(s); alias(t2,s);
+					TrackString(s); Alias(t2,s);

}
break;
@@ -1277,7 +1277,7 @@ public partial class AssignTokenTypesWalker : TreeParser
// Grammars\\AssignTokenTypesWalker.g3:225:6: c= CHAR_LITERAL
{
c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_tokenSpec493);
-					trackString(c); alias(t2,c);
+					TrackString(c); Alias(t2,c);

}
break;
@@ -1644,7 +1644,7 @@ public partial class AssignTokenTypesWalker : TreeParser
}

Match(input,EOR,Follow._EOR_in_rule630);
-			trackTokenRule(id,(m!=null?((GrammarAST)m.start):null),(b!=null?((GrammarAST)b.start):null));
+			TrackTokenRule(id,(m!=null?((GrammarAST)m.start):null),(b!=null?((GrammarAST)b.start):null));

Match(input, TokenConstants.Up, null);

@@ -3101,7 +3101,7 @@ public partial class AssignTokenTypesWalker : TreeParser

Match(input, TokenConstants.Up, null);
}
-				trackToken(t);
+				TrackToken(t);

}
break;
@@ -3109,7 +3109,7 @@ public partial class AssignTokenTypesWalker : TreeParser
// Grammars\\AssignTokenTypesWalker.g3:329:4: c= CHAR_LITERAL
{
c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1112);
-				trackString(c);
+				TrackString(c);

}
break;
@@ -3117,7 +3117,7 @@ public partial class AssignTokenTypesWalker : TreeParser
// Grammars\\AssignTokenTypesWalker.g3:330:4: s= STRING_LITERAL
{
s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1123);
-				trackString(s);
+				TrackString(s);

}
break;
@@ -3198,6 +3198,7 @@ public partial class AssignTokenTypesWalker : TreeParser
// $ANTLR end "ast_suffix"
#endregion Rules

+
#region Follow sets
public static class Follow
{
diff --git a/Antlr3/Grammars/AssignTokenTypesWalker.g3 b/Antlr3/Grammars/AssignTokenTypesWalker.g3
index cc3107b..be43fbb 100644
--- a/Antlr3/Grammars/AssignTokenTypesWalker.g3
+++ b/Antlr3/Grammars/AssignTokenTypesWalker.g3
@@ -140,7 +140,7 @@ grammar_[Grammar g]
@init
{
if ( state.backtracking == 0 )
-		init($g);
+		Init($g);
}
:	(	^( LEXER_GRAMMAR 	  grammarSpec )
|	^( PARSER_GRAMMAR   grammarSpec )
@@ -176,7 +176,7 @@ option[Map opts]
// check for grammar-level option to import vocabulary
if ( currentRuleName==null && key.Equals("tokenVocab") )
{
-				grammar.importTokenVocabulary($ID,(string)$optionValue.value);
+				grammar.ImportTokenVocabulary($ID,(string)$optionValue.value);
}
}
;
@@ -218,11 +218,11 @@ tokensSpec
;

tokenSpec
-	:	t=TOKEN_REF            {trackToken($t);}
+	:	t=TOKEN_REF            {TrackToken($t);}
|	^(	ASSIGN
-			t2=TOKEN_REF       {trackToken($t2);}
-			( s=STRING_LITERAL {trackString($s); alias($t2,$s);}
-			| c=CHAR_LITERAL   {trackString($c); alias($t2,$c);}
+			t2=TOKEN_REF       {TrackToken($t2);}
+			( s=STRING_LITERAL {TrackString($s); Alias($t2,$s);}
+			| c=CHAR_LITERAL   {TrackString($c); Alias($t2,$c);}
)
)
;
@@ -243,7 +243,7 @@ rule
b=block
(exceptionGroup)?
EOR
-			{trackTokenRule($id,$m.start,$b.start);}
+			{TrackTokenRule($id,$m.start,$b.start);}
)
;

@@ -325,9 +325,9 @@ tree_

atom
:	^( RULE_REF (ARG_ACTION)? )
-	|	^( t=TOKEN_REF (ARG_ACTION )? ) {trackToken($t);}
-	|	c=CHAR_LITERAL   {trackString($c);}
-	|	s=STRING_LITERAL {trackString($s);}
+	|	^( t=TOKEN_REF (ARG_ACTION )? ) {TrackToken($t);}
+	|	c=CHAR_LITERAL   {TrackString($c);}
+	|	s=STRING_LITERAL {TrackString($s);}
|	WILDCARD
|	^(DOT ID atom) // scope override on rule
;
diff --git a/Antlr3/Grammars/AssignTokenTypesWalkerHelper.cs b/Antlr3/Grammars/AssignTokenTypesWalkerHelper.cs
index 9dceb34..714aaf1 100644
--- a/Antlr3/Grammars/AssignTokenTypesWalkerHelper.cs
+++ b/Antlr3/Grammars/AssignTokenTypesWalkerHelper.cs
@@ -58,7 +58,7 @@ namespace Antlr3.Grammars
{
token = ( (NoViableAltException)ex ).token;
}
-            ErrorManager.syntaxError(
+            ErrorManager.SyntaxError(
ErrorManager.MSG_SYNTAX_ERROR,
grammar,
token,
@@ -67,7 +67,7 @@ namespace Antlr3.Grammars
}


-        protected void initASTPatterns()
+        protected void InitASTPatterns()
{
ITreeAdaptor adaptor = new ANTLRParser.grammar_Adaptor( null );

@@ -123,37 +123,37 @@ namespace Antlr3.Grammars
}

// Behavior moved to AssignTokenTypesBehavior
-        protected virtual void trackString( GrammarAST t )
+        protected virtual void TrackString( GrammarAST t )
{
}
-        protected virtual void trackToken( GrammarAST t )
+        protected virtual void TrackToken( GrammarAST t )
{
}
-        protected virtual void trackTokenRule( GrammarAST t, GrammarAST modifier, GrammarAST block )
+        protected virtual void TrackTokenRule( GrammarAST t, GrammarAST modifier, GrammarAST block )
{
}
-        protected virtual void alias( GrammarAST t, GrammarAST s )
+        protected virtual void Alias( GrammarAST t, GrammarAST s )
{
}
-        protected internal virtual void defineTokens( Grammar root )
+        protected internal virtual void DefineTokens( Grammar root )
{
}
-        protected virtual void defineStringLiteralsFromDelegates()
+        protected virtual void DefineStringLiteralsFromDelegates()
{
}
-        protected virtual void assignStringTypes( Grammar root )
+        protected virtual void AssignStringTypes( Grammar root )
{
}
-        protected virtual void aliasTokenIDsAndLiterals( Grammar root )
+        protected virtual void AliasTokenIDsAndLiterals( Grammar root )
{
}
-        protected virtual void assignTokenIDTypes( Grammar root )
+        protected virtual void AssignTokenIDTypes( Grammar root )
{
}
-        protected virtual void defineTokenNamesAndLiteralsInGrammar( Grammar root )
+        protected virtual void DefineTokenNamesAndLiteralsInGrammar( Grammar root )
{
}
-        protected virtual void init( Grammar root )
+        protected virtual void Init( Grammar root )
{
}
}
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.cs b/Antlr3/Grammars/CodeGenTreeWalker.cs
index 61c314f..93810b3 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-16 19:01:29
+// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-16 21:13:39

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -195,24 +195,24 @@ public partial class CodeGenTreeWalker : TreeParser

if ( state.backtracking == 0 )
{
-				init(g);
+				Init(g);
this.recognizerST = recognizerST;
this.outputFileST = outputFileST;
this.headerFileST = headerFileST;
-				string superClass = (string)g.getOption("superClass");
-				outputOption = (string)g.getOption("output");
+				string superClass = (string)g.GetOption("superClass");
+				outputOption = (string)g.GetOption("output");
recognizerST.SetAttribute("superClass", superClass);
if ( g.type!=Grammar.LEXER ) {
-					recognizerST.SetAttribute("ASTLabelType", g.getOption("ASTLabelType"));
+					recognizerST.SetAttribute("ASTLabelType", g.GetOption("ASTLabelType"));
}
-				if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
-					ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
+				if ( g.type==Grammar.TREE_PARSER && g.GetOption("ASTLabelType")==null ) {
+					ErrorManager.GrammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
g,
null,
g.name);
}
if ( g.type!=Grammar.TREE_PARSER ) {
-					recognizerST.SetAttribute("labelType", g.getOption("TokenLabelType"));
+					recognizerST.SetAttribute("labelType", g.GetOption("TokenLabelType"));
}
recognizerST.SetAttribute("numRules", grammar.Rules.Count);
outputFileST.SetAttribute("numRules", grammar.Rules.Count);
@@ -492,9 +492,9 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							recognizerST.SetAttribute("name", grammar.getRecognizerName());
-							outputFileST.SetAttribute("name", grammar.getRecognizerName());
-							headerFileST.SetAttribute("name", grammar.getRecognizerName());
+							recognizerST.SetAttribute("name", grammar.GetRecognizerName());
+							outputFileST.SetAttribute("name", grammar.GetRecognizerName());
+							headerFileST.SetAttribute("name", grammar.GetRecognizerName());
recognizerST.SetAttribute("scopes", grammar.GlobalScopes);
headerFileST.SetAttribute("scopes", grammar.GlobalScopes);

@@ -823,7 +823,7 @@ public partial class CodeGenTreeWalker : TreeParser


string ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
-			bool generated = grammar.generateMethodForRule(ruleName);
+			bool generated = grammar.GenerateMethodForRule(ruleName);

try
{
@@ -965,7 +965,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
-										generated = grammar.generateMethodForRule(ruleName);
+										generated = grammar.GenerateMethodForRule(ruleName);
}


@@ -1026,7 +1026,7 @@ public partial class CodeGenTreeWalker : TreeParser
// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
// for alts of rule
blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
-			Rule ruleDescr = grammar.getRule(((GrammarAST)retval.start).GetChild(0).Text);
+			Rule ruleDescr = grammar.GetRule(((GrammarAST)retval.start).GetChild(0).Text);
currentRuleName = ((GrammarAST)retval.start).GetChild(0).Text;

// For syn preds, we don't want any AST code etc... in there.
@@ -1324,7 +1324,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

description =
-									grammar.grammarTreeToString((GrammarAST)((GrammarAST)retval.start).GetFirstChildWithType(BLOCK),
+									grammar.GrammarTreeToString((GrammarAST)((GrammarAST)retval.start).GetFirstChildWithType(BLOCK),
false);
description =
generator.target.GetTargetStringLiteralFromString(description);
@@ -1357,13 +1357,13 @@ public partial class CodeGenTreeWalker : TreeParser
retval.code = templates.GetInstanceOf(stName);
if ( retval.code.Name.Equals("rule") )
{
-									retval.code.SetAttribute("emptyRule", grammar.isEmptyRule(block2));
+									retval.code.SetAttribute("emptyRule", grammar.IsEmptyRule(block2));
}
retval.code.SetAttribute("ruleDescriptor", ruleDescr);
-								string memo = (string)grammar.getBlockOption(((GrammarAST)retval.start),"memoize");
+								string memo = (string)grammar.GetBlockOption(((GrammarAST)retval.start),"memoize");
if ( memo==null )
{
-									memo = (string)grammar.getOption("memoize");
+									memo = (string)grammar.GetOption("memoize");
}
if ( memo!=null && memo.Equals("true") &&
(stName.Equals("rule")||stName.Equals("lexerRule")) )
@@ -1413,11 +1413,11 @@ public partial class CodeGenTreeWalker : TreeParser
}
else
{
-									description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+									description = grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);
}
-								Rule theRule = grammar.getRule(currentRuleName);
+								Rule theRule = grammar.GetRule(currentRuleName);
generator.TranslateActionAttributeReferencesForSingleScope(
theRule,
theRule.Actions
@@ -2000,11 +2000,11 @@ public partial class CodeGenTreeWalker : TreeParser
{
if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
{
-					Rule r = grammar.getRule(currentRuleName);
-					currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+					Rule r = grammar.GetRule(currentRuleName);
+					currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
if ( currentAltHasASTRewrite )
{
-						r.trackTokenReferenceInAlt(((GrammarAST)retval.start), outerAltNum);
+						r.TrackTokenReferenceInAlt(((GrammarAST)retval.start), outerAltNum);
}
}
}
@@ -2063,11 +2063,11 @@ public partial class CodeGenTreeWalker : TreeParser
int i = ((TokenWithIndex)s.Token).TokenIndex;
if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
{
-								setcode = getTokenElementST("matchRuleBlockSet", "set", s, null, null);
+								setcode = GetTokenElementST("matchRuleBlockSet", "set", s, null, null);
}
else
{
-								setcode = getTokenElementST("matchSet", "set", s, null, null);
+								setcode = GetTokenElementST("matchSet", "set", s, null, null);
}
setcode.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
@@ -2427,10 +2427,10 @@ public partial class CodeGenTreeWalker : TreeParser
*/
if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
{
-					Rule r = grammar.getRule(currentRuleName);
-					currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+					Rule r = grammar.GetRule(currentRuleName);
+					currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
}
-				string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+				string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);
retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
@@ -3081,13 +3081,13 @@ public partial class CodeGenTreeWalker : TreeParser
int ttype=0;
if ( grammar.type==Grammar.LEXER )
{
-										ttype = Grammar.getCharValueFromGrammarCharLiteral((assign_c!=null?assign_c.Text:null));
+										ttype = Grammar.GetCharValueFromGrammarCharLiteral((assign_c!=null?assign_c.Text:null));
}
else
{
-										ttype = grammar.getTokenType((assign_c!=null?assign_c.Text:null));
+										ttype = grammar.GetTokenType((assign_c!=null?assign_c.Text:null));
}
-									elements = grammar.complement(ttype);
+									elements = grammar.Complement(ttype);

}

@@ -3107,9 +3107,9 @@ public partial class CodeGenTreeWalker : TreeParser
}
else
{
-										ttype = grammar.getTokenType((assign_s!=null?assign_s.Text:null));
+										ttype = grammar.GetTokenType((assign_s!=null?assign_s.Text:null));
}
-									elements = grammar.complement(ttype);
+									elements = grammar.Complement(ttype);

}

@@ -3122,8 +3122,8 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-									int ttype = grammar.getTokenType((assign_t!=null?assign_t.Text:null));
-									elements = grammar.complement(ttype);
+									int ttype = grammar.GetTokenType((assign_t!=null?assign_t.Text:null));
+									elements = grammar.Complement(ttype);

}

@@ -3179,7 +3179,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

elements = assign_st.SetValue;
-									elements = grammar.complement(elements);
+									elements = grammar.Complement(elements);

}

@@ -3191,7 +3191,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							code = getTokenElementST("matchSet",
+							code = GetTokenElementST("matchSet",
"set",
(GrammarAST)n.GetChild(0),
astSuffix,
@@ -3377,7 +3377,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+							string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -3420,7 +3420,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
retval.code = templates.GetInstanceOf("tree");
NFAState afterDOWN = (NFAState)((GrammarAST)retval.start).NFATreeDownState.GetTransition(0).target;
-				LookaheadSet s = grammar.LOOK(afterDOWN);
+				LookaheadSet s = grammar.Look(afterDOWN);
if ( s.Member(Label.UP) ) {
// nullable child list if we can see the UP as the next token
// we need an "if ( input.LA(1)==Token.DOWN )" gate around
@@ -3429,8 +3429,8 @@ public partial class CodeGenTreeWalker : TreeParser
}
retval.code.SetAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
-				Rule r = grammar.getRule(currentRuleName);
-				if ( grammar.BuildAST && !r.hasRewrite(outerAltNum) ) {
+				Rule r = grammar.GetRule(currentRuleName);
+				if ( grammar.BuildAST && !r.HasRewrite(outerAltNum) ) {
rootSuffix = new GrammarAST(ROOT,"ROOT");
}
}
@@ -3621,10 +3621,10 @@ public partial class CodeGenTreeWalker : TreeParser
(((GrammarAST)retval.start).Type==RULE_REF||((GrammarAST)retval.start).Type==TOKEN_REF||
((GrammarAST)retval.start).Type==CHAR_LITERAL||((GrammarAST)retval.start).Type==STRING_LITERAL) )
{
-					Rule encRule = grammar.getRule(((GrammarAST)((GrammarAST)retval.start)).enclosingRuleName);
-					if ( encRule!=null && encRule.hasRewrite(outerAltNum) && astSuffix!=null )
+					Rule encRule = grammar.GetRule(((GrammarAST)((GrammarAST)retval.start)).enclosingRuleName);
+					if ( encRule!=null && encRule.HasRewrite(outerAltNum) && astSuffix!=null )
{
-						ErrorManager.grammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
+						ErrorManager.GrammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
grammar,
((GrammarAST)((GrammarAST)retval.start)).Token,
((GrammarAST)((GrammarAST)retval.start)).enclosingRuleName,
@@ -3720,25 +3720,25 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-								grammar.checkRuleReference(scope, r, rarg, currentRuleName);
+								grammar.CheckRuleReference(scope, r, rarg, currentRuleName);
string scopeName = null;
if ( scope!=null ) {
scopeName = scope.Text;
}
-								Rule rdef = grammar.getRule(scopeName, (r!=null?r.Text:null));
+								Rule rdef = grammar.GetRule(scopeName, (r!=null?r.Text:null));
// don't insert label=r() if label.attr not used, no ret value, ...
if ( !rdef.HasReturnValue ) {
labelText = null;
}
-								retval.code = getRuleElementST("ruleRef", (r!=null?r.Text:null), r, astSuffix, labelText);
+								retval.code = GetRuleElementST("ruleRef", (r!=null?r.Text:null), r, astSuffix, labelText);
retval.code.SetAttribute("rule", rdef);
if ( scope!=null ) { // scoped rule ref
-									Grammar scopeG = grammar.composite.getGrammar(scope.Text);
+									Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
retval.code.SetAttribute("scope", scopeG);
}
else if ( rdef.grammar != this.grammar ) { // nonlocal
// if rule definition is not in this grammar, it's nonlocal
-									IList<Grammar> rdefDelegates = rdef.grammar.getDelegates();
+									IList<Grammar> rdefDelegates = rdef.grammar.GetDelegates();
if ( rdefDelegates.Contains(this.grammar) ) {
retval.code.SetAttribute("scope", rdef.grammar);
}
@@ -3803,22 +3803,22 @@ public partial class CodeGenTreeWalker : TreeParser
if ( currentAltHasASTRewrite && t.terminalOptions!=null &&
t.terminalOptions[Grammar.defaultTokenOption]!=null )
{
-									ErrorManager.grammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
+									ErrorManager.GrammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
grammar,
((GrammarAST)(t)).Token,
(t!=null?t.Text:null));
}
-								grammar.checkRuleReference(scope, t, targ, currentRuleName);
+								grammar.CheckRuleReference(scope, t, targ, currentRuleName);
if ( grammar.type==Grammar.LEXER )
{
-									if ( grammar.getTokenType((t!=null?t.Text:null))==Label.EOF )
+									if ( grammar.GetTokenType((t!=null?t.Text:null))==Label.EOF )
{
retval.code = templates.GetInstanceOf("lexerMatchEOF");
}
else
{
retval.code = templates.GetInstanceOf("lexerRuleRef");
-										if ( isListLabel(labelText) )
+										if ( IsListLabel(labelText) )
{
retval.code = templates.GetInstanceOf("lexerRuleRefAndListLabel");
}
@@ -3827,11 +3827,11 @@ public partial class CodeGenTreeWalker : TreeParser
{
scopeName = scope.Text;
}
-										Rule rdef2 = grammar.getRule(scopeName, (t!=null?t.Text:null));
+										Rule rdef2 = grammar.GetRule(scopeName, (t!=null?t.Text:null));
retval.code.SetAttribute("rule", rdef2);
if ( scope!=null )
{ // scoped rule ref
-											Grammar scopeG = grammar.composite.getGrammar(scope.Text);
+											Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
retval.code.SetAttribute("scope", scopeG);
}
else if ( rdef2.grammar != this.grammar )
@@ -3852,9 +3852,9 @@ public partial class CodeGenTreeWalker : TreeParser
}
else
{
-									retval.code = getTokenElementST("tokenRef", (t!=null?t.Text:null), t, astSuffix, labelText);
+									retval.code = GetTokenElementST("tokenRef", (t!=null?t.Text:null), t, astSuffix, labelText);
string tokenLabel =
-										generator.GetTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
+										generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType(t.Text));
retval.code.SetAttribute("token",tokenLabel);
if ( !currentAltHasASTRewrite && t.terminalOptions!=null )
{
@@ -3888,8 +3888,8 @@ public partial class CodeGenTreeWalker : TreeParser
}
}
else { // else it's a token type reference
-									retval.code = getTokenElementST("tokenRef", "char_literal", c, astSuffix, labelText);
-									string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.getTokenType((c!=null?c.Text:null)));
+									retval.code = GetTokenElementST("tokenRef", "char_literal", c, astSuffix, labelText);
+									string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType((c!=null?c.Text:null)));
retval.code.SetAttribute("token",tokenLabel);
if ( c.terminalOptions!=null ) {
retval.code.SetAttribute("hetero",c.terminalOptions[Grammar.defaultTokenOption]);
@@ -3922,9 +3922,9 @@ public partial class CodeGenTreeWalker : TreeParser
}
else
{ // else it's a token type reference
-									retval.code = getTokenElementST("tokenRef", "string_literal", s, astSuffix, labelText);
+									retval.code = GetTokenElementST("tokenRef", "string_literal", s, astSuffix, labelText);
string tokenLabel =
-										generator.GetTokenTypeAsTargetLabel(grammar.getTokenType((s!=null?s.Text:null)));
+										generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType((s!=null?s.Text:null)));
retval.code.SetAttribute("token",tokenLabel);
if ( s.terminalOptions!=null )
{
@@ -3946,7 +3946,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-								retval.code = getWildcardST(w,astSuffix,labelText);
+								retval.code = GetWildcardST(w,astSuffix,labelText);
retval.code.SetAttribute("elementIndex", ((TokenWithIndex)w.Token).TokenIndex);

}
@@ -4110,7 +4110,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							code = getTokenElementST("matchSet", "set", s, astSuffix, labelText);
+							code = GetTokenElementST("matchSet", "set", s, astSuffix, labelText);
int i = ((TokenWithIndex)s.Token).TokenIndex;
code.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
@@ -4258,19 +4258,19 @@ public partial class CodeGenTreeWalker : TreeParser
retval.code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
retval.code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
retval.code.SetAttribute("referencedElementsDeep",
-										  getTokenTypesAsTargetLabels(((GrammarAST)retval.start).rewriteRefsDeep));
+										  GetTokenTypesAsTargetLabels(((GrammarAST)retval.start).rewriteRefsDeep));
HashSet<string> tokenLabels =
-							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.TOKEN_LABEL);
+							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.TOKEN_LABEL);
HashSet<string> tokenListLabels =
-							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
+							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
HashSet<string> ruleLabels =
-							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.RULE_LABEL);
+							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.RULE_LABEL);
HashSet<string> ruleListLabels =
-							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
+							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
HashSet<string> wildcardLabels =
-							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
+							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
HashSet<string> wildcardListLabels =
-							grammar.getLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
+							grammar.GetLabels(((GrammarAST)retval.start).rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
// just in case they ref r for "previous value", make a stream
// from retval.tree
StringTemplate retvalST = templates.GetInstanceOf("prevRuleRootRef");
@@ -4358,7 +4358,7 @@ public partial class CodeGenTreeWalker : TreeParser
predChunks = generator.TranslateAction(currentRuleName,pred);
}
string description =
-											grammar.grammarTreeToString(r,false);
+											grammar.GrammarTreeToString(r,false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("alts.{pred,alt,description}",
predChunks,
@@ -4428,9 +4428,9 @@ public partial class CodeGenTreeWalker : TreeParser
{

currentBlockST.SetAttribute("referencedElementsDeep",
-									getTokenTypesAsTargetLabels(BLOCK14.rewriteRefsDeep));
+									GetTokenTypesAsTargetLabels(BLOCK14.rewriteRefsDeep));
currentBlockST.SetAttribute("referencedElements",
-									getTokenTypesAsTargetLabels(BLOCK14.rewriteRefsShallow));
+									GetTokenTypesAsTargetLabels(BLOCK14.rewriteRefsShallow));

}

@@ -4926,7 +4926,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-								string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -4954,7 +4954,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-								string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -4982,7 +4982,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-								string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+								string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -5102,7 +5102,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
+							string description = grammar.GrammarTreeToString(((GrammarAST)retval.start), false);
description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

@@ -5198,18 +5198,18 @@ public partial class CodeGenTreeWalker : TreeParser
}
retval.code = templates.GetInstanceOf(stName);
retval.code.SetAttribute("rule", ruleRefName);
-								if ( grammar.getRule(ruleRefName)==null )
+								if ( grammar.GetRule(ruleRefName)==null )
{
-									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
+									ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
grammar,
((GrammarAST)(r)).Token,
ruleRefName);
retval.code = new StringTemplate(); // blank; no code gen
}
-								else if ( grammar.getRule(currentRuleName)
-											 .getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
+								else if ( grammar.GetRule(currentRuleName)
+											 .GetRuleRefsInAlt(ruleRefName,outerAltNum)==null )
{
-									ErrorManager.grammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
+									ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
grammar,
((GrammarAST)(r)).Token,
ruleRefName);
@@ -5318,8 +5318,8 @@ public partial class CodeGenTreeWalker : TreeParser
GrammarAST term = (tk) ?? (cl) ?? (sl);
string tokenName = ((GrammarAST)retval.start).Token.Text;
string stName = "rewriteTokenRef";
-								Rule rule = grammar.getRule(currentRuleName);
-								ICollection<string> tokenRefsInAlt = rule.getTokenRefsInAlt(outerAltNum);
+								Rule rule = grammar.GetRule(currentRuleName);
+								ICollection<string> tokenRefsInAlt = rule.GetTokenRefsInAlt(outerAltNum);
bool createNewNode = !tokenRefsInAlt.Contains(tokenName) || arg!=null;
object hetero = null;
if ( term.terminalOptions!=null )
@@ -5342,12 +5342,12 @@ public partial class CodeGenTreeWalker : TreeParser
retval.code.SetAttribute("args", args);
}
retval.code.SetAttribute("elementIndex", ((TokenWithIndex)((GrammarAST)retval.start).Token).TokenIndex);
-								int ttype = grammar.getTokenType(tokenName);
+								int ttype = grammar.GetTokenType(tokenName);
string tok = generator.GetTokenTypeAsTargetLabel(ttype);
retval.code.SetAttribute("token", tok);
-								if ( grammar.getTokenType(tokenName)==Label.INVALID )
+								if ( grammar.GetTokenType(tokenName)==Label.INVALID )
{
-									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
+									ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
grammar,
((GrammarAST)(((GrammarAST)retval.start))).Token,
tokenName);
@@ -5366,15 +5366,15 @@ public partial class CodeGenTreeWalker : TreeParser
{

string labelName = (LABEL22!=null?LABEL22.Text:null);
-								Rule rule = grammar.getRule(currentRuleName);
-								Grammar.LabelElementPair pair = rule.getLabel(labelName);
+								Rule rule = grammar.GetRule(currentRuleName);
+								Grammar.LabelElementPair pair = rule.GetLabel(labelName);
if ( labelName.Equals(currentRuleName) )
{
// special case; ref to old value via $ rule
-									if ( rule.hasRewrite(outerAltNum) &&
-										 rule.getRuleRefsInAlt(outerAltNum).Contains(labelName) )
+									if ( rule.HasRewrite(outerAltNum) &&
+										 rule.GetRuleRefsInAlt(outerAltNum).Contains(labelName) )
{
-										ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+										ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
grammar,
((GrammarAST)(LABEL22)).Token,
labelName);
@@ -5385,7 +5385,7 @@ public partial class CodeGenTreeWalker : TreeParser
}
else if ( pair==null )
{
-									ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
+									ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
grammar,
((GrammarAST)(LABEL22)).Token,
labelName);
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index 9867598..a5f6003 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -102,24 +102,24 @@ grammar_[Grammar g,
{
if ( state.backtracking == 0 )
{
-		init(g);
+		Init(g);
this.recognizerST = recognizerST;
this.outputFileST = outputFileST;
this.headerFileST = headerFileST;
-		string superClass = (string)g.getOption("superClass");
-		outputOption = (string)g.getOption("output");
+		string superClass = (string)g.GetOption("superClass");
+		outputOption = (string)g.GetOption("output");
recognizerST.SetAttribute("superClass", superClass);
if ( g.type!=Grammar.LEXER ) {
-			recognizerST.SetAttribute("ASTLabelType", g.getOption("ASTLabelType"));
+			recognizerST.SetAttribute("ASTLabelType", g.GetOption("ASTLabelType"));
}
-		if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
-			ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
+		if ( g.type==Grammar.TREE_PARSER && g.GetOption("ASTLabelType")==null ) {
+			ErrorManager.GrammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
g,
null,
g.name);
}
if ( g.type!=Grammar.TREE_PARSER ) {
-			recognizerST.SetAttribute("labelType", g.getOption("TokenLabelType"));
+			recognizerST.SetAttribute("labelType", g.GetOption("TokenLabelType"));
}
$recognizerST.SetAttribute("numRules", grammar.Rules.Count);
$outputFileST.SetAttribute("numRules", grammar.Rules.Count);
@@ -146,9 +146,9 @@ grammarSpec
}
)?
{
-			recognizerST.SetAttribute("name", grammar.getRecognizerName());
-			outputFileST.SetAttribute("name", grammar.getRecognizerName());
-			headerFileST.SetAttribute("name", grammar.getRecognizerName());
+			recognizerST.SetAttribute("name", grammar.GetRecognizerName());
+			outputFileST.SetAttribute("name", grammar.GetRecognizerName());
+			headerFileST.SetAttribute("name", grammar.GetRecognizerName());
recognizerST.SetAttribute("scopes", grammar.GlobalScopes);
headerFileST.SetAttribute("scopes", grammar.GlobalScopes);
}
@@ -164,7 +164,7 @@ rules[StringTemplate recognizerST]
@init
{
string ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
-	bool generated = grammar.generateMethodForRule(ruleName);
+	bool generated = grammar.GenerateMethodForRule(ruleName);
}
:	(	(	options {k=1;} :
{generated}? =>
@@ -184,7 +184,7 @@ rules[StringTemplate recognizerST]
{
ruleName = ((GrammarAST)input.LT(1)).GetChild(0).Text;
//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
-					generated = grammar.generateMethodForRule(ruleName);
+					generated = grammar.GenerateMethodForRule(ruleName);
}
}}
)+
@@ -200,7 +200,7 @@ rule returns [StringTemplate code=null]
// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
// for alts of rule
blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
-	Rule ruleDescr = grammar.getRule($start.GetChild(0).Text);
+	Rule ruleDescr = grammar.GetRule($start.GetChild(0).Text);
currentRuleName = $start.GetChild(0).Text;

// For syn preds, we don't want any AST code etc... in there.
@@ -225,7 +225,7 @@ rule returns [StringTemplate code=null]
b=block["ruleBlock", dfa]
{
description =
-					grammar.grammarTreeToString((GrammarAST)$start.GetFirstChildWithType(BLOCK),
+					grammar.GrammarTreeToString((GrammarAST)$start.GetFirstChildWithType(BLOCK),
false);
description =
generator.target.GetTargetStringLiteralFromString(description);
@@ -258,13 +258,13 @@ rule returns [StringTemplate code=null]
$code = templates.GetInstanceOf(stName);
if ( $code.Name.Equals("rule") )
{
-					$code.SetAttribute("emptyRule", grammar.isEmptyRule(block2));
+					$code.SetAttribute("emptyRule", grammar.IsEmptyRule(block2));
}
$code.SetAttribute("ruleDescriptor", ruleDescr);
-				string memo = (string)grammar.getBlockOption($start,"memoize");
+				string memo = (string)grammar.GetBlockOption($start,"memoize");
if ( memo==null )
{
-					memo = (string)grammar.getOption("memoize");
+					memo = (string)grammar.GetOption("memoize");
}
if ( memo!=null && memo.Equals("true") &&
(stName.Equals("rule")||stName.Equals("lexerRule")) )
@@ -288,11 +288,11 @@ rule returns [StringTemplate code=null]
}
else
{
-					description = grammar.grammarTreeToString($start,false);
+					description = grammar.GrammarTreeToString($start,false);
description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
-				Rule theRule = grammar.getRule(currentRuleName);
+				Rule theRule = grammar.GetRule(currentRuleName);
generator.TranslateActionAttributeReferencesForSingleScope(
theRule,
theRule.Actions
@@ -399,11 +399,11 @@ setBlock returns [StringTemplate code=null]
{
if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
{
-			Rule r = grammar.getRule(currentRuleName);
-			currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+			Rule r = grammar.GetRule(currentRuleName);
+			currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
if ( currentAltHasASTRewrite )
{
-				r.trackTokenReferenceInAlt($start, outerAltNum);
+				r.TrackTokenReferenceInAlt($start, outerAltNum);
}
}
}
@@ -413,11 +413,11 @@ setBlock returns [StringTemplate code=null]
int i = ((TokenWithIndex)$s.Token).TokenIndex;
if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
{
-				setcode = getTokenElementST("matchRuleBlockSet", "set", $s, null, null);
+				setcode = GetTokenElementST("matchRuleBlockSet", "set", $s, null, null);
}
else
{
-				setcode = getTokenElementST("matchSet", "set", $s, null, null);
+				setcode = GetTokenElementST("matchSet", "set", $s, null, null);
}
setcode.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
@@ -492,10 +492,10 @@ alternative returns [StringTemplate code]
*/
if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.BuildAST )
{
-			Rule r = grammar.getRule(currentRuleName);
-			currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+			Rule r = grammar.GetRule(currentRuleName);
+			currentAltHasASTRewrite = r.HasRewrite(outerAltNum);
}
-		string description = grammar.grammarTreeToString($start, false);
+		string description = grammar.GrammarTreeToString($start, false);
description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
$code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
@@ -615,13 +615,13 @@ notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [String
int ttype=0;
if ( grammar.type==Grammar.LEXER )
{
-					ttype = Grammar.getCharValueFromGrammarCharLiteral($assign_c.text);
+					ttype = Grammar.GetCharValueFromGrammarCharLiteral($assign_c.text);
}
else
{
-					ttype = grammar.getTokenType($assign_c.text);
+					ttype = grammar.GetTokenType($assign_c.text);
}
-				elements = grammar.complement(ttype);
+				elements = grammar.Complement(ttype);
}
|	assign_s=STRING_LITERAL
{
@@ -632,23 +632,23 @@ notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [String
}
else
{
-					ttype = grammar.getTokenType($assign_s.text);
+					ttype = grammar.GetTokenType($assign_s.text);
}
-				elements = grammar.complement(ttype);
+				elements = grammar.Complement(ttype);
}
|	assign_t=TOKEN_REF
{
-				int ttype = grammar.getTokenType($assign_t.text);
-				elements = grammar.complement(ttype);
+				int ttype = grammar.GetTokenType($assign_t.text);
+				elements = grammar.Complement(ttype);
}
|	^(assign_st=BLOCK .*)
{
elements = $assign_st.SetValue;
-				elements = grammar.complement(elements);
+				elements = grammar.Complement(elements);
}
)
{
-			$code = getTokenElementST("matchSet",
+			$code = GetTokenElementST("matchSet",
"set",
(GrammarAST)$n.GetChild(0),
astSuffix,
@@ -684,7 +684,7 @@ ebnf returns [StringTemplate code=null]
{ $code = $blk.code; }
)
{
-			string description = grammar.grammarTreeToString($start, false);
+			string description = grammar.GrammarTreeToString($start, false);
description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
@@ -699,7 +699,7 @@ tree_ returns [StringTemplate code]
{
$code = templates.GetInstanceOf("tree");
NFAState afterDOWN = (NFAState)$start.NFATreeDownState.GetTransition(0).target;
-		LookaheadSet s = grammar.LOOK(afterDOWN);
+		LookaheadSet s = grammar.Look(afterDOWN);
if ( s.Member(Label.UP) ) {
// nullable child list if we can see the UP as the next token
// we need an "if ( input.LA(1)==Token.DOWN )" gate around
@@ -708,8 +708,8 @@ tree_ returns [StringTemplate code]
}
$code.SetAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
$code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
-		Rule r = grammar.getRule(currentRuleName);
-		if ( grammar.BuildAST && !r.hasRewrite(outerAltNum) ) {
+		Rule r = grammar.GetRule(currentRuleName);
+		if ( grammar.BuildAST && !r.HasRewrite(outerAltNum) ) {
rootSuffix = new GrammarAST(ROOT,"ROOT");
}
}
@@ -764,10 +764,10 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
($start.Type==RULE_REF||$start.Type==TOKEN_REF||
$start.Type==CHAR_LITERAL||$start.Type==STRING_LITERAL) )
{
-			Rule encRule = grammar.getRule(((GrammarAST)$start).enclosingRuleName);
-			if ( encRule!=null && encRule.hasRewrite(outerAltNum) && astSuffix!=null )
+			Rule encRule = grammar.GetRule(((GrammarAST)$start).enclosingRuleName);
+			if ( encRule!=null && encRule.HasRewrite(outerAltNum) && astSuffix!=null )
{
-				ErrorManager.grammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
+				ErrorManager.GrammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
grammar,
((GrammarAST)$start).Token,
((GrammarAST)$start).enclosingRuleName,
@@ -779,25 +779,25 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
:   ^( r=RULE_REF (rarg=ARG_ACTION)? )
{
-			grammar.checkRuleReference(scope, $r, $rarg, currentRuleName);
+			grammar.CheckRuleReference(scope, $r, $rarg, currentRuleName);
string scopeName = null;
if ( scope!=null ) {
scopeName = scope.Text;
}
-			Rule rdef = grammar.getRule(scopeName, $r.text);
+			Rule rdef = grammar.GetRule(scopeName, $r.text);
// don't insert label=r() if $label.attr not used, no ret value, ...
if ( !rdef.HasReturnValue ) {
labelText = null;
}
-			$code = getRuleElementST("ruleRef", $r.text, $r, astSuffix, labelText);
+			$code = GetRuleElementST("ruleRef", $r.text, $r, astSuffix, labelText);
$code.SetAttribute("rule", rdef);
if ( scope!=null ) { // scoped rule ref
-				Grammar scopeG = grammar.composite.getGrammar(scope.Text);
+				Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
$code.SetAttribute("scope", scopeG);
}
else if ( rdef.grammar != this.grammar ) { // nonlocal
// if rule definition is not in this grammar, it's nonlocal
-				IList<Grammar> rdefDelegates = rdef.grammar.getDelegates();
+				IList<Grammar> rdefDelegates = rdef.grammar.GetDelegates();
if ( rdefDelegates.Contains(this.grammar) ) {
$code.SetAttribute("scope", rdef.grammar);
}
@@ -827,22 +827,22 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
if ( currentAltHasASTRewrite && $t.terminalOptions!=null &&
$t.terminalOptions[Grammar.defaultTokenOption]!=null )
{
-				ErrorManager.grammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
+				ErrorManager.GrammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
grammar,
((GrammarAST)($t)).Token,
$t.text);
}
-			grammar.checkRuleReference(scope, $t, $targ, currentRuleName);
+			grammar.CheckRuleReference(scope, $t, $targ, currentRuleName);
if ( grammar.type==Grammar.LEXER )
{
-				if ( grammar.getTokenType($t.text)==Label.EOF )
+				if ( grammar.GetTokenType($t.text)==Label.EOF )
{
$code = templates.GetInstanceOf("lexerMatchEOF");
}
else
{
$code = templates.GetInstanceOf("lexerRuleRef");
-					if ( isListLabel(labelText) )
+					if ( IsListLabel(labelText) )
{
$code = templates.GetInstanceOf("lexerRuleRefAndListLabel");
}
@@ -851,11 +851,11 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
{
scopeName = scope.Text;
}
-					Rule rdef2 = grammar.getRule(scopeName, $t.text);
+					Rule rdef2 = grammar.GetRule(scopeName, $t.text);
$code.SetAttribute("rule", rdef2);
if ( scope!=null )
{ // scoped rule ref
-						Grammar scopeG = grammar.composite.getGrammar(scope.Text);
+						Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
$code.SetAttribute("scope", scopeG);
}
else if ( rdef2.grammar != this.grammar )
@@ -876,9 +876,9 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
else
{
-				$code = getTokenElementST("tokenRef", $t.text, $t, astSuffix, labelText);
+				$code = GetTokenElementST("tokenRef", $t.text, $t, astSuffix, labelText);
string tokenLabel =
-					generator.GetTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
+					generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType(t.Text));
$code.SetAttribute("token",tokenLabel);
if ( !currentAltHasASTRewrite && $t.terminalOptions!=null )
{
@@ -904,8 +904,8 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
}
else { // else it's a token type reference
-				$code = getTokenElementST("tokenRef", "char_literal", $c, astSuffix, labelText);
-				string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.getTokenType($c.text));
+				$code = GetTokenElementST("tokenRef", "char_literal", $c, astSuffix, labelText);
+				string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType($c.text));
$code.SetAttribute("token",tokenLabel);
if ( $c.terminalOptions!=null ) {
$code.SetAttribute("hetero",$c.terminalOptions[Grammar.defaultTokenOption]);
@@ -930,9 +930,9 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
else
{ // else it's a token type reference
-				$code = getTokenElementST("tokenRef", "string_literal", $s, astSuffix, labelText);
+				$code = GetTokenElementST("tokenRef", "string_literal", $s, astSuffix, labelText);
string tokenLabel =
-					generator.GetTokenTypeAsTargetLabel(grammar.getTokenType($s.text));
+					generator.GetTokenTypeAsTargetLabel(grammar.GetTokenType($s.text));
$code.SetAttribute("token",tokenLabel);
if ( $s.terminalOptions!=null )
{
@@ -946,7 +946,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]

|	w=WILDCARD
{
-			$code = getWildcardST($w,astSuffix,labelText);
+			$code = GetWildcardST($w,astSuffix,labelText);
$code.SetAttribute("elementIndex", ((TokenWithIndex)$w.Token).TokenIndex);
}

@@ -973,7 +973,7 @@ set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
}
:	^(s=BLOCK .*) // only care that it's a BLOCK with setValue!=null
{
-			$code = getTokenElementST("matchSet", "set", $s, astSuffix, labelText);
+			$code = GetTokenElementST("matchSet", "set", $s, astSuffix, labelText);
int i = ((TokenWithIndex)$s.Token).TokenIndex;
$code.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
@@ -1010,19 +1010,19 @@ rewrite returns [StringTemplate code=null]
$code.SetAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
$code.SetAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
$code.SetAttribute("referencedElementsDeep",
-								  getTokenTypesAsTargetLabels($start.rewriteRefsDeep));
+								  GetTokenTypesAsTargetLabels($start.rewriteRefsDeep));
HashSet<string> tokenLabels =
-					grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LABEL);
+					grammar.GetLabels($start.rewriteRefsDeep, Grammar.TOKEN_LABEL);
HashSet<string> tokenListLabels =
-					grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
+					grammar.GetLabels($start.rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
HashSet<string> ruleLabels =
-					grammar.getLabels($start.rewriteRefsDeep, Grammar.RULE_LABEL);
+					grammar.GetLabels($start.rewriteRefsDeep, Grammar.RULE_LABEL);
HashSet<string> ruleListLabels =
-					grammar.getLabels($start.rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
+					grammar.GetLabels($start.rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
HashSet<string> wildcardLabels =
-					grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
+					grammar.GetLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
HashSet<string> wildcardListLabels =
-					grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
+					grammar.GetLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
// just in case they ref $r for "previous value", make a stream
// from retval.tree
StringTemplate retvalST = templates.GetInstanceOf("prevRuleRootRef");
@@ -1055,7 +1055,7 @@ rewrite returns [StringTemplate code=null]
predChunks = generator.TranslateAction(currentRuleName,$pred);
}
string description =
-					grammar.grammarTreeToString($r,false);
+					grammar.GrammarTreeToString($r,false);
description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("alts.{pred,alt,description}",
predChunks,
@@ -1081,9 +1081,9 @@ rewrite_block[string blockTemplateName] returns [StringTemplate code=null]
:	^(	BLOCK
{
currentBlockST.SetAttribute("referencedElementsDeep",
-					getTokenTypesAsTargetLabels($BLOCK.rewriteRefsDeep));
+					GetTokenTypesAsTargetLabels($BLOCK.rewriteRefsDeep));
currentBlockST.SetAttribute("referencedElements",
-					getTokenTypesAsTargetLabels($BLOCK.rewriteRefsShallow));
+					GetTokenTypesAsTargetLabels($BLOCK.rewriteRefsShallow));
}
alt=rewrite_alternative
EOB
@@ -1142,21 +1142,21 @@ rewrite_ebnf returns [StringTemplate code=null]
:	^( OPTIONAL rewrite_block["rewriteOptionalBlock"] )
{ $code = $rewrite_block.code; }
{
-			string description = grammar.grammarTreeToString($start, false);
+			string description = grammar.GrammarTreeToString($start, false);
description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
|	^( CLOSURE rewrite_block["rewriteClosureBlock"] )
{ $code = $rewrite_block.code; }
{
-			string description = grammar.grammarTreeToString($start, false);
+			string description = grammar.GrammarTreeToString($start, false);
description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
|	^( POSITIVE_CLOSURE rewrite_block["rewritePositiveClosureBlock"] )
{ $code = $rewrite_block.code; }
{
-			string description = grammar.grammarTreeToString($start, false);
+			string description = grammar.GrammarTreeToString($start, false);
description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
@@ -1194,7 +1194,7 @@ rewrite_tree returns [StringTemplate code]
)*
)
{
-			string description = grammar.grammarTreeToString($start, false);
+			string description = grammar.GrammarTreeToString($start, false);
description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
@@ -1212,18 +1212,18 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
}
$code = templates.GetInstanceOf(stName);
$code.SetAttribute("rule", ruleRefName);
-			if ( grammar.getRule(ruleRefName)==null )
+			if ( grammar.GetRule(ruleRefName)==null )
{
-				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
+				ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
grammar,
((GrammarAST)($r)).Token,
ruleRefName);
$code = new StringTemplate(); // blank; no code gen
}
-			else if ( grammar.getRule(currentRuleName)
-						 .getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
+			else if ( grammar.GetRule(currentRuleName)
+						 .GetRuleRefsInAlt(ruleRefName,outerAltNum)==null )
{
-				ErrorManager.grammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
+				ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
grammar,
((GrammarAST)($r)).Token,
ruleRefName);
@@ -1248,8 +1248,8 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
GrammarAST term = ($tk) ?? ($cl) ?? ($sl);
string tokenName = $start.Token.Text;
string stName = "rewriteTokenRef";
-			Rule rule = grammar.getRule(currentRuleName);
-			ICollection<string> tokenRefsInAlt = rule.getTokenRefsInAlt(outerAltNum);
+			Rule rule = grammar.GetRule(currentRuleName);
+			ICollection<string> tokenRefsInAlt = rule.GetTokenRefsInAlt(outerAltNum);
bool createNewNode = !tokenRefsInAlt.Contains(tokenName) || $arg!=null;
object hetero = null;
if ( term.terminalOptions!=null )
@@ -1272,12 +1272,12 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
$code.SetAttribute("args", args);
}
$code.SetAttribute("elementIndex", ((TokenWithIndex)$start.Token).TokenIndex);
-			int ttype = grammar.getTokenType(tokenName);
+			int ttype = grammar.GetTokenType(tokenName);
string tok = generator.GetTokenTypeAsTargetLabel(ttype);
$code.SetAttribute("token", tok);
-			if ( grammar.getTokenType(tokenName)==Label.INVALID )
+			if ( grammar.GetTokenType(tokenName)==Label.INVALID )
{
-				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
+				ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
grammar,
((GrammarAST)($start)).Token,
tokenName);
@@ -1288,15 +1288,15 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
|	LABEL
{
string labelName = $LABEL.text;
-			Rule rule = grammar.getRule(currentRuleName);
-			Grammar.LabelElementPair pair = rule.getLabel(labelName);
+			Rule rule = grammar.GetRule(currentRuleName);
+			Grammar.LabelElementPair pair = rule.GetLabel(labelName);
if ( labelName.Equals(currentRuleName) )
{
// special case; ref to old value via $ rule
-				if ( rule.hasRewrite(outerAltNum) &&
-					 rule.getRuleRefsInAlt(outerAltNum).Contains(labelName) )
+				if ( rule.HasRewrite(outerAltNum) &&
+					 rule.GetRuleRefsInAlt(outerAltNum).Contains(labelName) )
{
-					ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+					ErrorManager.GrammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
grammar,
((GrammarAST)($LABEL)).Token,
labelName);
@@ -1307,7 +1307,7 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
}
else if ( pair==null )
{
-				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
+				ErrorManager.GrammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
grammar,
((GrammarAST)($LABEL)).Token,
labelName);
diff --git a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
index e138892..5e981ea 100644
--- a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
@@ -74,7 +74,7 @@ namespace Antlr3.Grammars
{
token = ( (NoViableAltException)ex ).token;
}
-            ErrorManager.syntaxError(
+            ErrorManager.SyntaxError(
ErrorManager.MSG_SYNTAX_ERROR,
grammar,
token,
@@ -82,7 +82,7 @@ namespace Antlr3.Grammars
ex );
}

-        public void reportError( string s )
+        public void ReportError( string s )
{
Console.Out.WriteLine( "codegen: error: " + s );
}
@@ -101,34 +101,34 @@ namespace Antlr3.Grammars

protected string outputOption = "";

-        protected StringTemplate getWildcardST( GrammarAST elementAST, GrammarAST ast_suffix, string label )
+        protected StringTemplate GetWildcardST( GrammarAST elementAST, GrammarAST ast_suffix, string label )
{
string name = "wildcard";
if ( grammar.type == Grammar.LEXER )
{
name = "wildcardChar";
}
-            return getTokenElementST( name, name, elementAST, ast_suffix, label );
+            return GetTokenElementST( name, name, elementAST, ast_suffix, label );
}

-        protected StringTemplate getRuleElementST( string name,
+        protected StringTemplate GetRuleElementST( string name,
string ruleTargetName,
GrammarAST elementAST,
GrammarAST ast_suffix,
string label )
{
-            string suffix = getSTSuffix( elementAST, ast_suffix, label );
+            string suffix = GetSTSuffix( elementAST, ast_suffix, label );
name += suffix;
// if we're building trees and there is no label, gen a label
// unless we're in a synpred rule.
-            Rule r = grammar.getRule( currentRuleName );
+            Rule r = grammar.GetRule( currentRuleName );
if ( ( grammar.BuildAST || suffix.Length > 0 ) && label == null &&
( r == null || !r.isSynPred ) )
{
// we will need a label to do the AST or tracking, make one
label = generator.CreateUniqueLabel( ruleTargetName );
CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
-                grammar.defineRuleRefLabel( currentRuleName, labelTok, elementAST );
+                grammar.DefineRuleRefLabel( currentRuleName, labelTok, elementAST );
}
StringTemplate elementST = templates.GetInstanceOf( name );
if ( label != null )
@@ -138,7 +138,7 @@ namespace Antlr3.Grammars
return elementST;
}

-        protected StringTemplate getTokenElementST( string name,
+        protected StringTemplate GetTokenElementST( string name,
string elementName,
GrammarAST elementAST,
GrammarAST ast_suffix,
@@ -158,16 +158,16 @@ namespace Antlr3.Grammars
}
}

-            string suffix = getSTSuffix( elementAST, ast_suffix, label );
+            string suffix = GetSTSuffix( elementAST, ast_suffix, label );
// if we're building trees and there is no label, gen a label
// unless we're in a synpred rule.
-            Rule r = grammar.getRule( currentRuleName );
+            Rule r = grammar.GetRule( currentRuleName );
if ( ( grammar.BuildAST || suffix.Length > 0 ) && label == null &&
( r == null || !r.isSynPred ) )
{
label = generator.CreateUniqueLabel( elementName );
CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
-                grammar.defineTokenRefLabel( currentRuleName, labelTok, elementAST );
+                grammar.DefineTokenRefLabel( currentRuleName, labelTok, elementAST );
}

StringTemplate elementST = null;
@@ -183,16 +183,16 @@ namespace Antlr3.Grammars
return elementST;
}

-        public bool isListLabel( string label )
+        public bool IsListLabel( string label )
{
bool hasListLabel = false;
if ( label != null )
{
-                Rule r = grammar.getRule( currentRuleName );
+                Rule r = grammar.GetRule( currentRuleName );
//String stName = null;
if ( r != null )
{
-                    Grammar.LabelElementPair pair = r.getLabel( label );
+                    Grammar.LabelElementPair pair = r.GetLabel( label );
if ( pair != null &&
( pair.type == Grammar.TOKEN_LIST_LABEL ||
pair.type == Grammar.RULE_LIST_LABEL ||
@@ -208,7 +208,7 @@ namespace Antlr3.Grammars
/** Return a non-empty template name suffix if the token is to be
*  tracked, added to a tree, or both.
*/
-        protected string getSTSuffix( GrammarAST elementAST, GrammarAST ast_suffix, string label )
+        protected string GetSTSuffix( GrammarAST elementAST, GrammarAST ast_suffix, string label )
{
if ( grammar.type == Grammar.LEXER )
{
@@ -219,7 +219,7 @@ namespace Antlr3.Grammars
string operatorPart = "";
string rewritePart = "";
string listLabelPart = "";
-            Rule ruleDescr = grammar.getRule( currentRuleName );
+            Rule ruleDescr = grammar.GetRule( currentRuleName );
if ( ast_suffix != null && !ruleDescr.isSynPred )
{
if ( ast_suffix.Type == ANTLRParser.ROOT )
@@ -235,7 +235,7 @@ namespace Antlr3.Grammars
{
rewritePart = "Track";
}
-            if ( isListLabel( label ) )
+            if ( IsListLabel( label ) )
{
listLabelPart = "AndListLabel";
}
@@ -246,7 +246,7 @@ namespace Antlr3.Grammars
}

/** Convert rewrite AST lists to target labels list */
-        protected IList<string> getTokenTypesAsTargetLabels( HashSet<GrammarAST> refs )
+        protected IList<string> GetTokenTypesAsTargetLabels( HashSet<GrammarAST> refs )
{
if ( refs == null || refs.Count == 0 )
{
@@ -268,14 +268,14 @@ namespace Antlr3.Grammars
{
// must be char or string literal
label = generator.GetTokenTypeAsTargetLabel(
-                                grammar.getTokenType( t.Text ) );
+                                grammar.GetTokenType( t.Text ) );
}
labels.Add( label );
}
return labels;
}

-        public void init( Grammar g )
+        public void Init( Grammar g )
{
this.grammar = g;
this.generator = grammar.CodeGenerator;
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.cs b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
index 3f31597..a83336d 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.cs
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\DefineGrammarItemsWalker.g3 2009-04-10 17:46:17
+// $ANTLR 3.1.2 Grammars\\DefineGrammarItemsWalker.g3 2009-04-16 21:27:02

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -335,7 +335,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-				finish();
+				Finish();

}
}
@@ -414,9 +414,9 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-							AttributeScope scope = grammar.defineGlobalScope((name!=null?name.Text:null),attrs.token);
+							AttributeScope scope = grammar.DefineGlobalScope((name!=null?name.Text:null),attrs.token);
scope.isDynamicGlobalScope = true;
-							scope.addAttributes((attrs!=null?attrs.Text:null), ';');
+							scope.AddAttributes((attrs!=null?attrs.Text:null), ';');
foreach ( var action in ((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions )
scope.DefineNamedAction( action.Key, action.Value );

@@ -810,7 +810,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-						 grammar.defineNamedAction(amp,scope,nameAST,actionAST);
+						 grammar.DefineNamedAction(amp,scope,nameAST,actionAST);

}

@@ -1371,22 +1371,22 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( Character.isUpperCase(name[0]) && grammar.type==Grammar.COMBINED )
{
// a merged grammar spec, track lexer rules and send to another grammar
-									grammar.defineLexerRuleFoundInParser(id.token, ((GrammarAST)retval.start));
+									grammar.DefineLexerRuleFoundInParser(id.token, ((GrammarAST)retval.start));
}
else
{
-									int numAlts = countAltsForRule(((GrammarAST)retval.start));
-									grammar.defineRule(id.Token, (modifier4!=null?modifier4.mod:default(string)), opts, ((GrammarAST)retval.start), args, numAlts);
-									r = grammar.getRule(name);
+									int numAlts = CountAltsForRule(((GrammarAST)retval.start));
+									grammar.DefineRule(id.Token, (modifier4!=null?modifier4.mod:default(string)), opts, ((GrammarAST)retval.start), args, numAlts);
+									r = grammar.GetRule(name);
if ( args!=null )
{
-										r.parameterScope = grammar.createParameterScope(name,args.Token);
-										r.parameterScope.addAttributes((args!=null?args.Text:null), ',');
+										r.parameterScope = grammar.CreateParameterScope(name,args.Token);
+										r.parameterScope.AddAttributes((args!=null?args.Text:null), ',');
}
if ( ret!=null )
{
-										r.returnScope = grammar.createReturnScope(name,ret.token);
-										r.returnScope.addAttributes((ret!=null?ret.Text:null), ',');
+										r.returnScope = grammar.CreateReturnScope(name,ret.token);
+										r.returnScope.AddAttributes((ret!=null?ret.Text:null), ',');
}
if ( throwsSpec5 != null )
{
@@ -1494,7 +1494,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

// copy rule options into the block AST, which is where
// the analysis will look for k option etc...
-								(b!=null?((GrammarAST)b.start):null).setBlockOptions( opts );
+								(b!=null?((GrammarAST)b.start):null).BlockOptions = opts;

}

@@ -1538,7 +1538,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
Match(input, TokenConstants.Up, null); if (state.failed) return ;
if ( state.backtracking == 0 )
{
-				if (r!=null) r.defineNamedAction(amp,id,a);
+				if (r!=null) r.DefineNamedAction(amp,id,a);
}

}
@@ -1759,9 +1759,9 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-											r.ruleScope = grammar.createRuleScope(r.name,attrs.token);
+											r.ruleScope = grammar.CreateRuleScope(r.name,attrs.token);
r.ruleScope.isDynamicRuleScope = true;
-											r.ruleScope.addAttributes((attrs!=null?attrs.Text:null), ';');
+											r.ruleScope.AddAttributes((attrs!=null?attrs.Text:null), ';');
foreach ( var action in ((AttributeScopeActions_scope)AttributeScopeActions_stack.Peek()).actions )
r.ruleScope.DefineNamedAction( action.Key, action.Value );

@@ -1793,8 +1793,8 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-												if ( grammar.getGlobalScope((uses!=null?uses.Text:null))==null ) {
-												ErrorManager.grammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
+												if ( grammar.GetGlobalScope((uses!=null?uses.Text:null))==null ) {
+												ErrorManager.GrammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
grammar,
uses.token,
(uses!=null?uses.Text:null));
@@ -2044,9 +2044,9 @@ public partial class DefineGrammarItemsWalker : TreeParser

if ( state.backtracking == 0 )
{
-				if ( grammar.type!=Grammar.LEXER && grammar.getOption("output")!=null && blockLevel==1 )
+				if ( grammar.type!=Grammar.LEXER && grammar.GetOption("output")!=null && blockLevel==1 )
{
-					GrammarAST aRewriteNode = ((GrammarAST)retval.start).findFirstType(REWRITE); // alt itself has rewrite?
+					GrammarAST aRewriteNode = ((GrammarAST)retval.start).FindFirstType(REWRITE); // alt itself has rewrite?
GrammarAST rewriteAST = (GrammarAST)((GrammarAST)retval.start).Parent.GetChild(((GrammarAST)retval.start).ChildIndex + 1);
// we have a rewrite if alt uses it inside subrule or this alt has one
// but don't count -> ... rewrites, which mean "do default auto construction"
@@ -2056,8 +2056,8 @@ public partial class DefineGrammarItemsWalker : TreeParser
rewriteAST.GetChild(0)!=null &&
rewriteAST.GetChild(0).Type!=ETC) )
{
-						Rule r = grammar.getRule(currentRuleName);
-						r.trackAltsWithRewrites(((GrammarAST)retval.start),this.outerAltNum);
+						Rule r = grammar.GetRule(currentRuleName);
+						r.TrackAltsWithRewrites(((GrammarAST)retval.start),this.outerAltNum);
}
}
}
@@ -2276,7 +2276,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
Match(input, TokenConstants.Up, null); if (state.failed) return ;
if ( state.backtracking == 0 )
{
-				trackInlineAction(ACTION7);
+				TrackInlineAction(ACTION7);
}

}
@@ -2314,7 +2314,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
Match(input, TokenConstants.Up, null); if (state.failed) return ;
if ( state.backtracking == 0 )
{
-				trackInlineAction(ACTION8);
+				TrackInlineAction(ACTION8);
}

}
@@ -2484,15 +2484,15 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
if ( e.Type==RULE_REF)
{
-										grammar.defineRuleRefLabel(currentRuleName,id.token,e);
+										grammar.DefineRuleRefLabel(currentRuleName,id.token,e);
}
else if ( e.Type==WILDCARD && grammar.type==Grammar.TREE_PARSER )
{
-										grammar.defineWildcardTreeLabel(currentRuleName,id.token,e);
+										grammar.DefineWildcardTreeLabel(currentRuleName,id.token,e);
}
else
{
-										grammar.defineTokenRefLabel(currentRuleName,id.Token,e);
+										grammar.DefineTokenRefLabel(currentRuleName,id.Token,e);
}

}
@@ -2521,15 +2521,15 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
if ( a.Type==RULE_REF )
{
-										grammar.defineRuleListLabel(currentRuleName,id2.Token,a);
+										grammar.DefineRuleListLabel(currentRuleName,id2.Token,a);
}
else if ( a.Type == WILDCARD && grammar.type == Grammar.TREE_PARSER )
{
-										grammar.defineWildcardTreeListLabel( currentRuleName, id2.token, a );
+										grammar.DefineWildcardTreeListLabel( currentRuleName, id2.token, a );
}
else
{
-										grammar.defineTokenListLabel(currentRuleName,id2.Token,a);
+										grammar.DefineTokenListLabel(currentRuleName,id2.Token,a);
}

}
@@ -2584,7 +2584,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{

act.outerAltNum = this.outerAltNum;
-								trackInlineAction(act);
+								TrackInlineAction(act);

}

@@ -2598,7 +2598,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{

act2.outerAltNum = this.outerAltNum;
-								trackInlineAction(act2);
+								TrackInlineAction(act2);

}

@@ -2612,7 +2612,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{

SEMPRED9.outerAltNum = this.outerAltNum;
-								trackInlineAction(SEMPRED9);
+								TrackInlineAction(SEMPRED9);

}

@@ -2682,7 +2682,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{

GATED_SEMPRED10.outerAltNum = this.outerAltNum;
-								trackInlineAction(GATED_SEMPRED10);
+								TrackInlineAction(GATED_SEMPRED10);

}

@@ -2892,7 +2892,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
// otherwise they (analysis?) look til EOF!
opts["k"] = 1;
}
-							block.setOptions(grammar,opts);
+							block.SetOptions(grammar,opts);

}

@@ -3116,11 +3116,11 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( state.backtracking == 0 )
{

-								grammar.altReferencesRule( currentRuleName, scope_, rr, this.outerAltNum );
+								grammar.AltReferencesRule( currentRuleName, scope_, rr, this.outerAltNum );
if ( rarg != null )
{
rarg.outerAltNum = this.outerAltNum;
-									trackInlineAction(rarg);
+									TrackInlineAction(rarg);
}

}
@@ -3164,15 +3164,15 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( targ != null )
{
targ.outerAltNum = this.outerAltNum;
-									trackInlineAction(targ);
+									TrackInlineAction(targ);
}
if ( grammar.type == Grammar.LEXER )
{
-									grammar.altReferencesRule( currentRuleName, scope_, t, this.outerAltNum );
+									grammar.AltReferencesRule( currentRuleName, scope_, t, this.outerAltNum );
}
else
{
-									grammar.altReferencesTokenID( currentRuleName, t, this.outerAltNum );
+									grammar.AltReferencesTokenID( currentRuleName, t, this.outerAltNum );
}

}
@@ -3188,9 +3188,9 @@ public partial class DefineGrammarItemsWalker : TreeParser

if ( grammar.type != Grammar.LEXER )
{
-									Rule rule = grammar.getRule(currentRuleName);
+									Rule rule = grammar.GetRule(currentRuleName);
if ( rule != null )
-										rule.trackTokenReferenceInAlt(c, outerAltNum);
+										rule.TrackTokenReferenceInAlt(c, outerAltNum);
}

}
@@ -3206,9 +3206,9 @@ public partial class DefineGrammarItemsWalker : TreeParser

if ( grammar.type != Grammar.LEXER )
{
-									Rule rule = grammar.getRule(currentRuleName);
+									Rule rule = grammar.GetRule(currentRuleName);
if ( rule!=null )
-										rule.trackTokenReferenceInAlt(s, outerAltNum);
+										rule.TrackTokenReferenceInAlt(s, outerAltNum);
}

}
@@ -3371,7 +3371,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( pred != null )
{
pred.outerAltNum = this.outerAltNum;
-											trackInlineAction(pred);
+											TrackInlineAction(pred);
}

}
@@ -3990,8 +3990,8 @@ public partial class DefineGrammarItemsWalker : TreeParser

if ( state.backtracking == 0 )
{
-				Rule r = grammar.getRule(currentRuleName);
-				var tokenRefsInAlt = r.getTokenRefsInAlt(outerAltNum);
+				Rule r = grammar.GetRule(currentRuleName);
+				var tokenRefsInAlt = r.GetTokenRefsInAlt(outerAltNum);
boolean imaginary =
((GrammarAST)retval.start).Type==TOKEN_REF &&
!tokenRefsInAlt.Contains(((GrammarAST)retval.start).Text);
@@ -4117,7 +4117,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{

ARG_ACTION12.outerAltNum = this.outerAltNum;
-														trackInlineAction(ARG_ACTION12);
+														TrackInlineAction(ARG_ACTION12);

}

@@ -4167,7 +4167,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{

ACTION13.outerAltNum = this.outerAltNum;
-								trackInlineAction(ACTION13);
+								TrackInlineAction(ACTION13);

}

@@ -4321,7 +4321,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{

a.outerAltNum = this.outerAltNum;
-														trackInlineAction(a);
+														TrackInlineAction(a);

}

@@ -4346,7 +4346,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( ind!=null )
{
ind.outerAltNum = this.outerAltNum;
-										trackInlineAction(ind);
+										TrackInlineAction(ind);
}

}
@@ -4394,7 +4394,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{

act.outerAltNum = this.outerAltNum;
-								trackInlineAction(act);
+								TrackInlineAction(act);

}

diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.g3 b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
index 1baefdc..df97278 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.g3
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
@@ -98,7 +98,7 @@ root = $start;
}
@after
{
-finish();
+Finish();
}
:	^( LEXER_GRAMMAR	{grammar.type = Grammar.LEXER;} 		grammarSpec )
|	^( PARSER_GRAMMAR	{grammar.type = Grammar.PARSER;}		grammarSpec )
@@ -114,9 +114,9 @@ scope AttributeScopeActions;
}
:	^( 'scope' name=ID attrScopeAction* attrs=ACTION )
{
-			AttributeScope scope = grammar.defineGlobalScope($name.text,$attrs.token);
+			AttributeScope scope = grammar.DefineGlobalScope($name.text,$attrs.token);
scope.isDynamicGlobalScope = true;
-			scope.addAttributes($attrs.text, ';');
+			scope.AddAttributes($attrs.text, ';');
foreach ( var action in $AttributeScopeActions::actions )
scope.DefineNamedAction( action.Key, action.Value );
}
@@ -158,7 +158,7 @@ action
)
)
{
-		 grammar.defineNamedAction($amp,scope,nameAST,actionAST);
+		 grammar.DefineNamedAction($amp,scope,nameAST,actionAST);
}
;

@@ -207,22 +207,22 @@ rule
if ( Character.isUpperCase(name[0]) && grammar.type==Grammar.COMBINED )
{
// a merged grammar spec, track lexer rules and send to another grammar
-					grammar.defineLexerRuleFoundInParser($id.token, $start);
+					grammar.DefineLexerRuleFoundInParser($id.token, $start);
}
else
{
-					int numAlts = countAltsForRule($start);
-					grammar.defineRule($id.Token, $modifier.mod, opts, $start, $args, numAlts);
-					r = grammar.getRule(name);
+					int numAlts = CountAltsForRule($start);
+					grammar.DefineRule($id.Token, $modifier.mod, opts, $start, $args, numAlts);
+					r = grammar.GetRule(name);
if ( $args!=null )
{
-						r.parameterScope = grammar.createParameterScope(name,$args.Token);
-						r.parameterScope.addAttributes($args.text, ',');
+						r.parameterScope = grammar.CreateParameterScope(name,$args.Token);
+						r.parameterScope.AddAttributes($args.text, ',');
}
if ( $ret!=null )
{
-						r.returnScope = grammar.createReturnScope(name,$ret.token);
-						r.returnScope.addAttributes($ret.text, ',');
+						r.returnScope = grammar.CreateReturnScope(name,$ret.token);
+						r.returnScope.AddAttributes($ret.text, ',');
}
if ( $throwsSpec.exceptions != null )
{
@@ -240,13 +240,13 @@ rule
{
// copy rule options into the block AST, which is where
// the analysis will look for k option etc...
-				$b.start.setBlockOptions( opts );
+				$b.start.BlockOptions = opts;
}
)
;

ruleAction[Rule r]
-	:	^(amp=AMPERSAND id=ID a=ACTION ) {if (r!=null) r.defineNamedAction($amp,$id,$a);}
+	:	^(amp=AMPERSAND id=ID a=ACTION ) {if (r!=null) r.DefineNamedAction($amp,$id,$a);}
;

modifier returns [string mod]
@@ -277,17 +277,17 @@ scope AttributeScopeActions;
:	^(	'scope'
(	attrScopeAction* attrs=ACTION
{
-					r.ruleScope = grammar.createRuleScope(r.name,$attrs.token);
+					r.ruleScope = grammar.CreateRuleScope(r.name,$attrs.token);
r.ruleScope.isDynamicRuleScope = true;
-					r.ruleScope.addAttributes($attrs.text, ';');
+					r.ruleScope.AddAttributes($attrs.text, ';');
foreach ( var action in $AttributeScopeActions::actions )
r.ruleScope.DefineNamedAction( action.Key, action.Value );
}
)?
(	uses=ID
{
-					if ( grammar.getGlobalScope($uses.text)==null ) {
-					ErrorManager.grammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
+					if ( grammar.GetGlobalScope($uses.text)==null ) {
+					ErrorManager.GrammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
grammar,
$uses.token,
$uses.text);
@@ -333,9 +333,9 @@ alternative
{
if ( state.backtracking == 0 )
{
-		if ( grammar.type!=Grammar.LEXER && grammar.getOption("output")!=null && blockLevel==1 )
+		if ( grammar.type!=Grammar.LEXER && grammar.GetOption("output")!=null && blockLevel==1 )
{
-			GrammarAST aRewriteNode = $start.findFirstType(REWRITE); // alt itself has rewrite?
+			GrammarAST aRewriteNode = $start.FindFirstType(REWRITE); // alt itself has rewrite?
GrammarAST rewriteAST = (GrammarAST)$start.Parent.GetChild($start.ChildIndex + 1);
// we have a rewrite if alt uses it inside subrule or this alt has one
// but don't count -> ... rewrites, which mean "do default auto construction"
@@ -345,8 +345,8 @@ alternative
rewriteAST.GetChild(0)!=null &&
rewriteAST.GetChild(0).Type!=ETC) )
{
-				Rule r = grammar.getRule(currentRuleName);
-				r.trackAltsWithRewrites($start,this.outerAltNum);
+				Rule r = grammar.GetRule(currentRuleName);
+				r.TrackAltsWithRewrites($start,this.outerAltNum);
}
}
}
@@ -360,11 +360,11 @@ exceptionGroup
;

exceptionHandler
-	:   ^('catch' ARG_ACTION ACTION) {trackInlineAction($ACTION);}
+	:   ^('catch' ARG_ACTION ACTION) {TrackInlineAction($ACTION);}
;

finallyClause
-	:    ^('finally' ACTION) {trackInlineAction($ACTION);}
+	:    ^('finally' ACTION) {TrackInlineAction($ACTION);}
;

element
@@ -383,15 +383,15 @@ element
}
if ( e.Type==RULE_REF)
{
-					grammar.defineRuleRefLabel(currentRuleName,$id.token,e);
+					grammar.DefineRuleRefLabel(currentRuleName,$id.token,e);
}
else if ( e.Type==WILDCARD && grammar.type==Grammar.TREE_PARSER )
{
-					grammar.defineWildcardTreeLabel(currentRuleName,$id.token,e);
+					grammar.DefineWildcardTreeLabel(currentRuleName,$id.token,e);
}
else
{
-					grammar.defineTokenRefLabel(currentRuleName,$id.Token,e);
+					grammar.DefineTokenRefLabel(currentRuleName,$id.Token,e);
}
}
|	^(	PLUS_ASSIGN id2=ID a2=element
@@ -403,15 +403,15 @@ element
}
if ( a.Type==RULE_REF )
{
-					grammar.defineRuleListLabel(currentRuleName,$id2.Token,a);
+					grammar.DefineRuleListLabel(currentRuleName,$id2.Token,a);
}
else if ( a.Type == WILDCARD && grammar.type == Grammar.TREE_PARSER )
{
-					grammar.defineWildcardTreeListLabel( currentRuleName, $id2.token, a );
+					grammar.DefineWildcardTreeListLabel( currentRuleName, $id2.token, a );
}
else
{
-					grammar.defineTokenListLabel(currentRuleName,$id2.Token,a);
+					grammar.DefineTokenListLabel(currentRuleName,$id2.Token,a);
}
}
)
@@ -421,24 +421,24 @@ element
|   act=ACTION
{
$act.outerAltNum = this.outerAltNum;
-			trackInlineAction($act);
+			TrackInlineAction($act);
}
|   act2=FORCED_ACTION
{
$act2.outerAltNum = this.outerAltNum;
-			trackInlineAction($act2);
+			TrackInlineAction($act2);
}
|   SEMPRED
{
$SEMPRED.outerAltNum = this.outerAltNum;
-			trackInlineAction($SEMPRED);
+			TrackInlineAction($SEMPRED);
}
|   SYN_SEMPRED
|   ^(BACKTRACK_SEMPRED .*)
|   GATED_SEMPRED
{
$GATED_SEMPRED.outerAltNum = this.outerAltNum;
-			trackInlineAction($GATED_SEMPRED);
+			TrackInlineAction($GATED_SEMPRED);
}
|   EPSILON
;
@@ -467,7 +467,7 @@ dotLoop
// otherwise they (analysis?) look til EOF!
opts["k"] = 1;
}
-			block.setOptions(grammar,opts);
+			block.SetOptions(grammar,opts);
}
;

@@ -482,11 +482,11 @@ tree_
atom[GrammarAST scope_]
:	^( rr=RULE_REF (rarg=ARG_ACTION)? )
{
-			grammar.altReferencesRule( currentRuleName, $scope_, $rr, this.outerAltNum );
+			grammar.AltReferencesRule( currentRuleName, $scope_, $rr, this.outerAltNum );
if ( $rarg != null )
{
$rarg.outerAltNum = this.outerAltNum;
-				trackInlineAction($rarg);
+				TrackInlineAction($rarg);
}
}
|	^( t=TOKEN_REF (targ=ARG_ACTION )? )
@@ -494,33 +494,33 @@ atom[GrammarAST scope_]
if ( $targ != null )
{
$targ.outerAltNum = this.outerAltNum;
-				trackInlineAction($targ);
+				TrackInlineAction($targ);
}
if ( grammar.type == Grammar.LEXER )
{
-				grammar.altReferencesRule( currentRuleName, $scope_, $t, this.outerAltNum );
+				grammar.AltReferencesRule( currentRuleName, $scope_, $t, this.outerAltNum );
}
else
{
-				grammar.altReferencesTokenID( currentRuleName, $t, this.outerAltNum );
+				grammar.AltReferencesTokenID( currentRuleName, $t, this.outerAltNum );
}
}
|	c=CHAR_LITERAL
{
if ( grammar.type != Grammar.LEXER )
{
-				Rule rule = grammar.getRule(currentRuleName);
+				Rule rule = grammar.GetRule(currentRuleName);
if ( rule != null )
-					rule.trackTokenReferenceInAlt($c, outerAltNum);
+					rule.TrackTokenReferenceInAlt($c, outerAltNum);
}
}
|	s=STRING_LITERAL
{
if ( grammar.type != Grammar.LEXER )
{
-				Rule rule = grammar.getRule(currentRuleName);
+				Rule rule = grammar.GetRule(currentRuleName);
if ( rule!=null )
-					rule.trackTokenReferenceInAlt($s, outerAltNum);
+					rule.TrackTokenReferenceInAlt($s, outerAltNum);
}
}
|	WILDCARD
@@ -548,7 +548,7 @@ rewrite
if ( $pred != null )
{
$pred.outerAltNum = this.outerAltNum;
-					trackInlineAction($pred);
+					TrackInlineAction($pred);
}
}
)*
@@ -608,8 +608,8 @@ rewrite_atom
{
if ( state.backtracking == 0 )
{
-		Rule r = grammar.getRule(currentRuleName);
-		var tokenRefsInAlt = r.getTokenRefsInAlt(outerAltNum);
+		Rule r = grammar.GetRule(currentRuleName);
+		var tokenRefsInAlt = r.GetTokenRefsInAlt(outerAltNum);
boolean imaginary =
$start.Type==TOKEN_REF &&
!tokenRefsInAlt.Contains($start.Text);
@@ -635,7 +635,7 @@ rewrite_atom
(	ARG_ACTION
{
$ARG_ACTION.outerAltNum = this.outerAltNum;
-						trackInlineAction($ARG_ACTION);
+						TrackInlineAction($ARG_ACTION);
}
)?
)
@@ -646,7 +646,7 @@ rewrite_atom
|	ACTION
{
$ACTION.outerAltNum = this.outerAltNum;
-			trackInlineAction($ACTION);
+			TrackInlineAction($ACTION);
}
;

@@ -657,7 +657,7 @@ rewrite_template
(	^( ARG arg=ID a=ACTION )
{
$a.outerAltNum = this.outerAltNum;
-						trackInlineAction($a);
+						TrackInlineAction($a);
}
)*
)
@@ -665,7 +665,7 @@ rewrite_template
if ( $ind!=null )
{
$ind.outerAltNum = this.outerAltNum;
-					trackInlineAction($ind);
+					TrackInlineAction($ind);
}
}
(	DOUBLE_QUOTE_STRING_LITERAL
@@ -675,6 +675,6 @@ rewrite_template
|	act=ACTION
{
$act.outerAltNum = this.outerAltNum;
-			trackInlineAction($act);
+			TrackInlineAction($act);
}
;
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
index 165f161..d885158 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
+++ b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
@@ -47,7 +47,7 @@ namespace Antlr3.Grammars
protected int outerAltNum = 0;
protected int blockLevel = 0;

-        public int countAltsForRule( CommonTree t )
+        public int CountAltsForRule( CommonTree t )
{
return CountNodes( ALT, t );
}
@@ -65,13 +65,13 @@ namespace Antlr3.Grammars
return i;
}

-        protected void finish()
+        protected void Finish()
{
-            trimGrammar();
+            TrimGrammar();
}

/** Remove any lexer rules from a COMBINED; already passed to lexer */
-        protected void trimGrammar()
+        protected void TrimGrammar()
{
if ( grammar.type != Grammar.COMBINED )
{
@@ -101,12 +101,12 @@ namespace Antlr3.Grammars
//Console.Out.WriteLine( "root after removal is: " + root.ToStringList() );
}

-        protected void trackInlineAction( GrammarAST actionAST )
+        protected void TrackInlineAction( GrammarAST actionAST )
{
-            Rule r = grammar.getRule( currentRuleName );
+            Rule r = grammar.GetRule( currentRuleName );
if ( r != null )
{
-                r.trackInlineAction( actionAST );
+                r.TrackInlineAction( actionAST );
}
}
}
diff --git a/Antlr3/Grammars/TreeToNFAConverter.cs b/Antlr3/Grammars/TreeToNFAConverter.cs
index 7532fed..b315af7 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.cs
+++ b/Antlr3/Grammars/TreeToNFAConverter.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-04-16 19:02:09
+// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-04-16 21:09:09

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -296,7 +296,7 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-					finish();
+					Finish();

}
}
@@ -860,7 +860,7 @@ public partial class TreeToNFAConverter : TreeParser
{

currentRuleName = (id!=null?id.Text:null);
-								factory.CurrentRule = grammar.getLocallyDefinedRule( currentRuleName );
+								factory.CurrentRule = grammar.GetLocallyDefinedRule( currentRuleName );

}
// Grammars\\TreeToNFAConverter.g3:125:4: ( modifier )?
@@ -1164,25 +1164,25 @@ public partial class TreeToNFAConverter : TreeParser
{
// if block comes back as a set not BLOCK, make it
// a single ALT block
-									g = factory.build_AlternativeBlockFromSet(g);
+									g = factory.BuildAlternativeBlockFromSet(g);
}
if ( char.IsLower(currentRuleName[0]) ||
grammar.type==Grammar.LEXER )
{
// attach start node to block for this rule
-									Rule thisR = grammar.getLocallyDefinedRule(currentRuleName);
+									Rule thisR = grammar.GetLocallyDefinedRule(currentRuleName);
NFAState start = thisR.startState;
start.associatedASTNode = id;
start.AddTransition(new Transition(Label.EPSILON, g.left));

// track decision if > 1 alts
-									if ( grammar.getNumberOfAltsForDecisionNFA(g.left)>1 )
+									if ( grammar.GetNumberOfAltsForDecisionNFA(g.left)>1 )
{
-										g.left.Description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+										g.left.Description = grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
g.left.SetDecisionASTNode((b!=null?((GrammarAST)b.start):null));
-										int d = grammar.assignDecisionNumber( g.left );
-										grammar.setDecisionNFA( d, g.left );
-										grammar.setDecisionBlockAST(d, (b!=null?((GrammarAST)b.start):null));
+										int d = grammar.AssignDecisionNumber( g.left );
+										grammar.SetDecisionNFA( d, g.left );
+										grammar.SetDecisionBlockAST(d, (b!=null?((GrammarAST)b.start):null));
}

// hook to end of rule node
@@ -1504,7 +1504,7 @@ public partial class TreeToNFAConverter : TreeParser
{
int LA33_1 = input.LA(2);

-				if ( ((grammar.isValidSet(this,((GrammarAST)retval.start)) &&
+				if ( ((grammar.IsValidSet(this,((GrammarAST)retval.start)) &&
!currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME))) )
{
alt33=1;
@@ -1533,11 +1533,11 @@ public partial class TreeToNFAConverter : TreeParser
case 1:
// Grammars\\TreeToNFAConverter.g3:193:4: {...}? => set
{
-				if ( !((grammar.isValidSet(this,((GrammarAST)retval.start)) &&
+				if ( !((grammar.IsValidSet(this,((GrammarAST)retval.start)) &&
!currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME))) )
{
if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "block", "grammar.isValidSet(this,$start) &&\r\n\t\t !currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME)");
+					throw new FailedPredicateException(input, "block", "grammar.IsValidSet(this,$start) &&\r\n\t\t !currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME)");
}
PushFollow(Follow._set_in_block480);
set1=set();
@@ -1680,7 +1680,7 @@ public partial class TreeToNFAConverter : TreeParser
Match(input, TokenConstants.Up, null); if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_AlternativeBlock(alts);
+					retval.g = factory.BuildAlternativeBlock(alts);
}

}
@@ -1744,7 +1744,7 @@ public partial class TreeToNFAConverter : TreeParser
if (state.failed) return g;
if ( state.backtracking == 0 )
{
-						g = factory.build_AB(g,(e!=null?e.g:default(StateCluster)));
+						g = factory.BuildAB(g,(e!=null?e.g:default(StateCluster)));
}

}
@@ -1771,10 +1771,10 @@ public partial class TreeToNFAConverter : TreeParser
{

if (g==null) { // if alt was a list of actions or whatever
-								g = factory.build_Epsilon();
+								g = factory.BuildEpsilon();
}
else {
-								factory.optimizeAlternative(g);
+								factory.OptimizeAlternative(g);
}

}
@@ -2020,9 +2020,9 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-										if ( grammar.getOption("output")==null )
+										if ( grammar.GetOption("output")==null )
{
-											ErrorManager.grammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
+											ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
grammar, ((GrammarAST)retval.start).Token, currentRuleName);
}

@@ -2235,10 +2235,10 @@ public partial class TreeToNFAConverter : TreeParser
Match(input, TokenConstants.Up, null); if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_Range(grammar.getTokenType((a!=null?(input.TokenStream.ToString(
+					retval.g = factory.BuildRange(grammar.GetTokenType((a!=null?(input.TokenStream.ToString(
input.TreeAdaptor.GetTokenStartIndex(a.start),
input.TreeAdaptor.GetTokenStopIndex(a.start))):null)),
-													 grammar.getTokenType((b!=null?(input.TokenStream.ToString(
+													 grammar.GetTokenType((b!=null?(input.TokenStream.ToString(
input.TreeAdaptor.GetTokenStartIndex(b.start),
input.TreeAdaptor.GetTokenStopIndex(b.start))):null)));
}
@@ -2259,7 +2259,7 @@ public partial class TreeToNFAConverter : TreeParser
{

if ( grammar.type==Grammar.LEXER ) {
-								retval.g = factory.build_CharRange((c1!=null?c1.Text:null), (c2!=null?c2.Text:null));
+								retval.g = factory.BuildCharRange((c1!=null?c1.Text:null), (c2!=null?c2.Text:null));
}

}
@@ -2333,7 +2333,7 @@ public partial class TreeToNFAConverter : TreeParser
ACTION5=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element839); if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_Action(ACTION5);
+					retval.g = factory.BuildAction(ACTION5);
}

}
@@ -2344,7 +2344,7 @@ public partial class TreeToNFAConverter : TreeParser
FORCED_ACTION6=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element848); if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_Action(FORCED_ACTION6);
+					retval.g = factory.BuildAction(FORCED_ACTION6);
}

}
@@ -2355,7 +2355,7 @@ public partial class TreeToNFAConverter : TreeParser
pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element859); if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_SemanticPredicate(pred);
+					retval.g = factory.BuildSemanticPredicate(pred);
}

}
@@ -2366,7 +2366,7 @@ public partial class TreeToNFAConverter : TreeParser
spred=(GrammarAST)Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element870); if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_SemanticPredicate(spred);
+					retval.g = factory.BuildSemanticPredicate(spred);
}

}
@@ -2419,7 +2419,7 @@ public partial class TreeToNFAConverter : TreeParser
}
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_SemanticPredicate(bpred);
+					retval.g = factory.BuildSemanticPredicate(bpred);
}

}
@@ -2430,7 +2430,7 @@ public partial class TreeToNFAConverter : TreeParser
gpred=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element897); if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_SemanticPredicate(gpred);
+					retval.g = factory.BuildSemanticPredicate(gpred);
}

}
@@ -2441,7 +2441,7 @@ public partial class TreeToNFAConverter : TreeParser
Match(input,EPSILON,Follow._EPSILON_in_element906); if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-					retval.g = factory.build_Epsilon();
+					retval.g = factory.BuildEpsilon();
}

}
@@ -2493,7 +2493,7 @@ public partial class TreeToNFAConverter : TreeParser
{
int LA42_1 = input.LA(2);

-				if ( ((grammar.isValidSet(this,((GrammarAST)retval.start)))) )
+				if ( ((grammar.IsValidSet(this,((GrammarAST)retval.start)))) )
{
alt42=1;
}
@@ -2539,10 +2539,10 @@ public partial class TreeToNFAConverter : TreeParser
case 1:
// Grammars\\TreeToNFAConverter.g3:287:4: {...}? => set
{
-				if ( !((grammar.isValidSet(this,((GrammarAST)retval.start)))) )
+				if ( !((grammar.IsValidSet(this,((GrammarAST)retval.start)))) )
{
if (state.backtracking>0) {state.failed=true; return retval;}
-					throw new FailedPredicateException(input, "ebnf", "grammar.isValidSet(this,$start)");
+					throw new FailedPredicateException(input, "ebnf", "grammar.IsValidSet(this,$start)");
}
PushFollow(Follow._set_in_ebnf932);
set7=set();
@@ -2568,13 +2568,13 @@ public partial class TreeToNFAConverter : TreeParser
{

// track decision if > 1 alts
-								if ( grammar.getNumberOfAltsForDecisionNFA((b!=null?b.g:default(StateCluster)).left)>1 )
+								if ( grammar.GetNumberOfAltsForDecisionNFA((b!=null?b.g:default(StateCluster)).left)>1 )
{
-									(b!=null?b.g:default(StateCluster)).left.Description = grammar.grammarTreeToString(blk,false);
+									(b!=null?b.g:default(StateCluster)).left.Description = grammar.GrammarTreeToString(blk,false);
(b!=null?b.g:default(StateCluster)).left.SetDecisionASTNode(blk);
-									int d = grammar.assignDecisionNumber( (b!=null?b.g:default(StateCluster)).left );
-									grammar.setDecisionNFA( d, (b!=null?b.g:default(StateCluster)).left );
-									grammar.setDecisionBlockAST(d, blk);
+									int d = grammar.AssignDecisionNumber( (b!=null?b.g:default(StateCluster)).left );
+									grammar.SetDecisionNFA( d, (b!=null?b.g:default(StateCluster)).left );
+									grammar.SetDecisionBlockAST(d, blk);
}
retval.g = (b!=null?b.g:default(StateCluster));

@@ -2603,14 +2603,14 @@ public partial class TreeToNFAConverter : TreeParser
{
// if block comes back SET not BLOCK, make it
// a single ALT block
-									bg = factory.build_AlternativeBlockFromSet(bg);
+									bg = factory.BuildAlternativeBlockFromSet(bg);
}
-								retval.g = factory.build_Aoptional(bg);
-								retval.g.left.Description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
+								retval.g = factory.BuildAoptional(bg);
+								retval.g.left.Description = grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
// there is always at least one alt even if block has just 1 alt
-								int d = grammar.assignDecisionNumber( retval.g.left );
-								grammar.setDecisionNFA(d, retval.g.left);
-								grammar.setDecisionBlockAST(d, blk);
+								int d = grammar.AssignDecisionNumber( retval.g.left );
+								grammar.SetDecisionNFA(d, retval.g.left);
+								grammar.SetDecisionBlockAST(d, blk);
retval.g.left.SetDecisionASTNode(((GrammarAST)retval.start));

}
@@ -2636,14 +2636,14 @@ public partial class TreeToNFAConverter : TreeParser
StateCluster bg = (b!=null?b.g:default(StateCluster));
if ( blk.SetValue!=null )
{
-									bg = factory.build_AlternativeBlockFromSet(bg);
+									bg = factory.BuildAlternativeBlockFromSet(bg);
}
-								retval.g = factory.build_Astar(bg);
+								retval.g = factory.BuildAstar(bg);
// track the loop back / exit decision point
-								bg.right.Description = "()* loopback of "+grammar.grammarTreeToString(((GrammarAST)retval.start),false);
-								int d = grammar.assignDecisionNumber( bg.right );
-								grammar.setDecisionNFA(d, bg.right);
-								grammar.setDecisionBlockAST(d, blk);
+								bg.right.Description = "()* loopback of "+grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
+								int d = grammar.AssignDecisionNumber( bg.right );
+								grammar.SetDecisionNFA(d, bg.right);
+								grammar.SetDecisionBlockAST(d, blk);
bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
NFAState altBlockState = (NFAState)retval.g.left.GetTransition(0).target;
@@ -2675,15 +2675,15 @@ public partial class TreeToNFAConverter : TreeParser
StateCluster bg = (b!=null?b.g:default(StateCluster));
if ( blk.SetValue!=null )
{
-									bg = factory.build_AlternativeBlockFromSet(bg);
+									bg = factory.BuildAlternativeBlockFromSet(bg);
}
-								retval.g = factory.build_Aplus(bg);
+								retval.g = factory.BuildAplus(bg);
// don't make a decision on left edge, can reuse loop end decision
// track the loop back / exit decision point
-								bg.right.Description = "()+ loopback of "+grammar.grammarTreeToString(((GrammarAST)retval.start),false);
-								int d = grammar.assignDecisionNumber( bg.right );
-								grammar.setDecisionNFA(d, bg.right);
-								grammar.setDecisionBlockAST(d, blk);
+								bg.right.Description = "()+ loopback of "+grammar.GrammarTreeToString(((GrammarAST)retval.start),false);
+								int d = grammar.AssignDecisionNumber( bg.right );
+								grammar.SetDecisionNFA(d, bg.right);
+								grammar.SetDecisionBlockAST(d, blk);
bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
NFAState altBlockState = (NFAState)retval.g.left.GetTransition(0).target;
@@ -2746,10 +2746,10 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-								down = factory.build_Atom(Label.DOWN, (e!=null?((GrammarAST)e.start):null));
+								down = factory.BuildAtom(Label.DOWN, (e!=null?((GrammarAST)e.start):null));
// TODO set following states for imaginary nodes?
//el.followingNFAState = down.right;
-								retval.g = factory.build_AB(retval.g,down);
+								retval.g = factory.BuildAB(retval.g,down);

}
// Grammars\\TreeToNFAConverter.g3:375:4: (e= element )*
@@ -2776,7 +2776,7 @@ public partial class TreeToNFAConverter : TreeParser
if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-						retval.g = factory.build_AB(retval.g,(e!=null?e.g:default(StateCluster)));
+						retval.g = factory.BuildAB(retval.g,(e!=null?e.g:default(StateCluster)));
}

}
@@ -2794,9 +2794,9 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-								up = factory.build_Atom(Label.UP, (e!=null?((GrammarAST)e.start):null));
+								up = factory.BuildAtom(Label.UP, (e!=null?((GrammarAST)e.start):null));
//el.followingNFAState = up.right;
-								retval.g = factory.build_AB(retval.g,up);
+								retval.g = factory.BuildAB(retval.g,up);
// tree roots point at right edge of DOWN for LOOK computation later
((GrammarAST)retval.start).NFATreeDownState = down.left;

@@ -2941,22 +2941,22 @@ public partial class TreeToNFAConverter : TreeParser
int ttype=0;
if ( grammar.type==Grammar.LEXER )
{
-												ttype = Grammar.getCharValueFromGrammarCharLiteral((c!=null?c.Text:null));
+												ttype = Grammar.GetCharValueFromGrammarCharLiteral((c!=null?c.Text:null));
}
else
{
-												ttype = grammar.getTokenType((c!=null?c.Text:null));
+												ttype = grammar.GetTokenType((c!=null?c.Text:null));
}
-											IIntSet notAtom = grammar.complement(ttype);
+											IIntSet notAtom = grammar.Complement(ttype);
if ( notAtom.IsNil )
{
-												ErrorManager.grammarError(
+												ErrorManager.GrammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
grammar,
c.Token,
(c!=null?c.Text:null));
}
-											g =factory.build_Set(notAtom,n);
+											g =factory.BuildSet(notAtom,n);

}

@@ -2997,10 +2997,10 @@ public partial class TreeToNFAConverter : TreeParser
IIntSet notAtom = null;
if ( grammar.type==Grammar.LEXER )
{
-												notAtom = grammar.getSetFromRule(this,(t!=null?t.Text:null));
+												notAtom = grammar.GetSetFromRule(this,(t!=null?t.Text:null));
if ( notAtom==null )
{
-													ErrorManager.grammarError(
+													ErrorManager.GrammarError(
ErrorManager.MSG_RULE_INVALID_SET,
grammar,
t.Token,
@@ -3008,23 +3008,23 @@ public partial class TreeToNFAConverter : TreeParser
}
else
{
-													notAtom = grammar.complement(notAtom);
+													notAtom = grammar.Complement(notAtom);
}
}
else
{
-												ttype = grammar.getTokenType((t!=null?t.Text:null));
-												notAtom = grammar.complement(ttype);
+												ttype = grammar.GetTokenType((t!=null?t.Text:null));
+												notAtom = grammar.Complement(ttype);
}
if ( notAtom==null || notAtom.IsNil )
{
-												ErrorManager.grammarError(
+												ErrorManager.GrammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
grammar,
t.Token,
(t!=null?t.Text:null));
}
-											g =factory.build_Set(notAtom,n);
+											g =factory.BuildSet(notAtom,n);

}

@@ -3046,21 +3046,21 @@ public partial class TreeToNFAConverter : TreeParser
{

GrammarAST stNode = (GrammarAST)n.GetChild(0);
-											//IIntSet notSet = grammar.complement(stNode.SetValue);
+											//IIntSet notSet = grammar.Complement(stNode.SetValue);
// let code generator complement the sets
IIntSet s = stNode.SetValue;
stNode.SetValue = s;
// let code gen do the complement again; here we compute
// for NFA construction
-											s = grammar.complement(s);
+											s = grammar.Complement(s);
if ( s.IsNil )
{
-												ErrorManager.grammarError(
+												ErrorManager.GrammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
grammar,
n.Token);
}
-											g =factory.build_Set(s,n);
+											g =factory.BuildSet(s,n);

}

@@ -3220,17 +3220,17 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-								NFAState start = grammar.getRuleStartState(scopeName,(r!=null?r.Text:null));
+								NFAState start = grammar.GetRuleStartState(scopeName,(r!=null?r.Text:null));
if ( start!=null )
{
-									Rule rr = grammar.getRule(scopeName,(r!=null?r.Text:null));
-									retval.g = factory.build_RuleRef(rr, start);
+									Rule rr = grammar.GetRule(scopeName,(r!=null?r.Text:null));
+									retval.g = factory.BuildRuleRef(rr, start);
r.followingNFAState = retval.g.right;
r._nfaStartState = retval.g.left;
if ( retval.g.left.GetTransition(0) is RuleClosureTransition
&& grammar.type!=Grammar.LEXER )
{
-										addFollowTransition((r!=null?r.Text:null), retval.g.right);
+										AddFollowTransition((r!=null?r.Text:null), retval.g.right);
}
// else rule ref got inlined to a set
}
@@ -3299,11 +3299,11 @@ public partial class TreeToNFAConverter : TreeParser

if ( grammar.type==Grammar.LEXER )
{
-									NFAState start = grammar.getRuleStartState(scopeName,(t!=null?t.Text:null));
+									NFAState start = grammar.GetRuleStartState(scopeName,(t!=null?t.Text:null));
if ( start!=null )
{
-										Rule rr = grammar.getRule(scopeName,t.Text);
-										retval.g = factory.build_RuleRef(rr, start);
+										Rule rr = grammar.GetRule(scopeName,t.Text);
+										retval.g = factory.BuildRuleRef(rr, start);
t._nfaStartState = retval.g.left;
// don't add FOLLOW transitions in the lexer;
// only exact context should be used.
@@ -3311,7 +3311,7 @@ public partial class TreeToNFAConverter : TreeParser
}
else
{
-									retval.g = factory.build_Atom(t);
+									retval.g = factory.BuildAtom(t);
t.followingNFAState = retval.g.right;
}

@@ -3359,11 +3359,11 @@ public partial class TreeToNFAConverter : TreeParser

if ( grammar.type==Grammar.LEXER )
{
-									retval.g = factory.build_CharLiteralAtom(c);
+									retval.g = factory.BuildCharLiteralAtom(c);
}
else
{
-									retval.g = factory.build_Atom(c);
+									retval.g = factory.BuildAtom(c);
c.followingNFAState = retval.g.right;
}

@@ -3411,11 +3411,11 @@ public partial class TreeToNFAConverter : TreeParser

if ( grammar.type==Grammar.LEXER )
{
-									retval.g = factory.build_StringLiteralAtom(s);
+									retval.g = factory.BuildStringLiteralAtom(s);
}
else
{
-									retval.g = factory.build_Atom(s);
+									retval.g = factory.BuildAtom(s);
s.followingNFAState = retval.g.right;
}

@@ -3464,11 +3464,11 @@ public partial class TreeToNFAConverter : TreeParser
if ( nfa.grammar.type == Grammar.TREE_PARSER
&& (w.ChildIndex > 0 || w.Parent.GetChild(1).Type == EOA) )
{
-										retval.g = factory.build_WildcardTree( w );
+										retval.g = factory.BuildWildcardTree( w );
}
else
{
-										retval.g = factory.build_Wildcard( w );
+										retval.g = factory.BuildWildcard( w );
}

}
@@ -3691,7 +3691,7 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-						retval.g = factory.build_Set(elements,b);
+						retval.g = factory.BuildSet(elements,b);
b.followingNFAState = retval.g.right;
b.SetValue = elements; // track set value of this block

@@ -4168,15 +4168,15 @@ public partial class TreeToNFAConverter : TreeParser

if ( grammar.type==Grammar.LEXER )
{
-									ttype = Grammar.getCharValueFromGrammarCharLiteral((c!=null?c.Text:null));
+									ttype = Grammar.GetCharValueFromGrammarCharLiteral((c!=null?c.Text:null));
}
else
{
-									ttype = grammar.getTokenType((c!=null?c.Text:null));
+									ttype = grammar.GetTokenType((c!=null?c.Text:null));
}
if ( elements.Contains(ttype) )
{
-									ErrorManager.grammarError(
+									ErrorManager.GrammarError(
ErrorManager.MSG_DUPLICATE_SET_ENTRY,
grammar,
c.Token,
@@ -4198,10 +4198,10 @@ public partial class TreeToNFAConverter : TreeParser
if ( grammar.type==Grammar.LEXER )
{
// recursively will invoke this rule to match elements in target rule ref
-									IIntSet ruleSet = grammar.getSetFromRule(this,(t!=null?t.Text:null));
+									IIntSet ruleSet = grammar.GetSetFromRule(this,(t!=null?t.Text:null));
if ( ruleSet==null )
{
-										ErrorManager.grammarError(
+										ErrorManager.GrammarError(
ErrorManager.MSG_RULE_INVALID_SET,
grammar,
t.Token,
@@ -4214,10 +4214,10 @@ public partial class TreeToNFAConverter : TreeParser
}
else
{
-									ttype = grammar.getTokenType((t!=null?t.Text:null));
+									ttype = grammar.GetTokenType((t!=null?t.Text:null));
if ( elements.Contains(ttype) )
{
-										ErrorManager.grammarError(
+										ErrorManager.GrammarError(
ErrorManager.MSG_DUPLICATE_SET_ENTRY,
grammar,
t.Token,
@@ -4237,10 +4237,10 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-								ttype = grammar.getTokenType((s!=null?s.Text:null));
+								ttype = grammar.GetTokenType((s!=null?s.Text:null));
if ( elements.Contains(ttype) )
{
-									ErrorManager.grammarError(
+									ErrorManager.GrammarError(
ErrorManager.MSG_DUPLICATE_SET_ENTRY,
grammar,
s.Token,
@@ -4267,8 +4267,8 @@ public partial class TreeToNFAConverter : TreeParser

if ( grammar.type==Grammar.LEXER )
{
-									int a = Grammar.getCharValueFromGrammarCharLiteral((c1!=null?c1.Text:null));
-									int b = Grammar.getCharValueFromGrammarCharLiteral((c2!=null?c2.Text:null));
+									int a = Grammar.GetCharValueFromGrammarCharLiteral((c1!=null?c1.Text:null));
+									int b = Grammar.GetCharValueFromGrammarCharLiteral((c2!=null?c2.Text:null));
elements.AddAll(IntervalSet.Of(a,b));
}

@@ -4313,7 +4313,7 @@ public partial class TreeToNFAConverter : TreeParser
if ( state.backtracking == 0 )
{

-									IIntSet not = grammar.complement(ns);
+									IIntSet not = grammar.Complement(ns);
elements.AddAll(not);

}
@@ -4839,14 +4839,14 @@ public partial class TreeToNFAConverter : TreeParser

if ( grammar.type==Grammar.LEXER )
{
-								Rule rule = grammar.getRule((t!=null?t.Text:null));
+								Rule rule = grammar.GetRule((t!=null?t.Text:null));
if ( rule==null )
{
//throw new RecognitionException("invalid rule");
throw new RecognitionException();
}
// recursively will invoke this rule to match elements in target rule ref
-								alts += testSetRule(rule.tree);
+								alts += TestSetRule(rule.tree);
}


@@ -4874,7 +4874,7 @@ public partial class TreeToNFAConverter : TreeParser
c2=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_testSetElement1938); if (state.failed) return alts;

Match(input, TokenConstants.Up, null); if (state.failed) return alts;
-				 alts = IntervalSet.Of( Grammar.getCharValueFromGrammarCharLiteral((c1!=null?c1.Text:null)), Grammar.getCharValueFromGrammarCharLiteral((c2!=null?c2.Text:null)) ).Count;
+				 alts = IntervalSet.Of( Grammar.GetCharValueFromGrammarCharLiteral((c1!=null?c1.Text:null)), Grammar.GetCharValueFromGrammarCharLiteral((c2!=null?c2.Text:null)) ).Count;

}
break;
diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
index d6e11e1..47ad104 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.g3
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -88,7 +88,7 @@ public
grammar_
@after
{
-	finish();
+	Finish();
}
:	(	^( LEXER_GRAMMAR grammarSpec )
|	^( PARSER_GRAMMAR grammarSpec )
@@ -120,7 +120,7 @@ rule
:	^(	RULE id=ID
{
currentRuleName = $id.text;
-				factory.CurrentRule = grammar.getLocallyDefinedRule( currentRuleName );
+				factory.CurrentRule = grammar.GetLocallyDefinedRule( currentRuleName );
}
(modifier)?
^(ARG (ARG_ACTION)?)
@@ -138,25 +138,25 @@ rule
{
// if block comes back as a set not BLOCK, make it
// a single ALT block
-					g = factory.build_AlternativeBlockFromSet(g);
+					g = factory.BuildAlternativeBlockFromSet(g);
}
if ( char.IsLower(currentRuleName[0]) ||
grammar.type==Grammar.LEXER )
{
// attach start node to block for this rule
-					Rule thisR = grammar.getLocallyDefinedRule(currentRuleName);
+					Rule thisR = grammar.GetLocallyDefinedRule(currentRuleName);
NFAState start = thisR.startState;
start.associatedASTNode = $id;
start.AddTransition(new Transition(Label.EPSILON, g.left));

// track decision if > 1 alts
-					if ( grammar.getNumberOfAltsForDecisionNFA(g.left)>1 )
+					if ( grammar.GetNumberOfAltsForDecisionNFA(g.left)>1 )
{
-						g.left.Description = grammar.grammarTreeToString($start,false);
+						g.left.Description = grammar.GrammarTreeToString($start,false);
g.left.SetDecisionASTNode($b.start);
-						int d = grammar.assignDecisionNumber( g.left );
-						grammar.setDecisionNFA( d, g.left );
-						grammar.setDecisionBlockAST(d, $b.start);
+						int d = grammar.AssignDecisionNumber( g.left );
+						grammar.SetDecisionNFA( d, g.left );
+						grammar.SetDecisionBlockAST(d, $b.start);
}

// hook to end of rule node
@@ -190,7 +190,7 @@ block returns [StateCluster g = null]
if ( this.blockLevel==1 )
this.outerAltNum=1;
}
-	:	{grammar.isValidSet(this,$start) &&
+	:	{grammar.IsValidSet(this,$start) &&
!currentRuleName.Equals(Grammar.ARTIFICIAL_TOKENS_RULENAME)}? =>
set {$g = $set.g;}

@@ -206,18 +206,18 @@ block returns [StateCluster g = null]
)+
EOB
)
-		{$g = factory.build_AlternativeBlock(alts);}
+		{$g = factory.BuildAlternativeBlock(alts);}
;
finally { blockLevel--; }

alternative returns [StateCluster g=null]
-	:	^( ALT (e=element {$g = factory.build_AB($g,$e.g);} )+ EOA )
+	:	^( ALT (e=element {$g = factory.BuildAB($g,$e.g);} )+ EOA )
{
if ($g==null) { // if alt was a list of actions or whatever
-				$g = factory.build_Epsilon();
+				$g = factory.BuildEpsilon();
}
else {
-				factory.optimizeAlternative($g);
+				factory.OptimizeAlternative($g);
}
}
;
@@ -238,9 +238,9 @@ finallyClause
rewrite
:	(
{
-				if ( grammar.getOption("output")==null )
+				if ( grammar.GetOption("output")==null )
{
-					ErrorManager.grammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
+					ErrorManager.GrammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
grammar, $start.Token, currentRuleName);
}
}
@@ -254,25 +254,25 @@ element returns [StateCluster g=null]
|	^(ASSIGN ID e=element {$g = $e.g;})
|	^(PLUS_ASSIGN ID e=element {$g = $e.g;})
|   ^(RANGE a=atom[null] b=atom[null])
-		{$g = factory.build_Range(grammar.getTokenType($a.text),
-								 grammar.getTokenType($b.text));}
+		{$g = factory.BuildRange(grammar.GetTokenType($a.text),
+								 grammar.GetTokenType($b.text));}
|   ^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
{
if ( grammar.type==Grammar.LEXER ) {
-			$g = factory.build_CharRange($c1.text, $c2.text);
+			$g = factory.BuildCharRange($c1.text, $c2.text);
}
}
|   atom_or_notatom {$g = $atom_or_notatom.g;}
|   ebnf {$g = $ebnf.g;}
|   tree_ {$g = $tree_.g;}
|   ^( SYNPRED block )
-	|   ACTION {$g = factory.build_Action($ACTION);}
-	|   FORCED_ACTION {$g = factory.build_Action($FORCED_ACTION);}
-	|   pred=SEMPRED {$g = factory.build_SemanticPredicate($pred);}
-	|   spred=SYN_SEMPRED {$g = factory.build_SemanticPredicate($spred);}
-	|   ^(bpred=BACKTRACK_SEMPRED .*) {$g = factory.build_SemanticPredicate($bpred);}
-	|   gpred=GATED_SEMPRED {$g = factory.build_SemanticPredicate($gpred);}
-	|   EPSILON {$g = factory.build_Epsilon();}
+	|   ACTION {$g = factory.BuildAction($ACTION);}
+	|   FORCED_ACTION {$g = factory.BuildAction($FORCED_ACTION);}
+	|   pred=SEMPRED {$g = factory.BuildSemanticPredicate($pred);}
+	|   spred=SYN_SEMPRED {$g = factory.BuildSemanticPredicate($spred);}
+	|   ^(bpred=BACKTRACK_SEMPRED .*) {$g = factory.BuildSemanticPredicate($bpred);}
+	|   gpred=GATED_SEMPRED {$g = factory.BuildSemanticPredicate($gpred);}
+	|   EPSILON {$g = factory.BuildEpsilon();}
;

ebnf returns [StateCluster g=null]
@@ -284,18 +284,18 @@ ebnf returns [StateCluster g=null]
}
GrammarAST eob = blk.LastChild;
}
-	:	{grammar.isValidSet(this,$start)}? => set {$g = $set.g;}
+	:	{grammar.IsValidSet(this,$start)}? => set {$g = $set.g;}

|	b=block
{
// track decision if > 1 alts
-			if ( grammar.getNumberOfAltsForDecisionNFA($b.g.left)>1 )
+			if ( grammar.GetNumberOfAltsForDecisionNFA($b.g.left)>1 )
{
-				$b.g.left.Description = grammar.grammarTreeToString(blk,false);
+				$b.g.left.Description = grammar.GrammarTreeToString(blk,false);
$b.g.left.SetDecisionASTNode(blk);
-				int d = grammar.assignDecisionNumber( $b.g.left );
-				grammar.setDecisionNFA( d, $b.g.left );
-				grammar.setDecisionBlockAST(d, blk);
+				int d = grammar.AssignDecisionNumber( $b.g.left );
+				grammar.SetDecisionNFA( d, $b.g.left );
+				grammar.SetDecisionBlockAST(d, blk);
}
$g = $b.g;
}
@@ -306,14 +306,14 @@ ebnf returns [StateCluster g=null]
{
// if block comes back SET not BLOCK, make it
// a single ALT block
-				bg = factory.build_AlternativeBlockFromSet(bg);
+				bg = factory.BuildAlternativeBlockFromSet(bg);
}
-			$g = factory.build_Aoptional(bg);
-			$g.left.Description = grammar.grammarTreeToString($start,false);
+			$g = factory.BuildAoptional(bg);
+			$g.left.Description = grammar.GrammarTreeToString($start,false);
// there is always at least one alt even if block has just 1 alt
-			int d = grammar.assignDecisionNumber( $g.left );
-			grammar.setDecisionNFA(d, $g.left);
-			grammar.setDecisionBlockAST(d, blk);
+			int d = grammar.AssignDecisionNumber( $g.left );
+			grammar.SetDecisionNFA(d, $g.left);
+			grammar.SetDecisionBlockAST(d, blk);
$g.left.SetDecisionASTNode($start);
}
|	^( CLOSURE b=block )
@@ -321,14 +321,14 @@ ebnf returns [StateCluster g=null]
StateCluster bg = $b.g;
if ( blk.SetValue!=null )
{
-				bg = factory.build_AlternativeBlockFromSet(bg);
+				bg = factory.BuildAlternativeBlockFromSet(bg);
}
-			$g = factory.build_Astar(bg);
+			$g = factory.BuildAstar(bg);
// track the loop back / exit decision point
-			bg.right.Description = "()* loopback of "+grammar.grammarTreeToString($start,false);
-			int d = grammar.assignDecisionNumber( bg.right );
-			grammar.setDecisionNFA(d, bg.right);
-			grammar.setDecisionBlockAST(d, blk);
+			bg.right.Description = "()* loopback of "+grammar.GrammarTreeToString($start,false);
+			int d = grammar.AssignDecisionNumber( bg.right );
+			grammar.SetDecisionNFA(d, bg.right);
+			grammar.SetDecisionBlockAST(d, blk);
bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
NFAState altBlockState = (NFAState)$g.left.GetTransition(0).target;
@@ -342,15 +342,15 @@ ebnf returns [StateCluster g=null]
StateCluster bg = $b.g;
if ( blk.SetValue!=null )
{
-				bg = factory.build_AlternativeBlockFromSet(bg);
+				bg = factory.BuildAlternativeBlockFromSet(bg);
}
-			$g = factory.build_Aplus(bg);
+			$g = factory.BuildAplus(bg);
// don't make a decision on left edge, can reuse loop end decision
// track the loop back / exit decision point
-			bg.right.Description = "()+ loopback of "+grammar.grammarTreeToString($start,false);
-			int d = grammar.assignDecisionNumber( bg.right );
-			grammar.setDecisionNFA(d, bg.right);
-			grammar.setDecisionBlockAST(d, blk);
+			bg.right.Description = "()+ loopback of "+grammar.GrammarTreeToString($start,false);
+			int d = grammar.AssignDecisionNumber( bg.right );
+			grammar.SetDecisionNFA(d, bg.right);
+			grammar.SetDecisionBlockAST(d, blk);
bg.right.SetDecisionASTNode(eob);
// make block entry state also have same decision for interpreting grammar
NFAState altBlockState = (NFAState)$g.left.GetTransition(0).target;
@@ -367,16 +367,16 @@ tree_ returns [StateCluster g=null]
:	^(	TREE_BEGIN
e=element { $g = $e.g; }
{
-				down = factory.build_Atom(Label.DOWN, $e.start);
+				down = factory.BuildAtom(Label.DOWN, $e.start);
// TODO set following states for imaginary nodes?
//el.followingNFAState = down.right;
-				$g = factory.build_AB($g,down);
+				$g = factory.BuildAB($g,down);
}
-			( e=element {$g = factory.build_AB($g,$e.g);} )*
+			( e=element {$g = factory.BuildAB($g,$e.g);} )*
{
-				up = factory.build_Atom(Label.UP, $e.start);
+				up = factory.BuildAtom(Label.UP, $e.start);
//el.followingNFAState = up.right;
-				$g = factory.build_AB($g,up);
+				$g = factory.BuildAB($g,up);
// tree roots point at right edge of DOWN for LOOK computation later
$start.NFATreeDownState = down.left;
}
@@ -391,22 +391,22 @@ atom_or_notatom returns [StateCluster g=null]
int ttype=0;
if ( grammar.type==Grammar.LEXER )
{
-						ttype = Grammar.getCharValueFromGrammarCharLiteral($c.text);
+						ttype = Grammar.GetCharValueFromGrammarCharLiteral($c.text);
}
else
{
-						ttype = grammar.getTokenType($c.text);
+						ttype = grammar.GetTokenType($c.text);
}
-					IIntSet notAtom = grammar.complement(ttype);
+					IIntSet notAtom = grammar.Complement(ttype);
if ( notAtom.IsNil )
{
-						ErrorManager.grammarError(
+						ErrorManager.GrammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
grammar,
$c.Token,
$c.text);
}
-					$g=factory.build_Set(notAtom,$n);
+					$g=factory.BuildSet(notAtom,$n);
}
|	t=TOKEN_REF (ast3=ast_suffix)?
{
@@ -414,10 +414,10 @@ atom_or_notatom returns [StateCluster g=null]
IIntSet notAtom = null;
if ( grammar.type==Grammar.LEXER )
{
-						notAtom = grammar.getSetFromRule(this,$t.text);
+						notAtom = grammar.GetSetFromRule(this,$t.text);
if ( notAtom==null )
{
-							ErrorManager.grammarError(
+							ErrorManager.GrammarError(
ErrorManager.MSG_RULE_INVALID_SET,
grammar,
$t.Token,
@@ -425,42 +425,42 @@ atom_or_notatom returns [StateCluster g=null]
}
else
{
-							notAtom = grammar.complement(notAtom);
+							notAtom = grammar.Complement(notAtom);
}
}
else
{
-						ttype = grammar.getTokenType($t.text);
-						notAtom = grammar.complement(ttype);
+						ttype = grammar.GetTokenType($t.text);
+						notAtom = grammar.Complement(ttype);
}
if ( notAtom==null || notAtom.IsNil )
{
-						ErrorManager.grammarError(
+						ErrorManager.GrammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
grammar,
$t.Token,
$t.text);
}
-					$g=factory.build_Set(notAtom,$n);
+					$g=factory.BuildSet(notAtom,$n);
}
|	set {$g = $set.g;}
{
GrammarAST stNode = (GrammarAST)$n.GetChild(0);
-					//IIntSet notSet = grammar.complement(stNode.SetValue);
+					//IIntSet notSet = grammar.Complement(stNode.SetValue);
// let code generator complement the sets
IIntSet s = stNode.SetValue;
stNode.SetValue = s;
// let code gen do the complement again; here we compute
// for NFA construction
-					s = grammar.complement(s);
+					s = grammar.Complement(s);
if ( s.IsNil )
{
-						ErrorManager.grammarError(
+						ErrorManager.GrammarError(
ErrorManager.MSG_EMPTY_COMPLEMENT,
grammar,
$n.Token);
}
-					$g=factory.build_Set(s,$n);
+					$g=factory.BuildSet(s,$n);
}
)
{$n.followingNFAState = $g.right;}
@@ -470,17 +470,17 @@ atom_or_notatom returns [StateCluster g=null]
atom[string scopeName] returns [StateCluster g=null]
:	^( r=RULE_REF (rarg=ARG_ACTION)? (as1=ast_suffix)? )
{
-			NFAState start = grammar.getRuleStartState(scopeName,$r.text);
+			NFAState start = grammar.GetRuleStartState(scopeName,$r.text);
if ( start!=null )
{
-				Rule rr = grammar.getRule(scopeName,$r.text);
-				$g = factory.build_RuleRef(rr, start);
+				Rule rr = grammar.GetRule(scopeName,$r.text);
+				$g = factory.BuildRuleRef(rr, start);
r.followingNFAState = $g.right;
r._nfaStartState = $g.left;
if ( $g.left.GetTransition(0) is RuleClosureTransition
&& grammar.type!=Grammar.LEXER )
{
-					addFollowTransition($r.text, $g.right);
+					AddFollowTransition($r.text, $g.right);
}
// else rule ref got inlined to a set
}
@@ -490,11 +490,11 @@ atom[string scopeName] returns [StateCluster g=null]
{
if ( grammar.type==Grammar.LEXER )
{
-				NFAState start = grammar.getRuleStartState(scopeName,$t.text);
+				NFAState start = grammar.GetRuleStartState(scopeName,$t.text);
if ( start!=null )
{
-					Rule rr = grammar.getRule(scopeName,t.Text);
-					$g = factory.build_RuleRef(rr, start);
+					Rule rr = grammar.GetRule(scopeName,t.Text);
+					$g = factory.BuildRuleRef(rr, start);
t._nfaStartState = $g.left;
// don't add FOLLOW transitions in the lexer;
// only exact context should be used.
@@ -502,7 +502,7 @@ atom[string scopeName] returns [StateCluster g=null]
}
else
{
-				$g = factory.build_Atom(t);
+				$g = factory.BuildAtom(t);
t.followingNFAState = $g.right;
}
}
@@ -511,11 +511,11 @@ atom[string scopeName] returns [StateCluster g=null]
{
if ( grammar.type==Grammar.LEXER )
{
-				$g = factory.build_CharLiteralAtom(c);
+				$g = factory.BuildCharLiteralAtom(c);
}
else
{
-				$g = factory.build_Atom(c);
+				$g = factory.BuildAtom(c);
c.followingNFAState = $g.right;
}
}
@@ -524,11 +524,11 @@ atom[string scopeName] returns [StateCluster g=null]
{
if ( grammar.type==Grammar.LEXER )
{
-				$g = factory.build_StringLiteralAtom(s);
+				$g = factory.BuildStringLiteralAtom(s);
}
else
{
-				$g = factory.build_Atom(s);
+				$g = factory.BuildAtom(s);
s.followingNFAState = $g.right;
}
}
@@ -538,11 +538,11 @@ atom[string scopeName] returns [StateCluster g=null]
if ( nfa.grammar.type == Grammar.TREE_PARSER
&& (w.ChildIndex > 0 || w.Parent.GetChild(1).Type == EOA) )
{
-					$g = factory.build_WildcardTree( $w );
+					$g = factory.BuildWildcardTree( $w );
}
else
{
-					$g = factory.build_Wildcard( $w );
+					$g = factory.BuildWildcard( $w );
}
}

@@ -566,7 +566,7 @@ set returns [StateCluster g=null]
EOB
)
{
-		$g = factory.build_Set(elements,$b);
+		$g = factory.BuildSet(elements,$b);
$b.followingNFAState = $g.right;
$b.SetValue = elements; // track set value of this block
}
@@ -600,15 +600,15 @@ setElement[IIntSet elements]
{
if ( grammar.type==Grammar.LEXER )
{
-				ttype = Grammar.getCharValueFromGrammarCharLiteral($c.text);
+				ttype = Grammar.GetCharValueFromGrammarCharLiteral($c.text);
}
else
{
-				ttype = grammar.getTokenType($c.text);
+				ttype = grammar.GetTokenType($c.text);
}
if ( elements.Contains(ttype) )
{
-				ErrorManager.grammarError(
+				ErrorManager.GrammarError(
ErrorManager.MSG_DUPLICATE_SET_ENTRY,
grammar,
$c.Token,
@@ -621,10 +621,10 @@ setElement[IIntSet elements]
if ( grammar.type==Grammar.LEXER )
{
// recursively will invoke this rule to match elements in target rule ref
-				IIntSet ruleSet = grammar.getSetFromRule(this,$t.text);
+				IIntSet ruleSet = grammar.GetSetFromRule(this,$t.text);
if ( ruleSet==null )
{
-					ErrorManager.grammarError(
+					ErrorManager.GrammarError(
ErrorManager.MSG_RULE_INVALID_SET,
grammar,
$t.Token,
@@ -637,10 +637,10 @@ setElement[IIntSet elements]
}
else
{
-				ttype = grammar.getTokenType($t.text);
+				ttype = grammar.GetTokenType($t.text);
if ( elements.Contains(ttype) )
{
-					ErrorManager.grammarError(
+					ErrorManager.GrammarError(
ErrorManager.MSG_DUPLICATE_SET_ENTRY,
grammar,
$t.Token,
@@ -652,10 +652,10 @@ setElement[IIntSet elements]

|	s=STRING_LITERAL
{
-			ttype = grammar.getTokenType($s.text);
+			ttype = grammar.GetTokenType($s.text);
if ( elements.Contains(ttype) )
{
-				ErrorManager.grammarError(
+				ErrorManager.GrammarError(
ErrorManager.MSG_DUPLICATE_SET_ENTRY,
grammar,
$s.Token,
@@ -667,8 +667,8 @@ setElement[IIntSet elements]
{
if ( grammar.type==Grammar.LEXER )
{
-				int a = Grammar.getCharValueFromGrammarCharLiteral($c1.text);
-				int b = Grammar.getCharValueFromGrammarCharLiteral($c2.text);
+				int a = Grammar.GetCharValueFromGrammarCharLiteral($c1.text);
+				int b = Grammar.GetCharValueFromGrammarCharLiteral($c2.text);
elements.AddAll(IntervalSet.Of(a,b));
}
}
@@ -682,7 +682,7 @@ setElement[IIntSet elements]
|	^(	NOT {ns=new IntervalSet();}
setElement[ns]
{
-				IIntSet not = grammar.complement(ns);
+				IIntSet not = grammar.Complement(ns);
elements.AddAll(not);
}
)
@@ -736,19 +736,19 @@ testSetElement returns [int alts=1]
{{
if ( grammar.type==Grammar.LEXER )
{
-				Rule rule = grammar.getRule($t.text);
+				Rule rule = grammar.GetRule($t.text);
if ( rule==null )
{
//throw new RecognitionException("invalid rule");
throw new RecognitionException();
}
// recursively will invoke this rule to match elements in target rule ref
-				$alts += testSetRule(rule.tree);
+				$alts += TestSetRule(rule.tree);
}
}}
|   {grammar.type!=Grammar.LEXER}? => s=STRING_LITERAL
|	^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
-		{{ $alts = IntervalSet.Of( Grammar.getCharValueFromGrammarCharLiteral($c1.text), Grammar.getCharValueFromGrammarCharLiteral($c2.text) ).Count; }}
+		{{ $alts = IntervalSet.Of( Grammar.GetCharValueFromGrammarCharLiteral($c1.text), Grammar.GetCharValueFromGrammarCharLiteral($c2.text) ).Count; }}
|   testBlockAsSet
{{ $alts = $testBlockAsSet.alts; }}
|   ^( NOT tse=testSetElement )
diff --git a/Antlr3/Grammars/TreeToNFAConverterHelper.cs b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
index 3daf5e3..683a9c7 100644
--- a/Antlr3/Grammars/TreeToNFAConverterHelper.cs
+++ b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
@@ -70,7 +70,7 @@ namespace Antlr3.Grammars
this.factory = factory;
}

-        public IIntSet setRule( GrammarAST t )
+        public IIntSet SetRule( GrammarAST t )
{
TreeToNFAConverter other = new TreeToNFAConverter( grammar, nfa, factory, new CommonTreeNodeStream( t ) );

@@ -80,10 +80,10 @@ namespace Antlr3.Grammars

return other.setRule();
}
-        internal int testBlockAsSet( GrammarAST t )
+        internal int TestBlockAsSet( GrammarAST t )
{
-            Rule r = grammar.getLocallyDefinedRule( currentRuleName );
-            if ( r.hasRewrite( outerAltNum ) )
+            Rule r = grammar.GetLocallyDefinedRule( currentRuleName );
+            if ( r.HasRewrite( outerAltNum ) )
return -1;

TreeToNFAConverter other = new TreeToNFAConverter( grammar, nfa, factory, new CommonTreeNodeStream( t ) );
@@ -99,7 +99,7 @@ namespace Antlr3.Grammars

return result;
}
-        public int testSetRule( GrammarAST t )
+        public int TestSetRule( GrammarAST t )
{
TreeToNFAConverter other = new TreeToNFAConverter( grammar, nfa, factory, new CommonTreeNodeStream( t ) );

@@ -115,11 +115,11 @@ namespace Antlr3.Grammars
return result;
}

-        protected virtual void addFollowTransition( string ruleName, NFAState following )
+        protected virtual void AddFollowTransition( string ruleName, NFAState following )
{
//System.Console.Out.WriteLine( "adding follow link to rule " + ruleName );
// find last link in FOLLOW chain emanating from rule
-            Rule r = grammar.getRule( ruleName );
+            Rule r = grammar.GetRule( ruleName );
NFAState end = r.stopState;
while ( end.GetTransition( 1 ) != null )
{
@@ -129,7 +129,7 @@ namespace Antlr3.Grammars
{
// already points to a following node
// gotta add another node to keep edges to a max of 2
-                NFAState n = factory.newState();
+                NFAState n = factory.NewState();
Transition e = new Transition( Label.EPSILON, n );
end.AddTransition( e );
end = n;
@@ -138,12 +138,12 @@ namespace Antlr3.Grammars
end.AddTransition( followEdge );
}

-        protected virtual void finish()
+        protected virtual void Finish()
{
-            int numEntryPoints = factory.build_EOFStates( grammar.Rules );
+            int numEntryPoints = factory.BuildEofStates( grammar.Rules );
if ( numEntryPoints == 0 )
{
-                ErrorManager.grammarWarning( ErrorManager.MSG_NO_GRAMMAR_START_RULE,
+                ErrorManager.GrammarWarning( ErrorManager.MSG_NO_GRAMMAR_START_RULE,
grammar,
null,
grammar.name );
@@ -164,7 +164,7 @@ namespace Antlr3.Grammars
{
token = ( (NoViableAltException)ex ).token;
}
-            ErrorManager.syntaxError(
+            ErrorManager.SyntaxError(
ErrorManager.MSG_SYNTAX_ERROR,
grammar,
token,
diff --git a/Antlr3/Misc/BitSet.cs b/Antlr3/Misc/BitSet.cs
index 2c70ddd..d6ef754 100644
--- a/Antlr3/Misc/BitSet.cs
+++ b/Antlr3/Misc/BitSet.cs
@@ -602,7 +602,7 @@ namespace Antlr3.Misc
}
if ( g != null )
{
-                        buf.Append( g.getTokenDisplayName( i ) );
+                        buf.Append( g.GetTokenDisplayName( i ) );
}
else
{
diff --git a/Antlr3/Misc/IntervalSet.cs b/Antlr3/Misc/IntervalSet.cs
index 7697ad9..9876dd3 100644
--- a/Antlr3/Misc/IntervalSet.cs
+++ b/Antlr3/Misc/IntervalSet.cs
@@ -740,7 +740,7 @@ namespace Antlr3.Misc
{
if ( g != null )
{
-                        buf.Append( g.getTokenDisplayName( a ) );
+                        buf.Append( g.GetTokenDisplayName( a ) );
}
else
{
@@ -751,7 +751,7 @@ namespace Antlr3.Misc
{
if ( g != null )
{
-                        buf.Append( g.getTokenDisplayName( a ) + ".." + g.getTokenDisplayName( b ) );
+                        buf.Append( g.GetTokenDisplayName( a ) + ".." + g.GetTokenDisplayName( b ) );
}
else
{
diff --git a/Antlr3/Tool/ANTLRErrorListener.cs b/Antlr3/Tool/ANTLRErrorListener.cs
index fae2156..f3b8727 100644
--- a/Antlr3/Tool/ANTLRErrorListener.cs
+++ b/Antlr3/Tool/ANTLRErrorListener.cs
@@ -41,9 +41,9 @@ namespace Antlr3.Tool
*/
public interface IANTLRErrorListener
{
-        void info( string msg );
-        void error( Message msg );
-        void warning( Message msg );
-        void error( ToolMessage msg );
+        void Info( string msg );
+        void Error( Message msg );
+        void Warning( Message msg );
+        void Error( ToolMessage msg );
}
}
diff --git a/Antlr3/Tool/AssignTokenTypesBehavior.cs b/Antlr3/Tool/AssignTokenTypesBehavior.cs
index 136bd47..eaafab5 100644
--- a/Antlr3/Tool/AssignTokenTypesBehavior.cs
+++ b/Antlr3/Tool/AssignTokenTypesBehavior.cs
@@ -61,24 +61,24 @@ namespace Antlr3.Tool
*/
protected HashSet<string> tokenRuleDefs = new HashSet<string>();

-        protected override void init( Grammar g )
+        protected override void Init( Grammar g )
{
this.grammar = g;
currentRuleName = null;
if ( stringAlias == null )
{
// only init once; can't statically init since we need astFactory
-                initASTPatterns();
+                InitASTPatterns();
}
}

/** Track string literals (could be in tokens{} section) */
-        protected override void trackString( GrammarAST t )
+        protected override void TrackString( GrammarAST t )
{
// if lexer, don't allow aliasing in tokens section
if ( currentRuleName == null && grammar.type == Grammar.LEXER )
{
-                ErrorManager.grammarError( ErrorManager.MSG_CANNOT_ALIAS_TOKENS_IN_LEXER,
+                ErrorManager.GrammarError( ErrorManager.MSG_CANNOT_ALIAS_TOKENS_IN_LEXER,
grammar,
t.token,
t.Text );
@@ -89,9 +89,9 @@ namespace Antlr3.Tool
// don't warn until we hit root grammar as may be defined there.
if ( grammar.IsRoot &&
grammar.type == Grammar.PARSER &&
-                 grammar.getTokenType( t.Text ) == Label.INVALID )
+                 grammar.GetTokenType( t.Text ) == Label.INVALID )
{
-                ErrorManager.grammarError( ErrorManager.MSG_LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE,
+                ErrorManager.GrammarError( ErrorManager.MSG_LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE,
grammar,
t.token,
t.Text );
@@ -105,25 +105,25 @@ namespace Antlr3.Tool
// or in the tokens{} section
if ( ( currentRuleName == null ||
char.IsLower( currentRuleName[0] ) ) &&
-                                                                    grammar.getTokenType( t.Text ) == Label.INVALID )
+                                                                    grammar.GetTokenType( t.Text ) == Label.INVALID )
{
stringLiterals[t.Text] = UNASSIGNED_IN_PARSER_RULE;
}
}

-        protected override void trackToken( GrammarAST t )
+        protected override void TrackToken( GrammarAST t )
{
// imported token names might exist, only add if new
// Might have ';'=4 in vocab import and SEMI=';'. Avoid
// setting to UNASSIGNED if we have loaded ';'/SEMI
-            if ( grammar.getTokenType( t.Text ) == Label.INVALID &&
+            if ( grammar.GetTokenType( t.Text ) == Label.INVALID &&
!tokens.ContainsKey( t.Text ) )
{
tokens[t.Text] = UNASSIGNED;
}
}

-        protected override void trackTokenRule( GrammarAST t,
+        protected override void TrackTokenRule( GrammarAST t,
GrammarAST modifier,
GrammarAST block )
{
@@ -144,17 +144,17 @@ namespace Antlr3.Tool
// associated lexer rules.
grammar.composite.lexerRules.Add( t.Text );

-                int existing = grammar.getTokenType( t.Text );
+                int existing = grammar.GetTokenType( t.Text );
if ( existing == Label.INVALID )
{
tokens[t.Text] = UNASSIGNED;
}
// look for "<TOKEN> : <literal> ;" pattern
// (can have optional action last)
-                if ( block.hasSameTreeStructure( charAlias ) ||
-                     block.hasSameTreeStructure( stringAlias ) ||
-                     block.hasSameTreeStructure( charAlias2 ) ||
-                     block.hasSameTreeStructure( stringAlias2 ) )
+                if ( block.HasSameTreeStructure( charAlias ) ||
+                     block.HasSameTreeStructure( stringAlias ) ||
+                     block.HasSameTreeStructure( charAlias2 ) ||
+                     block.HasSameTreeStructure( stringAlias2 ) )
{
tokenRuleDefs.Add( t.Text );
/*
@@ -166,14 +166,14 @@ namespace Antlr3.Tool
if ( grammar.type == Grammar.COMBINED || grammar.type == Grammar.LEXER )
{
// only call this rule an alias if combined or lexer
-                        alias( t, (GrammarAST)block.GetChild( 0 ).GetChild( 0 ) );
+                        Alias( t, (GrammarAST)block.GetChild( 0 ).GetChild( 0 ) );
}
}
}
// else error
}

-        protected override void alias( GrammarAST t, GrammarAST s )
+        protected override void Alias( GrammarAST t, GrammarAST s )
{
string tokenID = t.Text;
string literal = s.Text;
@@ -192,7 +192,7 @@ namespace Antlr3.Tool
{
// don't allow alias if A='a' in tokens section and B : 'a'; is rule.
// Allow if both are rules.  Will get DFA nondeterminism error later.
-                    ErrorManager.grammarError( ErrorManager.MSG_TOKEN_ALIAS_CONFLICT,
+                    ErrorManager.GrammarError( ErrorManager.MSG_TOKEN_ALIAS_CONFLICT,
grammar,
t.token,
tokenID + "=" + literal,
@@ -200,7 +200,7 @@ namespace Antlr3.Tool
}
return; // don't do the alias
}
-            int existingLiteralType = grammar.getTokenType( literal );
+            int existingLiteralType = grammar.GetTokenType( literal );
if ( existingLiteralType != Label.INVALID )
{
// we've seen this before from a tokenVocab most likely
@@ -210,7 +210,7 @@ namespace Antlr3.Tool
string prevAliasTokenID = aliases.get( tokenID );
if ( prevAliasTokenID != null )
{
-                ErrorManager.grammarError( ErrorManager.MSG_TOKEN_ALIAS_REASSIGNMENT,
+                ErrorManager.GrammarError( ErrorManager.MSG_TOKEN_ALIAS_REASSIGNMENT,
grammar,
t.token,
tokenID + "=" + literal,
@@ -221,23 +221,23 @@ namespace Antlr3.Tool
aliasesReverseIndex[literal] = tokenID;
}

-        protected internal override void defineTokens( Grammar root )
+        protected internal override void DefineTokens( Grammar root )
{
//System.Console.Out.WriteLine( "stringLiterals=" + stringLiterals );
//System.Console.Out.WriteLine( "tokens=" + tokens );
//System.Console.Out.WriteLine( "aliases=" + aliases );
//System.Console.Out.WriteLine( "aliasesReverseIndex=" + aliasesReverseIndex );

-            assignTokenIDTypes( root );
+            AssignTokenIDTypes( root );

-            aliasTokenIDsAndLiterals( root );
+            AliasTokenIDsAndLiterals( root );

-            assignStringTypes( root );
+            AssignStringTypes( root );

//System.Console.Out.WriteLine( "stringLiterals=" + stringLiterals );
//System.Console.Out.WriteLine( "tokens=" + tokens );
//System.Console.Out.WriteLine( "aliases=" + aliases );
-            defineTokenNamesAndLiteralsInGrammar( root );
+            DefineTokenNamesAndLiteralsInGrammar( root );
}

#if false
@@ -262,20 +262,20 @@ namespace Antlr3.Tool
}
#endif

-        protected override void assignStringTypes( Grammar root )
+        protected override void AssignStringTypes( Grammar root )
{
// walk string literals assigning types to unassigned ones
foreach ( var literal in stringLiterals.Where( pair => pair.Value < Label.MIN_TOKEN_TYPE ).ToArray() )
{
-                int type = root.getNewTokenType();
+                int type = root.GetNewTokenType();
stringLiterals[literal.Key] = type;
// if string referenced in combined grammar parser rule,
// automatically define in the generated lexer
-                root.defineLexerRuleForStringLiteral( literal.Key, type );
+                root.DefineLexerRuleForStringLiteral( literal.Key, type );
}
}

-        protected override void aliasTokenIDsAndLiterals( Grammar root )
+        protected override void AliasTokenIDsAndLiterals( Grammar root )
{
if ( root.type == Grammar.LEXER )
{
@@ -294,31 +294,31 @@ namespace Antlr3.Tool
int typeI = (int)tokens.get( tokenID );
if ( !tokenRuleDefs.Contains( tokenID ) )
{
-                        root.defineLexerRuleForAliasedStringLiteral( tokenID, literal, typeI );
+                        root.DefineLexerRuleForAliasedStringLiteral( tokenID, literal, typeI );
}
}
}
}

-        protected override void assignTokenIDTypes( Grammar root )
+        protected override void AssignTokenIDTypes( Grammar root )
{
// walk token names, assigning values if unassigned
foreach ( var token in tokens.Where( pair => pair.Value == UNASSIGNED ).ToArray() )
{
-                tokens[token.Key] = root.getNewTokenType();
+                tokens[token.Key] = root.GetNewTokenType();
}
}

-        protected override void defineTokenNamesAndLiteralsInGrammar( Grammar root )
+        protected override void DefineTokenNamesAndLiteralsInGrammar( Grammar root )
{
foreach ( var token in tokens )
{
-                root.defineToken( token.Key, token.Value );
+                root.DefineToken( token.Key, token.Value );
}

foreach ( var lit in stringLiterals )
{
-                root.defineToken( lit.Key, lit.Value );
+                root.DefineToken( lit.Key, lit.Value );
}
}

diff --git a/Antlr3/Tool/Attribute.cs b/Antlr3/Tool/Attribute.cs
index 2695a8e..5846c19 100644
--- a/Antlr3/Tool/Attribute.cs
+++ b/Antlr3/Tool/Attribute.cs
@@ -69,7 +69,7 @@ namespace Antlr3.Tool

public Attribute( string decl )
{
-            extractAttribute( decl );
+            ExtractAttribute( decl );
}

public Attribute( string name, string decl )
@@ -86,7 +86,7 @@ namespace Antlr3.Tool
*
*  Set name, type, initvalue, and full decl instance vars.
*/
-        protected virtual void extractAttribute( string decl )
+        protected virtual void ExtractAttribute( string decl )
{
if ( decl == null )
{
@@ -124,7 +124,7 @@ namespace Antlr3.Tool
}
if ( start < 0 )
{
-                ErrorManager.error( ErrorManager.MSG_CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL, decl );
+                ErrorManager.Error( ErrorManager.MSG_CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL, decl );
}
// walk forwards looking for end of an ID
int stop = -1;
diff --git a/Antlr3/Tool/AttributeScope.cs b/Antlr3/Tool/AttributeScope.cs
index 68fc2ce..d590274 100644
--- a/Antlr3/Tool/AttributeScope.cs
+++ b/Antlr3/Tool/AttributeScope.cs
@@ -56,14 +56,14 @@ namespace Antlr3.Tool

static AttributeScope()
{
-            tokenScope.addAttribute( "text", null );
-            tokenScope.addAttribute( "type", null );
-            tokenScope.addAttribute( "line", null );
-            tokenScope.addAttribute( "index", null );
-            tokenScope.addAttribute( "pos", null );
-            tokenScope.addAttribute( "channel", null );
-            tokenScope.addAttribute( "tree", null );
-            tokenScope.addAttribute( "int", null );
+            tokenScope.AddAttribute( "text", null );
+            tokenScope.AddAttribute( "type", null );
+            tokenScope.AddAttribute( "line", null );
+            tokenScope.AddAttribute( "index", null );
+            tokenScope.AddAttribute( "pos", null );
+            tokenScope.AddAttribute( "channel", null );
+            tokenScope.AddAttribute( "tree", null );
+            tokenScope.AddAttribute( "int", null );
}

/** This scope is associated with which input token (for error handling)? */
@@ -120,26 +120,26 @@ namespace Antlr3.Tool
{
get
{
-                return getAttributes();
+                return GetAttributes();
}
}
public int Count
{
get
{
-                return size();
+                return Size();
}
}
public string Name
{
get
{
-                return getName();
+                return GetName();
}
}
#endregion

-        public virtual string getName()
+        public virtual string GetName()
{
if ( isParameterScope )
{
@@ -165,7 +165,7 @@ namespace Antlr3.Tool
*  would pass in definitions equal to the text in between {...} and
*  separator=';'.  It results in two Attribute objects.
*/
-        public virtual void addAttributes( string definitions, int separator )
+        public virtual void AddAttributes( string definitions, int separator )
{
IList<string> attrs = new List<string>();
CodeGenerator.GetListOfArgumentsFromAction( definitions, 0, -1, separator, attrs );
@@ -174,7 +174,7 @@ namespace Antlr3.Tool
Attribute attr = new Attribute( a );
if ( !isReturnScope && attr.InitValue != null )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_ARG_INIT_VALUES_ILLEGAL,
+                    ErrorManager.GrammarError( ErrorManager.MSG_ARG_INIT_VALUES_ILLEGAL,
grammar,
derivedFromToken,
attr.Name );
@@ -201,7 +201,7 @@ namespace Antlr3.Tool
}
}

-        public virtual void addAttribute( string name, string decl )
+        public virtual void AddAttribute( string name, string decl )
{
Attribute attr = new Attribute( name, decl );
for ( int i = 0; i <= attributes.Count; i++ )
@@ -233,7 +233,7 @@ namespace Antlr3.Tool
GrammarAST a;
if ( Actions.TryGetValue( actionName, out a ) && a != null )
{
-                ErrorManager.grammarError(
+                ErrorManager.GrammarError(
ErrorManager.MSG_ACTION_REDEFINITION, grammar,
nameAST.Token, nameAST.Text );
}
@@ -243,13 +243,13 @@ namespace Antlr3.Tool
}
}

-        public virtual Attribute getAttribute( string name )
+        public virtual Attribute GetAttribute( string name )
{
return attributes.FirstOrDefault( attr => attr.Name == name );
}

/** Used by templates to get all attributes */
-        public virtual IList<Attribute> getAttributes()
+        public virtual IList<Attribute> GetAttributes()
{
return attributes.ToArray();
}
@@ -257,7 +257,7 @@ namespace Antlr3.Tool
/** Return the set of keys that collide from
*  this and other.
*/
-        public virtual HashSet<object> intersection( AttributeScope other )
+        public virtual HashSet<object> Intersection( AttributeScope other )
{
if ( other == null || other.Count == 0 || Count == 0 )
{
@@ -267,7 +267,7 @@ namespace Antlr3.Tool
foreach ( Attribute attr in attributes )
{
string key = attr.Name;
-                if ( other.getAttribute( key ) != null )
+                if ( other.GetAttribute( key ) != null )
{
inter.Add( key );
}
@@ -279,7 +279,7 @@ namespace Antlr3.Tool
return inter;
}

-        public virtual int size()
+        public virtual int Size()
{
return attributes == null ? 0 : attributes.Count;
}
diff --git a/Antlr3/Tool/BuildDependencyGenerator.cs b/Antlr3/Tool/BuildDependencyGenerator.cs
index 191e1c2..1e85491 100644
--- a/Antlr3/Tool/BuildDependencyGenerator.cs
+++ b/Antlr3/Tool/BuildDependencyGenerator.cs
@@ -94,7 +94,7 @@ namespace Antlr3.Tool
this.tool = tool;
this.grammarFileName = grammarFileName;
grammar = tool.GetRootGrammar( grammarFileName );
-            string language = (string)grammar.getOption( "language" );
+            string language = (string)grammar.GetOption( "language" );
generator = new CodeGenerator( tool, grammar, language );
generator.LoadTemplates( language );
}
@@ -118,7 +118,7 @@ namespace Antlr3.Tool
/** From T.g return a list of File objects that
*  name files ANTLR will emit from T.g.
*/
-        public virtual IList<string> getGeneratedFileList()
+        public virtual IList<string> GetGeneratedFileList()
{
List<FileInfo> files = new List<FileInfo>();
System.IO.DirectoryInfo outputDir = tool.GetOutputDirectory( grammarFileName );
@@ -170,11 +170,11 @@ namespace Antlr3.Tool

// handle generated files for imported grammars
IList<Grammar> imports =
-                grammar.composite.getDelegates( grammar.composite.RootGrammar );
+                grammar.composite.GetDelegates( grammar.composite.RootGrammar );
foreach ( Grammar g in imports )
{
outputDir = tool.GetOutputDirectory( g.FileName );
-                string fname = groomQualifiedFileName( outputDir.ToString(), g.getRecognizerName() + extST.ToString() );
+                string fname = GroomQualifiedFileName( outputDir.ToString(), g.GetRecognizerName() + extST.ToString() );
files.Add( new FileInfo( fname ) );
}

@@ -190,20 +190,20 @@ namespace Antlr3.Tool
*  to process T.g; This can be .tokens files if the grammar uses the tokenVocab option
*  as well as any imported grammar files.
*/
-        public virtual IList<string> getDependenciesFileList()
+        public virtual IList<string> GetDependenciesFileList()
{
// Find all things other than imported grammars
//
-            IList<string> files = getNonImportDependenciesFileList();
+            IList<string> files = GetNonImportDependenciesFileList();

// Handle imported grammars
//
IList<Grammar> imports =
-                grammar.composite.getDelegates( grammar.composite.RootGrammar );
+                grammar.composite.GetDelegates( grammar.composite.RootGrammar );
foreach ( Grammar g in imports )
{
string libdir = tool.LibraryDirectory;
-                string fileName = groomQualifiedFileName( libdir, g.fileName );
+                string fileName = GroomQualifiedFileName( libdir, g.fileName );
files.Add( fileName );
}

@@ -221,12 +221,12 @@ namespace Antlr3.Tool
*
* @return List of dependencies other than imported grammars
*/
-        public virtual List<string> getNonImportDependenciesFileList()
+        public virtual List<string> GetNonImportDependenciesFileList()
{
List<string> files = new List<string>();

// handle token vocabulary loads
-            tokenVocab = (string)grammar.getOption( "tokenVocab" );
+            tokenVocab = (string)grammar.GetOption( "tokenVocab" );
if ( tokenVocab != null )
{
FileInfo vocabFile = tool.GetImportedVocabFile( tokenVocab );
@@ -236,17 +236,17 @@ namespace Antlr3.Tool
return files;
}

-        public virtual StringTemplate getDependencies()
+        public virtual StringTemplate GetDependencies()
{
-            loadDependencyTemplates();
+            LoadDependencyTemplates();
StringTemplate dependenciesST = templates.GetInstanceOf( "dependencies" );
-            dependenciesST.SetAttribute( "in", getDependenciesFileList() );
-            dependenciesST.SetAttribute( "out", getGeneratedFileList() );
+            dependenciesST.SetAttribute( "in", GetDependenciesFileList() );
+            dependenciesST.SetAttribute( "out", GetGeneratedFileList() );
dependenciesST.SetAttribute( "grammarFileName", grammar.fileName );
return dependenciesST;
}

-        public virtual void loadDependencyTemplates()
+        public virtual void LoadDependencyTemplates()
{
throw new NotImplementedException();
//if ( templates != null )
@@ -294,7 +294,7 @@ namespace Antlr3.Tool
//}
}

-        public virtual string groomQualifiedFileName( string outputDir, string fileName )
+        public virtual string GroomQualifiedFileName( string outputDir, string fileName )
{
if ( outputDir.Equals( "." ) )
{
diff --git a/Antlr3/Tool/CompositeGrammar.cs b/Antlr3/Tool/CompositeGrammar.cs
index d08c6b9..f3eaaad 100644
--- a/Antlr3/Tool/CompositeGrammar.cs
+++ b/Antlr3/Tool/CompositeGrammar.cs
@@ -155,7 +155,7 @@ namespace Antlr3.Tool
public CompositeGrammar( Grammar g )
: this()
{
-            setDelegationRoot( g );
+            SetDelegationRoot( g );
}

#region Properties
@@ -163,30 +163,30 @@ namespace Antlr3.Tool
{
get
{
-                return getRootGrammar();
+                return GetRootGrammar();
}
}
#endregion

-        public virtual void setDelegationRoot( Grammar root )
+        public virtual void SetDelegationRoot( Grammar root )
{
delegateGrammarTreeRoot = new CompositeGrammarTree( root );
root.compositeTreeNode = delegateGrammarTreeRoot;
}

-        public virtual Rule getRule( string ruleName )
+        public virtual Rule GetRule( string ruleName )
{
-            return delegateGrammarTreeRoot.getRule( ruleName );
+            return delegateGrammarTreeRoot.GetRule( ruleName );
}

-        public virtual object getOption( string key )
+        public virtual object GetOption( string key )
{
-            return delegateGrammarTreeRoot.getOption( key );
+            return delegateGrammarTreeRoot.GetOption( key );
}

/** Add delegate grammar as child of delegator */
#if WTF
-        public void addGrammar( Grammar delegator, Grammar @delegate )
+        public void AddGrammar( Grammar delegator, Grammar @delegate )
{
if ( delegator.compositeTreeNode == null )
{
@@ -202,16 +202,16 @@ namespace Antlr3.Tool
@delegate.composite = this;
}
#else
-        public virtual void addGrammar( Grammar delegator, Grammar @delegate )
+        public virtual void AddGrammar( Grammar delegator, Grammar @delegate )
{
throw new System.NotImplementedException();
}
#endif

/** Get parent of this grammar */
-        public virtual Grammar getDelegator( Grammar g )
+        public virtual Grammar GetDelegator( Grammar g )
{
-            CompositeGrammarTree me = delegateGrammarTreeRoot.findNode( g );
+            CompositeGrammarTree me = delegateGrammarTreeRoot.FindNode( g );
if ( me == null )
{
return null; // not found
@@ -227,21 +227,21 @@ namespace Antlr3.Tool
*  The grammars are in delegation tree preorder.  Don't include g itself
*  in list as it is not a delegate of itself.
*/
-        public virtual IList<Grammar> getDelegates( Grammar g )
+        public virtual IList<Grammar> GetDelegates( Grammar g )
{
-            CompositeGrammarTree t = delegateGrammarTreeRoot.findNode( g );
+            CompositeGrammarTree t = delegateGrammarTreeRoot.FindNode( g );
if ( t == null )
{
return null; // no delegates
}
-            IList<Grammar> grammars = t.getPostOrderedGrammarList();
+            IList<Grammar> grammars = t.GetPostOrderedGrammarList();
grammars.RemoveAt( grammars.Count - 1 ); // remove g (last one)
return grammars;
}

-        public virtual IList<Grammar> getDirectDelegates( Grammar g )
+        public virtual IList<Grammar> GetDirectDelegates( Grammar g )
{
-            CompositeGrammarTree t = delegateGrammarTreeRoot.findNode( g );
+            CompositeGrammarTree t = delegateGrammarTreeRoot.FindNode( g );
IList<CompositeGrammarTree> children = t.children;
if ( children == null )
{
@@ -257,28 +257,28 @@ namespace Antlr3.Tool
}

/** Get delegates below direct delegates of g */
-        public virtual IList<Grammar> getIndirectDelegates( Grammar g )
+        public virtual IList<Grammar> GetIndirectDelegates( Grammar g )
{
//IList<Grammar> direct = getDirectDelegates( g );
//IList<Grammar> delegates = getDelegates( g );
//delegates.removeAll( direct );
//return delegates;
-            return getDelegates( g )
-                .Except( getDirectDelegates( g ) ?? Enumerable.Empty<Grammar>() )
+            return GetDelegates( g )
+                .Except( GetDirectDelegates( g ) ?? Enumerable.Empty<Grammar>() )
.ToArray();
}

/** Return list of delegate grammars from root down to g.
*  Order is root, ..., g.parent.  (g not included).
*/
-        public virtual IList<Grammar> getDelegators( Grammar g )
+        public virtual IList<Grammar> GetDelegators( Grammar g )
{
if ( g == delegateGrammarTreeRoot.grammar )
{
return null;
}
List<Grammar> grammars = new List<Grammar>();
-            CompositeGrammarTree t = delegateGrammarTreeRoot.findNode( g );
+            CompositeGrammarTree t = delegateGrammarTreeRoot.FindNode( g );
// walk backwards to root, collecting grammars
CompositeGrammarTree p = t.parent;
while ( p != null )
@@ -298,17 +298,17 @@ namespace Antlr3.Tool
*  should not be instantiated directly for use as parsers (you can create
*  them to pass to the root parser's ctor as arguments).
*/
-        public virtual HashSet<Rule> getDelegatedRules( Grammar g )
+        public virtual HashSet<Rule> GetDelegatedRules( Grammar g )
{
if ( g != delegateGrammarTreeRoot.grammar )
{
return null;
}

-            HashSet<Rule> rules = getAllImportedRules( g );
+            HashSet<Rule> rules = GetAllImportedRules( g );
foreach ( Rule r in rules.ToArray() )
{
-                Rule localRule = g.getLocallyDefinedRule( r.name );
+                Rule localRule = g.GetLocallyDefinedRule( r.name );
// if locally defined or it's not local but synpred, don't make a delegation method
if ( localRule != null || r.isSynPred )
{
@@ -322,12 +322,12 @@ namespace Antlr3.Tool
/** Get all rule definitions from all direct/indirect delegate grammars
*  of g.
*/
-        public virtual HashSet<Rule> getAllImportedRules( Grammar g )
+        public virtual HashSet<Rule> GetAllImportedRules( Grammar g )
{
HashSet<string> ruleNames = new HashSet<string>();
HashSet<Rule> rules = new HashSet<Rule>();
-            CompositeGrammarTree subtreeRoot = delegateGrammarTreeRoot.findNode( g );
-            IList<Grammar> grammars = subtreeRoot.getPostOrderedGrammarList();
+            CompositeGrammarTree subtreeRoot = delegateGrammarTreeRoot.FindNode( g );
+            IList<Grammar> grammars = subtreeRoot.GetPostOrderedGrammarList();
// walk all grammars
foreach ( Grammar grammar in grammars )
{
@@ -345,7 +345,7 @@ namespace Antlr3.Tool
return rules;
}

-        public virtual Grammar getRootGrammar()
+        public virtual Grammar GetRootGrammar()
{
if ( delegateGrammarTreeRoot == null )
{
@@ -354,9 +354,9 @@ namespace Antlr3.Tool
return delegateGrammarTreeRoot.grammar;
}

-        public virtual Grammar getGrammar( string grammarName )
+        public virtual Grammar GetGrammar( string grammarName )
{
-            CompositeGrammarTree t = delegateGrammarTreeRoot.findNode( grammarName );
+            CompositeGrammarTree t = delegateGrammarTreeRoot.FindNode( grammarName );
if ( t != null )
{
return t.grammar;
@@ -366,28 +366,28 @@ namespace Antlr3.Tool

// NFA spans multiple grammars, must handle here

-        public virtual int getNewNFAStateNumber()
+        public virtual int GetNewNFAStateNumber()
{
return stateCounter++;
}

-        public virtual void addState( NFAState state )
+        public virtual void AddState( NFAState state )
{
numberToStateList.setSize( state.stateNumber + 1 ); // make sure we have room
numberToStateList[state.stateNumber] = state;
}

-        public virtual NFAState getState( int s )
+        public virtual NFAState GetState( int s )
{
return (NFAState)numberToStateList[s];
}

-        public virtual void assignTokenTypes()
+        public virtual void AssignTokenTypes()
{
// ASSIGN TOKEN TYPES for all delegates (same walker)
//System.Console.Out.WriteLine( "### assign types" );
//ttypesWalker.setASTNodeClass( "org.antlr.tool.GrammarAST" );
-            IList<Grammar> grammars = delegateGrammarTreeRoot.getPostOrderedGrammarList();
+            IList<Grammar> grammars = delegateGrammarTreeRoot.GetPostOrderedGrammarList();
for ( int i = 0; grammars != null && i < grammars.Count; i++ )
{
Grammar g = (Grammar)grammars[i];
@@ -399,40 +399,40 @@ namespace Antlr3.Tool

// the walker has filled literals, tokens, and alias tables.
// now tell it to define them in the root grammar
-                    ttypesWalker.defineTokens( delegateGrammarTreeRoot.grammar );
+                    ttypesWalker.DefineTokens( delegateGrammarTreeRoot.grammar );
}
catch ( RecognitionException re )
{
-                    ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                    ErrorManager.Error( ErrorManager.MSG_BAD_AST_STRUCTURE,
re );
}
}
}

-        public virtual void defineGrammarSymbols()
+        public virtual void DefineGrammarSymbols()
{
-            delegateGrammarTreeRoot.trimLexerImportsIntoCombined();
-            IList<Grammar> grammars = delegateGrammarTreeRoot.getPostOrderedGrammarList();
+            delegateGrammarTreeRoot.TrimLexerImportsIntoCombined();
+            IList<Grammar> grammars = delegateGrammarTreeRoot.GetPostOrderedGrammarList();
for ( int i = 0; grammars != null && i < grammars.Count; i++ )
{
Grammar g = (Grammar)grammars[i];
-                g.defineGrammarSymbols();
+                g.DefineGrammarSymbols();
}
for ( int i = 0; grammars != null && i < grammars.Count; i++ )
{
Grammar g = (Grammar)grammars[i];
-                g.checkNameSpaceAndActions();
+                g.CheckNameSpaceAndActions();
}
-            minimizeRuleSet();
+            MinimizeRuleSet();
}

-        public virtual void createNFAs()
+        public virtual void CreateNFAs()
{
-            if ( ErrorManager.doNotAttemptAnalysis() )
+            if ( ErrorManager.DoNotAttemptAnalysis() )
{
return;
}
-            IList<Grammar> grammars = delegateGrammarTreeRoot.getPostOrderedGrammarList();
+            IList<Grammar> grammars = delegateGrammarTreeRoot.GetPostOrderedGrammarList();
IList<string> names = new List<string>();
for ( int i = 0; i < grammars.Count; i++ )
{
@@ -443,22 +443,22 @@ namespace Antlr3.Tool
for ( int i = 0; grammars != null && i < grammars.Count; i++ )
{
Grammar g = (Grammar)grammars[i];
-                g.createRuleStartAndStopNFAStates();
+                g.CreateRuleStartAndStopNFAStates();
}
for ( int i = 0; grammars != null && i < grammars.Count; i++ )
{
Grammar g = (Grammar)grammars[i];
-                g.buildNFA();
+                g.BuildNFA();
}
}

-        public virtual void minimizeRuleSet()
+        public void MinimizeRuleSet()
{
HashSet<string> ruleDefs = new HashSet<string>();
-            _minimizeRuleSet( ruleDefs, delegateGrammarTreeRoot );
+            MinimizeRuleSetCore( ruleDefs, delegateGrammarTreeRoot );
}

-        public virtual void _minimizeRuleSet( HashSet<string> ruleDefs,
+        protected virtual void MinimizeRuleSetCore( HashSet<string> ruleDefs,
CompositeGrammarTree p )
{
HashSet<string> localRuleDefs = new HashSet<string>();
@@ -490,7 +490,7 @@ namespace Antlr3.Tool
{
foreach ( CompositeGrammarTree @delegate in p.children )
{
-                    _minimizeRuleSet( ruleDefs, @delegate );
+                    MinimizeRuleSetCore( ruleDefs, @delegate );
}
}
}
diff --git a/Antlr3/Tool/CompositeGrammarTree.cs b/Antlr3/Tool/CompositeGrammarTree.cs
index c8a6e0b..499cd47 100644
--- a/Antlr3/Tool/CompositeGrammarTree.cs
+++ b/Antlr3/Tool/CompositeGrammarTree.cs
@@ -48,7 +48,7 @@ namespace Antlr3.Tool
grammar = g;
}

-        public virtual void addChild( CompositeGrammarTree t )
+        public virtual void AddChild( CompositeGrammarTree t )
{
//Console.Out.WriteLine("add "+t.toStringTree()+" as child to "+this.toStringTree());
if ( t == null )
@@ -66,33 +66,33 @@ namespace Antlr3.Tool
/** Find a rule by looking in current grammar then down towards the
*  delegate grammars.
*/
-        public virtual Rule getRule( string ruleName )
+        public virtual Rule GetRule( string ruleName )
{
-            Rule r = grammar.getLocallyDefinedRule( ruleName );
+            Rule r = grammar.GetLocallyDefinedRule( ruleName );
for ( int i = 0; r == null && children != null && i < children.Count; i++ )
{
CompositeGrammarTree child = children[i];
-                r = child.getRule( ruleName );
+                r = child.GetRule( ruleName );
}
return r;
}

/** Find an option by looking up towards the root grammar rather than down */
-        public virtual object getOption( string key )
+        public virtual object GetOption( string key )
{
-            object o = grammar.getLocallyDefinedOption( key );
+            object o = grammar.GetLocallyDefinedOption( key );
if ( o != null )
{
return o;
}
if ( parent != null )
{
-                return parent.getOption( key );
+                return parent.GetOption( key );
}
return null; // not found
}

-        public virtual CompositeGrammarTree findNode( Grammar g )
+        public virtual CompositeGrammarTree FindNode( Grammar g )
{
if ( g == null )
{
@@ -106,12 +106,12 @@ namespace Antlr3.Tool
for ( int i = 0; n == null && children != null && i < children.Count; i++ )
{
CompositeGrammarTree child = children[i];
-                n = child.findNode( g );
+                n = child.FindNode( g );
}
return n;
}

-        public virtual CompositeGrammarTree findNode( string grammarName )
+        public virtual CompositeGrammarTree FindNode( string grammarName )
{
if ( grammarName == null )
{
@@ -125,49 +125,49 @@ namespace Antlr3.Tool
for ( int i = 0; n == null && children != null && i < children.Count; i++ )
{
CompositeGrammarTree child = children[i];
-                n = child.findNode( grammarName );
+                n = child.FindNode( grammarName );
}
return n;
}

/** Return a postorder list of grammars; root is last in list */
-        public virtual IList<Grammar> getPostOrderedGrammarList()
+        public IList<Grammar> GetPostOrderedGrammarList()
{
IList<Grammar> grammars = new List<Grammar>();
-            _getPostOrderedGrammarList( grammars );
+            GetPostOrderedGrammarListCore( grammars );
return grammars;
}

/** work for getPostOrderedGrammarList */
-        protected virtual void _getPostOrderedGrammarList( IList<Grammar> grammars )
+        protected virtual void GetPostOrderedGrammarListCore( IList<Grammar> grammars )
{
for ( int i = 0; children != null && i < children.Count; i++ )
{
CompositeGrammarTree child = children[i];
-                child._getPostOrderedGrammarList( grammars );
+                child.GetPostOrderedGrammarListCore( grammars );
}
grammars.Add( this.grammar );
}

/** Return a postorder list of grammars; root is last in list */
-        public virtual IList<Grammar> getPreOrderedGrammarList()
+        public IList<Grammar> GetPreOrderedGrammarList()
{
IList<Grammar> grammars = new List<Grammar>();
-            _getPreOrderedGrammarList( grammars );
+            GetPreOrderedGrammarListCore( grammars );
return grammars;
}

-        protected virtual void _getPreOrderedGrammarList( IList<Grammar> grammars )
+        protected virtual void GetPreOrderedGrammarListCore( IList<Grammar> grammars )
{
grammars.Add( this.grammar );
for ( int i = 0; children != null && i < children.Count; i++ )
{
CompositeGrammarTree child = children[i];
-                child._getPostOrderedGrammarList( grammars );
+                child.GetPostOrderedGrammarListCore( grammars );
}
}

-        public virtual void trimLexerImportsIntoCombined()
+        public virtual void TrimLexerImportsIntoCombined()
{
CompositeGrammarTree p = this;
if ( p.grammar.type == Grammar.LEXER && p.parent != null &&
@@ -179,7 +179,7 @@ namespace Antlr3.Tool
for ( int i = 0; children != null && i < children.Count; i++ )
{
CompositeGrammarTree child = children[i];
-                child.trimLexerImportsIntoCombined();
+                child.TrimLexerImportsIntoCombined();
}
}
}
diff --git a/Antlr3/Tool/DOTGenerator.cs b/Antlr3/Tool/DOTGenerator.cs
index 1f3370f..4bbeb5b 100644
--- a/Antlr3/Tool/DOTGenerator.cs
+++ b/Antlr3/Tool/DOTGenerator.cs
@@ -104,7 +104,7 @@ namespace Antlr3.Tool
*  will show the incoming state machine visually.  All nodes reachable
*  from startState will be included.
*/
-        public virtual string getDOT( State startState )
+        public virtual string GetDOT( State startState )
{
if ( startState == null )
{
@@ -120,14 +120,14 @@ namespace Antlr3.Tool
startState.stateNumber );
dot.SetAttribute( "useBox",
AntlrTool.internalOption_ShowNFAConfigsInDFA );
-                walkCreatingDFADOT( dot, (DFAState)startState );
+                WalkCreatingDFADOT( dot, (DFAState)startState );
}
else
{
dot = stlib.GetInstanceOf( Path.Combine( dfaTemplateDirectoryName, "nfa" ) );
dot.SetAttribute( "startState",
startState.stateNumber );
-                walkRuleNFACreatingDOT( dot, startState );
+                WalkRuleNFACreatingDOT( dot, startState );
}
dot.SetAttribute( "rankdir", rankdir );
return dot.ToString();
@@ -138,7 +138,7 @@ namespace Antlr3.Tool
*  will show the incoming state machine visually.  All nodes reachable
*  from startState will be included.
*/
-        public string getRuleNFADOT( State startState )
+        public string GetRuleNFADOT( State startState )
{
// The output DOT graph for visualization
StringTemplate dot = stlib.GetInstanceOf( Path.Combine( dfaTemplateDirectoryName, "nfa" ) );
@@ -154,7 +154,7 @@ namespace Antlr3.Tool
*  fill a DOT description template.  Keep filling the
*  states and edges attributes.
*/
-        protected virtual void walkCreatingDFADOT( StringTemplate dot,
+        protected virtual void WalkCreatingDFADOT( StringTemplate dot,
DFAState s )
{
if ( markedStates.Contains( s.stateNumber ) )
@@ -174,7 +174,7 @@ namespace Antlr3.Tool
{
st = stlib.GetInstanceOf( Path.Combine( dfaTemplateDirectoryName, "state" ) );
}
-            st.SetAttribute( "name", getStateLabel( s ) );
+            st.SetAttribute( "name", GetStateLabel( s ) );
dot.SetAttribute( "states", st );

// make a DOT edge for each transition
@@ -192,12 +192,12 @@ namespace Antlr3.Tool
}
}
st = stlib.GetInstanceOf( Path.Combine( dfaTemplateDirectoryName, "edge" ) );
-                st.SetAttribute( "label", getEdgeLabel( edge ) );
-                st.SetAttribute( "src", getStateLabel( s ) );
-                st.SetAttribute( "target", getStateLabel( edge.target ) );
+                st.SetAttribute( "label", GetEdgeLabel( edge ) );
+                st.SetAttribute( "src", GetStateLabel( s ) );
+                st.SetAttribute( "target", GetStateLabel( edge.target ) );
st.SetAttribute( "arrowhead", arrowhead );
dot.SetAttribute( "edges", st );
-                walkCreatingDFADOT( dot, (DFAState)edge.target ); // keep walkin'
+                WalkCreatingDFADOT( dot, (DFAState)edge.target ); // keep walkin'
}
}

@@ -207,7 +207,7 @@ namespace Antlr3.Tool
*  for a rule so don't traverse edges to other rules and
*  don't go past rule end state.
*/
-        protected virtual void walkRuleNFACreatingDOT( StringTemplate dot,
+        protected virtual void WalkRuleNFACreatingDOT( StringTemplate dot,
State s )
{
if ( markedStates.Contains( s.stateNumber ) )
@@ -227,7 +227,7 @@ namespace Antlr3.Tool
{
stateST = stlib.GetInstanceOf( Path.Combine( dfaTemplateDirectoryName, "state" ) );
}
-            stateST.SetAttribute( "name", getStateLabel( s ) );
+            stateST.SetAttribute( "name", GetStateLabel( s ) );
dot.SetAttribute( "states", stateST );

if ( s.IsAcceptState )
@@ -246,7 +246,7 @@ namespace Antlr3.Tool
NFAState alt = (NFAState)s;
while ( alt != null )
{
-                        rankST.SetAttribute( "states", getStateLabel( alt ) );
+                        rankST.SetAttribute( "states", GetStateLabel( alt ) );
if ( alt.transition[1] != null )
{
alt = (NFAState)alt.transition[1].target;
@@ -278,11 +278,11 @@ namespace Antlr3.Tool
{
edgeST.SetAttribute( "label", "<" + rr.rule.name + ">" );
}
-                    edgeST.SetAttribute( "src", getStateLabel( s ) );
-                    edgeST.SetAttribute( "target", getStateLabel( rr.followState ) );
+                    edgeST.SetAttribute( "src", GetStateLabel( s ) );
+                    edgeST.SetAttribute( "target", GetStateLabel( rr.followState ) );
edgeST.SetAttribute( "arrowhead", arrowhead );
dot.SetAttribute( "edges", edgeST );
-                    walkRuleNFACreatingDOT( dot, rr.followState );
+                    WalkRuleNFACreatingDOT( dot, rr.followState );
continue;
}
if ( edge.IsAction )
@@ -297,17 +297,17 @@ namespace Antlr3.Tool
{
edgeST = stlib.GetInstanceOf( Path.Combine( dfaTemplateDirectoryName, "edge" ) );
}
-                edgeST.SetAttribute( "label", getEdgeLabel( edge ) );
-                edgeST.SetAttribute( "src", getStateLabel( s ) );
-                edgeST.SetAttribute( "target", getStateLabel( edge.target ) );
+                edgeST.SetAttribute( "label", GetEdgeLabel( edge ) );
+                edgeST.SetAttribute( "src", GetStateLabel( s ) );
+                edgeST.SetAttribute( "target", GetStateLabel( edge.target ) );
edgeST.SetAttribute( "arrowhead", arrowhead );
dot.SetAttribute( "edges", edgeST );
-                walkRuleNFACreatingDOT( dot, edge.target ); // keep walkin'
+                WalkRuleNFACreatingDOT( dot, edge.target ); // keep walkin'
}
}

#if false
-        public void writeDOTFilesForAllRuleNFAs()
+        public void WriteDOTFilesForAllRuleNFAs()
{
var rules = grammar.Rules;
foreach ( var r in rules )
@@ -321,7 +321,7 @@ namespace Antlr3.Tool
#endif

#if false
-        public void writeDOTFilesForAllDecisionDFAs()
+        public void WriteDOTFilesForAllDecisionDFAs()
{
// for debugging, create a DOT file for each decision in
// a directory named for the grammar.
@@ -350,7 +350,7 @@ namespace Antlr3.Tool
/** Fix edge strings so they print out in DOT properly;
*  generate any gated predicates on edge too.
*/
-        protected virtual string getEdgeLabel( Transition edge )
+        protected virtual string GetEdgeLabel( Transition edge )
{
string label = edge.label.ToString( grammar );
label = label.Replace( "\\", "\\\\" );
@@ -380,7 +380,7 @@ namespace Antlr3.Tool
return label;
}

-        protected virtual string getStateLabel( State s )
+        protected virtual string GetStateLabel( State s )
{
if ( s == null )
{
diff --git a/Antlr3/Tool/ErrorManager.cs b/Antlr3/Tool/ErrorManager.cs
index e8ed6a2..743c75c 100644
--- a/Antlr3/Tool/ErrorManager.cs
+++ b/Antlr3/Tool/ErrorManager.cs
@@ -252,39 +252,39 @@ namespace Antlr3.Tool

class DefaultErrorListener : IANTLRErrorListener
{
-            public virtual void info( String msg )
+            public virtual void Info( String msg )
{
-                if ( formatWantsSingleLineMessage() )
+                if ( FormatWantsSingleLineMessage() )
{
msg = msg.replaceAll( "\n", " " );
}
Console.Error.WriteLine( msg );
}

-            public virtual void error( Message msg )
+            public virtual void Error( Message msg )
{
String outputMsg = msg.ToString();
-                if ( formatWantsSingleLineMessage() )
+                if ( FormatWantsSingleLineMessage() )
{
outputMsg = outputMsg.replaceAll( "\n", " " );
}
Console.Error.WriteLine( outputMsg );
}

-            public virtual void warning( Message msg )
+            public virtual void Warning( Message msg )
{
String outputMsg = msg.ToString();
-                if ( formatWantsSingleLineMessage() )
+                if ( FormatWantsSingleLineMessage() )
{
outputMsg = outputMsg.replaceAll( "\n", " " );
}
Console.Error.WriteLine( outputMsg );
}

-            public virtual void error( ToolMessage msg )
+            public virtual void Error( ToolMessage msg )
{
String outputMsg = msg.ToString();
-                if ( formatWantsSingleLineMessage() )
+                if ( FormatWantsSingleLineMessage() )
{
outputMsg = outputMsg.replaceAll( "\n", " " );
}
@@ -347,11 +347,11 @@ namespace Antlr3.Tool
{
e = e.InnerException ?? e;
}
-                ErrorManager.error( ErrorManager.MSG_INTERNAL_ERROR, s, e );
+                ErrorManager.Error( ErrorManager.MSG_INTERNAL_ERROR, s, e );
}
public virtual void Warning( String s )
{
-                ErrorManager.warning( ErrorManager.MSG_INTERNAL_WARNING, s );
+                ErrorManager.Warning( ErrorManager.MSG_INTERNAL_WARNING, s );
}
public virtual void Debug( String s )
{
@@ -364,19 +364,19 @@ namespace Antlr3.Tool

static ErrorManager()
{
-            initIdToMessageNameMapping();
+            InitIdToMessageNameMapping();
// it is inefficient to set the default locale here if another
// piece of code is going to set the locale, but that would
// require that a user call an init() function or something.  I prefer
// that this class be ready to go when loaded as I'm absentminded ;)
-            setLocale( CultureInfo.CurrentCulture );
+            SetLocale( CultureInfo.CurrentCulture );
// try to load the message format group
// the user might have specified one on the command line
// if not, or if the user has given an illegal value, we will fall back to "antlr"
-            setFormat( "antlr" );
+            SetFormat( "antlr" );
}

-        public static IStringTemplateErrorListener getStringTemplateErrorListener()
+        public static IStringTemplateErrorListener GetStringTemplateErrorListener()
{
return theDefaultSTListener;
}
@@ -386,7 +386,7 @@ namespace Antlr3.Tool
*  so that French Canadians and French Frenchies all get the same
*  template file, fr.stg.  Just easier this way.
*/
-        public static void setLocale( CultureInfo locale )
+        public static void SetLocale( CultureInfo locale )
{
ErrorManager.locale = locale;
String language = locale.TwoLetterISOLanguageName;
@@ -406,12 +406,12 @@ namespace Antlr3.Tool
//    @is = cl.getResourceAsStream(fileName);
//}
if ( @is==null && language.Equals(CultureInfo.GetCultureInfo("en-us").TwoLetterISOLanguageName) ) {
-                rawError("ANTLR installation corrupted; cannot find English messages file "+fileName);
-                panic();
+                RawError("ANTLR installation corrupted; cannot find English messages file "+fileName);
+                Panic();
}
else if ( @is==null ) {
//rawError("no such locale file "+fileName+" retrying with English locale");
-                setLocale(CultureInfo.GetCultureInfo("en-us")); // recurse on this rule, trying the US locale
+                SetLocale(CultureInfo.GetCultureInfo("en-us")); // recurse on this rule, trying the US locale
return;
}
StreamReader br = null;
@@ -423,7 +423,7 @@ namespace Antlr3.Tool
br.Close();
}
catch (IOException ioe) {
-                rawError("error reading message file "+fileName, ioe);
+                RawError("error reading message file "+fileName, ioe);
}
finally {
if ( br!=null ) {
@@ -431,26 +431,26 @@ namespace Antlr3.Tool
br.Close();
}
catch (IOException ioe) {
-                        rawError("cannot close message file "+fileName, ioe);
+                        RawError("cannot close message file "+fileName, ioe);
}
}
}

messages.ErrorListener = blankSTListener;
-            bool messagesOK = verifyMessages();
+            bool messagesOK = VerifyMessages();
if ( !messagesOK && language.Equals(CultureInfo.GetCultureInfo("en-us").TwoLetterISOLanguageName) ) {
-                rawError("ANTLR installation corrupted; English messages file "+language+".stg incomplete");
-                panic();
+                RawError("ANTLR installation corrupted; English messages file "+language+".stg incomplete");
+                Panic();
}
else if ( !messagesOK ) {
-                setLocale(CultureInfo.GetCultureInfo("en-us")); // try US to see if that will work
+                SetLocale(CultureInfo.GetCultureInfo("en-us")); // try US to see if that will work
}
}

/** The format gets reset either from the Tool if the user supplied a command line option to that effect
*  Otherwise we just use the default "antlr".
*/
-        public static void setFormat( String formatName )
+        public static void SetFormat( String formatName )
{
ErrorManager.formatName = formatName;
//String fileName = "org/antlr/tool/templates/messages/formats/"+formatName+".stg";
@@ -470,13 +470,13 @@ namespace Antlr3.Tool
//}
if ( @is == null && formatName.Equals( "antlr" ) )
{
-                rawError( "ANTLR installation corrupted; cannot find ANTLR messages format file " + fileName );
-                panic();
+                RawError( "ANTLR installation corrupted; cannot find ANTLR messages format file " + fileName );
+                Panic();
}
else if ( @is == null )
{
-                rawError( "no such message format file " + fileName + " retrying with default ANTLR format" );
-                setFormat( "antlr" ); // recurse on this rule, trying the default message format
+                RawError( "no such message format file " + fileName + " retrying with default ANTLR format" );
+                SetFormat( "antlr" ); // recurse on this rule, trying the default message format
return;
}
StreamReader br = null;
@@ -498,20 +498,20 @@ namespace Antlr3.Tool
}
catch ( IOException ioe )
{
-                    rawError( "cannot close message format file " + fileName, ioe );
+                    RawError( "cannot close message format file " + fileName, ioe );
}
}

format.ErrorListener = blankSTListener;
-            bool formatOK = verifyFormat();
+            bool formatOK = VerifyFormat();
if ( !formatOK && formatName.Equals( "antlr" ) )
{
-                rawError( "ANTLR installation corrupted; ANTLR messages format file " + formatName + ".stg incomplete" );
-                panic();
+                RawError( "ANTLR installation corrupted; ANTLR messages format file " + formatName + ".stg incomplete" );
+                Panic();
}
else if ( !formatOK )
{
-                setFormat( "antlr" ); // recurse on this rule, trying the default message format
+                SetFormat( "antlr" ); // recurse on this rule, trying the default message format
}
}

@@ -549,17 +549,17 @@ namespace Antlr3.Tool
*  depending on the thread.  I store a single listener per
*  thread.
*/
-        public static void setErrorListener( IANTLRErrorListener listener )
+        public static void SetErrorListener( IANTLRErrorListener listener )
{
threadToListenerMap[Thread.CurrentThread] = listener;
}

-        public static void removeErrorListener()
+        public static void RemoveErrorListener()
{
threadToListenerMap.Remove( Thread.CurrentThread );
}

-        public static void setTool( Tool tool )
+        public static void SetTool( Tool tool )
{
threadToToolMap[Thread.CurrentThread] = tool;
}
@@ -568,46 +568,46 @@ namespace Antlr3.Tool
*  with data.  We need to convert the int ID to the name of a template
*  in the messages ST group.
*/
-        public static StringTemplate getMessage( int msgID )
+        public static StringTemplate GetMessage( int msgID )
{
String msgName = idToMessageTemplateName[msgID];
return messages.GetInstanceOf( msgName );
}
-        public static String getMessageType( int msgID )
+        public static String GetMessageType( int msgID )
{
-            if ( getErrorState().warningMsgIDs.Contains( msgID ) )
+            if ( GetErrorState().warningMsgIDs.Contains( msgID ) )
{
return messages.GetInstanceOf( "warning" ).ToString();
}
-            else if ( getErrorState().errorMsgIDs.Contains( msgID ) )
+            else if ( GetErrorState().errorMsgIDs.Contains( msgID ) )
{
return messages.GetInstanceOf( "error" ).ToString();
}
-            assertTrue( false, "Assertion failed! Message ID " + msgID + " created but is not present in errorMsgIDs or warningMsgIDs." );
+            AssertTrue( false, "Assertion failed! Message ID " + msgID + " created but is not present in errorMsgIDs or warningMsgIDs." );
return "";
}

/** Return a StringTemplate that refers to the current format used for
* emitting messages.
*/
-        public static StringTemplate getLocationFormat()
+        public static StringTemplate GetLocationFormat()
{
return format.GetInstanceOf( "location" );
}
-        public static StringTemplate getReportFormat()
+        public static StringTemplate GetReportFormat()
{
return format.GetInstanceOf( "report" );
}
-        public static StringTemplate getMessageFormat()
+        public static StringTemplate GetMessageFormat()
{
return format.GetInstanceOf( "message" );
}
-        public static bool formatWantsSingleLineMessage()
+        public static bool FormatWantsSingleLineMessage()
{
return format.GetInstanceOf( "wantsSingleLineMessage" ).ToString().Equals( "true" );
}

-        public static IANTLRErrorListener getErrorListener()
+        public static IANTLRErrorListener GetErrorListener()
{
IANTLRErrorListener el =
(IANTLRErrorListener)threadToListenerMap.get( Thread.CurrentThread );
@@ -618,7 +618,7 @@ namespace Antlr3.Tool
return el;
}

-        public static ErrorState getErrorState()
+        public static ErrorState GetErrorState()
{
ErrorState ec =
(ErrorState)threadToErrorStateMap.get( Thread.CurrentThread );
@@ -630,141 +630,141 @@ namespace Antlr3.Tool
return ec;
}

-        public static int getNumErrors()
+        public static int GetNumErrors()
{
-            return getErrorState().errors;
+            return GetErrorState().errors;
}

-        public static void resetErrorState()
+        public static void ResetErrorState()
{
threadToListenerMap = new Dictionary<Thread, IANTLRErrorListener>();
ErrorState ec = new ErrorState();
threadToErrorStateMap[Thread.CurrentThread] = ec;
}

-        public static void info( String msg )
+        public static void Info( String msg )
{
-            getErrorState().infos++;
-            getErrorListener().info( msg );
+            GetErrorState().infos++;
+            GetErrorListener().Info( msg );
}

-        public static void error( int msgID )
+        public static void Error( int msgID )
{
-            getErrorState().errors++;
-            getErrorState().errorMsgIDs.Add( msgID );
-            getErrorListener().error( new ToolMessage( msgID ) );
+            GetErrorState().errors++;
+            GetErrorState().errorMsgIDs.Add( msgID );
+            GetErrorListener().Error( new ToolMessage( msgID ) );
}

-        public static void error( int msgID, Exception e )
+        public static void Error( int msgID, Exception e )
{
-            getErrorState().errors++;
-            getErrorState().errorMsgIDs.Add( msgID );
-            getErrorListener().error( new ToolMessage( msgID, e ) );
+            GetErrorState().errors++;
+            GetErrorState().errorMsgIDs.Add( msgID );
+            GetErrorListener().Error( new ToolMessage( msgID, e ) );
}

-        public static void error( int msgID, Object arg )
+        public static void Error( int msgID, Object arg )
{
-            getErrorState().errors++;
-            getErrorState().errorMsgIDs.Add( msgID );
-            getErrorListener().error( new ToolMessage( msgID, arg ) );
+            GetErrorState().errors++;
+            GetErrorState().errorMsgIDs.Add( msgID );
+            GetErrorListener().Error( new ToolMessage( msgID, arg ) );
}

-        public static void error( int msgID, Object arg, Object arg2 )
+        public static void Error( int msgID, Object arg, Object arg2 )
{
-            getErrorState().errors++;
-            getErrorState().errorMsgIDs.Add( msgID );
-            getErrorListener().error( new ToolMessage( msgID, arg, arg2 ) );
+            GetErrorState().errors++;
+            GetErrorState().errorMsgIDs.Add( msgID );
+            GetErrorListener().Error( new ToolMessage( msgID, arg, arg2 ) );
}

-        public static void error( int msgID, Object arg, Exception e )
+        public static void Error( int msgID, Object arg, Exception e )
{
-            getErrorState().errors++;
-            getErrorState().errorMsgIDs.Add( msgID );
-            getErrorListener().error( new ToolMessage( msgID, arg, e ) );
+            GetErrorState().errors++;
+            GetErrorState().errorMsgIDs.Add( msgID );
+            GetErrorListener().Error( new ToolMessage( msgID, arg, e ) );
}

-        public static void warning( int msgID, Object arg )
+        public static void Warning( int msgID, Object arg )
{
-            getErrorState().warnings++;
-            getErrorState().warningMsgIDs.Add( msgID );
-            getErrorListener().warning( new ToolMessage( msgID, arg ) );
+            GetErrorState().warnings++;
+            GetErrorState().warningMsgIDs.Add( msgID );
+            GetErrorListener().Warning( new ToolMessage( msgID, arg ) );
}

-        public static void nondeterminism( DecisionProbe probe,
+        public static void Nondeterminism( DecisionProbe probe,
DFAState d )
{
-            getErrorState().warnings++;
+            GetErrorState().warnings++;
Message msg = new GrammarNonDeterminismMessage( probe, d );
-            getErrorState().warningMsgIDs.Add( msg.msgID );
-            getErrorListener().warning( msg );
+            GetErrorState().warningMsgIDs.Add( msg.msgID );
+            GetErrorListener().Warning( msg );
}

-        public static void danglingState( DecisionProbe probe,
+        public static void DanglingState( DecisionProbe probe,
DFAState d )
{
-            getErrorState().errors++;
+            GetErrorState().errors++;
Message msg = new GrammarDanglingStateMessage( probe, d );
-            getErrorState().errorMsgIDs.Add( msg.msgID );
+            GetErrorState().errorMsgIDs.Add( msg.msgID );
ICollection<object> seen = (ICollection<object>)emitSingleError.get( "danglingState" );
if ( !seen.Contains( d.dfa.decisionNumber + "|" + d.AltSet ) )
{
-                getErrorListener().error( msg );
+                GetErrorListener().Error( msg );
// we've seen this decision and this alt set; never again
seen.Add( d.dfa.decisionNumber + "|" + d.AltSet );
}
}

-        public static void analysisAborted( DecisionProbe probe )
+        public static void AnalysisAborted( DecisionProbe probe )
{
-            getErrorState().warnings++;
+            GetErrorState().warnings++;
Message msg = new GrammarAnalysisAbortedMessage( probe );
-            getErrorState().warningMsgIDs.Add( msg.msgID );
-            getErrorListener().warning( msg );
+            GetErrorState().warningMsgIDs.Add( msg.msgID );
+            GetErrorListener().Warning( msg );
}

-        public static void unreachableAlts( DecisionProbe probe,
+        public static void UnreachableAlts( DecisionProbe probe,
IEnumerable<int> alts )
{
-            getErrorState().errors++;
+            GetErrorState().errors++;
Message msg = new GrammarUnreachableAltsMessage( probe, alts );
-            getErrorState().errorMsgIDs.Add( msg.msgID );
-            getErrorListener().error( msg );
+            GetErrorState().errorMsgIDs.Add( msg.msgID );
+            GetErrorListener().Error( msg );
}

-        public static void insufficientPredicates( DecisionProbe probe,
+        public static void InsufficientPredicates( DecisionProbe probe,
DFAState d,
IDictionary<int, ICollection<IToken>> altToUncoveredLocations )
{
-            getErrorState().warnings++;
+            GetErrorState().warnings++;
Message msg = new GrammarInsufficientPredicatesMessage( probe, d, altToUncoveredLocations );
-            getErrorState().warningMsgIDs.Add( msg.msgID );
-            getErrorListener().warning( msg );
+            GetErrorState().warningMsgIDs.Add( msg.msgID );
+            GetErrorListener().Warning( msg );
}

-        public static void nonLLStarDecision( DecisionProbe probe )
+        public static void NonLLStarDecision( DecisionProbe probe )
{
-            getErrorState().errors++;
+            GetErrorState().errors++;
Message msg = new NonRegularDecisionMessage( probe, probe.NonDeterministicAlts );
-            getErrorState().errorMsgIDs.Add( msg.msgID );
-            getErrorListener().error( msg );
+            GetErrorState().errorMsgIDs.Add( msg.msgID );
+            GetErrorListener().Error( msg );
}

-        public static void recursionOverflow( DecisionProbe probe,
+        public static void RecursionOverflow( DecisionProbe probe,
DFAState sampleBadState,
int alt,
ICollection<string> targetRules,
ICollection<ICollection<NFAState>> callSiteStates )
{
-            getErrorState().errors++;
+            GetErrorState().errors++;
Message msg = new RecursionOverflowMessage( probe, sampleBadState, alt,
targetRules, callSiteStates );
-            getErrorState().errorMsgIDs.Add( msg.msgID );
-            getErrorListener().error( msg );
+            GetErrorState().errorMsgIDs.Add( msg.msgID );
+            GetErrorListener().Error( msg );
}

#if false
// TODO: we can remove I think.  All detected now with cycles check.
-        public static void leftRecursion(DecisionProbe probe,
+        public static void LeftRecursion(DecisionProbe probe,
int alt,
ICollection targetRules,
ICollection callSiteStates)
@@ -772,113 +772,113 @@ namespace Antlr3.Tool
getErrorState().warnings++;
Message msg = new LeftRecursionMessage(probe, alt, targetRules, callSiteStates);
getErrorState().warningMsgIDs.add(msg.msgID);
-            getErrorListener().warning(msg);
+            getErrorListener().Warning(msg);
}
#endif

-        public static void leftRecursionCycles( ICollection cycles )
+        public static void LeftRecursionCycles( ICollection cycles )
{
-            getErrorState().errors++;
+            GetErrorState().errors++;
Message msg = new LeftRecursionCyclesMessage( cycles );
-            getErrorState().errorMsgIDs.Add( msg.msgID );
-            getErrorListener().warning( msg );
+            GetErrorState().errorMsgIDs.Add( msg.msgID );
+            GetErrorListener().Warning( msg );
}

-        public static void grammarError( int msgID,
+        public static void GrammarError( int msgID,
Grammar g,
IToken token,
Object arg,
Object arg2 )
{
-            getErrorState().errors++;
+            GetErrorState().errors++;
Message msg = new GrammarSemanticsMessage( msgID, g, token, arg, arg2 );
-            getErrorState().errorMsgIDs.Add( msgID );
-            getErrorListener().error( msg );
+            GetErrorState().errorMsgIDs.Add( msgID );
+            GetErrorListener().Error( msg );
}

-        public static void grammarError( int msgID,
+        public static void GrammarError( int msgID,
Grammar g,
IToken token,
Object arg )
{
-            grammarError( msgID, g, token, arg, null );
+            GrammarError( msgID, g, token, arg, null );
}

-        public static void grammarError( int msgID,
+        public static void GrammarError( int msgID,
Grammar g,
IToken token )
{
-            grammarError( msgID, g, token, null, null );
+            GrammarError( msgID, g, token, null, null );
}

-        public static void grammarWarning( int msgID,
+        public static void GrammarWarning( int msgID,
Grammar g,
IToken token,
Object arg,
Object arg2 )
{
-            getErrorState().warnings++;
+            GetErrorState().warnings++;
Message msg = new GrammarSemanticsMessage( msgID, g, token, arg, arg2 );
-            getErrorState().warningMsgIDs.Add( msgID );
-            getErrorListener().warning( msg );
+            GetErrorState().warningMsgIDs.Add( msgID );
+            GetErrorListener().Warning( msg );
}

-        public static void grammarWarning( int msgID,
+        public static void GrammarWarning( int msgID,
Grammar g,
IToken token,
Object arg )
{
-            grammarWarning( msgID, g, token, arg, null );
+            GrammarWarning( msgID, g, token, arg, null );
}

-        public static void grammarWarning( int msgID,
+        public static void GrammarWarning( int msgID,
Grammar g,
IToken token )
{
-            grammarWarning( msgID, g, token, null, null );
+            GrammarWarning( msgID, g, token, null, null );
}

-        public static void syntaxError( int msgID,
+        public static void SyntaxError( int msgID,
Grammar grammar,
IToken token,
Object arg,
RecognitionException re )
{
-            getErrorState().errors++;
-            getErrorState().errorMsgIDs.Add( msgID );
-            getErrorListener().error(
+            GetErrorState().errors++;
+            GetErrorState().errorMsgIDs.Add( msgID );
+            GetErrorListener().Error(
new GrammarSyntaxMessage( msgID, grammar, token, arg, re )
);
}

-        public static void internalError( Object error, Exception e )
+        public static void InternalError( Object error, Exception e )
{
-            StackFrame location = getLastNonErrorManagerCodeLocation( e );
+            StackFrame location = GetLastNonErrorManagerCodeLocation( e );
String msg = "Exception " + e + "@" + location + ": " + error;
-            ErrorManager.error( MSG_INTERNAL_ERROR, msg );
+            ErrorManager.Error( MSG_INTERNAL_ERROR, msg );
}

-        public static void internalError( Object error )
+        public static void InternalError( Object error )
{
StackFrame location =
-                getLastNonErrorManagerCodeLocation( new Exception() );
+                GetLastNonErrorManagerCodeLocation( new Exception() );
String msg = location + ": " + error;
-            ErrorManager.error( MSG_INTERNAL_ERROR, msg );
+            ErrorManager.Error( MSG_INTERNAL_ERROR, msg );
}

-        public static bool doNotAttemptAnalysis()
+        public static bool DoNotAttemptAnalysis()
{
-            return !getErrorState().errorMsgIDs.And( ERRORS_FORCING_NO_ANALYSIS ).IsNil;
+            return !GetErrorState().errorMsgIDs.And( ERRORS_FORCING_NO_ANALYSIS ).IsNil;
}

-        public static bool doNotAttemptCodeGen()
+        public static bool DoNotAttemptCodeGen()
{
-            return doNotAttemptAnalysis() ||
-                   !getErrorState().errorMsgIDs.And( ERRORS_FORCING_NO_CODEGEN ).IsNil;
+            return DoNotAttemptAnalysis() ||
+                   !GetErrorState().errorMsgIDs.And( ERRORS_FORCING_NO_CODEGEN ).IsNil;
}

/** Return first non ErrorManager code location for generating messages */
-        private static StackFrame getLastNonErrorManagerCodeLocation( Exception e )
+        private static StackFrame GetLastNonErrorManagerCodeLocation( Exception e )
{
StackFrame[] stack = e.getStackTrace();
int i = 0;
@@ -896,17 +896,17 @@ namespace Antlr3.Tool

// A S S E R T I O N  C O D E

-        public static void assertTrue( bool condition, String message )
+        public static void AssertTrue( bool condition, String message )
{
if ( !condition )
{
-                internalError( message );
+                InternalError( message );
}
}

// S U P P O R T  C O D E

-        static bool initIdToMessageNameMapping()
+        static bool InitIdToMessageNameMapping()
{
// make sure a message exists, even if it's just to indicate a problem
for ( int i = 0; i < idToMessageTemplateName.Length; i++ )
@@ -948,7 +948,7 @@ namespace Antlr3.Tool
/** Use reflection to find list of MSG_ fields and then verify a
*  template exists for each one from the locale's group.
*/
-        static bool verifyMessages()
+        static bool VerifyMessages()
{
bool ok = true;
FieldInfo[] fields = typeof( ErrorManager ).GetFields();
@@ -983,7 +983,7 @@ namespace Antlr3.Tool
}

/** Verify the message format template group */
-        static bool verifyFormat()
+        static bool VerifyFormat()
{
bool ok = true;
if ( !format.IsDefined( "location" ) )
@@ -1007,21 +1007,21 @@ namespace Antlr3.Tool
/** If there are errors during ErrorManager init, we have no choice
*  but to go to System.err.
*/
-        static void rawError( String msg )
+        static void RawError( String msg )
{
Console.Error.WriteLine( msg );
}

-        static void rawError( String msg, Exception e )
+        static void RawError( String msg, Exception e )
{
-            rawError( msg );
+            RawError( msg );
e.PrintStackTrace( Console.Error );
}

/** I *think* this will allow Tool subclasses to exit gracefully
*  for GUIs etc...
*/
-        public static void panic()
+        public static void Panic()
{
Tool tool = (Tool)threadToToolMap.get( Thread.CurrentThread );
if ( tool == null )
diff --git a/Antlr3/Tool/FASerializer.cs b/Antlr3/Tool/FASerializer.cs
index d7ab037..7165bd8 100644
--- a/Antlr3/Tool/FASerializer.cs
+++ b/Antlr3/Tool/FASerializer.cs
@@ -69,13 +69,13 @@ namespace Antlr3.Tool
this.grammar = grammar;
}

-        public virtual string serialize( State s )
+        public virtual string Serialize( State s )
{
if ( s == null )
{
return "<no automaton>";
}
-            return serialize( s, true );
+            return Serialize( s, true );
}

/** Return a string representation of a state machine.  Two identical
@@ -86,24 +86,24 @@ namespace Antlr3.Tool
*  will be identical.  Accept states are distinguished from regular
*  states.
*/
-        public virtual string serialize( State s, bool renumber )
+        public virtual string Serialize( State s, bool renumber )
{
markedStates = new HashSet<State>();
stateCounter = 0;
if ( renumber )
{
stateNumberTranslator = new Dictionary<State, int>();
-                walkFANormalizingStateNumbers( s );
+                WalkFANormalizingStateNumbers( s );
}
List<string> lines = new List<string>();
if ( s.NumberOfTransitions > 0 )
{
-                walkSerializingFA( lines, s );
+                WalkSerializingFA( lines, s );
}
else
{
// special case: s0 is an accept
-                string s0 = getStateString( 0, s );
+                string s0 = GetStateString( 0, s );
lines.Add( s0 + "\n" );
}
StringBuilder buf = new StringBuilder( 0 );
@@ -122,11 +122,11 @@ namespace Antlr3.Tool
*  state number.  Used by walkSerializingFA to make sure any two
*  identical state machines will serialize the same way.
*/
-        protected virtual void walkFANormalizingStateNumbers( State s )
+        protected virtual void WalkFANormalizingStateNumbers( State s )
{
if ( s == null )
{
-                ErrorManager.internalError( "null state s" );
+                ErrorManager.InternalError( "null state s" );
return;
}
if ( stateNumberTranslator.ContainsKey( s ) )
@@ -141,18 +141,18 @@ namespace Antlr3.Tool
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
Transition edge = (Transition)s.GetTransition( i );
-                walkFANormalizingStateNumbers( edge.target ); // keep walkin'
+                WalkFANormalizingStateNumbers( edge.target ); // keep walkin'
// if this transition is a rule reference, the node "following" this state
// will not be found and appear to be not in graph.  Must explicitly jump
// to it, but don't "draw" an edge.
if ( edge is RuleClosureTransition )
{
-                    walkFANormalizingStateNumbers( ( (RuleClosureTransition)edge ).followState );
+                    WalkFANormalizingStateNumbers( ( (RuleClosureTransition)edge ).followState );
}
}
}

-        protected virtual void walkSerializingFA( IList lines, State s )
+        protected virtual void WalkSerializingFA( IList lines, State s )
{
if ( markedStates.Contains( s ) )
{
@@ -167,7 +167,7 @@ namespace Antlr3.Tool
normalizedStateNumber = stateNumberTranslator[s];
}

-            string stateStr = getStateString( normalizedStateNumber, s );
+            string stateStr = GetStateString( normalizedStateNumber, s );

// depth first walk each transition, printing its edge first
for ( int i = 0; i < s.NumberOfTransitions; i++ )
@@ -211,25 +211,25 @@ namespace Antlr3.Tool
{
normalizedTargetStateNumber = stateNumberTranslator[edge.target];
}
-                buf.Append( getStateString( normalizedTargetStateNumber, edge.target ) );
+                buf.Append( GetStateString( normalizedTargetStateNumber, edge.target ) );
buf.Append( "\n" );
lines.Add( buf.ToString() );

// walk this transition
-                walkSerializingFA( lines, edge.target );
+                WalkSerializingFA( lines, edge.target );

// if this transition is a rule reference, the node "following" this state
// will not be found and appear to be not in graph.  Must explicitly jump
// to it, but don't "draw" an edge.
if ( edge is RuleClosureTransition )
{
-                    walkSerializingFA( lines, ( (RuleClosureTransition)edge ).followState );
+                    WalkSerializingFA( lines, ( (RuleClosureTransition)edge ).followState );
}
}

}

-        private string getStateString( int n, State s )
+        private string GetStateString( int n, State s )
{
string stateStr = ".s" + n;
if ( s.IsAcceptState )
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index b70a5f0..d9bbb71 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -201,9 +201,9 @@ namespace Antlr3.Tool
this.elementRef = elementRef;
this.referencedRuleName = elementRef.Text;
}
-            public Rule getReferencedRule()
+            public Rule GetReferencedRule()
{
-                return _outer.getRule( referencedRuleName );
+                return _outer.GetRule( referencedRuleName );
}
public override string ToString()
{
@@ -565,7 +565,7 @@ namespace Antlr3.Tool
// ensure we have the composite set to something
if ( composite.delegateGrammarTreeRoot == null )
{
-                composite.setDelegationRoot( this );
+                composite.SetDelegationRoot( this );
}
else
{
@@ -601,10 +601,10 @@ namespace Antlr3.Tool
Tool = tool;
FileName = "<string>";
StringReader r = new StringReader( grammarString );
-            parseAndBuildAST( r );
-            composite.assignTokenTypes();
-            defineGrammarSymbols();
-            checkNameSpaceAndActions();
+            ParseAndBuildAST( r );
+            composite.AssignTokenTypes();
+            DefineGrammarSymbols();
+            CheckNameSpaceAndActions();
}

#region Properties
@@ -641,7 +641,7 @@ namespace Antlr3.Tool
{
get
{
-                string outputType = (string)getOption( "output" );
+                string outputType = (string)GetOption( "output" );
if ( outputType != null )
{
return outputType.Equals( "AST" );
@@ -653,7 +653,7 @@ namespace Antlr3.Tool
{
get
{
-                string outputType = (string)getOption( "output" );
+                string outputType = (string)GetOption( "output" );
if ( outputType != null )
{
return outputType.Equals( "template" );
@@ -667,6 +667,10 @@ namespace Antlr3.Tool
{
return generator;
}
+            set
+            {
+                generator = value;
+            }
}
public string DefaultRuleModifier
{
@@ -683,14 +687,14 @@ namespace Antlr3.Tool
{
get
{
-                return getDelegatedRuleReferences();
+                return GetDelegatedRuleReferences();
}
}
public ICollection<Grammar> Delegates
{
get
{
-                return getDelegates();
+                return GetDelegates();
}
}
/** Who's my direct parent grammar? */
@@ -698,21 +702,21 @@ namespace Antlr3.Tool
{
get
{
-                return composite.getDelegator( this );
+                return composite.GetDelegator( this );
}
}
public ICollection<Grammar> Delegators
{
get
{
-                return getDelegators();
+                return GetDelegators();
}
}
public ICollection<Grammar> DirectDelegates
{
get
{
-                return getDirectDelegates();
+                return GetDirectDelegates();
}
}
public string FileName
@@ -753,7 +757,7 @@ namespace Antlr3.Tool
{
get
{
-                return getIndirectDelegates();
+                return GetIndirectDelegates();
}
}
public bool IsBuiltFromString
@@ -770,6 +774,17 @@ namespace Antlr3.Tool
return composite.delegateGrammarTreeRoot.grammar == this;
}
}
+
+        // this is used by the codegen templates
+        [System.Obsolete]
+        public bool GrammarIsRoot
+        {
+            get
+            {
+                return IsRoot;
+            }
+        }
+
public IDictionary<string, DFA> LineColumnToLookaheadDFAMap
{
get
@@ -806,7 +821,7 @@ namespace Antlr3.Tool
{
get
{
-                return getGrammarMaxLookahead();
+                return GetGrammarMaxLookahead();
}
}
public int NumberOfDecisions
@@ -820,14 +835,14 @@ namespace Antlr3.Tool
{
get
{
-                return getRecognizerName();
+                return GetRecognizerName();
}
}
public bool RewriteMode
{
get
{
-                string outputType = (string)getOption( "rewrite" );
+                string outputType = (string)GetOption( "rewrite" );
if ( outputType != null )
{
return outputType.Equals( "true" );
@@ -897,19 +912,7 @@ namespace Antlr3.Tool
}
#endregion

-        [System.Obsolete]
-        public virtual void setFileName( string fileName )
-        {
-            FileName = fileName;
-        }
-
-        [System.Obsolete]
-        public string getFileName()
-        {
-            return FileName;
-        }
-
-        public virtual void setName( string name )
+        public virtual void SetName( string name )
{
if ( name == null )
{
@@ -934,7 +937,7 @@ namespace Antlr3.Tool
//String onlyFileNameNoSuffix = null;
if ( onlyFileNameNoSuffix == onlyFileName )
{
-                    ErrorManager.error( ErrorManager.MSG_FILENAME_EXTENSION_ERROR, fileName );
+                    ErrorManager.Error( ErrorManager.MSG_FILENAME_EXTENSION_ERROR, fileName );
onlyFileNameNoSuffix = onlyFileName + GRAMMAR_FILE_EXTENSION;
}
else
@@ -943,7 +946,7 @@ namespace Antlr3.Tool
}
if ( !name.Equals( onlyFileNameNoSuffix ) )
{
-                    ErrorManager.error( ErrorManager.MSG_FILE_AND_GRAMMAR_NAME_DIFFER,
+                    ErrorManager.Error( ErrorManager.MSG_FILE_AND_GRAMMAR_NAME_DIFFER,
name,
fileName );
}
@@ -951,19 +954,19 @@ namespace Antlr3.Tool
this.name = name;
}

-        public virtual void setGrammarContent( string grammarString )
+        public virtual void SetGrammarContent( string grammarString )
{
StringReader r = new StringReader( grammarString );
-            parseAndBuildAST( r );
-            composite.assignTokenTypes();
-            composite.defineGrammarSymbols();
+            ParseAndBuildAST( r );
+            composite.AssignTokenTypes();
+            composite.DefineGrammarSymbols();
}

-        public virtual void parseAndBuildAST()
+        public virtual void ParseAndBuildAST()
{
using ( System.IO.TextReader reader = System.IO.File.OpenText( fileName ) )
{
-                parseAndBuildAST( reader );
+                ParseAndBuildAST( reader );
}
}

@@ -1008,7 +1011,7 @@ namespace Antlr3.Tool
#endregion
}

-        public virtual void parseAndBuildAST( TextReader r )
+        public virtual void ParseAndBuildAST( TextReader r )
{
// BUILD AST FROM GRAMMAR
ANTLRLexer lexer = new ANTLRLexer( new Antlr.Runtime.ANTLRReaderStream( r ) );
@@ -1037,23 +1040,23 @@ namespace Antlr3.Tool
//}
catch ( RecognitionException re )
{
-                ErrorManager.internalError( "unexpected parser recognition error from " + fileName, re );
+                ErrorManager.InternalError( "unexpected parser recognition error from " + fileName, re );
}

-            dealWithTreeFilterMode(); // tree grammar and filter=true?
+            DealWithTreeFilterMode(); // tree grammar and filter=true?

if ( lexer.hasASTOperator && !BuildAST )
{
-                object value = getOption( "output" );
+                object value = GetOption( "output" );
if ( value == null )
{
-                    ErrorManager.grammarWarning( ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
+                    ErrorManager.GrammarWarning( ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
this, null );
-                    setOption( "output", "AST", null );
+                    SetOption( "output", "AST", null );
}
else
{
-                    ErrorManager.grammarError( ErrorManager.MSG_AST_OP_WITH_NON_AST_OUTPUT_OPTION,
+                    ErrorManager.GrammarError( ErrorManager.MSG_AST_OP_WITH_NON_AST_OUTPUT_OPTION,
this, null, value );
}
}
@@ -1061,15 +1064,15 @@ namespace Antlr3.Tool
//grammarTree = (GrammarAST)parser.getAST();
grammarTree = (GrammarAST)result.tree;
FileName = lexer.Filename; // the lexer #src might change name
-            if ( grammarTree == null || grammarTree.findFirstType( ANTLRParser.RULE ) == null )
+            if ( grammarTree == null || grammarTree.FindFirstType( ANTLRParser.RULE ) == null )
{
-                ErrorManager.error( ErrorManager.MSG_NO_RULES, FileName );
+                ErrorManager.Error( ErrorManager.MSG_NO_RULES, FileName );
return;
}

// Get syn pred rules and add to existing tree
IList<GrammarAST> synpredRules =
-                getArtificialRulesForSyntacticPredicates( parser,
+                GetArtificialRulesForSyntacticPredicates( parser,
nameToSynpredASTMap );
for ( int i = 0; i < synpredRules.Count; i++ )
{
@@ -1078,9 +1081,9 @@ namespace Antlr3.Tool
}
}

-        protected virtual void dealWithTreeFilterMode()
+        protected virtual void DealWithTreeFilterMode()
{
-            object filterMode = (string)getOption( "filter" );
+            object filterMode = (string)GetOption( "filter" );
if ( type == TREE_PARSER && filterMode != null && filterMode.ToString().Equals( "true" ) )
{
// check for conflicting options
@@ -1088,37 +1091,37 @@ namespace Antlr3.Tool
// filter&&output=AST => rewrite=true
// filter&&output!=AST => error
// any deviation from valid option set is an error
-                object backtrack = (string)getOption( "backtrack" );
-                object output = getOption( "output" );
-                object rewrite = getOption( "rewrite" );
+                object backtrack = (string)GetOption( "backtrack" );
+                object output = GetOption( "output" );
+                object rewrite = GetOption( "rewrite" );
if ( backtrack != null && !backtrack.ToString().Equals( "true" ) )
{
-                    ErrorManager.error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
+                    ErrorManager.Error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
"backtrack", backtrack );
}
if ( output != null && !output.ToString().Equals( "AST" ) )
{
-                    ErrorManager.error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
+                    ErrorManager.Error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
"output", output );
-                    setOption( "output", "", null );
+                    SetOption( "output", "", null );
}
if ( rewrite != null && !rewrite.ToString().Equals( "true" ) )
{
-                    ErrorManager.error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
+                    ErrorManager.Error( ErrorManager.MSG_CONFLICTING_OPTION_IN_TREE_FILTER,
"rewrite", rewrite );
}
// set options properly
-                setOption( "backtrack", "true", null );
+                SetOption( "backtrack", "true", null );
if ( output != null && output.ToString().Equals( "AST" ) )
{
-                    setOption( "rewrite", "true", null );
+                    SetOption( "rewrite", "true", null );
}
// @synpredgate set to state.backtracking==1 by code gen when filter=true
// superClass set in template target::treeParser
}
}

-        public virtual void defineGrammarSymbols()
+        public virtual void DefineGrammarSymbols()
{
if ( Tool.internalOption_PrintGrammarTree )
{
@@ -1135,22 +1138,22 @@ namespace Antlr3.Tool
}
catch ( RecognitionException re )
{
-                ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                ErrorManager.Error( ErrorManager.MSG_BAD_AST_STRUCTURE,
re );
}
}

/** ANALYZE ACTIONS, LOOKING FOR LABEL AND ATTR REFS, sanity check */
-        public virtual void checkNameSpaceAndActions()
+        public virtual void CheckNameSpaceAndActions()
{
-            examineAllExecutableActions();
-            checkAllRulesForUselessLabels();
+            ExamineAllExecutableActions();
+            CheckAllRulesForUselessLabels();

-            nameSpaceChecker.checkConflicts();
+            nameSpaceChecker.CheckConflicts();
}

/** Many imports are illegal such as lexer into a tree grammar */
-        public virtual bool validImport( Grammar @delegate )
+        public virtual bool ValidImport( Grammar @delegate )
{
IList<int> validDelegators = validDelegations.get( @delegate.type );
return validDelegators != null && validDelegators.Contains( this.type );
@@ -1159,7 +1162,7 @@ namespace Antlr3.Tool
/** If the grammar is a combined grammar, return the text of the implicit
*  lexer grammar.
*/
-        public virtual string getLexerGrammar()
+        public virtual string GetLexerGrammar()
{
if ( LexerGrammarST.GetAttribute( "literals" ) == null &&
LexerGrammarST.GetAttribute( "rules" ) == null )
@@ -1192,21 +1195,15 @@ namespace Antlr3.Tool
return LexerGrammarST.ToString();
}

-        [System.Obsolete]
-        public string getImplicitlyGeneratedLexerFileName()
-        {
-            return ImplicitlyGeneratedLexerFileName;
-        }
-
/** Get the name of the generated recognizer; may or may not be same
*  as grammar name.
*  Recognizer is TParser and TLexer from T if combined, else
*  just use T regardless of grammar type.
*/
-        public virtual string getRecognizerName()
+        public virtual string GetRecognizerName()
{
string suffix = "";
-            IList<Grammar> grammarsFromRootToMe = composite.getDelegators( this );
+            IList<Grammar> grammarsFromRootToMe = composite.GetDelegators( this );
//JSystem.@out.println("grammarsFromRootToMe="+grammarsFromRootToMe);
string qualifiedName = name;
if ( grammarsFromRootToMe != null )
@@ -1243,7 +1240,7 @@ namespace Antlr3.Tool
*  and builds a string representing the rule; then it creates a parser
*  and adds the resulting tree to the grammar's tree.
*/
-        public GrammarAST addArtificialMatchTokensRule( GrammarAST grammarAST,
+        public GrammarAST AddArtificialMatchTokensRule( GrammarAST grammarAST,
IList<string> ruleNames,
IList<string> delegateNames,
bool filterMode )
@@ -1309,7 +1306,7 @@ namespace Antlr3.Tool
}
catch ( Exception e )
{
-                ErrorManager.error( ErrorManager.MSG_ERROR_CREATING_ARTIFICIAL_RULE,
+                ErrorManager.Error( ErrorManager.MSG_ERROR_CREATING_ARTIFICIAL_RULE,
e );
}
return (GrammarAST)result.Tree;
@@ -1318,7 +1315,7 @@ namespace Antlr3.Tool
/** for any syntactic predicates, we need to define rules for them; they will get
*  defined automatically like any other rule. :)
*/
-        protected virtual IList<GrammarAST> getArtificialRulesForSyntacticPredicates( ANTLRParser parser,
+        protected virtual IList<GrammarAST> GetArtificialRulesForSyntacticPredicates( ANTLRParser parser,
IDictionary<string, GrammarAST> nameToSynpredASTMap )
{
IList<GrammarAST> rules = new List<GrammarAST>();
@@ -1332,7 +1329,7 @@ namespace Antlr3.Tool
string synpredName = synpred.Key;
GrammarAST fragmentAST = (GrammarAST)synpred.Value;
GrammarAST ruleAST =
-                    parser.createSimpleRuleAST( synpredName,
+                    parser.CreateSimpleRuleAST( synpredName,
fragmentAST,
isLexer );
rules.Add( ruleAST );
@@ -1344,7 +1341,7 @@ namespace Antlr3.Tool
/** Walk the list of options, altering this Grammar object according
*  to any I recognize.
*/
-        protected virtual void processOptions()
+        protected virtual void ProcessOptions()
{
foreach ( var option in options )
{
@@ -1366,7 +1363,7 @@ namespace Antlr3.Tool
*  just call buildNFA(), which forces a call to this method if not
*  done already. Works ONLY for single noncomposite grammars.
*/
-        public virtual void createRuleStartAndStopNFAStates()
+        public virtual void CreateRuleStartAndStopNFAStates()
{
//JSystem.@out.println("### createRuleStartAndStopNFAStates "+getGrammarTypeString()+" grammar "+name+" NFAs");
if ( nfa != null )
@@ -1379,11 +1376,11 @@ namespace Antlr3.Tool
foreach ( Rule r in Rules )
{
string ruleName = r.name;
-                NFAState ruleBeginState = factory.newState();
+                NFAState ruleBeginState = factory.NewState();
ruleBeginState.Description = "rule " + ruleName + " start";
ruleBeginState.enclosingRule = r;
r.startState = ruleBeginState;
-                NFAState ruleEndState = factory.newState();
+                NFAState ruleEndState = factory.NewState();
ruleEndState.Description = "rule " + ruleName + " end";
ruleEndState.IsAcceptState = true;
ruleEndState.enclosingRule = r;
@@ -1391,11 +1388,11 @@ namespace Antlr3.Tool
}
}

-        public virtual void buildNFA()
+        public virtual void BuildNFA()
{
if ( nfa == null )
{
-                createRuleStartAndStopNFAStates();
+                CreateRuleStartAndStopNFAStates();
}
if ( nfa.complete )
{
@@ -1416,7 +1413,7 @@ namespace Antlr3.Tool
}
catch ( RecognitionException re )
{
-                ErrorManager.error( ErrorManager.MSG_BAD_AST_STRUCTURE,
+                ErrorManager.Error( ErrorManager.MSG_BAD_AST_STRUCTURE,
name,
re );
}
@@ -1434,20 +1431,20 @@ namespace Antlr3.Tool
*  This is a separate method because you might want to create a
*  Grammar without doing the expensive analysis.
*/
-        public virtual void createLookaheadDFAs()
+        public virtual void CreateLookaheadDFAs()
{
-            createLookaheadDFAs( true );
+            CreateLookaheadDFAs( true );
}

-        public virtual void createLookaheadDFAs( bool wackTempStructures )
+        public virtual void CreateLookaheadDFAs( bool wackTempStructures )
{
if ( nfa == null )
{
-                buildNFA();
+                BuildNFA();
}

// CHECK FOR LEFT RECURSION; Make sure we can actually do analysis
-            checkAllRulesForLeftRecursion();
+            CheckAllRulesForLeftRecursion();

/*
// was there a severe problem while sniffing the grammar?
@@ -1464,7 +1461,7 @@ namespace Antlr3.Tool
{
for ( int decision = 1; decision <= numDecisions; decision++ )
{
-                    NFAState decisionStartState = getDecisionNFAStartState( decision );
+                    NFAState decisionStartState = GetDecisionNFAStartState( decision );
if ( leftRecursiveRules.Contains( decisionStartState.enclosingRule ) )
{
// don't bother to process decisions within left recursive rules.
@@ -1484,10 +1481,10 @@ namespace Antlr3.Tool
}
DFA dfa = null;
// if k=* or k=1, try LL(1)
-                        if ( getUserMaxLookahead( decision ) == 0 ||
-                             getUserMaxLookahead( decision ) == 1 )
+                        if ( GetUserMaxLookahead( decision ) == 0 ||
+                             GetUserMaxLookahead( decision ) == 1 )
{
-                            dfa = createLL_1_LookaheadDFA( decision );
+                            dfa = CreateLL_1_LookaheadDFA( decision );
}
if ( dfa == null )
{
@@ -1496,18 +1493,18 @@ namespace Antlr3.Tool
Console.Out.WriteLine( "decision " + decision +
" not suitable for LL(1)-optimized DFA analysis" );
}
-                            dfa = createLookaheadDFA( decision, wackTempStructures );
+                            dfa = CreateLookaheadDFA( decision, wackTempStructures );
}
if ( dfa.startState == null )
{
// something went wrong; wipe out DFA
-                            setLookaheadDFA( decision, null );
+                            SetLookaheadDFA( decision, null );
}
if ( Tool.internalOption_PrintDFA )
{
Console.Out.WriteLine( "DFA d=" + decision );
FASerializer serializer = new FASerializer( nfa.grammar );
-                            string result = serializer.serialize( dfa.startState );
+                            string result = serializer.Serialize( dfa.startState );
Console.Out.WriteLine( result );
}
}
@@ -1515,7 +1512,7 @@ namespace Antlr3.Tool
}
else
{
-                ErrorManager.info( "two-threaded DFA conversion" );
+                ErrorManager.Info( "two-threaded DFA conversion" );
// create a barrier expecting n DFA and this main creation thread
Barrier barrier = new Barrier( 3 );
// assume 2 CPU for now
@@ -1554,12 +1551,12 @@ namespace Antlr3.Tool
allDecisionDFACreated = true;
}

-        public virtual DFA createLL_1_LookaheadDFA( int decision )
+        public virtual DFA CreateLL_1_LookaheadDFA( int decision )
{
-            Decision d = getDecision( decision );
+            Decision d = GetDecision( decision );
string enclosingRule = d.startState.enclosingRule.name;
Rule r = d.startState.enclosingRule;
-            NFAState decisionStartState = getDecisionNFAStartState( decision );
+            NFAState decisionStartState = GetDecisionNFAStartState( decision );

if ( composite.watchNFAConversion )
{
@@ -1574,13 +1571,13 @@ namespace Antlr3.Tool
}

// compute lookahead for each alt
-            int numAlts = getNumberOfAltsForDecisionNFA( decisionStartState );
+            int numAlts = GetNumberOfAltsForDecisionNFA( decisionStartState );
LookaheadSet[] altLook = new LookaheadSet[numAlts + 1];
for ( int alt = 1; alt <= numAlts; alt++ )
{
int walkAlt =
decisionStartState.TranslateDisplayAltToWalkAlt( alt );
-                NFAState altLeftEdge = getNFAStateForAltOfDecision( decisionStartState, walkAlt );
+                NFAState altLeftEdge = GetNFAStateForAltOfDecision( decisionStartState, walkAlt );
NFAState altStartState = (NFAState)altLeftEdge.transition[0].target;
//JSystem.@out.println("alt "+alt+" start state = "+altStartState.stateNumber);
altLook[alt] = ll1Analyzer.Look( altStartState );
@@ -1619,8 +1616,8 @@ namespace Antlr3.Tool
Console.Out.WriteLine( "decision " + decision + " is simple LL(1)" );
}
DFA lookaheadDFA2 = new LL1DFA( decision, decisionStartState, altLook );
-                setLookaheadDFA( decision, lookaheadDFA2 );
-                updateLineColumnToLookaheadDFAMap( lookaheadDFA2 );
+                SetLookaheadDFA( decision, lookaheadDFA2 );
+                UpdateLineColumnToLookaheadDFAMap( lookaheadDFA2 );
return lookaheadDFA2;
}

@@ -1637,8 +1634,8 @@ namespace Antlr3.Tool

// exit if not forced k=1 or we found a predicate situation we
// can't handle: predicates in rules invoked from this decision.
-            if ( getUserMaxLookahead( decision ) != 1 || // not manually set to k=1
-                 !getAutoBacktrackMode( decision ) ||
+            if ( GetUserMaxLookahead( decision ) != 1 || // not manually set to k=1
+                 !GetAutoBacktrackMode( decision ) ||
foundConfoundingPredicate )
{
//JSystem.@out.println("trying LL(*)");
@@ -1651,7 +1648,7 @@ namespace Antlr3.Tool
LookaheadSet s = altLook[i];
edges.Add( (IntervalSet)s.tokenTypeSet );
}
-            IList<IIntSet> disjoint = makeEdgeSetsDisjoint( edges );
+            IList<IIntSet> disjoint = MakeEdgeSetsDisjoint( edges );
//JSystem.@out.println("disjoint="+disjoint);

MultiMap<IntervalSet, int> edgeMap = new MultiMap<IntervalSet, int>();
@@ -1673,23 +1670,23 @@ namespace Antlr3.Tool

// build an LL(1) optimized DFA with edge for each altLook[i]
DFA lookaheadDFA = new LL1DFA( decision, decisionStartState, edgeMap );
-            setLookaheadDFA( decision, lookaheadDFA );
+            SetLookaheadDFA( decision, lookaheadDFA );

// create map from line:col to decision DFA (for ANTLRWorks)
-            updateLineColumnToLookaheadDFAMap( lookaheadDFA );
+            UpdateLineColumnToLookaheadDFAMap( lookaheadDFA );

return lookaheadDFA;
}

-        private void updateLineColumnToLookaheadDFAMap( DFA lookaheadDFA )
+        private void UpdateLineColumnToLookaheadDFAMap( DFA lookaheadDFA )
{
-            GrammarAST decisionAST = nfa.grammar.getDecisionBlockAST( lookaheadDFA.decisionNumber );
+            GrammarAST decisionAST = nfa.grammar.GetDecisionBlockAST( lookaheadDFA.decisionNumber );
int line = decisionAST.Line;
int col = decisionAST.CharPositionInLine;
lineColumnToLookaheadDFAMap[line + ":" + col] = lookaheadDFA;
}

-        protected virtual IList<IIntSet> makeEdgeSetsDisjoint( IList<IIntSet> edges )
+        protected virtual IList<IIntSet> MakeEdgeSetsDisjoint( IList<IIntSet> edges )
{
OrderedHashSet<IIntSet> disjointSets = new OrderedHashSet<IIntSet>();
// walk each incoming edge label/set and add to disjoint set
@@ -1750,14 +1747,14 @@ namespace Antlr3.Tool
return disjointSets.GetElements();
}

-        public virtual DFA createLookaheadDFA( int decision, bool wackTempStructures )
+        public virtual DFA CreateLookaheadDFA( int decision, bool wackTempStructures )
{
-            Decision d = getDecision( decision );
+            Decision d = GetDecision( decision );
string enclosingRule = d.startState.enclosingRule.name;
Rule r = d.startState.enclosingRule;

//JSystem.@out.println("createLookaheadDFA(): "+enclosingRule+" dec "+decision+"; synprednames prev used "+synPredNamesUsedInDFA);
-            NFAState decisionStartState = getDecisionNFAStartState( decision );
+            NFAState decisionStartState = GetDecisionNFAStartState( decision );
DateTime startDFA = DateTime.MinValue;
DateTime stopDFA = DateTime.MinValue;
if ( composite.watchNFAConversion )
@@ -1781,7 +1778,7 @@ namespace Antlr3.Tool
// First, clean up tracking stuff
decisionsWhoseDFAsUsesSynPreds.Remove( lookaheadDFA );
// TODO: clean up synPredNamesUsedInDFA also (harder)
-                d.blockAST.setBlockOption( this, "k", 1 );
+                d.blockAST.SetBlockOption( this, "k", 1 );
if ( composite.watchNFAConversion )
{
Console.Out.Write( "trying decision " + decision +
@@ -1793,13 +1790,13 @@ namespace Antlr3.Tool
}
if ( lookaheadDFA.AnalysisTimedOut )
{ // did analysis bug out?
-                ErrorManager.internalError( "could not even do k=1 for decision " +
+                ErrorManager.InternalError( "could not even do k=1 for decision " +
decision + "; reason: " +
lookaheadDFA.ReasonForFailure );
}


-            setLookaheadDFA( decision, lookaheadDFA );
+            SetLookaheadDFA( decision, lookaheadDFA );

if ( wackTempStructures )
{
@@ -1810,7 +1807,7 @@ namespace Antlr3.Tool
}

// create map from line:col to decision DFA (for ANTLRWorks)
-            updateLineColumnToLookaheadDFAMap( lookaheadDFA );
+            UpdateLineColumnToLookaheadDFAMap( lookaheadDFA );

if ( composite.watchNFAConversion )
{
@@ -1824,7 +1821,7 @@ namespace Antlr3.Tool

/** Terminate DFA creation (grammar analysis).
*/
-        public virtual void externallyAbortNFAToDFAConversion()
+        public virtual void ExternallyAbortNFAToDFAConversion()
{
externalAnalysisAbort = true;
}
@@ -1835,7 +1832,7 @@ namespace Antlr3.Tool
}

/** Return a new unique integer in the token type space */
-        public virtual int getNewTokenType()
+        public virtual int GetNewTokenType()
{
composite.maxTokenType++;
return composite.maxTokenType;
@@ -1845,7 +1842,7 @@ namespace Antlr3.Tool
*  old value with a new one.  This is called normal grammar processsing
*  and during import vocab operations to set tokens with specific values.
*/
-        public virtual void defineToken( string text, int tokenType )
+        public virtual void DefineToken( string text, int tokenType )
{
//JSystem.@out.println("defineToken("+text+", "+tokenType+")");
if ( composite.tokenIDToTypeMap.ContainsKey( text ) && composite.tokenIDToTypeMap[text] < TokenConstants.MinTokenType )
@@ -1888,7 +1885,7 @@ namespace Antlr3.Tool
/** Define a new rule.  A new rule index is created by incrementing
*  ruleIndex.
*/
-        public virtual void defineRule( IToken ruleToken,
+        public virtual void DefineRule( IToken ruleToken,
string modifier,
IDictionary<string,object> options,
GrammarAST tree,
@@ -1896,9 +1893,9 @@ namespace Antlr3.Tool
int numAlts )
{
string ruleName = ruleToken.Text;
-            if ( getLocallyDefinedRule( ruleName ) != null )
+            if ( GetLocallyDefinedRule( ruleName ) != null )
{
-                ErrorManager.grammarError( ErrorManager.MSG_RULE_REDEFINITION,
+                ErrorManager.GrammarError( ErrorManager.MSG_RULE_REDEFINITION,
this, ruleToken, ruleName );
return;
}
@@ -1906,7 +1903,7 @@ namespace Antlr3.Tool
if ( ( type == Grammar.PARSER || type == Grammar.TREE_PARSER ) &&
char.IsUpper( ruleName[0] ) )
{
-                ErrorManager.grammarError( ErrorManager.MSG_LEXER_RULES_NOT_ALLOWED,
+                ErrorManager.GrammarError( ErrorManager.MSG_LEXER_RULES_NOT_ALLOWED,
this, ruleToken, ruleName );
return;
}
@@ -1918,8 +1915,8 @@ namespace Antlr3.Tool
*/
r.modifier = modifier ?? DefaultRuleModifier;
nameToRuleMap[ruleName] = r;
-            setRuleAST( ruleName, tree );
-            r.setOptions( options, ruleToken );
+            SetRuleAST( ruleName, tree );
+            r.SetOptions( options, ruleToken );
r.argActionAST = argActionAST;
composite.ruleIndexToRuleList.setSize( composite.ruleIndex + 1 );
composite.ruleIndexToRuleList[composite.ruleIndex] = r;
@@ -1933,7 +1930,7 @@ namespace Antlr3.Tool
/** Define a new predicate and get back its name for use in building
*  a semantic predicate reference to the syn pred.
*/
-        public virtual string defineSyntacticPredicate( GrammarAST blockAST,
+        public virtual string DefineSyntacticPredicate( GrammarAST blockAST,
string currentRuleName )
{
if ( nameToSynpredASTMap == null )
@@ -1942,18 +1939,12 @@ namespace Antlr3.Tool
}
string predName =
SYNPRED_RULE_PREFIX + ( nameToSynpredASTMap.Count + 1 ) + "_" + name;
-            blockAST.setTreeEnclosingRuleNameDeeply( predName );
+            blockAST.SetTreeEnclosingRuleNameDeeply( predName );
nameToSynpredASTMap[predName] = blockAST;
return predName;
}

-        [System.Obsolete]
-        public IDictionary<string, GrammarAST> getSyntacticPredicates()
-        {
-            return SyntacticPredicates;
-        }
-
-        public virtual GrammarAST getSyntacticPredicate( string name )
+        public virtual GrammarAST GetSyntacticPredicate( string name )
{
if ( nameToSynpredASTMap == null )
{
@@ -1967,31 +1958,24 @@ namespace Antlr3.Tool
return null;
}

-        public virtual void synPredUsedInDFA( DFA dfa, SemanticContext semCtx )
+        public virtual void SynPredUsedInDFA( DFA dfa, SemanticContext semCtx )
{
decisionsWhoseDFAsUsesSynPreds.Add( dfa );
semCtx.TrackUseOfSyntacticPredicates( this ); // walk ctx looking for preds
}

-#if false
-        public HashSet<Rule> getRuleNamesVisitedDuringLOOK()
-        {
-            return rulesSensitiveToOtherRules;
-        }
-#endif
-
/** Given @scope::name {action} define it for this grammar.  Later,
*  the code generator will ask for the actions table.  For composite
*  grammars, make sure header action propogates down to all delegates.
*/
-        public virtual void defineNamedAction( GrammarAST ampersandAST,
+        public virtual void DefineNamedAction( GrammarAST ampersandAST,
string scope,
GrammarAST nameAST,
GrammarAST actionAST )
{
if ( scope == null )
{
-                scope = getDefaultActionScope( type );
+                scope = GetDefaultActionScope( type );
}
//JSystem.@out.println("@"+scope+"::"+nameAST.getText()+"{"+actionAST.getText()+"}");
string actionName = nameAST.Text;
@@ -2004,7 +1988,7 @@ namespace Antlr3.Tool
GrammarAST a = (GrammarAST)scopeActions.get( actionName );
if ( a != null )
{
-                ErrorManager.grammarError(
+                ErrorManager.GrammarError(
ErrorManager.MSG_ACTION_REDEFINITION, this,
nameAST.Token, nameAST.Text );
}
@@ -2015,23 +1999,17 @@ namespace Antlr3.Tool
// propogate header (regardless of scope (lexer, parser, ...) ?
if ( this == composite.RootGrammar && actionName.Equals( "header" ) )
{
-                IList<Grammar> allgrammars = composite.RootGrammar.getDelegates();
+                IList<Grammar> allgrammars = composite.RootGrammar.GetDelegates();
foreach ( Grammar g in allgrammars )
{
-                    g.defineNamedAction( ampersandAST, scope, nameAST, actionAST );
+                    g.DefineNamedAction( ampersandAST, scope, nameAST, actionAST );
}
}
}

-        [System.Obsolete]
-        public IDictionary<string, IDictionary<string, object>> getActions()
+        public virtual void SetSynPredGateIfNotAlready( StringTemplate gateST )
{
-            return Actions;
-        }
-
-        public virtual void setSynPredGateIfNotAlready( StringTemplate gateST )
-        {
-            string scope = getDefaultActionScope( type );
+            string scope = GetDefaultActionScope( type );
var actionsForGrammarScope = actions.get( scope );
// if no synpredgate action set by user then set
if ( actionsForGrammarScope == null || !actionsForGrammarScope.ContainsKey( Grammar.SYNPREDGATE_ACTION_NAME ) )
@@ -2049,7 +2027,7 @@ namespace Antlr3.Tool
*  If I say @members in a COMBINED grammar, for example, the
*  default scope should be "parser".
*/
-        public virtual string getDefaultActionScope( int grammarType )
+        public virtual string GetDefaultActionScope( int grammarType )
{
switch ( grammarType )
{
@@ -2064,7 +2042,7 @@ namespace Antlr3.Tool
return null;
}

-        public virtual void defineLexerRuleFoundInParser( IToken ruleToken,
+        public virtual void DefineLexerRuleFoundInParser( IToken ruleToken,
GrammarAST ruleAST )
{
//JSystem.@out.println("rule tree is:\n"+ruleAST.toStringTree());
@@ -2129,7 +2107,7 @@ namespace Antlr3.Tool
/** If someone does PLUS='+' in the parser, must make sure we get
*  "PLUS : '+' ;" in lexer not "T73 : '+';"
*/
-        public virtual void defineLexerRuleForAliasedStringLiteral( string tokenID,
+        public virtual void DefineLexerRuleForAliasedStringLiteral( string tokenID,
string literal,
int tokenType )
{
@@ -2145,12 +2123,12 @@ namespace Antlr3.Tool
composite.lexerRules.Add( tokenID );
}

-        public virtual void defineLexerRuleForStringLiteral( string literal, int tokenType )
+        public virtual void DefineLexerRuleForStringLiteral( string literal, int tokenType )
{
//JSystem.@out.println("defineLexerRuleForStringLiteral: "+literal+" "+tokenType);
// compute new token name like T237 and define it as having tokenType
-            string tokenID = computeTokenNameFromLiteral( tokenType, literal );
-            defineToken( tokenID, tokenType );
+            string tokenID = ComputeTokenNameFromLiteral( tokenType, literal );
+            DefineToken( tokenID, tokenType );
// tell implicit lexer to define a rule to match the literal
if ( IsRoot )
{ // don't build lexers for delegates
@@ -2161,7 +2139,7 @@ namespace Antlr3.Tool
}
}

-        public virtual Rule getLocallyDefinedRule( string ruleName )
+        public virtual Rule GetLocallyDefinedRule( string ruleName )
{
Rule r;
if ( nameToRuleMap.TryGetValue( ruleName ?? string.Empty, out r ) )
@@ -2170,9 +2148,9 @@ namespace Antlr3.Tool
return null;
}

-        public virtual Rule getRule( string ruleName )
+        public virtual Rule GetRule( string ruleName )
{
-            Rule r = composite.getRule( ruleName );
+            Rule r = composite.GetRule( ruleName );
/*
if ( r!=null && r.grammar != this ) {
JSystem.@out.println(name+".getRule("+ruleName+")="+r);
@@ -2181,23 +2159,23 @@ namespace Antlr3.Tool
return r;
}

-        public virtual Rule getRule( string scopeName, string ruleName )
+        public virtual Rule GetRule( string scopeName, string ruleName )
{
if ( scopeName != null )
{ // scope override
-                Grammar scope = composite.getGrammar( scopeName );
+                Grammar scope = composite.GetGrammar( scopeName );
if ( scope == null )
{
return null;
}
-                return scope.getLocallyDefinedRule( ruleName );
+                return scope.GetLocallyDefinedRule( ruleName );
}
-            return getRule( ruleName );
+            return GetRule( ruleName );
}

-        public virtual int getRuleIndex( string scopeName, string ruleName )
+        public virtual int GetRuleIndex( string scopeName, string ruleName )
{
-            Rule r = getRule( scopeName, ruleName );
+            Rule r = GetRule( scopeName, ruleName );
if ( r != null )
{
return r.index;
@@ -2205,12 +2183,12 @@ namespace Antlr3.Tool
return INVALID_RULE_INDEX;
}

-        public virtual int getRuleIndex( string ruleName )
+        public virtual int GetRuleIndex( string ruleName )
{
-            return getRuleIndex( null, ruleName );
+            return GetRuleIndex( null, ruleName );
}

-        public virtual string getRuleName( int ruleIndex )
+        public virtual string GetRuleName( int ruleIndex )
{
Rule r = composite.ruleIndexToRuleList[ruleIndex];
if ( r != null )
@@ -2225,7 +2203,7 @@ namespace Antlr3.Tool
*  If regular rule, only gen if not overridden in delegator
*  Always gen Tokens rule though.
*/
-        public virtual bool generateMethodForRule( string ruleName )
+        public virtual bool GenerateMethodForRule( string ruleName )
{
if ( ruleName.Equals( ARTIFICIAL_TOKENS_RULENAME ) )
{
@@ -2239,33 +2217,33 @@ namespace Antlr3.Tool
return false;
}
// generate if non-synpred or synpred used in a DFA
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
return !r.isSynPred ||
( r.isSynPred && synPredNamesUsedInDFA.Contains( ruleName ) );
}

-        public virtual AttributeScope defineGlobalScope( string name, IToken scopeAction )
+        public virtual AttributeScope DefineGlobalScope( string name, IToken scopeAction )
{
AttributeScope scope = new AttributeScope( this, name, scopeAction );
scopes[name] = scope;
return scope;
}

-        public virtual AttributeScope createReturnScope( string ruleName, IToken retAction )
+        public virtual AttributeScope CreateReturnScope( string ruleName, IToken retAction )
{
AttributeScope scope = new AttributeScope( this, ruleName, retAction );
scope.isReturnScope = true;
return scope;
}

-        public virtual AttributeScope createRuleScope( string ruleName, IToken scopeAction )
+        public virtual AttributeScope CreateRuleScope( string ruleName, IToken scopeAction )
{
AttributeScope scope = new AttributeScope( this, ruleName, scopeAction );
scope.isDynamicRuleScope = true;
return scope;
}

-        public virtual AttributeScope createParameterScope( string ruleName, IToken argAction )
+        public virtual AttributeScope CreateParameterScope( string ruleName, IToken argAction )
{
AttributeScope scope = new AttributeScope( this, ruleName, argAction );
scope.isParameterScope = true;
@@ -2273,35 +2251,29 @@ namespace Antlr3.Tool
}

/** Get a global scope */
-        public virtual AttributeScope getGlobalScope( string name )
+        public virtual AttributeScope GetGlobalScope( string name )
{
return (AttributeScope)scopes.get( name );
}

-        [System.Obsolete]
-        public IDictionary<string, AttributeScope> getGlobalScopes()
-        {
-            return GlobalScopes;
-        }
-
/** Define a label defined in a rule r; check the validity then ask the
*  Rule object to actually define it.
*/
-        protected virtual void defineLabel( Rule r, IToken label, GrammarAST element, int type )
+        protected virtual void DefineLabel( Rule r, IToken label, GrammarAST element, int type )
{
-            bool err = nameSpaceChecker.checkForLabelTypeMismatch( r, label, type );
+            bool err = nameSpaceChecker.CheckForLabelTypeMismatch( r, label, type );
if ( err )
{
return;
}
-            r.defineLabel( label, element, type );
+            r.DefineLabel( label, element, type );
}

-        public virtual void defineTokenRefLabel( string ruleName,
+        public virtual void DefineTokenRefLabel( string ruleName,
IToken label,
GrammarAST tokenRef )
{
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
if ( r != null )
{
if ( type == LEXER &&
@@ -2311,69 +2283,69 @@ namespace Antlr3.Tool
tokenRef.Type == ANTLRParser.CHAR_RANGE ||
tokenRef.Type == ANTLRParser.WILDCARD ) )
{
-                    defineLabel( r, label, tokenRef, CHAR_LABEL );
+                    DefineLabel( r, label, tokenRef, CHAR_LABEL );
}
else
{
-                    defineLabel( r, label, tokenRef, TOKEN_LABEL );
+                    DefineLabel( r, label, tokenRef, TOKEN_LABEL );
}
}
}

-        public virtual void defineWildcardTreeLabel( string ruleName,
+        public virtual void DefineWildcardTreeLabel( string ruleName,
IToken label,
GrammarAST tokenRef )
{
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
if ( r != null )
{
-                defineLabel( r, label, tokenRef, WILDCARD_TREE_LABEL );
+                DefineLabel( r, label, tokenRef, WILDCARD_TREE_LABEL );
}
}

-        public virtual void defineWildcardTreeListLabel( string ruleName, IToken label, GrammarAST tokenRef )
+        public virtual void DefineWildcardTreeListLabel( string ruleName, IToken label, GrammarAST tokenRef )
{
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
if ( r != null )
-                defineLabel( r, label, tokenRef, WILDCARD_TREE_LIST_LABEL );
+                DefineLabel( r, label, tokenRef, WILDCARD_TREE_LIST_LABEL );
}

-        public virtual void defineRuleRefLabel( string ruleName,
+        public virtual void DefineRuleRefLabel( string ruleName,
IToken label,
GrammarAST ruleRef )
{
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
if ( r != null )
{
-                defineLabel( r, label, ruleRef, RULE_LABEL );
+                DefineLabel( r, label, ruleRef, RULE_LABEL );
}
}

-        public virtual void defineTokenListLabel( string ruleName,
+        public virtual void DefineTokenListLabel( string ruleName,
IToken label,
GrammarAST element )
{
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
if ( r != null )
{
-                defineLabel( r, label, element, TOKEN_LIST_LABEL );
+                DefineLabel( r, label, element, TOKEN_LIST_LABEL );
}
}

-        public virtual void defineRuleListLabel( string ruleName,
+        public virtual void DefineRuleListLabel( string ruleName,
IToken label,
GrammarAST element )
{
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
if ( r != null )
{
if ( !r.HasMultipleReturnValues )
{
-                    ErrorManager.grammarError(
+                    ErrorManager.GrammarError(
ErrorManager.MSG_LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT, this,
label, label.Text );
}
-                defineLabel( r, label, element, RULE_LIST_LABEL );
+                DefineLabel( r, label, element, RULE_LIST_LABEL );
}
}

@@ -2381,7 +2353,7 @@ namespace Antlr3.Tool
*  label types such as Grammar.TOKEN_LABEL, Grammar.TOKEN_LIST_LABEL, ...
*  Return a displayable token type name computed from the GrammarAST.
*/
-        public virtual HashSet<string> getLabels( HashSet<GrammarAST> rewriteElements, int labelType )
+        public virtual HashSet<string> GetLabels( HashSet<GrammarAST> rewriteElements, int labelType )
{
HashSet<string> labels = new HashSet<string>();
foreach ( GrammarAST el in rewriteElements )
@@ -2389,8 +2361,8 @@ namespace Antlr3.Tool
if ( el.Type == ANTLRParser.LABEL )
{
string labelName = el.Text;
-                    Rule enclosingRule = getLocallyDefinedRule( el.enclosingRuleName );
-                    LabelElementPair pair = enclosingRule.getLabel( labelName );
+                    Rule enclosingRule = GetLocallyDefinedRule( el.enclosingRuleName );
+                    LabelElementPair pair = enclosingRule.GetLabel( labelName );
/*
// if tree grammar and we have a wildcard, only notice it
// when looking for rule labels not token label. x=. should
@@ -2422,7 +2394,7 @@ namespace Antlr3.Tool
*  Rule.referencedPredefinedRuleAttributes.  I need to remove unused
*  rule labels for example.
*/
-        protected virtual void examineAllExecutableActions()
+        protected virtual void ExamineAllExecutableActions()
{
foreach ( Rule r in Rules )
{
@@ -2431,14 +2403,14 @@ namespace Antlr3.Tool
foreach ( GrammarAST actionAST in actions )
{
ActionAnalysisLexer sniffer = new ActionAnalysisLexer( this, r.name, actionAST );
-                    sniffer.analyze();
+                    sniffer.Analyze();
}
// walk any named actions like @init, @after
IEnumerable<GrammarAST> namedActions = r.Actions.Values.Cast<GrammarAST>();
foreach ( GrammarAST actionAST in namedActions )
{
ActionAnalysisLexer sniffer = new ActionAnalysisLexer( this, r.name, actionAST );
-                    sniffer.analyze();
+                    sniffer.Analyze();
}
}
}
@@ -2446,29 +2418,29 @@ namespace Antlr3.Tool
/** Remove all labels on rule refs whose target rules have no return value.
*  Do this for all rules in grammar.
*/
-        public virtual void checkAllRulesForUselessLabels()
+        public virtual void CheckAllRulesForUselessLabels()
{
if ( type == LEXER )
return;

foreach ( string ruleName in nameToRuleMap.Keys )
{
-                Rule r = getRule( ruleName );
-                removeUselessLabels( r.RuleLabels );
-                removeUselessLabels( r.RuleListLabels );
+                Rule r = GetRule( ruleName );
+                RemoveUselessLabels( r.RuleLabels );
+                RemoveUselessLabels( r.RuleListLabels );
}
}

/** A label on a rule is useless if the rule has no return value, no
*  tree or template output, and it is not referenced in an action.
*/
-        protected virtual void removeUselessLabels( IDictionary ruleToElementLabelPairMap )
+        protected virtual void RemoveUselessLabels( IDictionary ruleToElementLabelPairMap )
{
if ( ruleToElementLabelPairMap == null )
return;

var tokill = from pair in ruleToElementLabelPairMap.Values.Cast<LabelElementPair>()
-                         let rule = getRule( pair.elementRef.Text )
+                         let rule = GetRule( pair.elementRef.Text )
where rule != null && !rule.HasReturnValue && !pair.actionReferencesLabel
select pair.label.Text;

@@ -2482,7 +2454,7 @@ namespace Antlr3.Tool
*
*  This data is also used to verify that all rules have been defined.
*/
-        public virtual void altReferencesRule( string enclosingRuleName,
+        public virtual void AltReferencesRule( string enclosingRuleName,
GrammarAST refScopeAST,
GrammarAST refAST,
int outerAltNum )
@@ -2497,12 +2469,12 @@ namespace Antlr3.Tool
scope = refScopeAST.getText();
}
*/
-            Rule r = getRule( enclosingRuleName );
+            Rule r = GetRule( enclosingRuleName );
if ( r == null )
{
return; // no error here; see NameSpaceChecker
}
-            r.trackRuleReferenceInAlt( refAST, outerAltNum );
+            r.TrackRuleReferenceInAlt( refAST, outerAltNum );
IToken refToken = refAST.Token;
if ( !ruleRefs.Contains( refAST ) )
{
@@ -2516,14 +2488,14 @@ namespace Antlr3.Tool
*
*  Rewrite rules force tracking of all tokens.
*/
-        public virtual void altReferencesTokenID( string ruleName, GrammarAST refAST, int outerAltNum )
+        public virtual void AltReferencesTokenID( string ruleName, GrammarAST refAST, int outerAltNum )
{
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
if ( r == null )
{
return;
}
-            r.trackTokenReferenceInAlt( refAST, outerAltNum );
+            r.TrackTokenReferenceInAlt( refAST, outerAltNum );
if ( !tokenIDRefs.Contains( refAST.Token ) )
{
tokenIDRefs.Add( refAST.Token );
@@ -2536,9 +2508,9 @@ namespace Antlr3.Tool
*  etc...  Make the rule have void return value.  Don't track for lexer
*  rules.
*/
-        public virtual void referenceRuleLabelPredefinedAttribute( string ruleName )
+        public virtual void ReferenceRuleLabelPredefinedAttribute( string ruleName )
{
-            Rule r = getRule( ruleName );
+            Rule r = GetRule( ruleName );
if ( r != null && type != LEXER )
{
// indicate that an action ref'd an attr unless it's in a lexer
@@ -2548,35 +2520,35 @@ namespace Antlr3.Tool
}
}

-        public virtual IList checkAllRulesForLeftRecursion()
+        public virtual IList<HashSet<Rule>> CheckAllRulesForLeftRecursion()
{
-            return (IList)sanity.checkAllRulesForLeftRecursion();
+            return sanity.CheckAllRulesForLeftRecursion();
}

/** Return a list of left-recursive rules; no analysis can be done
*  successfully on these.  Useful to skip these rules then and also
*  for ANTLRWorks to highlight them.
*/
-        public virtual HashSet<Rule> getLeftRecursiveRules()
+        public virtual HashSet<Rule> GetLeftRecursiveRules()
{
if ( nfa == null )
{
-                buildNFA();
+                BuildNFA();
}
if ( leftRecursiveRules != null )
{
return leftRecursiveRules;
}
-            sanity.checkAllRulesForLeftRecursion();
+            sanity.CheckAllRulesForLeftRecursion();
return leftRecursiveRules;
}

-        public virtual void checkRuleReference( GrammarAST scopeAST,
+        public virtual void CheckRuleReference( GrammarAST scopeAST,
GrammarAST refAST,
GrammarAST argsAST,
string currentRuleName )
{
-            sanity.checkRuleReference( scopeAST, refAST, argsAST, currentRuleName );
+            sanity.CheckRuleReference( scopeAST, refAST, argsAST, currentRuleName );
}

/** Rules like "a : ;" and "a : {...} ;" should not generate
@@ -2585,7 +2557,7 @@ namespace Antlr3.Tool
*  that can match some input.  W/o that, the rule is unlikey to have
*  any else.
*/
-        public virtual bool isEmptyRule( GrammarAST block )
+        public virtual bool IsEmptyRule( GrammarAST block )
{
foreach ( ITree node in GrammarAST.Descendants(block) )
{
@@ -2606,7 +2578,7 @@ namespace Antlr3.Tool
return false;
}

-        public virtual bool isAtomTokenType( int ttype )
+        public virtual bool IsAtomTokenType( int ttype )
{
return ttype == ANTLRParser.WILDCARD ||
ttype == ANTLRParser.CHAR_LITERAL ||
@@ -2616,7 +2588,7 @@ namespace Antlr3.Tool
( type != LEXER && ttype == ANTLRParser.TOKEN_REF );
}

-        public virtual int getTokenType( string tokenName )
+        public virtual int GetTokenType( string tokenName )
{
int i;
if ( tokenName[0] == '\'' )
@@ -2634,22 +2606,16 @@ namespace Antlr3.Tool
return Label.INVALID;
}

-        [System.Obsolete]
-        public ICollection<string> getTokenIDs()
-        {
-            return TokenIDs;
-        }
-
/** Return an ordered integer list of token types that have no
*  corresponding token ID like INT or KEYWORD_BEGIN; for stuff
*  like 'begin'.
*/
-        public virtual ICollection getTokenTypesWithoutID()
+        public virtual ICollection<int> GetTokenTypesWithoutID()
{
-            IList types = new List<object>();
+            IList<int> types = new List<int>();
for ( int t = Label.MIN_TOKEN_TYPE; t <= MaxTokenType; t++ )
{
-                string name = getTokenDisplayName( t );
+                string name = GetTokenDisplayName( t );
if ( name[0] == '\'' )
{
types.Add( t );
@@ -2661,12 +2627,12 @@ namespace Antlr3.Tool
/** Get a list of all token IDs and literals that have an associated
*  token type.
*/
-        public virtual HashSet<string> getTokenDisplayNames()
+        public virtual HashSet<string> GetTokenDisplayNames()
{
HashSet<string> names = new HashSet<string>();
for ( int t = Label.MIN_TOKEN_TYPE; t <= MaxTokenType; t++ )
{
-                names.Add( getTokenDisplayName( t ) );
+                names.Add( GetTokenDisplayName( t ) );
}
return names;
}
@@ -2678,7 +2644,7 @@ namespace Antlr3.Tool
*  11/26/2005: I changed literals to always be '...' even for strings.
*  This routine still works though.
*/
-        public static int getCharValueFromGrammarCharLiteral( string literal )
+        public static int GetCharValueFromGrammarCharLiteral( string literal )
{
switch ( literal.Length )
{
@@ -2689,7 +2655,7 @@ namespace Antlr3.Tool
// '\x'  (antlr lexer will catch invalid char)
if ( char.IsDigit( literal[2] ) )
{
-                    ErrorManager.error( ErrorManager.MSG_SYNTAX_ERROR,
+                    ErrorManager.Error( ErrorManager.MSG_SYNTAX_ERROR,
"invalid char literal: " + literal );
return -1;
}
@@ -2707,7 +2673,7 @@ namespace Antlr3.Tool
//return Integer.parseInt( unicodeChars, 16 );
return int.Parse( unicodeChars, System.Globalization.NumberStyles.AllowHexSpecifier );
default:
-                ErrorManager.error( ErrorManager.MSG_SYNTAX_ERROR,
+                ErrorManager.Error( ErrorManager.MSG_SYNTAX_ERROR,
"invalid char literal: " + literal );
return -1;
}
@@ -2726,7 +2692,7 @@ namespace Antlr3.Tool
*
*  The NFA construction routine must know the actual char values.
*/
-        public static StringBuilder getUnescapedStringFromGrammarStringLiteral( string literal )
+        public static StringBuilder GetUnescapedStringFromGrammarStringLiteral( string literal )
{
//JSystem.@out.println("escape: ["+literal+"]");
StringBuilder buf = new StringBuilder();
@@ -2751,7 +2717,7 @@ namespace Antlr3.Tool
}
else if ( char.IsDigit( c ) )
{
-                        ErrorManager.error( ErrorManager.MSG_SYNTAX_ERROR,
+                        ErrorManager.Error( ErrorManager.MSG_SYNTAX_ERROR,
"invalid char literal: " + literal );
buf.Append( "\\" + (char)c );
}
@@ -2778,17 +2744,17 @@ namespace Antlr3.Tool
*
*  Returns the max token type found.
*/
-        public virtual int importTokenVocabulary( Grammar importFromGr )
+        public virtual int ImportTokenVocabulary( Grammar importFromGr )
{
var importedTokenIDs = importFromGr.TokenIDs;
foreach ( string tokenID in importedTokenIDs )
{
-                int tokenType = importFromGr.getTokenType( tokenID );
+                int tokenType = importFromGr.GetTokenType( tokenID );
composite.maxTokenType = Math.Max( composite.maxTokenType, tokenType );
if ( tokenType >= Label.MIN_TOKEN_TYPE )
{
//JSystem.@out.println("import token from grammar "+tokenID+"="+tokenType);
-                    defineToken( tokenID, tokenType );
+                    DefineToken( tokenID, tokenType );
}
}
return composite.maxTokenType; // return max found
@@ -2800,7 +2766,7 @@ namespace Antlr3.Tool
*  Do not create NFA here because NFA construction needs to hook up with
*  overridden rules in delegation root grammar.
*/
-        public virtual void importGrammar( GrammarAST grammarNameAST, string label )
+        public virtual void ImportGrammar( GrammarAST grammarNameAST, string label )
{
string grammarName = grammarNameAST.Text;
//JSystem.@out.println("import "+gfile.getName());
@@ -2816,12 +2782,12 @@ namespace Antlr3.Tool
delegateGrammar = new Grammar( tool, gname, composite );
delegateGrammar.label = label;

-                addDelegateGrammar( delegateGrammar );
+                AddDelegateGrammar( delegateGrammar );

-                delegateGrammar.parseAndBuildAST( br );
-                if ( !validImport( delegateGrammar ) )
+                delegateGrammar.ParseAndBuildAST( br );
+                if ( !ValidImport( delegateGrammar ) )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_INVALID_IMPORT,
+                    ErrorManager.GrammarError( ErrorManager.MSG_INVALID_IMPORT,
this,
grammarNameAST.token,
this,
@@ -2832,7 +2798,7 @@ namespace Antlr3.Tool
( delegateGrammar.name.Equals( this.name + grammarTypeToFileNameSuffix[LEXER] ) ||
delegateGrammar.name.Equals( this.name + grammarTypeToFileNameSuffix[PARSER] ) ) )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_IMPORT_NAME_CLASH,
+                    ErrorManager.GrammarError( ErrorManager.MSG_IMPORT_NAME_CLASH,
this,
grammarNameAST.token,
this,
@@ -2856,7 +2822,7 @@ namespace Antlr3.Tool
}
catch ( IOException ioe )
{
-                ErrorManager.error( ErrorManager.MSG_CANNOT_OPEN_FILE,
+                ErrorManager.Error( ErrorManager.MSG_CANNOT_OPEN_FILE,
gname,
ioe );
}
@@ -2870,7 +2836,7 @@ namespace Antlr3.Tool
}
catch ( IOException ioe )
{
-                        ErrorManager.error( ErrorManager.MSG_CANNOT_CLOSE_FILE,
+                        ErrorManager.Error( ErrorManager.MSG_CANNOT_CLOSE_FILE,
gname,
ioe );
}
@@ -2879,21 +2845,21 @@ namespace Antlr3.Tool
}

/** add new delegate to composite tree */
-        protected virtual void addDelegateGrammar( Grammar delegateGrammar )
+        protected virtual void AddDelegateGrammar( Grammar delegateGrammar )
{
-            CompositeGrammarTree t = composite.delegateGrammarTreeRoot.findNode( this );
-            t.addChild( new CompositeGrammarTree( delegateGrammar ) );
+            CompositeGrammarTree t = composite.delegateGrammarTreeRoot.FindNode( this );
+            t.AddChild( new CompositeGrammarTree( delegateGrammar ) );
// make sure new grammar shares this composite
delegateGrammar.composite = this.composite;
}

/** Load a vocab file <vocabName>.tokens and return max token type found. */
-        public virtual int importTokenVocabulary( GrammarAST tokenVocabOptionAST,
+        public virtual int ImportTokenVocabulary( GrammarAST tokenVocabOptionAST,
string vocabName )
{
if ( !IsRoot )
{
-                ErrorManager.grammarWarning( ErrorManager.MSG_TOKEN_VOCAB_IN_DELEGATE,
+                ErrorManager.GrammarWarning( ErrorManager.MSG_TOKEN_VOCAB_IN_DELEGATE,
this,
tokenVocabOptionAST.token,
name );
@@ -2930,7 +2896,7 @@ namespace Antlr3.Tool
}
else
{
-                        ErrorManager.error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
+                        ErrorManager.Error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
lineNum );
while ( tokenizer.nextToken() != StreamTokenizer.TT_EOL )
@@ -2943,7 +2909,7 @@ namespace Antlr3.Tool
token = tokenizer.nextToken();
if ( token != '=' )
{
-                        ErrorManager.error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
+                        ErrorManager.Error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
lineNum );
while ( tokenizer.nextToken() != StreamTokenizer.TT_EOL )
@@ -2956,7 +2922,7 @@ namespace Antlr3.Tool
token = tokenizer.nextToken(); // skip '='
if ( token != StreamTokenizer.TT_NUMBER )
{
-                        ErrorManager.error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
+                        ErrorManager.Error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
lineNum );
while ( tokenizer.nextToken() != StreamTokenizer.TT_EOL )
@@ -2970,11 +2936,11 @@ namespace Antlr3.Tool
token = tokenizer.nextToken();
//JSystem.@out.println("import "+tokenID+"="+tokenType);
composite.maxTokenType = Math.Max( composite.maxTokenType, tokenType );
-                    defineToken( tokenID, tokenType );
+                    DefineToken( tokenID, tokenType );
lineNum++;
if ( token != StreamTokenizer.TT_EOL )
{
-                        ErrorManager.error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
+                        ErrorManager.Error( ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,
vocabName + CodeGenerator.VOCAB_FILE_EXTENSION,
lineNum );
while ( tokenizer.nextToken() != StreamTokenizer.TT_EOL )
@@ -2990,18 +2956,18 @@ namespace Antlr3.Tool
}
catch ( java.io.FileNotFoundException /*fnfe*/ )
{
-                ErrorManager.error( ErrorManager.MSG_CANNOT_FIND_TOKENS_FILE,
+                ErrorManager.Error( ErrorManager.MSG_CANNOT_FIND_TOKENS_FILE,
fullFile );
}
catch ( IOException ioe )
{
-                ErrorManager.error( ErrorManager.MSG_ERROR_READING_TOKENS_FILE,
+                ErrorManager.Error( ErrorManager.MSG_ERROR_READING_TOKENS_FILE,
fullFile,
ioe );
}
catch ( Exception e )
{
-                ErrorManager.error( ErrorManager.MSG_ERROR_READING_TOKENS_FILE,
+                ErrorManager.Error( ErrorManager.MSG_ERROR_READING_TOKENS_FILE,
fullFile,
e );
}
@@ -3012,7 +2978,7 @@ namespace Antlr3.Tool
*  or string literal.  If this is a lexer and the ttype is in the
*  char vocabulary, compute an ANTLR-valid (possibly escaped) char literal.
*/
-        public virtual string getTokenDisplayName( int ttype )
+        public virtual string GetTokenDisplayName( int ttype )
{
string tokenName = null;
int index = 0;
@@ -3020,7 +2986,7 @@ namespace Antlr3.Tool
if ( this.type == LEXER &&
ttype >= Label.MIN_CHAR_VALUE && ttype <= Label.MAX_CHAR_VALUE )
{
-                return getANTLRCharLiteralForChar( ttype );
+                return GetANTLRCharLiteralForChar( ttype );
}
// faux label?
else if ( ttype < 0 )
@@ -3051,25 +3017,13 @@ namespace Antlr3.Tool
return tokenName;
}

-        [System.Obsolete]
-        public ICollection<string> getStringLiterals()
-        {
-            return StringLiterals;
-        }
-
-        [System.Obsolete]
-        public string getGrammarTypeString()
-        {
-            return GrammarTypeString;
-        }
-
-        public virtual int getGrammarMaxLookahead()
+        public virtual int GetGrammarMaxLookahead()
{
if ( global_k >= 0 )
{
return global_k;
}
-            object k = getOption( "k" );
+            object k = GetOption( "k" );
if ( k == null )
{
global_k = 0;
@@ -3093,23 +3047,23 @@ namespace Antlr3.Tool
/** Save the option key/value pair and process it; return the key
*  or null if invalid option.
*/
-        public virtual string setOption( string key, object value, IToken optionsStartToken )
+        public virtual string SetOption( string key, object value, IToken optionsStartToken )
{
-            if ( legalOption( key ) )
+            if ( LegalOption( key ) )
{
-                ErrorManager.grammarError( ErrorManager.MSG_ILLEGAL_OPTION,
+                ErrorManager.GrammarError( ErrorManager.MSG_ILLEGAL_OPTION,
this,
optionsStartToken,
key );
return null;
}
-            if ( !optionIsValid( key, value ) )
+            if ( !OptionIsValid( key, value ) )
{
return null;
}
if ( key == "backtrack" && value.ToString() == "true" )
{
-                composite.getRootGrammar().atLeastOneBacktrackOption = true;
+                composite.GetRootGrammar().atLeastOneBacktrackOption = true;
}
if ( options == null )
{
@@ -3119,7 +3073,7 @@ namespace Antlr3.Tool
return key;
}

-        public virtual bool legalOption( string key )
+        public virtual bool LegalOption( string key )
{
switch ( type )
{
@@ -3134,7 +3088,7 @@ namespace Antlr3.Tool
}
}

-        public virtual void setOptions( IDictionary<string, object> options, IToken optionsStartToken )
+        public virtual void SetOptions( IDictionary<string, object> options, IToken optionsStartToken )
{
if ( options == null )
{
@@ -3145,18 +3099,18 @@ namespace Antlr3.Tool
{
string optionName = option.Key;
object optionValue = option.Value;
-                string stored = setOption( optionName, optionValue, optionsStartToken );
+                string stored = SetOption( optionName, optionValue, optionsStartToken );
if ( stored == null )
options.Remove( optionName );
}
}

-        public virtual object getOption( string key )
+        public virtual object GetOption( string key )
{
-            return composite.getOption( key );
+            return composite.GetOption( key );
}

-        public virtual object getLocallyDefinedOption( string key )
+        public virtual object GetLocallyDefinedOption( string key )
{
object value = null;
if ( options != null )
@@ -3170,9 +3124,9 @@ namespace Antlr3.Tool
return value;
}

-        public virtual object getBlockOption( GrammarAST blockAST, string key )
+        public virtual object GetBlockOption( GrammarAST blockAST, string key )
{
-            string v = (string)blockAST.getBlockOption( key );
+            string v = (string)blockAST.GetBlockOption( key );
if ( v != null )
{
return v;
@@ -3184,11 +3138,11 @@ namespace Antlr3.Tool
return defaultBlockOptions.get( key );
}

-        public virtual int getUserMaxLookahead( int decision )
+        public virtual int GetUserMaxLookahead( int decision )
{
int user_k = 0;
-            GrammarAST blockAST = nfa.grammar.getDecisionBlockAST( decision );
-            object k = blockAST.getBlockOption( "k" );
+            GrammarAST blockAST = nfa.grammar.GetDecisionBlockAST( decision );
+            object k = blockAST.GetBlockOption( "k" );
if ( k == null )
{
user_k = nfa.grammar.MaxLookahead;
@@ -3210,54 +3164,24 @@ namespace Antlr3.Tool
return user_k;
}

-        public virtual bool getAutoBacktrackMode( int decision )
+        public virtual bool GetAutoBacktrackMode( int decision )
{
-            NFAState decisionNFAStartState = getDecisionNFAStartState( decision );
+            NFAState decisionNFAStartState = GetDecisionNFAStartState( decision );
string autoBacktrack =
-                (string)getBlockOption( decisionNFAStartState.associatedASTNode, "backtrack" );
+                (string)GetBlockOption( decisionNFAStartState.associatedASTNode, "backtrack" );

if ( autoBacktrack == null )
{
-                autoBacktrack = (string)nfa.grammar.getOption( "backtrack" );
+                autoBacktrack = (string)nfa.grammar.GetOption( "backtrack" );
}
return autoBacktrack != null && autoBacktrack.Equals( "true" );
}

-        public virtual bool optionIsValid( string key, object value )
+        public virtual bool OptionIsValid( string key, object value )
{
return true;
}

-        [System.Obsolete]
-        public bool buildAST()
-        {
-            return BuildAST;
-        }
-
-        [System.Obsolete]
-        public bool rewriteMode()
-        {
-            return RewriteMode;
-        }
-
-        [System.Obsolete]
-        public bool isBuiltFromString()
-        {
-            return IsBuiltFromString;
-        }
-
-        [System.Obsolete]
-        public virtual bool buildTemplate()
-        {
-            return BuildTemplate;
-        }
-
-        [System.Obsolete]
-        public ICollection<Rule> getRules()
-        {
-            return Rules;
-        }
-
/** Get the set of Rules that need to have manual delegations
*  like "void rule() { importedGrammar.rule(); }"
*
@@ -3273,32 +3197,32 @@ namespace Antlr3.Tool
*
*  delegatedRules = imported - overridden
*/
-        public virtual HashSet<Rule> getDelegatedRules()
+        public virtual HashSet<Rule> GetDelegatedRules()
{
-            return composite.getDelegatedRules( this );
+            return composite.GetDelegatedRules( this );
}

/** Get set of all rules imported from all delegate grammars even if
*  indirectly delegated.
*/
-        public virtual HashSet<Rule> getAllImportedRules()
+        public virtual HashSet<Rule> GetAllImportedRules()
{
-            return composite.getAllImportedRules( this );
+            return composite.GetAllImportedRules( this );
}

/** Get list of all delegates from all grammars directly or indirectly
*  imported into this grammar.
*/
-        public virtual IList<Grammar> getDelegates()
+        public virtual IList<Grammar> GetDelegates()
{
-            return composite.getDelegates( this );
+            return composite.GetDelegates( this );
}

-        public virtual IList<string> getDelegateNames()
+        public virtual IList<string> GetDelegateNames()
{
// compute delegates:{Grammar g | return g.name;}
IList<string> names = new List<string>();
-            IList<Grammar> delegates = composite.getDelegates( this );
+            IList<Grammar> delegates = composite.GetDelegates( this );
if ( delegates != null )
{
foreach ( Grammar g in delegates )
@@ -3309,45 +3233,33 @@ namespace Antlr3.Tool
return names;
}

-        public virtual IList<Grammar> getDirectDelegates()
+        public virtual IList<Grammar> GetDirectDelegates()
{
-            return composite.getDirectDelegates( this );
+            return composite.GetDirectDelegates( this );
}

/** Get delegates below direct delegates */
-        public virtual IList<Grammar> getIndirectDelegates()
+        public virtual IList<Grammar> GetIndirectDelegates()
{
-            return composite.getIndirectDelegates( this );
+            return composite.GetIndirectDelegates( this );
}

/** Get list of all delegators.  This amounts to the grammars on the path
*  to the root of the delegation tree.
*/
-        public virtual IList<Grammar> getDelegators()
+        public virtual IList<Grammar> GetDelegators()
{
-            return composite.getDelegators( this );
+            return composite.GetDelegators( this );
}

-        [System.Obsolete]
-        public Grammar getDelegator()
-        {
-            return Delegator;
-        }
-
-        public virtual HashSet<Rule> getDelegatedRuleReferences()
+        public virtual HashSet<Rule> GetDelegatedRuleReferences()
{
return delegatedRuleReferences;
}

-        [System.Obsolete]
-        public bool getGrammarIsRoot()
-        {
-            return IsRoot;
-        }
-
-        public virtual void setRuleAST( string ruleName, GrammarAST t )
+        public virtual void SetRuleAST( string ruleName, GrammarAST t )
{
-            Rule r = getLocallyDefinedRule( ruleName );
+            Rule r = GetLocallyDefinedRule( ruleName );
if ( r != null )
{
r.tree = t;
@@ -3355,14 +3267,14 @@ namespace Antlr3.Tool
}
}

-        public virtual NFAState getRuleStartState( string ruleName )
+        public virtual NFAState GetRuleStartState( string ruleName )
{
-            return getRuleStartState( null, ruleName );
+            return GetRuleStartState( null, ruleName );
}

-        public virtual NFAState getRuleStartState( string scopeName, string ruleName )
+        public virtual NFAState GetRuleStartState( string scopeName, string ruleName )
{
-            Rule r = getRule( scopeName, ruleName );
+            Rule r = GetRule( scopeName, ruleName );
if ( r != null )
{
//JSystem.@out.println("getRuleStartState("+scopeName+", "+ruleName+")="+r.startState);
@@ -3372,9 +3284,9 @@ namespace Antlr3.Tool
return null;
}

-        public virtual string getRuleModifier( string ruleName )
+        public virtual string GetRuleModifier( string ruleName )
{
-            Rule r = getRule( ruleName );
+            Rule r = GetRule( ruleName );
if ( r != null )
{
return r.modifier;
@@ -3382,9 +3294,9 @@ namespace Antlr3.Tool
return null;
}

-        public virtual NFAState getRuleStopState( string ruleName )
+        public virtual NFAState GetRuleStopState( string ruleName )
{
-            Rule r = getRule( ruleName );
+            Rule r = GetRule( ruleName );
if ( r != null )
{
return r.stopState;
@@ -3392,14 +3304,14 @@ namespace Antlr3.Tool
return null;
}

-        public virtual int assignDecisionNumber( NFAState state )
+        public virtual int AssignDecisionNumber( NFAState state )
{
decisionCount++;
state.DecisionNumber = decisionCount;
return decisionCount;
}

-        protected internal virtual Decision getDecision( int decision )
+        protected internal virtual Decision GetDecision( int decision )
{
int index = decision - 1;
if ( index >= indexToDecision.Count )
@@ -3410,12 +3322,12 @@ namespace Antlr3.Tool
return d;
}

-        protected virtual Decision createDecision( int decision )
+        protected virtual Decision CreateDecision( int decision )
{
int index = decision - 1;
if ( index < indexToDecision.Count )
{
-                return getDecision( decision ); // don't recreate
+                return GetDecision( decision ); // don't recreate
}
Decision d = new Decision();
d.decision = decision;
@@ -3424,9 +3336,9 @@ namespace Antlr3.Tool
return d;
}

-        public virtual IList getDecisionNFAStartStateList()
+        public virtual IList<NFAState> GetDecisionNFAStartStateList()
{
-            IList states = new List<object>( 100 );
+            var states = new List<NFAState>( 100 );
for ( int d = 0; d < indexToDecision.Count; d++ )
{
Decision dec = (Decision)indexToDecision[d];
@@ -3435,9 +3347,9 @@ namespace Antlr3.Tool
return states;
}

-        public virtual NFAState getDecisionNFAStartState( int decision )
+        public virtual NFAState GetDecisionNFAStartState( int decision )
{
-            Decision d = getDecision( decision );
+            Decision d = GetDecision( decision );
if ( d == null )
{
return null;
@@ -3445,9 +3357,9 @@ namespace Antlr3.Tool
return d.startState;
}

-        public virtual DFA getLookaheadDFA( int decision )
+        public virtual DFA GetLookaheadDFA( int decision )
{
-            Decision d = getDecision( decision );
+            Decision d = GetDecision( decision );
if ( d == null )
{
return null;
@@ -3455,9 +3367,9 @@ namespace Antlr3.Tool
return d.dfa;
}

-        public virtual GrammarAST getDecisionBlockAST( int decision )
+        public virtual GrammarAST GetDecisionBlockAST( int decision )
{
-            Decision d = getDecision( decision );
+            Decision d = GetDecision( decision );
if ( d == null )
{
return null;
@@ -3474,10 +3386,10 @@ namespace Antlr3.Tool
*  This is not particularly fast as it walks entire line:col->DFA map
*  looking for a prefix of "line:".
*/
-        public virtual IList getLookaheadDFAColumnsForLineInFile( int line )
+        public virtual IList<int> GetLookaheadDFAColumnsForLineInFile( int line )
{
string prefix = line + ":";
-            IList columns = new List<object>();
+            var columns = new List<int>();
foreach ( string key in lineColumnToLookaheadDFAMap.Keys )
{
if ( key.StartsWith( prefix ) )
@@ -3489,25 +3401,19 @@ namespace Antlr3.Tool
}

/** Useful for ANTLRWorks to map position in file to the DFA for display */
-        public virtual DFA getLookaheadDFAFromPositionInFile( int line, int col )
+        public virtual DFA GetLookaheadDFAFromPositionInFile( int line, int col )
{
return (DFA)lineColumnToLookaheadDFAMap.get( line.ToString() + ":" + col.ToString() );
}

-        [System.Obsolete]
-        public IDictionary<string, DFA> getLineColumnToLookaheadDFAMap()
-        {
-            return LineColumnToLookaheadDFAMap;
-        }
-
#if false
-        public virtual void setDecisionOptions( int decision, IDictionary options )
+        public virtual void SetDecisionOptions( int decision, IDictionary options )
{
Decision d = createDecision( decision );
d.options = options;
}

-        public virtual void setDecisionOption( int decision, string name, object value )
+        public virtual void SetDecisionOption( int decision, string name, object value )
{
Decision d = getDecision( decision );
if ( d != null )
@@ -3520,7 +3426,7 @@ namespace Antlr3.Tool
}
}

-        public virtual IDictionary getDecisionOptions( int decision )
+        public virtual IDictionary GetDecisionOptions( int decision )
{
Decision d = getDecision( decision );
if ( d == null )
@@ -3531,18 +3437,12 @@ namespace Antlr3.Tool
}
#endif

-        [System.Obsolete]
-        public int getNumberOfDecisions()
-        {
-            return NumberOfDecisions;
-        }
-
-        public virtual int getNumberOfCyclicDecisions()
+        public virtual int GetNumberOfCyclicDecisions()
{
int n = 0;
for ( int i = 1; i <= NumberOfDecisions; i++ )
{
-                Decision d = getDecision( i );
+                Decision d = GetDecision( i );
if ( d.dfa != null && d.dfa.IsCyclic )
{
n++;
@@ -3561,57 +3461,27 @@ namespace Antlr3.Tool
*    g.setLookahead(2, dfa2);
*    ...
*/
-        public virtual void setLookaheadDFA( int decision, DFA lookaheadDFA )
+        public virtual void SetLookaheadDFA( int decision, DFA lookaheadDFA )
{
-            Decision d = createDecision( decision );
+            Decision d = CreateDecision( decision );
d.dfa = lookaheadDFA;
GrammarAST ast = d.startState.associatedASTNode;
ast.LookaheadDFA = lookaheadDFA;
}

-        public virtual void setDecisionNFA( int decision, NFAState state )
+        public virtual void SetDecisionNFA( int decision, NFAState state )
{
-            Decision d = createDecision( decision );
+            Decision d = CreateDecision( decision );
d.startState = state;
}

-        public virtual void setDecisionBlockAST( int decision, GrammarAST blockAST )
+        public virtual void SetDecisionBlockAST( int decision, GrammarAST blockAST )
{
//JSystem.@out.println("setDecisionBlockAST("+decision+", "+blockAST.token);
-            Decision d = createDecision( decision );
+            Decision d = CreateDecision( decision );
d.blockAST = blockAST;
}

-        [System.Obsolete]
-        public bool allDecisionDFAHaveBeenCreated()
-        {
-            return AllDecisionDFAHaveBeenCreated;
-        }
-
-        [System.Obsolete]
-        public int getMaxTokenType()
-        {
-            return MaxTokenType;
-        }
-
-        [System.Obsolete]
-        public int getMaxCharValue()
-        {
-            return MaxCharValue;
-        }
-
-        [System.Obsolete]
-        public IIntSet getTokenTypes()
-        {
-            return TokenTypes;
-        }
-
-        [System.Obsolete]
-        public IIntSet getAllCharValues()
-        {
-            return AllCharValues;
-        }
-
/** Return a string representing the escaped char for code c.  E.g., If c
*  has value 0x100, you will get "\u0100".  ASCII gets the usual
*  char (non-hex) representation.  Control characters are spit out
@@ -3621,11 +3491,11 @@ namespace Antlr3.Tool
*  11/26/2005: I changed this to use double quotes, consistent with antlr.g
*  12/09/2005: I changed so everything is single quotes
*/
-        public static string getANTLRCharLiteralForChar( int c )
+        public static string GetANTLRCharLiteralForChar( int c )
{
if ( c < Label.MIN_CHAR_VALUE )
{
-                ErrorManager.internalError( "invalid char value " + c );
+                ErrorManager.InternalError( "invalid char value " + c );
return "'<INVALID>'";
}
if ( c < ANTLRLiteralCharValueEscape.Length && ANTLRLiteralCharValueEscape[c] != null )
@@ -3656,7 +3526,7 @@ namespace Antlr3.Tool
*  For parser and tree grammars, return everything in token space
*  from MIN_TOKEN_TYPE to last valid token type or char value.
*/
-        public virtual IIntSet complement( IIntSet set )
+        public virtual IIntSet Complement( IIntSet set )
{
//JSystem.@out.println("complement "+set.toString(this));
//JSystem.@out.println("vocabulary "+getTokenTypes().toString(this));
@@ -3665,21 +3535,21 @@ namespace Antlr3.Tool
return c;
}

-        public virtual IIntSet complement( int atom )
+        public virtual IIntSet Complement( int atom )
{
-            return complement( IntervalSet.Of( atom ) );
+            return Complement( IntervalSet.Of( atom ) );
}

/** Given set tree like ( SET A B ), check that A and B
*  are both valid sets themselves, else we must tree like a BLOCK
*/
-        public virtual bool isValidSet( TreeToNFAConverter nfabuilder, GrammarAST t )
+        public virtual bool IsValidSet( TreeToNFAConverter nfabuilder, GrammarAST t )
{
bool valid = true;
try
{
//JSystem.@out.println("parse BLOCK as set tree: "+t.toStringTree());
-                int alts = nfabuilder.testBlockAsSet( t );
+                int alts = nfabuilder.TestBlockAsSet( t );
valid = ( alts > 1 );
}
catch ( RecognitionException /*re*/ )
@@ -3700,16 +3570,16 @@ namespace Antlr3.Tool
*
*		^( RULE ID modifier ARG RET SCOPE block EOR )
*/
-        public virtual IIntSet getSetFromRule( TreeToNFAConverter nfabuilder, string ruleName )
+        public virtual IIntSet GetSetFromRule( TreeToNFAConverter nfabuilder, string ruleName )
{
-            Rule r = getRule( ruleName );
+            Rule r = GetRule( ruleName );
if ( r == null )
{
return null;
}
IIntSet elements = null;
//JSystem.@out.println("parsed tree: "+r.tree.toStringTree());
-            elements = nfabuilder.setRule( r.tree );
+            elements = nfabuilder.SetRule( r.tree );
//JSystem.@out.println("elements="+elements);
return elements;
}
@@ -3718,7 +3588,7 @@ namespace Antlr3.Tool
*  many there are.  This is here rather than in NFAState because
*  a grammar decides how NFAs are put together to form a decision.
*/
-        public virtual int getNumberOfAltsForDecisionNFA( NFAState decisionState )
+        public virtual int GetNumberOfAltsForDecisionNFA( NFAState decisionState )
{
if ( decisionState == null )
{
@@ -3745,7 +3615,7 @@ namespace Antlr3.Tool
*  This routine returns the leftmost state for each alt.  So alt=1, returns
*  the upperleft most state in this structure.
*/
-        public virtual NFAState getNFAStateForAltOfDecision( NFAState decisionState, int alt )
+        public virtual NFAState GetNFAStateForAltOfDecision( NFAState decisionState, int alt )
{
if ( decisionState == null || alt <= 0 )
{
@@ -3771,7 +3641,7 @@ namespace Antlr3.Tool
}

#if false
-        public virtual void computeRuleFOLLOWSets()
+        public virtual void ComputeRuleFOLLOWSets()
{
if ( getNumberOfDecisions() == 0 )
{
@@ -3790,65 +3660,36 @@ namespace Antlr3.Tool
}
#endif

-        public virtual LookaheadSet FIRST( NFAState s )
+        public virtual LookaheadSet First( NFAState s )
{
return ll1Analyzer.First( s );
}

-        public virtual LookaheadSet LOOK( NFAState s )
+        public virtual LookaheadSet Look( NFAState s )
{
return ll1Analyzer.Look( s );
}

-        public virtual void setCodeGenerator( CodeGenerator generator )
-        {
-            this.generator = generator;
-        }
-
-        [System.Obsolete]
-        public CodeGenerator getCodeGenerator()
-        {
-            return CodeGenerator;
-        }
-
-        [System.Obsolete]
-        public GrammarAST getGrammarTree()
-        {
-            return Tree;
-        }
-
-        [System.Obsolete]
-        public Tool getTool()
-        {
-            return Tool;
-        }
-
-        [System.Obsolete]
-        public void setTool( Tool tool )
-        {
-            Tool = tool;
-        }
-
/** given a token type and the text of the literal, come up with a
*  decent token type label.  For now it's just T<type>.  Actually,
*  if there is an aliased name from tokens like PLUS='+', use it.
*/
-        public virtual string computeTokenNameFromLiteral( int tokenType, string literal )
+        public virtual string ComputeTokenNameFromLiteral( int tokenType, string literal )
{
return AUTO_GENERATED_TOKEN_NAME_PREFIX + tokenType;
}

public override string ToString()
{
-            return grammarTreeToString( grammarTree );
+            return GrammarTreeToString( grammarTree );
}

-        public virtual string grammarTreeToString( GrammarAST t )
+        public virtual string GrammarTreeToString( GrammarAST t )
{
-            return grammarTreeToString( t, true );
+            return GrammarTreeToString( t, true );
}

-        public virtual string grammarTreeToString( GrammarAST t, bool showActions )
+        public virtual string GrammarTreeToString( GrammarAST t, bool showActions )
{
string s = null;
try
@@ -3863,7 +3704,7 @@ namespace Antlr3.Tool
return s;
}

-        public virtual void printGrammar( TextWriter output )
+        public virtual void PrintGrammar( TextWriter output )
{
ANTLRTreePrinter printer = new ANTLRTreePrinter( new Antlr.Runtime.Tree.CommonTreeNodeStream( grammarTree ) );
//printer.setASTNodeClass( "org.antlr.tool.GrammarAST" );
@@ -3874,7 +3715,7 @@ namespace Antlr3.Tool
}
catch ( RecognitionException re )
{
-                ErrorManager.error( ErrorManager.MSG_SYNTAX_ERROR, re );
+                ErrorManager.Error( ErrorManager.MSG_SYNTAX_ERROR, re );
}
}

diff --git a/Antlr3/Tool/GrammarAST.cs b/Antlr3/Tool/GrammarAST.cs
index 90f12b1..934a711 100644
--- a/Antlr3/Tool/GrammarAST.cs
+++ b/Antlr3/Tool/GrammarAST.cs
@@ -138,12 +138,12 @@ namespace Antlr3.Tool

public GrammarAST( int t, string txt )
{
-            initialize( t, txt );
+            Initialize( t, txt );
}

public GrammarAST( IToken token )
{
-            initialize( token );
+            Initialize( token );
}

#region Properties
@@ -151,11 +151,11 @@ namespace Antlr3.Tool
{
get
{
-                return getBlockOptions();
+                return blockOptions;
}
set
{
-                setBlockOptions( value );
+                blockOptions = value;
}
}
public GrammarAST LastChild
@@ -212,22 +212,12 @@ namespace Antlr3.Tool
}
#endregion

-        public IDictionary<string, object> getBlockOptions()
-        {
-            return blockOptions;
-        }
-
-        public void setBlockOptions( IDictionary<string, object> value )
-        {
-            blockOptions = value;
-        }
-
-        public virtual void initialize( int i, string s )
+        public virtual void Initialize( int i, string s )
{
token = new CommonToken( i, s );
}

-        public virtual void initialize( ITree ast )
+        public virtual void Initialize( ITree ast )
{
GrammarAST t = ( (GrammarAST)ast );
this.token = t.token;
@@ -239,61 +229,37 @@ namespace Antlr3.Tool
this.outerAltNum = t.outerAltNum;
}

-        public virtual void initialize( IToken token )
+        public virtual void Initialize( IToken token )
{
this.token = token;
}

-        [Obsolete]
-        public virtual DFA getLookaheadDFA()
-        {
-            return LookaheadDFA;
-        }
-
-        [Obsolete]
-        public virtual void setLookaheadDFA( DFA lookaheadDFA )
-        {
-            LookaheadDFA = lookaheadDFA;
-        }
-
-        [Obsolete]
-        public virtual NFAState getNFAStartState()
-        {
-            return NFAStartState;
-        }
-
-        [Obsolete]
-        public virtual void setNFAStartState( NFAState nfaStartState )
-        {
-            NFAStartState = nfaStartState;
-        }
-
/** Save the option key/value pair and process it; return the key
*  or null if invalid option.
*/
-        public virtual string setBlockOption( Grammar grammar, string key, object value )
+        public virtual string SetBlockOption( Grammar grammar, string key, object value )
{
if ( blockOptions == null )
{
blockOptions = new Dictionary<string, object>();
}
-            return setOption( blockOptions, Grammar.legalBlockOptions, grammar, key, value );
+            return SetOption( blockOptions, Grammar.legalBlockOptions, grammar, key, value );
}

-        public virtual string setTerminalOption( Grammar grammar, string key, object value )
+        public virtual string SetTerminalOption( Grammar grammar, string key, object value )
{
if ( terminalOptions == null )
{
terminalOptions = new Dictionary<string, object>();
}
-            return setOption( terminalOptions, Grammar.legalTokenOptions, grammar, key, value );
+            return SetOption( terminalOptions, Grammar.legalTokenOptions, grammar, key, value );
}

-        public virtual string setOption( IDictionary<string, object> options, HashSet<string> legalOptions, Grammar grammar, string key, object value )
+        public virtual string SetOption( IDictionary<string, object> options, HashSet<string> legalOptions, Grammar grammar, string key, object value )
{
if ( !legalOptions.Contains( key ) )
{
-                ErrorManager.grammarError( ErrorManager.MSG_ILLEGAL_OPTION,
+                ErrorManager.GrammarError( ErrorManager.MSG_ILLEGAL_OPTION,
grammar,
token,
key );
@@ -313,13 +279,13 @@ namespace Antlr3.Tool
}
if ( key == "backtrack" && value.ToString() == "true" )
{
-                grammar.composite.getRootGrammar().atLeastOneBacktrackOption = true;
+                grammar.composite.GetRootGrammar().atLeastOneBacktrackOption = true;
}
options[key] = value;
return key;
}

-        public virtual object getBlockOption( string key )
+        public virtual object GetBlockOption( string key )
{
object value = null;
if ( blockOptions != null )
@@ -329,7 +295,7 @@ namespace Antlr3.Tool
return value;
}

-        public virtual void setOptions( Grammar grammar, IDictionary<string, object> options )
+        public virtual void SetOptions( Grammar grammar, IDictionary<string, object> options )
{
if ( options == null )
{
@@ -338,7 +304,7 @@ namespace Antlr3.Tool
}
foreach ( string optionName in options.Keys.ToArray() )
{
-                string stored = setBlockOption( grammar, optionName, options.get( optionName ) );
+                string stored = SetBlockOption( grammar, optionName, options.get( optionName ) );
if ( stored == null )
options.Remove( optionName );
}
@@ -421,31 +387,7 @@ namespace Antlr3.Tool
}
}

-        [Obsolete]
-        public virtual IIntSet getSetValue()
-        {
-            return SetValue;
-        }
-
-        [Obsolete]
-        public virtual void setSetValue( IIntSet setValue )
-        {
-            SetValue = setValue;
-        }
-
-        [Obsolete]
-        public virtual GrammarAST getLastChild()
-        {
-            return LastChild;
-        }
-
-        [Obsolete]
-        public virtual GrammarAST getLastSibling()
-        {
-            return LastSibling;
-        }
-
-        public virtual GrammarAST[] getChildrenAsArray()
+        public virtual GrammarAST[] GetChildrenAsArray()
{
return Children.CastListDown<GrammarAST, ITree>().ToArray();
}
@@ -495,7 +437,7 @@ namespace Antlr3.Tool
*  token type ttype.  Assume 'this' is a root node; don't visit siblings
*  of root.  Return null if no node found with ttype.
*/
-        public GrammarAST findFirstType( int ttype )
+        public GrammarAST FindFirstType( int ttype )
{
// check this node (the root) first
if ( this.Type == ttype )
@@ -532,7 +474,7 @@ namespace Antlr3.Tool
}

/** See if tree has exact token types and structure; no text */
-        public bool hasSameTreeStructure( ITree other )
+        public bool HasSameTreeStructure( ITree other )
{
// check roots first.
if ( Type != other.Type )
@@ -542,20 +484,20 @@ namespace Antlr3.Tool
return Descendants( this, true ).SequenceEqual( Descendants( other, true ), ( a, b ) => a.Type == b.Type );
}

-        public static GrammarAST dup( ITree t )
+        public static GrammarAST Dup( ITree t )
{
if ( t == null )
{
return null;
}
GrammarAST dup_t = new GrammarAST();
-            dup_t.initialize( t );
+            dup_t.Initialize( t );
return dup_t;
}

public override ITree DupNode()
{
-            return dup( this );
+            return Dup( this );
}

static IEnumerable<GrammarAST> GetChildrenForDupTree( GrammarAST t )
@@ -583,16 +525,16 @@ namespace Antlr3.Tool
/**Duplicate a tree, assuming this is a root node of a tree--
* duplicate that node and what's below; ignore siblings of root node.
*/
-        public static GrammarAST dupTreeNoActions( GrammarAST t, GrammarAST parent )
+        public static GrammarAST DupTreeNoActions( GrammarAST t, GrammarAST parent )
{
GrammarAST d = (GrammarAST)t.DupNode();
foreach ( GrammarAST subchild in GetChildrenForDupTree( t ) )
-                d.AddChild( dupTreeNoActions( subchild, d ) );
+                d.AddChild( DupTreeNoActions( subchild, d ) );

return d;
}

-        public void setTreeEnclosingRuleNameDeeply( string rname )
+        public void SetTreeEnclosingRuleNameDeeply( string rname )
{
enclosingRuleName = rname;
foreach ( GrammarAST child in Descendants( this ).OfType<GrammarAST>() )
diff --git a/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs b/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
index c80369b..1250c3b 100644
--- a/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
+++ b/Antlr3/Tool/GrammarAnalysisAbortedMessage.cs
@@ -58,7 +58,7 @@ namespace Antlr3.Tool
{
file = fileName;
}
-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
st.SetAttribute( "enclosingRule",
probe.dfa.NFADecisionStartState.enclosingRule.name );

diff --git a/Antlr3/Tool/GrammarDanglingStateMessage.cs b/Antlr3/Tool/GrammarDanglingStateMessage.cs
index 42fd378..7f1cef8 100644
--- a/Antlr3/Tool/GrammarDanglingStateMessage.cs
+++ b/Antlr3/Tool/GrammarDanglingStateMessage.cs
@@ -67,7 +67,7 @@ namespace Antlr3.Tool
}
var labels = probe.GetSampleNonDeterministicInputSequence( problemState );
string input = probe.GetInputSequenceDisplay( labels );
-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
List<int> alts = new List<int>();
alts.addAll( problemState.AltSet );
alts.Sort();
diff --git a/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs b/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
index 92ee585..8e2c77e 100644
--- a/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
+++ b/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
@@ -65,7 +65,7 @@ namespace Antlr3.Tool
{
file = fileName;
}
-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
// convert to string key to avoid 3.1 ST bug
var altToLocationsWithStringKey = new SortedList<string, ICollection<IToken>>();
List<int> alts = new List<int>();
diff --git a/Antlr3/Tool/GrammarNonDeterminismMessage.cs b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
index 9d905bc..56d9904 100644
--- a/Antlr3/Tool/GrammarNonDeterminismMessage.cs
+++ b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
@@ -57,7 +57,7 @@ namespace Antlr3.Tool
// flip msg ID if alts are actually token refs in Tokens rule
if ( probe.dfa.IsTokensRuleDecision )
{
-                setMessageID( ErrorManager.MSG_TOKEN_NONDETERMINISM );
+                MessageID = ErrorManager.MSG_TOKEN_NONDETERMINISM;
}
}

@@ -72,7 +72,7 @@ namespace Antlr3.Tool
file = fileName;
}

-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
// Now fill template with information about problemState
var labels = probe.GetSampleNonDeterministicInputSequence( problemState );
string input = probe.GetInputSequenceDisplay( labels );
@@ -87,7 +87,7 @@ namespace Antlr3.Tool
probe.GetTokenNameForTokensRuleAlt( (int)altI );
// reset the line/col to the token definition (pick last one)
NFAState ruleStart =
-                        probe.dfa.nfa.grammar.getRuleStartState( tokenName );
+                        probe.dfa.nfa.grammar.GetRuleStartState( tokenName );
line = ruleStart.associatedASTNode.Line;
charPositionInLine = ruleStart.associatedASTNode.CharPositionInLine;
st.SetAttribute( "disabled", tokenName );
diff --git a/Antlr3/Tool/GrammarReport.cs b/Antlr3/Tool/GrammarReport.cs
index 2647f57..8b26bee 100644
--- a/Antlr3/Tool/GrammarReport.cs
+++ b/Antlr3/Tool/GrammarReport.cs
@@ -61,7 +61,7 @@ namespace Antlr3.Tool
/** Create a single-line stats report about this grammar suitable to
*  send to the notify page at antlr.org
*/
-        public virtual string toNotifyString()
+        public virtual string ToNotifyString()
{
StringBuilder buf = new StringBuilder();
buf.Append( Version );
@@ -70,7 +70,7 @@ namespace Antlr3.Tool
buf.Append( '\t' );
buf.Append( grammar.GrammarTypeString );
buf.Append( '\t' );
-            buf.Append( grammar.getOption( "language" ) );
+            buf.Append( grammar.GetOption( "language" ) );
int totalNonSynPredProductions = 0;
int totalNonSynPredRules = 0;
foreach ( Rule r in grammar.Rules )
@@ -87,17 +87,17 @@ namespace Antlr3.Tool
buf.Append( '\t' );
buf.Append( totalNonSynPredProductions );
int numACyclicDecisions =
-                grammar.NumberOfDecisions - grammar.getNumberOfCyclicDecisions();
+                grammar.NumberOfDecisions - grammar.GetNumberOfCyclicDecisions();
int[] depths = new int[numACyclicDecisions];
int[] acyclicDFAStates = new int[numACyclicDecisions];
-            int[] cyclicDFAStates = new int[grammar.getNumberOfCyclicDecisions()];
+            int[] cyclicDFAStates = new int[grammar.GetNumberOfCyclicDecisions()];
int acyclicIndex = 0;
int cyclicIndex = 0;
int numLL1 = 0;
int numDec = 0;
for ( int i = 1; i <= grammar.NumberOfDecisions; i++ )
{
-                Grammar.Decision d = grammar.getDecision( i );
+                Grammar.Decision d = grammar.GetDecision( i );
if ( d.dfa == null )
{
continue;
@@ -123,7 +123,7 @@ namespace Antlr3.Tool
buf.Append( '\t' );
buf.Append( numDec );
buf.Append( '\t' );
-            buf.Append( grammar.getNumberOfCyclicDecisions() );
+            buf.Append( grammar.GetNumberOfCyclicDecisions() );
buf.Append( '\t' );
buf.Append( numLL1 );
buf.Append( '\t' );
@@ -169,11 +169,11 @@ namespace Antlr3.Tool
buf.Append( '\t' );
buf.Append( grammar.setOfDFAWhoseAnalysisTimedOut.Count );
buf.Append( '\t' );
-            buf.Append( ErrorManager.getErrorState().errors );
+            buf.Append( ErrorManager.GetErrorState().errors );
buf.Append( '\t' );
-            buf.Append( ErrorManager.getErrorState().warnings );
+            buf.Append( ErrorManager.GetErrorState().warnings );
buf.Append( '\t' );
-            buf.Append( ErrorManager.getErrorState().infos );
+            buf.Append( ErrorManager.GetErrorState().infos );
buf.Append( '\t' );
var synpreds = grammar.SyntacticPredicates;
int num_synpreds = synpreds != null ? synpreds.Count : 0;
@@ -187,21 +187,21 @@ namespace Antlr3.Tool
buf.Append( '\t' );
buf.Append( grammar.decisionsWhoseDFAsUsesSemPreds.Count );
buf.Append( '\t' );
-            string output = (string)grammar.getOption( "output" );
+            string output = (string)grammar.GetOption( "output" );
if ( output == null )
{
output = "none";
}
buf.Append( output );
buf.Append( '\t' );
-            object k = grammar.getOption( "k" );
+            object k = grammar.GetOption( "k" );
if ( k == null )
{
k = "none";
}
buf.Append( k );
buf.Append( '\t' );
-            string backtrack = (string)grammar.getOption( "backtrack" );
+            string backtrack = (string)grammar.GetOption( "backtrack" );
if ( backtrack == null )
{
backtrack = "false";
@@ -210,7 +210,7 @@ namespace Antlr3.Tool
return buf.ToString();
}

-        public virtual string getBacktrackingReport()
+        public virtual string GetBacktrackingReport()
{
StringBuilder buf = new StringBuilder();
buf.Append( "Backtracking report:" );
@@ -218,11 +218,11 @@ namespace Antlr3.Tool
buf.Append( "Number of decisions that backtrack: " );
buf.Append( grammar.decisionsWhoseDFAsUsesSynPreds.Count );
buf.Append( newline );
-            buf.Append( getDFALocations( grammar.decisionsWhoseDFAsUsesSynPreds ) );
+            buf.Append( GetDFALocations( grammar.decisionsWhoseDFAsUsesSynPreds ) );
return buf.ToString();
}

-        public virtual string getAnalysisTimeoutReport()
+        public virtual string GetAnalysisTimeoutReport()
{
StringBuilder buf = new StringBuilder();
buf.Append( "NFA conversion early termination report:" );
@@ -230,11 +230,11 @@ namespace Antlr3.Tool
buf.Append( "Number of NFA conversions that terminated early: " );
buf.Append( grammar.setOfDFAWhoseAnalysisTimedOut.Count );
buf.Append( newline );
-            buf.Append( getDFALocations( grammar.setOfDFAWhoseAnalysisTimedOut ) );
+            buf.Append( GetDFALocations( grammar.setOfDFAWhoseAnalysisTimedOut ) );
return buf.ToString();
}

-        protected virtual string getDFALocations( HashSet<DFA> dfas )
+        protected virtual string GetDFALocations( HashSet<DFA> dfas )
{
HashSet<int> decisions = new HashSet<int>();
StringBuilder buf = new StringBuilder();
@@ -267,10 +267,10 @@ namespace Antlr3.Tool
*/
public override string ToString()
{
-            return toString( toNotifyString() );
+            return ToString( ToNotifyString() );
}

-        protected static string[] decodeReportData( string data )
+        protected static string[] DecodeReportData( string data )
{
string[] fields = new string[NUM_GRAMMAR_STATS];
StringTokenizer st = new StringTokenizer( data, "\t" );
@@ -287,9 +287,9 @@ namespace Antlr3.Tool
return fields;
}

-        public static string toString( string notifyDataLine )
+        public static string ToString( string notifyDataLine )
{
-            string[] fields = decodeReportData( notifyDataLine );
+            string[] fields = DecodeReportData( notifyDataLine );
if ( fields == null )
{
return null;
diff --git a/Antlr3/Tool/GrammarSanity.cs b/Antlr3/Tool/GrammarSanity.cs
index ead09ff..547e912 100644
--- a/Antlr3/Tool/GrammarSanity.cs
+++ b/Antlr3/Tool/GrammarSanity.cs
@@ -59,9 +59,9 @@ namespace Antlr3.Tool
*  the error manager that we have problems and it sets the list of
*  recursive rules that we should ignore during analysis.
*/
-        public virtual IList<HashSet<Rule>> checkAllRulesForLeftRecursion()
+        public virtual IList<HashSet<Rule>> CheckAllRulesForLeftRecursion()
{
-            grammar.buildNFA(); // make sure we have NFAs
+            grammar.BuildNFA(); // make sure we have NFAs
grammar.leftRecursiveRules = new HashSet<Rule>();
List<HashSet<Rule>> listOfRecursiveCycles = new List<HashSet<Rule>>();
for ( int i = 0; i < grammar.composite.ruleIndexToRuleList.Count; i++ )
@@ -72,14 +72,14 @@ namespace Antlr3.Tool
visitedDuringRecursionCheck = new HashSet<Rule>();
visitedDuringRecursionCheck.Add( r );
HashSet<object> visitedStates = new HashSet<object>();
-                    traceStatesLookingForLeftRecursion( r.startState,
+                    TraceStatesLookingForLeftRecursion( r.startState,
visitedStates,
listOfRecursiveCycles );
}
}
if ( listOfRecursiveCycles.Count > 0 )
{
-                ErrorManager.leftRecursionCycles( listOfRecursiveCycles );
+                ErrorManager.LeftRecursionCycles( listOfRecursiveCycles );
}
return listOfRecursiveCycles;
}
@@ -94,7 +94,7 @@ namespace Antlr3.Tool
*  filling the cycles in listOfRecursiveCycles and also, as a
*  side-effect, set leftRecursiveRules.
*/
-        protected virtual bool traceStatesLookingForLeftRecursion( NFAState s,
+        protected virtual bool TraceStatesLookingForLeftRecursion( NFAState s,
HashSet<object> visitedStates,
IList<HashSet<Rule>> listOfRecursiveCycles )
{
@@ -122,7 +122,7 @@ namespace Antlr3.Tool
// record left-recursive rule, but don't go back in
grammar.leftRecursiveRules.Add( refRuleDef );
//System.Console.Out.WriteLine( "already visited " + refRuleDef + ", calling from " + s.enclosingRule );
-                    addRulesToCycle( refRuleDef,
+                    AddRulesToCycle( refRuleDef,
s.enclosingRule,
listOfRecursiveCycles );
}
@@ -131,7 +131,7 @@ namespace Antlr3.Tool
// must visit if not already visited; send new visitedStates set
visitedDuringRecursionCheck.Add( refRuleDef );
bool callReachedAcceptState =
-                        traceStatesLookingForLeftRecursion( (NFAState)t0.target,
+                        TraceStatesLookingForLeftRecursion( (NFAState)t0.target,
new HashSet<object>(),
listOfRecursiveCycles );
// we're back from visiting that rule
@@ -142,7 +142,7 @@ namespace Antlr3.Tool
NFAState followingState =
( (RuleClosureTransition)t0 ).followState;
stateReachesAcceptState |=
-                            traceStatesLookingForLeftRecursion( followingState,
+                            TraceStatesLookingForLeftRecursion( followingState,
visitedStates,
listOfRecursiveCycles );
}
@@ -151,7 +151,7 @@ namespace Antlr3.Tool
else if ( t0.label.IsEpsilon || t0.label.IsSemanticPredicate )
{
stateReachesAcceptState |=
-                    traceStatesLookingForLeftRecursion( (NFAState)t0.target, visitedStates, listOfRecursiveCycles );
+                    TraceStatesLookingForLeftRecursion( (NFAState)t0.target, visitedStates, listOfRecursiveCycles );
}
// else it has a labeled edge

@@ -160,7 +160,7 @@ namespace Antlr3.Tool
if ( t1 != null )
{
stateReachesAcceptState |=
-                    traceStatesLookingForLeftRecursion( (NFAState)t1.target,
+                    TraceStatesLookingForLeftRecursion( (NFAState)t1.target,
visitedStates,
listOfRecursiveCycles );
}
@@ -173,7 +173,7 @@ namespace Antlr3.Tool
*  cycle.  listOfRecursiveCycles is List<Set<String>> that holds a list
*  of cycles (sets of rule names).
*/
-        protected virtual void addRulesToCycle( Rule targetRule,
+        protected virtual void AddRulesToCycle( Rule targetRule,
Rule enclosingRule,
IList<HashSet<Rule>> listOfRecursiveCycles )
{
@@ -202,12 +202,12 @@ namespace Antlr3.Tool
}
}

-        public virtual void checkRuleReference( GrammarAST scopeAST,
+        public virtual void CheckRuleReference( GrammarAST scopeAST,
GrammarAST refAST,
GrammarAST argsAST,
string currentRuleName )
{
-            Rule r = grammar.getRule( refAST.Text );
+            Rule r = grammar.GetRule( refAST.Text );
if ( refAST.Type == ANTLRParser.RULE_REF )
{
if ( argsAST != null )
@@ -216,7 +216,7 @@ namespace Antlr3.Tool
if ( r != null && r.argActionAST == null )
{
// but rule def has no args
-                        ErrorManager.grammarError(
+                        ErrorManager.GrammarError(
ErrorManager.MSG_RULE_HAS_NO_ARGS,
grammar,
argsAST.Token,
@@ -229,7 +229,7 @@ namespace Antlr3.Tool
if ( r != null && r.argActionAST != null )
{
// but rule def has args
-                        ErrorManager.grammarError(
+                        ErrorManager.GrammarError(
ErrorManager.MSG_MISSING_RULE_ARGS,
grammar,
refAST.Token,
@@ -244,7 +244,7 @@ namespace Antlr3.Tool
if ( argsAST != null )
{
// args on a token ref not in a lexer rule
-                        ErrorManager.grammarError(
+                        ErrorManager.GrammarError(
ErrorManager.MSG_ARGS_ON_TOKEN_REF,
grammar,
refAST.Token,
@@ -258,7 +258,7 @@ namespace Antlr3.Tool
if ( r != null && r.argActionAST == null )
{
// but token rule def has no args
-                        ErrorManager.grammarError(
+                        ErrorManager.GrammarError(
ErrorManager.MSG_RULE_HAS_NO_ARGS,
grammar,
argsAST.Token,
@@ -271,7 +271,7 @@ namespace Antlr3.Tool
if ( r != null && r.argActionAST != null )
{
// but token rule def has args
-                        ErrorManager.grammarError(
+                        ErrorManager.GrammarError(
ErrorManager.MSG_MISSING_RULE_ARGS,
grammar,
refAST.Token,
@@ -291,16 +291,16 @@ namespace Antlr3.Tool
*
*  Ignore predicates in front and labels.
*/
-        public virtual void ensureAltIsSimpleNodeOrTree( GrammarAST altAST,
+        public virtual void EnsureAltIsSimpleNodeOrTree( GrammarAST altAST,
GrammarAST elementAST,
int outerAltNum )
{
-            if ( isValidSimpleElementNode( elementAST ) )
+            if ( IsValidSimpleElementNode( elementAST ) )
{
GrammarAST next = (GrammarAST)elementAST.getNextSibling();
-                if ( !isNextNonActionElementEOA( next ) )
+                if ( !IsNextNonActionElementEOA( next ) )
{
-                    ErrorManager.grammarWarning( ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
+                    ErrorManager.GrammarWarning( ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
grammar,
next.token,
outerAltNum );
@@ -311,7 +311,7 @@ namespace Antlr3.Tool
{
case ANTLRParser.ASSIGN:		// labels ok on non-rule refs
case ANTLRParser.PLUS_ASSIGN:
-                if ( isValidSimpleElementNode( (GrammarAST)elementAST.GetChild( 1 ) ) )
+                if ( IsValidSimpleElementNode( (GrammarAST)elementAST.GetChild( 1 ) ) )
{
return;
}
@@ -321,18 +321,18 @@ namespace Antlr3.Tool
case ANTLRParser.SYN_SEMPRED:
case ANTLRParser.BACKTRACK_SEMPRED:
case ANTLRParser.GATED_SEMPRED:
-                ensureAltIsSimpleNodeOrTree( altAST,
+                EnsureAltIsSimpleNodeOrTree( altAST,
(GrammarAST)elementAST.getNextSibling(),
outerAltNum );
return;
}
-            ErrorManager.grammarWarning( ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
+            ErrorManager.GrammarWarning( ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
grammar,
elementAST.token,
outerAltNum );
}

-        protected virtual bool isValidSimpleElementNode( GrammarAST t )
+        protected virtual bool IsValidSimpleElementNode( GrammarAST t )
{
switch ( t.Type )
{
@@ -347,7 +347,7 @@ namespace Antlr3.Tool
}
}

-        protected virtual bool isNextNonActionElementEOA( GrammarAST t )
+        protected virtual bool IsNextNonActionElementEOA( GrammarAST t )
{
while ( t.Type == ANTLRParser.ACTION ||
t.Type == ANTLRParser.SEMPRED )
diff --git a/Antlr3/Tool/GrammarSemanticsMessage.cs b/Antlr3/Tool/GrammarSemanticsMessage.cs
index be875d2..7edbbd6 100644
--- a/Antlr3/Tool/GrammarSemanticsMessage.cs
+++ b/Antlr3/Tool/GrammarSemanticsMessage.cs
@@ -85,7 +85,7 @@ namespace Antlr3.Tool
{
file = g.FileName;
}
-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
if ( arg != null )
{
st.SetAttribute( "arg", arg );
diff --git a/Antlr3/Tool/GrammarSpelunker.cs b/Antlr3/Tool/GrammarSpelunker.cs
index 7b45cf3..c5b3660 100644
--- a/Antlr3/Tool/GrammarSpelunker.cs
+++ b/Antlr3/Tool/GrammarSpelunker.cs
@@ -75,22 +75,22 @@ namespace Antlr3.Tool
this.grammarFileName = grammarFileName;
}

-        void consume()
+        void Consume()
{
-            token = scanner.nextToken();
+            token = scanner.NextToken();
}

-        protected virtual void match( string expecting )
+        protected virtual void Match( string expecting )
{
//System.Console.Out.WriteLine( "match " + expecting + "; is " + token );
if ( token.Equals( expecting ) )
-                consume();
+                Consume();
else
throw new Exception( "Error parsing " + grammarFileName + ": '" + token +
"' not expected '" + expecting + "'" );
}

-        public virtual void parse()
+        public virtual void Parse()
{
string fileName = grammarFileName;
if ( inputDirectory != null )
@@ -100,24 +100,24 @@ namespace Antlr3.Tool
try
{
scanner = new Scanner( r );
-                consume();
-                grammarHeader();
+                Consume();
+                GrammarHeader();
// scan until imports or options
while ( token != null && !token.Equals( "@" ) && !token.Equals( ":" ) &&
!token.Equals( "import" ) && !token.Equals( "options" ) )
{
-                    consume();
+                    Consume();
}
if ( token.Equals( "options" ) )
-                    options();
+                    Options();
// scan until options or first rule
while ( token != null && !token.Equals( "@" ) && !token.Equals( ":" ) &&
!token.Equals( "import" ) )
{
-                    consume();
+                    Consume();
}
if ( token.Equals( "import" ) )
-                    imports();
+                    Imports();
// ignore rest of input; close up shop
}
finally
@@ -127,78 +127,89 @@ namespace Antlr3.Tool
}
}

-        protected virtual void grammarHeader()
+        protected virtual void GrammarHeader()
{
if ( token == null )
return;
if ( token.Equals( "tree" ) || token.Equals( "parser" ) || token.Equals( "lexer" ) )
{
grammarModifier = token;
-                consume();
+                Consume();
}
-            match( "grammar" );
+            Match( "grammar" );
grammarName = token;
-            consume(); // move beyond name
+            Consume(); // move beyond name
}

// looks like "options { backtrack true ; tokenVocab MyTokens ; }"
-        protected virtual void options()
+        protected virtual void Options()
{
-            match( "options" );
-            match( "{" );
+            Match( "options" );
+            Match( "{" );
while ( token != null && !token.Equals( "}" ) )
{
string name = token;
-                consume();
+                Consume();
string value = token;
-                consume();
-                match( ";" );
+                Consume();
+                Match( ";" );
if ( name.Equals( "tokenVocab" ) )
tokenVocab = value;
if ( name.Equals( "language" ) )
language = value;
}
-            match( "}" );
+            Match( "}" );
}

// looks like "import JavaDecl JavaAnnotations JavaExpr ;"
-        protected virtual void imports()
+        protected virtual void Imports()
{
-            match( "import" );
+            Match( "import" );
importedGrammars = new List<string>();
while ( token != null && !token.Equals( ";" ) )
{
importedGrammars.Add( token );
-                consume();
+                Consume();
}
-            match( ";" );
+            Match( ";" );
if ( importedGrammars.Count == 0 )
importedGrammars = null;
}

-        public virtual string getGrammarModifier()
+        public virtual string GrammarModifier
{
-            return grammarModifier;
+            get
+            {
+                return grammarModifier;
+            }
}
-
-        public virtual string getGrammarName()
+        public virtual string GrammarName
{
-            return grammarName;
+            get
+            {
+                return grammarName;
+            }
}
-
-        public virtual string getTokenVocab()
+        public virtual string TokenVocab
{
-            return tokenVocab;
+            get
+            {
+                return tokenVocab;
+            }
}
-
-        public virtual string getLanguage()
+        public virtual string Language
{
-            return language;
+            get
+            {
+                return language;
+            }
}
-
-        public virtual List<string> getImportedGrammars()
+        public virtual List<string> ImportedGrammars
{
-            return importedGrammars;
+            get
+            {
+                return importedGrammars;
+            }
}

/** Strip comments and then return stream of words and
@@ -213,28 +224,28 @@ namespace Antlr3.Tool
public Scanner( TextReader input )
{
this.input = input;
-                consume();
+                Consume();
}

-            bool isDIGIT()
+            bool IsDigit()
{
return c >= '0' && c <= '9';
}
-            bool isID_START()
+            bool IsIdStart()
{
return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z';
}
-            bool isID_LETTER()
+            bool IsIdLetter()
{
-                return isID_START() || c >= '0' && c <= '9' || c == '_';
+                return IsIdStart() || c >= '0' && c <= '9' || c == '_';
}

-            void consume()
+            void Consume()
{
c = input.Read();
}

-            public virtual string nextToken()
+            public virtual string NextToken()
{
while ( c != EOF )
{
@@ -242,31 +253,31 @@ namespace Antlr3.Tool
switch ( c )
{
case ';':
-                        consume();
+                        Consume();
return ";";
case '{':
-                        consume();
+                        Consume();
return "{";
case '}':
-                        consume();
+                        Consume();
return "}";
case ':':
-                        consume();
+                        Consume();
return ":";
case '@':
-                        consume();
+                        Consume();
return "@";
case '/':
-                        COMMENT();
+                        Comment();
break;
case '\'':
-                        return STRING();
+                        return String();
default:
-                        if ( isID_START() )
-                            return ID();
-                        else if ( isDIGIT() )
-                            return INT();
-                        consume(); // ignore anything else
+                        if ( IsIdStart() )
+                            return Id();
+                        else if ( IsDigit() )
+                            return Int();
+                        Consume(); // ignore anything else
break;
}
}
@@ -274,76 +285,76 @@ namespace Antlr3.Tool
}

/** NAME : LETTER+ ; // NAME is sequence of >=1 letter */
-            string ID()
+            string Id()
{
StringBuilder buf = new StringBuilder();
-                while ( c != EOF && isID_LETTER() )
+                while ( c != EOF && IsIdLetter() )
{
buf.Append( (char)c );
-                    consume();
+                    Consume();
}
return buf.ToString();
}

-            string INT()
+            string Int()
{
StringBuilder buf = new StringBuilder();
-                while ( c != EOF && isDIGIT() )
+                while ( c != EOF && IsDigit() )
{
buf.Append( (char)c );
-                    consume();
+                    Consume();
}
return buf.ToString();
}

-            string STRING()
+            string String()
{
StringBuilder buf = new StringBuilder();
-                consume();
+                Consume();
while ( c != EOF && c != '\'' )
{
if ( c == '\\' )
{
buf.Append( (char)c );
-                        consume();
+                        Consume();
}
buf.Append( (char)c );
-                    consume();
+                    Consume();
}
-                consume(); // scan past '
+                Consume(); // scan past '
return buf.ToString();
}

-            void COMMENT()
+            void Comment()
{
if ( c == '/' )
{
-                    consume();
+                    Consume();
if ( c == '*' )
{
-                        consume();
+                        Consume();
for ( ; ; )
{
if ( c == '*' )
{
-                                consume();
+                                Consume();
if ( c == '/' )
{
-                                    consume();
+                                    Consume();
break;
}
}
else
{
while ( c != EOF && c != '*' )
-                                    consume();
+                                    Consume();
}
}
}
else if ( c == '/' )
{
while ( c != EOF && c != '\n' )
-                            consume();
+                            Consume();
}
}
}
diff --git a/Antlr3/Tool/GrammarSyntaxMessage.cs b/Antlr3/Tool/GrammarSyntaxMessage.cs
index 4bce309..3e5f43a 100644
--- a/Antlr3/Tool/GrammarSyntaxMessage.cs
+++ b/Antlr3/Tool/GrammarSyntaxMessage.cs
@@ -83,7 +83,7 @@ namespace Antlr3.Tool
{
file = g.FileName;
}
-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
if ( arg != null )
{
st.SetAttribute( "arg", arg );
diff --git a/Antlr3/Tool/GrammarUnreachableAltsMessage.cs b/Antlr3/Tool/GrammarUnreachableAltsMessage.cs
index 52bc0a9..4b5aff2 100644
--- a/Antlr3/Tool/GrammarUnreachableAltsMessage.cs
+++ b/Antlr3/Tool/GrammarUnreachableAltsMessage.cs
@@ -57,7 +57,7 @@ namespace Antlr3.Tool
// flip msg ID if alts are actually token refs in Tokens rule
if ( probe.dfa.IsTokensRuleDecision )
{
-                setMessageID( ErrorManager.MSG_UNREACHABLE_TOKENS );
+                MessageID = ErrorManager.MSG_UNREACHABLE_TOKENS;
}
}

@@ -72,7 +72,7 @@ namespace Antlr3.Tool
file = fileName;
}

-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();

if ( probe.dfa.IsTokensRuleDecision )
{
@@ -82,7 +82,7 @@ namespace Antlr3.Tool
int altI = alts[i];
String tokenName = probe.GetTokenNameForTokensRuleAlt( altI );
// reset the line/col to the token definition
-                    NFAState ruleStart = probe.dfa.nfa.grammar.getRuleStartState( tokenName );
+                    NFAState ruleStart = probe.dfa.nfa.grammar.GetRuleStartState( tokenName );
line = ruleStart.associatedASTNode.Line;
charPositionInLine = ruleStart.associatedASTNode.CharPositionInLine;
st.SetAttribute( "tokens", tokenName );
diff --git a/Antlr3/Tool/Interpreter.cs b/Antlr3/Tool/Interpreter.cs
index 6571e3a..a16f26a 100644
--- a/Antlr3/Tool/Interpreter.cs
+++ b/Antlr3/Tool/Interpreter.cs
@@ -80,7 +80,7 @@ namespace Antlr3.Tool
{
if ( !ruleName.Equals( Grammar.ARTIFICIAL_TOKENS_RULENAME ) )
{
-                    int type = g.getTokenType( ruleName );
+                    int type = g.GetTokenType( ruleName );
int channel = TokenConstants.DefaultChannel;
token = new CommonToken( (ICharStream)outer.input, type, channel, 0, 0 );
}
@@ -118,13 +118,13 @@ namespace Antlr3.Tool
{
try
{
-                    token = scan( Grammar.ARTIFICIAL_TOKENS_RULENAME, null );
+                    token = Scan( Grammar.ARTIFICIAL_TOKENS_RULENAME, null );
break;
}
catch ( RecognitionException re )
{
// report a problem and try for another
-                    reportScanError( re );
+                    ReportScanError( re );
continue;
}
}
@@ -152,7 +152,7 @@ namespace Antlr3.Tool
*
*  Return the token type associated with the final rule end state.
*/
-        public virtual void scan( String startRule,
+        public virtual void Scan( String startRule,
IDebugEventListener actions,
IList visitedStates )
{
@@ -163,72 +163,72 @@ namespace Antlr3.Tool
ICharStream @in = (ICharStream)this.input;
//Console.Out.WriteLine( "scan(" + startRule + ",'" + @in.substring( @in.Index, @in.Size() - 1 ) + "')" );
// Build NFAs/DFAs from the grammar AST if NFAs haven't been built yet
-            if ( grammar.getRuleStartState( startRule ) == null )
+            if ( grammar.GetRuleStartState( startRule ) == null )
{
-                grammar.buildNFA();
+                grammar.BuildNFA();
}

if ( !grammar.AllDecisionDFAHaveBeenCreated )
{
// Create the DFA predictors for each decision
-                grammar.createLookaheadDFAs();
+                grammar.CreateLookaheadDFAs();
}

// do the parse
Stack<object> ruleInvocationStack = new Stack<object>();
-            NFAState start = grammar.getRuleStartState( startRule );
-            NFAState stop = grammar.getRuleStopState( startRule );
-            parseEngine( startRule, start, stop, @in, ruleInvocationStack,
+            NFAState start = grammar.GetRuleStartState( startRule );
+            NFAState stop = grammar.GetRuleStopState( startRule );
+            ParseEngine( startRule, start, stop, @in, ruleInvocationStack,
actions, visitedStates );
}

-        public virtual CommonToken scan( String startRule )
+        public virtual CommonToken Scan( String startRule )
{
-            return scan( startRule, null );
+            return Scan( startRule, null );
}

-        public virtual CommonToken scan( String startRule,
+        public virtual CommonToken Scan( String startRule,
IList visitedStates )
{
LexerActionGetTokenType actions = new LexerActionGetTokenType( this, grammar );
-            scan( startRule, actions, visitedStates );
+            Scan( startRule, actions, visitedStates );
return actions.token;
}

-        public virtual void parse( String startRule,
+        public virtual void Parse( String startRule,
IDebugEventListener actions,
IList visitedStates )
{
//Console.Out.WriteLine( "parse(" + startRule + ")" );
// Build NFAs/DFAs from the grammar AST if NFAs haven't been built yet
-            if ( grammar.getRuleStartState( startRule ) == null )
+            if ( grammar.GetRuleStartState( startRule ) == null )
{
-                grammar.buildNFA();
+                grammar.BuildNFA();
}
if ( !grammar.AllDecisionDFAHaveBeenCreated )
{
// Create the DFA predictors for each decision
-                grammar.createLookaheadDFAs();
+                grammar.CreateLookaheadDFAs();
}
// do the parse
Stack<object> ruleInvocationStack = new Stack<object>();
-            NFAState start = grammar.getRuleStartState( startRule );
-            NFAState stop = grammar.getRuleStopState( startRule );
-            parseEngine( startRule, start, stop, input, ruleInvocationStack,
+            NFAState start = grammar.GetRuleStartState( startRule );
+            NFAState stop = grammar.GetRuleStopState( startRule );
+            ParseEngine( startRule, start, stop, input, ruleInvocationStack,
actions, visitedStates );
}

-        public virtual ParseTree parse( String startRule )
+        public virtual ParseTree Parse( String startRule )
{
-            return parse( startRule, null );
+            return Parse( startRule, null );
}

-        public virtual ParseTree parse( String startRule, IList visitedStates )
+        public virtual ParseTree Parse( String startRule, IList visitedStates )
{
ParseTreeBuilder actions = new ParseTreeBuilder( grammar.name );
try
{
-                parse( startRule, actions, visitedStates );
+                Parse( startRule, actions, visitedStates );
}
catch ( RecognitionException /*re*/ )
{
@@ -240,7 +240,7 @@ namespace Antlr3.Tool
}

/** Fill a list of all NFA states visited during the parse */
-        protected virtual void parseEngine( String startRule,
+        protected virtual void ParseEngine( String startRule,
NFAState start,
NFAState stop,
IIntStream input,
@@ -262,10 +262,10 @@ namespace Antlr3.Tool
}
//Console.Out.WriteLine( "parse state " + s.stateNumber + " input=" + s.nfa.grammar.getTokenDisplayName( t ) );
// CASE 1: decision state
-                if ( s.DecisionNumber > 0 && s.nfa.grammar.getNumberOfAltsForDecisionNFA( s ) > 1 )
+                if ( s.DecisionNumber > 0 && s.nfa.grammar.GetNumberOfAltsForDecisionNFA( s ) > 1 )
{
// decision point, must predict and jump to alt
-                    DFA dfa = s.nfa.grammar.getLookaheadDFA( s.DecisionNumber );
+                    DFA dfa = s.nfa.grammar.GetLookaheadDFA( s.DecisionNumber );
//if ( s.nfa.grammar.type != Grammar.LEXER )
//{
//    Console.Out.WriteLine( "decision: " +
@@ -273,7 +273,7 @@ namespace Antlr3.Tool
//                   " input=" + s.nfa.grammar.getTokenDisplayName( t ) );
//}
int m = input.Mark();
-                    int predictedAlt = predict( dfa );
+                    int predictedAlt = Predict( dfa );
if ( predictedAlt == NFA.INVALID_ALT_NUMBER )
{
String description = dfa.NFADecisionStartState.Description;
@@ -297,14 +297,14 @@ namespace Antlr3.Tool
//    Console.Out.WriteLine( "predicted alt " + predictedAlt + ", parseAlt " + parseAlt );
//}
NFAState alt;
-                    if ( parseAlt > s.nfa.grammar.getNumberOfAltsForDecisionNFA( s ) )
+                    if ( parseAlt > s.nfa.grammar.GetNumberOfAltsForDecisionNFA( s ) )
{
// implied branch of loop etc...
alt = s.nfa.grammar.nfa.GetState( s.endOfBlockStateNumber );
}
else
{
-                        alt = s.nfa.grammar.getNFAStateForAltOfDecision( s, parseAlt );
+                        alt = s.nfa.grammar.GetNFAStateForAltOfDecision( s, parseAlt );
}
s = (NFAState)alt.transition[0].target;
continue;
@@ -362,7 +362,7 @@ namespace Antlr3.Tool
// could be jumping to new grammar, make sure DFA created
if ( !s.nfa.grammar.AllDecisionDFAHaveBeenCreated )
{
-                            s.nfa.grammar.createLookaheadDFAs();
+                            s.nfa.grammar.CreateLookaheadDFAs();
}
}
// CASE 3b: plain old epsilon transition, just move
@@ -446,7 +446,7 @@ namespace Antlr3.Tool
*  input.lookahead(1) must point at the input symbol you want to start
*  predicting with.
*/
-        public int predict( DFA dfa )
+        public int Predict( DFA dfa )
{
DFAState s = dfa.startState;
int c = input.LA( 1 );
@@ -491,7 +491,7 @@ namespace Antlr3.Tool
return s.GetUniquelyPredictedAlt();
}

-        public virtual void reportScanError( RecognitionException re )
+        public virtual void ReportScanError( RecognitionException re )
{
ICharStream cs = (ICharStream)input;
// print as good of a message as we can, given that we do not have
diff --git a/Antlr3/Tool/LeftRecursionCyclesMessage.cs b/Antlr3/Tool/LeftRecursionCyclesMessage.cs
index 9c6da06..92c6d1f 100644
--- a/Antlr3/Tool/LeftRecursionCyclesMessage.cs
+++ b/Antlr3/Tool/LeftRecursionCyclesMessage.cs
@@ -54,7 +54,7 @@ namespace Antlr3.Tool

public override String ToString()
{
-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
st.SetAttribute( "listOfCycles", cycles );
return base.ToString( st );
}
diff --git a/Antlr3/Tool/Message.cs b/Antlr3/Tool/Message.cs
index b6d338f..a095a97 100644
--- a/Antlr3/Tool/Message.cs
+++ b/Antlr3/Tool/Message.cs
@@ -73,31 +73,50 @@ namespace Antlr3.Tool

public Message( int msgID, object arg, object arg2 )
{
-            setMessageID( msgID );
+            MessageID = msgID;
this.arg = arg;
this.arg2 = arg2;
}

-        public virtual void setLine( int line )
+        public virtual int Line
{
-            this.line = line;
+            get
+            {
+                return line;
+            }
+            set
+            {
+                line = value;
+            }
}
-
-        public virtual void setColumn( int column )
+        public virtual int Column
{
-            this.charPositionInLine = column;
+            get
+            {
+                return charPositionInLine;
+            }
+            set
+            {
+                charPositionInLine = value;
+            }
}
-
-        public virtual void setMessageID( int msgID )
+        public virtual int MessageID
{
-            this.msgID = msgID;
-            msgST = ErrorManager.getMessage( msgID );
+            get
+            {
+                return msgID;
+            }
+            set
+            {
+                msgID = value;
+                msgST = ErrorManager.GetMessage( msgID );
+            }
}

/** Return a new template instance every time someone tries to print
*  a Message.
*/
-        public virtual StringTemplate getMessageTemplate()
+        public virtual StringTemplate GetMessageTemplate()
{
return msgST.GetInstanceOf();
}
@@ -105,7 +124,7 @@ namespace Antlr3.Tool
/** Return a new template instance for the location part of a Message.
*  TODO: Is this really necessary? -Kay
*/
-        public virtual StringTemplate getLocationTemplate()
+        public virtual StringTemplate GetLocationTemplate()
{
return locationST.GetInstanceOf();
}
@@ -113,9 +132,9 @@ namespace Antlr3.Tool
public virtual string ToString( StringTemplate messageST )
{
// setup the location
-            locationST = ErrorManager.getLocationFormat();
-            reportST = ErrorManager.getReportFormat();
-            messageFormatST = ErrorManager.getMessageFormat();
+            locationST = ErrorManager.GetLocationFormat();
+            reportST = ErrorManager.GetReportFormat();
+            messageFormatST = ErrorManager.GetMessageFormat();
bool locationValid = false;
if ( line != -1 )
{
@@ -141,7 +160,7 @@ namespace Antlr3.Tool
reportST.SetAttribute( "location", locationST );
}
reportST.SetAttribute( "message", messageFormatST );
-            reportST.SetAttribute( "type", ErrorManager.getMessageType( msgID ) );
+            reportST.SetAttribute( "type", ErrorManager.GetMessageType( msgID ) );

return reportST.ToString();
}
diff --git a/Antlr3/Tool/NFAFactory.cs b/Antlr3/Tool/NFAFactory.cs
index 5c5e5b6..4883f92 100644
--- a/Antlr3/Tool/NFAFactory.cs
+++ b/Antlr3/Tool/NFAFactory.cs
@@ -80,19 +80,7 @@ namespace Antlr3.Tool
}
#endregion

-        [Obsolete]
-        public Rule getCurrentRule()
-        {
-            return CurrentRule;
-        }
-
-        [Obsolete]
-        public void setCurrentRule( Rule value )
-        {
-            CurrentRule = value;
-        }
-
-        public virtual NFAState newState()
+        public virtual NFAState NewState()
{
NFAState n = new NFAState( nfa );
int state = nfa.GetNewNFAStateNumber();
@@ -110,7 +98,7 @@ namespace Antlr3.Tool
*  This only removes 195 states from the java.g's NFA, but every little
*  bit helps.  Perhaps I can improve in the future.
*/
-        public virtual void optimizeAlternative( StateCluster alt )
+        public virtual void OptimizeAlternative( StateCluster alt )
{
NFAState s = alt.left;
while ( s != alt.right )
@@ -146,30 +134,30 @@ namespace Antlr3.Tool
}

/** From label A build Graph o-A->o */
-        public virtual StateCluster build_Atom( int label, GrammarAST associatedAST )
+        public virtual StateCluster BuildAtom( int label, GrammarAST associatedAST )
{
-            NFAState left = newState();
-            NFAState right = newState();
+            NFAState left = NewState();
+            NFAState right = NewState();
left.associatedASTNode = associatedAST;
right.associatedASTNode = associatedAST;
-            transitionBetweenStates( left, right, label );
+            TransitionBetweenStates( left, right, label );
StateCluster g = new StateCluster( left, right );
return g;
}

-        public virtual StateCluster build_Atom( GrammarAST atomAST )
+        public virtual StateCluster BuildAtom( GrammarAST atomAST )
{
-            int tokenType = nfa.grammar.getTokenType( atomAST.Text );
-            return build_Atom( tokenType, atomAST );
+            int tokenType = nfa.grammar.GetTokenType( atomAST.Text );
+            return BuildAtom( tokenType, atomAST );
}

/** From set build single edge graph o->o-set->o.  To conform to
*  what an alt block looks like, must have extra state on left.
*/
-        public virtual StateCluster build_Set( IIntSet set, GrammarAST associatedAST )
+        public virtual StateCluster BuildSet( IIntSet set, GrammarAST associatedAST )
{
-            NFAState left = newState();
-            NFAState right = newState();
+            NFAState left = NewState();
+            NFAState right = NewState();
left.associatedASTNode = associatedAST;
right.associatedASTNode = associatedAST;
Label label = new Label( set );
@@ -183,7 +171,7 @@ namespace Antlr3.Tool
/** Can only complement block of simple alts; can complement build_Set()
*  result, that is.  Get set and complement, replace old with complement.
*/
-        public StateCluster build_AlternativeBlockComplement( StateCluster blk )
+        public StateCluster BuildAlternativeBlockComplement( StateCluster blk )
{
State s0 = blk.left;
IIntSet set = getCollapsedBlockAsSet( s0 );
@@ -198,10 +186,10 @@ namespace Antlr3.Tool
}
#endif

-        public virtual StateCluster build_Range( int a, int b )
+        public virtual StateCluster BuildRange( int a, int b )
{
-            NFAState left = newState();
-            NFAState right = newState();
+            NFAState left = NewState();
+            NFAState right = NewState();
Label label = new Label( IntervalSet.Of( a, b ) );
Transition e = new Transition( label, right );
left.AddTransition( e );
@@ -211,10 +199,10 @@ namespace Antlr3.Tool

/** From char 'c' build StateCluster o-intValue(c)->o
*/
-        public virtual StateCluster build_CharLiteralAtom( GrammarAST charLiteralAST )
+        public virtual StateCluster BuildCharLiteralAtom( GrammarAST charLiteralAST )
{
-            int c = Grammar.getCharValueFromGrammarCharLiteral( charLiteralAST.Text );
-            return build_Atom( c, charLiteralAST );
+            int c = Grammar.GetCharValueFromGrammarCharLiteral( charLiteralAST.Text );
+            return BuildAtom( c, charLiteralAST );
}

/** From char 'c' build StateCluster o-intValue(c)->o
@@ -222,11 +210,11 @@ namespace Antlr3.Tool
*  actual unicode 16-bit now, of course, by default.
*  TODO not supplemental char clean!
*/
-        public virtual StateCluster build_CharRange( string a, string b )
+        public virtual StateCluster BuildCharRange( string a, string b )
{
-            int from = Grammar.getCharValueFromGrammarCharLiteral( a );
-            int to = Grammar.getCharValueFromGrammarCharLiteral( b );
-            return build_Range( from, to );
+            int from = Grammar.GetCharValueFromGrammarCharLiteral( a );
+            int to = Grammar.GetCharValueFromGrammarCharLiteral( b );
+            return BuildRange( from, to );
}

/** For a non-lexer, just build a simple token reference atom.
@@ -235,28 +223,28 @@ namespace Antlr3.Tool
*  the DFA.  Machine== o-'f'->o-'o'->o-'g'->o and has n+1 states
*  for n characters.
*/
-        public virtual StateCluster build_StringLiteralAtom( GrammarAST stringLiteralAST )
+        public virtual StateCluster BuildStringLiteralAtom( GrammarAST stringLiteralAST )
{
if ( nfa.grammar.type == Grammar.LEXER )
{
StringBuilder chars =
-                    Grammar.getUnescapedStringFromGrammarStringLiteral( stringLiteralAST.Text );
-                NFAState first = newState();
+                    Grammar.GetUnescapedStringFromGrammarStringLiteral( stringLiteralAST.Text );
+                NFAState first = NewState();
NFAState last = null;
NFAState prev = first;
for ( int i = 0; i < chars.Length; i++ )
{
int c = chars[i];
-                    NFAState next = newState();
-                    transitionBetweenStates( prev, next, c );
+                    NFAState next = NewState();
+                    TransitionBetweenStates( prev, next, c );
prev = last = next;
}
return new StateCluster( first, last );
}

// a simple token reference in non-Lexers
-            int tokenType = nfa.grammar.getTokenType( stringLiteralAST.Text );
-            return build_Atom( tokenType, stringLiteralAST );
+            int tokenType = nfa.grammar.GetTokenType( stringLiteralAST.Text );
+            return BuildAtom( tokenType, stringLiteralAST );
}

/** For reference to rule r, build
@@ -274,12 +262,12 @@ namespace Antlr3.Tool
*
*  TODO add to codegen: collapse alt blks that are sets into single matchSet
*/
-        public virtual StateCluster build_RuleRef( Rule refDef, NFAState ruleStart )
+        public virtual StateCluster BuildRuleRef( Rule refDef, NFAState ruleStart )
{
//System.Console.Out.WriteLine( "building ref to rule " + nfa.grammar.name + "." + refDef.name );
-            NFAState left = newState();
+            NFAState left = NewState();
//left.Description = "ref to " + ruleStart.Description;
-            NFAState right = newState();
+            NFAState right = NewState();
//right.Description = "NFAState following ref to " + ruleStart.Description;
Transition e = new RuleClosureTransition( refDef, ruleStart, right );
left.AddTransition( e );
@@ -288,11 +276,11 @@ namespace Antlr3.Tool
}

/** From an empty alternative build StateCluster o-e->o */
-        public virtual StateCluster build_Epsilon()
+        public virtual StateCluster BuildEpsilon()
{
-            NFAState left = newState();
-            NFAState right = newState();
-            transitionBetweenStates( left, right, Label.EPSILON );
+            NFAState left = NewState();
+            NFAState right = NewState();
+            TransitionBetweenStates( left, right, Label.EPSILON );
StateCluster g = new StateCluster( left, right );
return g;
}
@@ -301,15 +289,15 @@ namespace Antlr3.Tool
*  predicate action.  The pred is a pointer into the AST of
*  the SEMPRED token.
*/
-        public virtual StateCluster build_SemanticPredicate( GrammarAST pred )
+        public virtual StateCluster BuildSemanticPredicate( GrammarAST pred )
{
// don't count syn preds
if ( !pred.Text.StartsWith( Grammar.SYNPRED_RULE_PREFIX, StringComparison.OrdinalIgnoreCase ) )
{
nfa.grammar.numberOfSemanticPredicates++;
}
-            NFAState left = newState();
-            NFAState right = newState();
+            NFAState left = NewState();
+            NFAState right = NewState();
Transition e = new Transition( new PredicateLabel( pred ), right );
left.AddTransition( e );
StateCluster g = new StateCluster( left, right );
@@ -321,10 +309,10 @@ namespace Antlr3.Tool
*  It slows things down a bit, but I must ignore predicates after
*  having seen an action (5-5-2008).
*/
-        public virtual StateCluster build_Action( GrammarAST action )
+        public virtual StateCluster BuildAction( GrammarAST action )
{
-            NFAState left = newState();
-            NFAState right = newState();
+            NFAState left = NewState();
+            NFAState right = NewState();
Transition e = new Transition( new ActionLabel( action ), right );
left.AddTransition( e );
return new StateCluster( left, right );
@@ -338,7 +326,7 @@ namespace Antlr3.Tool
*  not invoked by another rule (they can only be invoked from outside).
*  These are the start rules.
*/
-        public virtual int build_EOFStates( IEnumerable<Rule> rules )
+        public virtual int BuildEofStates( IEnumerable<Rule> rules )
{
int numberUnInvokedRules = 0;
foreach ( Rule r in rules )
@@ -349,7 +337,7 @@ namespace Antlr3.Tool
{
// if so, then don't let algorithm fall off the end of
// the rule, make it hit EOF/EOT.
-                    build_EOFState( endNFAState );
+                    BuildEofState( endNFAState );
// track how many rules have been invoked by another rule
numberUnInvokedRules++;
}
@@ -361,9 +349,9 @@ namespace Antlr3.Tool
*  in the case of a lexer grammar, an EOT token when the conversion
*  hits the end of a rule.
*/
-        private void build_EOFState( NFAState endNFAState )
+        private void BuildEofState( NFAState endNFAState )
{
-            NFAState end = newState();
+            NFAState end = NewState();
int label = Label.EOF;
if ( nfa.grammar.type == Grammar.LEXER )
{
@@ -382,7 +370,7 @@ namespace Antlr3.Tool
*
*  As a convenience, return B if A is null or return A if B is null.
*/
-        public virtual StateCluster build_AB( StateCluster A, StateCluster B )
+        public virtual StateCluster BuildAB( StateCluster A, StateCluster B )
{
if ( A == null )
{
@@ -392,7 +380,7 @@ namespace Antlr3.Tool
{
return A;
}
-            transitionBetweenStates( A.right, B.left, Label.EPSILON );
+            TransitionBetweenStates( A.right, B.left, Label.EPSILON );
StateCluster g = new StateCluster( A.left, B.right );
return g;
}
@@ -401,7 +389,7 @@ namespace Antlr3.Tool
*
*  o->o-'a'..'b'->o->o (last NFAState is blockEndNFAState pointed to by all alts)
*/
-        public virtual StateCluster build_AlternativeBlockFromSet( StateCluster set )
+        public virtual StateCluster BuildAlternativeBlockFromSet( StateCluster set )
{
if ( set == null )
{
@@ -409,8 +397,8 @@ namespace Antlr3.Tool
}

// single alt, no decision, just return only alt state cluster
-            NFAState startOfAlt = newState(); // must have this no matter what
-            transitionBetweenStates( startOfAlt, set.left, Label.EPSILON );
+            NFAState startOfAlt = NewState(); // must have this no matter what
+            TransitionBetweenStates( startOfAlt, set.left, Label.EPSILON );

return new StateCluster( startOfAlt, set.right );
}
@@ -438,7 +426,7 @@ namespace Antlr3.Tool
*
*  Set alt number (1..n) in the left-Transition NFAState.
*/
-        public virtual StateCluster build_AlternativeBlock( ICollection<StateCluster> alternativeStateClusters )
+        public virtual StateCluster BuildAlternativeBlock( ICollection<StateCluster> alternativeStateClusters )
{
StateCluster result = null;
if ( alternativeStateClusters == null || alternativeStateClusters.Count == 0 )
@@ -451,8 +439,8 @@ namespace Antlr3.Tool
{
// single alt, no decision, just return only alt state cluster
StateCluster g = alternativeStateClusters.First();
-                NFAState startOfAlt = newState(); // must have this no matter what
-                transitionBetweenStates( startOfAlt, g.left, Label.EPSILON );
+                NFAState startOfAlt = NewState(); // must have this no matter what
+                TransitionBetweenStates( startOfAlt, g.left, Label.EPSILON );

//System.Console.Out.WriteLine( "### opt saved start/stop end in (...)" );
return new StateCluster( startOfAlt, g.right );
@@ -464,16 +452,16 @@ namespace Antlr3.Tool
// (always)
NFAState prevAlternative = null; // tracks prev so we can link to next alt
NFAState firstAlt = null;
-            NFAState blockEndNFAState = newState();
+            NFAState blockEndNFAState = NewState();
blockEndNFAState.Description = "end block";
int altNum = 1;
foreach ( StateCluster g in alternativeStateClusters )
{
// add begin NFAState for this alt connected by epsilon
-                NFAState left = newState();
+                NFAState left = NewState();
left.Description = "alt " + altNum + " of ()";
-                transitionBetweenStates( left, g.left, Label.EPSILON );
-                transitionBetweenStates( g.right, blockEndNFAState, Label.EPSILON );
+                TransitionBetweenStates( left, g.left, Label.EPSILON );
+                TransitionBetweenStates( g.right, blockEndNFAState, Label.EPSILON );
// Are we the first alternative?
if ( firstAlt == null )
{
@@ -482,7 +470,7 @@ namespace Antlr3.Tool
else
{
// if not first alternative, must link to this alt from previous
-                    transitionBetweenStates( prevAlternative, left, Label.EPSILON );
+                    TransitionBetweenStates( prevAlternative, left, Label.EPSILON );
}
prevAlternative = left;
altNum++;
@@ -508,25 +496,25 @@ namespace Antlr3.Tool
*
*  or, if A is a block, just add an empty alt to the end of the block
*/
-        public virtual StateCluster build_Aoptional( StateCluster A )
+        public virtual StateCluster BuildAoptional( StateCluster A )
{
StateCluster g = null;
-            int n = nfa.grammar.getNumberOfAltsForDecisionNFA( A.left );
+            int n = nfa.grammar.GetNumberOfAltsForDecisionNFA( A.left );
if ( n == 1 )
{
// no decision, just wrap in an optional path
//NFAState decisionState = newState();
NFAState decisionState = A.left; // resuse left edge
decisionState.Description = "only alt of ()? block";
-                NFAState emptyAlt = newState();
+                NFAState emptyAlt = NewState();
emptyAlt.Description = "epsilon path of ()? block";
NFAState blockEndNFAState = null;
-                blockEndNFAState = newState();
-                transitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON );
+                blockEndNFAState = NewState();
+                TransitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON );
blockEndNFAState.Description = "end ()? block";
//transitionBetweenStates(decisionState, A.left, Label.EPSILON);
-                transitionBetweenStates( decisionState, emptyAlt, Label.EPSILON );
-                transitionBetweenStates( emptyAlt, blockEndNFAState, Label.EPSILON );
+                TransitionBetweenStates( decisionState, emptyAlt, Label.EPSILON );
+                TransitionBetweenStates( emptyAlt, blockEndNFAState, Label.EPSILON );

// set EOB markers for Jean
decisionState.endOfBlockStateNumber = blockEndNFAState.stateNumber;
@@ -538,11 +526,11 @@ namespace Antlr3.Tool
{
// a decision block, add an empty alt
NFAState lastRealAlt =
-                        nfa.grammar.getNFAStateForAltOfDecision( A.left, n );
-                NFAState emptyAlt = newState();
+                        nfa.grammar.GetNFAStateForAltOfDecision( A.left, n );
+                NFAState emptyAlt = NewState();
emptyAlt.Description = "epsilon path of ()? block";
-                transitionBetweenStates( lastRealAlt, emptyAlt, Label.EPSILON );
-                transitionBetweenStates( emptyAlt, A.right, Label.EPSILON );
+                TransitionBetweenStates( lastRealAlt, emptyAlt, Label.EPSILON );
+                TransitionBetweenStates( emptyAlt, A.right, Label.EPSILON );

// set EOB markers for Jean (I think this is redundant here)
A.left.endOfBlockStateNumber = A.right.stateNumber;
@@ -568,10 +556,10 @@ namespace Antlr3.Tool
*  During analysis we'll call the follow link (transition 1) alt n+1 for
*  an n-alt A block.
*/
-        public virtual StateCluster build_Aplus( StateCluster A )
+        public virtual StateCluster BuildAplus( StateCluster A )
{
-            NFAState left = newState();
-            NFAState blockEndNFAState = newState();
+            NFAState left = NewState();
+            NFAState blockEndNFAState = NewState();
blockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;

// don't reuse A.right as loopback if it's right edge of another block
@@ -579,15 +567,15 @@ namespace Antlr3.Tool
{
// nested A* so make another tail node to be the loop back
// instead of the usual A.right which is the EOB for inner loop
-                NFAState extraRightEdge = newState();
-                transitionBetweenStates( A.right, extraRightEdge, Label.EPSILON );
+                NFAState extraRightEdge = NewState();
+                TransitionBetweenStates( A.right, extraRightEdge, Label.EPSILON );
A.right = extraRightEdge;
}

-            transitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON ); // follow is Transition 1
+            TransitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON ); // follow is Transition 1
// turn A's block end into a loopback (acts like alt 2)
-            transitionBetweenStates( A.right, A.left, Label.EPSILON ); // loop back Transition 2
-            transitionBetweenStates( left, A.left, Label.EPSILON );
+            TransitionBetweenStates( A.right, A.left, Label.EPSILON ); // loop back Transition 2
+            TransitionBetweenStates( left, A.left, Label.EPSILON );

A.right.decisionStateType = NFAState.LOOPBACK;
A.left.decisionStateType = NFAState.BLOCK_START;
@@ -629,13 +617,13 @@ namespace Antlr3.Tool
*  is sufficient to let me make an appropriate enter, exit, loop
*  determination.  See codegen.g
*/
-        public virtual StateCluster build_Astar( StateCluster A )
+        public virtual StateCluster BuildAstar( StateCluster A )
{
-            NFAState bypassDecisionState = newState();
+            NFAState bypassDecisionState = NewState();
bypassDecisionState.Description = "enter loop path of ()* block";
-            NFAState optionalAlt = newState();
+            NFAState optionalAlt = NewState();
optionalAlt.Description = "epsilon path of ()* block";
-            NFAState blockEndNFAState = newState();
+            NFAState blockEndNFAState = NewState();
blockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;

// don't reuse A.right as loopback if it's right edge of another block
@@ -643,22 +631,22 @@ namespace Antlr3.Tool
{
// nested A* so make another tail node to be the loop back
// instead of the usual A.right which is the EOB for inner loop
-                NFAState extraRightEdge = newState();
-                transitionBetweenStates( A.right, extraRightEdge, Label.EPSILON );
+                NFAState extraRightEdge = NewState();
+                TransitionBetweenStates( A.right, extraRightEdge, Label.EPSILON );
A.right = extraRightEdge;
}

// convert A's end block to loopback
A.right.Description = "()* loopback";
// Transition 1 to actual block of stuff
-            transitionBetweenStates( bypassDecisionState, A.left, Label.EPSILON );
+            TransitionBetweenStates( bypassDecisionState, A.left, Label.EPSILON );
// Transition 2 optional to bypass
-            transitionBetweenStates( bypassDecisionState, optionalAlt, Label.EPSILON );
-            transitionBetweenStates( optionalAlt, blockEndNFAState, Label.EPSILON );
+            TransitionBetweenStates( bypassDecisionState, optionalAlt, Label.EPSILON );
+            TransitionBetweenStates( optionalAlt, blockEndNFAState, Label.EPSILON );
// Transition 1 of end block exits
-            transitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON );
+            TransitionBetweenStates( A.right, blockEndNFAState, Label.EPSILON );
// Transition 2 of end block loops
-            transitionBetweenStates( A.right, A.left, Label.EPSILON );
+            TransitionBetweenStates( A.right, A.left, Label.EPSILON );

bypassDecisionState.decisionStateType = NFAState.BYPASS;
A.left.decisionStateType = NFAState.BLOCK_START;
@@ -697,7 +685,7 @@ namespace Antlr3.Tool
*
*  11/28/2005: removed so we can use normal rule construction for Tokens.
*/
-        public NFAState build_ArtificialMatchTokensRuleNFA()
+        public NFAState BuildArtificialMatchTokensRuleNFA()
{
int altNum = 1;
NFAState firstAlt = null; // the start state for the "rule"
@@ -739,10 +727,10 @@ namespace Antlr3.Tool
#endif

/** Build an atom with all possible values in its label */
-        public virtual StateCluster build_Wildcard( GrammarAST associatedAST )
+        public virtual StateCluster BuildWildcard( GrammarAST associatedAST )
{
-            NFAState left = newState();
-            NFAState right = newState();
+            NFAState left = NewState();
+            NFAState right = NewState();
left.associatedASTNode = associatedAST;
right.associatedASTNode = associatedAST;
Label label = new Label( nfa.grammar.TokenTypes ); // char or tokens
@@ -755,23 +743,23 @@ namespace Antlr3.Tool
/** Build a subrule matching ^(. .*) (any tree or node). Let's use
*  (^(. .+) | .) to be safe.
*/
-        public StateCluster build_WildcardTree( GrammarAST associatedAST )
+        public StateCluster BuildWildcardTree( GrammarAST associatedAST )
{
-            StateCluster wildRoot = build_Wildcard( associatedAST );
+            StateCluster wildRoot = BuildWildcard( associatedAST );

-            StateCluster down = build_Atom( Label.DOWN, associatedAST );
-            wildRoot = build_AB( wildRoot, down ); // hook in; . DOWN
+            StateCluster down = BuildAtom( Label.DOWN, associatedAST );
+            wildRoot = BuildAB( wildRoot, down ); // hook in; . DOWN

// make .+
-            StateCluster wildChildren = build_Wildcard( associatedAST );
-            wildChildren = build_Aplus( wildChildren );
-            wildRoot = build_AB( wildRoot, wildChildren ); // hook in; . DOWN .+
+            StateCluster wildChildren = BuildWildcard( associatedAST );
+            wildChildren = BuildAplus( wildChildren );
+            wildRoot = BuildAB( wildRoot, wildChildren ); // hook in; . DOWN .+

-            StateCluster up = build_Atom( Label.UP, associatedAST );
-            wildRoot = build_AB( wildRoot, up ); // hook in; . DOWN .+ UP
+            StateCluster up = BuildAtom( Label.UP, associatedAST );
+            wildRoot = BuildAB( wildRoot, up ); // hook in; . DOWN .+ UP

// make optional . alt
-            StateCluster optionalNodeAlt = build_Wildcard( associatedAST );
+            StateCluster optionalNodeAlt = BuildWildcard( associatedAST );

//List alts = new List<object>();
var alts = new List<StateCluster>()
@@ -779,7 +767,7 @@ namespace Antlr3.Tool
wildRoot,
optionalNodeAlt
};
-            StateCluster blk = build_AlternativeBlock( alts );
+            StateCluster blk = BuildAlternativeBlock( alts );

return blk;
}
@@ -787,7 +775,7 @@ namespace Antlr3.Tool
/** Given a collapsed block of alts (a set of atoms), pull out
*  the set and return it.
*/
-        protected virtual IIntSet getCollapsedBlockAsSet( State blk )
+        protected virtual IIntSet GetCollapsedBlockAsSet( State blk )
{
State s0 = blk;
if ( s0 != null && s0.GetTransition( 0 ) != null )
@@ -805,7 +793,7 @@ namespace Antlr3.Tool
return null;
}

-        private void transitionBetweenStates( NFAState a, NFAState b, int label )
+        private void TransitionBetweenStates( NFAState a, NFAState b, int label )
{
Transition e = new Transition( label, b );
a.AddTransition( e );
diff --git a/Antlr3/Tool/NameSpaceChecker.cs b/Antlr3/Tool/NameSpaceChecker.cs
index 82bf9c3..105a494 100644
--- a/Antlr3/Tool/NameSpaceChecker.cs
+++ b/Antlr3/Tool/NameSpaceChecker.cs
@@ -48,7 +48,7 @@ namespace Antlr3.Tool
this.grammar = grammar;
}

-        public virtual void checkConflicts()
+        public virtual void CheckConflicts()
{
for ( int i = CompositeGrammar.MIN_RULE_INDEX; i < grammar.composite.ruleIndexToRuleList.Count; i++ )
{
@@ -62,7 +62,7 @@ namespace Antlr3.Tool
{
foreach ( Grammar.LabelElementPair pair in r.labelNameSpace.Values )
{
-                        checkForLabelConflict( r, pair.label );
+                        CheckForLabelConflict( r, pair.label );
}
}
// walk rule scope attributes for Rule r
@@ -72,31 +72,31 @@ namespace Antlr3.Tool
for ( int j = 0; j < attributes.Count; j++ )
{
Attribute attribute = (Attribute)attributes.ElementAt( j );
-                        checkForRuleScopeAttributeConflict( r, attribute );
+                        CheckForRuleScopeAttributeConflict( r, attribute );
}
}
-                checkForRuleDefinitionProblems( r );
-                checkForRuleArgumentAndReturnValueConflicts( r );
+                CheckForRuleDefinitionProblems( r );
+                CheckForRuleArgumentAndReturnValueConflicts( r );
}
// check all global scopes against tokens
foreach ( AttributeScope scope in grammar.GlobalScopes.Values )
{
-                checkForGlobalScopeTokenConflict( scope );
+                CheckForGlobalScopeTokenConflict( scope );
}
// check for missing rule, tokens
-            lookForReferencesToUndefinedSymbols();
+            LookForReferencesToUndefinedSymbols();
}

-        protected virtual void checkForRuleArgumentAndReturnValueConflicts( Rule r )
+        protected virtual void CheckForRuleArgumentAndReturnValueConflicts( Rule r )
{
if ( r.returnScope != null )
{
-                HashSet<object> conflictingKeys = r.returnScope.intersection( r.parameterScope );
+                HashSet<object> conflictingKeys = r.returnScope.Intersection( r.parameterScope );
if ( conflictingKeys != null )
{
foreach ( string key in conflictingKeys )
{
-                        ErrorManager.grammarError(
+                        ErrorManager.GrammarError(
ErrorManager.MSG_ARG_RETVAL_CONFLICT,
grammar,
r.tree.Token,
@@ -107,7 +107,7 @@ namespace Antlr3.Tool
}
}

-        protected virtual void checkForRuleDefinitionProblems( Rule r )
+        protected virtual void CheckForRuleDefinitionProblems( Rule r )
{
string ruleName = r.name;
IToken ruleToken = r.tree.Token;
@@ -123,13 +123,13 @@ namespace Antlr3.Tool
{
msgID = ErrorManager.MSG_PARSER_RULES_NOT_ALLOWED;
}
-            else if ( grammar.getGlobalScope( ruleName ) != null )
+            else if ( grammar.GetGlobalScope( ruleName ) != null )
{
msgID = ErrorManager.MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE;
}
if ( msgID != 0 )
{
-                ErrorManager.grammarError( msgID, grammar, ruleToken, ruleName );
+                ErrorManager.GrammarError( msgID, grammar, ruleToken, ruleName );
}
}

@@ -140,23 +140,23 @@ namespace Antlr3.Tool
*  If you ref ID in a combined grammar and don't define ID as a lexer rule
*  it is an error.
*/
-        protected virtual void lookForReferencesToUndefinedSymbols()
+        protected virtual void LookForReferencesToUndefinedSymbols()
{
// for each rule ref, ask if there is a rule definition
foreach ( GrammarAST refAST in grammar.ruleRefs )
{
IToken tok = refAST.token;
string ruleName = tok.Text;
-                Rule localRule = grammar.getLocallyDefinedRule( ruleName );
-                Rule rule = grammar.getRule( ruleName );
+                Rule localRule = grammar.GetLocallyDefinedRule( ruleName );
+                Rule rule = grammar.GetRule( ruleName );
if ( localRule == null && rule != null )
{ // imported rule?
grammar.delegatedRuleReferences.Add( rule );
rule.imported = true;
}
-                if ( rule == null && grammar.getTokenType( ruleName ) != Label.EOF )
+                if ( rule == null && grammar.GetTokenType( ruleName ) != Label.EOF )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_UNDEFINED_RULE_REF,
+                    ErrorManager.GrammarError( ErrorManager.MSG_UNDEFINED_RULE_REF,
grammar,
tok,
ruleName );
@@ -170,9 +170,9 @@ namespace Antlr3.Tool
{
string tokenID = tok.Text;
if ( !grammar.composite.lexerRules.Contains( tokenID ) &&
-                         grammar.getTokenType( tokenID ) != Label.EOF )
+                         grammar.GetTokenType( tokenID ) != Label.EOF )
{
-                        ErrorManager.grammarWarning( ErrorManager.MSG_NO_TOKEN_DEFINITION,
+                        ErrorManager.GrammarWarning( ErrorManager.MSG_NO_TOKEN_DEFINITION,
grammar,
tok,
tokenID );
@@ -183,12 +183,12 @@ namespace Antlr3.Tool
foreach ( GrammarAST scopeAST in grammar.scopedRuleRefs )
{
// ^(DOT ID atom)
-                Grammar scopeG = grammar.composite.getGrammar( scopeAST.Text );
+                Grammar scopeG = grammar.composite.GetGrammar( scopeAST.Text );
GrammarAST refAST = (GrammarAST)scopeAST.GetChild( 1 );
string ruleName = refAST.Text;
if ( scopeG == null )
{
-                    ErrorManager.grammarError( ErrorManager.MSG_NO_SUCH_GRAMMAR_SCOPE,
+                    ErrorManager.GrammarError( ErrorManager.MSG_NO_SUCH_GRAMMAR_SCOPE,
grammar,
scopeAST.Token,
scopeAST.Text,
@@ -196,10 +196,10 @@ namespace Antlr3.Tool
}
else
{
-                    Rule rule = grammar.getRule( scopeG.name, ruleName );
+                    Rule rule = grammar.GetRule( scopeG.name, ruleName );
if ( rule == null )
{
-                        ErrorManager.grammarError( ErrorManager.MSG_NO_SUCH_RULE_IN_SCOPE,
+                        ErrorManager.GrammarError( ErrorManager.MSG_NO_SUCH_RULE_IN_SCOPE,
grammar,
scopeAST.Token,
scopeAST.Text,
@@ -209,11 +209,11 @@ namespace Antlr3.Tool
}
}

-        protected virtual void checkForGlobalScopeTokenConflict( AttributeScope scope )
+        protected virtual void CheckForGlobalScopeTokenConflict( AttributeScope scope )
{
-            if ( grammar.getTokenType( scope.Name ) != Label.INVALID )
+            if ( grammar.GetTokenType( scope.Name ) != Label.INVALID )
{
-                ErrorManager.grammarError( ErrorManager.MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE,
+                ErrorManager.GrammarError( ErrorManager.MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE,
grammar, null, scope.Name );
}
}
@@ -221,7 +221,7 @@ namespace Antlr3.Tool
/** Check for collision of a rule-scope dynamic attribute with:
*  arg, return value, rule name itself.  Labels are checked elsewhere.
*/
-        public virtual void checkForRuleScopeAttributeConflict( Rule r, Attribute attribute )
+        public virtual void CheckForRuleScopeAttributeConflict( Rule r, Attribute attribute )
{
int msgID = 0;
object arg2 = null;
@@ -231,15 +231,15 @@ namespace Antlr3.Tool
msgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE;
arg2 = r.name;
}
-            else if ( ( r.returnScope != null && r.returnScope.getAttribute( attrName ) != null ) ||
-                      ( r.parameterScope != null && r.parameterScope.getAttribute( attrName ) != null ) )
+            else if ( ( r.returnScope != null && r.returnScope.GetAttribute( attrName ) != null ) ||
+                      ( r.parameterScope != null && r.parameterScope.GetAttribute( attrName ) != null ) )
{
msgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL;
arg2 = r.name;
}
if ( msgID != 0 )
{
-                ErrorManager.grammarError( msgID, grammar, r.tree.Token, attrName, arg2 );
+                ErrorManager.GrammarError( msgID, grammar, r.tree.Token, attrName, arg2 );
}
}

@@ -248,42 +248,42 @@ namespace Antlr3.Tool
*  return values, parameters, and rule-scope dynamic attributes
*  defined in surrounding rule.
*/
-        protected virtual void checkForLabelConflict( Rule r, IToken label )
+        protected virtual void CheckForLabelConflict( Rule r, IToken label )
{
int msgID = 0;
object arg2 = null;
-            if ( grammar.getGlobalScope( label.Text ) != null )
+            if ( grammar.GetGlobalScope( label.Text ) != null )
{
msgID = ErrorManager.MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE;
}
-            else if ( grammar.getRule( label.Text ) != null )
+            else if ( grammar.GetRule( label.Text ) != null )
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE;
}
-            else if ( grammar.getTokenType( label.Text ) != Label.INVALID )
+            else if ( grammar.GetTokenType( label.Text ) != Label.INVALID )
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_TOKEN;
}
-            else if ( r.ruleScope != null && r.ruleScope.getAttribute( label.Text ) != null )
+            else if ( r.ruleScope != null && r.ruleScope.GetAttribute( label.Text ) != null )
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE;
arg2 = r.name;
}
-            else if ( ( r.returnScope != null && r.returnScope.getAttribute( label.Text ) != null ) ||
-                      ( r.parameterScope != null && r.parameterScope.getAttribute( label.Text ) != null ) )
+            else if ( ( r.returnScope != null && r.returnScope.GetAttribute( label.Text ) != null ) ||
+                      ( r.parameterScope != null && r.parameterScope.GetAttribute( label.Text ) != null ) )
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL;
arg2 = r.name;
}
if ( msgID != 0 )
{
-                ErrorManager.grammarError( msgID, grammar, label, label.Text, arg2 );
+                ErrorManager.GrammarError( msgID, grammar, label, label.Text, arg2 );
}
}

/** If type of previous label differs from new label's type, that's an error.
*/
-        public virtual bool checkForLabelTypeMismatch( Rule r, IToken label, int type )
+        public virtual bool CheckForLabelTypeMismatch( Rule r, IToken label, int type )
{
Grammar.LabelElementPair prevLabelPair =
(Grammar.LabelElementPair)r.labelNameSpace.get( label.Text );
@@ -295,7 +295,7 @@ namespace Antlr3.Tool
string typeMismatchExpr =
Grammar.LabelTypeToString[type] + "!=" +
Grammar.LabelTypeToString[prevLabelPair.type];
-                    ErrorManager.grammarError(
+                    ErrorManager.GrammarError(
ErrorManager.MSG_LABEL_TYPE_CONFLICT,
grammar,
label,
diff --git a/Antlr3/Tool/NonRegularDecisionMessage.cs b/Antlr3/Tool/NonRegularDecisionMessage.cs
index 92515d2..0a10217 100644
--- a/Antlr3/Tool/NonRegularDecisionMessage.cs
+++ b/Antlr3/Tool/NonRegularDecisionMessage.cs
@@ -63,7 +63,7 @@ namespace Antlr3.Tool
file = fileName;
}

-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
String ruleName = probe.dfa.NFADecisionStartState.enclosingRule.name;
st.SetAttribute( "ruleName", ruleName );
List<int> sortedAlts = new List<int>();
diff --git a/Antlr3/Tool/RecursionOverflowMessage.cs b/Antlr3/Tool/RecursionOverflowMessage.cs
index 1367d41..98ad303 100644
--- a/Antlr3/Tool/RecursionOverflowMessage.cs
+++ b/Antlr3/Tool/RecursionOverflowMessage.cs
@@ -74,7 +74,7 @@ namespace Antlr3.Tool
file = fileName;
}

-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
st.SetAttribute( "targetRules", targetRules );
st.SetAttribute( "alt", alt );
st.SetAttribute( "callSiteStates", callSiteStates );
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index 3b86693..195140a 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -208,61 +208,61 @@ namespace Antlr3.Tool
{
get
{
-                return getHasMultipleReturnValues();
+                return GetHasMultipleReturnValues();
}
}
public bool HasReturnValue
{
get
{
-                return getHasReturnValue();
+                return GetHasReturnValue();
}
}
public bool HasSingleReturnValue
{
get
{
-                return getHasSingleReturnValue();
+                return GetHasSingleReturnValue();
}
}
public ICollection<GrammarAST> InlineActions
{
get
{
-                return getInlineActions();
+                return GetInlineActions();
}
}
public IDictionary RuleLabels
{
get
{
-                return getRuleLabels();
+                return GetRuleLabels();
}
}
public IDictionary RuleListLabels
{
get
{
-                return getRuleListLabels();
+                return GetRuleListLabels();
}
}
public string SingleValueReturnName
{
get
{
-                return getSingleValueReturnName();
+                return GetSingleValueReturnName();
}
}
public string SingleValueReturnType
{
get
{
-                return getSingleValueReturnType();
+                return GetSingleValueReturnType();
}
}
#endregion

-        public virtual void defineLabel( IToken label, GrammarAST elementRef, int type )
+        public virtual void DefineLabel( IToken label, GrammarAST elementRef, int type )
{
Grammar.LabelElementPair pair = new Grammar.LabelElementPair( grammar, label, elementRef );
pair.type = type;
@@ -320,12 +320,12 @@ namespace Antlr3.Tool
}
}

-        public virtual Grammar.LabelElementPair getLabel( string name )
+        public virtual Grammar.LabelElementPair GetLabel( string name )
{
return (Grammar.LabelElementPair)labelNameSpace.get( name );
}

-        public virtual Grammar.LabelElementPair getTokenLabel( string name )
+        public virtual Grammar.LabelElementPair GetTokenLabel( string name )
{
Grammar.LabelElementPair pair = null;
if ( tokenLabels != null )
@@ -335,17 +335,17 @@ namespace Antlr3.Tool
return pair;
}

-        public virtual IDictionary getRuleLabels()
+        public virtual IDictionary GetRuleLabels()
{
return ruleLabels;
}

-        public virtual IDictionary getRuleListLabels()
+        public virtual IDictionary GetRuleListLabels()
{
return ruleListLabels;
}

-        public virtual Grammar.LabelElementPair getRuleLabel( string name )
+        public virtual Grammar.LabelElementPair GetRuleLabel( string name )
{
Grammar.LabelElementPair pair = null;
if ( ruleLabels != null )
@@ -355,7 +355,7 @@ namespace Antlr3.Tool
return pair;
}

-        public virtual Grammar.LabelElementPair getTokenListLabel( string name )
+        public virtual Grammar.LabelElementPair GetTokenListLabel( string name )
{
Grammar.LabelElementPair pair = null;
if ( tokenListLabels != null )
@@ -365,7 +365,7 @@ namespace Antlr3.Tool
return pair;
}

-        public virtual Grammar.LabelElementPair getRuleListLabel( string name )
+        public virtual Grammar.LabelElementPair GetRuleListLabel( string name )
{
Grammar.LabelElementPair pair = null;
if ( ruleListLabels != null )
@@ -381,7 +381,7 @@ namespace Antlr3.Tool
*  This differs from Grammar.altReferencesTokenID(), which tracks all
*  token IDs to check for token IDs without corresponding lexer rules.
*/
-        public virtual void trackTokenReferenceInAlt( GrammarAST refAST, int outerAltNum )
+        public virtual void TrackTokenReferenceInAlt( GrammarAST refAST, int outerAltNum )
{
IList<GrammarAST> refs = altToTokenRefMap[outerAltNum].get( refAST.Text );
if ( refs == null )
@@ -392,7 +392,7 @@ namespace Antlr3.Tool
refs.Add( refAST );
}

-        public virtual IList getTokenRefsInAlt( string @ref, int outerAltNum )
+        public virtual IList GetTokenRefsInAlt( string @ref, int outerAltNum )
{
if ( altToTokenRefMap[outerAltNum] != null )
{
@@ -402,7 +402,7 @@ namespace Antlr3.Tool
return null;
}

-        public virtual void trackRuleReferenceInAlt( GrammarAST refAST, int outerAltNum )
+        public virtual void TrackRuleReferenceInAlt( GrammarAST refAST, int outerAltNum )
{
IList<GrammarAST> refs = altToRuleRefMap[outerAltNum].get( refAST.Text );
if ( refs == null )
@@ -413,7 +413,7 @@ namespace Antlr3.Tool
refs.Add( refAST );
}

-        public virtual IList getRuleRefsInAlt( string @ref, int outerAltNum )
+        public virtual IList GetRuleRefsInAlt( string @ref, int outerAltNum )
{
if ( altToRuleRefMap[outerAltNum] != null )
{
@@ -423,7 +423,7 @@ namespace Antlr3.Tool
return null;
}

-        public virtual ICollection<string> getTokenRefsInAlt( int altNum )
+        public virtual ICollection<string> GetTokenRefsInAlt( int altNum )
{
return altToTokenRefMap[altNum].Keys;
}
@@ -433,9 +433,9 @@ namespace Antlr3.Tool
*  token types for which the rule needs a list of tokens.  This
*  is called from the rule template not directly by the code generator.
*/
-        public virtual ICollection<string> getAllTokenRefsInAltsWithRewrites()
+        public virtual ICollection<string> GetAllTokenRefsInAltsWithRewrites()
{
-            string output = (string)grammar.getOption( "output" );
+            string output = (string)grammar.GetOption( "output" );
ICollection<string> tokens = new HashSet<string>();
if ( output == null || !output.Equals( "AST" ) )
{
@@ -449,7 +449,7 @@ namespace Antlr3.Tool
foreach ( string tokenName in altToTokenRefMap[i].Keys )
{
// convert token name like ID to ID, "void" to 31
-                        int ttype = grammar.getTokenType( tokenName );
+                        int ttype = grammar.GetTokenType( tokenName );
string label = grammar.generator.GetTokenTypeAsTargetLabel( ttype );
tokens.Add( label );
}
@@ -458,7 +458,7 @@ namespace Antlr3.Tool
return tokens;
}

-        public virtual ICollection<string> getRuleRefsInAlt( int outerAltNum )
+        public virtual ICollection<string> GetRuleRefsInAlt( int outerAltNum )
{
return altToRuleRefMap[outerAltNum].Keys;
}
@@ -467,7 +467,7 @@ namespace Antlr3.Tool
*  left-hand-side; so we need Lists.  This is a unique list of all
*  rule results for which the rule needs a list of results.
*/
-        public virtual ICollection<string> getAllRuleRefsInAltsWithRewrites()
+        public virtual ICollection<string> GetAllRuleRefsInAltsWithRewrites()
{
var rules = from i in Enumerable.Range( 1, numberOfAlts )
where altsWithRewrites[i]
@@ -476,16 +476,16 @@ namespace Antlr3.Tool
return new HashSet<string>( rules.SelectMany( r => r ) );
}

-        public virtual IList<GrammarAST> getInlineActions()
+        public virtual IList<GrammarAST> GetInlineActions()
{
return inlineActions;
}

-        public virtual bool hasRewrite( int i )
+        public virtual bool HasRewrite( int i )
{
if ( i >= altsWithRewrites.Length )
{
-                ErrorManager.internalError( "alt " + i + " exceeds number of " + name +
+                ErrorManager.InternalError( "alt " + i + " exceeds number of " + name +
"'s alts (" + altsWithRewrites.Length + ")" );
return false;
}
@@ -496,16 +496,16 @@ namespace Antlr3.Tool
*  for the alt so we can check for problems when output=template,
*  rewrite=true, and grammar type is tree parser.
*/
-        public virtual void trackAltsWithRewrites( GrammarAST altAST, int outerAltNum )
+        public virtual void TrackAltsWithRewrites( GrammarAST altAST, int outerAltNum )
{
if ( grammar.type == Grammar.TREE_PARSER &&
grammar.BuildTemplate &&
-                 grammar.getOption( "rewrite" ) != null &&
-                 grammar.getOption( "rewrite" ).Equals( "true" )
+                 grammar.GetOption( "rewrite" ) != null &&
+                 grammar.GetOption( "rewrite" ).Equals( "true" )
)
{
GrammarAST firstElementAST = (GrammarAST)altAST.GetChild( 0 );
-                grammar.sanity.ensureAltIsSimpleNodeOrTree( altAST,
+                grammar.sanity.EnsureAltIsSimpleNodeOrTree( altAST,
firstElementAST,
outerAltNum );
}
@@ -513,14 +513,14 @@ namespace Antlr3.Tool
}

/** Return the scope containing name */
-        public virtual AttributeScope getAttributeScope( string name )
+        public virtual AttributeScope GetAttributeScope( string name )
{
-            AttributeScope scope = getLocalAttributeScope( name );
+            AttributeScope scope = GetLocalAttributeScope( name );
if ( scope != null )
{
return scope;
}
-            if ( ruleScope != null && ruleScope.getAttribute( name ) != null )
+            if ( ruleScope != null && ruleScope.GetAttribute( name ) != null )
{
scope = ruleScope;
}
@@ -528,14 +528,14 @@ namespace Antlr3.Tool
}

/** Get the arg, return value, or predefined property for this rule */
-        public virtual AttributeScope getLocalAttributeScope( string name )
+        public virtual AttributeScope GetLocalAttributeScope( string name )
{
AttributeScope scope = null;
-            if ( returnScope != null && returnScope.getAttribute( name ) != null )
+            if ( returnScope != null && returnScope.GetAttribute( name ) != null )
{
scope = returnScope;
}
-            else if ( parameterScope != null && parameterScope.getAttribute( name ) != null )
+            else if ( parameterScope != null && parameterScope.GetAttribute( name ) != null )
{
scope = parameterScope;
}
@@ -543,7 +543,7 @@ namespace Antlr3.Tool
{
AttributeScope rulePropertiesScope =
RuleLabelScope.grammarTypeToRulePropertiesScope[grammar.type];
-                if ( rulePropertiesScope.getAttribute( name ) != null )
+                if ( rulePropertiesScope.GetAttribute( name ) != null )
{
scope = rulePropertiesScope;
}
@@ -555,7 +555,7 @@ namespace Antlr3.Tool
*  need to get the existing label for the ID ref or create a new
*  one.
*/
-        public virtual string getElementLabel( string refdSymbol,
+        public virtual string GetElementLabel( string refdSymbol,
int outerAltNum,
CodeGenerator generator )
{
@@ -564,13 +564,13 @@ namespace Antlr3.Tool
char.IsUpper( refdSymbol[0] ) )
{
// symbol is a token
-                IList tokenRefs = getTokenRefsInAlt( refdSymbol, outerAltNum );
+                IList tokenRefs = GetTokenRefsInAlt( refdSymbol, outerAltNum );
uniqueRefAST = (GrammarAST)tokenRefs[0];
}
else
{
// symbol is a rule
-                IList ruleRefs = getRuleRefsInAlt( refdSymbol, outerAltNum );
+                IList ruleRefs = GetRuleRefsInAlt( refdSymbol, outerAltNum );
uniqueRefAST = (GrammarAST)ruleRefs[0];
}
if ( uniqueRefAST.code == null )
@@ -594,11 +594,11 @@ namespace Antlr3.Tool
if ( grammar.type != Grammar.LEXER &&
char.IsUpper( refdSymbol[0] ) )
{
-                    grammar.defineTokenRefLabel( name, label, uniqueRefAST );
+                    grammar.DefineTokenRefLabel( name, label, uniqueRefAST );
}
else
{
-                    grammar.defineRuleRefLabel( name, label, uniqueRefAST );
+                    grammar.DefineRuleRefLabel( name, label, uniqueRefAST );
}
uniqueRefAST.code.SetAttribute( "label", labelName );
}
@@ -610,7 +610,7 @@ namespace Antlr3.Tool
*  define a struct; otherwise for now we assume a struct.  A rule also
*  has multiple return values if you are building trees or templates.
*/
-        public virtual bool getHasMultipleReturnValues()
+        public virtual bool GetHasMultipleReturnValues()
{
return
referencedPredefinedRuleAttributes || grammar.BuildAST ||
@@ -618,7 +618,7 @@ namespace Antlr3.Tool
( returnScope != null && returnScope.attributes.Count > 1 );
}

-        public virtual bool getHasSingleReturnValue()
+        public virtual bool GetHasSingleReturnValue()
{
return
!( referencedPredefinedRuleAttributes || grammar.BuildAST ||
@@ -626,7 +626,7 @@ namespace Antlr3.Tool
( returnScope != null && returnScope.attributes.Count == 1 );
}

-        public virtual bool getHasReturnValue()
+        public virtual bool GetHasReturnValue()
{
return
referencedPredefinedRuleAttributes || grammar.BuildAST ||
@@ -634,7 +634,7 @@ namespace Antlr3.Tool
( returnScope != null && returnScope.attributes.Count > 0 );
}

-        public virtual string getSingleValueReturnType()
+        public virtual string GetSingleValueReturnType()
{
if ( returnScope != null && returnScope.attributes.Count == 1 )
{
@@ -648,7 +648,7 @@ namespace Antlr3.Tool
return null;
}

-        public virtual string getSingleValueReturnName()
+        public virtual string GetSingleValueReturnName()
{
if ( returnScope != null && returnScope.attributes.Count == 1 )
{
@@ -660,7 +660,7 @@ namespace Antlr3.Tool
/** Given @scope::name {action} define it for this grammar.  Later,
*  the code generator will ask for the actions table.
*/
-        public virtual void defineNamedAction( GrammarAST ampersandAST,
+        public virtual void DefineNamedAction( GrammarAST ampersandAST,
GrammarAST nameAST,
GrammarAST actionAST )
{
@@ -669,7 +669,7 @@ namespace Antlr3.Tool
GrammarAST a = (GrammarAST)actions.get( actionName );
if ( a != null )
{
-                ErrorManager.grammarError(
+                ErrorManager.GrammarError(
ErrorManager.MSG_ACTION_REDEFINITION, grammar,
nameAST.Token, nameAST.Text );
}
@@ -679,7 +679,7 @@ namespace Antlr3.Tool
}
}

-        public virtual void trackInlineAction( GrammarAST actionAST )
+        public virtual void TrackInlineAction( GrammarAST actionAST )
{
inlineActions.Add( actionAST );
}
@@ -687,11 +687,11 @@ namespace Antlr3.Tool
/** Save the option key/value pair and process it; return the key
*  or null if invalid option.
*/
-        public virtual string setOption( string key, object value, IToken optionsStartToken )
+        public virtual string SetOption( string key, object value, IToken optionsStartToken )
{
if ( !legalOptions.Contains( key ) )
{
-                ErrorManager.grammarError( ErrorManager.MSG_ILLEGAL_OPTION,
+                ErrorManager.GrammarError( ErrorManager.MSG_ILLEGAL_OPTION,
grammar,
optionsStartToken,
key );
@@ -707,7 +707,7 @@ namespace Antlr3.Tool
}
if ( key == "backtrack" && value.ToString() == "true" )
{
-                grammar.composite.getRootGrammar().atLeastOneBacktrackOption = true;
+                grammar.composite.GetRootGrammar().atLeastOneBacktrackOption = true;
}
if ( key.Equals( "k" ) )
{
@@ -717,7 +717,7 @@ namespace Antlr3.Tool
return key;
}

-        public virtual void setOptions( IDictionary<string, object> options, IToken optionsStartToken )
+        public virtual void SetOptions( IDictionary<string, object> options, IToken optionsStartToken )
{
if ( options == null )
{
@@ -729,7 +729,7 @@ namespace Antlr3.Tool
{
string optionName = option.Key;
object optionValue = option.Value;
-                string stored = setOption( optionName, optionValue, optionsStartToken );
+                string stored = SetOption( optionName, optionValue, optionsStartToken );
if ( stored == null )
options.Remove( optionName );
}
diff --git a/Antlr3/Tool/RuleLabelScope.cs b/Antlr3/Tool/RuleLabelScope.cs
index 433daa8..92cdba9 100644
--- a/Antlr3/Tool/RuleLabelScope.cs
+++ b/Antlr3/Tool/RuleLabelScope.cs
@@ -50,30 +50,30 @@ namespace Antlr3.Tool
static RuleLabelScope()
{
predefinedRulePropertiesScope = new AttributeScope( "RulePredefined", null );
-            predefinedRulePropertiesScope.addAttribute( "text", null );
-            predefinedRulePropertiesScope.addAttribute( "start", null );
-            predefinedRulePropertiesScope.addAttribute( "stop", null );
-            predefinedRulePropertiesScope.addAttribute( "tree", null );
-            predefinedRulePropertiesScope.addAttribute( "st", null );
+            predefinedRulePropertiesScope.AddAttribute( "text", null );
+            predefinedRulePropertiesScope.AddAttribute( "start", null );
+            predefinedRulePropertiesScope.AddAttribute( "stop", null );
+            predefinedRulePropertiesScope.AddAttribute( "tree", null );
+            predefinedRulePropertiesScope.AddAttribute( "st", null );
predefinedRulePropertiesScope.isPredefinedRuleScope = true;

predefinedTreeRulePropertiesScope = new AttributeScope( "RulePredefined", null );
-            predefinedTreeRulePropertiesScope.addAttribute( "text", null );
-            predefinedTreeRulePropertiesScope.addAttribute( "start", null ); // note: no stop; not meaningful
-            predefinedTreeRulePropertiesScope.addAttribute( "tree", null );
-            predefinedTreeRulePropertiesScope.addAttribute( "st", null );
+            predefinedTreeRulePropertiesScope.AddAttribute( "text", null );
+            predefinedTreeRulePropertiesScope.AddAttribute( "start", null ); // note: no stop; not meaningful
+            predefinedTreeRulePropertiesScope.AddAttribute( "tree", null );
+            predefinedTreeRulePropertiesScope.AddAttribute( "st", null );
predefinedTreeRulePropertiesScope.isPredefinedRuleScope = true;

predefinedLexerRulePropertiesScope = new AttributeScope( "LexerRulePredefined", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "text", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "type", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "line", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "index", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "pos", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "channel", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "start", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "stop", null );
-            predefinedLexerRulePropertiesScope.addAttribute( "int", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "text", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "type", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "line", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "index", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "pos", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "channel", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "start", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "stop", null );
+            predefinedLexerRulePropertiesScope.AddAttribute( "int", null );
predefinedLexerRulePropertiesScope.isPredefinedLexerRuleScope = true;

grammarTypeToRulePropertiesScope =
@@ -99,18 +99,18 @@ namespace Antlr3.Tool
/** If you label a rule reference, you can access that rule's
*  return values as well as any predefined attributes.
*/
-        public override Attribute getAttribute( string name )
+        public override Attribute GetAttribute( string name )
{
AttributeScope rulePropertiesScope =
RuleLabelScope.grammarTypeToRulePropertiesScope[grammar.type];
-            if ( rulePropertiesScope.getAttribute( name ) != null )
+            if ( rulePropertiesScope.GetAttribute( name ) != null )
{
-                return rulePropertiesScope.getAttribute( name );
+                return rulePropertiesScope.GetAttribute( name );
}

if ( referencedRule.returnScope != null )
{
-                return referencedRule.returnScope.getAttribute( name );
+                return referencedRule.returnScope.GetAttribute( name );
}
return null;
}
diff --git a/Antlr3/Tool/ToolMessage.cs b/Antlr3/Tool/ToolMessage.cs
index 1414262..8540617 100644
--- a/Antlr3/Tool/ToolMessage.cs
+++ b/Antlr3/Tool/ToolMessage.cs
@@ -74,7 +74,7 @@ namespace Antlr3.Tool
}
public override string ToString()
{
-            StringTemplate st = getMessageTemplate();
+            StringTemplate st = GetMessageTemplate();
if ( arg != null )
{
st.SetAttribute( "arg", arg );

