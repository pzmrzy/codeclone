commit a7940ce4892d86aab11513f67709104fb01fed9d
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Apr 7 13:24:16 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Apr 7 13:24:16 2011 -0800

(C# 3) Updated bootstrap binaries

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8102]

diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index ca2293f..1131315 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index 0f60bd5..46e3b5b 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.StringTemplate.dll b/bin/Bootstrap/Antlr3.StringTemplate.dll
index 13e018e..4e4fde5 100644
Binary files a/bin/Bootstrap/Antlr3.StringTemplate.dll and b/bin/Bootstrap/Antlr3.StringTemplate.dll differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index c229b97..1ada5bc 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
index ef1a921..b1dcef8 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti b/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti
deleted file mode 100644
index 4776e31..0000000
--- a/bin/Bootstrap/Codegen/Templates/ANTLRCore.sti
+++ /dev/null
@@ -1,375 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2006 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-interface ANTLRCore;
-
-/** The overall file structure of a recognizer; stores methods for rules
- *  and cyclic DFAs plus support code.
- */
-outputFile(LEXER,PARSER,TREE_PARSER, actionScope, actions,
-           docComment, recognizer,
-           name, tokens, tokenNames, rules, cyclicDFAs,
-	   bitsets, buildTemplate, buildAST, rewriteMode, profile,
-	   backtracking, synpreds, memoize, numRules,
-	   fileName, ANTLRVersion, generatedTimestamp, trace,
-	   scopes, superClass, literals);
-
-/** The header file; make sure to define headerFileExtension() below */
-optional
-headerFile(LEXER,PARSER,TREE_PARSER, actionScope, actions,
-           docComment, recognizer,
-           name, tokens, tokenNames, rules, cyclicDFAs,
-	   bitsets, buildTemplate, buildAST, rewriteMode, profile,
-	   backtracking, synpreds, memoize, numRules,
-	   fileName, ANTLRVersion, generatedTimestamp, trace,
-	   scopes, superClass, literals);
-
-lexer(grammar, name, tokens, scopes, rules, numRules, labelType,
-      filterMode, superClass);
-
-parser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
-       bitsets, ASTLabelType, superClass,
-       labelType, members);
-
-/** How to generate a tree parser; same as parser except the input
- *  stream is a different type.
- */
-treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
-           numRules, bitsets, labelType, ASTLabelType,
-           superClass, members, filterMode);
-
-/** A simpler version of a rule template that is specific to the imaginary
- *  rules created for syntactic predicates.  As they never have return values
- *  nor parameters etc..., just give simplest possible method.  Don't do
- *  any of the normal memoization stuff in here either; it's a waste.
- *  As predicates cannot be inlined into the invoking rule, they need to
- *  be in a rule by themselves.
- */
-synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock);
-
-/** How to generate code for a rule.  This includes any return type
- *  data aggregates required for multiple return values.
- */
-rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memoize);
-
-/** How to generate a rule in the lexer; naked blocks are used for
- *  fragment rules.
- */
-lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize);
-
-/** How to generate code for the implicitly-defined lexer grammar rule
- *  that chooses between lexer rules.
- */
-tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor);
-
-filteringNextToken();
-
-filteringActionGate();
-
-// S U B R U L E S
-
-/** A (...) subrule with multiple alternatives */
-block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description);
-
-/** A rule block with multiple alternatives */
-ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description);
-
-ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description);
-
-/** A special case of a (...) subrule with a single alternative */
-blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description);
-
-/** A (..)+ block with 0 or more alternatives */
-positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description);
-
-positiveClosureBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description);
-
-/** A (..)* block with 0 or more alternatives */
-closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description);
-
-closureBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description);
-
-/** Optional blocks (x)? are translated to (x|) by before code generation
- *  so we can just use the normal block template
- */
-optionalBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description);
-
-optionalBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description);
-
-/** An alternative is just a list of elements; at outermost level */
-alt(elements,altNum,description,autoAST,outerAlt,treeLevel,rew);
-
-// E L E M E N T S
-
-/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,terminalOptions);
-
-/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions);
-
-listLabel(label,elem);
-
-/** match a character */
-charRef(char,label);
-
-/** match a character range */
-charRangeRef(a,b,label);
-
-/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,elementIndex,postmatchCode);
-
-matchSetAndListLabel(s,label,elementIndex,postmatchCode);
-
-/** Match a string literal */
-lexerStringRef(string,label,elementIndex);
-
-wildcard(label,elementIndex);
-
-wildcardAndListLabel(label,elementIndex);
-
-/** Match . wildcard in lexer */
-wildcardChar(label, elementIndex);
-
-wildcardCharListLabel(label, elementIndex);
-
-/** Match a rule reference by invoking it possibly with arguments
- *  and a return value or values.
- */
-ruleRef(rule,label,elementIndex,args,scope);
-
-/** ids+=ID */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope);
-
-/** A lexer rule reference */
-lexerRuleRef(rule,label,args,elementIndex,scope);
-
-/** i+=INT in lexer */
-lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope);
-
-/** EOF in the lexer */
-lexerMatchEOF(label,elementIndex);
-
-/** match ^(root children) in tree parser */
-tree(root, actionsAfterRoot, children, nullableChildList,
-     enclosingTreeLevel, treeLevel);
-
-/** Every predicate is used as a validating predicate (even when it is
- *  also hoisted into a prediction expression).
- */
-validateSemanticPredicate(pred,description);
-
-// F i x e d  D F A  (if-then-else)
-
-dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState);
-
-/** Same as a normal DFA state except that we don't examine lookahead
- *  for the bypass alternative.  It delays error detection but this
- *  is faster, smaller, and more what people expect.  For (X)? people
- *  expect "if ( LA(1)==X ) match(X);" and that's it.
- *
- *  If a semPredState, don't force lookahead lookup; preds might not
- *  need.
- */
-dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState);
-
-/** A DFA state that is actually the loopback decision of a closure
- *  loop.  If end-of-token (EOT) predicts any of the targets then it
- *  should act like a default clause (i.e., no error can be generated).
- *  This is used only in the lexer so that for ('a')* on the end of a
- *  rule anything other than 'a' predicts exiting.
- *
- *  If a semPredState, don't force lookahead lookup; preds might not
- *  need.
- */
-dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState);
-
-/** An accept state indicates a unique alternative has been predicted */
-dfaAcceptState(alt);
-
-/** A simple edge with an expression.  If the expression is satisfied,
- *  enter to the target state.  To handle gated productions, we may
- *  have to evaluate some predicates for this edge.
- */
-dfaEdge(labelExpr, targetState, predicates);
-
-// F i x e d  D F A  (switch case)
-
-/** A DFA state where a SWITCH may be generated.  The code generator
- *  decides if this is possible: CodeGenerator.canGenerateSwitch().
- */
-dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState);
-
-dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState);
-
-dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState);
-
-dfaEdgeSwitch(labels, targetState);
-
-// C y c l i c  D F A
-
-/** The code to initiate execution of a cyclic DFA; this is used
- *  in the rule to predict an alt just like the fixed DFA case.
- *  The <name> attribute is inherited via the parser, lexer, ...
- */
-dfaDecision(decisionNumber,description);
-
-/** Generate the tables and support code needed for the DFAState object
- *  argument.  Unless there is a semantic predicate (or syn pred, which
- *  become sem preds), all states should be encoded in the state tables.
- *  Consequently, cyclicDFAState/cyclicDFAEdge,eotDFAEdge templates are
- *  not used except for special DFA states that cannot be encoded as
- *  a transition table.
- */
-cyclicDFA(dfa);
-
-/** A special state in a cyclic DFA; special means has a semantic predicate
- *  or it's a huge set of symbols to check.
- */
-cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState);
-
-/** Just like a fixed DFA edge, test the lookahead and indicate what
- *  state to jump to next if successful.  Again, this is for special
- *  states.
- */
-cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates);
-
-/** An edge pointing at end-of-token; essentially matches any char;
- *  always jump to the target.
- */
-eotDFAEdge(targetStateNumber,edgeNumber, predicates);
-
-// D F A  E X P R E S S I O N S
-
-andPredicates(left,right);
-
-orPredicates(operands);
-
-notPredicate(pred);
-
-evalPredicate(pred,description);
-
-evalSynPredicate(pred,description);
-
-lookaheadTest(atom,k,atomAsInt);
-
-/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
- *  somewhere.  Must ask for the lookahead directly.
- */
-isolatedLookaheadTest(atom,k,atomAsInt);
-
-lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt);
-
-isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt);
-
-setTest(ranges);
-
-// A T T R I B U T E S
-
-parameterAttributeRef(attr);
-parameterSetAttributeRef(attr,expr);
-
-scopeAttributeRef(scope,attr,index,negIndex);
-scopeSetAttributeRef(scope,attr,expr,index,negIndex);
-
-/** $x is either global scope or x is rule with dynamic scope; refers
- *  to stack itself not top of stack.  This is useful for predicates
- *  like {$function.size()>0 && $function::name.equals("foo")}?
- */
-isolatedDynamicScopeRef(scope);
-
-/** reference an attribute of rule; might only have single return value */
-ruleLabelRef(referencedRule,scope,attr);
-
-returnAttributeRef(ruleDescriptor,attr);
-returnSetAttributeRef(ruleDescriptor,attr,expr);
-
-/** How to translate $tokenLabel */
-tokenLabelRef(label);
-
-/** ids+=ID {$ids} or e+=expr {$e} */
-listLabelRef(label);
-
-// not sure the next are the right approach; and they are evaluated early;
-// they cannot see TREE_PARSER or PARSER attributes for example. :(
-
-tokenLabelPropertyRef_text(scope,attr);
-tokenLabelPropertyRef_type(scope,attr);
-tokenLabelPropertyRef_line(scope,attr);
-tokenLabelPropertyRef_pos(scope,attr);
-tokenLabelPropertyRef_channel(scope,attr);
-tokenLabelPropertyRef_index(scope,attr);
-tokenLabelPropertyRef_tree(scope,attr);
-
-ruleLabelPropertyRef_start(scope,attr);
-ruleLabelPropertyRef_stop(scope,attr);
-ruleLabelPropertyRef_tree(scope,attr);
-ruleLabelPropertyRef_text(scope,attr);
-ruleLabelPropertyRef_st(scope,attr);
-
-/** Isolated $RULE ref ok in lexer as it's a Token */
-lexerRuleLabel(label);
-
-lexerRuleLabelPropertyRef_type(scope,attr);
-lexerRuleLabelPropertyRef_line(scope,attr);
-lexerRuleLabelPropertyRef_pos(scope,attr);
-lexerRuleLabelPropertyRef_channel(scope,attr);
-lexerRuleLabelPropertyRef_index(scope,attr);
-lexerRuleLabelPropertyRef_text(scope,attr);
-
-// Somebody may ref $template or $tree or $stop within a rule:
-rulePropertyRef_start(scope,attr);
-rulePropertyRef_stop(scope,attr);
-rulePropertyRef_tree(scope,attr);
-rulePropertyRef_text(scope,attr);
-rulePropertyRef_st(scope,attr);
-
-lexerRulePropertyRef_text(scope,attr);
-lexerRulePropertyRef_type(scope,attr);
-lexerRulePropertyRef_line(scope,attr);
-lexerRulePropertyRef_pos(scope,attr);
-/** Undefined, but present for consistency with Token attributes; set to -1 */
-lexerRulePropertyRef_index(scope,attr);
-lexerRulePropertyRef_channel(scope,attr);
-lexerRulePropertyRef_start(scope,attr);
-lexerRulePropertyRef_stop(scope,attr);
-
-ruleSetPropertyRef_tree(scope,attr,expr);
-ruleSetPropertyRef_st(scope,attr,expr);
-
-/** How to execute an action */
-execAction(action);
-
-// M I S C (properties, etc...)
-
-codeFileExtension();
-
-/** Your language needs a header file; e.g., ".h" */
-optional headerFileExtension();
-
-true();
-false();
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
index 159eaf3..97dae26 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
@@ -1,5 +1,5 @@
/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2011 Terence Parr
* All rights reserved.
*
@@ -427,17 +427,17 @@ adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
>>

createImaginaryNode(tokenType,terminalOptions,args) ::= <<
-<if(terminalOptions.class)>
+<if(terminalOptions.node)>
<! new MethodNode(IDLabel, args) !>
-new <terminalOptions.class>(<tokenType><if(args)>, <args; separator=", "><endif>)
+new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
<else>
(<ASTLabelType>)adaptor.Create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
<endif>
>>

createRewriteNodeFromElement(token,terminalOptions,args) ::= <<
-<if(terminalOptions.class)>
-new <terminalOptions.class>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
+<if(terminalOptions.node)>
+new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
<else>
<if(args)> <! must create new node from old !>
adaptor.Create(<token>, <args; separator=", ">)
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
index 7f43a38..cac71e3 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
@@ -1,5 +1,5 @@
/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2005-2008 Terence Parr
* All rights reserved.
*
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
index ec93fd7..d9b174c 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
@@ -1,5 +1,5 @@
/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2011 Terence Parr
* All rights reserved.
*
@@ -178,8 +178,8 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
>>

createNodeFromToken(label,terminalOptions) ::= <<
-<if(terminalOptions.class)>
-new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
+<if(terminalOptions.node)>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<else>
(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<endif>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
index 1b6bbf8..f67adf7 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
@@ -1,5 +1,5 @@
/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2011 Terence Parr
* All rights reserved.
*
@@ -119,8 +119,8 @@ _last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.class)>
-<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
@@ -144,8 +144,8 @@ _last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.class)>
-<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
@@ -182,8 +182,8 @@ _last = (<ASTLabelType>)input.LT(1);
<super.matchSet(..., postmatchCode={
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.class)>
-<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
@@ -208,8 +208,8 @@ matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<super.matchSet(..., postmatchCode={
<if(!rewriteMode)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.class)>
-<label>_tree = new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
@@ -283,8 +283,8 @@ _last = (<ASTLabelType>)input.LT(1);
*  change NextToken to NextNode.
*/
createRewriteNodeFromElement(token,terminalOptions,scope) ::= <<
-<if(terminalOptions.class)>
-new <terminalOptions.class>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
+<if(terminalOptions.node)>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
<else>
stream_<token>.NextNode()
<endif>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index e79cf43..da1d775 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -1,5 +1,5 @@
/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2011 Terence Parr
* All rights reserved.
*
@@ -29,7 +29,7 @@
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
-group CSharp3 implements ANTLRCore;
+group CSharp3;

csharpVisibilityMap ::= [
"private":"private",
@@ -76,6 +76,8 @@ outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
+// Missing XML comment for publicly visible type or member 'Type_or_Member'
+#pragma warning disable 1591

<actions.(actionScope).header>

@@ -110,7 +112,7 @@ lexer(grammar, name, tokens, scopes, rules, numRules, labelType="CommonToken",
filterMode, superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>}) ::= <<
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
[System.CLSCompliant(false)]
-public partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
{
<tokens:{public const int <it.name; format="id">=<it.type>;}; separator="\n">
<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
@@ -118,23 +120,23 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e

// delegates
<grammar.delegates:
-         {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
+         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
// delegators
<grammar.delegators:
-         {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    <last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
+         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+    <last(grammar.delegators):{g|private <g.recognizerName> gParent;}>

-	public <grammar.recognizerName>()<! needed by subclasses !>
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
{
OnCreated();
}

-	public <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
{
}

-	public <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
: base(input, state)
{
<if(memoize)>
@@ -277,7 +279,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
filterMode) ::= <<
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
[System.CLSCompliant(false)]
-public partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
{
<if(grammar.grammarIsRoot)>
internal static readonly string[] tokenNames = new string[] {
@@ -288,20 +290,20 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e

// delegates
<grammar.delegates:
-		 {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
// delegators
<grammar.delegators:
-		 {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
-	<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>

<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<@members>
<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
-public <grammar.recognizerName>( <inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>( <inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: this( input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}> )
{
}
-public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
: base(input, state)
{
<parserCtorBody()>
@@ -332,7 +334,7 @@ public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState s
appear to be defined in this recognizer. !>
#region Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-	public <returnType()> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) <!throws RecognitionException !>\{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType()> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) <!throws RecognitionException !>\{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
#endregion Delegated rules<\n>
<endif>

@@ -364,6 +366,11 @@ public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState s
}
>>

+// imported grammars are 'public' (can't be internal because their return scope classes must be accessible)
+parserModifier(grammar, actions) ::= <<
+<if(grammar.grammarIsRoot)><actions.(actionScope).modifier; null="public"><else>public<endif>
+>>
+
parserCtorBody() ::= <<
<if(memoize)>
<if(grammar.grammarIsRoot)>
@@ -385,7 +392,7 @@ parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
*/
treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
numRules, bitsets, labelType={<ASTLabelType>}, ASTLabelType="object",
-           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter\<<labelType>\><else>TreeFilter<endif><else>TreeParser<endif><endif>},
+           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif><endif>},
members={<actions.treeparser.members>},
filterMode) ::= <<
<genericParser(inputStreamType="ITreeNodeStream", rewriteElementType="Node", ...)>
@@ -487,7 +494,7 @@ partial void LeaveRule_<ruleName>();
// $ANTLR start "<ruleName>"
// <fileName>:<description>
[GrammarRule("<ruleName>")]
-<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> <returnType()> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType()> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
EnterRule_<ruleName>();
EnterRule("<ruleName>", <ruleDescriptor.index>);
@@ -539,6 +546,16 @@ partial void LeaveRule_<ruleName>();
// $ANTLR end "<ruleName>"
>>

+// imported grammars need to have internal rules
+ruleModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>internal<endif>
+>>
+
+// imported grammars need to have public return scopes
+returnScopeModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>public<endif>
+>>
+
catch(decl,action) ::= <<
catch (<e.decl>)
{
@@ -641,7 +658,7 @@ partial void LeaveRule_<ruleName>();

// $ANTLR start "<ruleName>"
[GrammarRule("<ruleName>")]
-<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{
EnterRule_<ruleName>();
EnterRule("<ruleName>", <ruleDescriptor.index>);
@@ -1474,7 +1491,7 @@ ruleLabelDef(label) ::= <<
*/
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> sealed partial class <ruleDescriptor:returnStructName()> : <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>\><@ruleReturnInterfaces()>
+<returnScopeModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> sealed partial class <ruleDescriptor:returnStructName()> : <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>\><@ruleReturnInterfaces()>
{
<scope.attributes:{public <it.decl>;}; separator="\n">
<@ruleReturnMembers()>
@@ -1596,7 +1613,7 @@ lexerRuleLabelPropertyRef_type(scope,attr) ::=
lexerRuleLabelPropertyRef_line(scope,attr) ::=
"(<scope>!=null?<scope>.Line:0)"

-lexerRuleLabelPropertyRef_pos(scope,attr) ::=
+lexerRuleLabelPropertyRef_pos(scope,attr) ::=
"(<scope>!=null?<scope>.CharPositionInLine:-1)"

lexerRuleLabelPropertyRef_channel(scope,attr) ::=
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
index 94d43a5..68a8889 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
@@ -1,5 +1,5 @@
/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2005-2008 Terence Parr
* All rights reserved.
*
@@ -88,11 +88,11 @@ protected virtual bool EvalPredicate( bool result, string predicate )
ctorForRootGrammar() ::= <<
<! bug: can't use <@super.members()> cut-n-paste instead !>
<! Same except we add port number and profile stuff if root grammar !>
-public <name>( <inputStreamType> input )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
{
}
-public <name>( <inputStreamType> input, int port, RecognizerSharedState state )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
: base( input, state )
{
<parserCtorBody()>
@@ -104,11 +104,11 @@ public <name>( <inputStreamType> input, int port, RecognizerSharedState state )

ctorForProfilingRootGrammar() ::= <<
<! bug: can't use <@super.members()> cut-n-paste instead !>
-public <name>( <inputStreamType> input )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
: this( input, new Profiler(null), new RecognizerSharedState() )
{
}
-public <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
: base( input, dbg, state )
{
Profiler p = (Profiler)dbg;
@@ -123,7 +123,7 @@ public <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerShare

/** Basically we don't want to set any dbg listeners are root will have it. */
ctorForDelegateGrammar() ::= <<
-public <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: base( input, dbg, state )
{
<parserCtorBody()>
@@ -133,7 +133,7 @@ public <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerShare
>>

ctorForPredefinedListener() ::= <<
-public <name>( <inputStreamType> input, IDebugEventListener dbg )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg )
<@superClassRef>: base( input, dbg, new RecognizerSharedState() )<@end>
{
<if(profile)>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
index ff5a2cf..beab9a1 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
@@ -1,5 +1,5 @@
/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2011 Terence Parr
* All rights reserved.
*
diff --git a/bin/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg b/bin/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg
index 6879530..0c7349f 100644
--- a/bin/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg
+++ b/bin/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg
@@ -28,17 +28,25 @@

/** How to generate rules derived from left-recursive rules.
*  These rely on recRuleDefArg(), recRuleAltPredicate(),
- *  recRuleArg(), recRuleSetResultAction() templates in main language.stg
+ *  recRuleArg(), recRuleSetResultAction(), recRuleSetReturnAction()
+ *  templates in main language.stg
*/
group LeftRecursiveRules;

-recRuleStart(ruleName, maxPrec) ::= "<ruleName> : <recRuleName(...)>[<maxPrec>] ;"
-
recRuleName(ruleName) ::= "<ruleName>_"
+recPrimaryName(ruleName) ::= "<ruleName>_primary"
+
+recRuleStart(ruleName, minPrec, userRetvals, userRetvalAssignments) ::= <<
+<ruleName><if(userRetvals)> returns [<userRetvals>]<endif>
+  : <recRuleName(...)>[<minPrec>] <if(userRetvals)>{<userRetvalAssignments>}<endif> ;
+>>

-recRule(ruleName, argDef, argName, alts, setResultAction, buildAST) ::= <<
-<recRuleName(...)>[<argDef>]
-    :   <ruleName>_primary <if(buildAST)>{<setResultAction>}<endif>
+recRule(ruleName, precArgDef, argName, alts, setResultAction, buildAST,
+        userRetvals, userRetvalAssignments) ::= <<
+<recRuleName(...)>[<precArgDef>]<if(userRetvals)> returns [<userRetvals>]<endif>
+    :   <recPrimaryName(...)>
+    	<if(buildAST)>{<setResultAction>}<endif>
+    	<if(userRetvals)>{<userRetvalAssignments>}<endif>
( options {backtrack=false;}
: ( options {backtrack=false;}
: <alts; separator="\n        | ">
@@ -47,8 +55,8 @@ recRule(ruleName, argDef, argName, alts, setResultAction, buildAST) ::= <<
;
>>

-recPrimaryRule(ruleName, alts) ::= <<
-<ruleName>_primary
+recPrimaryRule(ruleName, alts, userRetvals) ::= <<
+<recPrimaryName(...)><if(userRetvals)> returns [<userRetvals>]<endif>
options {backtrack=true;}
: <alts; separator="\n    | ">
;
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index 001c774..179697f 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ
diff --git a/bin/Bootstrap/Tool/Templates/messages/formats/antlr.stg b/bin/Bootstrap/Tool/Templates/messages/formats/antlr.stg
index cf9cbc9..9fb4612 100644
--- a/bin/Bootstrap/Tool/Templates/messages/formats/antlr.stg
+++ b/bin/Bootstrap/Tool/Templates/messages/formats/antlr.stg
@@ -1,5 +1,5 @@
/*
- [The "BSD licence"]
+ [The "BSD license"]
Copyright (c) 2006 Kay Roepke
All rights reserved.

diff --git a/bin/Bootstrap/Tool/Templates/messages/formats/vs2005.stg b/bin/Bootstrap/Tool/Templates/messages/formats/vs2005.stg
index 34c88e4..0c94e48 100644
--- a/bin/Bootstrap/Tool/Templates/messages/formats/vs2005.stg
+++ b/bin/Bootstrap/Tool/Templates/messages/formats/vs2005.stg
@@ -1,5 +1,5 @@
/*
- [The "BSD licence"]
+ [The "BSD license"]
Copyright (c) 2006 Kay Roepke
All rights reserved.


