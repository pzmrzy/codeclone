commit 3337fa2d68084b520e1ab5f31ecccd25cbb81625
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Nov 21 13:21:37 2010 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Nov 21 13:21:37 2010 -0800

(C# 3) Template compiling and caching ability in ST, enabled in the ANTLR tool (~20% overall performance improvement)

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7102]

diff --git a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
index ff9400e..ccabe65 100644
--- a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
+++ b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
@@ -35,7 +35,7 @@
<DebugType>pdbonly</DebugType>
<Optimize>true</Optimize>
<OutputPath>bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
+    <DefineConstants>TRACE;COMPILE_EXPRESSIONS; CACHE_FUNCTORS</DefineConstants>
<ErrorReport>prompt</ErrorReport>
<WarningLevel>4</WarningLevel>
</PropertyGroup>
@@ -127,17 +127,14 @@
<Link>Key.snk</Link>
</None>
</ItemGroup>
-
<PropertyGroup>
<!-- Folder containing AntlrBuildTask.dll -->
<AntlrBuildTaskPath>$(SolutionDir)bin\Bootstrap</AntlrBuildTaskPath>
<!-- Path to the ANTLR Tool itself. -->
<AntlrToolPath>$(SolutionDir)bin\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
-
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
<Import Project="$(SolutionDir)bin\Bootstrap\Antlr3.targets" />
-
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/Antlr3.StringTemplate/Language/ASTExpr.cs b/Antlr3.StringTemplate/Language/ASTExpr.cs
index 275c59f..54d83ba 100644
--- a/Antlr3.StringTemplate/Language/ASTExpr.cs
+++ b/Antlr3.StringTemplate/Language/ASTExpr.cs
@@ -106,7 +106,7 @@ namespace Antlr3.ST.Language

static readonly Dictionary<Type, Dictionary<string, Func<object, object>>> _memberAccessors = new Dictionary<Type, Dictionary<string, Func<object, object>>>();

-        ITree _exprTree;
+        private readonly ITree _exprTree;

/** <summary>store separator etc...</summary> */
IDictionary<string, object> _options;
@@ -147,6 +147,11 @@ namespace Antlr3.ST.Language
{
public System.Func<ASTExpr, StringTemplate, IStringTemplateWriter, int> func;
public ASTExpr chunk;
+
+            internal int Evaluate(StringTemplate template, IStringTemplateWriter writer)
+            {
+                return func(chunk, template, writer);
+            }
}
public static bool EnableDynamicMethods = false;
public static bool EnableFunctionalMethods = true;
@@ -176,12 +181,20 @@ namespace Antlr3.ST.Language
}
#endregion

-#if COMPILE_EXPRESSIONS
-        public static int CallFunctionalActionEvaluator( HoldsActionFuncAndChunk data, StringTemplate self, IStringTemplateWriter writer )
+        public static int EvaluatorCacheHits
+        {
+            get;
+            private set;
+        }
+
+        public static int EvaluatorCacheMisses
{
-            return data.func( data.chunk, self, writer );
+            get;
+            private set;
}
-        static System.Func<StringTemplate, IStringTemplateWriter, int> GetEvaluator( ASTExpr chunk, ITree condition )
+
+#if COMPILE_EXPRESSIONS
+        private static System.Func<StringTemplate, IStringTemplateWriter, int> GetEvaluator( ASTExpr chunk, ITree condition )
{
if ( EnableDynamicMethods )
{
@@ -228,7 +241,7 @@ namespace Antlr3.ST.Language
func = functionalEvaluator,
chunk = chunk
};
-                    return (System.Func<StringTemplate, IStringTemplateWriter, int>)System.Delegate.CreateDelegate( typeof( System.Func<StringTemplate, IStringTemplateWriter, int> ), holder, typeof( ASTExpr ).GetMethod( "CallFunctionalActionEvaluator" ) );
+                    return holder.Evaluate;
}
catch
{
@@ -273,22 +286,46 @@ namespace Antlr3.ST.Language
@out.PushIndentation( Indentation );
HandleExprOptions( self );
//System.out.println("evaluating tree: "+exprTree.toStringList());
+            ActionEvaluator eval = null;
#if COMPILE_EXPRESSIONS
-            if ( EvaluateAction == null )
-                EvaluateAction = GetEvaluator( this, AST );
-#else
-            ActionEvaluator eval =
-                    new ActionEvaluator( self, this, @out, _exprTree );
+            bool compile = self.Group != null && self.Group.EnableCompiledExpressions;
+            bool cache = compile && self.Group.EnableCachedExpressions;
+            System.Func<StringTemplate, IStringTemplateWriter, int> evaluator = EvaluateAction;
+            if (compile)
+            {
+                if (!cache || EvaluateAction == null)
+                {
+                    // caching won't help here because AST is read only
+                    EvaluatorCacheMisses++;
+                    evaluator = GetEvaluator(this, AST);
+                    if (cache)
+                        EvaluateAction = evaluator;
+                }
+                else
+                {
+                    EvaluatorCacheHits++;
+                }
+            }
+            else
#endif
+            {
+                eval = new ActionEvaluator(self, this, @out, _exprTree);
+            }
+
int n = 0;
try
{
// eval and write out tree
#if COMPILE_EXPRESSIONS
-                n = EvaluateAction( self, @out );
-#else
-                n = eval.action();
+                if (compile)
+                {
+                    n = evaluator(self, @out);
+                }
+                else
#endif
+                {
+                    n = eval.action();
+                }
}
catch ( RecognitionException re )
{
@@ -1190,14 +1227,27 @@ namespace Antlr3.ST.Language
if ( exprAST != null )
{
#if COMPILE_EXPRESSIONS
-                System.Func<StringTemplate, IStringTemplateWriter, int> value;
+                System.Func<StringTemplate, IStringTemplateWriter, int> value = null;
+                bool compile = self.Group != null && self.Group.EnableCompiledExpressions;
+                bool cache = compile && self.Group.EnableCachedExpressions;
+                if (compile)
+                {
#if CACHE_FUNCTORS
-                if ( !_evaluators.TryGetValue( expr, out value ) )
+                    if (!cache || !_evaluators.TryGetValue(expr, out value))
#endif
-                {
-                    value = GetEvaluator( this, exprAST );
+                    {
+                        value = GetEvaluator(this, exprAST);
#if CACHE_FUNCTORS
-                    _evaluators[expr] = value;
+                        EvaluatorCacheMisses++;
+                        if (cache)
+                            _evaluators[expr] = value;
+#endif
+                    }
+#if CACHE_FUNCTORS
+                    else
+                    {
+                        EvaluatorCacheHits++;
+                    }
#endif
}
#endif
@@ -1209,12 +1259,17 @@ namespace Antlr3.ST.Language
try
{
#if COMPILE_EXPRESSIONS
-                        value( self, sw );
-#else
-                        ActionEvaluator eval = new ActionEvaluator( self, this, sw, exprAST );
-                        // eval tree
-                        eval.action();
+                        if (compile)
+                        {
+                            value(self, sw);
+                        }
+                        else
#endif
+                        {
+                            ActionEvaluator eval = new ActionEvaluator(self, this, sw, exprAST);
+                            // eval tree
+                            eval.action();
+                        }
}
catch ( RecognitionException re )
{
diff --git a/Antlr3.StringTemplate/StringTemplateGroup.cs b/Antlr3.StringTemplate/StringTemplateGroup.cs
index 269e1c0..f4bb8a8 100644
--- a/Antlr3.StringTemplate/StringTemplateGroup.cs
+++ b/Antlr3.StringTemplate/StringTemplateGroup.cs
@@ -193,7 +193,15 @@ namespace Antlr3.ST
*  to distinguish from the other variety.
*  </summary>
*/
-        static IStringTemplateGroupLoader _groupLoader = null;
+        private static IStringTemplateGroupLoader _groupLoader;
+
+        private static bool _compileExpressions;
+
+        private static bool _cacheExpression;
+
+        private readonly bool _enableCompiledExpressions = _compileExpressions;
+
+        private readonly bool _enableCachedExpressions = _cacheExpression;

/** <summary>
*  Where to report errors.  All string templates in this group
@@ -353,7 +361,6 @@ namespace Antlr3.ST
VerifyInterfaceImplementations();
}

-
#region PIXEL MINE ADDED

public IStringTemplateErrorListener ErrorListener
@@ -466,26 +473,44 @@ namespace Antlr3.ST
}
}

+        public bool EnableCompiledExpressions
+        {
+            get
+            {
+                return _enableCompiledExpressions;
+            }
+        }
+
+        public bool EnableCachedExpressions
+        {
+            get
+            {
+                return _enableCachedExpressions;
+            }
+        }
+
#endregion

-        [MethodImpl( MethodImplOptions.Synchronized )]
-        static Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> BuildLexerCtor( Type lexerType )
+        private static Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> BuildLexerCtor( Type lexerType )
{
if ( lexerType == null )
return null;

-            Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> result;
-            if ( !_ctors.TryGetValue( lexerType, out result ) )
+            lock (_ctors)
{
-                var template = Expression.Parameter(typeof(StringTemplate), "template");
-                var reader = Expression.Parameter(typeof(TextReader), "reader");
-                ConstructorInfo ctor = lexerType.GetConstructor(new Type[] { typeof(StringTemplate), typeof(TextReader) });
-                var expression = Expression.Lambda<Func<StringTemplate, TextReader, Antlr.Runtime.Lexer>>(Expression.New(ctor, template, reader), template, reader);
-                result = expression.Compile();
-                _ctors[lexerType] = result;
-            }
+                Func<StringTemplate, TextReader, Antlr.Runtime.Lexer> result;
+                if (!_ctors.TryGetValue(lexerType, out result))
+                {
+                    var template = Expression.Parameter(typeof(StringTemplate), "template");
+                    var reader = Expression.Parameter(typeof(TextReader), "reader");
+                    ConstructorInfo ctor = lexerType.GetConstructor(new Type[] { typeof(StringTemplate), typeof(TextReader) });
+                    var expression = Expression.Lambda<Func<StringTemplate, TextReader, Antlr.Runtime.Lexer>>(Expression.New(ctor, template, reader), template, reader);
+                    result = expression.Compile();
+                    _ctors[lexerType] = result;
+                }

-            return result;
+                return result;
+            }
}

public static void ResetNameMaps()
@@ -692,55 +717,60 @@ namespace Antlr3.ST
}
CheckRefreshInterval();
StringTemplate st;
-            if ( !_templates.TryGetValue( name, out st ) || st == null )
+
+            lock (_templates)
{
-                // not there?  Attempt to load
-                if ( !_templatesDefinedInGroupFile )
+                if (!_templates.TryGetValue(name, out st) || st == null)
{
-                    // only check the disk for individual template
-                    st = LoadTemplateFromBeneathRootDirOrCLASSPATH( GetFileNameFromTemplateName( name ) );
-                }
-                if ( st == null && _superGroup != null )
-                {
-                    // try to resolve in super group
-                    st = _superGroup.GetInstanceOf( name );
-                    // make sure that when we inherit a template, that it's
-                    // group is reset; it's nativeGroup will remain where it was
-                    if ( st != null )
+                    // not there?  Attempt to load
+                    if (!_templatesDefinedInGroupFile)
{
-                        st.Group = this;
+                        // only check the disk for individual template
+                        st = LoadTemplateFromBeneathRootDirOrCLASSPATH(GetFileNameFromTemplateName(name));
}
-                }
-                if ( st != null )
-                {
-                    // found in superGroup
-                    // insert into this group; refresh will allow super
-                    // to change it's def later or this group to add
-                    // an override.
-                    _templates[name] = st;
-                }
-                else
-                {
-                    // not found; remember that this sucker doesn't exist
-                    _templates[name] = NOT_FOUND_ST;
-                    string context = "";
-                    if ( enclosingInstance != null )
+                    if (st == null && _superGroup != null)
+                    {
+                        // try to resolve in super group
+                        st = _superGroup.GetInstanceOf(name);
+                        // make sure that when we inherit a template, that it's
+                        // group is reset; it's nativeGroup will remain where it was
+                        if (st != null)
+                        {
+                            st.Group = this;
+                        }
+                    }
+                    if (st != null)
{
-                        context = "; context is " +
-                                  enclosingInstance.GetEnclosingInstanceStackString();
+                        // found in superGroup
+                        // insert into this group; refresh will allow super
+                        // to change it's def later or this group to add
+                        // an override.
+                        _templates[name] = st;
+                    }
+                    else
+                    {
+                        // not found; remember that this sucker doesn't exist
+                        _templates[name] = NOT_FOUND_ST;
+                        string context = "";
+                        if (enclosingInstance != null)
+                        {
+                            context = "; context is " +
+                                      enclosingInstance.GetEnclosingInstanceStackString();
+                        }
+                        string hier = GetGroupHierarchyStackString();
+                        context += "; group hierarchy is " + hier;
+                        throw new ArgumentException("Can't find template " +
+                                                           GetFileNameFromTemplateName(name) +
+                                                           context);
}
-                    string hier = GetGroupHierarchyStackString();
-                    context += "; group hierarchy is " + hier;
-                    throw new ArgumentException( "Can't find template " +
-                                                       GetFileNameFromTemplateName( name ) +
-                                                       context );
}
+                else if (st == NOT_FOUND_ST)
+                {
+                    return null;
+                }
+                //Console.Out.WriteLine( "lookup found " + st.Group.Name + "::" + st.Name );
}
-            else if ( st == NOT_FOUND_ST )
-            {
-                return null;
-            }
-            //Console.Out.WriteLine( "lookup found " + st.Group.Name + "::" + st.Name );
+
return st;
}

@@ -939,14 +969,18 @@ namespace Antlr3.ST
{
throw new ArgumentException( "cannot have '.' in template names" );
}
-            StringTemplate st = CreateStringTemplate();
-            st.Name = name;
-            st.Group = this;
-            st.NativeGroup = this;
-            st.Template = template;
-            st.ErrorListener = _listener;
-            _templates[name] = st;
-            return st;
+
+            lock (_templates)
+            {
+                StringTemplate st = CreateStringTemplate();
+                st.Name = name;
+                st.Group = this;
+                st.NativeGroup = this;
+                st.Template = template;
+                st.ErrorListener = _listener;
+                _templates[name] = st;
+                return st;
+            }
}

/** <summary>Track all references to regions &lt;@foo>...&lt;@end> or &lt;@foo()>.</summary> */
@@ -1015,43 +1049,49 @@ namespace Antlr3.ST
}

/** <summary>Make name and alias for target.  Replace any previous def of name</summary> */
-        [MethodImpl( MethodImplOptions.Synchronized )]
public virtual StringTemplate DefineTemplateAlias( string name, string target )
{
-            StringTemplate targetST = GetTemplateDefinition( target );
-            if ( targetST == null )
+            lock (_templates)
{
-                Error( "cannot alias " + name + " to undefined template: " + target );
-                return null;
+                StringTemplate targetST = GetTemplateDefinition(target);
+                if (targetST == null)
+                {
+                    Error("cannot alias " + name + " to undefined template: " + target);
+                    return null;
+                }
+                _templates[name] = targetST;
+                return targetST;
}
-            _templates[name] = targetST;
-            return targetST;
}

-        [MethodImpl( MethodImplOptions.Synchronized )]
public virtual bool IsDefinedInThisGroup( string name )
{
-            StringTemplate st;
-            if ( _templates.TryGetValue( name, out st ) && st != null )
+            lock (_templates)
{
-                if ( st.IsRegion )
+                StringTemplate st;
+                if (_templates.TryGetValue(name, out st) && st != null)
{
-                    // don't allow redef of @t.r() ::= "..." or <@r>...<@end>
-                    if ( st.RegionDefType == RegionType.Implicit )
+                    if (st.IsRegion)
{
-                        return false;
+                        // don't allow redef of @t.r() ::= "..." or <@r>...<@end>
+                        if (st.RegionDefType == RegionType.Implicit)
+                        {
+                            return false;
+                        }
}
+                    return true;
}
-                return true;
+                return false;
}
-            return false;
}

/** <summary>Get the ST for 'name' in this group only</summary> */
-        [MethodImpl( MethodImplOptions.Synchronized )]
public virtual StringTemplate GetTemplateDefinition( string name )
{
-            return _templates[name];
+            lock (_templates)
+            {
+                return _templates[name];
+            }
}

/** <summary>
@@ -1238,9 +1278,16 @@ namespace Antlr3.ST
_defaultTemplateLexerClassCtor = BuildLexerCtor( lexerClass );
}

-        public static void RegisterGroupLoader( IStringTemplateGroupLoader loader )
+        public static void RegisterGroupLoader(IStringTemplateGroupLoader loader)
+        {
+            RegisterGroupLoader(loader, false, false);
+        }
+
+        public static void RegisterGroupLoader( IStringTemplateGroupLoader loader, bool enableCompilation, bool enableCaching )
{
_groupLoader = loader;
+            _compileExpressions = enableCompilation;
+            _cacheExpression = enableCaching;
}

public static StringTemplateGroup LoadGroup( string name )
@@ -1295,10 +1342,12 @@ namespace Antlr3.ST
}
}

-        [MethodImpl( MethodImplOptions.Synchronized )]
public virtual ICollection<string> GetTemplateNames()
{
-            return _templates.Keys;
+            lock (_templates)
+            {
+                return _templates.Keys.ToArray();
+            }
}

/** <summary>
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index b36a10c..db89798 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -75,6 +75,7 @@ namespace Antlr3.Codegen
using Path = System.IO.Path;
using RecognitionException = Antlr.Runtime.RecognitionException;
using Rule = Antlr3.Tool.Rule;
+    using RuntimeHelpers = System.Runtime.CompilerServices.RuntimeHelpers;
using Stopwatch = System.Diagnostics.Stopwatch;
using StringTemplate = Antlr3.ST.StringTemplate;
using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
@@ -284,146 +285,163 @@ namespace Antlr3.Codegen

#endregion

-        [MethodImpl( MethodImplOptions.Synchronized )]
protected virtual void LoadLanguageTarget( string language )
{
-            if ( !_targets.TryGetValue( language, out target ) )
+            lock (_targets)
{
-                // first try to load the target via a satellite DLL
-                string assembly = "Antlr3.Targets." + language + ".dll";
-                string path1 = tool.TargetsDirectory;
-                string[] paths = { path1 };
+                if (!_targets.TryGetValue(language, out target))
+                {
+                    // first try to load the target via a satellite DLL
+                    string assembly = "Antlr3.Targets." + language + ".dll";
+                    string path1 = tool.TargetsDirectory;
+                    string[] paths = { path1 };

-                System.Reflection.Assembly targetAssembly = null;
-                System.Type targetType = null;
-                string targetName = "Antlr3.Targets." + language + "Target";
+                    System.Reflection.Assembly targetAssembly = null;
+                    System.Type targetType = null;
+                    string targetName = "Antlr3.Targets." + language + "Target";

-                foreach ( string path in paths )
-                {
-                    string filename = System.IO.Path.Combine( path, assembly );
-                    if ( System.IO.File.Exists( filename ) )
+                    foreach (string path in paths)
{
-                        try
-                        {
-                            targetAssembly = System.Reflection.Assembly.LoadFrom( filename );
-                            targetType = targetAssembly.GetType( targetName, false );
-                        }
-                        catch
+                        string filename = System.IO.Path.Combine(path, assembly);
+                        if (System.IO.File.Exists(filename))
{
+                            try
+                            {
+                                targetAssembly = System.Reflection.Assembly.LoadFrom(filename);
+                                targetType = targetAssembly.GetType(targetName, false);
+                            }
+                            catch
+                            {
+                            }
}
}
-                }
-
-                // then try to load from the current file
-                if ( targetType == null )
-                {
-                    targetType = System.Type.GetType( targetName );

-                    if ( targetType == null )
+                    // then try to load from the current file
+                    if (targetType == null)
{
-                        ErrorManager.Error( ErrorManager.MSG_CANNOT_CREATE_TARGET_GENERATOR, targetName );
-                        return;
+                        targetType = System.Type.GetType(targetName);
+
+                        if (targetType == null)
+                        {
+                            ErrorManager.Error(ErrorManager.MSG_CANNOT_CREATE_TARGET_GENERATOR, targetName);
+                            return;
+                        }
}
-                }

-                target = (Target)Activator.CreateInstance(targetType);
-                _targets[language] = target;
+                    target = (Target)Activator.CreateInstance(targetType);
+                    _targets[language] = target;
+                }
}
}

/** load the main language.stg template group file */
public virtual void LoadTemplates( string language )
{
-            // get a group loader containing main templates dir and target subdir
-            string templateDirs =
-                tool.TemplatesDirectory + ":" +
-                Path.Combine(tool.TemplatesDirectory, language);
-            //JSystem.@out.println("targets="+templateDirs.toString());
-            IStringTemplateGroupLoader loader =
-                new CommonGroupLoader( templateDirs,
-                                      ErrorManager.GetStringTemplateErrorListener() );
-            StringTemplateGroup.RegisterGroupLoader( loader );
-            StringTemplateGroup.RegisterDefaultLexer( typeof( AngleBracketTemplateLexer ) );
+            string outputOption = (string)this.grammar.GetOption("output") ?? string.Empty;
+            LoadTemplates(tool, language, grammar.type, outputOption, debug, out baseTemplates, out templates);
+        }
+
+        private static readonly Dictionary<string, IStringTemplateGroupLoader> _templateLoaders = new Dictionary<string, IStringTemplateGroupLoader>();
+        private static readonly Dictionary<string, StringTemplateGroup> _coreTemplates = new Dictionary<string, StringTemplateGroup>();
+        private static readonly Dictionary<StringTemplateGroup, Dictionary<string, StringTemplateGroup>> _languageTemplates = new Dictionary<StringTemplateGroup, Dictionary<string, StringTemplateGroup>>(ObjectReferenceEqualityComparer<StringTemplateGroup>.Default);
+
+        private sealed class ObjectReferenceEqualityComparer<T> : EqualityComparer<T>
+            where T : class
+        {
+            private static readonly ObjectReferenceEqualityComparer<T> _default = new ObjectReferenceEqualityComparer<T>();

+            private ObjectReferenceEqualityComparer()
+            {
+            }
+
+            public static new ObjectReferenceEqualityComparer<T> Default
+            {
+                get
+                {
+                    return _default;
+                }
+            }
+
+            public override bool Equals(T x, T y)
+            {
+                return object.ReferenceEquals(x, y);
+            }
+
+            public override int GetHashCode(T obj)
+            {
+                return RuntimeHelpers.GetHashCode(obj);
+            }
+        }
+
+        private static void LoadTemplates(AntlrTool tool, string language, GrammarType grammarType, string outputOption, bool debug, out StringTemplateGroup baseTemplates, out StringTemplateGroup templates)
+        {
// first load main language template
-            StringTemplateGroup coreTemplates =
-                StringTemplateGroup.LoadGroup( language );
+            StringTemplateGroup coreTemplates = GetOrCacheTemplateGroup(tool, language, null, null);
baseTemplates = coreTemplates;
-            if ( coreTemplates == null )
+            if (coreTemplates == null)
{
-                ErrorManager.Error( ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES,
-                                   language );
+                ErrorManager.Error(ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES, language);
+                baseTemplates = null;
+                templates = null;
return;
}

+            outputOption = outputOption ?? string.Empty;
// dynamically add subgroups that act like filters to apply to
// their supergroup.  E.g., Java:Dbg:AST:ASTParser::ASTDbg.
-            string outputOption = (string)grammar.GetOption( "output" );
-            if ( outputOption != null && outputOption.Equals( "AST" ) )
+            if (outputOption.Equals("AST"))
{
-                if ( debug && grammar.type != GrammarType.Lexer )
+                if (debug && grammarType != GrammarType.Lexer)
{
-                    StringTemplateGroup dbgTemplates =
-                        StringTemplateGroup.LoadGroup( "Dbg", coreTemplates );
+                    StringTemplateGroup dbgTemplates = GetOrCacheTemplateGroup(tool, language, "Dbg", coreTemplates);
baseTemplates = dbgTemplates;
-                    StringTemplateGroup astTemplates =
-                        StringTemplateGroup.LoadGroup( "AST", dbgTemplates );
+                    StringTemplateGroup astTemplates = GetOrCacheTemplateGroup(tool, language, "AST", dbgTemplates);
StringTemplateGroup astParserTemplates = astTemplates;
-                    //if ( !grammar.rewriteMode() ) {
-                    if ( grammar.type == GrammarType.TreeParser )
+                    if (grammarType == GrammarType.TreeParser)
{
-                        astParserTemplates =
-                            StringTemplateGroup.LoadGroup( "ASTTreeParser", astTemplates );
+                        astParserTemplates = GetOrCacheTemplateGroup(tool, language, "ASTTreeParser", astTemplates);
}
else
{
-                        astParserTemplates =
-                            StringTemplateGroup.LoadGroup( "ASTParser", astTemplates );
+                        astParserTemplates = GetOrCacheTemplateGroup(tool, language, "ASTParser", astTemplates);
}
-                    //}
-                    StringTemplateGroup astDbgTemplates =
-                        StringTemplateGroup.LoadGroup( "ASTDbg", astParserTemplates );
+
+                    StringTemplateGroup astDbgTemplates = GetOrCacheTemplateGroup(tool, language, "ASTDbg", astParserTemplates);
templates = astDbgTemplates;
}
else
{
-                    StringTemplateGroup astTemplates =
-                        StringTemplateGroup.LoadGroup( "AST", coreTemplates );
+                    StringTemplateGroup astTemplates = GetOrCacheTemplateGroup(tool, language, "AST", coreTemplates);
StringTemplateGroup astParserTemplates = astTemplates;
-                    //if ( !grammar.rewriteMode() ) {
-                    if ( grammar.type == GrammarType.TreeParser )
+                    if (grammarType == GrammarType.TreeParser)
{
-                        astParserTemplates =
-                            StringTemplateGroup.LoadGroup( "ASTTreeParser", astTemplates );
+                        astParserTemplates = GetOrCacheTemplateGroup(tool, language, "ASTTreeParser", astTemplates);
}
else
{
-                        astParserTemplates =
-                            StringTemplateGroup.LoadGroup( "ASTParser", astTemplates );
+                        astParserTemplates = GetOrCacheTemplateGroup(tool, language, "ASTParser", astTemplates);
}
-                    //}
+
templates = astParserTemplates;
}
}
-            else if ( outputOption != null && outputOption.Equals( "template" ) )
+            else if (outputOption.Equals("template"))
{
-                if ( debug && grammar.type != GrammarType.Lexer )
+                if (debug && grammarType != GrammarType.Lexer)
{
-                    StringTemplateGroup dbgTemplates =
-                        StringTemplateGroup.LoadGroup( "Dbg", coreTemplates );
+                    StringTemplateGroup dbgTemplates = GetOrCacheTemplateGroup(tool, language, "Dbg", coreTemplates);
baseTemplates = dbgTemplates;
-                    StringTemplateGroup stTemplates =
-                        StringTemplateGroup.LoadGroup( "ST", dbgTemplates );
+                    StringTemplateGroup stTemplates = GetOrCacheTemplateGroup(tool, language, "ST", dbgTemplates);
templates = stTemplates;
}
else
{
-                    templates = StringTemplateGroup.LoadGroup( "ST", coreTemplates );
+                    templates = GetOrCacheTemplateGroup(tool, language, "ST", coreTemplates);
}
}
-            else if ( debug && grammar.type != GrammarType.Lexer )
+            else if (debug && grammarType != GrammarType.Lexer)
{
-                templates = StringTemplateGroup.LoadGroup( "Dbg", coreTemplates );
+                templates = GetOrCacheTemplateGroup(tool, language, "Dbg", coreTemplates);
baseTemplates = templates;
}
else
@@ -431,11 +449,89 @@ namespace Antlr3.Codegen
templates = coreTemplates;
}

-            if ( EmitTemplateDelimiters )
+            if (CodeGenerator.EmitTemplateDelimiters)
+            {
+                templates.EmitDebugStartStopStrings(true);
+                templates.DoNotEmitDebugStringsForTemplate("codeFileExtension");
+                templates.DoNotEmitDebugStringsForTemplate("headerFileExtension");
+            }
+        }
+
+        private static StringTemplateGroup GetOrCacheTemplateGroup(AntlrTool tool, string language, string name, StringTemplateGroup superGroup)
+        {
+#if true // <-- Caching
+            return GetOrCacheTemplateGroup(tool, null, language, name, superGroup);
+#else
+            // get or create the template loader
+            IStringTemplateGroupLoader loader;
+            if (!_templateLoaders.TryGetValue(language, out loader))
+            {
+                string templateDirs =
+                    tool.TemplatesDirectory + ":" +
+                    Path.Combine(tool.TemplatesDirectory, language);
+                loader = new CommonGroupLoader(templateDirs, ErrorManager.GetStringTemplateErrorListener());
+                _templateLoaders[language] = loader;
+            }
+
+            return CacheTemplateGroup(loader, language, name, superGroup);
+#endif
+        }
+
+        private static StringTemplateGroup GetOrCacheTemplateGroup(AntlrTool tool, IStringTemplateGroupLoader loader, string language, string name, StringTemplateGroup superGroup)
+        {
+            if (string.IsNullOrEmpty(name) && superGroup == null)
+            {
+                StringTemplateGroup group;
+                if (_coreTemplates.TryGetValue(language, out group))
+                    return group;
+            }
+            else
{
-                templates.EmitDebugStartStopStrings( true );
-                templates.DoNotEmitDebugStringsForTemplate( "codeFileExtension" );
-                templates.DoNotEmitDebugStringsForTemplate( "headerFileExtension" );
+                Dictionary<string, StringTemplateGroup> languageTemplates;
+                if (_languageTemplates.TryGetValue(superGroup, out languageTemplates))
+                {
+                    StringTemplateGroup group;
+                    if (languageTemplates.TryGetValue(name, out group))
+                        return group;
+                }
+            }
+
+            // get or create the template loader
+            if (loader == null && !_templateLoaders.TryGetValue(language, out loader))
+            {
+                string templateDirs =
+                    tool.TemplatesDirectory + ":" +
+                    Path.Combine(tool.TemplatesDirectory, language);
+                loader = new CommonGroupLoader(templateDirs, ErrorManager.GetStringTemplateErrorListener());
+                _templateLoaders[language] = loader;
+            }
+
+            return CacheTemplateGroup(loader, language, name, superGroup);
+        }
+
+        private static StringTemplateGroup CacheTemplateGroup(IStringTemplateGroupLoader loader, string language, string name, StringTemplateGroup superGroup)
+        {
+            StringTemplateGroup.RegisterGroupLoader(loader, true, true);
+            StringTemplateGroup.RegisterDefaultLexer(typeof(AngleBracketTemplateLexer));
+
+            if (string.IsNullOrEmpty(name) && superGroup == null)
+            {
+                StringTemplateGroup group = StringTemplateGroup.LoadGroup(language);
+                _coreTemplates[language] = group;
+                return group;
+            }
+            else
+            {
+                StringTemplateGroup group = StringTemplateGroup.LoadGroup(name, superGroup);
+                Dictionary<string, StringTemplateGroup> groups;
+                if (!_languageTemplates.TryGetValue(superGroup, out groups))
+                {
+                    groups = new Dictionary<string, StringTemplateGroup>();
+                    _languageTemplates[superGroup] = groups;
+                }
+
+                groups[name] = group;
+                return group;
}
}


