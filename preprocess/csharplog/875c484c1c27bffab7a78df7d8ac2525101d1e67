commit 875c484c1c27bffab7a78df7d8ac2525101d1e67
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri Apr 10 14:56:32 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri Apr 10 14:56:32 2009 -0800

C# Port:
* Code cleanup

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6026]

diff --git a/Antlr3.Test/TestDFAConversion.cs b/Antlr3.Test/TestDFAConversion.cs
index 111afcb..6b95704 100644
--- a/Antlr3.Test/TestDFAConversion.cs
+++ b/Antlr3.Test/TestDFAConversion.cs
@@ -1686,7 +1686,7 @@ namespace AntlrUnitTests
RecursionOverflowMessage recMsg = null;
GrammarNonDeterminismMessage nondetMsg =
getNonDeterminismMessage( equeue.warnings );
-                IList nonDetAlts = null;
+                IList<int> nonDetAlts = null;
if ( nondetMsg != null )
{
nonDetAlts =
diff --git a/Antlr3.Test/TestSemanticPredicates.cs b/Antlr3.Test/TestSemanticPredicates.cs
index 85f0363..c9c6925 100644
--- a/Antlr3.Test/TestSemanticPredicates.cs
+++ b/Antlr3.Test/TestSemanticPredicates.cs
@@ -908,7 +908,7 @@ namespace AntlrUnitTests
getNonDeterminismMessage( equeue.warnings );
assertNotNull( "found no nondet alts; expecting: " +
str( expectingNonDetAlts ), nondetMsg );
-                IList nonDetAlts =
+                var nonDetAlts =
nondetMsg.probe.getNonDeterministicAltsForState( nondetMsg.problemState );
// compare nonDetAlts with expectingNonDetAlts
BitSet s = new BitSet();
diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index 2075cc3..bb0e0f4 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -59,7 +59,7 @@ namespace Antlr3.Analysis

/** Prevent explosion of DFA states during conversion. The max number
*  of states per alt in a single decision's DFA.
-        public static final int MAX_STATES_PER_ALT_IN_DFA = 450;
+        public const int MAX_STATES_PER_ALT_IN_DFA = 450;
*/

/** Set to 0 to not terminate early (time in ms) */
@@ -89,7 +89,6 @@ namespace Antlr3.Analysis
*  Not used during fixed k lookahead as it's a waste to fill it with
*  a dup of states array.
*/
-        //protected Map<DFAState, DFAState> uniqueStates = new HashMap<DFAState, DFAState>();
protected IDictionary<DFAState, DFAState> uniqueStates = new Dictionary<DFAState, DFAState>();

/** Maps the state number to the actual DFAState.  Use a Vector as it
@@ -290,14 +289,16 @@ namespace Antlr3.Analysis
{
get
{
-                return analysisTimedOut();
+                return probe.AnalysisTimedOut;
}
}
public bool CanInlineDecision
{
get
{
-                return canInlineDecision();
+                return !IsCyclic &&
+                    !probe.IsNonLLStarDecision &&
+                    NumberOfStates < CodeGenerator.MAX_ACYCLIC_DFA_STATES_INLINE;
}
}
public bool AutoBacktrackMode
@@ -311,28 +312,28 @@ namespace Antlr3.Analysis
{
get
{
-                return getDecisionASTNode();
+                return decisionNFAStartState.associatedASTNode;
}
}
public int DecisionNumber
{
get
{
-                return getDecisionNumber();
+                return decisionNFAStartState.DecisionNumber;
}
}
public string Description
{
get
{
-                return getDescription();
+                return description;
}
}
public bool IsCyclic
{
get
{
-                return isCyclic();
+                return cyclic && UserMaxLookahead == 0;
}
}
public bool IsGreedy
@@ -346,7 +347,7 @@ namespace Antlr3.Analysis
{
get
{
-                return isReduced();
+                return reduced;
}
}
public bool IsTokensRuleDecision
@@ -360,35 +361,44 @@ namespace Antlr3.Analysis
{
get
{
-                return getMaxLookaheadDepth();
+                if ( IsCyclic )
+                {
+                    return int.MaxValue;
+                }
+                return max_k;
}
}
public int MaxStateNumber
{
get
{
-                return getMaxStateNumber();
+                return states.Count - 1;
}
}
public NFAState NFADecisionStartState
{
get
{
-                return getNFADecisionStartState();
+                return decisionNFAStartState;
}
}
public int NumberOfAlts
{
get
{
-                return getNumberOfAlts();
+                return nAlts;
}
}
public int NumberOfStates
{
get
{
-                return getNumberOfStates();
+                if ( UserMaxLookahead > 0 )
+                {
+                    // if using fixed lookahead then uniqueSets not set
+                    return states.Count;
+                }
+                return numberOfStates;
}
}
public bool OkToRetryWithK1
@@ -409,14 +419,14 @@ namespace Antlr3.Analysis
{
get
{
-                return getUniqueStates();
+                return uniqueStates;
}
}
public ICollection<int> UnreachableAlts
{
get
{
-                return getUnreachableAlts();
+                return unreachableAlts;
}
}
public int UserMaxLookahead
@@ -434,7 +444,7 @@ namespace Antlr3.Analysis
*  will result in states[i] == states[j].  We don't want to waste a state
*  number on this.  Useful mostly for code generation in tables.
*
-         *  At the start of this routine, states[i].stateNumber <= i by definition.
+         *  At the start of this routine, states[i].stateNumber &lt;= i by definition.
*  If states[50].stateNumber is 50 then a cycle during conversion may
*  try to add state 103, but we find that an identical DFA state, named
*  50, already exists, hence, states[103]==states[50] and both have
@@ -534,7 +544,7 @@ namespace Antlr3.Analysis
*  that GIF files use.  Transition tables are heavily compressed by
*  this technique.  I got the idea from JFlex http://jflex.de/
*
-         *  Return List<String> where each string is either \xyz for 8bit char
+         *  Return List&lt;String&gt; where each string is either \xyz for 8bit char
*  and \uFFFF for 16bit.  Hideous and specific to Java, but it is the
*  only target bad enough to need it.
*/
@@ -676,35 +686,41 @@ namespace Antlr3.Analysis
*/
}

-        /*
-        private void testEncodeDecode(List data) {
-            JSystem.@out.println("data="+data);
-            List encoded = getRunLengthEncoding(data);
-            StringBuffer buf = new StringBuffer();
-            for (int i = 0; i < encoded.size(); i++) {
-                String I = (String)encoded.get(i);
+#if false
+        private void testEncodeDecode( int[] data )
+        {
+            JSystem.@out.println( "data=" + data );
+            var encoded = getRunLengthEncoding( data );
+            StringBuilder buf = new StringBuilder();
+            for ( int i = 0; i < encoded.size(); i++ )
+            {
+                String I = (String)encoded.get( i );
int v = 0;
-                if ( I.startsWith("\\u") ) {
-                    v = Integer.parseInt(I.substring(2,I.length()), 16);
+                if ( I.startsWith( "\\u" ) )
+                {
+                    v = int.Parse( I.substring( 2, I.length() ), NumberStyles.HexNumber );
}
-                else {
-                    v = Integer.parseInt(I.substring(1,I.length()), 8);
+                else
+                {
+                    v = int.Parse( I.substring( 1, I.length() ), System.Globalization.NumberStyles.Octal );
}
-                buf.append((char)v);
+                buf.append( (char)v );
}
-            String encodedS = buf.toString();
-            short[] decoded = org.antlr.runtime.DFA.unpackEncodedString(encodedS);
+            String encodedS = buf.ToString();
+            short[] decoded = Antlr.Runtime.DFA.UnpackEncodedString( encodedS );
//JSystem.@out.println("decoded:");
-            for (int i = 0; i < decoded.length; i++) {
+            for ( int i = 0; i < decoded.Length; i++ )
+            {
short x = decoded[i];
-                if ( x!=((Integer)data.get(i)).intValue() ) {
-                    System.err.println("problem with encoding");
+                if ( x != data[i] )
+                {
+                    Console.Error.WriteLine( "problem with encoding" );
}
//JSystem.@out.print(", "+x);
}
//JSystem.@out.println();
}
-        */
+#endif

protected virtual void createMinMaxTables( DFAState s )
{
@@ -932,17 +948,19 @@ namespace Antlr3.Analysis
}
}

+        [Obsolete]
public IDictionary<DFAState, DFAState> getUniqueStates()
{
-            return uniqueStates;
+            return UniqueStates;
}

/** What is the max state number ever created?  This may be beyond
*  getNumberOfStates().
*/
+        [Obsolete]
public int getMaxStateNumber()
{
-            return states.Count - 1;
+            return MaxStateNumber;
}

public virtual DFAState getState( int stateNumber )
@@ -960,9 +978,10 @@ namespace Antlr3.Analysis
*  which paths are "dead ends".  Also tracks list of alts with no accept
*  state in the DFA.  Must call verify() first before this makes sense.
*/
+        [Obsolete]
public virtual bool isReduced()
{
-            return reduced;
+            return IsReduced;
}

/** Is this DFA cyclic?  That is, are there any loops?  If not, then
@@ -971,16 +990,16 @@ namespace Antlr3.Analysis
*  presence of cycles, we need to build a general DFA and interpret it
*  to distinguish between alternatives.
*/
+        [Obsolete]
public virtual bool isCyclic()
{
-            return cyclic && UserMaxLookahead == 0;
+            return IsCyclic;
}

+        [Obsolete]
public virtual bool canInlineDecision()
{
-            return !IsCyclic &&
-                !probe.IsNonLLStarDecision &&
-                NumberOfStates < CodeGenerator.MAX_ACYCLIC_DFA_STATES_INLINE;
+            return CanInlineDecision;
}

/** Is this DFA derived from the NFA for the Tokens rule? */
@@ -1023,22 +1042,20 @@ namespace Antlr3.Analysis
}

/** Return k if decision is LL(k) for some k else return max int */
+        [Obsolete]
public virtual int getMaxLookaheadDepth()
{
-            if ( IsCyclic )
-            {
-                return int.MaxValue;
-            }
-            return max_k;
+            return MaxLookaheadDepth;
}

/** Return a list of Integer alt numbers for which no lookahead could
*  be computed or for which no single DFA accept state predicts those
*  alts.  Must call verify() first before this makes sense.
*/
+        [Obsolete]
public virtual List<int> getUnreachableAlts()
{
-            return unreachableAlts;
+            return (List<int>)UnreachableAlts;
}

/** Once this DFA has been built, need to verify that:
@@ -1076,7 +1093,7 @@ namespace Antlr3.Analysis
if ( d.IsAcceptState )
{
// accept states have no edges emanating from them so we can return
-                d.setAcceptStateReachable( REACHABLE_YES );
+                d.AcceptStateReachable = REACHABLE_YES;
// this alt is uniquely predicted, remove from nondeterministic list
int predicts = d.getUniquelyPredictedAlt();
unreachableAlts.Remove( predicts );
@@ -1084,7 +1101,7 @@ namespace Antlr3.Analysis
}

// avoid infinite loops
-            d.setAcceptStateReachable( REACHABLE_BUSY );
+            d.AcceptStateReachable = REACHABLE_BUSY;

bool anEdgeReachesAcceptState = false;
// Visit every transition, track if at least one edge reaches stop state
@@ -1119,11 +1136,11 @@ namespace Antlr3.Analysis
}
if ( anEdgeReachesAcceptState )
{
-                d.setAcceptStateReachable( REACHABLE_YES );
+                d.AcceptStateReachable = REACHABLE_YES;
}
else
{
-                d.setAcceptStateReachable( REACHABLE_NO );
+                d.AcceptStateReachable = REACHABLE_NO;
reduced = false;
}
return anEdgeReachesAcceptState;
@@ -1159,9 +1176,10 @@ namespace Antlr3.Analysis
}
}

+        [Obsolete]
public virtual NFAState getNFADecisionStartState()
{
-            return decisionNFAStartState;
+            return NFADecisionStartState;
}

public virtual DFAState getAcceptState( int alt )
@@ -1174,14 +1192,16 @@ namespace Antlr3.Analysis
altToAcceptState[alt] = acceptState;
}

+        [Obsolete]
public virtual String getDescription()
{
-            return description;
+            return Description;
}

+        [Obsolete]
public virtual int getDecisionNumber()
{
-            return decisionNFAStartState.DecisionNumber;
+            return DecisionNumber;
}

/** If this DFA failed to finish during construction, we might be
@@ -1237,9 +1257,10 @@ namespace Antlr3.Analysis
*  associated with?  It will point to the start of a block or
*  the loop back of a (...)+ block etc...
*/
+        [Obsolete]
public virtual GrammarAST getDecisionASTNode()
{
-            return decisionNFAStartState.associatedASTNode;
+            return DecisionASTNode;
}

public virtual bool isGreedy()
@@ -1264,24 +1285,22 @@ namespace Antlr3.Analysis
return n;
}

+        [Obsolete]
public virtual int getNumberOfStates()
{
-            if ( UserMaxLookahead > 0 )
-            {
-                // if using fixed lookahead then uniqueSets not set
-                return states.Count;
-            }
-            return numberOfStates;
+            return NumberOfStates;
}

+        [Obsolete]
public virtual int getNumberOfAlts()
{
-            return nAlts;
+            return NumberOfAlts;
}

+        [Obsolete]
public virtual bool analysisTimedOut()
{
-            return probe.AnalysisTimedOut;
+            return AnalysisTimedOut;
}

protected virtual void initAltRelatedInfo()
@@ -1304,6 +1323,7 @@ namespace Antlr3.Analysis
return serializer.serialize( startState, false );
}

+#if false
/** EOT (end of token) is a label that indicates when the DFA conversion
*  algorithm would "fall off the end of a lexer rule".  It normally
*  means the default clause.  So for ('a'..'z')+ you would see a DFA
@@ -1333,6 +1353,7 @@ namespace Antlr3.Analysis
*  If EOT coexists with ALLCHAR:
*  1. If not greedy, modify the labels parameter to be EOT
*  2. If greedy, remove EOT from the labels set
+         */
protected boolean reachableLabelsEOTCoexistsWithAllChar(OrderedHashSet labels)
{
Label eot = new Label(Label.EOT);
@@ -1340,23 +1361,23 @@ namespace Antlr3.Analysis
return false;
}
JSystem.@out.println("### contains EOT");
-            boolean containsAllChar = false;
+            bool containsAllChar = false;
IntervalSet completeVocab = new IntervalSet();
int n = labels.size();
for (int i=0; i<n; i++) {
Label rl = (Label)labels.get(i);
-                if ( !rl.equals(eot) ) {
-                    completeVocab.addAll(rl.getSet());
+                if ( !rl.Equals(eot) ) {
+                    completeVocab.addAll(rl.Set());
}
}
JSystem.@out.println("completeVocab="+completeVocab);
-            if ( completeVocab.equals(Label.ALLCHAR) ) {
+            if ( completeVocab.Equals(Label.ALLCHAR) ) {
JSystem.@out.println("all char");
containsAllChar = true;
}
return containsAllChar;
}
-         */
+#endif
}

}
diff --git a/Antlr3/Analysis/DFAOptimizer.cs b/Antlr3/Analysis/DFAOptimizer.cs
index 49b909d..1ea5cea 100644
--- a/Antlr3/Analysis/DFAOptimizer.cs
+++ b/Antlr3/Analysis/DFAOptimizer.cs
@@ -260,22 +260,27 @@ namespace Antlr3.Analysis
}
}

+#if false
/** Walk DFA states, unlinking the nfa configs and whatever else I
*  can to reduce memory footprint.
-        protected void unlinkUnneededStateData(DFAState d) {
-            Integer sI = Utils.integer(d.stateNumber);
-            if ( visited.contains(sI) ) {
+         */
+        protected virtual void unlinkUnneededStateData( DFAState d )
+        {
+            int sI = d.stateNumber;
+            if ( visited.Contains( sI ) )
+            {
return; // already visited
}
-            visited.add(sI);
+            visited.Add( sI );
d.nfaConfigurations = null;
-            for (int i = 0; i < d.getNumberOfTransitions(); i++) {
-                Transition edge = (Transition) d.transition(i);
-                DFAState edgeTarget = ((DFAState)edge.target);
-                unlinkUnneededStateData(edgeTarget);
+            for ( int i = 0; i < d.NumberOfTransitions; i++ )
+            {
+                Transition edge = (Transition)d.transition( i );
+                DFAState edgeTarget = ( (DFAState)edge.target );
+                unlinkUnneededStateData( edgeTarget );
}
}
-         */
+#endif

}
}
diff --git a/Antlr3/Analysis/DFAState.cs b/Antlr3/Analysis/DFAState.cs
index 8cbfa35..bef518e 100644
--- a/Antlr3/Analysis/DFAState.cs
+++ b/Antlr3/Analysis/DFAState.cs
@@ -179,7 +179,11 @@ namespace Antlr3.Analysis
{
get
{
-                return getAcceptStateReachable();
+                return acceptStateReachable;
+            }
+            set
+            {
+                acceptStateReachable = value;
}
}
public ICollection<int> AltSet
@@ -200,14 +204,23 @@ namespace Antlr3.Analysis
{
get
{
-                return isResolvedWithPredicates();
+                return resolvedWithPredicates;
}
}
public int LookaheadDepth
{
get
{
-                return getLookaheadDepth();
+                return k;
+            }
+            set
+            {
+                k = value;
+                if ( value > dfa.max_k )
+                {
+                    // track max k for entire DFA
+                    dfa.max_k = value;
+                }
}
}
public ICollection<Label> ReachableLabels
@@ -384,7 +397,8 @@ namespace Antlr3.Analysis
"reachableLabels="+reachableLabels.toString());
*/
if ( reachableLabels.Contains( label ) )
-            { // exact label present
+            {
+                // exact label present
return;
}
IIntSet t = label.Set;
@@ -871,19 +885,22 @@ namespace Antlr3.Analysis
}

/** Is an accept state reachable from this state? */
+        [Obsolete]
public virtual int getAcceptStateReachable()
{
-            return acceptStateReachable;
+            return AcceptStateReachable;
}

+        [Obsolete]
public virtual void setAcceptStateReachable( int acceptStateReachable )
{
-            this.acceptStateReachable = acceptStateReachable;
+            AcceptStateReachable = acceptStateReachable;
}

+        [Obsolete]
public virtual bool isResolvedWithPredicates()
{
-            return resolvedWithPredicates;
+            return IsResolvedWithPredicates;
}

/** Print all NFA states plus what alts they predict */
@@ -904,18 +921,16 @@ namespace Antlr3.Analysis
return buf.ToString();
}

+        [Obsolete]
public virtual int getLookaheadDepth()
{
-            return k;
+            return LookaheadDepth;
}

+        [Obsolete]
public virtual void setLookaheadDepth( int k )
{
-            this.k = k;
-            if ( k > dfa.max_k )
-            { // track max k for entire DFA
-                dfa.max_k = k;
-            }
+            LookaheadDepth = k;
}

}
diff --git a/Antlr3/Analysis/DecisionProbe.cs b/Antlr3/Analysis/DecisionProbe.cs
index 787e527..cf6d026 100644
--- a/Antlr3/Analysis/DecisionProbe.cs
+++ b/Antlr3/Analysis/DecisionProbe.cs
@@ -89,7 +89,6 @@ namespace Antlr3.Analysis
*  Note that from the DFA state, you can ask for
*  which alts are nondeterministic.
*/
-        //protected Set<DFAState> statesWithSyntacticallyAmbiguousAltsSet = new HashSet<DFAState>();
protected ICollection<DFAState> statesWithSyntacticallyAmbiguousAltsSet = new HashSet<DFAState>();

/** Track just like stateToSyntacticallyAmbiguousAltsMap, but only
@@ -97,8 +96,6 @@ namespace Antlr3.Analysis
*  ID rule.  The state maps to the list of Tokens rule alts that are
*  in conflict.
*/
-        //protected Map<DFAState, Set<Integer>> stateToSyntacticallyAmbiguousTokensRuleAltsMap =
-        //    new HashMap<DFAState, Set<Integer>>();
protected internal IDictionary<DFAState, ICollection<int>> stateToSyntacticallyAmbiguousTokensRuleAltsMap =
new Dictionary<DFAState, ICollection<int>>();

@@ -106,7 +103,6 @@ namespace Antlr3.Analysis
*  state that predicts more than one alternative, must be resolved
*  with predicates or it should be reported to the user.
*/
-        //protected Set<DFAState> statesResolvedWithSemanticPredicatesSet = new HashSet<DFAState>();
protected ICollection<DFAState> statesResolvedWithSemanticPredicatesSet = new HashSet<DFAState>();

/** Track the predicates for each alt per DFA state;
@@ -114,8 +110,6 @@ namespace Antlr3.Analysis
*  Maps DFA state to another map, mapping alt number to a
*  SemanticContext (pred(s) to execute to resolve syntactic ambiguity).
*/
-        //protected Map<DFAState, Map<Integer,SemanticContext>> stateToAltSetWithSemanticPredicatesMap =
-        //    new HashMap<DFAState, Map<Integer,SemanticContext>>();
protected IDictionary<DFAState, IDictionary<int, SemanticContext>> stateToAltSetWithSemanticPredicatesMap =
new Dictionary<DFAState, IDictionary<int, SemanticContext>>();

@@ -123,19 +117,15 @@ namespace Antlr3.Analysis
*  For example, p1||true gets reduced to true and so leaves
*  whole alt uncovered.  This maps DFA state to the set of alts
*/
-        //protected Map<DFAState,Map<Integer, Set<Token>>> stateToIncompletelyCoveredAltsMap =
-        //    new HashMap<DFAState,Map<Integer, Set<Token>>>();
protected IDictionary<DFAState, IDictionary<int, ICollection<IToken>>> stateToIncompletelyCoveredAltsMap =
new Dictionary<DFAState, IDictionary<int, ICollection<IToken>>>();

/** The set of states w/o emanating edges and w/o resolving sem preds. */
-        //protected Set<DFAState> danglingStates = new HashSet<DFAState>();
protected ICollection<DFAState> danglingStates = new HashSet<DFAState>();

/** The overall list of alts within the decision that have at least one
*  conflicting input sequence.
*/
-        //protected Set<Integer> altsWithProblem = new HashSet<Integer>();
protected ICollection<int> altsWithProblem = new HashSet<int>();

/** If decision with > 1 alt has recursion in > 1 alt, it's nonregular
@@ -147,10 +137,8 @@ namespace Antlr3.Analysis
/** Recursion is limited to a particular depth.  If that limit is exceeded
*  the proposed new NFAConfiguration is recorded for the associated DFA state.
*/
-        //protected MultiMap<Integer, NFAConfiguration> stateToRecursionOverflowConfigurationsMap =
-        //    new MultiMap<Integer, NFAConfiguration>();
-	protected MultiMap<int, NFAConfiguration> stateToRecursionOverflowConfigurationsMap =
-		new MultiMap<int, NFAConfiguration>();
+        protected MultiMap<int, NFAConfiguration> stateToRecursionOverflowConfigurationsMap =
+            new MultiMap<int, NFAConfiguration>();

/*
protected Map<Integer, List<NFAConfiguration>> stateToRecursionOverflowConfigurationsMap =
@@ -169,7 +157,6 @@ namespace Antlr3.Analysis
/** Used to find paths through syntactically ambiguous DFA. If we've
*  seen statement number before, what did we learn?
*/
-        //protected Map<Integer, Integer> stateReachable;
protected IDictionary<int, int> stateReachable;

public const int REACHABLE_BUSY = -1;
@@ -183,10 +170,8 @@ namespace Antlr3.Analysis
*  infinite loop.  Stop.  Set<String>.  The strings look like
*  stateNumber_labelIndex.
*/
-        //protected Set<String> statesVisitedAtInputDepth;
-        protected ICollection<String> statesVisitedAtInputDepth;
+        protected ICollection<string> statesVisitedAtInputDepth;

-        //protected Set<Integer> statesVisitedDuringSampleSequence;
protected ICollection<int> statesVisitedDuringSampleSequence;

public static bool verbose = false;
@@ -201,49 +186,49 @@ namespace Antlr3.Analysis
{
get
{
-                return analysisOverflowed();
+                return stateToRecursionOverflowConfigurationsMap.Count > 0;
}
}
public bool AnalysisTimedOut
{
get
{
-                return analysisTimedOut();
+                return timedOut;
}
}
public ICollection<DFAState> DanglingStates
{
get
{
-                return getDanglingStates();
+                return danglingStates;
}
}
public string Description
{
get
{
-                return getDescription();
+                return dfa.NFADecisionStartState.Description;
}
}
public ICollection<DFAState> DFAStatesWithSyntacticallyAmbiguousAlts
{
get
{
-                return getDFAStatesWithSyntacticallyAmbiguousAlts();
+                return statesWithSyntacticallyAmbiguousAltsSet;
}
}
public bool HasPredicate
{
get
{
-                return hasPredicate();
+                return stateToAltSetWithSemanticPredicatesMap.Count > 0;
}
}
public bool IsCyclic
{
get
{
-                return isCyclic();
+                return dfa.IsCyclic;
}
}
public bool IsDeterministic
@@ -257,42 +242,42 @@ namespace Antlr3.Analysis
{
get
{
-                return isNonLLStarDecision();
+                return nonLLStarDecision;
}
}
public bool IsReduced
{
get
{
-                return isReduced();
+                return dfa.IsReduced;
}
}
public ICollection<int> NonDeterministicAlts
{
get
{
-                return getNonDeterministicAlts();
+                return altsWithProblem;
}
}
public ICollection<DFAState> NondeterministicStatesResolvedWithSemanticPredicate
{
get
{
-                return getNondeterministicStatesResolvedWithSemanticPredicate();
+                return statesResolvedWithSemanticPredicatesSet;
}
}
public int NumberOfStates
{
get
{
-                return getNumberOfStates();
+                return dfa.NumberOfStates;
}
}
public ICollection<int> UnreachableAlts
{
get
{
-                return getUnreachableAlts();
+                return dfa.UnreachableAlts;
}
}
#endregion
@@ -302,19 +287,22 @@ namespace Antlr3.Analysis
/** Return a string like "3:22: ( A {;} | B )" that describes this
*  decision.
*/
+        [Obsolete]
public virtual String getDescription()
{
-            return dfa.NFADecisionStartState.Description;
+            return Description;
}

+        [Obsolete]
public virtual bool isReduced()
{
-            return dfa.IsReduced;
+            return IsReduced;
}

+        [Obsolete]
public virtual bool isCyclic()
{
-            return dfa.IsCyclic;
+            return IsCyclic;
}

/** If no states are dead-ends, no alts are unreachable, there are
@@ -357,27 +345,31 @@ namespace Antlr3.Analysis
}

/** Did the analysis complete it's work? */
+        [Obsolete]
public virtual bool analysisTimedOut()
{
-            return timedOut;
+            return AnalysisTimedOut;
}

/** Took too long to analyze a DFA */
+        [Obsolete]
public virtual bool analysisOverflowed()
{
-            return stateToRecursionOverflowConfigurationsMap.Count > 0;
+            return AnalysisOverflowed;
}

/** Found recursion in > 1 alt */
+        [Obsolete]
public virtual bool isNonLLStarDecision()
{
-            return nonLLStarDecision;
+            return IsNonLLStarDecision;
}

/** How many states does the DFA predictor have? */
+        [Obsolete]
public virtual int getNumberOfStates()
{
-            return dfa.NumberOfStates;
+            return NumberOfStates;
}

/** Get a list of all unreachable alternatives for this decision.  There
@@ -385,9 +377,10 @@ namespace Antlr3.Analysis
*  is the overall list of unreachable alternatives (either due to
*  conflict resolution or alts w/o accept states).
*/
+        [Obsolete]
public virtual IList<int> getUnreachableAlts()
{
-            return (IList<int>)dfa.UnreachableAlts;
+            return (IList<int>)UnreachableAlts;
}

/** return set of states w/o emanating edges and w/o resolving sem preds.
@@ -395,20 +388,22 @@ namespace Antlr3.Analysis
*  terminate early to avoid infinite recursion for example (due to
*  left recursion perhaps).
*/
+        [Obsolete]
public virtual ICollection<DFAState> getDanglingStates()
{
-            return danglingStates;
+            return DanglingStates;
}

+        [Obsolete]
public virtual ICollection<int> getNonDeterministicAlts()
{
-            return altsWithProblem;
+            return NonDeterministicAlts;
}

/** Return the sorted list of alts that conflict within a single state.
*  Note that predicates may resolve the conflict.
*/
-        public virtual IList getNonDeterministicAltsForState( DFAState targetState )
+        public virtual IList<int> getNonDeterministicAltsForState( DFAState targetState )
{
IEnumerable<int> nondetAlts = targetState.getNonDeterministicAlts();
if ( nondetAlts == null )
@@ -431,9 +426,10 @@ namespace Antlr3.Analysis
*  conflict.  You must report a problem for each state in this set
*  because each state represents a different input sequence.
*/
+        [Obsolete]
public virtual ICollection<DFAState> getDFAStatesWithSyntacticallyAmbiguousAlts()
{
-            return statesWithSyntacticallyAmbiguousAltsSet;
+            return DFAStatesWithSyntacticallyAmbiguousAlts;
}

/** Which alts were specifically turned off to resolve nondeterminisms?
@@ -452,7 +448,6 @@ namespace Antlr3.Analysis
*/
public virtual void removeRecursiveOverflowState( DFAState d )
{
-            //Integer stateI = Utils.integer( d.stateNumber );
stateToRecursionOverflowConfigurationsMap.Remove( d.stateNumber );
}

@@ -476,7 +471,7 @@ namespace Antlr3.Analysis
return labels;
}

-        /** Given IList<Label>, return a String with a useful representation
+        /** Given IList&lt;Label&gt;, return a String with a useful representation
*  of the associated input string.  One could show something different
*  for lexers and parsers, for example.
*/
@@ -484,10 +479,8 @@ namespace Antlr3.Analysis
{
Grammar g = dfa.nfa.grammar;
StringBuilder buf = new StringBuilder();
-            //for ( Iterator it = labels.iterator(); it.hasNext(); )
foreach ( Label label in labels )
{
-                //Label label = (Label)it.next();
buf.Append( label.ToString( g ) );
if ( /*it.hasNext() &&*/ g.type != Grammar.LEXER )
{
@@ -572,14 +565,16 @@ namespace Antlr3.Analysis
}

/** At least one alt refs a sem or syn pred */
+        [Obsolete]
public virtual bool hasPredicate()
{
-            return stateToAltSetWithSemanticPredicatesMap.Count > 0;
+            return HasPredicate;
}

+        [Obsolete]
public virtual ICollection<DFAState> getNondeterministicStatesResolvedWithSemanticPredicate()
{
-            return statesResolvedWithSemanticPredicatesSet;
+            return NondeterministicStatesResolvedWithSemanticPredicate;
}

/** Return a list of alts whose predicate context was insufficient to
@@ -646,7 +641,7 @@ namespace Antlr3.Analysis
ICollection<DFAState> danglingStates = DanglingStates;
if ( danglingStates.Count > 0 )
{
-                //System.err.println("no emanating edges for states: "+danglingStates);
+                //Console.Error.WriteLine( "no emanating edges for states: " + danglingStates );
foreach ( DFAState d in danglingStates )
{
ErrorManager.danglingState( this, d );
diff --git a/Antlr3/Analysis/LL1Analyzer.cs b/Antlr3/Analysis/LL1Analyzer.cs
index 3a14f7f..e134a28 100644
--- a/Antlr3/Analysis/LL1Analyzer.cs
+++ b/Antlr3/Analysis/LL1Analyzer.cs
@@ -71,27 +71,31 @@ namespace Antlr3.Analysis
this.grammar = grammar;
}

-        /*
-        public void computeRuleFIRSTSets() {
-            if ( getNumberOfDecisions()==0 ) {
+#if false
+        public virtual void computeRuleFIRSTSets()
+        {
+            if ( NumberOfDecisions == 0 )
+            {
createNFAs();
}
-            for (Iterator it = getRules().iterator(); it.hasNext();) {
+            for ( Iterator it = getRules().iterator(); it.hasNext(); )
+            {
Rule r = (Rule)it.next();
-                if ( r.isSynPred ) {
+                if ( r.isSynPred )
+                {
continue;
}
-                LookaheadSet s = FIRST(r);
-                JSystem.@out.println("FIRST("+r.name+")="+s);
+                LookaheadSet s = FIRST( r );
+                JSystem.@out.println( "FIRST(" + r.name + ")=" + s );
}
}
-        */
+#endif

-        /*
-        public Set<String> getOverriddenRulesWithDifferentFIRST() {
+#if false
+        public HashSet<string> getOverriddenRulesWithDifferentFIRST() {
// walk every rule in this grammar and compare FIRST set with
// those in imported grammars.
-            Set<String> rules = new HashSet();
+            HashSet<string> rules = new HashSet<string>();
for (Iterator it = getRules().iterator(); it.hasNext();) {
Rule r = (Rule)it.next();
//JSystem.@out.println(r.name+" FIRST="+r.FIRST);
@@ -126,16 +130,16 @@ namespace Antlr3.Analysis
}
return rules;
}
-    */
+#endif

-        /*
+#if false
public LookaheadSet LOOK(Rule r) {
if ( r.FIRST==null ) {
r.FIRST = FIRST(r.startState);
}
return r.FIRST;
}
-    */
+#endif

/** From an NFA state, s, find the set of all labels reachable from s.
*  Used to compute follow sets for error recovery.  Never computes
diff --git a/Antlr3/Analysis/Label.cs b/Antlr3/Analysis/Label.cs
index d7cd096..95941d0 100644
--- a/Antlr3/Analysis/Label.cs
+++ b/Antlr3/Analysis/Label.cs
@@ -367,6 +367,7 @@ namespace Antlr3.Analysis
return this.label - ( (Label)o ).label;
}

+#if false
/** Predicates are lists of AST nodes from the NFA created from the
*  grammar, but the same predicate could be cut/paste into multiple
*  places in the grammar.  I must compare the text of all the
@@ -378,7 +379,6 @@ namespace Antlr3.Analysis
*  At this point, Labels are not compared for equals when they are
*  predicates, but here's the code for future use.
*/
-        /*
protected boolean predicatesEquals(Set others) {
Iterator iter = semanticContext.iterator();
while (iter.hasNext()) {
@@ -393,7 +393,7 @@ namespace Antlr3.Analysis
}
return true;
}
-          */
+#endif

public override string ToString()
{
@@ -417,7 +417,7 @@ namespace Antlr3.Analysis
}
}

-        /*
+#if false
public String predicatesToString() {
if ( semanticContext==NFAConfiguration.DEFAULT_CLAUSE_SEMANTIC_CONTEXT ) {
return "!other preds";
@@ -433,7 +433,7 @@ namespace Antlr3.Analysis
}
return buf.toString();
}
-        */
+#endif

public static bool intersect( Label label, Label edgeLabel )
{
diff --git a/Antlr3/Analysis/NFAContext.cs b/Antlr3/Analysis/NFAContext.cs
index b99c1f1..6685a74 100644
--- a/Antlr3/Analysis/NFAContext.cs
+++ b/Antlr3/Analysis/NFAContext.cs
@@ -252,21 +252,26 @@ namespace Antlr3.Analysis
return true;
}

+#if false
/** Walk upwards to the root of the call stack context looking
*  for a particular invoking state.
-        public boolean contains(int state) {
+         */
+        public virtual bool contains( int state )
+        {
NFAContext sp = this;
int n = 0; // track recursive invocations of state
-            JSystem.@out.println("this.context is "+sp);
-            while ( sp.parent!=null ) {
-                if ( sp.invokingState.stateNumber == state ) {
+            System.Console.Out.WriteLine( "this.context is " + sp );
+            while ( sp.parent != null )
+            {
+                if ( sp.invokingState.stateNumber == state )
+                {
return true;
}
sp = sp.parent;
}
return false;
}
-         */
+#endif

/** Given an NFA state number, how many times has the NFA-to-DFA
*  conversion pushed that state on the stack?  In other words,
diff --git a/Antlr3/Analysis/NFAState.cs b/Antlr3/Analysis/NFAState.cs
index 06f6347..8972b38 100644
--- a/Antlr3/Analysis/NFAState.cs
+++ b/Antlr3/Analysis/NFAState.cs
@@ -290,7 +290,7 @@ namespace Antlr3.Analysis
*/
public void setDecisionASTNode( GrammarAST decisionASTNode )
{
-            decisionASTNode.setNFAStartState( this );
+            decisionASTNode.NFAStartState = this;
this.associatedASTNode = decisionASTNode;
}

diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index 7dc73a3..fe6f5bb 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -339,7 +339,7 @@ namespace Antlr3.Analysis
// We are possibly setting the depth of a pre-existing state
// that is equal to one we just computed...not sure if that's
// ok.
-                targetState.setLookaheadDepth( d.LookaheadDepth + 1 );
+                targetState.LookaheadDepth = d.LookaheadDepth + 1;
}

//JSystem.@out.println("DFA after reach / closures:\n"+dfa);
@@ -349,7 +349,7 @@ namespace Antlr3.Analysis
//JSystem.@out.println("dangling DFA state "+d+"\nAfter reach / closures:\n"+dfa);
// TODO: can fixed lookahead hit a dangling state case?
// TODO: yes, with left recursion
-                //System.err.println("dangling state alts: "+d.getAltSet());
+                //Console.Error.WriteLine( "dangling state alts: " + d.getAltSet() );
dfa.probe.reportDanglingState( d );
// turn off all configurations except for those associated with
// min alt number; somebody has to win else some input will not
@@ -385,14 +385,14 @@ namespace Antlr3.Analysis
*
*  The normal decision to predict alts 1, 2, 3 is:
*
-         *  if ( (input.LA(1)>='1' && input.LA(1)<='9') ) {
+         *  if ( (input.LA(1)>='1' && input.LA(1)&lt;='9') ) {
*       alt7=1;
*  }
*  else if ( input.LA(1)=='0' ) {
*      if ( input.LA(2)=='X'||input.LA(2)=='x' ) {
*          alt7=2;
*      }
-         *      else if ( (input.LA(2)>='0' && input.LA(2)<='7') ) {
+         *      else if ( (input.LA(2)>='0' && input.LA(2)&lt;='7') ) {
*           alt7=3;
*      }
*      else if ( input.LA(2)=='L'||input.LA(2)=='l' ) {
@@ -410,7 +410,7 @@ namespace Antlr3.Analysis
*
*  A better decision is as follows:
*
-         *  if ( (input.LA(1)>='1' && input.LA(1)<='9') ) {
+         *  if ( (input.LA(1)>='1' && input.LA(1)&lt;='9') ) {
*      alt7=1;
*  }
*  else if ( input.LA(1)=='0' ) {
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index 4f9375b..65f484b 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -623,8 +623,7 @@ namespace Antlr3
if ( TestMode )
grammar.DefaultRuleModifier = "public";
composite.setDelegationRoot( grammar );
-            //FileReader fr = null;
-            //fr = new FileReader( grammarFileName );
+
string f = null;

if ( haveInputDir )
@@ -651,13 +650,9 @@ namespace Antlr3
grammarOutputDirectory = grammarFileName.Substring( 0, grammarFileName.LastIndexOfAny( new char[] { Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar } ) );
}

-            //BufferedReader br = new BufferedReader( fr );
-            //grammar.parseAndBuildAST( br );
StringReader reader = new StringReader( System.IO.File.ReadAllText( f ) );
grammar.parseAndBuildAST( reader );
composite.watchNFAConversion = internalOption_watchNFAConversion;
-            //br.close();
-            //fr.close();
return grammar;
}

@@ -698,7 +693,8 @@ namespace Antlr3
{
Grammar @delegate = (Grammar)delegates[i];
if ( @delegate != grammar )
-                    { // already processing this one
+                    {
+                        // already processing this one
generateRecognizer( @delegate );
}
}
diff --git a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
index 8d3575f..49d0b55 100644
--- a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
+++ b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
@@ -60,7 +60,7 @@ namespace Antlr3.Codegen
DFAState s,
int k )
{
-            //System.out.println("walk "+s.stateNumber+" in dfa for decision "+dfa.decisionNumber);
+            //System.Console.Out.WriteLine( "walk " + s.stateNumber + " in dfa for decision " + dfa.decisionNumber );
if ( s.IsAcceptState )
{
StringTemplate dfaST2 = templates.GetInstanceOf( "dfaAcceptState" );
@@ -96,20 +96,21 @@ namespace Antlr3.Codegen
dfaST.SetAttribute( "semPredState",
s.IsResolvedWithPredicates );
/*
-            String description = dfa.getNFADecisionStartState().getDescription();
-            description = parentGenerator.target.getTargetStringLiteralFromString(description);
-            //System.out.println("DFA: "+description+" associated with AST "+dfa.getNFADecisionStartState());
-            if ( description!=null ) {
-                dfaST.setAttribute("description", description);
+            string description = dfa.getNFADecisionStartState().Description;
+            description = parentGenerator.target.getTargetStringLiteralFromString( description );
+            //System.Console.Out.WriteLine( "DFA: " + description + " associated with AST " + dfa.getNFADecisionStartState() );
+            if ( description != null )
+            {
+                dfaST.SetAttribute( "description", description );
}
*/
int EOTPredicts = NFA.INVALID_ALT_NUMBER;
DFAState EOTTarget = null;
-            //System.out.println("DFA state "+s.stateNumber);
+            //System.Console.Out.WriteLine( "DFA state " + s.stateNumber );
for ( int i = 0; i < s.NumberOfTransitions; i++ )
{
Transition edge = (Transition)s.transition( i );
-                //System.out.println("edge "+s.stateNumber+"-"+edge.label.toString()+"->"+edge.target.stateNumber);
+                //System.Console.Out.WriteLine( "edge " + s.stateNumber + "-" + edge.label.ToString() + "->" + edge.target.stateNumber );
if ( edge.label.Atom == Label.EOT )
{
// don't generate a real edge for EOT; track alt EOT predicts
@@ -117,7 +118,7 @@ namespace Antlr3.Codegen
EOTTarget = (DFAState)edge.target;
EOTPredicts = EOTTarget.getUniquelyPredictedAlt();
/*
-                    System.out.println("DFA s"+s.stateNumber+" EOT goes to s"+
+                    System.Console.Out.WriteLine("DFA s"+s.stateNumber+" EOT goes to s"+
edge.target.stateNumber+" predicates alt "+
EOTPredicts);
*/
@@ -144,7 +145,7 @@ namespace Antlr3.Codegen
target.getGatedPredicatesInNFAConfigurations();
if ( preds != null )
{
-                        //System.out.println("preds="+target.getGatedPredicatesInNFAConfigurations());
+                        //System.Console.Out.WriteLine( "preds=" + target.getGatedPredicatesInNFAConfigurations() );
StringTemplate predST = preds.genExpr( parentGenerator,
parentGenerator.Templates,
dfa );
@@ -159,10 +160,7 @@ namespace Antlr3.Codegen
k + 1 );
edgeST.SetAttribute( "targetState", targetST );
dfaST.SetAttribute( "edges", edgeST );
-                /*
-                System.out.println("back to DFA "+
-                                   dfa.decisionNumber+"."+s.stateNumber);
-                                   */
+                //System.Console.Out.WriteLine( "back to DFA " + dfa.decisionNumber + "." + s.stateNumber );
}

// HANDLE EOT EDGE
@@ -188,7 +186,7 @@ namespace Antlr3.Codegen
edgeST.SetAttribute( "labelExpr",
parentGenerator.genSemanticPredicateExpr( templates, predEdge ) );
// the target must be an accept state
-                    //System.out.println("EOT edge");
+                    //System.Console.Out.WriteLine( "EOT edge" );
StringTemplate targetST =
walkFixedDFAGeneratingStateMachine( templates,
dfa,
diff --git a/Antlr3/Grammars/ANTLRParserHelper.cs b/Antlr3/Grammars/ANTLRParserHelper.cs
index c5a098b..0088d6b 100644
--- a/Antlr3/Grammars/ANTLRParserHelper.cs
+++ b/Antlr3/Grammars/ANTLRParserHelper.cs
@@ -59,7 +59,7 @@ namespace Antlr3.Grammars
public GrammarASTErrorNode( ITokenStream input, IToken start, IToken stop,
RecognitionException e )
{
-                //System.out.println("start: "+start+", stop: "+stop);
+                //Console.Out.WriteLine( "start: " + start + ", stop: " + stop );
if ( stop == null ||
( stop.TokenIndex < start.TokenIndex &&
stop.Type != TokenConstants.Eof ) )
@@ -325,7 +325,7 @@ namespace Antlr3.Grammars
adaptor.AddChild( rule, adaptor.Create( RET, "RET" ) );
adaptor.AddChild( rule, adaptor.Create( SCOPE, "scope" ) );
adaptor.AddChild( rule, block );
-            adaptor.AddChild( rule, adaptor.Create( EOR, block.getLastChild().Token, "<end-of-rule>" ) );
+            adaptor.AddChild( rule, adaptor.Create( EOR, block.LastChild.Token, "<end-of-rule>" ) );

return rule;
}
diff --git a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
index 5f88792..5e33b3d 100644
--- a/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
+++ b/Antlr3/Grammars/ActionAnalysisLexerHelper.cs
@@ -53,7 +53,7 @@ namespace Antlr3.Grammars

public void analyze()
{
-            // System.out.println("###\naction="+actionToken);
+            //System.Console.Out.WriteLine( "###\naction=" + actionToken );
IToken t;
do
{
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.cs b/Antlr3/Grammars/CodeGenTreeWalker.cs
index 32f9169..12e67d7 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-10 15:22:10
+// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-10 17:42:48

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -3238,7 +3238,7 @@ public partial class CodeGenTreeWalker : TreeParser

Antlr3.Analysis.DFA dfa=null;
GrammarAST b = (GrammarAST)((GrammarAST)retval.start).GetChild(0);
-			GrammarAST eob = (GrammarAST)b.getLastChild(); // loops will use EOB DFA
+			GrammarAST eob = (GrammarAST)b.LastChild; // loops will use EOB DFA

try
{
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index 37bf060..9c4c628 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -668,7 +668,7 @@ ebnf returns [StringTemplate code=null]
{
Antlr3.Analysis.DFA dfa=null;
GrammarAST b = (GrammarAST)$start.GetChild(0);
-	GrammarAST eob = (GrammarAST)b.getLastChild(); // loops will use EOB DFA
+	GrammarAST eob = (GrammarAST)b.LastChild; // loops will use EOB DFA
}
:	(	{ dfa = $start.LookaheadDFA; }
blk=block["block", dfa]
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.cs b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
index 5303a97..3f31597 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.cs
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\DefineGrammarItemsWalker.g3 2009-04-10 15:22:19
+// $ANTLR 3.1.2 Grammars\\DefineGrammarItemsWalker.g3 2009-04-10 17:46:17

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -43,7 +43,9 @@ using System;
using Antlr3.Tool;
using boolean = System.Boolean;
using Character = java.lang.Character;
+#if DEBUG
using Utils = Antlr3.Misc.Utils;
+#endif


using System.Collections.Generic;
@@ -197,7 +199,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "grammar_"
-	// Grammars\\DefineGrammarItemsWalker.g3:91:0: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) );
+	// Grammars\\DefineGrammarItemsWalker.g3:93:0: public grammar_[Grammar g] : ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) );
public DefineGrammarItemsWalker.grammar__return grammar_( Grammar g )
{
DefineGrammarItemsWalker.grammar__return retval = new DefineGrammarItemsWalker.grammar__return();
@@ -209,7 +211,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:101:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:103:4: ( ^( LEXER_GRAMMAR grammarSpec ) | ^( PARSER_GRAMMAR grammarSpec ) | ^( TREE_GRAMMAR grammarSpec ) | ^( COMBINED_GRAMMAR grammarSpec ) )
int alt1=4;
switch ( input.LA(1) )
{
@@ -245,7 +247,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt1 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:101:4: ^( LEXER_GRAMMAR grammarSpec )
+				// Grammars\\DefineGrammarItemsWalker.g3:103:4: ^( LEXER_GRAMMAR grammarSpec )
{
Match(input,LEXER_GRAMMAR,Follow._LEXER_GRAMMAR_in_grammar_77); if (state.failed) return retval;

@@ -266,7 +268,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:102:4: ^( PARSER_GRAMMAR grammarSpec )
+				// Grammars\\DefineGrammarItemsWalker.g3:104:4: ^( PARSER_GRAMMAR grammarSpec )
{
Match(input,PARSER_GRAMMAR,Follow._PARSER_GRAMMAR_in_grammar_92); if (state.failed) return retval;

@@ -287,7 +289,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:103:4: ^( TREE_GRAMMAR grammarSpec )
+				// Grammars\\DefineGrammarItemsWalker.g3:105:4: ^( TREE_GRAMMAR grammarSpec )
{
Match(input,TREE_GRAMMAR,Follow._TREE_GRAMMAR_in_grammar_106); if (state.failed) return retval;

@@ -308,7 +310,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:104:4: ^( COMBINED_GRAMMAR grammarSpec )
+				// Grammars\\DefineGrammarItemsWalker.g3:106:4: ^( COMBINED_GRAMMAR grammarSpec )
{
Match(input,COMBINED_GRAMMAR,Follow._COMBINED_GRAMMAR_in_grammar_120); if (state.failed) return retval;

@@ -351,7 +353,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "attrScope"
-	// Grammars\\DefineGrammarItemsWalker.g3:107:0: attrScope : ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:109:0: attrScope : ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) ;
private void attrScope(  )
{
AttributeScopeActions_scope.PushScope(this);
@@ -364,14 +366,14 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:113:4: ( ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:113:4: ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:115:4: ( ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:115:4: ^( 'scope' name= ID ( attrScopeAction )* attrs= ACTION )
{
Match(input,SCOPE,Follow._SCOPE_in_attrScope150); if (state.failed) return ;

Match(input, TokenConstants.Down, null); if (state.failed) return ;
name=(GrammarAST)Match(input,ID,Follow._ID_in_attrScope154); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:113:23: ( attrScopeAction )*
+			// Grammars\\DefineGrammarItemsWalker.g3:115:23: ( attrScopeAction )*
for ( ; ; )
{
int alt2=2;
@@ -386,7 +388,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt2 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:113:0: attrScopeAction
+					// Grammars\\DefineGrammarItemsWalker.g3:115:0: attrScopeAction
{
PushFollow(Follow._attrScopeAction_in_attrScope156);
attrScopeAction();
@@ -439,7 +441,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "attrScopeAction"
-	// Grammars\\DefineGrammarItemsWalker.g3:123:0: attrScopeAction : ^( AMPERSAND ID ACTION ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:125:0: attrScopeAction : ^( AMPERSAND ID ACTION ) ;
private void attrScopeAction(  )
{
GrammarAST ID1=null;
@@ -447,8 +449,8 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:124:4: ( ^( AMPERSAND ID ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:124:4: ^( AMPERSAND ID ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:126:4: ( ^( AMPERSAND ID ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:126:4: ^( AMPERSAND ID ACTION )
{
Match(input,AMPERSAND,Follow._AMPERSAND_in_attrScopeAction179); if (state.failed) return ;

@@ -481,7 +483,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "grammarSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:130:0: grammarSpec : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules ;
+	// Grammars\\DefineGrammarItemsWalker.g3:132:0: grammarSpec : id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules ;
private void grammarSpec(  )
{
GrammarAST id=null;
@@ -489,11 +491,11 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:131:4: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules )
-			// Grammars\\DefineGrammarItemsWalker.g3:131:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules
+			// Grammars\\DefineGrammarItemsWalker.g3:133:4: (id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules )
+			// Grammars\\DefineGrammarItemsWalker.g3:133:4: id= ID (cmt= DOC_COMMENT )? ( optionsSpec )? ( delegateGrammars )? ( tokensSpec )? ( attrScope )* ( actions )? rules
{
id=(GrammarAST)Match(input,ID,Follow._ID_in_grammarSpec201); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:132:3: (cmt= DOC_COMMENT )?
+			// Grammars\\DefineGrammarItemsWalker.g3:134:3: (cmt= DOC_COMMENT )?
int alt3=2;
int LA3_0 = input.LA(1);

@@ -504,7 +506,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt3 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:132:4: cmt= DOC_COMMENT
+				// Grammars\\DefineGrammarItemsWalker.g3:134:4: cmt= DOC_COMMENT
{
cmt=(GrammarAST)Match(input,DOC_COMMENT,Follow._DOC_COMMENT_in_grammarSpec208); if (state.failed) return ;

@@ -513,7 +515,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

}

-			// Grammars\\DefineGrammarItemsWalker.g3:133:3: ( optionsSpec )?
+			// Grammars\\DefineGrammarItemsWalker.g3:135:3: ( optionsSpec )?
int alt4=2;
int LA4_0 = input.LA(1);

@@ -524,7 +526,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt4 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:133:5: optionsSpec
+				// Grammars\\DefineGrammarItemsWalker.g3:135:5: optionsSpec
{
PushFollow(Follow._optionsSpec_in_grammarSpec216);
optionsSpec();
@@ -537,7 +539,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

}

-			// Grammars\\DefineGrammarItemsWalker.g3:134:3: ( delegateGrammars )?
+			// Grammars\\DefineGrammarItemsWalker.g3:136:3: ( delegateGrammars )?
int alt5=2;
int LA5_0 = input.LA(1);

@@ -548,7 +550,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt5 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:134:4: delegateGrammars
+				// Grammars\\DefineGrammarItemsWalker.g3:136:4: delegateGrammars
{
PushFollow(Follow._delegateGrammars_in_grammarSpec224);
delegateGrammars();
@@ -561,7 +563,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

}

-			// Grammars\\DefineGrammarItemsWalker.g3:135:3: ( tokensSpec )?
+			// Grammars\\DefineGrammarItemsWalker.g3:137:3: ( tokensSpec )?
int alt6=2;
int LA6_0 = input.LA(1);

@@ -572,7 +574,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt6 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:135:4: tokensSpec
+				// Grammars\\DefineGrammarItemsWalker.g3:137:4: tokensSpec
{
PushFollow(Follow._tokensSpec_in_grammarSpec231);
tokensSpec();
@@ -585,7 +587,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

}

-			// Grammars\\DefineGrammarItemsWalker.g3:136:3: ( attrScope )*
+			// Grammars\\DefineGrammarItemsWalker.g3:138:3: ( attrScope )*
for ( ; ; )
{
int alt7=2;
@@ -600,7 +602,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt7 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:136:4: attrScope
+					// Grammars\\DefineGrammarItemsWalker.g3:138:4: attrScope
{
PushFollow(Follow._attrScope_in_grammarSpec238);
attrScope();
@@ -620,7 +622,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
;


-			// Grammars\\DefineGrammarItemsWalker.g3:137:3: ( actions )?
+			// Grammars\\DefineGrammarItemsWalker.g3:139:3: ( actions )?
int alt8=2;
int LA8_0 = input.LA(1);

@@ -631,7 +633,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt8 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:137:4: actions
+				// Grammars\\DefineGrammarItemsWalker.g3:139:4: actions
{
PushFollow(Follow._actions_in_grammarSpec245);
actions();
@@ -667,15 +669,15 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "actions"
-	// Grammars\\DefineGrammarItemsWalker.g3:141:0: actions : ( action )+ ;
+	// Grammars\\DefineGrammarItemsWalker.g3:143:0: actions : ( action )+ ;
private void actions(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( ( action )+ )
-			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( action )+
+			// Grammars\\DefineGrammarItemsWalker.g3:144:4: ( ( action )+ )
+			// Grammars\\DefineGrammarItemsWalker.g3:144:4: ( action )+
{
-			// Grammars\\DefineGrammarItemsWalker.g3:142:4: ( action )+
+			// Grammars\\DefineGrammarItemsWalker.g3:144:4: ( action )+
int cnt9=0;
for ( ; ; )
{
@@ -691,7 +693,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt9 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:142:6: action
+					// Grammars\\DefineGrammarItemsWalker.g3:144:6: action
{
PushFollow(Follow._action_in_actions264);
action();
@@ -734,7 +736,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "action"
-	// Grammars\\DefineGrammarItemsWalker.g3:145:0: action : ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:147:0: action : ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) ;
private void action(  )
{
GrammarAST amp=null;
@@ -749,14 +751,14 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:151:4: ( ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:151:4: ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:153:4: ( ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:153:4: ^(amp= AMPERSAND id1= ID (id2= ID a1= ACTION |a2= ACTION ) )
{
amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_action286); if (state.failed) return ;

Match(input, TokenConstants.Down, null); if (state.failed) return ;
id1=(GrammarAST)Match(input,ID,Follow._ID_in_action290); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:152:4: (id2= ID a1= ACTION |a2= ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:154:4: (id2= ID a1= ACTION |a2= ACTION )
int alt10=2;
int LA10_0 = input.LA(1);

@@ -778,7 +780,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt10 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:152:6: id2= ID a1= ACTION
+				// Grammars\\DefineGrammarItemsWalker.g3:154:6: id2= ID a1= ACTION
{
id2=(GrammarAST)Match(input,ID,Follow._ID_in_action299); if (state.failed) return ;
a1=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action303); if (state.failed) return ;
@@ -790,7 +792,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:154:6: a2= ACTION
+				// Grammars\\DefineGrammarItemsWalker.g3:156:6: a2= ACTION
{
a2=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_action319); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -829,20 +831,20 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "optionsSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:163:0: optionsSpec : ^( OPTIONS ( . )* ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:165:0: optionsSpec : ^( OPTIONS ( . )* ) ;
private void optionsSpec(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:164:4: ( ^( OPTIONS ( . )* ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:164:4: ^( OPTIONS ( . )* )
+			// Grammars\\DefineGrammarItemsWalker.g3:166:4: ( ^( OPTIONS ( . )* ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:166:4: ^( OPTIONS ( . )* )
{
Match(input,OPTIONS,Follow._OPTIONS_in_optionsSpec353); if (state.failed) return ;

if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return ;
-				// Grammars\\DefineGrammarItemsWalker.g3:164:14: ( . )*
+				// Grammars\\DefineGrammarItemsWalker.g3:166:14: ( . )*
for ( ; ; )
{
int alt11=2;
@@ -861,7 +863,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt11 )
{
case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:164:0: .
+						// Grammars\\DefineGrammarItemsWalker.g3:166:0: .
{
MatchAny(input); if (state.failed) return ;

@@ -898,18 +900,18 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "delegateGrammars"
-	// Grammars\\DefineGrammarItemsWalker.g3:167:0: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:169:0: delegateGrammars : ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) ;
private void delegateGrammars(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:168:4: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:168:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
+			// Grammars\\DefineGrammarItemsWalker.g3:170:4: ( ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:170:4: ^( 'import' ( ^( ASSIGN ID ID ) | ID )+ )
{
Match(input,IMPORT,Follow._IMPORT_in_delegateGrammars370); if (state.failed) return ;

Match(input, TokenConstants.Down, null); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:168:16: ( ^( ASSIGN ID ID ) | ID )+
+			// Grammars\\DefineGrammarItemsWalker.g3:170:16: ( ^( ASSIGN ID ID ) | ID )+
int cnt12=0;
for ( ; ; )
{
@@ -929,7 +931,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt12 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:168:18: ^( ASSIGN ID ID )
+					// Grammars\\DefineGrammarItemsWalker.g3:170:18: ^( ASSIGN ID ID )
{
Match(input,ASSIGN,Follow._ASSIGN_in_delegateGrammars375); if (state.failed) return ;

@@ -942,7 +944,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-					// Grammars\\DefineGrammarItemsWalker.g3:168:36: ID
+					// Grammars\\DefineGrammarItemsWalker.g3:170:36: ID
{
Match(input,ID,Follow._ID_in_delegateGrammars384); if (state.failed) return ;

@@ -983,18 +985,18 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "tokensSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:171:0: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:173:0: tokensSpec : ^( TOKENS ( tokenSpec )+ ) ;
private void tokensSpec(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:172:4: ( ^( TOKENS ( tokenSpec )+ ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:172:4: ^( TOKENS ( tokenSpec )+ )
+			// Grammars\\DefineGrammarItemsWalker.g3:174:4: ( ^( TOKENS ( tokenSpec )+ ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:174:4: ^( TOKENS ( tokenSpec )+ )
{
Match(input,TOKENS,Follow._TOKENS_in_tokensSpec402); if (state.failed) return ;

Match(input, TokenConstants.Down, null); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:172:14: ( tokenSpec )+
+			// Grammars\\DefineGrammarItemsWalker.g3:174:14: ( tokenSpec )+
int cnt13=0;
for ( ; ; )
{
@@ -1010,7 +1012,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt13 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:172:16: tokenSpec
+					// Grammars\\DefineGrammarItemsWalker.g3:174:16: tokenSpec
{
PushFollow(Follow._tokenSpec_in_tokensSpec406);
tokenSpec();
@@ -1055,14 +1057,14 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "tokenSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:175:0: tokenSpec : (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) );
+	// Grammars\\DefineGrammarItemsWalker.g3:177:0: tokenSpec : (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) );
private void tokenSpec(  )
{
GrammarAST t=null;

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:176:4: (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:178:4: (t= TOKEN_REF | ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) ) )
int alt14=2;
int LA14_0 = input.LA(1);

@@ -1084,14 +1086,14 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt14 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:176:4: t= TOKEN_REF
+				// Grammars\\DefineGrammarItemsWalker.g3:178:4: t= TOKEN_REF
{
t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_tokenSpec424); if (state.failed) return ;

}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:177:4: ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) )
+				// Grammars\\DefineGrammarItemsWalker.g3:179:4: ^( ASSIGN TOKEN_REF ( STRING_LITERAL | CHAR_LITERAL ) )
{
Match(input,ASSIGN,Follow._ASSIGN_in_tokenSpec431); if (state.failed) return ;

@@ -1131,15 +1133,15 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "rules"
-	// Grammars\\DefineGrammarItemsWalker.g3:185:0: rules : ( rule )+ ;
+	// Grammars\\DefineGrammarItemsWalker.g3:187:0: rules : ( rule )+ ;
private void rules(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( ( rule )+ )
-			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( rule )+
+			// Grammars\\DefineGrammarItemsWalker.g3:188:4: ( ( rule )+ )
+			// Grammars\\DefineGrammarItemsWalker.g3:188:4: ( rule )+
{
-			// Grammars\\DefineGrammarItemsWalker.g3:186:4: ( rule )+
+			// Grammars\\DefineGrammarItemsWalker.g3:188:4: ( rule )+
int cnt15=0;
for ( ; ; )
{
@@ -1155,7 +1157,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt15 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:186:0: rule
+					// Grammars\\DefineGrammarItemsWalker.g3:188:0: rule
{
PushFollow(Follow._rule_in_rules471);
rule();
@@ -1201,7 +1203,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "rule"
-	// Grammars\\DefineGrammarItemsWalker.g3:189:0: rule : ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:191:0: rule : ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) ;
private DefineGrammarItemsWalker.rule_return rule(  )
{
DefineGrammarItemsWalker.rule_return retval = new DefineGrammarItemsWalker.rule_return();
@@ -1222,8 +1224,8 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:196:5: ( ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:196:5: ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR )
+			// Grammars\\DefineGrammarItemsWalker.g3:198:5: ( ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:198:5: ^( RULE id= ID ( modifier )? ^( ARG (args= ARG_ACTION )? ) ^( RET (ret= ARG_ACTION )? ) ( throwsSpec )? ( optionsSpec )? ( ruleScopeSpec[r] )? ( ruleAction[r] )* b= block ( exceptionGroup )? EOR )
{
RULE3=(GrammarAST)Match(input,RULE,Follow._RULE_in_rule491); if (state.failed) return retval;

@@ -1233,7 +1235,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
{
opts = RULE3.BlockOptions;
}
-			// Grammars\\DefineGrammarItemsWalker.g3:197:4: ( modifier )?
+			// Grammars\\DefineGrammarItemsWalker.g3:199:4: ( modifier )?
int alt16=2;
int LA16_0 = input.LA(1);

@@ -1244,7 +1246,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt16 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:197:5: modifier
+				// Grammars\\DefineGrammarItemsWalker.g3:199:5: modifier
{
PushFollow(Follow._modifier_in_rule503);
modifier4=modifier();
@@ -1262,7 +1264,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return retval;
-				// Grammars\\DefineGrammarItemsWalker.g3:198:11: (args= ARG_ACTION )?
+				// Grammars\\DefineGrammarItemsWalker.g3:200:11: (args= ARG_ACTION )?
int alt17=2;
int LA17_0 = input.LA(1);

@@ -1273,7 +1275,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt17 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:198:12: args= ARG_ACTION
+					// Grammars\\DefineGrammarItemsWalker.g3:200:12: args= ARG_ACTION
{
args=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule517); if (state.failed) return retval;

@@ -1290,7 +1292,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return retval;
-				// Grammars\\DefineGrammarItemsWalker.g3:199:11: (ret= ARG_ACTION )?
+				// Grammars\\DefineGrammarItemsWalker.g3:201:11: (ret= ARG_ACTION )?
int alt18=2;
int LA18_0 = input.LA(1);

@@ -1301,7 +1303,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt18 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:199:12: ret= ARG_ACTION
+					// Grammars\\DefineGrammarItemsWalker.g3:201:12: ret= ARG_ACTION
{
ret=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rule533); if (state.failed) return retval;

@@ -1313,7 +1315,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

Match(input, TokenConstants.Up, null); if (state.failed) return retval;
}
-			// Grammars\\DefineGrammarItemsWalker.g3:200:4: ( throwsSpec )?
+			// Grammars\\DefineGrammarItemsWalker.g3:202:4: ( throwsSpec )?
int alt19=2;
int LA19_0 = input.LA(1);

@@ -1324,7 +1326,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt19 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:200:5: throwsSpec
+				// Grammars\\DefineGrammarItemsWalker.g3:202:5: throwsSpec
{
PushFollow(Follow._throwsSpec_in_rule543);
throwsSpec5=throwsSpec();
@@ -1337,7 +1339,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

}

-			// Grammars\\DefineGrammarItemsWalker.g3:201:4: ( optionsSpec )?
+			// Grammars\\DefineGrammarItemsWalker.g3:203:4: ( optionsSpec )?
int alt20=2;
int LA20_0 = input.LA(1);

@@ -1348,7 +1350,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt20 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:201:5: optionsSpec
+				// Grammars\\DefineGrammarItemsWalker.g3:203:5: optionsSpec
{
PushFollow(Follow._optionsSpec_in_rule551);
optionsSpec();
@@ -1394,7 +1396,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

}
-			// Grammars\\DefineGrammarItemsWalker.g3:232:4: ( ruleScopeSpec[r] )?
+			// Grammars\\DefineGrammarItemsWalker.g3:234:4: ( ruleScopeSpec[r] )?
int alt21=2;
int LA21_0 = input.LA(1);

@@ -1405,7 +1407,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt21 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:232:5: ruleScopeSpec[r]
+				// Grammars\\DefineGrammarItemsWalker.g3:234:5: ruleScopeSpec[r]
{
PushFollow(Follow._ruleScopeSpec_in_rule564);
ruleScopeSpec(r);
@@ -1418,7 +1420,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

}

-			// Grammars\\DefineGrammarItemsWalker.g3:233:4: ( ruleAction[r] )*
+			// Grammars\\DefineGrammarItemsWalker.g3:235:4: ( ruleAction[r] )*
for ( ; ; )
{
int alt22=2;
@@ -1433,7 +1435,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt22 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:233:5: ruleAction[r]
+					// Grammars\\DefineGrammarItemsWalker.g3:235:5: ruleAction[r]
{
PushFollow(Follow._ruleAction_in_rule573);
ruleAction(r);
@@ -1462,7 +1464,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

state._fsp--;
if (state.failed) return retval;
-			// Grammars\\DefineGrammarItemsWalker.g3:236:4: ( exceptionGroup )?
+			// Grammars\\DefineGrammarItemsWalker.g3:238:4: ( exceptionGroup )?
int alt23=2;
int LA23_0 = input.LA(1);

@@ -1473,7 +1475,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt23 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:236:5: exceptionGroup
+				// Grammars\\DefineGrammarItemsWalker.g3:238:5: exceptionGroup
{
PushFollow(Follow._exceptionGroup_in_rule594);
exceptionGroup();
@@ -1515,7 +1517,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "ruleAction"
-	// Grammars\\DefineGrammarItemsWalker.g3:246:0: ruleAction[Rule r] : ^(amp= AMPERSAND id= ID a= ACTION ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:248:0: ruleAction[Rule r] : ^(amp= AMPERSAND id= ID a= ACTION ) ;
private void ruleAction( Rule r )
{
GrammarAST amp=null;
@@ -1524,8 +1526,8 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:247:4: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:247:4: ^(amp= AMPERSAND id= ID a= ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:249:4: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:249:4: ^(amp= AMPERSAND id= ID a= ACTION )
{
amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_ruleAction625); if (state.failed) return ;

@@ -1560,7 +1562,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "modifier"
-	// Grammars\\DefineGrammarItemsWalker.g3:250:0: modifier returns [string mod] : ( 'protected' | 'public' | 'private' | 'fragment' );
+	// Grammars\\DefineGrammarItemsWalker.g3:252:0: modifier returns [string mod] : ( 'protected' | 'public' | 'private' | 'fragment' );
private DefineGrammarItemsWalker.modifier_return modifier(  )
{
DefineGrammarItemsWalker.modifier_return retval = new DefineGrammarItemsWalker.modifier_return();
@@ -1571,7 +1573,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:255:4: ( 'protected' | 'public' | 'private' | 'fragment' )
+			// Grammars\\DefineGrammarItemsWalker.g3:257:4: ( 'protected' | 'public' | 'private' | 'fragment' )
// Grammars\\DefineGrammarItemsWalker.g3:
{
if ( input.LA(1)==FRAGMENT||(input.LA(1)>=PRIVATE && input.LA(1)<=PUBLIC) )
@@ -1604,7 +1606,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "throwsSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:261:0: throwsSpec returns [HashSet<string> exceptions] : ^( 'throws' ( ID )+ ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:263:0: throwsSpec returns [HashSet<string> exceptions] : ^( 'throws' ( ID )+ ) ;
private HashSet<string> throwsSpec(  )
{

@@ -1617,13 +1619,13 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:266:4: ( ^( 'throws' ( ID )+ ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:266:4: ^( 'throws' ( ID )+ )
+			// Grammars\\DefineGrammarItemsWalker.g3:268:4: ( ^( 'throws' ( ID )+ ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:268:4: ^( 'throws' ( ID )+ )
{
Match(input,THROWS,Follow._THROWS_in_throwsSpec693); if (state.failed) return exceptions;

Match(input, TokenConstants.Down, null); if (state.failed) return exceptions;
-			// Grammars\\DefineGrammarItemsWalker.g3:266:15: ( ID )+
+			// Grammars\\DefineGrammarItemsWalker.g3:268:15: ( ID )+
int cnt24=0;
for ( ; ; )
{
@@ -1639,7 +1641,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt24 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:266:16: ID
+					// Grammars\\DefineGrammarItemsWalker.g3:268:16: ID
{
ID6=(GrammarAST)Match(input,ID,Follow._ID_in_throwsSpec696); if (state.failed) return exceptions;
if ( state.backtracking == 0 )
@@ -1684,7 +1686,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "ruleScopeSpec"
-	// Grammars\\DefineGrammarItemsWalker.g3:269:0: ruleScopeSpec[Rule r] : ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:271:0: ruleScopeSpec[Rule r] : ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) ;
private void ruleScopeSpec( Rule r )
{
AttributeScopeActions_scope.PushScope(this);
@@ -1697,15 +1699,15 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:275:4: ( ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:275:4: ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* )
+			// Grammars\\DefineGrammarItemsWalker.g3:277:4: ( ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:277:4: ^( 'scope' ( ( attrScopeAction )* attrs= ACTION )? (uses= ID )* )
{
Match(input,SCOPE,Follow._SCOPE_in_ruleScopeSpec726); if (state.failed) return ;

if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return ;
-				// Grammars\\DefineGrammarItemsWalker.g3:276:4: ( ( attrScopeAction )* attrs= ACTION )?
+				// Grammars\\DefineGrammarItemsWalker.g3:278:4: ( ( attrScopeAction )* attrs= ACTION )?
int alt26=2;
int LA26_0 = input.LA(1);

@@ -1716,9 +1718,9 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt26 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:276:6: ( attrScopeAction )* attrs= ACTION
+					// Grammars\\DefineGrammarItemsWalker.g3:278:6: ( attrScopeAction )* attrs= ACTION
{
-					// Grammars\\DefineGrammarItemsWalker.g3:276:6: ( attrScopeAction )*
+					// Grammars\\DefineGrammarItemsWalker.g3:278:6: ( attrScopeAction )*
for ( ; ; )
{
int alt25=2;
@@ -1733,7 +1735,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt25 )
{
case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:276:0: attrScopeAction
+							// Grammars\\DefineGrammarItemsWalker.g3:278:0: attrScopeAction
{
PushFollow(Follow._attrScopeAction_in_ruleScopeSpec733);
attrScopeAction();
@@ -1770,7 +1772,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

}

-				// Grammars\\DefineGrammarItemsWalker.g3:285:4: (uses= ID )*
+				// Grammars\\DefineGrammarItemsWalker.g3:287:4: (uses= ID )*
for ( ; ; )
{
int alt27=2;
@@ -1785,7 +1787,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt27 )
{
case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:285:6: uses= ID
+						// Grammars\\DefineGrammarItemsWalker.g3:287:6: uses= ID
{
uses=(GrammarAST)Match(input,ID,Follow._ID_in_ruleScopeSpec759); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1842,7 +1844,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "block"
-	// Grammars\\DefineGrammarItemsWalker.g3:302:0: block : ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:304:0: block : ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) ;
private DefineGrammarItemsWalker.block_return block(  )
{
DefineGrammarItemsWalker.block_return retval = new DefineGrammarItemsWalker.block_return();
@@ -1856,13 +1858,13 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:310:4: ( ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:310:4: ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB )
+			// Grammars\\DefineGrammarItemsWalker.g3:312:4: ( ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:312:4: ^( BLOCK ( optionsSpec )? ( blockAction )* ( alternative rewrite )+ EOB )
{
Match(input,BLOCK,Follow._BLOCK_in_block793); if (state.failed) return retval;

Match(input, TokenConstants.Down, null); if (state.failed) return retval;
-			// Grammars\\DefineGrammarItemsWalker.g3:311:4: ( optionsSpec )?
+			// Grammars\\DefineGrammarItemsWalker.g3:313:4: ( optionsSpec )?
int alt28=2;
int LA28_0 = input.LA(1);

@@ -1873,7 +1875,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt28 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:311:5: optionsSpec
+				// Grammars\\DefineGrammarItemsWalker.g3:313:5: optionsSpec
{
PushFollow(Follow._optionsSpec_in_block799);
optionsSpec();
@@ -1886,7 +1888,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

}

-			// Grammars\\DefineGrammarItemsWalker.g3:312:4: ( blockAction )*
+			// Grammars\\DefineGrammarItemsWalker.g3:314:4: ( blockAction )*
for ( ; ; )
{
int alt29=2;
@@ -1901,7 +1903,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt29 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:312:5: blockAction
+					// Grammars\\DefineGrammarItemsWalker.g3:314:5: blockAction
{
PushFollow(Follow._blockAction_in_block807);
blockAction();
@@ -1921,7 +1923,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
;


-			// Grammars\\DefineGrammarItemsWalker.g3:313:4: ( alternative rewrite )+
+			// Grammars\\DefineGrammarItemsWalker.g3:315:4: ( alternative rewrite )+
int cnt30=0;
for ( ; ; )
{
@@ -1937,7 +1939,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt30 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:313:6: alternative rewrite
+					// Grammars\\DefineGrammarItemsWalker.g3:315:6: alternative rewrite
{
PushFollow(Follow._alternative_in_block816);
alternative();
@@ -1993,7 +1995,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "blockAction"
-	// Grammars\\DefineGrammarItemsWalker.g3:325:0: blockAction : ^(amp= AMPERSAND id= ID a= ACTION ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:327:0: blockAction : ^(amp= AMPERSAND id= ID a= ACTION ) ;
private void blockAction(  )
{
GrammarAST amp=null;
@@ -2002,8 +2004,8 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:326:4: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:326:4: ^(amp= AMPERSAND id= ID a= ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:328:4: ( ^(amp= AMPERSAND id= ID a= ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:328:4: ^(amp= AMPERSAND id= ID a= ACTION )
{
amp=(GrammarAST)Match(input,AMPERSAND,Follow._AMPERSAND_in_blockAction859); if (state.failed) return ;

@@ -2033,7 +2035,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "alternative"
-	// Grammars\\DefineGrammarItemsWalker.g3:329:0: alternative : ^( ALT ( element )+ EOA ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:331:0: alternative : ^( ALT ( element )+ EOA ) ;
private DefineGrammarItemsWalker.alternative_return alternative(  )
{
DefineGrammarItemsWalker.alternative_return retval = new DefineGrammarItemsWalker.alternative_return();
@@ -2062,13 +2064,13 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:352:4: ( ^( ALT ( element )+ EOA ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:352:4: ^( ALT ( element )+ EOA )
+			// Grammars\\DefineGrammarItemsWalker.g3:354:4: ( ^( ALT ( element )+ EOA ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:354:4: ^( ALT ( element )+ EOA )
{
Match(input,ALT,Follow._ALT_in_alternative888); if (state.failed) return retval;

Match(input, TokenConstants.Down, null); if (state.failed) return retval;
-			// Grammars\\DefineGrammarItemsWalker.g3:352:11: ( element )+
+			// Grammars\\DefineGrammarItemsWalker.g3:354:11: ( element )+
int cnt31=0;
for ( ; ; )
{
@@ -2084,7 +2086,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt31 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:352:12: element
+					// Grammars\\DefineGrammarItemsWalker.g3:354:12: element
{
PushFollow(Follow._element_in_alternative891);
element();
@@ -2130,12 +2132,12 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "exceptionGroup"
-	// Grammars\\DefineGrammarItemsWalker.g3:355:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
+	// Grammars\\DefineGrammarItemsWalker.g3:357:0: exceptionGroup : ( ( exceptionHandler )+ ( finallyClause )? | finallyClause );
private void exceptionGroup(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
+			// Grammars\\DefineGrammarItemsWalker.g3:358:4: ( ( exceptionHandler )+ ( finallyClause )? | finallyClause )
int alt34=2;
int LA34_0 = input.LA(1);

@@ -2157,9 +2159,9 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt34 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( exceptionHandler )+ ( finallyClause )?
+				// Grammars\\DefineGrammarItemsWalker.g3:358:4: ( exceptionHandler )+ ( finallyClause )?
{
-				// Grammars\\DefineGrammarItemsWalker.g3:356:4: ( exceptionHandler )+
+				// Grammars\\DefineGrammarItemsWalker.g3:358:4: ( exceptionHandler )+
int cnt32=0;
for ( ; ; )
{
@@ -2175,7 +2177,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt32 )
{
case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:356:6: exceptionHandler
+						// Grammars\\DefineGrammarItemsWalker.g3:358:6: exceptionHandler
{
PushFollow(Follow._exceptionHandler_in_exceptionGroup910);
exceptionHandler();
@@ -2200,7 +2202,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
;


-				// Grammars\\DefineGrammarItemsWalker.g3:356:26: ( finallyClause )?
+				// Grammars\\DefineGrammarItemsWalker.g3:358:26: ( finallyClause )?
int alt33=2;
int LA33_0 = input.LA(1);

@@ -2211,7 +2213,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt33 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:356:27: finallyClause
+					// Grammars\\DefineGrammarItemsWalker.g3:358:27: finallyClause
{
PushFollow(Follow._finallyClause_in_exceptionGroup916);
finallyClause();
@@ -2228,7 +2230,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:357:4: finallyClause
+				// Grammars\\DefineGrammarItemsWalker.g3:359:4: finallyClause
{
PushFollow(Follow._finallyClause_in_exceptionGroup923);
finallyClause();
@@ -2255,15 +2257,15 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "exceptionHandler"
-	// Grammars\\DefineGrammarItemsWalker.g3:360:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:362:0: exceptionHandler : ^( 'catch' ARG_ACTION ACTION ) ;
private void exceptionHandler(  )
{
GrammarAST ACTION7=null;

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:361:6: ( ^( 'catch' ARG_ACTION ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:361:6: ^( 'catch' ARG_ACTION ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:363:6: ( ^( 'catch' ARG_ACTION ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:363:6: ^( 'catch' ARG_ACTION ACTION )
{
Match(input,CATCH,Follow._CATCH_in_exceptionHandler937); if (state.failed) return ;

@@ -2294,15 +2296,15 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "finallyClause"
-	// Grammars\\DefineGrammarItemsWalker.g3:364:0: finallyClause : ^( 'finally' ACTION ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:366:0: finallyClause : ^( 'finally' ACTION ) ;
private void finallyClause(  )
{
GrammarAST ACTION8=null;

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:365:7: ( ^( 'finally' ACTION ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:365:7: ^( 'finally' ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:367:7: ( ^( 'finally' ACTION ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:367:7: ^( 'finally' ACTION )
{
Match(input,FINALLY,Follow._FINALLY_in_finallyClause959); if (state.failed) return ;

@@ -2335,7 +2337,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "element"
-	// Grammars\\DefineGrammarItemsWalker.g3:368:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
+	// Grammars\\DefineGrammarItemsWalker.g3:370:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );
private DefineGrammarItemsWalker.element_return element(  )
{
DefineGrammarItemsWalker.element_return retval = new DefineGrammarItemsWalker.element_return();
@@ -2352,13 +2354,13 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:369:6: ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
+			// Grammars\\DefineGrammarItemsWalker.g3:371:6: ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON )
int alt36=18;
alt36 = dfa36.Predict(input);
switch ( alt36 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:369:6: ^( ROOT element )
+				// Grammars\\DefineGrammarItemsWalker.g3:371:6: ^( ROOT element )
{
Match(input,ROOT,Follow._ROOT_in_element978); if (state.failed) return retval;

@@ -2374,7 +2376,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:370:6: ^( BANG element )
+				// Grammars\\DefineGrammarItemsWalker.g3:372:6: ^( BANG element )
{
Match(input,BANG,Follow._BANG_in_element989); if (state.failed) return retval;

@@ -2390,7 +2392,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:371:6: atom[null]
+				// Grammars\\DefineGrammarItemsWalker.g3:373:6: atom[null]
{
PushFollow(Follow._atom_in_element999);
atom(null);
@@ -2401,7 +2403,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:372:6: ^( NOT element )
+				// Grammars\\DefineGrammarItemsWalker.g3:374:6: ^( NOT element )
{
Match(input,NOT,Follow._NOT_in_element1008); if (state.failed) return retval;

@@ -2417,7 +2419,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 5:
-				// Grammars\\DefineGrammarItemsWalker.g3:373:6: ^( RANGE atom[null] atom[null] )
+				// Grammars\\DefineGrammarItemsWalker.g3:375:6: ^( RANGE atom[null] atom[null] )
{
Match(input,RANGE,Follow._RANGE_in_element1019); if (state.failed) return retval;

@@ -2438,7 +2440,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 6:
-				// Grammars\\DefineGrammarItemsWalker.g3:374:6: ^( CHAR_RANGE atom[null] atom[null] )
+				// Grammars\\DefineGrammarItemsWalker.g3:376:6: ^( CHAR_RANGE atom[null] atom[null] )
{
Match(input,CHAR_RANGE,Follow._CHAR_RANGE_in_element1034); if (state.failed) return retval;

@@ -2459,7 +2461,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 7:
-				// Grammars\\DefineGrammarItemsWalker.g3:375:4: ^( ASSIGN id= ID el= element )
+				// Grammars\\DefineGrammarItemsWalker.g3:377:4: ^( ASSIGN id= ID el= element )
{
Match(input,ASSIGN,Follow._ASSIGN_in_element1048); if (state.failed) return retval;

@@ -2498,7 +2500,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 8:
-				// Grammars\\DefineGrammarItemsWalker.g3:395:4: ^( PLUS_ASSIGN id2= ID a2= element )
+				// Grammars\\DefineGrammarItemsWalker.g3:397:4: ^( PLUS_ASSIGN id2= ID a2= element )
{
Match(input,PLUS_ASSIGN,Follow._PLUS_ASSIGN_in_element1069); if (state.failed) return retval;

@@ -2537,7 +2539,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 9:
-				// Grammars\\DefineGrammarItemsWalker.g3:416:6: ebnf
+				// Grammars\\DefineGrammarItemsWalker.g3:418:6: ebnf
{
PushFollow(Follow._ebnf_in_element1094);
ebnf();
@@ -2548,7 +2550,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 10:
-				// Grammars\\DefineGrammarItemsWalker.g3:417:6: tree_
+				// Grammars\\DefineGrammarItemsWalker.g3:419:6: tree_
{
PushFollow(Follow._tree__in_element1101);
tree_();
@@ -2559,7 +2561,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 11:
-				// Grammars\\DefineGrammarItemsWalker.g3:418:6: ^( SYNPRED block )
+				// Grammars\\DefineGrammarItemsWalker.g3:420:6: ^( SYNPRED block )
{
Match(input,SYNPRED,Follow._SYNPRED_in_element1110); if (state.failed) return retval;

@@ -2575,7 +2577,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 12:
-				// Grammars\\DefineGrammarItemsWalker.g3:419:6: act= ACTION
+				// Grammars\\DefineGrammarItemsWalker.g3:421:6: act= ACTION
{
act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_element1123); if (state.failed) return retval;
if ( state.backtracking == 0 )
@@ -2589,7 +2591,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 13:
-				// Grammars\\DefineGrammarItemsWalker.g3:424:6: act2= FORCED_ACTION
+				// Grammars\\DefineGrammarItemsWalker.g3:426:6: act2= FORCED_ACTION
{
act2=(GrammarAST)Match(input,FORCED_ACTION,Follow._FORCED_ACTION_in_element1136); if (state.failed) return retval;
if ( state.backtracking == 0 )
@@ -2603,7 +2605,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 14:
-				// Grammars\\DefineGrammarItemsWalker.g3:429:6: SEMPRED
+				// Grammars\\DefineGrammarItemsWalker.g3:431:6: SEMPRED
{
SEMPRED9=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_element1147); if (state.failed) return retval;
if ( state.backtracking == 0 )
@@ -2617,21 +2619,21 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 15:
-				// Grammars\\DefineGrammarItemsWalker.g3:434:6: SYN_SEMPRED
+				// Grammars\\DefineGrammarItemsWalker.g3:436:6: SYN_SEMPRED
{
Match(input,SYN_SEMPRED,Follow._SYN_SEMPRED_in_element1158); if (state.failed) return retval;

}
break;
case 16:
-				// Grammars\\DefineGrammarItemsWalker.g3:435:6: ^( BACKTRACK_SEMPRED ( . )* )
+				// Grammars\\DefineGrammarItemsWalker.g3:437:6: ^( BACKTRACK_SEMPRED ( . )* )
{
Match(input,BACKTRACK_SEMPRED,Follow._BACKTRACK_SEMPRED_in_element1166); if (state.failed) return retval;

if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return retval;
-					// Grammars\\DefineGrammarItemsWalker.g3:435:26: ( . )*
+					// Grammars\\DefineGrammarItemsWalker.g3:437:26: ( . )*
for ( ; ; )
{
int alt35=2;
@@ -2650,7 +2652,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt35 )
{
case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:435:0: .
+							// Grammars\\DefineGrammarItemsWalker.g3:437:0: .
{
MatchAny(input); if (state.failed) return retval;

@@ -2673,7 +2675,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 17:
-				// Grammars\\DefineGrammarItemsWalker.g3:436:6: GATED_SEMPRED
+				// Grammars\\DefineGrammarItemsWalker.g3:438:6: GATED_SEMPRED
{
GATED_SEMPRED10=(GrammarAST)Match(input,GATED_SEMPRED,Follow._GATED_SEMPRED_in_element1177); if (state.failed) return retval;
if ( state.backtracking == 0 )
@@ -2687,7 +2689,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 18:
-				// Grammars\\DefineGrammarItemsWalker.g3:441:6: EPSILON
+				// Grammars\\DefineGrammarItemsWalker.g3:443:6: EPSILON
{
Match(input,EPSILON,Follow._EPSILON_in_element1188); if (state.failed) return retval;

@@ -2710,18 +2712,18 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "ebnf"
-	// Grammars\\DefineGrammarItemsWalker.g3:444:0: ebnf : (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
+	// Grammars\\DefineGrammarItemsWalker.g3:446:0: ebnf : (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );
private void ebnf(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:445:4: (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:447:4: (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) )
int alt37=5;
alt37 = dfa37.Predict(input);
switch ( alt37 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:445:4: => dotLoop
+				// Grammars\\DefineGrammarItemsWalker.g3:447:4: => dotLoop
{

PushFollow(Follow._dotLoop_in_ebnf1206);
@@ -2733,7 +2735,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:446:4: block
+				// Grammars\\DefineGrammarItemsWalker.g3:448:4: block
{
PushFollow(Follow._block_in_ebnf1212);
block();
@@ -2744,7 +2746,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:447:4: ^( OPTIONAL block )
+				// Grammars\\DefineGrammarItemsWalker.g3:449:4: ^( OPTIONAL block )
{
Match(input,OPTIONAL,Follow._OPTIONAL_in_ebnf1219); if (state.failed) return ;

@@ -2760,7 +2762,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:448:4: ^( CLOSURE block )
+				// Grammars\\DefineGrammarItemsWalker.g3:450:4: ^( CLOSURE block )
{
Match(input,CLOSURE,Follow._CLOSURE_in_ebnf1230); if (state.failed) return ;

@@ -2776,7 +2778,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 5:
-				// Grammars\\DefineGrammarItemsWalker.g3:449:4: ^( POSITIVE_CLOSURE block )
+				// Grammars\\DefineGrammarItemsWalker.g3:451:4: ^( POSITIVE_CLOSURE block )
{
Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_ebnf1241); if (state.failed) return ;

@@ -2811,7 +2813,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "dotLoop"
-	// Grammars\\DefineGrammarItemsWalker.g3:454:0: dotLoop : ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:456:0: dotLoop : ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) ;
private DefineGrammarItemsWalker.dotLoop_return dotLoop(  )
{
DefineGrammarItemsWalker.dotLoop_return retval = new DefineGrammarItemsWalker.dotLoop_return();
@@ -2819,10 +2821,10 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:457:4: ( ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:457:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
{
-			// Grammars\\DefineGrammarItemsWalker.g3:455:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:457:4: ( ^( CLOSURE dotBlock ) | ^( POSITIVE_CLOSURE dotBlock ) )
int alt38=2;
int LA38_0 = input.LA(1);

@@ -2844,7 +2846,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt38 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:455:6: ^( CLOSURE dotBlock )
+				// Grammars\\DefineGrammarItemsWalker.g3:457:6: ^( CLOSURE dotBlock )
{
Match(input,CLOSURE,Follow._CLOSURE_in_dotLoop1262); if (state.failed) return retval;

@@ -2860,7 +2862,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:456:5: ^( POSITIVE_CLOSURE dotBlock )
+				// Grammars\\DefineGrammarItemsWalker.g3:458:5: ^( POSITIVE_CLOSURE dotBlock )
{
Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_dotLoop1274); if (state.failed) return retval;

@@ -2911,13 +2913,13 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "dotBlock"
-	// Grammars\\DefineGrammarItemsWalker.g3:472:0: dotBlock : ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:474:0: dotBlock : ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) ;
private void dotBlock(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:473:4: ( ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:473:4: ^( BLOCK ^( ALT WILDCARD EOA ) EOB )
+			// Grammars\\DefineGrammarItemsWalker.g3:475:4: ( ^( BLOCK ^( ALT WILDCARD EOA ) EOB ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:475:4: ^( BLOCK ^( ALT WILDCARD EOA ) EOB )
{
Match(input,BLOCK,Follow._BLOCK_in_dotBlock1299); if (state.failed) return ;

@@ -2950,18 +2952,18 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "tree_"
-	// Grammars\\DefineGrammarItemsWalker.g3:476:0: tree_ : ^( TREE_BEGIN ( element )+ ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:478:0: tree_ : ^( TREE_BEGIN ( element )+ ) ;
private void tree_(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:477:4: ( ^( TREE_BEGIN ( element )+ ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:477:4: ^( TREE_BEGIN ( element )+ )
+			// Grammars\\DefineGrammarItemsWalker.g3:479:4: ( ^( TREE_BEGIN ( element )+ ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:479:4: ^( TREE_BEGIN ( element )+ )
{
Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_tree_1325); if (state.failed) return ;

Match(input, TokenConstants.Down, null); if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:477:17: ( element )+
+			// Grammars\\DefineGrammarItemsWalker.g3:479:17: ( element )+
int cnt39=0;
for ( ; ; )
{
@@ -2977,7 +2979,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt39 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:477:0: element
+					// Grammars\\DefineGrammarItemsWalker.g3:479:0: element
{
PushFollow(Follow._element_in_tree_1327);
element();
@@ -3022,7 +3024,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "atom"
-	// Grammars\\DefineGrammarItemsWalker.g3:480:0: atom[GrammarAST scope_] : ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) );
+	// Grammars\\DefineGrammarItemsWalker.g3:482:0: atom[GrammarAST scope_] : ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) );
private void atom( GrammarAST scope_ )
{
GrammarAST rr=null;
@@ -3035,7 +3037,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:481:4: ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:483:4: ( ^(rr= RULE_REF (rarg= ARG_ACTION )? ) | ^(t= TOKEN_REF (targ= ARG_ACTION )? ) |c= CHAR_LITERAL |s= STRING_LITERAL | WILDCARD | ^( DOT ID atom[$ID] ) )
int alt42=6;
switch ( input.LA(1) )
{
@@ -3081,14 +3083,14 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt42 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:481:4: ^(rr= RULE_REF (rarg= ARG_ACTION )? )
+				// Grammars\\DefineGrammarItemsWalker.g3:483:4: ^(rr= RULE_REF (rarg= ARG_ACTION )? )
{
rr=(GrammarAST)Match(input,RULE_REF,Follow._RULE_REF_in_atom1345); if (state.failed) return ;

if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return ;
-					// Grammars\\DefineGrammarItemsWalker.g3:481:19: (rarg= ARG_ACTION )?
+					// Grammars\\DefineGrammarItemsWalker.g3:483:19: (rarg= ARG_ACTION )?
int alt40=2;
int LA40_0 = input.LA(1);

@@ -3099,7 +3101,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt40 )
{
case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:481:20: rarg= ARG_ACTION
+						// Grammars\\DefineGrammarItemsWalker.g3:483:20: rarg= ARG_ACTION
{
rarg=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1350); if (state.failed) return ;

@@ -3126,14 +3128,14 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:490:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
+				// Grammars\\DefineGrammarItemsWalker.g3:492:4: ^(t= TOKEN_REF (targ= ARG_ACTION )? )
{
t=(GrammarAST)Match(input,TOKEN_REF,Follow._TOKEN_REF_in_atom1367); if (state.failed) return ;

if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return ;
-					// Grammars\\DefineGrammarItemsWalker.g3:490:19: (targ= ARG_ACTION )?
+					// Grammars\\DefineGrammarItemsWalker.g3:492:19: (targ= ARG_ACTION )?
int alt41=2;
int LA41_0 = input.LA(1);

@@ -3144,7 +3146,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt41 )
{
case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:490:20: targ= ARG_ACTION
+						// Grammars\\DefineGrammarItemsWalker.g3:492:20: targ= ARG_ACTION
{
targ=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_atom1372); if (state.failed) return ;

@@ -3178,7 +3180,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:506:4: c= CHAR_LITERAL
+				// Grammars\\DefineGrammarItemsWalker.g3:508:4: c= CHAR_LITERAL
{
c=(GrammarAST)Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_atom1388); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -3196,7 +3198,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:515:4: s= STRING_LITERAL
+				// Grammars\\DefineGrammarItemsWalker.g3:517:4: s= STRING_LITERAL
{
s=(GrammarAST)Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_atom1399); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -3214,14 +3216,14 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 5:
-				// Grammars\\DefineGrammarItemsWalker.g3:524:4: WILDCARD
+				// Grammars\\DefineGrammarItemsWalker.g3:526:4: WILDCARD
{
Match(input,WILDCARD,Follow._WILDCARD_in_atom1409); if (state.failed) return ;

}
break;
case 6:
-				// Grammars\\DefineGrammarItemsWalker.g3:525:4: ^( DOT ID atom[$ID] )
+				// Grammars\\DefineGrammarItemsWalker.g3:527:4: ^( DOT ID atom[$ID] )
{
Match(input,DOT,Follow._DOT_in_atom1415); if (state.failed) return ;

@@ -3254,12 +3256,12 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "ast_suffix"
-	// Grammars\\DefineGrammarItemsWalker.g3:528:0: ast_suffix : ( ROOT | BANG );
+	// Grammars\\DefineGrammarItemsWalker.g3:530:0: ast_suffix : ( ROOT | BANG );
private void ast_suffix(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:529:4: ( ROOT | BANG )
+			// Grammars\\DefineGrammarItemsWalker.g3:531:4: ( ROOT | BANG )
// Grammars\\DefineGrammarItemsWalker.g3:
{
if ( input.LA(1)==BANG||input.LA(1)==ROOT )
@@ -3295,7 +3297,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "rewrite"
-	// Grammars\\DefineGrammarItemsWalker.g3:533:0: rewrite : ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* ;
+	// Grammars\\DefineGrammarItemsWalker.g3:535:0: rewrite : ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* ;
private DefineGrammarItemsWalker.rewrite_return rewrite(  )
{
DefineGrammarItemsWalker.rewrite_return retval = new DefineGrammarItemsWalker.rewrite_return();
@@ -3313,10 +3315,10 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* )
-			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
+			// Grammars\\DefineGrammarItemsWalker.g3:545:4: ( ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )* )
+			// Grammars\\DefineGrammarItemsWalker.g3:545:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
{
-			// Grammars\\DefineGrammarItemsWalker.g3:543:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
+			// Grammars\\DefineGrammarItemsWalker.g3:545:4: ( ^( REWRITE (pred= SEMPRED )? rewrite_alternative ) )*
for ( ; ; )
{
int alt44=2;
@@ -3331,12 +3333,12 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt44 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:544:4: ^( REWRITE (pred= SEMPRED )? rewrite_alternative )
+					// Grammars\\DefineGrammarItemsWalker.g3:546:4: ^( REWRITE (pred= SEMPRED )? rewrite_alternative )
{
Match(input,REWRITE,Follow._REWRITE_in_rewrite1461); if (state.failed) return retval;

Match(input, TokenConstants.Down, null); if (state.failed) return retval;
-					// Grammars\\DefineGrammarItemsWalker.g3:544:15: (pred= SEMPRED )?
+					// Grammars\\DefineGrammarItemsWalker.g3:546:15: (pred= SEMPRED )?
int alt43=2;
int LA43_0 = input.LA(1);

@@ -3347,7 +3349,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt43 )
{
case 1:
-						// Grammars\\DefineGrammarItemsWalker.g3:544:16: pred= SEMPRED
+						// Grammars\\DefineGrammarItemsWalker.g3:546:16: pred= SEMPRED
{
pred=(GrammarAST)Match(input,SEMPRED,Follow._SEMPRED_in_rewrite1466); if (state.failed) return retval;

@@ -3407,7 +3409,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "rewrite_block"
-	// Grammars\\DefineGrammarItemsWalker.g3:556:0: rewrite_block : ^( BLOCK rewrite_alternative EOB ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:558:0: rewrite_block : ^( BLOCK rewrite_alternative EOB ) ;
private DefineGrammarItemsWalker.rewrite_block_return rewrite_block(  )
{
DefineGrammarItemsWalker.rewrite_block_return retval = new DefineGrammarItemsWalker.rewrite_block_return();
@@ -3425,8 +3427,8 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:568:6: ( ^( BLOCK rewrite_alternative EOB ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:568:6: ^( BLOCK rewrite_alternative EOB )
+			// Grammars\\DefineGrammarItemsWalker.g3:570:6: ( ^( BLOCK rewrite_alternative EOB ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:570:6: ^( BLOCK rewrite_alternative EOB )
{
Match(input,BLOCK,Follow._BLOCK_in_rewrite_block1505); if (state.failed) return retval;

@@ -3470,14 +3472,14 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "rewrite_alternative"
-	// Grammars\\DefineGrammarItemsWalker.g3:582:0: rewrite_alternative : ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?);
+	// Grammars\\DefineGrammarItemsWalker.g3:584:0: rewrite_alternative : ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?);
private void rewrite_alternative(  )
{
GrammarAST a=null;

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:583:4: ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?)
+			// Grammars\\DefineGrammarItemsWalker.g3:585:4: ({...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA ) |{...}? => rewrite_template | ETC {...}?)
int alt47=3;
int LA47_0 = input.LA(1);

@@ -3571,7 +3573,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt47 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:583:4: {...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA )
+				// Grammars\\DefineGrammarItemsWalker.g3:585:4: {...}? => ^(a= ALT ( ( rewrite_element )+ | EPSILON ) EOA )
{
if ( !((grammar.BuildAST)) )
{
@@ -3581,7 +3583,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
a=(GrammarAST)Match(input,ALT,Follow._ALT_in_rewrite_alternative1541); if (state.failed) return ;

Match(input, TokenConstants.Down, null); if (state.failed) return ;
-				// Grammars\\DefineGrammarItemsWalker.g3:583:36: ( ( rewrite_element )+ | EPSILON )
+				// Grammars\\DefineGrammarItemsWalker.g3:585:36: ( ( rewrite_element )+ | EPSILON )
int alt46=2;
int LA46_0 = input.LA(1);

@@ -3603,9 +3605,9 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt46 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:583:38: ( rewrite_element )+
+					// Grammars\\DefineGrammarItemsWalker.g3:585:38: ( rewrite_element )+
{
-					// Grammars\\DefineGrammarItemsWalker.g3:583:38: ( rewrite_element )+
+					// Grammars\\DefineGrammarItemsWalker.g3:585:38: ( rewrite_element )+
int cnt45=0;
for ( ; ; )
{
@@ -3621,7 +3623,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt45 )
{
case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:583:40: rewrite_element
+							// Grammars\\DefineGrammarItemsWalker.g3:585:40: rewrite_element
{
PushFollow(Follow._rewrite_element_in_rewrite_alternative1547);
rewrite_element();
@@ -3650,7 +3652,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-					// Grammars\\DefineGrammarItemsWalker.g3:583:61: EPSILON
+					// Grammars\\DefineGrammarItemsWalker.g3:585:61: EPSILON
{
Match(input,EPSILON,Follow._EPSILON_in_rewrite_alternative1554); if (state.failed) return ;

@@ -3666,7 +3668,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:584:4: {...}? => rewrite_template
+				// Grammars\\DefineGrammarItemsWalker.g3:586:4: {...}? => rewrite_template
{
if ( !((grammar.BuildTemplate)) )
{
@@ -3682,7 +3684,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:585:4: ETC {...}?
+				// Grammars\\DefineGrammarItemsWalker.g3:587:4: ETC {...}?
{
Match(input,ETC,Follow._ETC_in_rewrite_alternative1574); if (state.failed) return ;
if ( !((this.blockLevel==1)) )
@@ -3710,12 +3712,12 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "rewrite_element"
-	// Grammars\\DefineGrammarItemsWalker.g3:588:0: rewrite_element : ( rewrite_atom | rewrite_ebnf | rewrite_tree );
+	// Grammars\\DefineGrammarItemsWalker.g3:590:0: rewrite_element : ( rewrite_atom | rewrite_ebnf | rewrite_tree );
private void rewrite_element(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:589:4: ( rewrite_atom | rewrite_ebnf | rewrite_tree )
+			// Grammars\\DefineGrammarItemsWalker.g3:591:4: ( rewrite_atom | rewrite_ebnf | rewrite_tree )
int alt48=3;
switch ( input.LA(1) )
{
@@ -3753,7 +3755,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt48 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:589:4: rewrite_atom
+				// Grammars\\DefineGrammarItemsWalker.g3:591:4: rewrite_atom
{
PushFollow(Follow._rewrite_atom_in_rewrite_element1588);
rewrite_atom();
@@ -3764,7 +3766,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:590:4: rewrite_ebnf
+				// Grammars\\DefineGrammarItemsWalker.g3:592:4: rewrite_ebnf
{
PushFollow(Follow._rewrite_ebnf_in_rewrite_element1593);
rewrite_ebnf();
@@ -3775,7 +3777,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:591:4: rewrite_tree
+				// Grammars\\DefineGrammarItemsWalker.g3:593:4: rewrite_tree
{
PushFollow(Follow._rewrite_tree_in_rewrite_element1598);
rewrite_tree();
@@ -3802,12 +3804,12 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "rewrite_ebnf"
-	// Grammars\\DefineGrammarItemsWalker.g3:594:0: rewrite_ebnf : ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) );
+	// Grammars\\DefineGrammarItemsWalker.g3:596:0: rewrite_ebnf : ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) );
private void rewrite_ebnf(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:595:4: ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:597:4: ( ^( OPTIONAL rewrite_block ) | ^( CLOSURE rewrite_block ) | ^( POSITIVE_CLOSURE rewrite_block ) )
int alt49=3;
switch ( input.LA(1) )
{
@@ -3838,7 +3840,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt49 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:595:4: ^( OPTIONAL rewrite_block )
+				// Grammars\\DefineGrammarItemsWalker.g3:597:4: ^( OPTIONAL rewrite_block )
{
Match(input,OPTIONAL,Follow._OPTIONAL_in_rewrite_ebnf1611); if (state.failed) return ;

@@ -3854,7 +3856,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:596:4: ^( CLOSURE rewrite_block )
+				// Grammars\\DefineGrammarItemsWalker.g3:598:4: ^( CLOSURE rewrite_block )
{
Match(input,CLOSURE,Follow._CLOSURE_in_rewrite_ebnf1622); if (state.failed) return ;

@@ -3870,7 +3872,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:597:4: ^( POSITIVE_CLOSURE rewrite_block )
+				// Grammars\\DefineGrammarItemsWalker.g3:599:4: ^( POSITIVE_CLOSURE rewrite_block )
{
Match(input,POSITIVE_CLOSURE,Follow._POSITIVE_CLOSURE_in_rewrite_ebnf1633); if (state.failed) return ;

@@ -3902,13 +3904,13 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "rewrite_tree"
-	// Grammars\\DefineGrammarItemsWalker.g3:600:0: rewrite_tree : ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) ;
+	// Grammars\\DefineGrammarItemsWalker.g3:602:0: rewrite_tree : ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) ;
private void rewrite_tree(  )
{
try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:601:6: ( ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) )
-			// Grammars\\DefineGrammarItemsWalker.g3:601:6: ^( TREE_BEGIN rewrite_atom ( rewrite_element )* )
+			// Grammars\\DefineGrammarItemsWalker.g3:603:6: ( ^( TREE_BEGIN rewrite_atom ( rewrite_element )* ) )
+			// Grammars\\DefineGrammarItemsWalker.g3:603:6: ^( TREE_BEGIN rewrite_atom ( rewrite_element )* )
{
Match(input,TREE_BEGIN,Follow._TREE_BEGIN_in_rewrite_tree1652); if (state.failed) return ;

@@ -3918,7 +3920,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

state._fsp--;
if (state.failed) return ;
-			// Grammars\\DefineGrammarItemsWalker.g3:601:33: ( rewrite_element )*
+			// Grammars\\DefineGrammarItemsWalker.g3:603:33: ( rewrite_element )*
for ( ; ; )
{
int alt50=2;
@@ -3933,7 +3935,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt50 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:601:35: rewrite_element
+					// Grammars\\DefineGrammarItemsWalker.g3:603:35: rewrite_element
{
PushFollow(Follow._rewrite_element_in_rewrite_tree1658);
rewrite_element();
@@ -3976,7 +3978,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

// $ANTLR start "rewrite_atom"
-	// Grammars\\DefineGrammarItemsWalker.g3:604:0: rewrite_atom : ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION );
+	// Grammars\\DefineGrammarItemsWalker.g3:606:0: rewrite_atom : ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION );
private DefineGrammarItemsWalker.rewrite_atom_return rewrite_atom(  )
{
DefineGrammarItemsWalker.rewrite_atom_return retval = new DefineGrammarItemsWalker.rewrite_atom_return();
@@ -4012,7 +4014,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:631:4: ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:633:4: ( RULE_REF | ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL ) | LABEL | ACTION )
int alt53=4;
switch ( input.LA(1) )
{
@@ -4050,16 +4052,16 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt53 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:631:4: RULE_REF
+				// Grammars\\DefineGrammarItemsWalker.g3:633:4: RULE_REF
{
Match(input,RULE_REF,Follow._RULE_REF_in_rewrite_atom1679); if (state.failed) return retval;

}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:632:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
+				// Grammars\\DefineGrammarItemsWalker.g3:634:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
{
-				// Grammars\\DefineGrammarItemsWalker.g3:632:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
+				// Grammars\\DefineGrammarItemsWalker.g3:634:4: ( ^( TOKEN_REF ( ARG_ACTION )? ) | CHAR_LITERAL | STRING_LITERAL )
int alt52=3;
switch ( input.LA(1) )
{
@@ -4090,14 +4092,14 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt52 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:632:6: ^( TOKEN_REF ( ARG_ACTION )? )
+					// Grammars\\DefineGrammarItemsWalker.g3:634:6: ^( TOKEN_REF ( ARG_ACTION )? )
{
Match(input,TOKEN_REF,Follow._TOKEN_REF_in_rewrite_atom1689); if (state.failed) return retval;

if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return retval;
-						// Grammars\\DefineGrammarItemsWalker.g3:633:5: ( ARG_ACTION )?
+						// Grammars\\DefineGrammarItemsWalker.g3:635:5: ( ARG_ACTION )?
int alt51=2;
int LA51_0 = input.LA(1);

@@ -4108,7 +4110,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt51 )
{
case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:633:7: ARG_ACTION
+							// Grammars\\DefineGrammarItemsWalker.g3:635:7: ARG_ACTION
{
ARG_ACTION12=(GrammarAST)Match(input,ARG_ACTION,Follow._ARG_ACTION_in_rewrite_atom1697); if (state.failed) return retval;
if ( state.backtracking == 0 )
@@ -4131,14 +4133,14 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-					// Grammars\\DefineGrammarItemsWalker.g3:640:5: CHAR_LITERAL
+					// Grammars\\DefineGrammarItemsWalker.g3:642:5: CHAR_LITERAL
{
Match(input,CHAR_LITERAL,Follow._CHAR_LITERAL_in_rewrite_atom1722); if (state.failed) return retval;

}
break;
case 3:
-					// Grammars\\DefineGrammarItemsWalker.g3:641:5: STRING_LITERAL
+					// Grammars\\DefineGrammarItemsWalker.g3:643:5: STRING_LITERAL
{
Match(input,STRING_LITERAL,Follow._STRING_LITERAL_in_rewrite_atom1728); if (state.failed) return retval;

@@ -4151,14 +4153,14 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:643:4: LABEL
+				// Grammars\\DefineGrammarItemsWalker.g3:645:4: LABEL
{
Match(input,LABEL,Follow._LABEL_in_rewrite_atom1737); if (state.failed) return retval;

}
break;
case 4:
-				// Grammars\\DefineGrammarItemsWalker.g3:644:4: ACTION
+				// Grammars\\DefineGrammarItemsWalker.g3:646:4: ACTION
{
ACTION13=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_atom1742); if (state.failed) return retval;
if ( state.backtracking == 0 )
@@ -4188,7 +4190,7 @@ public partial class DefineGrammarItemsWalker : TreeParser


// $ANTLR start "rewrite_template"
-	// Grammars\\DefineGrammarItemsWalker.g3:651:0: rewrite_template : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
+	// Grammars\\DefineGrammarItemsWalker.g3:653:0: rewrite_template : ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION );
private void rewrite_template(  )
{
GrammarAST id=null;
@@ -4199,7 +4201,7 @@ public partial class DefineGrammarItemsWalker : TreeParser

try
{
-			// Grammars\\DefineGrammarItemsWalker.g3:652:4: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
+			// Grammars\\DefineGrammarItemsWalker.g3:654:4: ( ^( ALT EPSILON EOA ) | ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? ) |act= ACTION )
int alt57=3;
switch ( input.LA(1) )
{
@@ -4230,7 +4232,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt57 )
{
case 1:
-				// Grammars\\DefineGrammarItemsWalker.g3:652:4: ^( ALT EPSILON EOA )
+				// Grammars\\DefineGrammarItemsWalker.g3:654:4: ^( ALT EPSILON EOA )
{
Match(input,ALT,Follow._ALT_in_rewrite_template1759); if (state.failed) return ;

@@ -4243,12 +4245,12 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 2:
-				// Grammars\\DefineGrammarItemsWalker.g3:653:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
+				// Grammars\\DefineGrammarItemsWalker.g3:655:4: ^( TEMPLATE (id= ID |ind= ACTION ) ^( ARGLIST ( ^( ARG arg= ID a= ACTION ) )* ) ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )? )
{
Match(input,TEMPLATE,Follow._TEMPLATE_in_rewrite_template1772); if (state.failed) return ;

Match(input, TokenConstants.Down, null); if (state.failed) return ;
-				// Grammars\\DefineGrammarItemsWalker.g3:653:16: (id= ID |ind= ACTION )
+				// Grammars\\DefineGrammarItemsWalker.g3:655:16: (id= ID |ind= ACTION )
int alt54=2;
int LA54_0 = input.LA(1);

@@ -4270,14 +4272,14 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt54 )
{
case 1:
-					// Grammars\\DefineGrammarItemsWalker.g3:653:17: id= ID
+					// Grammars\\DefineGrammarItemsWalker.g3:655:17: id= ID
{
id=(GrammarAST)Match(input,ID,Follow._ID_in_rewrite_template1777); if (state.failed) return ;

}
break;
case 2:
-					// Grammars\\DefineGrammarItemsWalker.g3:653:23: ind= ACTION
+					// Grammars\\DefineGrammarItemsWalker.g3:655:23: ind= ACTION
{
ind=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1781); if (state.failed) return ;

@@ -4291,7 +4293,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
if ( input.LA(1)==TokenConstants.Down )
{
Match(input, TokenConstants.Down, null); if (state.failed) return ;
-					// Grammars\\DefineGrammarItemsWalker.g3:655:5: ( ^( ARG arg= ID a= ACTION ) )*
+					// Grammars\\DefineGrammarItemsWalker.g3:657:5: ( ^( ARG arg= ID a= ACTION ) )*
for ( ; ; )
{
int alt55=2;
@@ -4306,7 +4308,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
switch ( alt55 )
{
case 1:
-							// Grammars\\DefineGrammarItemsWalker.g3:655:7: ^( ARG arg= ID a= ACTION )
+							// Grammars\\DefineGrammarItemsWalker.g3:657:7: ^( ARG arg= ID a= ACTION )
{
Match(input,ARG,Follow._ARG_in_rewrite_template1799); if (state.failed) return ;

@@ -4348,7 +4350,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}

}
-				// Grammars\\DefineGrammarItemsWalker.g3:669:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
+				// Grammars\\DefineGrammarItemsWalker.g3:671:4: ( DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL )?
int alt56=2;
int LA56_0 = input.LA(1);

@@ -4385,7 +4387,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
break;
case 3:
-				// Grammars\\DefineGrammarItemsWalker.g3:673:4: act= ACTION
+				// Grammars\\DefineGrammarItemsWalker.g3:675:4: act= ACTION
{
act=(GrammarAST)Match(input,ACTION,Follow._ACTION_in_rewrite_template1864); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -4416,8 +4418,8 @@ public partial class DefineGrammarItemsWalker : TreeParser
// $ANTLR start synpred1_DefineGrammarItemsWalker
public void synpred1_DefineGrammarItemsWalker_fragment()
{
-		// Grammars\\DefineGrammarItemsWalker.g3:445:4: ( dotLoop )
-		// Grammars\\DefineGrammarItemsWalker.g3:445:5: dotLoop
+		// Grammars\\DefineGrammarItemsWalker.g3:447:4: ( dotLoop )
+		// Grammars\\DefineGrammarItemsWalker.g3:447:5: dotLoop
{
PushFollow(Follow._dotLoop_in_synpred1_DefineGrammarItemsWalker1201);
dotLoop();
@@ -4538,7 +4540,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
public override string GetDescription()
{
-			return "368:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );";
+			return "370:0: element : ( ^( ROOT element ) | ^( BANG element ) | atom[null] | ^( NOT element ) | ^( RANGE atom[null] atom[null] ) | ^( CHAR_RANGE atom[null] atom[null] ) | ^( ASSIGN id= ID el= element ) | ^( PLUS_ASSIGN id2= ID a2= element ) | ebnf | tree_ | ^( SYNPRED block ) |act= ACTION |act2= FORCED_ACTION | SEMPRED | SYN_SEMPRED | ^( BACKTRACK_SEMPRED ( . )* ) | GATED_SEMPRED | EPSILON );";
}
}

@@ -4639,7 +4641,7 @@ public partial class DefineGrammarItemsWalker : TreeParser
}
public override string GetDescription()
{
-			return "444:0: ebnf : (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );";
+			return "446:0: ebnf : (=> dotLoop | block | ^( OPTIONAL block ) | ^( CLOSURE block ) | ^( POSITIVE_CLOSURE block ) );";
}
}

diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.g3 b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
index 1c09e89..1baefdc 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.g3
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
@@ -82,7 +82,9 @@ using System;
using Antlr3.Tool;
using boolean = System.Boolean;
using Character = java.lang.Character;
+#if DEBUG
using Utils = Antlr3.Misc.Utils;
+#endif
}

@namespace{Antlr3.Grammars}
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
index 4560706..165f161 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
+++ b/Antlr3/Grammars/DefineGrammarItemsWalkerHelper.cs
@@ -90,7 +90,7 @@ namespace Antlr3.Grammars
continue;

string ruleName = p.GetChild( i ).GetChild( 0 ).Text;
-                //System.out.println("rule "+ruleName+" prev="+prev.getText());
+                //Console.Out.WriteLine( "rule " + ruleName + " prev=" + prev.getText() );
if ( char.IsUpper( ruleName[0] ) )
{
// remove lexer rule
@@ -98,7 +98,7 @@ namespace Antlr3.Grammars
i--;
}
}
-            //System.out.println("root after removal is: "+root.toStringList());
+            //Console.Out.WriteLine( "root after removal is: " + root.ToStringList() );
}

protected void trackInlineAction( GrammarAST actionAST )
diff --git a/Antlr3/Grammars/TreeToNFAConverter.cs b/Antlr3/Grammars/TreeToNFAConverter.cs
index 816240c..f39d888 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.cs
+++ b/Antlr3/Grammars/TreeToNFAConverter.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-03-23 17:54:04
+// $ANTLR 3.1.2 Grammars\\TreeToNFAConverter.g3 2009-04-10 17:43:58

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -860,7 +860,7 @@ public partial class TreeToNFAConverter : TreeParser
{

currentRuleName = (id!=null?id.Text:null);
-								factory.setCurrentRule( grammar.getLocallyDefinedRule(currentRuleName) );
+								factory.CurrentRule = grammar.getLocallyDefinedRule( currentRuleName );

}
// Grammars\\TreeToNFAConverter.g3:125:4: ( modifier )?
@@ -2481,7 +2481,7 @@ public partial class TreeToNFAConverter : TreeParser
if ( blk.Type!=BLOCK ) {
blk = (GrammarAST)blk.GetChild(0);
}
-			GrammarAST eob = blk.getLastChild();
+			GrammarAST eob = blk.LastChild;

try
{
@@ -3049,7 +3049,7 @@ public partial class TreeToNFAConverter : TreeParser
//IIntSet notSet = grammar.complement(stNode.SetValue);
// let code generator complement the sets
IIntSet s = stNode.SetValue;
-											stNode.setSetValue(s);
+											stNode.SetValue = s;
// let code gen do the complement again; here we compute
// for NFA construction
s = grammar.complement(s);
@@ -3566,7 +3566,7 @@ public partial class TreeToNFAConverter : TreeParser

IIntSet elements=new IntervalSet();
if ( state.backtracking == 0 )
-				((GrammarAST)retval.start).setSetValue(elements); // track set for use by code gen
+				((GrammarAST)retval.start).SetValue = elements; // track set for use by code gen

try
{
@@ -3693,7 +3693,7 @@ public partial class TreeToNFAConverter : TreeParser

retval.g = factory.build_Set(elements,b);
b.followingNFAState = retval.g.right;
-						b.setSetValue(elements); // track set value of this block
+						b.SetValue = elements; // track set value of this block

}

@@ -4922,6 +4922,7 @@ public partial class TreeToNFAConverter : TreeParser
// $ANTLR end "testSetElement"
#endregion Rules

+
#region DFA
DFA41 dfa41;

diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
index f31c278..f38f461 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.g3
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -120,7 +120,7 @@ rule
:	^(	RULE id=ID
{
currentRuleName = $id.text;
-				factory.setCurrentRule( grammar.getLocallyDefinedRule(currentRuleName) );
+				factory.CurrentRule = grammar.getLocallyDefinedRule( currentRuleName );
}
(modifier)?
^(ARG (ARG_ACTION)?)
@@ -282,7 +282,7 @@ ebnf returns [StateCluster g=null]
if ( blk.Type!=BLOCK ) {
blk = (GrammarAST)blk.GetChild(0);
}
-	GrammarAST eob = blk.getLastChild();
+	GrammarAST eob = blk.LastChild;
}
:	{grammar.isValidSet(this,$start)}? => set {$g = $set.g;}

@@ -449,7 +449,7 @@ atom_or_notatom returns [StateCluster g=null]
//IIntSet notSet = grammar.complement(stNode.SetValue);
// let code generator complement the sets
IIntSet s = stNode.SetValue;
-					stNode.setSetValue(s);
+					stNode.SetValue = s;
// let code gen do the complement again; here we compute
// for NFA construction
s = grammar.complement(s);
@@ -559,7 +559,7 @@ set returns [StateCluster g=null]
{
IIntSet elements=new IntervalSet();
if ( state.backtracking == 0 )
-		$start.setSetValue(elements); // track set for use by code gen
+		$start.SetValue = elements; // track set for use by code gen
}
:	^( b=BLOCK
(^(ALT ( ^(BACKTRACK_SEMPRED .*) )? setElement[elements] EOA))+
@@ -568,7 +568,7 @@ set returns [StateCluster g=null]
{
$g = factory.build_Set(elements,$b);
$b.followingNFAState = $g.right;
-		$b.setSetValue(elements); // track set value of this block
+		$b.SetValue = elements; // track set value of this block
}
//{System.out.println("set elements="+elements.toString(grammar));}
;
diff --git a/Antlr3/Grammars/TreeToNFAConverterHelper.cs b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
index 26ca7ab..2d013eb 100644
--- a/Antlr3/Grammars/TreeToNFAConverterHelper.cs
+++ b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
@@ -117,7 +117,7 @@ namespace Antlr3.Grammars

protected virtual void addFollowTransition( string ruleName, NFAState following )
{
-            //System.out.println("adding follow link to rule "+ruleName);
+            //System.Console.Out.WriteLine( "adding follow link to rule " + ruleName );
// find last link in FOLLOW chain emanating from rule
Rule r = grammar.getRule( ruleName );
NFAState end = r.stopState;
diff --git a/Antlr3/Misc/BitSet.cs b/Antlr3/Misc/BitSet.cs
index 8b869af..4064814 100644
--- a/Antlr3/Misc/BitSet.cs
+++ b/Antlr3/Misc/BitSet.cs
@@ -718,7 +718,7 @@ namespace Antlr3.Misc
return ToString();
}

-        private /*final*/ static int wordNumber( int bit )
+        private static int wordNumber( int bit )
{
return bit >> LogBits; // bit / BITS
}
diff --git a/Antlr3/Misc/IntervalSet.cs b/Antlr3/Misc/IntervalSet.cs
index 12815f9..c4b5ab5 100644
--- a/Antlr3/Misc/IntervalSet.cs
+++ b/Antlr3/Misc/IntervalSet.cs
@@ -39,6 +39,7 @@ namespace Antlr3.Misc
using Grammar = Antlr3.Tool.Grammar;
using Label = Antlr3.Analysis.Label;
using NotImplementedException = System.NotImplementedException;
+    using Obsolete = System.ObsoleteAttribute;
using StringBuilder = System.Text.StringBuilder;

/** A set of integers that relies on ranges being common to do
@@ -208,50 +209,58 @@ namespace Antlr3.Misc
intervals.Add( addition );
}

-        /*
-        protected void add(Interval addition) {
+#if false
+        protected virtual void add( Interval addition )
+        {
//JSystem.@out.println("add "+addition+" to "+intervals.toString());
-            if ( addition.b<addition.a ) {
+            if ( addition.b < addition.a )
+            {
return;
}
// find position in list
//for (ListIterator iter = intervals.listIterator(); iter.hasNext();) {
-            int n = intervals.size();
-            for (int i=0; i<n; i++) {
-                Interval r = (Interval)intervals.get(i);
-                if ( addition.equals(r) ) {
+            int n = intervals.Count;
+            for ( int i = 0; i < n; i++ )
+            {
+                Interval r = (Interval)intervals[i];
+                if ( addition.Equals( r ) )
+                {
return;
}
-                if ( addition.adjacent(r) || !addition.disjoint(r) ) {
+                if ( addition.adjacent( r ) || !addition.disjoint( r ) )
+                {
// next to each other, make a single larger interval
-                    Interval bigger = addition.union(r);
-                    intervals.set(i, bigger);
+                    Interval bigger = addition.union( r );
+                    intervals[i] = bigger;
// make sure we didn't just create an interval that
// should be merged with next interval in list
-                    if ( (i+1)<n ) {
+                    if ( ( i + 1 ) < n )
+                    {
i++;
-                        Interval next = (Interval)intervals.get(i);
-                        if ( bigger.adjacent(next)||!bigger.disjoint(next) ) {
+                        Interval next = (Interval)intervals[i];
+                        if ( bigger.adjacent( next ) || !bigger.disjoint( next ) )
+                        {
// if we bump up against or overlap next, merge
-                            intervals.remove(i); // remove next one
+                            intervals.RemoveAt( i ); // remove next one
i--;
-                            intervals.set(i, bigger.union(next)); // set to 3 merged ones
+                            intervals[i] = bigger.union( next ); // set to 3 merged ones
}
}
return;
}
-                if ( addition.startsBeforeDisjoint(r) ) {
+                if ( addition.startsBeforeDisjoint( r ) )
+                {
// insert before r
-                    intervals.add(i, addition);
+                    intervals.Insert( i, addition );
return;
}
// if disjoint and after r, a future iteration will handle it
}
// ok, must be after last interval (and disjoint from last interval)
// just add it
-            intervals.add(addition);
+            intervals.Add( addition );
}
-    */
+#endif

public virtual void addAll( IIntSet set )
{
@@ -349,6 +358,7 @@ namespace Antlr3.Misc
return this.and( ( (IntervalSet)other ).complement( COMPLETE_SET ) );
}

+#if false
/** return a new set containing all elements in this but not in other.
*  Intervals may have to be broken up when ranges in this overlap
*  with ranges in other.  other is assumed to be a subset of this;
@@ -356,93 +366,112 @@ namespace Antlr3.Misc
*
*  Keep around, but 10-20-2005, I decided to make complement work w/o
*  subtract and so then subtract can simply be a&~b
-         *
-        public IntSet subtract(IntSet other) {
-            if ( other==null || !(other instanceof IntervalSet) ) {
+         */
+        public IIntSet subtract( IIntSet other )
+        {
+            if ( other == null || !( other is IntervalSet ) )
+            {
return null; // nothing in common with null set
}

IntervalSet diff = new IntervalSet();

// iterate down both interval lists
-            ListIterator thisIter = this.intervals.listIterator();
-            ListIterator otherIter = ((IntervalSet)other).intervals.listIterator();
-            Interval mine=null;
-            Interval theirs=null;
-            if ( thisIter.hasNext() ) {
-                mine = (Interval)thisIter.next();
+            var thisIter = this.intervals.GetEnumerator();
+            var otherIter = ( (IntervalSet)other ).intervals.GetEnumerator();
+            Interval mine = null;
+            Interval theirs = null;
+            if ( thisIter.MoveNext() )
+            {
+                mine = (Interval)thisIter.Current;
}
-            if ( otherIter.hasNext() ) {
-                theirs = (Interval)otherIter.next();
+            if ( otherIter.MoveNext() )
+            {
+                theirs = (Interval)otherIter.Current;
}
-            while ( mine!=null ) {
+            while ( mine != null )
+            {
//JSystem.@out.println("mine="+mine+", theirs="+theirs);
// CASE 1: nothing in theirs removes a chunk from mine
-                if ( theirs==null || mine.disjoint(theirs) ) {
+                if ( theirs == null || mine.disjoint( theirs ) )
+                {
// SUBCASE 1a: finished traversing theirs; keep adding mine now
-                    if ( theirs==null ) {
+                    if ( theirs == null )
+                    {
// add everything in mine to difference since theirs done
-                        diff.add(mine);
+                        diff.add( mine );
mine = null;
-                        if ( thisIter.hasNext() ) {
-                            mine = (Interval)thisIter.next();
+                        if ( thisIter.MoveNext() )
+                        {
+                            mine = (Interval)thisIter.Current;
}
}
-                    else {
+                    else
+                    {
// SUBCASE 1b: mine is completely to the left of theirs
// so we can add to difference; move mine, but not theirs
-                        if ( mine.startsBeforeDisjoint(theirs) ) {
-                            diff.add(mine);
+                        if ( mine.startsBeforeDisjoint( theirs ) )
+                        {
+                            diff.add( mine );
mine = null;
-                            if ( thisIter.hasNext() ) {
-                                mine = (Interval)thisIter.next();
+                            if ( thisIter.MoveNext() )
+                            {
+                                mine = (Interval)thisIter.Current;
}
}
// SUBCASE 1c: theirs is completely to the left of mine
-                        else {
+                        else
+                        {
// keep looking in theirs
theirs = null;
-                            if ( otherIter.hasNext() ) {
-                                theirs = (Interval)otherIter.next();
+                            if ( otherIter.MoveNext() )
+                            {
+                                theirs = (Interval)otherIter.Current;
}
}
}
}
-                else {
+                else
+                {
// CASE 2: theirs breaks mine into two chunks
-                    if ( mine.properlyContains(theirs) ) {
+                    if ( mine.properlyContains( theirs ) )
+                    {
// must add two intervals: stuff to left and stuff to right
-                        diff.add(mine.a, theirs.a-1);
+                        diff.add( mine.a, theirs.a - 1 );
// don't actually add stuff to right yet as next 'theirs'
// might overlap with it
// The stuff to the right might overlap with next "theirs".
// so it is considered next
-                        Interval right = new Interval(theirs.b+1, mine.b);
+                        Interval right = new Interval( theirs.b + 1, mine.b );
mine = right;
// move theirs forward
theirs = null;
-                        if ( otherIter.hasNext() ) {
-                            theirs = (Interval)otherIter.next();
+                        if ( otherIter.MoveNext() )
+                        {
+                            theirs = (Interval)otherIter.Current;
}
}

// CASE 3: theirs covers mine; nothing to add to diff
-                    else if ( theirs.properlyContains(mine) ) {
+                    else if ( theirs.properlyContains( mine ) )
+                    {
// nothing to add, theirs forces removal totally of mine
// just move mine looking for an overlapping interval
mine = null;
-                        if ( thisIter.hasNext() ) {
-                            mine = (Interval)thisIter.next();
+                        if ( thisIter.MoveNext() )
+                        {
+                            mine = (Interval)thisIter.Current;
}
}

// CASE 4: non proper overlap
-                    else {
+                    else
+                    {
// overlap, but not properly contained
-                        diff.add(mine.differenceNotProperlyContained(theirs));
+                        diff.add( mine.differenceNotProperlyContained( theirs ) );
// update iterators
-                        boolean moveTheirs = true;
-                        if ( mine.startsBeforeNonDisjoint(theirs) ||
+                        bool moveTheirs = true;
+                        if ( mine.startsBeforeNonDisjoint( theirs ) ||
theirs.b > mine.b )
{
// uh oh, right of theirs extends past right of mine
@@ -452,13 +481,16 @@ namespace Antlr3.Misc
}
// always move mine
mine = null;
-                        if ( thisIter.hasNext() ) {
-                            mine = (Interval)thisIter.next();
+                        if ( thisIter.MoveNext() )
+                        {
+                            mine = (Interval)thisIter.Current;
}
-                        if ( moveTheirs ) {
+                        if ( moveTheirs )
+                        {
theirs = null;
-                            if ( otherIter.hasNext() ) {
-                                theirs = (Interval)otherIter.next();
+                            if ( otherIter.MoveNext() )
+                            {
+                                theirs = (Interval)otherIter.Current;
}
}
}
@@ -466,7 +498,7 @@ namespace Antlr3.Misc
}
return diff;
}
-         */
+#endif

/** TODO: implement this! */
public IIntSet or( IIntSet a )
@@ -796,8 +828,6 @@ namespace Antlr3.Misc

public Antlr.Runtime.BitSet toRuntimeBitSet()
{
-            //org.antlr.runtime.BitSet s =
-            //    new org.antlr.runtime.BitSet( getMaxElement() + 1 );
Antlr.Runtime.BitSet s =
new Antlr.Runtime.BitSet( getMaxElement() + 1 );
int n = intervals.Count;
@@ -816,7 +846,6 @@ namespace Antlr3.Misc

public virtual void remove( int el )
{
-            //throw new NoSuchMethodError("IntervalSet.remove() unimplemented");
throw new NotImplementedException();
}

diff --git a/Antlr3/Misc/Utils.cs b/Antlr3/Misc/Utils.cs
index 5f2f7c8..67acd55 100644
--- a/Antlr3/Misc/Utils.cs
+++ b/Antlr3/Misc/Utils.cs
@@ -30,6 +30,8 @@
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

+#if DEBUG
+
namespace Antlr3.Misc
{
using System;
@@ -70,3 +72,5 @@ namespace Antlr3.Misc
}
}
}
+
+#endif
diff --git a/Antlr3/Tool/AssignTokenTypesBehavior.cs b/Antlr3/Tool/AssignTokenTypesBehavior.cs
index 3617ef8..136bd47 100644
--- a/Antlr3/Tool/AssignTokenTypesBehavior.cs
+++ b/Antlr3/Tool/AssignTokenTypesBehavior.cs
@@ -223,12 +223,10 @@ namespace Antlr3.Tool

protected internal override void defineTokens( Grammar root )
{
-            /*
-                System.out.println("stringLiterals="+stringLiterals);
-                System.out.println("tokens="+tokens);
-                System.out.println("aliases="+aliases);
-                System.out.println("aliasesReverseIndex="+aliasesReverseIndex);
-            */
+            //System.Console.Out.WriteLine( "stringLiterals=" + stringLiterals );
+            //System.Console.Out.WriteLine( "tokens=" + tokens );
+            //System.Console.Out.WriteLine( "aliases=" + aliases );
+            //System.Console.Out.WriteLine( "aliasesReverseIndex=" + aliasesReverseIndex );

assignTokenIDTypes( root );

@@ -236,32 +234,33 @@ namespace Antlr3.Tool

assignStringTypes( root );

-            /*
-                System.out.println("stringLiterals="+stringLiterals);
-                System.out.println("tokens="+tokens);
-                System.out.println("aliases="+aliases);
-            */
+            //System.Console.Out.WriteLine( "stringLiterals=" + stringLiterals );
+            //System.Console.Out.WriteLine( "tokens=" + tokens );
+            //System.Console.Out.WriteLine( "aliases=" + aliases );
defineTokenNamesAndLiteralsInGrammar( root );
}

-        /*
-        protected void defineStringLiteralsFromDelegates() {
-             if ( grammar.getGrammarIsMaster() && grammar.type==Grammar.COMBINED ) {
-                 List<Grammar> delegates = grammar.getDelegates();
-                 System.out.println("delegates in master combined: "+delegates);
-                 for (int i = 0; i < delegates.size(); i++) {
-                     Grammar d = (Grammar) delegates.get(i);
-                     Set<String> literals = d.getStringLiterals();
-                     for (Iterator it = literals.iterator(); it.hasNext();) {
-                         String literal = (String) it.next();
-                         System.out.println("literal "+literal);
-                         int ttype = grammar.getTokenType(literal);
-                         grammar.defineLexerRuleForStringLiteral(literal, ttype);
-                     }
-                 }
-             }
+#if false
+        protected virtual void defineStringLiteralsFromDelegates()
+        {
+            if ( grammar.IsRoot && grammar.type == Grammar.COMBINED )
+            {
+                IList<Grammar> delegates = grammar.getDelegates();
+                System.Console.Out.WriteLine( "delegates in master combined: " + delegates );
+                for ( int i = 0; i < delegates.size(); i++ )
+                {
+                    Grammar d = (Grammar)delegates.get( i );
+                    var literals = d.StringLiterals;
+                    foreach ( string literal in literals )
+                    {
+                        System.Console.Out.WriteLine( "literal " + literal );
+                        int ttype = grammar.getTokenType( literal );
+                        grammar.defineLexerRuleForStringLiteral( literal, ttype );
+                    }
+                }
+            }
}
-        */
+#endif

protected override void assignStringTypes( Grammar root )
{
diff --git a/Antlr3/Tool/AttributeScope.cs b/Antlr3/Tool/AttributeScope.cs
index d4572f5..66c36cc 100644
--- a/Antlr3/Tool/AttributeScope.cs
+++ b/Antlr3/Tool/AttributeScope.cs
@@ -246,18 +246,12 @@ namespace Antlr3.Tool
public virtual Attribute getAttribute( string name )
{
return attributes.FirstOrDefault( attr => attr.Name == name );
-            //return (Attribute)attributes.get( name );
}

/** Used by templates to get all attributes */
public virtual IList<Attribute> getAttributes()
{
return attributes.ToArray();
-            //return attributes.Values.ToArray();
-
-            //IList<Attribute> a = new List<Attribute>();
-            //a.addAll( attributes.values() );
-            //return a;
}

/** Return the set of keys that collide from
diff --git a/Antlr3/Tool/CompositeGrammar.cs b/Antlr3/Tool/CompositeGrammar.cs
index 371f1f7..d08c6b9 100644
--- a/Antlr3/Tool/CompositeGrammar.cs
+++ b/Antlr3/Tool/CompositeGrammar.cs
@@ -186,19 +186,21 @@ namespace Antlr3.Tool

/** Add delegate grammar as child of delegator */
#if WTF
-	public void addGrammar(Grammar delegator, Grammar delegate) {
-		if ( delegator.compositeTreeNode==null ) {
-			delegator.compositeTreeNode = new CompositeGrammarTree(delegator);
-		}
-		delegator.compositeTreeNode.addChild(new CompositeGrammarTree(delegate));
-
-		/*// find delegator in tree so we can add a child to it
-		CompositeGrammarTree t = delegateGrammarTreeRoot.findNode(delegator);
-		t.addChild();
-		*/
-		// make sure new grammar shares this composite
-		delegate.composite = this;
-	}
+        public void addGrammar( Grammar delegator, Grammar @delegate )
+        {
+            if ( delegator.compositeTreeNode == null )
+            {
+                delegator.compositeTreeNode = new CompositeGrammarTree( delegator );
+            }
+            delegator.compositeTreeNode.addChild( new CompositeGrammarTree( @delegate ) );
+
+            //// find delegator in tree so we can add a child to it
+            //CompositeGrammarTree t = delegateGrammarTreeRoot.findNode(delegator);
+            //t.addChild();
+
+            // make sure new grammar shares this composite
+            @delegate.composite = this;
+        }
#else
public virtual void addGrammar( Grammar delegator, Grammar @delegate )
{
@@ -302,18 +304,8 @@ namespace Antlr3.Tool
{
return null;
}
+
HashSet<Rule> rules = getAllImportedRules( g );
-            //for ( Iterator it = rules.iterator(); it.hasNext(); )
-            //{
-            //    Rule r = (Rule)it.next();
-            //    Rule localRule = g.getLocallyDefinedRule( r.name );
-            //    // if locally defined or it's not local but synpred, don't make
-            //    // a delegation method
-            //    if ( localRule != null || r.isSynPred )
-            //    {
-            //        it.remove(); // kill overridden rules
-            //    }
-            //}
foreach ( Rule r in rules.ToArray() )
{
Rule localRule = g.getLocallyDefinedRule( r.name );
@@ -393,7 +385,7 @@ namespace Antlr3.Tool
public virtual void assignTokenTypes()
{
// ASSIGN TOKEN TYPES for all delegates (same walker)
-            //System.out.println("### assign types");
+            //System.Console.Out.WriteLine( "### assign types" );
//ttypesWalker.setASTNodeClass( "org.antlr.tool.GrammarAST" );
IList<Grammar> grammars = delegateGrammarTreeRoot.getPostOrderedGrammarList();
for ( int i = 0; grammars != null && i < grammars.Count; i++ )
@@ -402,7 +394,7 @@ namespace Antlr3.Tool
AssignTokenTypesWalker ttypesWalker = new AssignTokenTypesBehavior( new Antlr.Runtime.Tree.CommonTreeNodeStream( g.Tree ) );
try
{
-                    //System.out.println("    walking "+g.name);
+                    //System.Console.Out.WriteLine( "    walking " + g.name );
ttypesWalker.grammar_( g );

// the walker has filled literals, tokens, and alias tables.
@@ -447,7 +439,7 @@ namespace Antlr3.Tool
Grammar g = (Grammar)grammars[i];
names.Add( g.name );
}
-            //System.out.println("### createNFAs for composite; grammars: "+names);
+            //System.Console.Out.WriteLine( "### createNFAs for composite; grammars: " + names );
for ( int i = 0; grammars != null && i < grammars.Count; i++ )
{
Grammar g = (Grammar)grammars[i];
@@ -484,8 +476,8 @@ namespace Antlr3.Tool
overrides.Add( r.name );
}
}
-            //System.out.println("rule defs for "+p.grammar.name+": "+localRuleDefs);
-            //System.out.println("overridden rule for "+p.grammar.name+": "+overrides);
+            //System.Console.Out.WriteLine( "rule defs for " + p.grammar.name + ": " + localRuleDefs );
+            //System.Console.Out.WriteLine( "overridden rule for " + p.grammar.name + ": " + overrides );
p.grammar.overriddenRules = overrides;

// make set of all rules defined thus far walking delegation tree.
@@ -503,73 +495,85 @@ namespace Antlr3.Tool
}
}

-        /*
-        public void minimizeRuleSet() {
-            Set<Rule> refs = _minimizeRuleSet(delegateGrammarTreeRoot);
-            System.out.println("all rule refs: "+refs);
+#if false
+        public virtual void minimizeRuleSet()
+        {
+            var refs = _minimizeRuleSet( delegateGrammarTreeRoot );
+            System.Console.Out.WriteLine( "all rule refs: " + refs );
}

-        public Set<Rule> _minimizeRuleSet(CompositeGrammarTree p) {
-            Set<Rule> refs = new HashSet<Rule>();
-            for (GrammarAST refAST : p.grammar.ruleRefs) {
-                System.out.println("ref "+refAST.getText()+": "+refAST.NFAStartState+
-                                   " enclosing rule: "+refAST.NFAStartState.enclosingRule+
-                                   " invoking rule: "+((NFAState)refAST.NFAStartState.transition[0].target).enclosingRule);
-                refs.add(((NFAState)refAST.NFAStartState.transition[0].target).enclosingRule);
+        public virtual HashSet<Rule> _minimizeRuleSet( CompositeGrammarTree p )
+        {
+            var refs = new HashSet<Rule>();
+            foreach ( GrammarAST refAST in p.grammar.ruleRefs )
+            {
+                System.Console.Out.WriteLine( "ref " + refAST.Text + ": " + refAST.NFAStartState +
+                                   " enclosing rule: " + refAST.NFAStartState.enclosingRule +
+                                   " invoking rule: " + ( (NFAState)refAST.NFAStartState.transition[0].target ).enclosingRule );
+                refs.Add( ( (NFAState)refAST.NFAStartState.transition[0].target ).enclosingRule );
}

-            if ( p.children!=null ) {
-                for (CompositeGrammarTree delegate : p.children) {
-                    Set<Rule> delegateRuleRefs = _minimizeRuleSet(delegate);
-                    refs.addAll(delegateRuleRefs);
+            if ( p.children != null )
+            {
+                foreach ( CompositeGrammarTree @delegate in p.children )
+                {
+                    var delegateRuleRefs = _minimizeRuleSet( @delegate );
+                    refs.addAll( delegateRuleRefs );
}
}

return refs;
}
-        */
+#endif

-        /*
-        public void oldminimizeRuleSet() {
+#if false
+        public virtual void oldminimizeRuleSet()
+        {
// first walk to remove all overridden rules
-            Set<String> ruleDefs = new HashSet<String>();
-            Set<String> ruleRefs = new HashSet<String>();
-            for (GrammarAST refAST : delegateGrammarTreeRoot.grammar.ruleRefs) {
-                String rname = refAST.getText();
-                ruleRefs.add(rname);
+            var ruleDefs = new HashSet<string>();
+            var ruleRefs = new HashSet<string>();
+            foreach ( GrammarAST refAST in delegateGrammarTreeRoot.grammar.ruleRefs )
+            {
+                string rname = refAST.Text;
+                ruleRefs.add( rname );
}
-            _minimizeRuleSet(ruleDefs,
+            _minimizeRuleSet( ruleDefs,
ruleRefs,
-                             delegateGrammarTreeRoot);
-            System.out.println("overall rule defs: "+ruleDefs);
-        }
-
-        public void _minimizeRuleSet(Set<String> ruleDefs,
-                                     Set<String> ruleRefs,
-                                     CompositeGrammarTree p) {
-            Set<String> localRuleDefs = new HashSet<String>();
-            for (Rule r : p.grammar.getRules()) {
-                if ( !ruleDefs.contains(r.name) ) {
-                    localRuleDefs.add(r.name);
-                    ruleDefs.add(r.name);
+                             delegateGrammarTreeRoot );
+            System.Console.Out.WriteLine( "overall rule defs: " + ruleDefs );
+        }
+
+        public virtual void _minimizeRuleSet( HashSet<string> ruleDefs, HashSet<string> ruleRefs, CompositeGrammarTree p )
+        {
+            var localRuleDefs = new HashSet<string>();
+            foreach ( Rule r in p.grammar.Rules )
+            {
+                if ( !ruleDefs.contains( r.name ) )
+                {
+                    localRuleDefs.add( r.name );
+                    ruleDefs.add( r.name );
}
}
-            System.out.println("rule defs for "+p.grammar.name+": "+localRuleDefs);
+            System.Console.Out.WriteLine( "rule defs for " + p.grammar.name + ": " + localRuleDefs );

// remove locally-defined rules not in ref set
// find intersection of local rules and references from delegator
// that is set of rules needed by delegator
-            Set<String> localRuleDefsSatisfyingRefsFromBelow = new HashSet<String>();
-            for (String r : ruleRefs) {
-                if ( localRuleDefs.contains(r) ) {
-                    localRuleDefsSatisfyingRefsFromBelow.add(r);
+            HashSet<string> localRuleDefsSatisfyingRefsFromBelow = new HashSet<string>();
+            foreach ( string r in ruleRefs )
+            {
+                if ( localRuleDefs.contains( r ) )
+                {
+                    localRuleDefsSatisfyingRefsFromBelow.add( r );
}
}

// now get list of refs from localRuleDefsSatisfyingRefsFromBelow.
// Those rules are also allowed in this delegate
-            for (GrammarAST refAST : p.grammar.ruleRefs) {
-                if ( localRuleDefsSatisfyingRefsFromBelow.contains(refAST.enclosingRuleName) ) {
+            foreach ( GrammarAST refAST in p.grammar.ruleRefs )
+            {
+                if ( localRuleDefsSatisfyingRefsFromBelow.contains( refAST.enclosingRuleName ) )
+                {
// found rule ref within needed rule
}
}
@@ -577,33 +581,37 @@ namespace Antlr3.Tool
// remove rule refs not in the new rule def set

// walk all children, adding rules not already defined
-            if ( p.children!=null ) {
-                for (CompositeGrammarTree delegate : p.children) {
-                    _minimizeRuleSet(ruleDefs, ruleRefs, delegate);
+            if ( p.children != null )
+            {
+                foreach ( CompositeGrammarTree @delegate in p.children )
+                {
+                    _minimizeRuleSet( ruleDefs, ruleRefs, @delegate );
}
}
}
-        */
+#endif

-        /*
-        public void trackNFAStatesThatHaveLabeledEdge(Label label,
-                                                      NFAState stateWithLabeledEdge)
+#if false
+        public virtual void trackNFAStatesThatHaveLabeledEdge( Label label, NFAState stateWithLabeledEdge )
{
-            Set<NFAState> states = typeToNFAStatesWithEdgeOfTypeMap.get(label);
-            if ( states==null ) {
+            HashSet<NFAState> states = typeToNFAStatesWithEdgeOfTypeMap.get( label );
+            if ( states == null )
+            {
states = new HashSet<NFAState>();
-                typeToNFAStatesWithEdgeOfTypeMap.put(label, states);
+                typeToNFAStatesWithEdgeOfTypeMap[label] = states;
}
-            states.add(stateWithLabeledEdge);
+            states.Add( stateWithLabeledEdge );
}

-        public Map<Label, Set<NFAState>> getTypeToNFAStatesWithEdgeOfTypeMap() {
+        public virtual IDictionary<Label, HashSet<NFAState>> getTypeToNFAStatesWithEdgeOfTypeMap()
+        {
return typeToNFAStatesWithEdgeOfTypeMap;
}

-        public Set<NFAState> getStatesWithEdge(Label label) {
-            return typeToNFAStatesWithEdgeOfTypeMap.get(label);
+        public HashSet<NFAState> getStatesWithEdge( Label label )
+        {
+            return typeToNFAStatesWithEdgeOfTypeMap.get( label );
}
-    */
+#endif
}
}
diff --git a/Antlr3/Tool/CompositeGrammarTree.cs b/Antlr3/Tool/CompositeGrammarTree.cs
index d37c2df..c8a6e0b 100644
--- a/Antlr3/Tool/CompositeGrammarTree.cs
+++ b/Antlr3/Tool/CompositeGrammarTree.cs
@@ -50,7 +50,7 @@ namespace Antlr3.Tool

public virtual void addChild( CompositeGrammarTree t )
{
-            //System.out.println("add "+t.toStringTree()+" as child to "+this.toStringTree());
+            //Console.Out.WriteLine("add "+t.toStringTree()+" as child to "+this.toStringTree());
if ( t == null )
{
return; // do nothing upon addChild(null)
@@ -173,7 +173,7 @@ namespace Antlr3.Tool
if ( p.grammar.type == Grammar.LEXER && p.parent != null &&
p.parent.grammar.type == Grammar.COMBINED )
{
-                //System.out.println("wacking "+p.grammar.name+" from "+p.parent.grammar.name);
+                //System.Console.Out.WriteLine( "wacking " + p.grammar.name + " from " + p.parent.grammar.name );
p.parent.children.Remove( this );
}
for ( int i = 0; children != null && i < children.Count; i++ )
diff --git a/Antlr3/Tool/ErrorManager.cs b/Antlr3/Tool/ErrorManager.cs
index df35737..3814954 100644
--- a/Antlr3/Tool/ErrorManager.cs
+++ b/Antlr3/Tool/ErrorManager.cs
@@ -293,38 +293,6 @@ namespace Antlr3.Tool
}

static IANTLRErrorListener theDefaultErrorListener = new DefaultErrorListener();
-        //static ANTLRErrorListener theDefaultErrorListener = new ANTLRErrorListener() {
-        //    public void info(String msg) {
-        //        if (formatWantsSingleLineMessage()) {
-        //            msg = msg.replaceAll("\n", " ");
-        //        }
-        //        System.err.println(msg);
-        //    }
-
-        //    public void error(Message msg) {
-        //        String outputMsg = msg.toString();
-        //        if (formatWantsSingleLineMessage()) {
-        //            outputMsg = outputMsg.replaceAll("\n", " ");
-        //        }
-        //        System.err.println(outputMsg);
-        //    }
-
-        //    public void warning(Message msg) {
-        //        String outputMsg = msg.toString();
-        //        if (formatWantsSingleLineMessage()) {
-        //            outputMsg = outputMsg.replaceAll("\n", " ");
-        //        }
-        //        System.err.println(outputMsg);
-        //    }
-
-        //    public void error(ToolMessage msg) {
-        //        String outputMsg = msg.toString();
-        //        if (formatWantsSingleLineMessage()) {
-        //            outputMsg = outputMsg.replaceAll("\n", " ");
-        //        }
-        //        System.err.println(outputMsg);
-        //    }
-        //};

class InitSTListener : IStringTemplateErrorListener
{
@@ -354,24 +322,6 @@ namespace Antlr3.Tool
*  use templates.
*/
static IStringTemplateErrorListener initSTListener = new InitSTListener();
-        //static StringTemplateErrorListener initSTListener =
-        //    new StringTemplateErrorListener() {
-        //        public void error(String s, Throwable e) {
-        //            System.err.println("ErrorManager init error: "+s);
-        //            if ( e!=null ) {
-        //                System.err.println("exception: "+e);
-        //            }
-        //            /*
-        //            if ( e!=null ) {
-        //                e.printStackTrace(System.err);
-        //            }
-        //            */
-        //        }
-        //        public void warning(String s) {
-        //            System.err.println("ErrorManager init warning: "+s);
-        //        }
-        //        public void debug(String s) {}
-        //    };

class BlankSTListener : IStringTemplateErrorListener
{
@@ -388,12 +338,6 @@ namespace Antlr3.Tool
*  and only for the messages STG.
*/
static IStringTemplateErrorListener blankSTListener = new BlankSTListener();
-        //static StringTemplateErrorListener blankSTListener =
-        //    new StringTemplateErrorListener() {
-        //        public void error(String s, Throwable e) {}
-        //        public void warning(String s) {}
-        //        public void debug(String s) {}
-        //    };

class DefaultSTListener : IStringTemplateErrorListener
{
@@ -417,20 +361,6 @@ namespace Antlr3.Tool
/** Errors during initialization related to ST must all go to System.err.
*/
static IStringTemplateErrorListener theDefaultSTListener = new DefaultSTListener();
-        //static StringTemplateErrorListener theDefaultSTListener =
-        //    new StringTemplateErrorListener() {
-        //    public void error(String s, Throwable e) {
-        //        if ( e instanceof InvocationTargetException ) {
-        //            e = ((InvocationTargetException)e).getTargetException();
-        //        }
-        //        ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, s, e);
-        //    }
-        //    public void warning(String s) {
-        //        ErrorManager.warning(ErrorManager.MSG_INTERNAL_WARNING, s);
-        //    }
-        //    public void debug(String s) {
-        //    }
-        //};

static ErrorManager()
{
@@ -832,19 +762,19 @@ namespace Antlr3.Tool
getErrorListener().error( msg );
}

-        /*
+#if false
// TODO: we can remove I think.  All detected now with cycles check.
public static void leftRecursion(DecisionProbe probe,
int alt,
-                                         Collection targetRules,
-                                         Collection callSiteStates)
+                                         ICollection targetRules,
+                                         ICollection callSiteStates)
{
getErrorState().warnings++;
Message msg = new LeftRecursionMessage(probe, alt, targetRules, callSiteStates);
getErrorState().warningMsgIDs.add(msg.msgID);
getErrorListener().warning(msg);
}
-        */
+#endif

public static void leftRecursionCycles( ICollection cycles )
{
diff --git a/Antlr3/Tool/FASerializer.cs b/Antlr3/Tool/FASerializer.cs
index bbac3db..f6e937b 100644
--- a/Antlr3/Tool/FASerializer.cs
+++ b/Antlr3/Tool/FASerializer.cs
@@ -109,7 +109,6 @@ namespace Antlr3.Tool
StringBuilder buf = new StringBuilder( 0 );
// sort lines to normalize; makes states come out ordered
// and then ordered by edge labels then by target state number :)
-            //Collections.sort( lines );
lines.Sort( System.StringComparer.Ordinal );
for ( int i = 0; i < lines.Count; i++ )
{
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index 231bd2b..953bd27 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -175,7 +175,7 @@ namespace Antlr3.Tool
public const string IGNORE_STRING_IN_GRAMMAR_FILE_NAME = "__";
public const string AUTO_GENERATED_TOKEN_NAME_PREFIX = "T__";

-        public /*static*/ class Decision
+        public class Decision
{
public int decision;
public NFAState startState;
@@ -1340,19 +1340,22 @@ namespace Antlr3.Tool
return rules;
}

+#if false
/** Walk the list of options, altering this Grammar object according
*  to any I recognize.
-        protected void processOptions() {
-            Iterator optionNames = options.keySet().iterator();
-            while (optionNames.hasNext()) {
-                String optionName = (String) optionNames.next();
-                Object value = options.get(optionName);
-                if ( optionName.equals("tokenVocab") ) {
-
+         */
+        protected virtual void processOptions()
+        {
+            foreach ( var option in options )
+            {
+                string optionName = option.Key;
+                object value = option.Value;
+                if ( optionName.Equals( "tokenVocab" ) )
+                {
}
}
}
-         */
+#endif

/** Define all the rule begin/end NFAStates to solve forward reference
*  issues.  Critical for composite grammars too.
@@ -1970,11 +1973,12 @@ namespace Antlr3.Tool
semCtx.trackUseOfSyntacticPredicates( this ); // walk ctx looking for preds
}

-        /*
-        public Set<Rule> getRuleNamesVisitedDuringLOOK() {
+#if false
+        public HashSet<Rule> getRuleNamesVisitedDuringLOOK()
+        {
return rulesSensitiveToOtherRules;
}
-        */
+#endif

/** Given @scope::name {action} define it for this grammar.  Later,
*  the code generator will ask for the actions table.  For composite
@@ -3137,20 +3141,10 @@ namespace Antlr3.Tool
this.options = null;
return;
}
-            //Set keys = options.keySet();
-            //for ( Iterator it = keys.iterator(); it.hasNext(); )
-            //{
-            //    String optionName = (String)it.next();
-            //    object optionValue = options.get( optionName );
-            //    String stored = setOption( optionName, optionValue, optionsStartToken );
-            //    if ( stored == null )
-            //    {
-            //        it.remove();
-            //    }
-            //}
-            foreach ( string optionName in options.Keys.ToArray() )
+            foreach ( var option in options.ToArray() )
{
-                object optionValue = options.get( optionName );
+                string optionName = option.Key;
+                object optionValue = option.Value;
string stored = setOption( optionName, optionValue, optionsStartToken );
if ( stored == null )
options.Remove( optionName );
@@ -3357,7 +3351,7 @@ namespace Antlr3.Tool
if ( r != null )
{
r.tree = t;
-                r.EORNode = t.getLastChild();
+                r.EORNode = t.LastChild;
}
}

@@ -3506,30 +3500,36 @@ namespace Antlr3.Tool
return LineColumnToLookaheadDFAMap;
}

-        /*
-        public void setDecisionOptions(int decision, Map options) {
-            Decision d = createDecision(decision);
+#if false
+        public virtual void setDecisionOptions( int decision, IDictionary options )
+        {
+            Decision d = createDecision( decision );
d.options = options;
}

-        public void setDecisionOption(int decision, String name, Object value) {
-            Decision d = getDecision(decision);
-            if ( d!=null ) {
-                if ( d.options==null ) {
-                    d.options = new HashMap();
+        public virtual void setDecisionOption( int decision, string name, object value )
+        {
+            Decision d = getDecision( decision );
+            if ( d != null )
+            {
+                if ( d.options == null )
+                {
+                    d.options = new Dictionary<object, object>();
}
-                d.options.put(name,value);
+                d.options.put( name, value );
}
}

-        public Map getDecisionOptions(int decision) {
-            Decision d = getDecision(decision);
-            if ( d==null ) {
+        public virtual IDictionary getDecisionOptions( int decision )
+        {
+            Decision d = getDecision( decision );
+            if ( d == null )
+            {
return null;
}
return d.options;
}
-        */
+#endif

[System.Obsolete]
public int getNumberOfDecisions()
@@ -3566,7 +3566,7 @@ namespace Antlr3.Tool
Decision d = createDecision( decision );
d.dfa = lookaheadDFA;
GrammarAST ast = d.startState.associatedASTNode;
-            ast.setLookaheadDFA( lookaheadDFA );
+            ast.LookaheadDFA = lookaheadDFA;
}

public virtual void setDecisionNFA( int decision, NFAState state )
@@ -3770,21 +3770,25 @@ namespace Antlr3.Tool
return null;
}

-        /*
-        public void computeRuleFOLLOWSets() {
-            if ( getNumberOfDecisions()==0 ) {
+#if false
+        public virtual void computeRuleFOLLOWSets()
+        {
+            if ( getNumberOfDecisions() == 0 )
+            {
createNFAs();
}
-            for (Iterator it = getRules().iterator(); it.hasNext();) {
+            for ( Iterator it = getRules().iterator(); it.hasNext(); )
+            {
Rule r = (Rule)it.next();
-                if ( r.isSynPred ) {
+                if ( r.isSynPred )
+                {
continue;
}
-                LookaheadSet s = ll1Analyzer.FOLLOW(r);
-                JSystem.@out.println("FOLLOW("+r.name+")="+s);
+                LookaheadSet s = ll1Analyzer.FOLLOW( r );
+                JSystem.@out.println( "FOLLOW(" + r.name + ")=" + s );
}
}
-        */
+#endif

public virtual LookaheadSet FIRST( NFAState s )
{
diff --git a/Antlr3/Tool/GrammarAST.cs b/Antlr3/Tool/GrammarAST.cs
index 7edfa36..90f12b1 100644
--- a/Antlr3/Tool/GrammarAST.cs
+++ b/Antlr3/Tool/GrammarAST.cs
@@ -44,6 +44,7 @@ namespace Antlr3.Tool
using IToken = Antlr.Runtime.IToken;
using ITree = Antlr.Runtime.Tree.ITree;
using NFAState = Antlr3.Analysis.NFAState;
+    using Obsolete = System.ObsoleteAttribute;
using StringTemplate = Antlr3.ST.StringTemplate;

/** Grammars are first converted to ASTs using this class and then are
@@ -180,33 +181,33 @@ namespace Antlr3.Tool
{
get
{
-                return getLookaheadDFA();
+                return lookaheadDFA;
}
set
{
-                setLookaheadDFA( value );
+                lookaheadDFA = value;
}
}
public NFAState NFAStartState
{
get
{
-                return getNFAStartState();
+                return _nfaStartState;
}
set
{
-                setNFAStartState( value );
+                _nfaStartState = value;
}
}
public IIntSet SetValue
{
get
{
-                return getSetValue();
+                return setValue;
}
set
{
-                setSetValue( value );
+                setValue = value;
}
}
#endregion
@@ -243,24 +244,28 @@ namespace Antlr3.Tool
this.token = token;
}

+        [Obsolete]
public virtual DFA getLookaheadDFA()
{
-            return lookaheadDFA;
+            return LookaheadDFA;
}

+        [Obsolete]
public virtual void setLookaheadDFA( DFA lookaheadDFA )
{
-            this.lookaheadDFA = lookaheadDFA;
+            LookaheadDFA = lookaheadDFA;
}

+        [Obsolete]
public virtual NFAState getNFAStartState()
{
-            return _nfaStartState;
+            return NFAStartState;
}

+        [Obsolete]
public virtual void setNFAStartState( NFAState nfaStartState )
{
-            this._nfaStartState = nfaStartState;
+            NFAStartState = nfaStartState;
}

/** Save the option key/value pair and process it; return the key
@@ -416,21 +421,25 @@ namespace Antlr3.Tool
}
}

+        [Obsolete]
public virtual IIntSet getSetValue()
{
-            return setValue;
+            return SetValue;
}

+        [Obsolete]
public virtual void setSetValue( IIntSet setValue )
{
-            this.setValue = setValue;
+            SetValue = setValue;
}

+        [Obsolete]
public virtual GrammarAST getLastChild()
{
return LastChild;
}

+        [Obsolete]
public virtual GrammarAST getLastSibling()
{
return LastSibling;
diff --git a/Antlr3/Tool/GrammarDanglingStateMessage.cs b/Antlr3/Tool/GrammarDanglingStateMessage.cs
index aa2d9f6..5229763 100644
--- a/Antlr3/Tool/GrammarDanglingStateMessage.cs
+++ b/Antlr3/Tool/GrammarDanglingStateMessage.cs
@@ -71,7 +71,6 @@ namespace Antlr3.Tool
List<int> alts = new List<int>();
alts.addAll( problemState.AltSet );
alts.Sort();
-            //Collections.sort(alts);
st.SetAttribute( "danglingAlts", alts );
st.SetAttribute( "input", input );

diff --git a/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs b/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
index 0a138a9..4d18916 100644
--- a/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
+++ b/Antlr3/Tool/GrammarInsufficientPredicatesMessage.cs
@@ -71,18 +71,16 @@ namespace Antlr3.Tool
List<int> alts = new List<int>();
alts.addAll( altToLocations.Keys );
alts.Sort();
-            //Collections.sort(alts);
foreach ( int altI in alts )
{
altToLocationsWithStringKey[altI.ToString()] = altToLocations.get( altI );
-                /*
-                List<String> tokens = new ArrayList<String>();
-                for (Token t : altToLocations.get(altI)) {
-                    tokens.add(t.toString());
-                }
-                Collections.sort(tokens);
-                System.out.println("tokens=\n"+tokens);
-                */
+                //List<string> tokens = new List<string>();
+                //foreach ( IToken t in altToLocations.get( altI ) )
+                //{
+                //    tokens.Add( t.ToString() );
+                //}
+                //tokens.Sort();
+                //System.Console.Out.WriteLine( "tokens=\n" + tokens );
}
st.SetAttribute( "altToLocations", altToLocationsWithStringKey );

diff --git a/Antlr3/Tool/GrammarNonDeterminismMessage.cs b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
index 48ba68b..e5d410e 100644
--- a/Antlr3/Tool/GrammarNonDeterminismMessage.cs
+++ b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
@@ -32,7 +32,6 @@

namespace Antlr3.Tool
{
-    using System;
using Antlr.Runtime.JavaExtensions;

using DecisionProbe = Antlr3.Analysis.DecisionProbe;
@@ -62,12 +61,12 @@ namespace Antlr3.Tool
}
}

-        public override String ToString()
+        public override string ToString()
{
GrammarAST decisionASTNode = probe.dfa.DecisionASTNode;
line = decisionASTNode.Line;
charPositionInLine = decisionASTNode.CharPositionInLine;
-            String fileName = probe.dfa.nfa.grammar.FileName;
+            string fileName = probe.dfa.nfa.grammar.FileName;
if ( fileName != null )
{
file = fileName;
@@ -76,7 +75,7 @@ namespace Antlr3.Tool
StringTemplate st = getMessageTemplate();
// Now fill template with information about problemState
var labels = probe.getSampleNonDeterministicInputSequence( problemState );
-            String input = probe.getInputSequenceDisplay( labels );
+            string input = probe.getInputSequenceDisplay( labels );
st.SetAttribute( "input", input );

if ( probe.dfa.IsTokensRuleDecision )
@@ -84,7 +83,7 @@ namespace Antlr3.Tool
var disabledAlts = probe.getDisabledAlternatives( problemState );
foreach ( int altI in disabledAlts )
{
-                    String tokenName =
+                    string tokenName =
probe.getTokenNameForTokensRuleAlt( (int)altI );
// reset the line/col to the token definition (pick last one)
NFAState ruleStart =
@@ -99,7 +98,7 @@ namespace Antlr3.Tool
st.SetAttribute( "disabled", probe.getDisabledAlternatives( problemState ) );
}

-            IList nondetAlts = probe.getNonDeterministicAltsForState( problemState );
+            var nondetAlts = probe.getNonDeterministicAltsForState( problemState );
NFAState nfaStart = probe.dfa.NFADecisionStartState;
// all state paths have to begin with same NFA state
int firstAlt = 0;
@@ -127,7 +126,7 @@ namespace Antlr3.Tool
if ( probe.dfa.IsTokensRuleDecision )
{
// alts are token rules, convert to the names instead of numbers
-                            String tokenName =
+                            string tokenName =
probe.getTokenNameForTokensRuleAlt( (int)displayAltI );
st.SetAttribute( "conflictingTokens", tokenName );
}
diff --git a/Antlr3/Tool/GrammarSanity.cs b/Antlr3/Tool/GrammarSanity.cs
index e40ba1d..ead09ff 100644
--- a/Antlr3/Tool/GrammarSanity.cs
+++ b/Antlr3/Tool/GrammarSanity.cs
@@ -121,10 +121,7 @@ namespace Antlr3.Tool
{
// record left-recursive rule, but don't go back in
grammar.leftRecursiveRules.Add( refRuleDef );
-                    /*
-                    System.out.println("already visited "+refRuleDef+", calling from "+
-                                       s.enclosingRule);
-                                       */
+                    //System.Console.Out.WriteLine( "already visited " + refRuleDef + ", calling from " + s.enclosingRule );
addRulesToCycle( refRuleDef,
s.enclosingRule,
listOfRecursiveCycles );
diff --git a/Antlr3/Tool/Interpreter.cs b/Antlr3/Tool/Interpreter.cs
index 25fbe50..ac31a4d 100644
--- a/Antlr3/Tool/Interpreter.cs
+++ b/Antlr3/Tool/Interpreter.cs
@@ -161,7 +161,7 @@ namespace Antlr3.Tool
return;
}
ICharStream @in = (ICharStream)this.input;
-            //System.out.println("scan("+startRule+",'"+in.substring(in.index(),in.size()-1)+"')");
+            //Console.Out.WriteLine( "scan(" + startRule + ",'" + @in.substring( @in.Index, @in.Size() - 1 ) + "')" );
// Build NFAs/DFAs from the grammar AST if NFAs haven't been built yet
if ( grammar.getRuleStartState( startRule ) == null )
{
@@ -199,7 +199,7 @@ namespace Antlr3.Tool
IDebugEventListener actions,
IList visitedStates )
{
-            //System.out.println("parse("+startRule+")");
+            //Console.Out.WriteLine( "parse(" + startRule + ")" );
// Build NFAs/DFAs from the grammar AST if NFAs haven't been built yet
if ( grammar.getRuleStartState( startRule ) == null )
{
@@ -260,22 +260,18 @@ namespace Antlr3.Tool
{
visitedStates.Add( s );
}
-                /*
-                System.out.println("parse state "+s.stateNumber+" input="+
-                    s.nfa.grammar.getTokenDisplayName(t));
-                    */
+                //Console.Out.WriteLine( "parse state " + s.stateNumber + " input=" + s.nfa.grammar.getTokenDisplayName( t ) );
// CASE 1: decision state
if ( s.DecisionNumber > 0 && s.nfa.grammar.getNumberOfAltsForDecisionNFA( s ) > 1 )
{
// decision point, must predict and jump to alt
DFA dfa = s.nfa.grammar.getLookaheadDFA( s.DecisionNumber );
-                    /*
-                    if ( s.nfa.grammar.type!=Grammar.LEXER ) {
-                        System.out.println("decision: "+
-                                       dfa.getNFADecisionStartState().getDescription()+
-                                       " input="+s.nfa.grammar.getTokenDisplayName(t));
-                    }
-                    */
+                    //if ( s.nfa.grammar.type != Grammar.LEXER )
+                    //{
+                    //    Console.Out.WriteLine( "decision: " +
+                    //                   dfa.getNFADecisionStartState().Description +
+                    //                   " input=" + s.nfa.grammar.getTokenDisplayName( t ) );
+                    //}
int m = input.Mark();
int predictedAlt = predict( dfa );
if ( predictedAlt == NFA.INVALID_ALT_NUMBER )
@@ -296,12 +292,10 @@ namespace Antlr3.Tool
input.Rewind( m );
int parseAlt =
s.translateDisplayAltToWalkAlt( predictedAlt );
-                    /*
-                    if ( s.nfa.grammar.type!=Grammar.LEXER ) {
-                        System.out.println("predicted alt "+predictedAlt+", parseAlt "+
-                                           parseAlt);
-                    }
-                    */
+                    //if ( s.nfa.grammar.type != Grammar.LEXER )
+                    //{
+                    //    Console.Out.WriteLine( "predicted alt " + predictedAlt + ", parseAlt " + parseAlt );
+                    //}
NFAState alt;
if ( parseAlt > s.nfa.grammar.getNumberOfAltsForDecisionNFA( s ) )
{
@@ -326,7 +320,7 @@ namespace Antlr3.Tool
if ( ruleInvocationStack.Count == 0 )
{
// done parsing.  Hit the start state.
-                        //System.out.println("stack empty in stop state for "+s.getEnclosingRule());
+                        //Console.Out.WriteLine( "stack empty in stop state for " + s.enclosingRule );
break;
}
// pop invoking state off the stack to know where to return to
@@ -360,7 +354,7 @@ namespace Antlr3.Tool
{
ruleInvocationStack.Push( s );
s = (NFAState)trans.target;
-                        //System.out.println("call "+s.enclosingRule.name+" from "+s.nfa.grammar.getFileName());
+                        //Console.Out.WriteLine( "call " + s.enclosingRule.name + " from " + s.nfa.grammar.getFileName() );
if ( actions != null )
{
actions.EnterRule( s.nfa.grammar.FileName, s.enclosingRule.name );
@@ -439,7 +433,7 @@ namespace Antlr3.Tool
}
}
}
-            //System.out.println("hit stop state for "+stop.getEnclosingRule());
+            //Console.Out.WriteLine( "hit stop state for " + stop.enclosingRule );
if ( actions != null )
{
actions.ExitRule( s.nfa.grammar.FileName, stop.enclosingRule.name );
@@ -452,50 +446,50 @@ namespace Antlr3.Tool
*  input.lookahead(1) must point at the input symbol you want to start
*  predicting with.
*/
-        public int predict( DFA dfa ) {
-		DFAState s = dfa.startState;
-		int c = input.LA(1);
-		Transition eotTransition = null;
-	dfaLoop:
-		while ( !s.IsAcceptState ) {
-			/*
-			System.out.println("DFA.predict("+s.getStateNumber()+", "+
-					dfa.getNFA().getGrammar().getTokenName(c)+")");
-			*/
-			// for each edge of s, look for intersection with current char
-			for (int i=0; i<s.NumberOfTransitions; i++) {
-				Transition t = s.transition(i);
-				// special case: EOT matches any char
-				if ( t.label.matches(c) ) {
-					// take transition i
-					s = (DFAState)t.target;
-					input.Consume();
-					c = input.LA(1);
-					goto dfaLoop;
-				}
-				if ( t.label.Atom==Label.EOT ) {
-					eotTransition = t;
-				}
-			}
-			if ( eotTransition!=null ) {
-				s = (DFAState)eotTransition.target;
-				goto dfaLoop;
-			}
-			/*
-			ErrorManager.error(ErrorManager.MSG_NO_VIABLE_DFA_ALT,
-							   s,
-							   dfa.nfa.grammar.getTokenName(c));
-			*/
-			return NFA.INVALID_ALT_NUMBER;
-		}
-		// woohoo!  We know which alt to predict
-		// nothing emanates from a stop state; must terminate anyway
-		/*
-		System.out.println("DFA stop state "+s.getStateNumber()+" predicts "+
-				s.getUniquelyPredictedAlt());
-		*/
-		return s.getUniquelyPredictedAlt();
-	}
+        public int predict( DFA dfa )
+        {
+            DFAState s = dfa.startState;
+            int c = input.LA( 1 );
+            Transition eotTransition = null;
+        dfaLoop:
+            while ( !s.IsAcceptState )
+            {
+                //Console.Out.WriteLine( "DFA.predict(" + s.stateNumber + ", " + dfa.nfa.grammar.getTokenDisplayName( c ) + ")" );
+                // for each edge of s, look for intersection with current char
+                for ( int i = 0; i < s.NumberOfTransitions; i++ )
+                {
+                    Transition t = s.transition( i );
+                    // special case: EOT matches any char
+                    if ( t.label.matches( c ) )
+                    {
+                        // take transition i
+                        s = (DFAState)t.target;
+                        input.Consume();
+                        c = input.LA( 1 );
+                        goto dfaLoop;
+                    }
+                    if ( t.label.Atom == Label.EOT )
+                    {
+                        eotTransition = t;
+                    }
+                }
+                if ( eotTransition != null )
+                {
+                    s = (DFAState)eotTransition.target;
+                    goto dfaLoop;
+                }
+                /*
+                ErrorManager.error(ErrorManager.MSG_NO_VIABLE_DFA_ALT,
+                                   s,
+                                   dfa.nfa.grammar.getTokenName(c));
+                */
+                return NFA.INVALID_ALT_NUMBER;
+            }
+            // woohoo!  We know which alt to predict
+            // nothing emanates from a stop state; must terminate anyway
+            //Console.Out.WriteLine( "DFA stop state " + s.stateNumber + " predicts " + s.getUniquelyPredictedAlt() );
+            return s.getUniquelyPredictedAlt();
+        }

public virtual void reportScanError( RecognitionException re )
{
diff --git a/Antlr3/Tool/NFAFactory.cs b/Antlr3/Tool/NFAFactory.cs
index b435996..db9b72c 100644
--- a/Antlr3/Tool/NFAFactory.cs
+++ b/Antlr3/Tool/NFAFactory.cs
@@ -40,7 +40,9 @@ namespace Antlr3.Tool
using IIntSet = Antlr3.Misc.IIntSet;
using IList = System.Collections.IList;
using IntervalSet = Antlr3.Misc.IntervalSet;
+    using Obsolete = System.ObsoleteAttribute;
using StringBuilder = System.Text.StringBuilder;
+    using StringComparison = System.StringComparison;

/** Routines to construct StateClusters from EBNF grammar constructs.
*  No optimization is done to remove unnecessary epsilon edges.
@@ -69,19 +71,25 @@ namespace Antlr3.Tool
{
get
{
-                return getCurrentRule();
+                return currentRule;
+            }
+            set
+            {
+                currentRule = value;
}
}
#endregion

+        [Obsolete]
public Rule getCurrentRule()
{
-            return currentRule;
+            return CurrentRule;
}

+        [Obsolete]
public void setCurrentRule( Rule value )
{
-            currentRule = value;
+            CurrentRule = value;
}

public virtual NFAState newState()
@@ -130,10 +138,7 @@ namespace Antlr3.Tool
epsilonTarget.transition[0] != null )
{
s.setTransition0( epsilonTarget.transition[0] );
-                        /*
-                        System.out.println("### opt "+s.stateNumber+"->"+
-                                           epsilonTarget.transition(0).target.stateNumber);
-                        */
+                        //System.Console.Out.WriteLine( "### opt " + s.stateNumber + "->" + epsilonTarget.transition[0].target.stateNumber );
}
}
s = (NFAState)t.target;
@@ -174,20 +179,24 @@ namespace Antlr3.Tool
return g;
}

+#if false
/** Can only complement block of simple alts; can complement build_Set()
*  result, that is.  Get set and complement, replace old with complement.
-        public StateCluster build_AlternativeBlockComplement(StateCluster blk) {
+         */
+        public StateCluster build_AlternativeBlockComplement( StateCluster blk )
+        {
State s0 = blk.left;
-            IntSet set = getCollapsedBlockAsSet(s0);
-            if ( set!=null ) {
+            IIntSet set = getCollapsedBlockAsSet( s0 );
+            if ( set != null )
+            {
// if set is available, then structure known and blk is a set
-                set = nfa.grammar.complement(set);
-                Label label = s0.transition(0).target.transition(0).label;
-                label.setSet(set);
+                set = nfa.grammar.complement( set );
+                Label label = s0.getTransition( 0 ).target.getTransition( 0 ).label;
+                label.Set = set;
}
return blk;
}
-         */
+#endif

public virtual StateCluster build_Range( int a, int b )
{
@@ -267,11 +276,11 @@ namespace Antlr3.Tool
*/
public virtual StateCluster build_RuleRef( Rule refDef, NFAState ruleStart )
{
-            //System.out.println("building ref to rule "+nfa.grammar.name+"."+refDef.name);
+            //System.Console.Out.WriteLine( "building ref to rule " + nfa.grammar.name + "." + refDef.name );
NFAState left = newState();
-            // left.setDescription("ref to "+ruleStart.getDescription());
+            //left.Description = "ref to " + ruleStart.Description;
NFAState right = newState();
-            // right.setDescription("NFAState following ref to "+ruleStart.getDescription());
+            //right.Description = "NFAState following ref to " + ruleStart.Description;
Transition e = new RuleClosureTransition( refDef, ruleStart, right );
left.addTransition( e );
StateCluster g = new StateCluster( left, right );
@@ -295,8 +304,7 @@ namespace Antlr3.Tool
public virtual StateCluster build_SemanticPredicate( GrammarAST pred )
{
// don't count syn preds
-            if ( !pred.Text.ToUpperInvariant()
-                    .StartsWith( Grammar.SYNPRED_RULE_PREFIX.ToUpperInvariant() ) )
+            if ( !pred.Text.StartsWith( Grammar.SYNPRED_RULE_PREFIX, StringComparison.OrdinalIgnoreCase ) )
{
nfa.grammar.numberOfSemanticPredicates++;
}
@@ -362,11 +370,9 @@ namespace Antlr3.Tool
label = Label.EOT;
end.IsEOTTargetState = true;
}
-            /*
-            System.out.println("build "+nfa.grammar.getTokenDisplayName(label)+
-                               " loop on end of state "+endNFAState.getDescription()+
-                               " to state "+end.stateNumber);
-            */
+            //System.Console.Out.WriteLine( "build " + nfa.grammar.getTokenDisplayName( label ) +
+            //                              " loop on end of state " + endNFAState.Description +
+            //                              " to state " + end.stateNumber );
Transition toEnd = new Transition( label, end );
endNFAState.addTransition( toEnd );
}
@@ -448,7 +454,7 @@ namespace Antlr3.Tool
NFAState startOfAlt = newState(); // must have this no matter what
transitionBetweenStates( startOfAlt, g.left, Label.EPSILON );

-                //System.out.println("### opt saved start/stop end in (...)");
+                //System.Console.Out.WriteLine( "### opt saved start/stop end in (...)" );
return new StateCluster( startOfAlt, g.right );
}

@@ -666,6 +672,7 @@ namespace Antlr3.Tool
return g;
}

+#if false
/** Build an NFA predictor for special rule called Tokens manually that
*  predicts which token will succeed.  The refs to the rules are not
*  RuleRefTransitions as I want DFA conversion to stop at the EOT
@@ -689,33 +696,38 @@ namespace Antlr3.Tool
*  Grammar.addArtificialMatchTokensRule().
*
*  11/28/2005: removed so we can use normal rule construction for Tokens.
-        public NFAState build_ArtificialMatchTokensRuleNFA() {
+         */
+        public NFAState build_ArtificialMatchTokensRuleNFA()
+        {
int altNum = 1;
NFAState firstAlt = null; // the start state for the "rule"
NFAState prevAlternative = null;
Iterator iter = nfa.grammar.getRules().iterator();
// TODO: add a single decision node/state for good description
-            while (iter.hasNext()) {
-                Rule r = (Rule) iter.next();
-                String ruleName = r.name;
-                String modifier = nfa.grammar.getRuleModifier(ruleName);
-                if ( ruleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
-                     (modifier!=null &&
-                      modifier.equals(Grammar.FRAGMENT_RULE_MODIFIER)) )
+            while ( iter.hasNext() )
+            {
+                Rule r = (Rule)iter.next();
+                string ruleName = r.name;
+                string modifier = nfa.grammar.getRuleModifier( ruleName );
+                if ( ruleName.Equals( Grammar.ARTIFICIAL_TOKENS_RULENAME ) ||
+                     ( modifier != null &&
+                      modifier.Equals( Grammar.FRAGMENT_RULE_MODIFIER ) ) )
{
continue; // don't loop to yourself or do nontoken rules
}
-                NFAState ruleStartState = nfa.grammar.getRuleStartState(ruleName);
+                NFAState ruleStartState = nfa.grammar.getRuleStartState( ruleName );
NFAState left = newState();
-                left.setDescription("alt "+altNum+" of artificial rule "+Grammar.ARTIFICIAL_TOKENS_RULENAME);
-                transitionBetweenStates(left, ruleStartState, Label.EPSILON);
+                left.Description = "alt " + altNum + " of artificial rule " + Grammar.ARTIFICIAL_TOKENS_RULENAME;
+                transitionBetweenStates( left, ruleStartState, Label.EPSILON );
// Are we the first alternative?
-                if ( firstAlt==null ) {
+                if ( firstAlt == null )
+                {
firstAlt = left; // track extreme top left node as rule start
}
-                else {
+                else
+                {
// if not first alternative, must link to this alt from previous
-                    transitionBetweenStates(prevAlternative, left, Label.EPSILON);
+                    transitionBetweenStates( prevAlternative, left, Label.EPSILON );
}
prevAlternative = left;
altNum++;
@@ -724,7 +736,7 @@ namespace Antlr3.Tool

return firstAlt;
}
-         */
+#endif

/** Build an atom with all possible values in its label */
public virtual StateCluster build_Wildcard( GrammarAST associatedAST )
diff --git a/Antlr3/Tool/NonRegularDecisionMessage.cs b/Antlr3/Tool/NonRegularDecisionMessage.cs
index eace20b..92515d2 100644
--- a/Antlr3/Tool/NonRegularDecisionMessage.cs
+++ b/Antlr3/Tool/NonRegularDecisionMessage.cs
@@ -69,7 +69,6 @@ namespace Antlr3.Tool
List<int> sortedAlts = new List<int>();
sortedAlts.addAll( altsWithRecursion );
sortedAlts.Sort();
-            //Collections.sort(sortedAlts); // make sure it's 1, 2, ...
st.SetAttribute( "alts", sortedAlts );

return base.ToString( st );
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index 1bf573a..fd9faea 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -141,7 +141,7 @@ namespace Antlr3.Tool

public int numberOfAlts;

-        /** Each alt has a Map<tokenRefName,List<tokenRefAST>>; range 1..numberOfAlts.
+        /** Each alt has a Map&lt;tokenRefName,List&lt;tokenRefAST&gt;&gt;; range 1..numberOfAlts.
*  So, if there are 3 ID refs in a rule's alt number 2, you'll have
*  altToTokenRef[2].get("ID").size()==3.  This is used to see if $ID is ok.
*  There must be only one ID reference in the alt for $ID to be ok in
@@ -154,7 +154,7 @@ namespace Antlr3.Tool
*/
IDictionary<string, IList<GrammarAST>>[] altToTokenRefMap;

-        /** Each alt has a Map<ruleRefName,List<ruleRefAST>>; range 1..numberOfAlts
+        /** Each alt has a Map&lt;ruleRefName,List&lt;ruleRefAST&gt;&gt;; range 1..numberOfAlts
*  So, if there are 3 expr refs in a rule's alt number 2, you'll have
*  altToRuleRef[2].get("expr").size()==3.  This is used to see if $expr is ok.
*  There must be only one expr reference in the alt for $expr to be ok in
@@ -274,7 +274,6 @@ namespace Antlr3.Tool
{
tokenLabels = new Dictionary<string, Grammar.LabelElementPair>();
}
-                //tokenLabels.put( label.getText(), pair );
tokenLabels[label.Text] = pair;
break;

@@ -295,7 +294,6 @@ namespace Antlr3.Tool
{
ruleLabels = new Dictionary<string, Grammar.LabelElementPair>();
}
-                //ruleLabels.put( label.getText(), pair );
ruleLabels[label.Text] = pair;
break;
case Grammar.TOKEN_LIST_LABEL:
@@ -303,7 +301,6 @@ namespace Antlr3.Tool
{
tokenListLabels = new Dictionary<string, Grammar.LabelElementPair>();
}
-                //tokenListLabels.put( label.getText(), pair );
tokenListLabels[label.Text] = pair;
break;
case Grammar.RULE_LIST_LABEL:
@@ -311,7 +308,6 @@ namespace Antlr3.Tool
{
ruleListLabels = new Dictionary<string, Grammar.LabelElementPair>();
}
-                //ruleListLabels.put( label.getText(), pair );
ruleListLabels[label.Text] = pair;
break;
case Grammar.CHAR_LABEL:
@@ -319,7 +315,6 @@ namespace Antlr3.Tool
{
charLabels = new Dictionary<string, Grammar.LabelElementPair>();
}
-                //charLabels.put( label.getText(), pair );
charLabels[label.Text] = pair;
break;
}
@@ -658,11 +653,6 @@ namespace Antlr3.Tool
if ( returnScope != null && returnScope.attributes.Count == 1 )
{
return returnScope.attributes[0].Name;
-                //ICollection<Attribute> retvalAttrs = returnScope.attributes.Values;
-                //return retvalAttrs.First().Name;
-
-                //object[] javaSucks = retvalAttrs.toArray();
-                //return ( (Attribute)javaSucks[0] ).name;
}
return null;
}
@@ -734,41 +724,36 @@ namespace Antlr3.Tool
this.options = null;
return;
}
-            //Set keys = options.keySet();
-            //for ( Iterator it = keys.iterator(); it.hasNext(); )
-            //{
-            //    String optionName = (String)it.next();
-            //    object optionValue = options.get( optionName );
-            //    String stored = setOption( optionName, optionValue, optionsStartToken );
-            //    if ( stored == null )
-            //    {
-            //        it.remove();
-            //    }
-            //}
-            foreach ( string optionName in options.Keys.ToArray() )
-            {
-                object optionValue = options.get( optionName );
+
+            foreach ( var option in options.ToArray() )
+            {
+                string optionName = option.Key;
+                object optionValue = option.Value;
string stored = setOption( optionName, optionValue, optionsStartToken );
if ( stored == null )
options.Remove( optionName );
}
}

+#if false
/** Used during grammar imports to see if sets of rules intersect... This
*  method and hashCode use the String name as the key for Rule objects.
-        public boolean equals(Object other) {
-            return this.name.equals(((Rule)other).name);
-        }
*/
+        public override bool Equals( object other )
+        {
+            return this.name.Equals( ( (Rule)other ).name );
+        }

-        /** Used during grammar imports to see if sets of rules intersect...
-        public int hashCode() {
-            return name.hashCode();
+        /** Used during grammar imports to see if sets of rules intersect... */
+        public override int GetHashCode()
+        {
+            return name.GetHashCode();
}
-         * */
+#endif

public override string ToString()
-        { // used for testing
+        {
+            // used for testing
return "[" + grammar.name + "." + name + ",index=" + index + ",line=" + tree.Token.Line + "]";
}
}

