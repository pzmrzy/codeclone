commit 02e4dea32f6c733eb0ccacf56debf365a7cc4145
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Apr 7 11:45:22 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Apr 7 11:45:22 2011 -0800

(C# 3) Use properties to encapsulate fields

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8093]

diff --git a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
index 416037b..f0ab410 100644
--- a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
@@ -85,7 +85,7 @@ namespace Antlr3.Targets
return text.Split( '\n' );
}

-        public override IList PostProcessAction( IList chunks, IToken actionToken )
+        public override IList<object> PostProcessAction( IList<object> chunks, IToken actionToken )
{
/* TODO
- check for and report TAB usage
diff --git a/Antlr3.Test/TestASTConstruction.cs b/Antlr3.Test/TestASTConstruction.cs
index 8608726..59e44d7 100644
--- a/Antlr3.Test/TestASTConstruction.cs
+++ b/Antlr3.Test/TestASTConstruction.cs
@@ -52,7 +52,7 @@ namespace AntlrUnitTests
"a : A;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT A <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -64,7 +64,7 @@ namespace AntlrUnitTests
"B : 'a';" );
string expecting =
"(rule A ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT B <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "A" ).tree.ToStringTree();
+            string found = g.GetRule( "A" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -76,7 +76,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -88,7 +88,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -100,7 +100,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -112,7 +112,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -124,7 +124,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -136,7 +136,7 @@ namespace AntlrUnitTests
"b : B;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -147,7 +147,7 @@ namespace AntlrUnitTests
"a : 'a'*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -158,7 +158,7 @@ namespace AntlrUnitTests
"B : 'b'*;" );
string expecting =
"(rule B ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "B" ).tree.ToStringTree();
+            string found = g.GetRule( "B" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -169,7 +169,7 @@ namespace AntlrUnitTests
"a : 'while'*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'while' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -180,7 +180,7 @@ namespace AntlrUnitTests
"B : 'while'*;" );
string expecting =
"(rule B ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'while' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "B" ).tree.ToStringTree();
+            string found = g.GetRule( "B" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -191,7 +191,7 @@ namespace AntlrUnitTests
"a : 'a'+;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -202,7 +202,7 @@ namespace AntlrUnitTests
"B : 'b'+;" );
string expecting =
"(rule B ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "B" ).tree.ToStringTree();
+            string found = g.GetRule( "B" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -213,7 +213,7 @@ namespace AntlrUnitTests
"a : 'a'?;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -224,7 +224,7 @@ namespace AntlrUnitTests
"B : 'b'?;" );
string expecting =
"(rule B ARG RET scope (BLOCK (ALT (? (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "B" ).tree.ToStringTree();
+            string found = g.GetRule( "B" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -235,7 +235,7 @@ namespace AntlrUnitTests
"ID : 'a'..'z'+;" );
string expecting =
"(rule ID ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (.. 'a' 'z') <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "ID" ).tree.ToStringTree();
+            string found = g.GetRule( "ID" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -246,7 +246,7 @@ namespace AntlrUnitTests
"a : x=ID;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -257,7 +257,7 @@ namespace AntlrUnitTests
"a : x=ID?;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -268,7 +268,7 @@ namespace AntlrUnitTests
"a : x=ID*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -280,7 +280,7 @@ namespace AntlrUnitTests
"b : ID;\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (= x b) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -291,7 +291,7 @@ namespace AntlrUnitTests
"a : x=(A|B);\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (= x (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -302,7 +302,7 @@ namespace AntlrUnitTests
"a : x=~(A|B);\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -313,7 +313,7 @@ namespace AntlrUnitTests
"a : x+=~(A|B);\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -324,7 +324,7 @@ namespace AntlrUnitTests
"a : x+=~(A|B)+;\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (+= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -336,7 +336,7 @@ namespace AntlrUnitTests
"b : ID;\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (= x b) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -347,7 +347,7 @@ namespace AntlrUnitTests
"a : x+=ID*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (+= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -358,7 +358,7 @@ namespace AntlrUnitTests
"a : x+='int'*;" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (+= x 'int') <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -371,7 +371,7 @@ namespace AntlrUnitTests
"b : ID;\n" );
string expecting =
"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (+= x b) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "a" ).tree.ToStringTree();
+            string found = g.GetRule( "a" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -383,7 +383,7 @@ namespace AntlrUnitTests
"a : ('*'^)* ;\n" );  // bug: the synpred had nothing in it
string expecting =
"(rule synpred1_Expr ARG RET scope (BLOCK (ALT '*' <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "synpred1_Expr" ).tree.ToStringTree();
+            string found = g.GetRule( "synpred1_Expr" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

@@ -395,7 +395,7 @@ namespace AntlrUnitTests
"a : ({blort} 'x')* ;\n" );  // bug: the synpred had nothing in it
string expecting =
"(rule synpred1_Expr ARG RET scope (BLOCK (ALT blort 'x' <end-of-alt>) <end-of-block>) <end-of-rule>)";
-            string found = g.GetRule( "synpred1_Expr" ).tree.ToStringTree();
+            string found = g.GetRule( "synpred1_Expr" ).Tree.ToStringTree();
Assert.AreEqual( expecting, found );
}

diff --git a/Antlr3.Test/TestAttributes.cs b/Antlr3.Test/TestAttributes.cs
index a844e0f..dfbe8bd 100644
--- a/Antlr3.Test/TestAttributes.cs
+++ b/Antlr3.Test/TestAttributes.cs
@@ -180,7 +180,7 @@ namespace AntlrUnitTests
g.CodeGenerator = generator;
generator.GenRecognizer(); // forces load of templates
Rule r = g.GetRule( "a" );
-            AttributeScope parameters = r.parameterScope;
+            AttributeScope parameters = r.ParameterScope;
var attrs = parameters.Attributes;
Assert.AreEqual("String[] ick", attrs.ElementAt(0).Decl.ToString(), "attribute mismatch");
Assert.AreEqual("ick", attrs.ElementAt(0).Name, "parameter name mismatch");
@@ -308,7 +308,7 @@ namespace AntlrUnitTests
"        ;";
Grammar g = new Grammar( grammar );
Rule ra = g.GetRule( "a" );
-            var attrs = ra.parameterScope.Attributes;
+            var attrs = ra.ParameterScope.Attributes;
Assert.AreEqual("HashMap<String,String> foo", attrs.ElementAt(0).Decl.ToString(), "attribute mismatch");
Assert.AreEqual("foo", attrs.ElementAt(0).Name, "parameter name mismatch");
Assert.AreEqual("HashMap<String,String>", attrs.ElementAt(0).Type, "declarator mismatch");
@@ -344,7 +344,7 @@ namespace AntlrUnitTests
"        ;";
Grammar g = new Grammar( grammar );
Rule ra = g.GetRule( "a" );
-            var attrs = ra.parameterScope.Attributes;
+            var attrs = ra.ParameterScope.Attributes;

Assert.AreEqual("HashMap<String,String> foo", attrs.ElementAt(0).Decl.ToString().Trim(), "attribute mismatch");
Assert.AreEqual("foo", attrs.ElementAt(0).Name, "parameter name mismatch");
@@ -384,7 +384,7 @@ namespace AntlrUnitTests
"a returns [HashMap<String,String> foo] : ;\n";
Grammar g = new Grammar( grammar );
Rule ra = g.GetRule( "a" );
-            var attrs = ra.returnScope.Attributes;
+            var attrs = ra.ReturnScope.Attributes;
Assert.AreEqual("HashMap<String,String> foo", attrs.ElementAt(0).Decl.ToString(), "attribute mismatch");
Assert.AreEqual("foo", attrs.ElementAt(0).Name, "parameter name mismatch");
Assert.AreEqual("HashMap<String,String>", attrs.ElementAt(0).Type, "declarator mismatch");
@@ -2572,7 +2572,7 @@ namespace AntlrUnitTests
Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);

Rule r = g.GetRule( "r" );
-            AttributeScope retScope = r.returnScope;
+            AttributeScope retScope = r.ReturnScope;
var parameters = retScope.Attributes;
Assert.IsNotNull(parameters, "missing return action");
Assert.AreEqual( 1, parameters.Count );
@@ -2592,7 +2592,7 @@ namespace AntlrUnitTests
Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);

Rule r = g.GetRule( "r" );
-            AttributeScope retScope = r.returnScope;
+            AttributeScope retScope = r.ReturnScope;
var parameters = retScope.Attributes;
Assert.IsNotNull(parameters, "missing return action");
Assert.AreEqual( 3, parameters.Count );
@@ -2612,7 +2612,7 @@ namespace AntlrUnitTests
Assert.AreEqual(0, equeue.errors.Count, "unexpected errors: " + equeue);

Rule r = g.GetRule( "r" );
-            AttributeScope retScope = r.returnScope;
+            AttributeScope retScope = r.ReturnScope;
var parameters = retScope.Attributes;
Assert.IsNotNull(parameters, "missing return action");
Assert.AreEqual( 1, parameters.Count );
diff --git a/Antlr3.Test/TestSymbolDefinitions.cs b/Antlr3.Test/TestSymbolDefinitions.cs
index d80d2d9..93e33e4 100644
--- a/Antlr3.Test/TestSymbolDefinitions.cs
+++ b/Antlr3.Test/TestSymbolDefinitions.cs
@@ -927,19 +927,19 @@ namespace AntlrUnitTests
ruleLabels.Add( labelName );
}
}
-            Assert.IsTrue((tokenLabels != null && r.tokenListLabels != null) ||
-                       (tokenLabels == null && r.tokenListLabels == null),
-                       "token += labels mismatch; " + tokenLabels + "!=" + r.tokenListLabels);
-            Assert.IsTrue((ruleLabels != null && r.ruleListLabels != null) ||
-                       (ruleLabels == null && r.ruleListLabels == null),
-                       "rule += labels mismatch; " + ruleLabels + "!=" + r.ruleListLabels);
+            Assert.IsTrue((tokenLabels != null && r.TokenListLabels != null) ||
+                       (tokenLabels == null && r.TokenListLabels == null),
+                       "token += labels mismatch; " + tokenLabels + "!=" + r.TokenListLabels);
+            Assert.IsTrue((ruleLabels != null && r.RuleListLabels != null) ||
+                       (ruleLabels == null && r.RuleListLabels == null),
+                       "rule += labels mismatch; " + ruleLabels + "!=" + r.RuleListLabels);
if ( tokenLabels != null )
{
-                Assert.IsTrue( tokenLabels.SequenceEqual( r.tokenListLabels.Keys ) );
+                Assert.IsTrue( tokenLabels.SequenceEqual( r.TokenListLabels.Keys ) );
}
if ( ruleLabels != null )
{
-                Assert.IsTrue( ruleLabels.SequenceEqual( r.ruleListLabels.Keys ) );
+                Assert.IsTrue( ruleLabels.SequenceEqual( r.RuleListLabels.Keys ) );
}
}

diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index 89c7bc8..6075103 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -41,7 +41,6 @@ namespace Antlr3.Analysis
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using IIntSet = Antlr3.Misc.IIntSet;
using IIntStream = Antlr.Runtime.IIntStream;
-    using IList = System.Collections.IList;
using IntervalSet = Antlr3.Misc.IntervalSet;
using StringBuilder = System.Text.StringBuilder;
using StringTemplate = Antlr3.ST.StringTemplate;
@@ -1141,7 +1140,7 @@ namespace Antlr3.Analysis
}
NFAState nfaStart = NFADecisionStartState;
Rule r = nfa.grammar.GetLocallyDefinedRule( Grammar.ArtificialTokensRuleName );
-            NFAState TokensRuleStart = r.startState;
+            NFAState TokensRuleStart = r.StartState;
NFAState TokensDecisionStart =
(NFAState)TokensRuleStart.transition[0].Target;
return nfaStart == TokensDecisionStart;
diff --git a/Antlr3/Analysis/DecisionProbe.cs b/Antlr3/Analysis/DecisionProbe.cs
index 0c98272..510cec2 100644
--- a/Antlr3/Analysis/DecisionProbe.cs
+++ b/Antlr3/Analysis/DecisionProbe.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -43,9 +43,7 @@ namespace Antlr3.Analysis
using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;
using GrammarType = Antlr3.Tool.GrammarType;
-    using IList = System.Collections.IList;
using IToken = Antlr.Runtime.IToken;
-    using Obsolete = System.ObsoleteAttribute;
using StringBuilder = System.Text.StringBuilder;

/** Collection of information about what is wrong with a decision as
@@ -430,7 +428,7 @@ namespace Antlr3.Analysis
*  the extra state beginning each alt in my NFA structures).  Here,
*  firstAlt=1.
*/
-        public virtual IList GetNFAPathStatesForAlt( int firstAlt,
+        public virtual IList<NFAState> GetNFAPathStatesForAlt( int firstAlt,
int alt,
IList<Label> labels )
{
@@ -664,7 +662,7 @@ namespace Antlr3.Analysis
foreach ( int stateI in dfaStatesUnaliased )
{
// walk this DFA's config list
-                IList configs = (IList)configurationsMap.get( stateI );
+                IList<NFAConfiguration> configs = configurationsMap.get( stateI );
for ( int i = 0; i < configs.Count; i++ )
{
NFAConfiguration c = (NFAConfiguration)configs[i];
diff --git a/Antlr3/Analysis/LL1Analyzer.cs b/Antlr3/Analysis/LL1Analyzer.cs
index 85bfc52..b32fc5d 100644
--- a/Antlr3/Analysis/LL1Analyzer.cs
+++ b/Antlr3/Analysis/LL1Analyzer.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -175,7 +175,7 @@ namespace Antlr3.Analysis
{
return f;
}
-            f = FirstCore( r.stopState, true );
+            f = FirstCore( r.StopState, true );
_followCache[r] = f;
//JSystem.@out.println("< FOLLOW("+r+") in rule "+r.startState.enclosingRule+"="+f.toString(this.grammar));
return f;
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index 803f4cc..66befae 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -35,13 +35,12 @@ namespace Antlr3.Analysis
using System.Collections.Generic;
using System.Linq;
using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Misc;

using BitSet = Antlr3.Misc.BitSet;
using Console = System.Console;
using ErrorManager = Antlr3.Tool.ErrorManager;
-    using IList = System.Collections.IList;
using IToken = Antlr.Runtime.IToken;
-    using Antlr3.Misc;

/** Code that embodies the NFA conversion to DFA. A new object is needed
*  per DFA (also required for thread safety if multiple conversions
@@ -1813,7 +1812,7 @@ namespace Antlr3.Analysis
// Sort ascending according to alt; alt i has higher precedence than i+1
configsWithPreds.Sort( new AddPredicateTransitionsComparer() );
//Collections.sort( configsWithPreds, new AddPredicateTransitionsComparer() );
-            IList predConfigsSortedByAlt = configsWithPreds;
+            IList<NFAConfiguration> predConfigsSortedByAlt = configsWithPreds;
// Now, we can add edges emanating from d for these preds in right order
for ( int i = 0; i < predConfigsSortedByAlt.Count; i++ )
{
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index 633fa00..54a377f 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2010 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -42,7 +42,6 @@ namespace Antlr3

using File = System.IO.File;
using FileInfo = System.IO.FileInfo;
-    using IList = System.Collections.IList;
using IOException = System.IO.IOException;
using Path = System.IO.Path;
using Stats = Antlr.Runtime.Misc.Stats;
@@ -846,7 +845,7 @@ namespace Antlr3
{
try
{
-                    string dot = generator.GenerateGraph( r.startState );
+                    string dot = generator.GenerateGraph( r.StartState );
if ( dot != null )
{
WriteGraphFile( g, r, dot, generator.FileExtension );
@@ -861,7 +860,7 @@ namespace Antlr3

protected virtual void WriteGraphFile( Grammar g, Rule r, string graph, string formatExtension )
{
-            WriteGraphFile( g, r.grammar.name + "." + r.Name, graph, formatExtension );
+            WriteGraphFile( g, r.Grammar.name + "." + r.Name, graph, formatExtension );
}

protected virtual void WriteGraphFile( Grammar g, string name, string graph, string formatExtension )
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index 30c1ed0..16eaf84 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -60,7 +60,6 @@ namespace Antlr3.Codegen
using GrammarAST = Antlr3.Tool.GrammarAST;
using GrammarType = Antlr3.Tool.GrammarType;
using IIntSet = Antlr3.Misc.IIntSet;
-    using IList = System.Collections.IList;
using Interval = Antlr3.Misc.Interval;
using IntervalSet = Antlr3.Misc.IntervalSet;
using IOException = System.IO.IOException;
@@ -69,8 +68,6 @@ namespace Antlr3.Codegen
using IToken = Antlr.Runtime.IToken;
using Label = Antlr3.Analysis.Label;
using LookaheadSet = Antlr3.Analysis.LookaheadSet;
-    using MethodImpl = System.Runtime.CompilerServices.MethodImplAttribute;
-    using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
using NFAState = Antlr3.Analysis.NFAState;
using Path = System.IO.Path;
using RecognitionException = Antlr.Runtime.RecognitionException;
@@ -814,7 +811,7 @@ namespace Antlr3.Codegen
foreach ( string name in actionNameSet )
{
GrammarAST actionAST = (GrammarAST)scopeActions.get( name );
-                IList chunks = TranslateAction( ruleName, actionAST );
+                IList<object> chunks = TranslateAction( ruleName, actionAST );
scopeActions[name] = chunks; // replace with translation
}
}
@@ -876,12 +873,12 @@ namespace Antlr3.Codegen
}
//JSystem.@out.println(" "+follow);

-            IList tokenTypeList = null;
+            IList<int> tokenTypeList = null;
ulong[] words = null;
if ( follow.tokenTypeSet == null )
{
words = new ulong[1];
-                tokenTypeList = new List<object>();
+                tokenTypeList = new List<int>();
}
else
{
@@ -1202,7 +1199,7 @@ namespace Antlr3.Codegen
return vocabFileST;
}

-        public virtual IList TranslateAction( string ruleName,
+        public virtual IList<object> TranslateAction( string ruleName,
GrammarAST actionTree )
{
if ( actionTree.Type == ANTLRParser.ARG_ACTION )
@@ -1210,7 +1207,7 @@ namespace Antlr3.Codegen
return TranslateArgAction( ruleName, actionTree );
}
ActionTranslator translator = new ActionTranslator( this, ruleName, actionTree );
-            IList chunks = translator.TranslateToChunks();
+            IList<object> chunks = translator.TranslateToChunks();
chunks = target.PostProcessAction( chunks, actionTree.Token );
return chunks;
}
@@ -1220,12 +1217,12 @@ namespace Antlr3.Codegen
*  of chunks, must cat together into a StringTemplate>.  Don't translate
*  to strings early as we need to eval templates in context.
*/
-        public virtual List<StringTemplate> TranslateArgAction( string ruleName,
+        public virtual List<object> TranslateArgAction( string ruleName,
GrammarAST actionTree )
{
string actionText = actionTree.Token.Text;
List<string> args = GetListOfArgumentsFromAction( actionText, ',' );
-            List<StringTemplate> translatedArgs = new List<StringTemplate>();
+            List<object> translatedArgs = new List<object>();
foreach ( string arg in args )
{
if ( arg != null )
@@ -1236,7 +1233,7 @@ namespace Antlr3.Codegen
new ActionTranslator( this, ruleName,
actionToken,
actionTree.outerAltNum );
-                    IList chunks = translator.TranslateToChunks();
+                    IList<object> chunks = translator.TranslateToChunks();
chunks = target.PostProcessAction( chunks, actionToken );
StringTemplate catST = new StringTemplate( templates, "<chunks>" );
catST.SetAttribute( "chunks", chunks );
@@ -1436,7 +1433,7 @@ namespace Antlr3.Codegen
{
if ( r != null )
{
-                    scope = r.ruleScope; // if not global, might be rule scope
+                    scope = r.RuleScope; // if not global, might be rule scope
}
}
if ( scope == null )
diff --git a/Antlr3/Codegen/Target.cs b/Antlr3/Codegen/Target.cs
index 6282fdb..6d3d41f 100644
--- a/Antlr3/Codegen/Target.cs
+++ b/Antlr3/Codegen/Target.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -32,14 +32,13 @@

namespace Antlr3.Codegen
{
-    using Antlr.Runtime.JavaExtensions;
+    using System.Collections.Generic;

using AntlrTool = Antlr3.AntlrTool;
using ArgumentException = System.ArgumentException;
using CLSCompliant = System.CLSCompliantAttribute;
using Grammar = Antlr3.Tool.Grammar;
using GrammarType = Antlr3.Tool.GrammarType;
-    using IList = System.Collections.IList;
using IToken = Antlr.Runtime.IToken;
using Label = Antlr3.Analysis.Label;
using StringBuilder = System.Text.StringBuilder;
@@ -429,7 +428,7 @@ namespace Antlr3.Codegen
/** Give target a chance to do some postprocessing on actions.
*  Python for example will have to fix the indention.
*/
-        public virtual IList PostProcessAction( IList chunks, IToken actionToken )
+        public virtual IList<object> PostProcessAction( IList<object> chunks, IToken actionToken )
{
return chunks;
}
diff --git a/Antlr3/Grammars/ActionTranslatorHelper.cs b/Antlr3/Grammars/ActionTranslatorHelper.cs
index 877578f..ff5fdc8 100644
--- a/Antlr3/Grammars/ActionTranslatorHelper.cs
+++ b/Antlr3/Grammars/ActionTranslatorHelper.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Grammar conversion to ANTLR v3 and C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -32,17 +32,16 @@

namespace Antlr3.Grammars
{
+    using System.Collections.Generic;
using Antlr3.Codegen;

using ANTLRStringStream = Antlr.Runtime.ANTLRStringStream;
-    using ArrayList = System.Collections.ArrayList;
using Attribute = Antlr3.Tool.Attribute;
using AttributeScope = Antlr3.Tool.AttributeScope;
using CommonToken = Antlr.Runtime.CommonToken;
using ErrorManager = Antlr3.Tool.ErrorManager;
using Grammar = Antlr3.Tool.Grammar;
using GrammarAST = Antlr3.Tool.GrammarAST;
-    using IList = System.Collections.IList;
using IToken = Antlr.Runtime.IToken;
using Rule = Antlr3.Tool.Rule;
using StringBuilder = System.Text.StringBuilder;
@@ -52,7 +51,7 @@ namespace Antlr3.Grammars

partial class ActionTranslator
{
-        public IList chunks = new ArrayList();
+        public IList<object> chunks = new List<object>();
Rule enclosingRule;
int outerAltNum;
Grammar grammar;
@@ -87,7 +86,7 @@ namespace Antlr3.Grammars
/** Return a list of strings and StringTemplate objects that
*  represent the translated action.
*/
-        public IList TranslateToChunks()
+        public IList<object> TranslateToChunks()
{
// JSystem.@out.println("###\naction="+action);
IToken t;
@@ -100,7 +99,7 @@ namespace Antlr3.Grammars

public string Translate()
{
-            IList theChunks = TranslateToChunks();
+            IList<object> theChunks = TranslateToChunks();
//JSystem.@out.println("chunks="+a.chunks);
StringBuilder buf = new StringBuilder();
for (int i = 0; i < theChunks.Count; i++)
@@ -112,7 +111,7 @@ namespace Antlr3.Grammars
return buf.ToString();
}

-        public IList TranslateAction(string action)
+        public IList<object> TranslateAction(string action)
{
string rname = null;
if (enclosingRule != null)
@@ -141,7 +140,7 @@ namespace Antlr3.Grammars

public void CheckElementRefUniqueness(string @ref, bool isToken)
{
-            IList refs = null;
+            IList<GrammarAST> refs = null;
if (isToken)
{
refs = enclosingRule.GetTokenRefsInAlt(@ref, outerAltNum);
@@ -182,7 +181,7 @@ namespace Antlr3.Grammars
Rule scopeRule = grammar.GetRule(scopeName);
if (scopeRule != null)
{
-                return scopeRule.ruleScope;
+                return scopeRule.RuleScope;
}
return null; // not a valid dynamic scope
}
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index 6872cec..07e51ec 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -54,7 +54,6 @@ using Antlr3.Tool;

using BitSet = Antlr.Runtime.BitSet;
using DFA = Antlr.Runtime.DFA;
-using IList = System.Collections.IList;
using StringTemplate = Antlr3.ST.StringTemplate;
using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
using TokenWithIndex = Antlr.Runtime.CommonToken;
@@ -176,7 +175,7 @@ rule returns [StringTemplate code=null]
// For syn preds, we don't want any AST code etc... in there.
// Save old templates ptr and restore later.  Base templates include Dbg.
StringTemplateGroup saveGroup = templates;
-	if ( ruleDescr.isSynPred )
+	if ( ruleDescr.IsSynPred )
{
templates = generator.BaseTemplates;
}
@@ -202,7 +201,7 @@ rule returns [StringTemplate code=null]
$b.code.SetAttribute("description", description);
// do not generate lexer rules in combined grammar
string stName = null;
-				if ( ruleDescr.isSynPred )
+				if ( ruleDescr.IsSynPred )
{
stName = "synpredRule";
}
@@ -426,7 +425,7 @@ exceptionGroup[StringTemplate ruleST]
exceptionHandler[StringTemplate ruleST]
:	^('catch' ARG_ACTION ACTION)
{
-			IList chunks = generator.TranslateAction(currentRuleName,$ACTION);
+			IList<object> chunks = generator.TranslateAction(currentRuleName,$ACTION);
$ruleST.SetAttribute("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
}
;
@@ -434,7 +433,7 @@ exceptionHandler[StringTemplate ruleST]
finallyClause[StringTemplate ruleST]
:	^('finally' ACTION)
{
-			IList chunks = generator.TranslateAction(currentRuleName,$ACTION);
+			IList<object> chunks = generator.TranslateAction(currentRuleName,$ACTION);
$ruleST.SetAttribute("finally",chunks);
}
;
@@ -750,25 +749,25 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
$code.SetAttribute("scope", scopeG);
}
-			else if ( rdef.grammar != this.grammar ) { // nonlocal
+			else if ( rdef.Grammar != this.grammar ) { // nonlocal
// if rule definition is not in this grammar, it's nonlocal
-				IList<Grammar> rdefDelegates = rdef.grammar.GetDelegates();
+				IList<Grammar> rdefDelegates = rdef.Grammar.GetDelegates();
if ( rdefDelegates.Contains(this.grammar) ) {
-					$code.SetAttribute("scope", rdef.grammar);
+					$code.SetAttribute("scope", rdef.Grammar);
}
else {
// defining grammar is not a delegate, scope all the
// back to root, which has delegate methods for all
// rules.  Don't use scope if we are root.
-					if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
+					if ( this.grammar != rdef.Grammar.composite.delegateGrammarTreeRoot.grammar ) {
$code.SetAttribute("scope",
-										  rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
+										  rdef.Grammar.composite.delegateGrammarTreeRoot.grammar);
}
}
}

if ( $rarg!=null ) {
-				IList args = generator.TranslateAction(currentRuleName,$rarg);
+				IList<object> args = generator.TranslateAction(currentRuleName,$rarg);
$code.SetAttribute("args", args);
}
int i = ((TokenWithIndex)r.Token).TokenIndex;
@@ -813,14 +812,14 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
Grammar scopeG = grammar.composite.GetGrammar(scope.Text);
$code.SetAttribute("scope", scopeG);
}
-					else if ( rdef2.grammar != this.grammar )
+					else if ( rdef2.Grammar != this.grammar )
{ // nonlocal
// if rule definition is not in this grammar, it's nonlocal
-						$code.SetAttribute("scope", rdef2.grammar);
+						$code.SetAttribute("scope", rdef2.Grammar);
}
if ( $targ!=null )
{
-						IList args = generator.TranslateAction(currentRuleName,$targ);
+						IList<object> args = generator.TranslateAction(currentRuleName,$targ);
$code.SetAttribute("args", args);
}
}
@@ -1006,7 +1005,7 @@ rewrite returns [StringTemplate code=null]
^( r=REWRITE (pred=SEMPRED)? alt=rewrite_alternative)
{
rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
-					IList predChunks = null;
+					IList<object> predChunks = null;
if ( $pred!=null )
{
//predText = #pred.getText();
@@ -1223,7 +1222,7 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
$code.SetAttribute("terminalOptions",term.terminalOptions);
if ( $arg!=null )
{
-				IList args = generator.TranslateAction(currentRuleName,$arg);
+				IList<object> args = generator.TranslateAction(currentRuleName,$arg);
$code.SetAttribute("args", args);
}
$code.SetAttribute("elementIndex", ((TokenWithIndex)$start.Token).TokenIndex);
@@ -1305,7 +1304,7 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
{
// actions in rewrite rules yield a tree object
string actText = $ACTION.text;
-			IList chunks = generator.TranslateAction(currentRuleName,$ACTION);
+			IList<object> chunks = generator.TranslateAction(currentRuleName,$ACTION);
$code = templates.GetInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
$code.SetAttribute("action", chunks);
}
@@ -1328,7 +1327,7 @@ rewrite_template returns [StringTemplate code=null]
else if ( $ind!=null )
{ // must be \%({expr})(args)
$code = templates.GetInstanceOf("rewriteIndirectTemplate");
-					IList chunks=generator.TranslateAction(currentRuleName,$ind);
+					IList<object> chunks=generator.TranslateAction(currentRuleName,$ind);
$code.SetAttribute("expr", chunks);
}
}
@@ -1339,7 +1338,7 @@ rewrite_template returns [StringTemplate code=null]
// because actions like \%foo(name={\$ID.text}) aren't
// broken up yet into trees.
$a.outerAltNum = this.outerAltNum;
-						IList chunks = generator.TranslateAction(currentRuleName,$a);
+						IList<object> chunks = generator.TranslateAction(currentRuleName,$a);
$code.SetAttribute("args.{name,value}", $arg.text, chunks);
}
)
diff --git a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
index dbcef53..039eb36 100644
--- a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Grammar conversion to ANTLR v3 and C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -33,7 +33,6 @@
namespace Antlr3.Grammars
{
using System.Collections.Generic;
-    using Antlr.Runtime.JavaExtensions;
using Antlr3.Codegen;

using CommonToken = Antlr.Runtime.CommonToken;
@@ -126,7 +125,7 @@ namespace Antlr3.Grammars
// unless we're in a synpred rule.
Rule r = grammar.GetRule( currentRuleName );
if ( ( grammar.BuildAST || suffix.Length > 0 ) && label == null &&
-                 ( r == null || !r.isSynPred ) )
+                 ( r == null || !r.IsSynPred ) )
{
// we will need a label to do the AST or tracking, make one
label = generator.CreateUniqueLabel( ruleTargetName );
@@ -166,7 +165,7 @@ namespace Antlr3.Grammars
// unless we're in a synpred rule.
Rule r = grammar.GetRule( currentRuleName );
if ( ( grammar.BuildAST || suffix.Length > 0 ) && label == null &&
-                 ( r == null || !r.isSynPred ) )
+                 ( r == null || !r.IsSynPred ) )
{
label = generator.CreateUniqueLabel( elementName );
CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
@@ -223,7 +222,7 @@ namespace Antlr3.Grammars
string rewritePart = "";
string listLabelPart = "";
Rule ruleDescr = grammar.GetRule( currentRuleName );
-            if ( ast_suffix != null && !ruleDescr.isSynPred )
+            if ( ast_suffix != null && !ruleDescr.IsSynPred )
{
if ( ast_suffix.Type == ANTLRParser.ROOT )
{
diff --git a/Antlr3/Grammars/DefineGrammarItemsWalker.g3 b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
index 7af2748..71dbbf3 100644
--- a/Antlr3/Grammars/DefineGrammarItemsWalker.g3
+++ b/Antlr3/Grammars/DefineGrammarItemsWalker.g3
@@ -178,18 +178,18 @@ rule
r = grammar.GetRule(name);
if ( $args!=null )
{
-						r.parameterScope = grammar.CreateParameterScope(name,$args.Token);
-						r.parameterScope.AddAttributes($args.text, ',');
+						r.ParameterScope = grammar.CreateParameterScope(name,$args.Token);
+						r.ParameterScope.AddAttributes($args.text, ',');
}
if ( $ret!=null )
{
-						r.returnScope = grammar.CreateReturnScope(name,$ret.Token);
-						r.returnScope.AddAttributes($ret.text, ',');
+						r.ReturnScope = grammar.CreateReturnScope(name,$ret.Token);
+						r.ReturnScope.AddAttributes($ret.text, ',');
}
if ( $throwsSpec.exceptions != null )
{
foreach ( string exception in $throwsSpec.exceptions )
-							r.throwsSpec.Add( exception );
+							r.ThrowsSpec.Add( exception );
}
}
}
@@ -239,11 +239,11 @@ scope AttributeScopeActions;
:	^(	'scope'
(	attrScopeAction* attrs=ACTION
{
-					r.ruleScope = grammar.CreateRuleScope(r.Name,$attrs.Token);
-					r.ruleScope.isDynamicRuleScope = true;
-					r.ruleScope.AddAttributes($attrs.text, ';');
+					r.RuleScope = grammar.CreateRuleScope(r.Name,$attrs.Token);
+					r.RuleScope.isDynamicRuleScope = true;
+					r.RuleScope.AddAttributes($attrs.text, ';');
foreach ( var action in $AttributeScopeActions::actions )
-						r.ruleScope.DefineNamedAction( action.Key, action.Value );
+						r.RuleScope.DefineNamedAction( action.Key, action.Value );
}
)?
(	uses=ID
@@ -255,8 +255,8 @@ scope AttributeScopeActions;
$uses.text);
}
else {
-					if ( r.useScopes==null ) {r.useScopes=new List<string>();}
-					r.useScopes.Add($uses.text);
+					if ( r.UseScopes==null ) {r.UseScopes=new List<string>();}
+					r.UseScopes.Add($uses.text);
}
}
)*
diff --git a/Antlr3/Grammars/TreeToNFAConverter.g3 b/Antlr3/Grammars/TreeToNFAConverter.g3
index 0c6c45e..7b0b91b 100644
--- a/Antlr3/Grammars/TreeToNFAConverter.g3
+++ b/Antlr3/Grammars/TreeToNFAConverter.g3
@@ -112,7 +112,7 @@ rule
{
// attach start node to block for this rule
Rule thisR = grammar.GetLocallyDefinedRule(currentRuleName);
-					NFAState start = thisR.startState;
+					NFAState start = thisR.StartState;
start.associatedASTNode = $id;
start.AddTransition(new Transition(Label.EPSILON, g.left));

@@ -127,7 +127,7 @@ rule
}

// hook to end of rule node
-					NFAState end = thisR.stopState;
+					NFAState end = thisR.StopState;
g.right.AddTransition(new Transition(Label.EPSILON,end));
}
}
@@ -713,7 +713,7 @@ testSetElement returns [int alts=1]
throw new RecognitionException();
}
// recursively will invoke this rule to match elements in target rule ref
-				$alts += TestSetRule(rule.tree);
+				$alts += TestSetRule(rule.Tree);
}
}}
|   {grammar.type!=GrammarType.Lexer}? => s=STRING_LITERAL
diff --git a/Antlr3/Grammars/TreeToNFAConverterHelper.cs b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
index ec0967c..88c6573 100644
--- a/Antlr3/Grammars/TreeToNFAConverterHelper.cs
+++ b/Antlr3/Grammars/TreeToNFAConverterHelper.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Grammar conversion to ANTLR v3 and C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -117,7 +117,7 @@ namespace Antlr3.Grammars
//System.Console.Out.WriteLine( "adding follow link to rule " + ruleName );
// find last link in FOLLOW chain emanating from rule
Rule r = grammar.GetRule( ruleName );
-            NFAState end = r.stopState;
+            NFAState end = r.StopState;
while ( end.GetTransition( 1 ) != null )
{
end = (NFAState)end.GetTransition( 1 ).Target;
diff --git a/Antlr3/Tool/BuildDependencyGenerator.cs b/Antlr3/Tool/BuildDependencyGenerator.cs
index eb98b92..fcac1ea 100644
--- a/Antlr3/Tool/BuildDependencyGenerator.cs
+++ b/Antlr3/Tool/BuildDependencyGenerator.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -38,7 +38,6 @@ namespace Antlr3.Tool

using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using FileInfo = System.IO.FileInfo;
-    using IList = System.Collections.IList;
using Path = System.IO.Path;
using StringTemplate = Antlr3.ST.StringTemplate;
using StringTemplateGroup = Antlr3.ST.StringTemplateGroup;
diff --git a/Antlr3/Tool/CompositeGrammar.cs b/Antlr3/Tool/CompositeGrammar.cs
index a64c77a..8726202 100644
--- a/Antlr3/Tool/CompositeGrammar.cs
+++ b/Antlr3/Tool/CompositeGrammar.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -121,7 +121,7 @@ namespace Antlr3.Tool

public bool watchNFAConversion = false;

-        protected virtual void initTokenSymbolTables()
+        protected virtual void InitTokenSymbolTables()
{
// the faux token types take first NUM_FAUX_LABELS positions
// then we must have room for the predefined runtime token types
@@ -149,7 +149,7 @@ namespace Antlr3.Tool

public CompositeGrammar()
{
-            initTokenSymbolTables();
+            InitTokenSymbolTables();
}

public CompositeGrammar( Grammar g )
@@ -310,7 +310,7 @@ namespace Antlr3.Tool
{
Rule localRule = g.GetLocallyDefinedRule( r.Name );
// if locally defined or it's not local but synpred, don't make a delegation method
-                if ( localRule != null || r.isSynPred )
+                if ( localRule != null || r.IsSynPred )
{
// kill overridden rules
rules.Remove( r );
diff --git a/Antlr3/Tool/DOTGenerator.cs b/Antlr3/Tool/DOTGenerator.cs
index 608e0a5..e8a103c 100644
--- a/Antlr3/Tool/DOTGenerator.cs
+++ b/Antlr3/Tool/DOTGenerator.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2010 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -39,7 +39,6 @@ namespace Antlr3.Tool

using AngleBracketTemplateLexer = Antlr3.ST.Language.AngleBracketTemplateLexer;
using ANTLRParser = Antlr3.Grammars.ANTLRParser;
-    using IList = System.Collections.IList;
using Path = System.IO.Path;
using StringBuffer = System.Text.StringBuilder;
using StringTemplate = Antlr3.ST.StringTemplate;
@@ -283,9 +282,9 @@ namespace Antlr3.Tool
RuleClosureTransition rr = ( (RuleClosureTransition)edge );
// don't jump to other rules, but display edge to follow node
edgeST = stlib.GetInstanceOf( Path.Combine( dfaTemplateDirectoryName, "edge" ) );
-                    if ( rr.rule.grammar != grammar )
+                    if ( rr.rule.Grammar != grammar )
{
-                        edgeST.SetAttribute( "label", "<" + rr.rule.grammar.name + "." + rr.rule.Name + ">" );
+                        edgeST.SetAttribute( "label", "<" + rr.rule.Grammar.name + "." + rr.rule.Name + ">" );
}
else
{
@@ -438,7 +437,7 @@ namespace Antlr3.Tool
buf.Append( ':' );
// get a list of configs for just this alt
// it will help us print better later
-                            IList configsInAlt = new List<object>();
+                            IList<object> configsInAlt = new List<object>();
foreach ( NFAConfiguration c in configurations )
{
if ( c.alt != alt )
diff --git a/Antlr3/Tool/DgmlGenerator.cs b/Antlr3/Tool/DgmlGenerator.cs
index 4c78fc3..8deb5fb 100644
--- a/Antlr3/Tool/DgmlGenerator.cs
+++ b/Antlr3/Tool/DgmlGenerator.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2010 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -240,8 +240,8 @@ namespace Antlr3.Tool
{
string label;

-                    if (rr.rule.grammar != _grammar)
-                        label = string.Format("<{0}.{1}>", rr.rule.grammar.name, rr.rule.Name);
+                    if (rr.rule.Grammar != _grammar)
+                        label = string.Format("<{0}.{1}>", rr.rule.Grammar.name, rr.rule.Name);
else
label = string.Format("<{0}>", rr.rule.Name);

diff --git a/Antlr3/Tool/FASerializer.cs b/Antlr3/Tool/FASerializer.cs
index 12c3760..e1c2911 100644
--- a/Antlr3/Tool/FASerializer.cs
+++ b/Antlr3/Tool/FASerializer.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -36,7 +36,6 @@ namespace Antlr3.Tool
using Antlr3.Analysis;

using Environment = System.Environment;
-    using IList = System.Collections.IList;
using StringBuilder = System.Text.StringBuilder;

/** An aspect of FA (finite automata) that knows how to dump them to serialized
@@ -153,7 +152,7 @@ namespace Antlr3.Tool
}
}

-        protected virtual void WalkSerializingFA( IList lines, State s )
+        protected virtual void WalkSerializingFA( IList<string> lines, State s )
{
if ( markedStates.Contains( s ) )
{
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index 9c70a27..72ee39e 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -1,5 +1,5 @@
﻿/*
- * [The "BSD licence"]
+ * [The "BSD license"]
* Copyright (c) 2011 Terence Parr
* All rights reserved.
*
@@ -48,8 +48,6 @@ namespace Antlr3.Tool
using DateTime = System.DateTime;
using Exception = System.Exception;
using File = System.IO.File;
-    using IDictionary = System.Collections.IDictionary;
-    using IList = System.Collections.IList;
using IOException = System.IO.IOException;
using IToken = Antlr.Runtime.IToken;
using ITree = Antlr.Runtime.Tree.ITree;
@@ -1244,9 +1242,9 @@ namespace Antlr3.Tool
if ( actions.get( "lexer" ) != null )
{
LexerGrammarST.SetAttribute( "actionNames",
-                                            ( (IDictionary)actions.get( "lexer" ) ).Keys );
+                                            ( actions.get( "lexer" ) ).Keys );
LexerGrammarST.SetAttribute( "actions",
-                                            ( (IDictionary)actions.get( "lexer" ) ).Values );
+                                            ( actions.get( "lexer" ) ).Values );
}
// make sure generated grammar has the same options
if ( options != null )
@@ -1498,12 +1496,12 @@ namespace Antlr3.Tool
NFAState ruleBeginState = factory.NewState();
ruleBeginState.Description = "rule " + ruleName + " start";
ruleBeginState.enclosingRule = r;
-                r.startState = ruleBeginState;
+                r.StartState = ruleBeginState;
NFAState ruleEndState = factory.NewState();
ruleEndState.Description = "rule " + ruleName + " end";
ruleEndState.IsAcceptState = true;
ruleEndState.enclosingRule = r;
-                r.stopState = ruleEndState;
+                r.StopState = ruleEndState;
}
}

@@ -1594,7 +1592,7 @@ namespace Antlr3.Tool
if ( !externalAnalysisAbort && decisionStartState.NumberOfTransitions > 1 )
{
Rule r = decisionStartState.enclosingRule;
-                        if ( r.isSynPred && !synPredNamesUsedInDFA.Contains( r.Name ) )
+                        if ( r.IsSynPred && !synPredNamesUsedInDFA.Contains( r.Name ) )
{
continue;
}
@@ -1684,7 +1682,7 @@ namespace Antlr3.Tool
decisionStartState.Description );
}

-            if ( r.isSynPred && !synPredNamesUsedInDFA.Contains( enclosingRule ) )
+            if ( r.IsSynPred && !synPredNamesUsedInDFA.Contains( enclosingRule ) )
{
return null;
}
@@ -2025,17 +2023,17 @@ namespace Antlr3.Tool
JSystem.@out.println("defineRule("+ruleName+",modifier="+modifier+
"): index="+r.index+", nalts="+numAlts);
*/
-            r.modifier = modifier ?? DefaultRuleModifier;
+            r.Modifier = modifier ?? DefaultRuleModifier;
nameToRuleMap[ruleName] = r;
SetRuleAST( ruleName, tree );
r.SetOptions( options, ruleToken );
-            r.argActionAST = argActionAST;
+            r.ArgActionAST = argActionAST;
composite.ruleIndexToRuleList.setSize( composite.ruleIndex + 1 );
composite.ruleIndexToRuleList[composite.ruleIndex] = r;
composite.ruleIndex++;
if ( ruleName.StartsWith( SynpredRulePrefix ) )
{
-                r.isSynPred = true;
+                r.IsSynPred = true;
}
}

@@ -2291,7 +2289,7 @@ namespace Antlr3.Tool
Rule r = GetRule( scopeName, ruleName );
if ( r != null )
{
-                return r.index;
+                return r.Index;
}
return InvalidRuleIndex;
}
@@ -2331,8 +2329,8 @@ namespace Antlr3.Tool
}
// generate if non-synpred or synpred used in a DFA
Rule r = GetLocallyDefinedRule( ruleName );
-            return !r.isSynPred ||
-                   ( r.isSynPred && synPredNamesUsedInDFA.Contains( ruleName ) );
+            return !r.IsSynPred ||
+                   ( r.IsSynPred && synPredNamesUsedInDFA.Contains( ruleName ) );
}

public virtual AttributeScope DefineGlobalScope( string name, IToken scopeAction )
@@ -2644,7 +2642,7 @@ namespace Antlr3.Tool
// indicate that an action ref'd an attr unless it's in a lexer
// so that $ID.text refs don't force lexer rules to define
// return values...Token objects are created by the caller instead.
-                r.referencedPredefinedRuleAttributes = true;
+                r.ReferencedPredefinedRuleAttributes = true;
}
}

@@ -3326,7 +3324,7 @@ namespace Antlr3.Tool
Rule r = GetLocallyDefinedRule( ruleName );
if ( r != null )
{
-                r.tree = t;
+                r.Tree = t;
r.EORNode = t.LastChild;
}
}
@@ -3342,7 +3340,7 @@ namespace Antlr3.Tool
if ( r != null )
{
//JSystem.@out.println("getRuleStartState("+scopeName+", "+ruleName+")="+r.startState);
-                return r.startState;
+                return r.StartState;
}
//JSystem.@out.println("getRuleStartState("+scopeName+", "+ruleName+")=null");
return null;
@@ -3353,7 +3351,7 @@ namespace Antlr3.Tool
Rule r = GetRule( ruleName );
if ( r != null )
{
-                return r.modifier;
+                return r.Modifier;
}
return null;
}
@@ -3363,7 +3361,7 @@ namespace Antlr3.Tool
Rule r = GetRule( ruleName );
if ( r != null )
{
-                return r.stopState;
+                return r.StopState;
}
return null;
}
@@ -3645,7 +3643,7 @@ namespace Antlr3.Tool
}
IIntSet elements = null;
//JSystem.@out.println("parsed tree: "+r.tree.toStringTree());
-            elements = nfabuilder.SetRule( r.tree );
+            elements = nfabuilder.SetRule( r.Tree );
//JSystem.@out.println("elements="+elements);
return elements;
}
diff --git a/Antlr3/Tool/GrammarNonDeterminismMessage.cs b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
index b5d5d37..d8c1ef4 100644
--- a/Antlr3/Tool/GrammarNonDeterminismMessage.cs
+++ b/Antlr3/Tool/GrammarNonDeterminismMessage.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -32,9 +32,10 @@

namespace Antlr3.Tool
{
+    using System.Collections.Generic;
+
using DecisionProbe = Antlr3.Analysis.DecisionProbe;
using DFAState = Antlr3.Analysis.DFAState;
-    using IList = System.Collections.IList;
using NFAState = Antlr3.Analysis.NFAState;
using StringTemplate = Antlr3.ST.StringTemplate;

@@ -112,7 +113,7 @@ namespace Antlr3.Tool
{
firstAlt = tracePathAlt;
}
-                        IList path =
+                        IList<NFAState> path =
probe.GetNFAPathStatesForAlt( firstAlt,
tracePathAlt,
labels );
diff --git a/Antlr3/Tool/GrammarReport.cs b/Antlr3/Tool/GrammarReport.cs
index 115be6a..9852f15 100644
--- a/Antlr3/Tool/GrammarReport.cs
+++ b/Antlr3/Tool/GrammarReport.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -32,17 +32,16 @@

namespace Antlr3.Tool
{
+    using System;
using System.Collections.Generic;
using System.Linq;
+    using System.Reflection;
using Antlr.Runtime.JavaExtensions;
+    using Antlr3.Grammars;

using DFA = Antlr3.Analysis.DFA;
-    using Stats = Antlr.Runtime.Misc.Stats;
using StringBuilder = System.Text.StringBuilder;
using StringComparison = System.StringComparison;
-    using System.Reflection;
-    using System;
-    using Antlr3.Grammars;

public class GrammarReport
{
@@ -99,7 +98,7 @@ namespace Antlr3.Tool
Rule r = (Rule)it.next();
if (!r.Name.StartsWith(Grammar.SynpredRulePrefix, StringComparison.OrdinalIgnoreCase))
{
-                    totalNonSynPredProductions += r.numberOfAlts;
+                    totalNonSynPredProductions += r.NumberOfAlts;
totalNonSynPredRules++;
}
}
diff --git a/Antlr3/Tool/GrammarReport2.cs b/Antlr3/Tool/GrammarReport2.cs
index 0d00557..13c76ff 100644
--- a/Antlr3/Tool/GrammarReport2.cs
+++ b/Antlr3/Tool/GrammarReport2.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -65,7 +65,7 @@ namespace Antlr3.Tool
}
int k = d.dfa.MaxLookaheadDepth;
Rule enclosingRule = d.dfa.NFADecisionStartState.enclosingRule;
-                if (enclosingRule.isSynPred)
+                if (enclosingRule.IsSynPred)
continue; // don't count synpred rules
buf.Append(g.name + "." + enclosingRule.Name + ":" +
"");
diff --git a/Antlr3/Tool/GrammarSanity.cs b/Antlr3/Tool/GrammarSanity.cs
index 66f3c2a..8f93811 100644
--- a/Antlr3/Tool/GrammarSanity.cs
+++ b/Antlr3/Tool/GrammarSanity.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -72,7 +72,7 @@ namespace Antlr3.Tool
visitedDuringRecursionCheck = new HashSet<Rule>();
visitedDuringRecursionCheck.Add( r );
HashSet<object> visitedStates = new HashSet<object>();
-                    TraceStatesLookingForLeftRecursion( r.startState,
+                    TraceStatesLookingForLeftRecursion( r.StartState,
visitedStates,
listOfRecursiveCycles );
}
@@ -213,7 +213,7 @@ namespace Antlr3.Tool
if ( argsAST != null )
{
// rule[args]; ref has args
-                    if ( r != null && r.argActionAST == null )
+                    if ( r != null && r.ArgActionAST == null )
{
// but rule def has no args
ErrorManager.GrammarError(
@@ -226,7 +226,7 @@ namespace Antlr3.Tool
else
{
// rule ref has no args
-                    if ( r != null && r.argActionAST != null )
+                    if ( r != null && r.ArgActionAST != null )
{
// but rule def has args
ErrorManager.GrammarError(
@@ -255,7 +255,7 @@ namespace Antlr3.Tool
if ( argsAST != null )
{
// tokenRef[args]; ref has args
-                    if ( r != null && r.argActionAST == null )
+                    if ( r != null && r.ArgActionAST == null )
{
// but token rule def has no args
ErrorManager.GrammarError(
@@ -268,7 +268,7 @@ namespace Antlr3.Tool
else
{
// token ref has no args
-                    if ( r != null && r.argActionAST != null )
+                    if ( r != null && r.ArgActionAST != null )
{
// but token rule def has args
ErrorManager.GrammarError(
diff --git a/Antlr3/Tool/NFAFactory.cs b/Antlr3/Tool/NFAFactory.cs
index 3f70fa7..1591d3a 100644
--- a/Antlr3/Tool/NFAFactory.cs
+++ b/Antlr3/Tool/NFAFactory.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -34,13 +34,10 @@ namespace Antlr3.Tool
{
using System.Collections.Generic;
using System.Linq;
-    using Antlr.Runtime.JavaExtensions;
using Antlr3.Analysis;

using IIntSet = Antlr3.Misc.IIntSet;
-    using IList = System.Collections.IList;
using IntervalSet = Antlr3.Misc.IntervalSet;
-    using Obsolete = System.ObsoleteAttribute;
using StringBuilder = System.Text.StringBuilder;
using StringComparison = System.StringComparison;

@@ -331,7 +328,7 @@ namespace Antlr3.Tool
int numberUnInvokedRules = 0;
foreach ( Rule r in rules )
{
-                NFAState endNFAState = r.stopState;
+                NFAState endNFAState = r.StopState;
// Is this rule a start symbol?  (no follow links)
if ( endNFAState.transition[0] == null )
{
diff --git a/Antlr3/Tool/NameSpaceChecker.cs b/Antlr3/Tool/NameSpaceChecker.cs
index 7ee7819..4311419 100644
--- a/Antlr3/Tool/NameSpaceChecker.cs
+++ b/Antlr3/Tool/NameSpaceChecker.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -58,17 +58,17 @@ namespace Antlr3.Tool
continue;
}
// walk all labels for Rule r
-                if ( r.labelNameSpace != null )
+                if ( r.LabelNameSpace != null )
{
-                    foreach ( Grammar.LabelElementPair pair in r.labelNameSpace.Values )
+                    foreach ( Grammar.LabelElementPair pair in r.LabelNameSpace.Values )
{
CheckForLabelConflict( r, pair.label );
}
}
// walk rule scope attributes for Rule r
-                if ( r.ruleScope != null )
+                if ( r.RuleScope != null )
{
-                    var attributes = r.ruleScope.Attributes;
+                    var attributes = r.RuleScope.Attributes;
for ( int j = 0; j < attributes.Count; j++ )
{
Attribute attribute = (Attribute)attributes.ElementAt( j );
@@ -89,9 +89,9 @@ namespace Antlr3.Tool

protected virtual void CheckForRuleArgumentAndReturnValueConflicts( Rule r )
{
-            if ( r.returnScope != null )
+            if ( r.ReturnScope != null )
{
-                HashSet<object> conflictingKeys = r.returnScope.Intersection( r.parameterScope );
+                HashSet<object> conflictingKeys = r.ReturnScope.Intersection( r.ParameterScope );
if ( conflictingKeys != null )
{
foreach ( string key in conflictingKeys )
@@ -99,7 +99,7 @@ namespace Antlr3.Tool
ErrorManager.GrammarError(
ErrorManager.MSG_ARG_RETVAL_CONFLICT,
grammar,
-                            r.tree.Token,
+                            r.Tree.Token,
key,
r.Name );
}
@@ -110,7 +110,7 @@ namespace Antlr3.Tool
protected virtual void CheckForRuleDefinitionProblems( Rule r )
{
string ruleName = r.Name;
-            IToken ruleToken = r.tree.Token;
+            IToken ruleToken = r.Tree.Token;
int msgID = 0;
if ( ( grammar.type == GrammarType.Parser || grammar.type == GrammarType.TreeParser ) &&
Rule.GetRuleType(ruleName) == RuleType.Lexer)
@@ -119,7 +119,7 @@ namespace Antlr3.Tool
}
else if ( grammar.type == GrammarType.Lexer &&
Rule.GetRuleType(ruleName) == RuleType.Parser &&
-                      !r.isSynPred )
+                      !r.IsSynPred )
{
msgID = ErrorManager.MSG_PARSER_RULES_NOT_ALLOWED;
}
@@ -152,7 +152,7 @@ namespace Antlr3.Tool
if ( localRule == null && rule != null )
{ // imported rule?
grammar.delegatedRuleReferences.Add( rule );
-                    rule.imported = true;
+                    rule.Imported = true;
}
if ( rule == null && grammar.GetTokenType( ruleName ) != Label.EOF )
{
@@ -231,15 +231,15 @@ namespace Antlr3.Tool
msgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE;
arg2 = r.Name;
}
-            else if ( ( r.returnScope != null && r.returnScope.GetAttribute( attrName ) != null ) ||
-                      ( r.parameterScope != null && r.parameterScope.GetAttribute( attrName ) != null ) )
+            else if ( ( r.ReturnScope != null && r.ReturnScope.GetAttribute( attrName ) != null ) ||
+                      ( r.ParameterScope != null && r.ParameterScope.GetAttribute( attrName ) != null ) )
{
msgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL;
arg2 = r.Name;
}
if ( msgID != 0 )
{
-                ErrorManager.GrammarError( msgID, grammar, r.tree.Token, attrName, arg2 );
+                ErrorManager.GrammarError( msgID, grammar, r.Tree.Token, attrName, arg2 );
}
}

@@ -264,13 +264,13 @@ namespace Antlr3.Tool
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_TOKEN;
}
-            else if ( r.ruleScope != null && r.ruleScope.GetAttribute( label.Text ) != null )
+            else if ( r.RuleScope != null && r.RuleScope.GetAttribute( label.Text ) != null )
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE;
arg2 = r.Name;
}
-            else if ( ( r.returnScope != null && r.returnScope.GetAttribute( label.Text ) != null ) ||
-                      ( r.parameterScope != null && r.parameterScope.GetAttribute( label.Text ) != null ) )
+            else if ( ( r.ReturnScope != null && r.ReturnScope.GetAttribute( label.Text ) != null ) ||
+                      ( r.ParameterScope != null && r.ParameterScope.GetAttribute( label.Text ) != null ) )
{
msgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL;
arg2 = r.Name;
@@ -286,7 +286,7 @@ namespace Antlr3.Tool
public virtual bool CheckForLabelTypeMismatch( Rule r, IToken label, LabelType type )
{
Grammar.LabelElementPair prevLabelPair =
-                (Grammar.LabelElementPair)r.labelNameSpace.get( label.Text );
+                (Grammar.LabelElementPair)r.LabelNameSpace.get( label.Text );
if ( prevLabelPair != null )
{
// label already defined; if same type, no problem
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index a40a600..d033a99 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -1,10 +1,10 @@
﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -38,26 +38,24 @@ namespace Antlr3.Tool

using ANTLRParser = Antlr3.Grammars.ANTLRParser;
using ArgumentException = System.ArgumentException;
-    using CLSCompliant = System.CLSCompliantAttribute;
using CodeGenerator = Antlr3.Codegen.CodeGenerator;
using CommonToken = Antlr.Runtime.CommonToken;
-    using IDictionary = System.Collections.IDictionary;
-    using IList = System.Collections.IList;
using IToken = Antlr.Runtime.IToken;
-    using LookaheadSet = Antlr3.Analysis.LookaheadSet;
using NFAState = Antlr3.Analysis.NFAState;

/** Combine the info associated with a rule. */
public class Rule
{
private readonly string _name;
-        public int index;
-        public string modifier;
-        public NFAState startState;
-        public NFAState stopState;
+        private int _index;
+        private string _modifier;
+        private NFAState _startState;
+        private NFAState _stopState;

-        /** This rule's options */
-        protected IDictionary options;
+        /// <summary>
+        /// This rule's options.
+        /// </summary>
+        private IDictionary<object, object> _options;

public static readonly HashSet<string> legalOptions = new HashSet<string>()
{
@@ -67,195 +65,544 @@ namespace Antlr3.Tool
"backtrack"
};

-        /** The AST representing the whole rule */
-        public GrammarAST tree;
+        /// <summary>
+        /// The AST representing the whole rule.
+        /// </summary>
+        private GrammarAST _tree;
+
+        /// <summary>
+        /// To which grammar does this belong?
+        /// </summary>
+        private Grammar _grammar;
+
+        /// <summary>
+        /// For convenience, track the argument def AST action node if any.
+        /// </summary>
+        private GrammarAST _argActionAST;
+
+        private GrammarAST _endOfRuleNode;
+
+        /// <summary>
+        /// The return values of a rule and predefined rule attributes.
+        /// </summary>
+        private AttributeScope _returnScope;
+
+        private AttributeScope _parameterScope;
+
+        /// <summary>
+        /// the attributes defined with "scope {...}" inside a rule
+        /// </summary>
+        private AttributeScope _ruleScope;
+
+        /// <summary>
+        /// A list of scope names used by this rule
+        /// </summary>
+        private List<string> _useScopes;
+
+        /// <summary>
+        /// Exceptions that this rule can throw
+        /// </summary>
+        private HashSet<string> _throwsSpec;
+
+        /// <summary>
+        /// A list of all LabelElementPair attached to tokens like id=ID
+        /// </summary>
+        private Dictionary<string, Grammar.LabelElementPair> _tokenLabels;
+
+        /// <summary>
+        /// A list of all LabelElementPair attached to tokens like x=. in tree grammar
+        /// </summary>
+        private Dictionary<string, Grammar.LabelElementPair> _wildcardTreeLabels;
+
+        /// <summary>
+        /// A list of all LabelElementPair attached to tokens like x+=. in tree grammar
+        /// </summary>
+        private Dictionary<string, Grammar.LabelElementPair> _wildcardTreeListLabels;
+
+        /// <summary>
+        /// A list of all LabelElementPair attached to single char literals like x='a'
+        /// </summary>
+        private Dictionary<string, Grammar.LabelElementPair> _charLabels;
+
+        /// <summary>
+        /// A list of all LabelElementPair attached to char literals like x+='a'
+        /// </summary>
+        private Dictionary<string, Grammar.LabelElementPair> _charListLabels;
+
+        /// <summary>
+        /// A list of all LabelElementPair attached to rule references like f=field
+        /// </summary>
+        private Dictionary<string, Grammar.LabelElementPair> _ruleLabels;
+
+        /// <summary>
+        /// A list of all Token list LabelElementPair like ids+=ID
+        /// </summary>
+        private Dictionary<string, Grammar.LabelElementPair> _tokenListLabels;
+
+        /// <summary>
+        /// A list of all rule ref list LabelElementPair like ids+=expr
+        /// </summary>
+        private Dictionary<string, Grammar.LabelElementPair> _ruleListLabels;
+
+        /// <summary>
+        /// All labels go in here (plus being split per the above lists) to
+        /// catch dup label and label type mismatches.
+        /// </summary>
+        private  IDictionary<string, Grammar.LabelElementPair> _labelNameSpace =
+            new Dictionary<string, Grammar.LabelElementPair>();

-        /** To which grammar does this belong? */
-        public Grammar grammar;
+        /// <summary>
+        /// Map a name to an action for this rule.  Currently init is only
+        /// one we use, but we can add more in future.
+        /// The code generator will use this to fill holes in the rule template.
+        /// I track the AST node for the action in case I need the line number
+        /// for errors.  A better name is probably namedActions, but I don't
+        /// want everyone to have to change their code gen templates now.
+        /// </summary>
+        private readonly IDictionary<string, object> _actions = new Dictionary<string, object>();
+
+        /// <summary>
+        /// Track all executable actions other than named actions like @init.
+        /// Also tracks exception handlers, predicates, and rewrite rewrites.
+        /// We need to examine these actions before code generation so
+        /// that we can detect refs to $rule.attr etc...
+        /// </summary>
+        private readonly IList<GrammarAST> _inlineActions = new List<GrammarAST>();
+
+        private readonly int _numberOfAlts;
+
+        /// <summary>
+        /// Each alt has a Map&lt;tokenRefName,List&lt;tokenRefAST&gt;&gt;; range 1..numberOfAlts.
+        /// So, if there are 3 ID refs in a rule's alt number 2, you'll have
+        /// altToTokenRef[2].get("ID").size()==3.  This is used to see if $ID is ok.
+        /// There must be only one ID reference in the alt for $ID to be ok in
+        /// an action--must be unique.
+        ///
+        /// This also tracks '+' and "int" literal token references
+        /// (if not in LEXER).
+        ///
+        /// Rewrite rules force tracking of all tokens.
+        /// </summary>
+        private IDictionary<string, IList<GrammarAST>>[] _altToTokenRefMap;
+
+        /// <summary>
+        /// Each alt has a Map&lt;ruleRefName,List&lt;ruleRefAST&gt;&gt;; range 1..numberOfAlts
+        /// So, if there are 3 expr refs in a rule's alt number 2, you'll have
+        /// altToRuleRef[2].get("expr").size()==3.  This is used to see if $expr is ok.
+        /// There must be only one expr reference in the alt for $expr to be ok in
+        /// an action--must be unique.
+        ///
+        /// Rewrite rules force tracking of all rule result ASTs. 1..n
+        /// </summary>
+        private IDictionary<string, IList<GrammarAST>>[] _altToRuleRefMap;
+
+        /// <summary>
+        /// Do not generate start, stop etc... in a return value struct unless
+        /// somebody references $r.start somewhere.
+        /// </summary>
+        private bool _referencedPredefinedRuleAttributes = false;
+
+        private bool _isSynPred = false;
+
+        private bool _imported = false;

-        /** For convenience, track the argument def AST action node if any */
-        public GrammarAST argActionAST;
+        public Rule( Grammar grammar,
+                    string ruleName,
+                    int ruleIndex,
+                    int numberOfAlts )
+        {
+            this._name = ruleName;
+            this._index = ruleIndex;
+            this._numberOfAlts = numberOfAlts;
+            this._grammar = grammar;
+            _throwsSpec = new HashSet<string>() { "RecognitionException" };
+            _altToTokenRefMap = new IDictionary<string, IList<GrammarAST>>[numberOfAlts + 1]; //new Map[numberOfAlts + 1];
+            _altToRuleRefMap = new IDictionary<string, IList<GrammarAST>>[numberOfAlts + 1]; //new Map[numberOfAlts + 1];
+            for ( int alt = 1; alt <= numberOfAlts; alt++ )
+            {
+                _altToTokenRefMap[alt] = new Dictionary<string, IList<GrammarAST>>();
+                _altToRuleRefMap[alt] = new Dictionary<string, IList<GrammarAST>>();
+            }
+        }

-        public GrammarAST EORNode;
+        #region Properties

-        /** The return values of a rule and predefined rule attributes */
-        public AttributeScope returnScope;
+        public int Index
+        {
+            get
+            {
+                return _index;
+            }

-        public AttributeScope parameterScope;
+            set
+            {
+                _index = value;
+            }
+        }

-        /** the attributes defined with "scope {...}" inside a rule */
-        public AttributeScope ruleScope;
+        public NFAState StartState
+        {
+            get
+            {
+                return _startState;
+            }

-        /** A list of scope names used by this rule */
-        public List<string> useScopes;
+            set
+            {
+                _startState = value;
+            }
+        }

-        /** Exceptions that this rule can throw */
-        public HashSet<string> throwsSpec;
+        public NFAState StopState
+        {
+            get
+            {
+                return _stopState;
+            }

-        /** A list of all LabelElementPair attached to tokens like id=ID */
-        public Dictionary<string, Grammar.LabelElementPair> tokenLabels;
+            set
+            {
+                _stopState = value;
+            }
+        }

-        /** A list of all LabelElementPair attached to tokens like x=. in tree grammar */
-        public Dictionary<string, Grammar.LabelElementPair> wildcardTreeLabels;
+        public GrammarAST EORNode
+        {
+            get
+            {
+                return _endOfRuleNode;
+            }

-        /** A list of all LabelElementPair attached to tokens like x+=. in tree grammar */
-        public Dictionary<string, Grammar.LabelElementPair> wildcardTreeListLabels;
+            set
+            {
+                _endOfRuleNode = value;
+            }
+        }

-        /** A list of all LabelElementPair attached to single char literals like x='a' */
-        public Dictionary<string, Grammar.LabelElementPair> charLabels;
+        public IDictionary<string, object> Actions
+        {
+            get
+            {
+                return _actions;
+            }
+        }

-        /** A list of all LabelElementPair attached to char literals like x+='a' */
-        public Dictionary<string, Grammar.LabelElementPair> charListLabels;
+        public bool HasMultipleReturnValues
+        {
+            get
+            {
+                return GetHasMultipleReturnValues();
+            }
+        }

-        /** A list of all LabelElementPair attached to rule references like f=field */
-        public Dictionary<string, Grammar.LabelElementPair> ruleLabels;
+        public bool HasReturnValue
+        {
+            get
+            {
+                return GetHasReturnValue();
+            }
+        }

-        /** A list of all Token list LabelElementPair like ids+=ID */
-        public Dictionary<string, Grammar.LabelElementPair> tokenListLabels;
+        public bool HasSingleReturnValue
+        {
+            get
+            {
+                return GetHasSingleReturnValue();
+            }
+        }

-        /** A list of all rule ref list LabelElementPair like ids+=expr */
-        public Dictionary<string, Grammar.LabelElementPair> ruleListLabels;
+        protected internal IDictionary<string, Grammar.LabelElementPair> LabelNameSpace
+        {
+            get
+            {
+                return _labelNameSpace;
+            }

-        /** All labels go in here (plus being split per the above lists) to
-         *  catch dup label and label type mismatches.
-         */
-        protected internal IDictionary<string, Grammar.LabelElementPair> labelNameSpace =
-            new Dictionary<string, Grammar.LabelElementPair>();
+            set
+            {
+                _labelNameSpace = value;
+            }
+        }

-        /** Map a name to an action for this rule.  Currently init is only
-         *  one we use, but we can add more in future.
-         *  The code generator will use this to fill holes in the rule template.
-         *  I track the AST node for the action in case I need the line number
-         *  for errors.  A better name is probably namedActions, but I don't
-         *  want everyone to have to change their code gen templates now.
-         */
-        private IDictionary<string, object> actions = new Dictionary<string, object>();
+        public bool Imported
+        {
+            get
+            {
+                return _imported;
+            }

-        /** Track all executable actions other than named actions like @init.
-         *  Also tracks exception handlers, predicates, and rewrite rewrites.
-         *  We need to examine these actions before code generation so
-         *  that we can detect refs to $rule.attr etc...
-         */
-        private IList<GrammarAST> inlineActions = new List<GrammarAST>();
+            set
+            {
+                _imported = value;
+            }
+        }

-        public int numberOfAlts;
+        public ICollection<GrammarAST> InlineActions
+        {
+            get
+            {
+                return _inlineActions;
+            }
+        }

-        /** Each alt has a Map&lt;tokenRefName,List&lt;tokenRefAST&gt;&gt;; range 1..numberOfAlts.
-         *  So, if there are 3 ID refs in a rule's alt number 2, you'll have
-         *  altToTokenRef[2].get("ID").size()==3.  This is used to see if $ID is ok.
-         *  There must be only one ID reference in the alt for $ID to be ok in
-         *  an action--must be unique.
-         *
-         *  This also tracks '+' and "int" literal token references
-         *  (if not in LEXER).
-         *
-         *  Rewrite rules force tracking of all tokens.
-         */
-        private IDictionary<string, IList<GrammarAST>>[] altToTokenRefMap;
+        public bool IsSynPred
+        {
+            get
+            {
+                return _isSynPred;
+            }

-        /** Each alt has a Map&lt;ruleRefName,List&lt;ruleRefAST&gt;&gt;; range 1..numberOfAlts
-         *  So, if there are 3 expr refs in a rule's alt number 2, you'll have
-         *  altToRuleRef[2].get("expr").size()==3.  This is used to see if $expr is ok.
-         *  There must be only one expr reference in the alt for $expr to be ok in
-         *  an action--must be unique.
-         *
-         *  Rewrite rules force tracking of all rule result ASTs. 1..n
-         */
-        private IDictionary<string, IList<GrammarAST>>[] altToRuleRefMap;
+            set
+            {
+                _isSynPred = value;
+            }
+        }

-        /** Do not generate start, stop etc... in a return value struct unless
-         *  somebody references $r.start somewhere.
-         */
-        public bool referencedPredefinedRuleAttributes = false;
+        public string Modifier
+        {
+            get
+            {
+                return _modifier;
+            }

-        public bool isSynPred = false;
+            set
+            {
+                _modifier = value;
+            }
+        }

-        public bool imported = false;
+        public string Name
+        {
+            get
+            {
+                return _name;
+            }
+        }

-        public Rule( Grammar grammar,
-                    string ruleName,
-                    int ruleIndex,
-                    int numberOfAlts )
+        public int NumberOfAlts
{
-            this._name = ruleName;
-            this.index = ruleIndex;
-            this.numberOfAlts = numberOfAlts;
-            this.grammar = grammar;
-            throwsSpec = new HashSet<string>() { "RecognitionException" };
-            altToTokenRefMap = new IDictionary<string, IList<GrammarAST>>[numberOfAlts + 1]; //new Map[numberOfAlts + 1];
-            altToRuleRefMap = new IDictionary<string, IList<GrammarAST>>[numberOfAlts + 1]; //new Map[numberOfAlts + 1];
-            for ( int alt = 1; alt <= numberOfAlts; alt++ )
+            get
{
-                altToTokenRefMap[alt] = new Dictionary<string, IList<GrammarAST>>();
-                altToRuleRefMap[alt] = new Dictionary<string, IList<GrammarAST>>();
+                return _numberOfAlts;
}
}

-        #region Properties
+        public bool ReferencedPredefinedRuleAttributes
+        {
+            get
+            {
+                return _referencedPredefinedRuleAttributes;
+            }

-        public IDictionary<string, object> Actions
+            set
+            {
+                _referencedPredefinedRuleAttributes = value;
+            }
+        }
+
+        public IDictionary<string, Grammar.LabelElementPair> RuleLabels
{
get
{
-                return actions;
+                return _ruleLabels;
}
}

-        public bool HasMultipleReturnValues
+        protected IDictionary<object, object> Options
{
get
{
-                return GetHasMultipleReturnValues();
+                return _options;
+            }
+
+            set
+            {
+                _options = value;
}
}

-        public bool HasReturnValue
+        public GrammarAST Tree
{
get
{
-                return GetHasReturnValue();
+                return _tree;
+            }
+
+            set
+            {
+                _tree = value;
}
}

-        public bool HasSingleReturnValue
+        public Grammar Grammar
{
get
{
-                return GetHasSingleReturnValue();
+                return _grammar;
+            }
+
+            set
+            {
+                _grammar = value;
}
}

-        public ICollection<GrammarAST> InlineActions
+        public GrammarAST ArgActionAST
{
get
{
-                return GetInlineActions();
+                return _argActionAST;
+            }
+
+            set
+            {
+                _argActionAST = value;
}
}

-        public string Name
+        public AttributeScope ReturnScope
{
get
{
-                return _name;
+                return _returnScope;
+            }
+
+            set
+            {
+                _returnScope = value;
}
}

-        [CLSCompliant(false)]
-        public IDictionary<string, Grammar.LabelElementPair> RuleLabels
+        public AttributeScope ParameterScope
+        {
+            get
+            {
+                return _parameterScope;
+            }
+
+            set
+            {
+                _parameterScope = value;
+            }
+        }
+
+        public AttributeScope RuleScope
+        {
+            get
+            {
+                return _ruleScope;
+            }
+
+            set
+            {
+                _ruleScope = value;
+            }
+        }
+
+        public List<string> UseScopes
+        {
+            get
+            {
+                return _useScopes;
+            }
+
+            set
+            {
+                _useScopes = value;
+            }
+        }
+
+        public HashSet<string> ThrowsSpec
{
get
{
-                return GetRuleLabels();
+                return _throwsSpec;
+            }
+        }
+
+        public Dictionary<string, Grammar.LabelElementPair> TokenLabels
+        {
+            get
+            {
+                return _tokenLabels;
+            }
+
+            set
+            {
+                _tokenLabels = value;
+            }
+        }
+
+        public Dictionary<string, Grammar.LabelElementPair> WildcardTreeLabels
+        {
+            get
+            {
+                return _wildcardTreeLabels;
+            }
+
+            set
+            {
+                _wildcardTreeLabels = value;
+            }
+        }
+
+        public Dictionary<string, Grammar.LabelElementPair> WildcardTreeListLabels
+        {
+            get
+            {
+                return _wildcardTreeListLabels;
+            }
+
+            set
+            {
+                _wildcardTreeListLabels = value;
+            }
+        }
+
+        public Dictionary<string, Grammar.LabelElementPair> CharLabels
+        {
+            get
+            {
+                return _charLabels;
+            }
+
+            set
+            {
+                _charLabels = value;
+            }
+        }
+
+        public Dictionary<string, Grammar.LabelElementPair> CharListLabels
+        {
+            get
+            {
+                return _charListLabels;
+            }
+
+            set
+            {
+                _charListLabels = value;
+            }
+        }
+
+        public Dictionary<string, Grammar.LabelElementPair> TokenListLabels
+        {
+            get
+            {
+                return _tokenListLabels;
+            }
+
+            set
+            {
+                _tokenListLabels = value;
}
}

-        [CLSCompliant(false)]
public IDictionary<string, Grammar.LabelElementPair> RuleListLabels
{
get
{
-                return GetRuleListLabels();
+                return _ruleListLabels;
}
}

@@ -292,49 +639,49 @@ namespace Antlr3.Tool

public virtual void DefineLabel( IToken label, GrammarAST elementRef, LabelType type )
{
-            Grammar.LabelElementPair pair = new Grammar.LabelElementPair( grammar, label, elementRef );
+            Grammar.LabelElementPair pair = new Grammar.LabelElementPair( Grammar, label, elementRef );
pair.type = type;
-            labelNameSpace[label.Text] = pair;
+            LabelNameSpace[label.Text] = pair;
switch (type)
{
case LabelType.Token:
-                tokenLabels = tokenLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
-                tokenLabels[label.Text] = pair;
+                TokenLabels = TokenLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
+                TokenLabels[label.Text] = pair;
break;

case LabelType.WildcardTree:
-                wildcardTreeLabels = wildcardTreeLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
-                wildcardTreeLabels[label.Text] = pair;
+                WildcardTreeLabels = WildcardTreeLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
+                WildcardTreeLabels[label.Text] = pair;
break;

case LabelType.WildcardTreeList:
-                wildcardTreeListLabels = wildcardTreeListLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
-                wildcardTreeListLabels[label.Text] = pair;
+                WildcardTreeListLabels = WildcardTreeListLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
+                WildcardTreeListLabels[label.Text] = pair;
break;

case LabelType.Rule:
-                ruleLabels = ruleLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
-                ruleLabels[label.Text] = pair;
+                _ruleLabels = _ruleLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
+                _ruleLabels[label.Text] = pair;
break;

case LabelType.TokenList:
-                tokenListLabels = tokenListLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
-                tokenListLabels[label.Text] = pair;
+                TokenListLabels = TokenListLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
+                TokenListLabels[label.Text] = pair;
break;

case LabelType.RuleList:
-                ruleListLabels = ruleListLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
-                ruleListLabels[label.Text] = pair;
+                _ruleListLabels = _ruleListLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
+                _ruleListLabels[label.Text] = pair;
break;

case LabelType.Char:
-                charLabels = charLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
-                charLabels[label.Text] = pair;
+                CharLabels = CharLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
+                CharLabels[label.Text] = pair;
break;

case LabelType.CharList:
-                charListLabels = charListLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
-                charListLabels[label.Text] = pair;
+                CharListLabels = CharListLabels ?? new Dictionary<string, Grammar.LabelElementPair>();
+                CharListLabels[label.Text] = pair;
break;

default:
@@ -345,34 +692,24 @@ namespace Antlr3.Tool
public virtual Grammar.LabelElementPair GetLabel( string name )
{
Grammar.LabelElementPair pair;
-            labelNameSpace.TryGetValue(name, out pair);
+            LabelNameSpace.TryGetValue(name, out pair);
return pair;
}

public virtual Grammar.LabelElementPair GetTokenLabel( string name )
{
Grammar.LabelElementPair pair = null;
-            if (tokenLabels != null)
-                tokenLabels.TryGetValue(name, out pair);
+            if (TokenLabels != null)
+                TokenLabels.TryGetValue(name, out pair);

return pair;
}

-        public virtual IDictionary<string, Grammar.LabelElementPair> GetRuleLabels()
-        {
-            return ruleLabels;
-        }
-
-        public virtual IDictionary<string, Grammar.LabelElementPair> GetRuleListLabels()
-        {
-            return ruleListLabels;
-        }
-
public virtual Grammar.LabelElementPair GetRuleLabel( string name )
{
Grammar.LabelElementPair pair = null;
-            if ( ruleLabels != null )
-                ruleLabels.TryGetValue(name, out pair);
+            if ( RuleLabels != null )
+                RuleLabels.TryGetValue(name, out pair);

return pair;
}
@@ -380,8 +717,8 @@ namespace Antlr3.Tool
public virtual Grammar.LabelElementPair GetTokenListLabel( string name )
{
Grammar.LabelElementPair pair = null;
-            if (tokenListLabels != null)
-                tokenListLabels.TryGetValue(name, out pair);
+            if (TokenListLabels != null)
+                TokenListLabels.TryGetValue(name, out pair);

return pair;
}
@@ -389,8 +726,8 @@ namespace Antlr3.Tool
public virtual Grammar.LabelElementPair GetRuleListLabel( string name )
{
Grammar.LabelElementPair pair = null;
-            if (ruleListLabels != null)
-                ruleListLabels.TryGetValue(name, out pair);
+            if (RuleListLabels != null)
+                RuleListLabels.TryGetValue(name, out pair);

return pair;
}
@@ -403,49 +740,52 @@ namespace Antlr3.Tool
*/
public virtual void TrackTokenReferenceInAlt( GrammarAST refAST, int outerAltNum )
{
-            IList<GrammarAST> refs = altToTokenRefMap[outerAltNum].get( refAST.Text );
+            IList<GrammarAST> refs = _altToTokenRefMap[outerAltNum].get( refAST.Text );
if ( refs == null )
{
refs = new List<GrammarAST>();
-                altToTokenRefMap[outerAltNum][refAST.Text] = refs;
+                _altToTokenRefMap[outerAltNum][refAST.Text] = refs;
}
refs.Add( refAST );
}

-        public virtual IList GetTokenRefsInAlt( string @ref, int outerAltNum )
+        public virtual IList<GrammarAST> GetTokenRefsInAlt( string @ref, int outerAltNum )
{
-            if ( altToTokenRefMap[outerAltNum] != null )
+            if ( _altToTokenRefMap[outerAltNum] != null )
{
-                IList tokenRefASTs = (IList)altToTokenRefMap[outerAltNum].get( @ref );
+                IList<GrammarAST> tokenRefASTs = _altToTokenRefMap[outerAltNum].get( @ref );
return tokenRefASTs;
}
+
return null;
}

public virtual void TrackRuleReferenceInAlt( GrammarAST refAST, int outerAltNum )
{
-            IList<GrammarAST> refs = altToRuleRefMap[outerAltNum].get( refAST.Text );
+            IList<GrammarAST> refs = _altToRuleRefMap[outerAltNum].get( refAST.Text );
if ( refs == null )
{
refs = new List<GrammarAST>();
-                altToRuleRefMap[outerAltNum][refAST.Text] = refs;
+                _altToRuleRefMap[outerAltNum][refAST.Text] = refs;
}
+
refs.Add( refAST );
}

-        public virtual IList GetRuleRefsInAlt( string @ref, int outerAltNum )
+        public virtual IList<GrammarAST> GetRuleRefsInAlt( string @ref, int outerAltNum )
{
-            if ( altToRuleRefMap[outerAltNum] != null )
+            if ( _altToRuleRefMap[outerAltNum] != null )
{
-                IList ruleRefASTs = (IList)altToRuleRefMap[outerAltNum].get( @ref );
+                IList<GrammarAST> ruleRefASTs = _altToRuleRefMap[outerAltNum].get( @ref );
return ruleRefASTs;
}
+
return null;
}

public virtual ICollection<string> GetTokenRefsInAlt( int altNum )
{
-            return altToTokenRefMap[altNum].Keys;
+            return _altToTokenRefMap[altNum].Keys;
}

/** For use with rewrite rules, we must track all tokens matched on the
@@ -455,7 +795,7 @@ namespace Antlr3.Tool
*/
public virtual ICollection<string> GetAllTokenRefsInAltsWithRewrites()
{
-            string output = (string)grammar.GetOption( "output" );
+            string output = (string)Grammar.GetOption( "output" );
ICollection<string> tokens = new HashSet<string>();
if ( output == null || !output.Equals( "AST" ) )
{
@@ -464,15 +804,15 @@ namespace Antlr3.Tool
}

//System.out.println("blk "+tree.findFirstType(ANTLRParser.BLOCK).toStringTree());
-            for (int i = 1; i <= numberOfAlts; i++)
+            for (int i = 1; i <= _numberOfAlts; i++)
{
if ( HasRewrite(i) )
{
-                    foreach ( string tokenName in altToTokenRefMap[i].Keys )
+                    foreach ( string tokenName in _altToTokenRefMap[i].Keys )
{
// convert token name like ID to ID, "void" to 31
-                        int ttype = grammar.GetTokenType( tokenName );
-                        string label = grammar.generator.GetTokenTypeAsTargetLabel( ttype );
+                        int ttype = Grammar.GetTokenType( tokenName );
+                        string label = Grammar.generator.GetTokenTypeAsTargetLabel( ttype );
tokens.Add( label );
}
}
@@ -483,7 +823,7 @@ namespace Antlr3.Tool

public virtual ICollection<string> GetRuleRefsInAlt( int outerAltNum )
{
-            return altToRuleRefMap[outerAltNum].Keys;
+            return _altToRuleRefMap[outerAltNum].Keys;
}

/** For use with rewrite rules, we must track all rule AST results on the
@@ -492,21 +832,16 @@ namespace Antlr3.Tool
*/
public virtual ICollection<string> GetAllRuleRefsInAltsWithRewrites()
{
-            var rules = from i in Enumerable.Range( 1, numberOfAlts )
+            var rules = from i in Enumerable.Range( 1, _numberOfAlts )
where HasRewrite(i)
-                        select altToRuleRefMap[i].Keys;
+                        select _altToRuleRefMap[i].Keys;

return new HashSet<string>( rules.SelectMany( r => r ) );
}

-        public virtual IList<GrammarAST> GetInlineActions()
-        {
-            return inlineActions;
-        }
-
public virtual bool HasRewrite( int i )
{
-            GrammarAST blk = tree.FindFirstType(ANTLRParser.BLOCK);
+            GrammarAST blk = Tree.FindFirstType(ANTLRParser.BLOCK);
GrammarAST alt = blk.GetBlockAlt(i);
GrammarAST rew = (GrammarAST)alt.getNextSibling();
if (rew != null && rew.Type == ANTLRParser.REWRITES)
@@ -526,9 +861,9 @@ namespace Antlr3.Tool
{
return scope;
}
-            if ( ruleScope != null && ruleScope.GetAttribute( name ) != null )
+            if ( RuleScope != null && RuleScope.GetAttribute( name ) != null )
{
-                scope = ruleScope;
+                scope = RuleScope;
}
return scope;
}
@@ -537,18 +872,18 @@ namespace Antlr3.Tool
public virtual AttributeScope GetLocalAttributeScope( string name )
{
AttributeScope scope = null;
-            if ( returnScope != null && returnScope.GetAttribute( name ) != null )
+            if ( ReturnScope != null && ReturnScope.GetAttribute( name ) != null )
{
-                scope = returnScope;
+                scope = ReturnScope;
}
-            else if ( parameterScope != null && parameterScope.GetAttribute( name ) != null )
+            else if ( ParameterScope != null && ParameterScope.GetAttribute( name ) != null )
{
-                scope = parameterScope;
+                scope = ParameterScope;
}
else
{
AttributeScope rulePropertiesScope =
-                    RuleLabelScope.grammarTypeToRulePropertiesScope[(int)grammar.type];
+                    RuleLabelScope.grammarTypeToRulePropertiesScope[(int)Grammar.type];
if ( rulePropertiesScope.GetAttribute( name ) != null )
{
scope = rulePropertiesScope;
@@ -566,18 +901,18 @@ namespace Antlr3.Tool
CodeGenerator generator )
{
GrammarAST uniqueRefAST;
-            if ( grammar.type != GrammarType.Lexer &&
+            if ( Grammar.type != GrammarType.Lexer &&
Rule.GetRuleType(refdSymbol) == RuleType.Lexer )
{
// symbol is a token
-                IList tokenRefs = GetTokenRefsInAlt( refdSymbol, outerAltNum );
-                uniqueRefAST = (GrammarAST)tokenRefs[0];
+                IList<GrammarAST> tokenRefs = GetTokenRefsInAlt( refdSymbol, outerAltNum );
+                uniqueRefAST = tokenRefs[0];
}
else
{
// symbol is a rule
-                IList ruleRefs = GetRuleRefsInAlt( refdSymbol, outerAltNum );
-                uniqueRefAST = (GrammarAST)ruleRefs[0];
+                IList<GrammarAST> ruleRefs = GetRuleRefsInAlt( refdSymbol, outerAltNum );
+                uniqueRefAST = ruleRefs[0];
}
if ( uniqueRefAST.code == null )
{
@@ -597,14 +932,14 @@ namespace Antlr3.Tool
// else create new label
labelName = generator.CreateUniqueLabel( refdSymbol );
CommonToken label = new CommonToken( ANTLRParser.ID, labelName );
-                if ( grammar.type != GrammarType.Lexer &&
+                if ( Grammar.type != GrammarType.Lexer &&
Rule.GetRuleType(refdSymbol) == Tool.RuleType.Lexer )
{
-                    grammar.DefineTokenRefLabel( Name, label, uniqueRefAST );
+                    Grammar.DefineTokenRefLabel( Name, label, uniqueRefAST );
}
else
{
-                    grammar.DefineRuleRefLabel( Name, label, uniqueRefAST );
+                    Grammar.DefineRuleRefLabel( Name, label, uniqueRefAST );
}
uniqueRefAST.code.SetAttribute( "label", labelName );
}
@@ -619,32 +954,32 @@ namespace Antlr3.Tool
public virtual bool GetHasMultipleReturnValues()
{
return
-                referencedPredefinedRuleAttributes || grammar.BuildAST ||
-                grammar.BuildTemplate ||
-                ( returnScope != null && returnScope.Attributes.Count > 1 );
+                _referencedPredefinedRuleAttributes || Grammar.BuildAST ||
+                Grammar.BuildTemplate ||
+                ( ReturnScope != null && ReturnScope.Attributes.Count > 1 );
}

public virtual bool GetHasSingleReturnValue()
{
return
-                !( referencedPredefinedRuleAttributes || grammar.BuildAST ||
-                  grammar.BuildTemplate ) &&
-                                           ( returnScope != null && returnScope.Attributes.Count == 1 );
+                !( _referencedPredefinedRuleAttributes || Grammar.BuildAST ||
+                  Grammar.BuildTemplate ) &&
+                                           ( ReturnScope != null && ReturnScope.Attributes.Count == 1 );
}

public virtual bool GetHasReturnValue()
{
return
-                referencedPredefinedRuleAttributes || grammar.BuildAST ||
-                grammar.BuildTemplate ||
-                ( returnScope != null && returnScope.Attributes.Count > 0 );
+                _referencedPredefinedRuleAttributes || Grammar.BuildAST ||
+                Grammar.BuildTemplate ||
+                ( ReturnScope != null && ReturnScope.Attributes.Count > 0 );
}

public virtual string GetSingleValueReturnType()
{
-            if ( returnScope != null && returnScope.Attributes.Count == 1 )
+            if ( ReturnScope != null && ReturnScope.Attributes.Count == 1 )
{
-                return returnScope.Attributes[0].Type;
+                return ReturnScope.Attributes[0].Type;
//ICollection<Attribute> retvalAttrs = returnScope.attributes.Values;
//return retvalAttrs.First().Type;

@@ -656,9 +991,9 @@ namespace Antlr3.Tool

public virtual string GetSingleValueReturnName()
{
-            if ( returnScope != null && returnScope.Attributes.Count == 1 )
+            if ( ReturnScope != null && ReturnScope.Attributes.Count == 1 )
{
-                return returnScope.Attributes[0].Name;
+                return ReturnScope.Attributes[0].Name;
}
return null;
}
@@ -672,22 +1007,22 @@ namespace Antlr3.Tool
{
//JSystem.@out.println("rule @"+nameAST.getText()+"{"+actionAST.getText()+"}");
string actionName = nameAST.Text;
-            GrammarAST a = (GrammarAST)actions.get( actionName );
+            GrammarAST a = (GrammarAST)_actions.get( actionName );
if ( a != null )
{
ErrorManager.GrammarError(
-                    ErrorManager.MSG_ACTION_REDEFINITION, grammar,
+                    ErrorManager.MSG_ACTION_REDEFINITION, Grammar,
nameAST.Token, nameAST.Text );
}
else
{
-                actions[actionName] = actionAST;
+                _actions[actionName] = actionAST;
}
}

public virtual void TrackInlineAction( GrammarAST actionAST )
{
-            inlineActions.Add( actionAST );
+            _inlineActions.Add( actionAST );
}

/** Save the option key/value pair and process it; return the key
@@ -698,28 +1033,28 @@ namespace Antlr3.Tool
if ( !legalOptions.Contains( key ) )
{
ErrorManager.GrammarError( ErrorManager.MSG_ILLEGAL_OPTION,
-                                          grammar,
+                                          Grammar,
optionsStartToken,
key );
return null;
}
-            if ( options == null )
+            if ( Options == null )
{
-                options = new Dictionary<object, object>();
+                Options = new Dictionary<object, object>();
}
if ( key.Equals( "memoize" ) && value.ToString().Equals( "true" ) )
{
-                grammar.atLeastOneRuleMemoizes = true;
+                Grammar.atLeastOneRuleMemoizes = true;
}
if ( key == "backtrack" && value.ToString() == "true" )
{
-                grammar.composite.GetRootGrammar().atLeastOneBacktrackOption = true;
+                Grammar.composite.GetRootGrammar().atLeastOneBacktrackOption = true;
}
if ( key.Equals( "k" ) )
{
-                grammar.numberOfManualLookaheadOptions++;
+                Grammar.numberOfManualLookaheadOptions++;
}
-            options[key] = value;
+            Options[key] = value;
return key;
}

@@ -727,7 +1062,7 @@ namespace Antlr3.Tool
{
if ( options == null )
{
-                this.options = null;
+                this.Options = null;
return;
}

@@ -760,7 +1095,7 @@ namespace Antlr3.Tool
public override string ToString()
{
// used for testing
-            return "[" + grammar.name + "." + Name + ",index=" + index + ",line=" + tree.Token.Line + "]";
+            return "[" + Grammar.name + "." + Name + ",index=" + Index + ",line=" + Tree.Token.Line + "]";
}
}
}
diff --git a/Antlr3/Tool/RuleLabelScope.cs b/Antlr3/Tool/RuleLabelScope.cs
index 352e9a0..d128806 100644
--- a/Antlr3/Tool/RuleLabelScope.cs
+++ b/Antlr3/Tool/RuleLabelScope.cs
@@ -1,10 +1,10 @@
/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
* All rights reserved.
*
* Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
@@ -108,9 +108,9 @@ namespace Antlr3.Tool
return rulePropertiesScope.GetAttribute( name );
}

-            if ( referencedRule.returnScope != null )
+            if ( referencedRule.ReturnScope != null )
{
-                return referencedRule.returnScope.GetAttribute( name );
+                return referencedRule.ReturnScope.GetAttribute( name );
}
return null;
}

