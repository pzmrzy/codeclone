commit 6a09f71406e98c1ce1e7aab578c4a97963012d25
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun May 15 13:37:55 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun May 15 13:37:55 2011 -0800

(C# 3) Updated bootstrap binaries

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8519]

diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index 8eee085..97f1fa4 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll b/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll
new file mode 100644
index 0000000..8847a6c
Binary files /dev/null and b/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index b9c23d1..abad749 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index bb9d9d9..cfc3653 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll
index 996485a..31d4d9b 100644
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll and b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll differ
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.dll b/bin/Bootstrap/Antlr4.StringTemplate.dll
index e3a3795..4136dcd 100644
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.dll and b/bin/Bootstrap/Antlr4.StringTemplate.dll differ
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
index 9e64bb5..c907436 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
new file mode 100644
index 0000000..35fdebd
--- /dev/null
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
@@ -0,0 +1,432 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+
+<if(!TREE_PARSER)>
+<! tree parser would already have imported !>
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
+<endif>
+>>
+
+@genericParser.members() ::= <<
+<@super.members()>
+<parserMembers()>
+>>
+
+parserCtorBody() ::= <%
+<super.parserCtorBody()><\n>
+TreeAdaptor =
+<if(actions.(actionScope).treeAdaptorInitializer)>
+	<actions.(actionScope).treeAdaptorInitializer>
+<else>
+	new <actions.(actionScope).treeAdaptorType; null="CommonTreeAdaptor">()
+<end>
+;
+%>
+
+/** Add an adaptor property that knows how to build trees */
+parserMembers() ::= <<
+private <treeAdaptorType()> adaptor;
+
+public <treeAdaptorType()> TreeAdaptor
+{
+	get
+	{
+		return adaptor;
+	}
+
+	set
+	{
+		this.adaptor = value;
+		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+	}
+}
+>>
+
+treeAdaptorType() ::= <<
+<actions.(actionScope).treeAdaptorType; null="ITreeAdaptor">
+>>
+
+ruleReturnBaseType() ::= <%
+Ast<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<ASTLabelType>, <labelType>>
+%>
+
+/** Add a variable to track rule's return AST */
+ruleDeclarations() ::= <<
+<super.ruleDeclarations()>
+<ASTLabelType> root_0 = default(<ASTLabelType>);<\n>
+>>
+
+ruleLabelDefs() ::= <<
+<super.ruleLabelDefs()>
+<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
+	:{it|<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
+<ruleDescriptor.tokenListLabels:{it|<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
+<ruleDescriptor.allTokenRefsInAltsWithRewrites
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
+<ruleDescriptor.allRuleRefsInAltsWithRewrites
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
+>>
+
+/** When doing auto AST construction, we must define some variables;
+ *  These should be turned off if doing rewrites.  This must be a "mode"
+ *  as a rule could have both rewrite and AST within the same alternative
+ *  block.
+ */
+@alt.declarations() ::= <<
+<if(autoAST)>
+<if(outerAlt)>
+<if(!rewriteMode)>
+root_0 = (<ASTLabelType>)adaptor.Nil();
+<endif>
+<endif>
+<endif>
+>>
+
+// T r a c k i n g  R u l e  E l e m e n t s
+
+/** ID and track it for use in a rewrite rule */
+tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRefBang(...)> <! Track implies no auto AST construction!>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
+>>
+
+/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
+ *  to the tracking list stream_ID for use in the rewrite.
+ */
+tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRefTrack(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** ^(ID ...) track for rewrite */
+tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRefBang(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
+>>
+
+/** Match ^(label+=TOKEN ...) track for rewrite */
+tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRefRuleRootTrack(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** rule when output=AST and tracking for rewrite */
+ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule.name>.Add(<label>.Tree);
+>>
+
+/** x+=rule when output=AST and tracking for rewrite */
+ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefTrack(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** ^(rule ...) rewrite */
+ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRoot(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule>.Add(<label>.Tree);
+>>
+
+/** ^(x+=rule ...) rewrite */
+ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRootTrack(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+// R e w r i t e
+
+rewriteCode(
+	alts, description,
+	referencedElementsDeep, // ALL referenced elements to right of ->
+	referencedTokenLabels,
+	referencedTokenListLabels,
+	referencedRuleLabels,
+	referencedRuleListLabels,
+	referencedWildcardLabels,
+	referencedWildcardListLabels,
+	rewriteBlockLevel, enclosingTreeLevel, treeLevel) ::= <<
+<\n>{
+// AST REWRITE
+// elements: <referencedElementsDeep; separator=", ">
+// token labels: <referencedTokenLabels; separator=", ">
+// rule labels: <referencedRuleLabels; separator=", ">
+// token list labels: <referencedTokenListLabels; separator=", ">
+// rule list labels: <referencedRuleListLabels; separator=", ">
+// wildcard labels: <[referencedWildcardLabels,referencedWildcardListLabels]; separator=", ">
+<if(backtracking)>
+if (<actions.(actionScope).synpredgate>) {
+<endif>
+<prevRuleRootRef()>.Tree = root_0;
+<rewriteCodeLabels()>
+root_0 = (<ASTLabelType>)adaptor.Nil();
+<alts:rewriteAlt(); separator="else ">
+<! if tree parser and rewrite=true !>
+<if(TREE_PARSER&&rewriteMode)>
+<prevRuleRootRef()>.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+input.ReplaceChildren(adaptor.GetParent(retval.Start),
+                      adaptor.GetChildIndex(retval.Start),
+                      adaptor.GetChildIndex(_last),
+                      retval.Tree);
+<endif>
+<! if parser or tree-parser && rewrite!=true, we need to set result !>
+<if(!TREE_PARSER||!rewriteMode)>
+<prevRuleRootRef()>.Tree = root_0;
+<endif>
+<if(backtracking)>
+}
+<endif>
+}
+
+>>
+
+rewriteCodeLabels() ::= <<
+<referencedTokenLabels
+    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
+    separator="\n"
+>
+<referencedTokenListLabels
+    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
+    separator="\n"
+>
+<referencedWildcardLabels
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
+	separator="\n"
+>
+<referencedWildcardListLabels
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
+	separator="\n"
+>
+<referencedRuleLabels
+    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
+    separator="\n"
+>
+<referencedRuleListLabels
+    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
+    separator="\n"
+>
+>>
+
+/** Generate code for an optional rewrite block; note it uses the deep ref'd element
+  *  list rather shallow like other blocks.
+  */
+rewriteOptionalBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+// <fileName>:<description>
+if (<referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||">)
+{
+	<alt>
+}
+<referencedElementsDeep:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewriteClosureBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+// <fileName>:<description>
+while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
+{
+	<alt>
+}
+<referencedElements:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewritePositiveClosureBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+if (!(<referencedElements:{el | stream_<el>.HasNext}; separator="||">))
+{
+	throw new RewriteEarlyExitException();
+}
+while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
+{
+	<alt>
+}
+<referencedElements:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewriteAlt(a) ::= <<
+// <a.description>
+<if(a.pred)>
+if (<a.pred>)
+{
+	<a.alt>
+}
+<else>
+{
+	<a.alt>
+}
+<endif>
+>>
+
+/** For empty rewrites: "r : ... -> ;" */
+rewriteEmptyAlt() ::= "root_0 = null;"
+
+rewriteTree(root,children,description,enclosingTreeLevel,treeLevel) ::= <<
+// <fileName>:<description>
+{
+<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
+<root:rewriteElement()>
+<children:rewriteElement()>
+adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
+}<\n>
+>>
+
+rewriteElementList(elements) ::= "<elements:rewriteElement()>"
+
+rewriteElement(e) ::= <%
+<@pregen()>
+DebugLocation(<e.line>, <e.pos>);<\n>
+<e.el>
+%>
+
+/** Gen ID or ID[args] */
+rewriteTokenRef(token,elementIndex,terminalOptions,args) ::= <<
+adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
+>>
+
+/** Gen $label ... where defined via label=ID */
+rewriteTokenLabelRef(label,elementIndex) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
+>>
+
+/** Gen $label ... where defined via label+=ID */
+rewriteTokenListLabelRef(label,elementIndex) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
+>>
+
+/** Gen ^($label ...) */
+rewriteTokenLabelRefRoot(label,elementIndex) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+/** Gen ^($label ...) where label+=... */
+rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot
+
+/** Gen ^(ID ...) or ^(ID[args] ...) */
+rewriteTokenRefRoot(token,elementIndex,terminalOptions,args) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
+>>
+
+rewriteImaginaryTokenRef(args,token,terminalOptions,elementIndex) ::= <<
+adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
+>>
+
+rewriteImaginaryTokenRefRoot(args,token,terminalOptions,elementIndex) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
+>>
+
+/** plain -> {foo} action */
+rewriteAction(action) ::= <<
+root_0 = <action>;<\n>
+>>
+
+/** What is the name of the previous value of this rule's root tree?  This
+ *  let's us refer to $rule to mean previous value.  I am reusing the
+ *  variable 'tree' sitting in retval struct to hold the value of root_0 right
+ *  before I set it during rewrites.  The assign will be to retval.tree.
+ */
+prevRuleRootRef() ::= "retval"
+
+rewriteRuleRef(rule) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<rule>.NextTree());<\n>
+>>
+
+rewriteRuleRefRoot(rule) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<rule>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+rewriteNodeAction(action) ::= <<
+adaptor.AddChild(root_<treeLevel>, <action>);<\n>
+>>
+
+rewriteNodeActionRoot(action) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<action>, root_<treeLevel>);<\n>
+>>
+
+/** Gen $ruleLabel ... where defined via ruleLabel=rule */
+rewriteRuleLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+/** Gen $ruleLabel ... where defined via ruleLabel+=rule */
+rewriteRuleListLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+/** Gen ^($ruleLabel ...) where ruleLabel=rule */
+rewriteRuleLabelRefRoot(label) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+/** Gen ^($ruleLabel ...) where ruleLabel+=rule */
+rewriteRuleListLabelRefRoot(label) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+rewriteWildcardLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+createImaginaryNode(tokenType,terminalOptions,args) ::= <%
+<if(terminalOptions.node)>
+<! new MethodNode(IDLabel, args) !>
+new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
+<else>
+(<ASTLabelType>)adaptor.Create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
+<endif>
+%>
+
+createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
+<else>
+<if(args)> <! must create new node from old !>
+adaptor.Create(<token>, <args; separator=", ">)
+<else>
+stream_<token>.NextNode()
+<endif>
+<endif>
+%>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
new file mode 100644
index 0000000..0d2a441
--- /dev/null
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
@@ -0,0 +1,94 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2005 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Template overrides to add debugging to AST stuff.  Dynamic inheritance
+ *  hierarchy is set up as ASTDbg : AST : Dbg : Java by code generator.
+ */
+
+parserMembers() ::= <<
+protected DebugTreeAdaptor adaptor;
+
+public ITreeAdaptor TreeAdaptor
+{
+	get
+	{
+		return adaptor;
+	}
+	set
+	{
+<if(grammar.grammarIsRoot)>
+		this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
+<else>
+		this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+<endif><\n>
+		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+	}
+}<\n>
+>>
+
+parserCtorBody() ::= <<
+<super.parserCtorBody()>
+>>
+
+createListenerAndHandshake() ::= <<
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, <if(TREE_PARSER)>input.TreeAdaptor<else>adaptor<endif> );
+DebugListener = proxy;
+<inputStreamType> = new Debug<inputStreamType>( input, proxy );
+try
+{
+	proxy.Handshake();
+}
+catch ( IOException ioe )
+{
+	ReportError( ioe );
+}
+>>
+
+@ctorForRootGrammar.finally() ::= <<
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;
+proxy.TreeAdaptor = adap;
+>>
+
+@ctorForProfilingRootGrammar.finally() ::=<<
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;
+>>
+
+@ctorForPredefinedListener.superClassRef() ::= ": base( input, dbg )"
+
+@ctorForPredefinedListener.finally() ::=<<
+<if(grammar.grammarIsRoot)><! don't create new adaptor for delegates !>
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;<\n>
+<endif>
+>>
+
+//@rewriteElement.pregen() ::= "dbg.Location( <e.line>, <e.pos> );"
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
new file mode 100644
index 0000000..6413dfe
--- /dev/null
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
@@ -0,0 +1,192 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Templates for building ASTs during normal parsing.
+ *
+ *  Deal with many combinations.  Dimensions are:
+ *  Auto build or rewrite
+ *    no label, label, list label  (label/no-label handled together)
+ *    child, root
+ *    token, set, rule, wildcard
+ *
+ *  The situation is not too bad as rewrite (->) usage makes ^ and !
+ *  invalid. There is no huge explosion of combinations.
+ */
+
+@rule.setErrorReturnValue() ::= <<
+retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
+<! System.out.WriteLine("<ruleName> returns "+((CommonTree)retval.tree).toStringTree()); !>
+>>
+
+// TOKEN AST STUFF
+
+/** ID and output=AST */
+tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+<super.tokenRef(...)>
+<if(backtracking)>if (state.backtracking == 0) {<endif>
+<label>_tree = <createNodeFromToken(...)>;
+adaptor.AddChild(root_0, <label>_tree);
+<if(backtracking)>}<endif>
+>>
+
+/** ID! and output=AST (same as plain tokenRef) */
+tokenRefBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"
+
+/** ID^ and output=AST */
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+<super.tokenRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = <createNodeFromToken(...)>;
+root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
+<if(backtracking)>}<endif>
+>>
+
+/** ids+=ID! and output=AST */
+tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRefBang(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** label+=TOKEN when output=AST but not rewrite alt */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match label+=TOKEN^ when output=AST but not rewrite alt */
+tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
+<tokenRefRuleRoot(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+// SET AST
+
+// the match set stuff is interesting in that it uses an argument list
+// to pass code to the default matchSet; another possible way to alter
+// inherited code.  I don't use the region stuff because I need to pass
+// different chunks depending on the operator.  I don't like making
+// the template name have the operator as the number of templates gets
+// large but this is the most flexible--this is as opposed to having
+// the code generator call matchSet then add root code or ruleroot code
+// plus list label plus ...  The combinations might require complicated
+// rather than just added on code.  Investigate that refactoring when
+// I have more time.
+
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);}, ...)>
+>>
+
+matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+<matchSet(...)>
+>>
+
+matchSetBang(s,label,elementIndex,terminalOptions,postmatchCode) ::= "<super.matchSet(...)>"
+
+// note there is no matchSetTrack because -> rewrites force sets to be
+// plain old blocks of alts: (A|B|...|C)
+
+matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+<if(label)>
+<label>=(<labelType>)input.LT(1);
+<endif>
+<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);}, ...)>
+>>
+
+// RULE REF AST
+
+/** rule when output=AST */
+ruleRef(rule,label,elementIndex,args,scope) ::= <<
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <label>.Tree);
+>>
+
+/** rule! is same as normal rule ref */
+ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(...)>"
+
+/** rule^ */
+ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
+>>
+
+/** x+=rule when output=AST */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** x+=rule! when output=AST is a rule ref with list addition */
+ruleRefBangAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefBang(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** x+=rule^ */
+ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRoot(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+// WILDCARD AST
+
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
+<super.wildcard(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
+adaptor.AddChild(root_0, <label>_tree);
+<if(backtracking)>}<endif>
+>>
+
+wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"
+
+wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+<super.wildcard(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
+root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
+<if(backtracking)>}<endif>
+>>
+
+createNodeFromToken(label,terminalOptions) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
+<else>
+(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
+<endif>
+%>
+
+ruleCleanUp() ::= <<
+<super.ruleCleanUp()>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
+<if(backtracking)>}<endif>
+>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
new file mode 100644
index 0000000..d749fa6
--- /dev/null
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
@@ -0,0 +1,298 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Templates for building ASTs during tree parsing.
+ *
+ *  Deal with many combinations.  Dimensions are:
+ *  Auto build or rewrite
+ *    no label, label, list label  (label/no-label handled together)
+ *    child, root
+ *    token, set, rule, wildcard
+ *
+ *  Each combination has its own template except that label/no label
+ *  is combined into tokenRef, ruleRef, ...
+ */
+
+/** Add a variable to track last element matched */
+ruleDeclarations() ::= <<
+<super.ruleDeclarations()>
+<ASTLabelType> _first_0 = default(<ASTLabelType>);
+<ASTLabelType> _last = default(<ASTLabelType>);<\n>
+>>
+
+/** What to emit when there is no rewrite rule.  For auto build
+ *  mode, does nothing.
+ */
+noRewrite(rewriteBlockLevel, treeLevel) ::= <<
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(rewriteMode)>
+retval.Tree = (<ASTLabelType>)_first_0;
+if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
+    retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
+<endif>
+<if(backtracking)>}<endif>
+>>
+
+/** match ^(root children) in tree parser; override here to
+ *  add tree construction actions.
+ */
+tree(root, actionsAfterRoot, children, nullableChildList,
+     enclosingTreeLevel, treeLevel) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+{
+<ASTLabelType> _save_last_<treeLevel> = _last;
+<ASTLabelType> _first_<treeLevel> = default(<ASTLabelType>);
+<if(!rewriteMode)>
+<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
+<endif>
+<root:element()>
+<if(rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+<if(root.el.rule)>
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
+<else>
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>;
+<endif>
+<endif>
+<actionsAfterRoot:element()>
+<if(nullableChildList)>
+if (input.LA(1) == TokenTypes.Down) {
+    Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+    <children:element()>
+    Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+}
+<else>
+Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+<children:element()>
+Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+<endif>
+<if(!rewriteMode)>
+adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
+<endif>
+_last = _save_last_<treeLevel>;
+}<\n>
+>>
+
+// TOKEN AST STUFF
+
+/** ID! and output=AST (same as plain tokenRef) 'cept add
+ *  setting of _last
+ */
+tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+>>
+
+/** ID auto construct */
+tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>}<endif>
+<else> <! rewrite mode !>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
+<endif>
+>>
+
+/** label+=TOKEN auto construct */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRef(...)>
+<listLabelElem(elem=label,...)>
+>>
+
+/** ^(ID ...) auto construct */
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
+<if(backtracking)>}<endif>
+<endif>
+>>
+
+/** Match ^(label+=TOKEN ...) auto construct */
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRefRuleRoot(...)>
+<listLabelElem(elem=label,...)>
+>>
+
+/** Match . wildcard and auto dup the node/subtree */
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.wildcard(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.DupTree(<label>);
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>}<endif>
+<else> <! rewrite mode !>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
+<endif>
+>>
+
+// SET AST
+
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.matchSet(postmatchCode={
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>\}<endif>
+<endif>
+}, ...
+)>
+>>
+
+matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+<matchSet(...)>
+<noRewrite(...)> <! set return tree !>
+>>
+
+matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.matchSet(...)>
+>>
+
+matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+<super.matchSet(postmatchCode={
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
+<if(backtracking)>\}<endif>
+<endif>
+}, ...
+)>
+>>
+
+// RULE REF AST
+
+/** rule auto construct */
+ruleRef(rule,label,elementIndex,args,scope) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+<if(!rewriteMode)>
+adaptor.AddChild(root_<treeLevel>, <label>.Tree);
+<else> <! rewrite mode !>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
+<endif>
+>>
+
+/** x+=rule auto construct */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabelElem(elem={<label>.Tree},...)>
+>>
+
+/** ^(rule ...) auto construct */
+ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
+<endif>
+>>
+
+/** ^(x+=rule ...) auto construct */
+ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRoot(...)>
+<listLabelElem(elem={<label>.Tree},...)>
+>>
+
+/** rule when output=AST and tracking for rewrite */
+ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefTrack(...)>
+>>
+
+/** x+=rule when output=AST and tracking for rewrite */
+ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefTrackAndListLabel(...)>
+>>
+
+/** ^(rule ...) rewrite */
+ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefRootTrack(...)>
+>>
+
+/** ^(x+=rule ...) rewrite */
+ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefRuleRootTrackAndListLabel(...)>
+>>
+
+/** Streams for token refs are tree nodes now; override to
+ *  change NextToken to NextNode.
+ */
+createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
+<else>
+stream_<token>.NextNode()
+<endif>
+%>
+
+ruleCleanUp() ::= <<
+<super.ruleCleanUp()>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+<if(backtracking)>}<endif>
+<endif>
+>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
new file mode 100644
index 0000000..8e5d603
--- /dev/null
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
@@ -0,0 +1,1715 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+csharpVisibilityMap ::= [
+	"private":"private",
+	"protected":"protected",
+	"public":"public",
+	"fragment":"private",
+	default:"private"
+]
+
+/** The overall file structure of a recognizer; stores methods for rules
+ *  and cyclic DFAs plus support code.
+ */
+outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
+			docComment, recognizer,
+			name, tokens, tokenNames, rules, cyclicDFAs,
+			bitsets, buildTemplate, buildAST, rewriteMode, profile,
+			backtracking, synpreds, memoize, numRules,
+			fileName, ANTLRVersion, generatedTimestamp, trace,
+			scopes, superClass, literals) ::=
+<<
+//------------------------------------------------------------------------------
+// \<auto-generated>
+//     This code was generated by a tool.
+//     ANTLR Version: <ANTLRVersion>
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// \</auto-generated>
+//------------------------------------------------------------------------------
+
+// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>
+
+<if(trace)>
+#define ANTLR_TRACE
+<endif>
+<@debugPreprocessor()>
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 168, 219
+// Unreachable code detected.
+#pragma warning disable 162
+// Missing XML comment for publicly visible type or member 'Type_or_Member'
+#pragma warning disable 1591
+
+<actions.(actionScope).header>
+
+<@imports>
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Misc;
+<if(TREE_PARSER)>
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
+<endif>
+using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;
+<@end>
+<if(actions.(actionScope).namespace)>
+namespace <actions.(actionScope).namespace>
+{
+<endif>
+<docComment>
+<recognizer>
+<if(actions.(actionScope).namespace)>
+
+} // namespace <actions.(actionScope).namespace>
+<endif>
+>>
+
+lexerInputStreamType() ::= <<
+<actions.(actionScope).inputStreamType; null="ICharStream">
+>>
+
+lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
+      superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>}) ::= <<
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
+[System.CLSCompliant(false)]
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+{
+	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
+	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+	<actions.lexer.members>
+
+    // delegates
+    <grammar.delegates:
+         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+    // delegators
+    <grammar.delegators:
+         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+    <last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
+	{
+		OnCreated();
+	}
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+		: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
+	{
+	}
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+		: base(input, state)
+	{
+<if(memoize)>
+<if(grammar.grammarIsRoot)>
+		state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<numRules>+1];<\n><! index from 1..n !>
+<endif>
+<endif>
+		<grammar.directDelegates:
+		 {g|<g:delegateName()> = new <g.recognizerName>(input, this.state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+		<grammar.delegators:
+		 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+
+		OnCreated();
+	}
+	public override string GrammarFileName { get { return "<fileName>"; } }
+
+	private static readonly bool[] decisionCanBacktrack = new bool[0];
+
+<if(grammar.hasDelegates)>
+	public override <lexerInputStreamType()> CharStream
+	{
+		get
+		{
+			return base.CharStream;
+		}
+		set
+		{
+			base.CharStream = value;
+			<grammar.directDelegates:
+			 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+			<grammar.delegators:
+			 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+			<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+		}
+	}
+
+<endif>
+<if(filterMode)>
+	<filteringNextToken()>
+<endif>
+
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void OnCreated() {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}
+
+    <rules; separator="\n">
+
+	<insertLexerSynpreds(synpreds)>
+
+	#region DFA
+	<cyclicDFAs:{dfa | DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif>);}; separator="\n">
+	}
+
+	<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
+	#endregion
+
+}
+>>
+
+/** A override of Lexer.nextToken() that backtracks over mTokens() looking
+ *  for matches.  No error can be generated upon error; just rewind, consume
+ *  a token and then try again.  backtracking needs to be set as well.
+ *  Make rule memoization happen only at levels above 1 as we start mTokens
+ *  at backtracking==1.
+ */
+filteringNextToken() ::= <<
+public override IToken NextToken()
+{
+	while (true)
+	{
+		if (input.LA(1) == CharStreamConstants.EndOfFile)
+		{
+			IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
+			eof.Line = Line;
+			eof.CharPositionInLine = CharPositionInLine;
+			return eof;
+		}
+		state.token = null;
+		state.channel = TokenChannels.Default;
+		state.tokenStartCharIndex = input.Index;
+		state.tokenStartCharPositionInLine = input.CharPositionInLine;
+		state.tokenStartLine = input.Line;
+		state.text = null;
+		try
+		{
+			int m = input.Mark();
+			state.backtracking=1;<! means we won't throw slow exception !>
+			state.failed=false;
+			mTokens();
+			state.backtracking=0;
+			<! mTokens backtracks with synpred at backtracking==2
+			   and we set the synpredgate to allow actions at level 1. !>
+			if (state.failed)
+			{
+				input.Rewind(m);
+				input.Consume();<! advance one char and try again !>
+			}
+			else
+			{
+				Emit();
+				return state.token;
+			}
+		}
+		catch (RecognitionException re)
+		{
+			// shouldn't happen in backtracking mode, but...
+			ReportError(re);
+			Recover(re);
+		}
+	}
+}
+
+public override void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex)
+{
+	if (state.backtracking > 1)
+		base.Memoize(input, ruleIndex, ruleStartIndex);
+}
+
+public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
+{
+	if (state.backtracking > 1)
+		return base.AlreadyParsedRule(input, ruleIndex);
+
+	return false;
+}
+>>
+
+actionGate() ::= "state.backtracking == 0"
+
+filteringActionGate() ::= "state.backtracking == 1"
+
+/** How to generate a parser */
+genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
+              bitsets, inputStreamType, superClass,
+              labelType, members, rewriteElementType,
+              filterMode, ASTLabelType="object") ::= <<
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
+[System.CLSCompliant(false)]
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+{
+<if(grammar.grammarIsRoot)>
+	internal static readonly string[] tokenNames = new string[] {
+		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
+	};
+<endif>
+	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
+
+<if(grammar.delegates)>
+	// delegates
+	<grammar.delegates:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
+	// delegators
+	<grammar.delegators:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+<endif>
+
+	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+	<@members()>
+
+	public override string[] TokenNames { get { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; } }
+	public override string GrammarFileName { get { return "<fileName>"; } }
+
+	<members>
+
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void OnCreated() {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}
+
+	#region Rules
+	<rules; separator="\n">
+	#endregion Rules
+
+<if(grammar.delegatedRules)>
+<! generate rule/method definitions for imported rules so they
+   appear to be defined in this recognizer. !>
+	#region Delegated rules
+<grammar.delegatedRules:{ruleDescriptor|
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
+	#endregion Delegated rules
+<endif>
+
+	<insertSynpreds(synpreds)>
+
+<if(cyclicDFAs)>
+	#region DFA
+	<cyclicDFAs:{dfa | private DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>( this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif> );}; separator="\n">
+	}
+
+	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
+	#endregion DFA
+<endif>
+
+<if(bitsets)>
+	#region Follow sets
+	private static class Follow
+	{
+		<bitsets:{it|<bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>}; separator="\n">
+	}
+	#endregion Follow sets
+<endif>
+}
+>>
+
+@genericParser.members() ::= <<
+#if ANTLR_DEBUG
+	private static readonly bool[] decisionCanBacktrack =
+		new bool[]
+		{
+			false, // invalid decision
+			<grammar.decisions:{d | <d.dfa.hasSynPred>}; wrap="\n", separator=", ">
+		};
+#else
+	private static readonly bool[] decisionCanBacktrack = new bool[0];
+#endif
+<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: base(input, state)
+{
+	<parserCtorBody()>
+<if(grammar.directDelegates)>
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+<endif>
+<if(grammar.indirectDelegates)>
+	<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
+	<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+<endif>
+	OnCreated();
+}
+>>
+
+// imported grammars are 'public' (can't be internal because their return scope classes must be accessible)
+parserModifier(grammar, actions) ::= <<
+<if(grammar.grammarIsRoot)><actions.(actionScope).modifier; null="public"><else>public<endif>
+>>
+
+parserCtorBody() ::= <<
+<if(memoize)>
+<if(grammar.grammarIsRoot)>
+this.state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<length(grammar.allImportedRules)>+1];<\n><! index from 1..n !>
+<endif>
+<endif>
+<grammar.delegators:
+ {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+>>
+
+parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
+       ASTLabelType="object", superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Parser<endif>}, labelType="IToken",
+       members={<actions.parser.members>}) ::= <<
+<genericParser(inputStreamType="ITokenStream", rewriteElementType="IToken", ...)>
+>>
+
+/** How to generate a tree parser; same as parser except the input
+ *  stream is a different type.
+ */
+treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
+           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="object",
+           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif><endif>},
+           members={<actions.treeparser.members>}) ::= <<
+<genericParser(inputStreamType="ITreeNodeStream", rewriteElementType="Node", ...)>
+>>
+
+/** A simpler version of a rule template that is specific to the imaginary
+ *  rules created for syntactic predicates.  As they never have return values
+ *  nor parameters etc..., just give simplest possible method.  Don't do
+ *  any of the normal memoization stuff in here either; it's a waste.
+ *  As predicates cannot be inlined into the invoking rule, they need to
+ *  be in a rule by themselves.
+ */
+synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
+<<
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>_fragment() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>_fragment() {}
+
+// $ANTLR start <ruleName>
+public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	<ruleLabelDefs()>
+	EnterRule_<ruleName>_fragment();
+	EnterRule("<ruleName>_fragment", <ruleDescriptor.index>);
+	TraceIn("<ruleName>_fragment", <ruleDescriptor.index>);
+	try
+	{
+		<block>
+	}
+	finally
+	{
+		TraceOut("<ruleName>_fragment", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>_fragment", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>_fragment();
+	}
+}
+// $ANTLR end <ruleName>
+>>
+
+insertLexerSynpreds(synpreds) ::= <<
+<insertSynpreds(synpreds)>
+>>
+
+insertSynpreds(synpreds) ::= <<
+<if(synpreds)>
+#region Synpreds
+private bool EvaluatePredicate(System.Action fragment)
+{
+	bool success = false;
+	state.backtracking++;
+	<@start()>
+	try { DebugBeginBacktrack(state.backtracking);
+	int start = input.Mark();
+	try
+	{
+		fragment();
+	}
+	catch ( RecognitionException re )
+	{
+		System.Console.Error.WriteLine("impossible: "+re);
+	}
+	success = !state.failed;
+	input.Rewind(start);
+	} finally { DebugEndBacktrack(state.backtracking, success); }
+	<@stop()>
+	state.backtracking--;
+	state.failed=false;
+	return success;
+}
+#endregion Synpreds
+<endif>
+>>
+
+ruleMemoization(name) ::= <<
+<if(memoize)>
+if (state.backtracking > 0 && AlreadyParsedRule(input, <ruleDescriptor.index>)) { <returnFromRule()> }
+<endif>
+>>
+
+/** How to test for failure and return from rule */
+checkRuleBacktrackFailure() ::= <<
+<if(backtracking)>if (state.failed) <returnFromRule()><endif>
+>>
+
+/** This rule has failed, exit indicating failure during backtrack */
+ruleBacktrackFailure() ::= <<
+<if(backtracking)>if (state.backtracking>0) {state.failed=true; <returnFromRule()>}<endif>
+>>
+
+/** How to generate code for a rule.  This includes any return type
+ *  data aggregates required for multiple return values.
+ */
+rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memoize) ::= <<
+<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
+<returnScope(ruleDescriptor.returnScope)>
+
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>() {}
+
+// $ANTLR start "<ruleName>"
+// <fileName>:<description>
+[GrammarRule("<ruleName>")]
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	EnterRule_<ruleName>();
+	EnterRule("<ruleName>", <ruleDescriptor.index>);
+	TraceIn("<ruleName>", <ruleDescriptor.index>);
+    <ruleScopeSetUp()>
+    <ruleDeclarations()>
+    <ruleLabelDefs()>
+    <ruleDescriptor.actions.init>
+	try { DebugEnterRule(GrammarFileName, "<ruleName>");
+	DebugLocation(<ruleDescriptor.tree.line>, <ruleDescriptor.EORNode.charPositionInLine>);
+	<@preamble()>
+	try
+	{
+		<ruleMemoization(name=ruleName)>
+		<block>
+		<ruleCleanUp()>
+		<(ruleDescriptor.actions.after):execAction()>
+	}
+<if(exceptions)>
+	<exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
+<else>
+<if(!emptyRule)>
+<if(actions.(actionScope).rulecatch)>
+	<actions.(actionScope).rulecatch>
+<else>
+	catch (RecognitionException re)
+	{
+		ReportError(re);
+		Recover(input,re);
+	<@setErrorReturnValue()>
+	}
+<endif>
+<endif>
+<endif>
+	finally
+	{
+		TraceOut("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>();
+        <memoize()>
+        <ruleScopeCleanUp()>
+        <finally>
+    }
+ 	DebugLocation(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);
+	} finally { DebugExitRule(GrammarFileName, "<ruleName>"); }
+	<@postamble()>
+	<returnFromRule()><\n>
+}
+// $ANTLR end "<ruleName>"
+>>
+
+// imported grammars need to have internal rules
+ruleModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>internal<endif>
+>>
+
+// imported grammars need to have public return scopes
+returnScopeModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>public<endif>
+>>
+
+catch(decl,action) ::= <<
+catch (<e.decl>)
+{
+	<e.action>
+}
+>>
+
+ruleDeclarations() ::= <<
+<if(ruleDescriptor.hasMultipleReturnValues)>
+<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>();
+retval.Start = (<labelType>)input.LT(1);
+<else>
+<ruleDescriptor.returnScope.attributes:{ a |
+<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
+}>
+<endif>
+<if(memoize)>
+int <ruleDescriptor.name>_StartIndex = input.Index;
+<endif>
+>>
+
+ruleScopeSetUp() ::= <<
+<ruleDescriptor.useScopes:{it|<it>_stack.Push(new <it>_scope());<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
+<ruleDescriptor.ruleScope:{it|<it.name>_stack.Push(new <it.name>_scope());<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
+>>
+
+ruleScopeCleanUp() ::= <<
+<ruleDescriptor.useScopes:{it|<it>_scopeAfter(<it>_stack.Peek());<it>_stack.Pop();}; separator="\n">
+<ruleDescriptor.ruleScope:{it|<it.name>_scopeAfter(<it.name>_stack.Peek());<it.name>_stack.Pop();}; separator="\n">
+>>
+
+ruleLabelDefs() ::= <<
+<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
+    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<ruleDescriptor.tokenListLabels
+    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<[ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
+    :{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
+<ruleDescriptor.ruleListLabels:ruleLabelDef(); separator="\n">
+>>
+
+lexerRuleLabelDefs() ::= <<
+<[ruleDescriptor.tokenLabels,
+  ruleDescriptor.tokenListLabels,
+  ruleDescriptor.ruleLabels]
+    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<[ruleDescriptor.charListLabels,
+  ruleDescriptor.charLabels]
+	:{it|int <it.label.text> = 0;}; separator="\n"
+>
+<[ruleDescriptor.tokenListLabels,
+  ruleDescriptor.ruleListLabels]
+    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<ruleDescriptor.charListLabels:{it|List\<int\> list_<it.label.text> = null;}; separator="\n"
+>
+>>
+
+returnFromRule() ::= <%
+return
+<if(!ruleDescriptor.isSynPred)>
+<if(ruleDescriptor.hasReturnValue)>
+<if(ruleDescriptor.hasSingleReturnValue)>
+<! This comment is a hack to make sure the following
+   single space appears in the output. !> <ruleDescriptor.singleValueReturnName>
+<else>
+<!!> retval
+<endif>
+<endif>
+<endif>
+;
+%>
+
+ruleCleanUp() ::= <<
+<if(ruleDescriptor.hasMultipleReturnValues)>
+<if(!TREE_PARSER)>
+retval.Stop = (<labelType>)input.LT(-1);
+<endif>
+<endif>
+>>
+
+memoize() ::= <<
+<if(memoize)>
+<if(backtracking)>
+if (state.backtracking > 0) { Memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex); }
+<endif>
+<endif>
+>>
+
+/** How to generate a rule in the lexer; naked blocks are used for
+ *  fragment rules.
+ */
+lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
+
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>() {}
+
+// $ANTLR start "<ruleName>"
+[GrammarRule("<ruleName>")]
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	EnterRule_<ruleName>();
+	EnterRule("<ruleName>", <ruleDescriptor.index>);
+	TraceIn("<ruleName>", <ruleDescriptor.index>);
+    <ruleScopeSetUp()>
+    <ruleDeclarations()>
+		try
+		{
+<if(nakedBlock)>
+		<ruleMemoization(name=ruleName)>
+		<lexerRuleLabelDefs()>
+		<ruleDescriptor.actions.init>
+		<block>
+<else>
+		int _type = <ruleName>;
+		int _channel = DefaultTokenChannel;
+		<ruleMemoization(name=ruleName)>
+		<lexerRuleLabelDefs()>
+		<ruleDescriptor.actions.init>
+		<block>
+		<ruleCleanUp()>
+		state.type = _type;
+		state.channel = _channel;
+		<(ruleDescriptor.actions.after):execAction()>
+<endif>
+	}
+	finally
+	{
+		TraceOut("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>();
+        <ruleScopeCleanUp()>
+        <memoize()>
+    }
+}
+// $ANTLR end "<ruleName>"
+>>
+
+/** How to generate code for the implicitly-defined lexer grammar rule
+ *  that chooses between lexer rules.
+ */
+tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
+
+public override void mTokens()
+{
+	<block><\n>
+}
+>>
+
+// S U B R U L E S
+
+/** A (...) subrule with multiple alternatives */
+block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int alt<decisionNumber>=<maxAlt>;
+<decls>
+<@predecision()>
+try { DebugEnterSubRule(<decisionNumber>);
+try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+<decision>
+} finally { DebugExitDecision(<decisionNumber>); }
+<@postdecision()>
+<@prebranch()>
+switch (alt<decisionNumber>)
+{
+<alts:{a|<altSwitchCase(i,a)>}>
+}
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postbranch()>
+>>
+
+/** A rule block with multiple alternatives */
+ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int alt<decisionNumber>=<maxAlt>;
+<decls>
+<@predecision()>
+try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+<decision>
+} finally { DebugExitDecision(<decisionNumber>); }
+<@postdecision()>
+switch (alt<decisionNumber>)
+{
+<alts:{a|<altSwitchCase(i,a)>}>
+}
+>>
+
+ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@prealt()>
+DebugEnterAlt(1);
+<alts>
+<@postalt()>
+>>
+
+/** A special case of a (...) subrule with a single alternative */
+blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@prealt()>
+DebugEnterAlt(1);
+<alts>
+<@postalt()>
+>>
+
+/** A (..)+ block with 1 or more alternatives */
+positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int cnt<decisionNumber>=0;
+<decls>
+<@preloop()>
+try { DebugEnterSubRule(<decisionNumber>);
+while (true)
+{
+	int alt<decisionNumber>=<maxAlt>;
+	<@predecision()>
+	try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+	<decision>
+	} finally { DebugExitDecision(<decisionNumber>); }
+	<@postdecision()>
+	switch (alt<decisionNumber>)
+	{
+	<alts:{a|<altSwitchCase(i,a)>}>
+	default:
+		if (cnt<decisionNumber> >= 1)
+			goto loop<decisionNumber>;
+
+		<ruleBacktrackFailure()>
+		EarlyExitException eee<decisionNumber> = new EarlyExitException( <decisionNumber>, input );
+		DebugRecognitionException(eee<decisionNumber>);
+		<@earlyExitException()>
+		throw eee<decisionNumber>;
+	}
+	cnt<decisionNumber>++;
+}
+loop<decisionNumber>:
+	;
+
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postloop()>
+>>
+
+positiveClosureBlockSingleAlt ::= positiveClosureBlock
+
+/** A (..)* block with 1 or more alternatives */
+closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@preloop()>
+try { DebugEnterSubRule(<decisionNumber>);
+while (true)
+{
+	int alt<decisionNumber>=<maxAlt>;
+	<@predecision()>
+	try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+	<decision>
+	} finally { DebugExitDecision(<decisionNumber>); }
+	<@postdecision()>
+	switch ( alt<decisionNumber> )
+	{
+	<alts:{a|<altSwitchCase(i,a)>}>
+	default:
+		goto loop<decisionNumber>;
+	}
+}
+
+loop<decisionNumber>:
+	;
+
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postloop()>
+>>
+
+closureBlockSingleAlt ::= closureBlock
+
+/** Optional blocks (x)? are translated to (x|) by before code generation
+ *  so we can just use the normal block template
+ */
+optionalBlock ::= block
+
+optionalBlockSingleAlt ::= block
+
+/** A case in a switch that jumps to an alternative given the alternative
+ *  number.  A DFA predicts the alternative and then a simple switch
+ *  does the jump to the code that actually matches that alternative.
+ */
+altSwitchCase(altNum,alt) ::= <<
+case <altNum>:
+	<@prealt()>
+	DebugEnterAlt(<altNum>);
+	<alt>
+	break;<\n>
+>>
+
+/** An alternative is just a list of elements; at outermost level */
+alt(elements,altNum,description,autoAST,outerAlt,treeLevel,rew) ::= <<
+// <fileName>:<description>
+{
+<@declarations()>
+<elements:element()>
+<rew>
+<@cleanup()>
+}
+>>
+
+/** What to emit when there is no rewrite.  For auto build
+ *  mode, does nothing.
+ */
+noRewrite(rewriteBlockLevel, treeLevel) ::= ""
+
+// E L E M E N T S
+
+/** Dump the elements one per line */
+element(it) ::= <%
+<@prematch()>
+DebugLocation(<it.line>, <it.pos>);<\n>
+<it.el><\n>
+%>
+
+/** match a token optionally with a label in front */
+tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
+>>
+
+/** ids+=ID */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<tokenRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+listLabelElem(label,elem,elemType) ::= <<
+if (list_<label>==null) list_<label>=new List\<<elemType; null={<labelType>}>\>();
+list_<label>.Add(<elem>);<\n>
+>>
+
+/** match a character */
+charRef(char,label) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+Match(<char>); <checkRuleBacktrackFailure()>
+>>
+
+/** match a character range */
+charRangeRef(a,b,label) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
+>>
+
+/** For now, sets are interval tests and must be tested inline */
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode="") ::= <<
+<if(label)>
+<matchSetLabel()>
+<endif>
+if (<s>)
+{
+	input.Consume();
+	<postmatchCode>
+	<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
+}
+else
+{
+	<ruleBacktrackFailure()>
+	MismatchedSetException mse = new MismatchedSetException(null,input);
+	DebugRecognitionException(mse);
+	<@mismatchedSetException()>
+<if(LEXER)>
+	Recover(mse);
+	throw mse;
+<else>
+	throw mse;
+	<! use following code to make it recover inline; remove throw mse;
+	recoverFromMismatchedSet(input,mse,Follow._set_in_<ruleName><elementIndex>);
+	!>
+<endif>
+}<\n>
+>>
+
+matchSetUnchecked(s,label,elementIndex,postmatchCode=false) ::= <%
+<if(label)>
+<matchSetLabel()><\n>
+<endif>
+input.Consume();<\n>
+<if(postmatchCode)>
+<postmatchCode><\n>
+<endif>
+<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
+%>
+
+matchSetLabel() ::= <%
+<if(LEXER)>
+<label>= input.LA(1);
+<else>
+<label>=(<labelType>)input.LT(1);
+<endif>
+%>
+
+matchRuleBlockSet ::= matchSet
+
+matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
+<matchSet(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match a string literal */
+lexerStringRef(string,label,elementIndex) ::= <%
+<if(label)>
+int <label>Start = CharIndex;<\n>
+Match(<string>); <checkRuleBacktrackFailure()><\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+Match(<string>); <checkRuleBacktrackFailure()><\n>
+<endif>
+%>
+
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
+<if(label)>
+<label>=(<labelType>)input.LT(1);<\n>
+<endif>
+MatchAny(input); <checkRuleBacktrackFailure()>
+>>
+
+wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<wildcard(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match . wildcard in lexer */
+wildcardChar(label, elementIndex) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+MatchAny(); <checkRuleBacktrackFailure()>
+>>
+
+wildcardCharListLabel(label, elementIndex) ::= <<
+<wildcardChar(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match a rule reference by invoking it possibly with arguments
+ *  and a return value or values.  The 'rule' argument was the
+ *  target rule name, but now is type Rule, whose toString is
+ *  same: the rule name.  Now though you can access full rule
+ *  descriptor stuff.
+ */
+ruleRef(rule,label,elementIndex,args,scope) ::= <<
+PushFollow(Follow._<rule.name>_in_<ruleName><elementIndex>);
+<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name; format="id">(<args; separator=", ">);
+PopFollow();
+<checkRuleBacktrackFailure()>
+>>
+
+/** ids+=r */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabelElem(elem=label,elemType={<ASTLabelType>},...)>
+>>
+
+/** A lexer rule reference.
+ *
+ *  The 'rule' argument was the target rule name, but now
+ *  is type Rule, whose toString is same: the rule name.
+ *  Now though you can access full rule descriptor stuff.
+ */
+lexerRuleRef(rule,label,args,elementIndex,scope) ::= <%
+<if(label)>
+int <label>Start<elementIndex> = CharIndex;<\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()><\n>
+<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
+<endif>
+%>
+
+/** i+=INT in lexer */
+lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
+<lexerRuleRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** EOF in the lexer */
+lexerMatchEOF(label,elementIndex) ::= <%
+<if(label)>
+int <label>Start<elementIndex> = CharIndex;<\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+Match(EOF); <checkRuleBacktrackFailure()><\n>
+<labelType> <label> = new <labelType>(input, EOF, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+Match(EOF); <checkRuleBacktrackFailure()>
+<endif>
+%>
+
+// used for left-recursive rules
+recRuleDefArg()                       ::= "int <recRuleArg()>"
+recRuleArg()                          ::= "_p"
+recRuleAltPredicate(ruleName,opPrec)  ::= "<recRuleArg()> \<= <opPrec>"
+recRuleSetResultAction()              ::= "root_0=$<ruleName>_primary.tree;"
+recRuleSetReturnAction(src,name)      ::= "$<name>=$<src>.<name>;"
+
+/** match ^(root children) in tree parser */
+tree(root, actionsAfterRoot, children, nullableChildList,
+     enclosingTreeLevel, treeLevel) ::= <<
+<root:element()>
+<actionsAfterRoot:element()>
+<if(nullableChildList)>
+if (input.LA(1) == TokenTypes.Down)
+{
+	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+	<children:element()>
+	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+}
+<else>
+Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+<children:element()>
+Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+<endif>
+>>
+
+/** Every predicate is used as a validating predicate (even when it is
+ *  also hoisted into a prediction expression).
+ */
+validateSemanticPredicate(pred,description) ::= <<
+if (!(<evalPredicate(...)>))
+{
+	<ruleBacktrackFailure()>
+	throw new FailedPredicateException(input, "<ruleName>", "<description>");
+}
+>>
+
+// F i x e d  D F A  (if-then-else)
+
+dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+<edges; separator="\nelse ">
+else
+{
+<if(eotPredictsAlt)>
+	alt<decisionNumber> = <eotPredictsAlt>;
+<else>
+	<ruleBacktrackFailure()>
+	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);
+	DebugRecognitionException(nvae);
+	<@noViableAltException()>
+	throw nvae;
+<endif>
+}
+>>
+
+/** Same as a normal DFA state except that we don't examine lookahead
+ *  for the bypass alternative.  It delays error detection but this
+ *  is faster, smaller, and more what people expect.  For (X)? people
+ *  expect "if ( LA(1)==X ) match(X);" and that's it.
+ */
+dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+<edges; separator="\nelse ">
+>>
+
+/** A DFA state that is actually the loopback decision of a closure
+ *  loop.  If end-of-token (EOT) predicts any of the targets then it
+ *  should act like a default clause (i.e., no error can be generated).
+ *  This is used only in the lexer so that for ('a')* on the end of a rule
+ *  anything other than 'a' predicts exiting.
+ */
+dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+<edges; separator="\nelse "><\n>
+<if(eotPredictsAlt)>
+<if(!edges)>
+alt<decisionNumber> = <eotPredictsAlt>;<! if no edges, don't gen ELSE !>
+<else>
+else
+{
+	alt<decisionNumber> = <eotPredictsAlt>;
+}<\n>
+<endif>
+<endif>
+>>
+
+/** An accept state indicates a unique alternative has been predicted */
+dfaAcceptState(alt) ::= "alt<decisionNumber> = <alt>;"
+
+/** A simple edge with an expression.  If the expression is satisfied,
+ *  enter to the target state.  To handle gated productions, we may
+ *  have to evaluate some predicates for this edge.
+ */
+dfaEdge(labelExpr, targetState, predicates) ::= <<
+if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>)
+{
+	<targetState>
+}
+>>
+
+// F i x e d  D F A  (switch case)
+
+/** A DFA state where a SWITCH may be generated.  The code generator
+ *  decides if this is possible: CodeGenerator.canGenerateSwitch().
+ */
+dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+default:
+<if(eotPredictsAlt)>
+	alt<decisionNumber>=<eotPredictsAlt>;
+	break;<\n>
+<else>
+	{
+		<ruleBacktrackFailure()>
+		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);
+		DebugRecognitionException(nvae);
+		<@noViableAltException()>
+		throw nvae;
+	}
+<endif>
+}<\n>
+>>
+
+dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+}<\n>
+>>
+
+dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+<if(eotPredictsAlt)>
+default:
+	alt<decisionNumber>=<eotPredictsAlt>;
+	break;<\n>
+<endif>
+}<\n>
+>>
+
+dfaEdgeSwitch(labels, targetState) ::= <<
+<labels:{it|case <it>:}; separator="\n">
+	{
+	<targetState>
+	}
+	break;
+>>
+
+// C y c l i c  D F A
+
+/** The code to initiate execution of a cyclic DFA; this is used
+ *  in the rule to predict an alt just like the fixed DFA case.
+ *  The <name> attribute is inherited via the parser, lexer, ...
+ */
+dfaDecision(decisionNumber,description) ::= <<
+try
+{
+	alt<decisionNumber> = dfa<decisionNumber>.Predict(input);
+}
+catch (NoViableAltException nvae)
+{
+	DebugRecognitionException(nvae);
+	throw;
+}
+>>
+
+/* Dump DFA tables as run-length-encoded Strings of octal values.
+ * Can't use hex as compiler translates them before compilation.
+ * These strings are split into multiple, concatenated strings.
+ * Java puts them back together at compile time thankfully.
+ * Java cannot handle large static arrays, so we're stuck with this
+ * encode/decode approach.  See analysis and runtime DFA for
+ * the encoding methods.
+ */
+cyclicDFA(dfa) ::= <<
+private class DFA<dfa.decisionNumber> : DFA
+{
+	private const string DFA<dfa.decisionNumber>_eotS =
+		"<dfa.javaCompressedEOT; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_eofS =
+		"<dfa.javaCompressedEOF; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_minS =
+		"<dfa.javaCompressedMin; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_maxS =
+		"<dfa.javaCompressedMax; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_acceptS =
+		"<dfa.javaCompressedAccept; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_specialS =
+		"<dfa.javaCompressedSpecial; wrap="\"+\n\t\t\"">}>";
+	private static readonly string[] DFA<dfa.decisionNumber>_transitionS =
+		{
+			<dfa.javaCompressedTransition:{s|"<s; wrap="\"+\n\"">"}; separator=",\n">
+		};
+
+	private static readonly short[] DFA<dfa.decisionNumber>_eot = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eotS);
+	private static readonly short[] DFA<dfa.decisionNumber>_eof = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eofS);
+	private static readonly char[] DFA<dfa.decisionNumber>_min = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_minS);
+	private static readonly char[] DFA<dfa.decisionNumber>_max = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_maxS);
+	private static readonly short[] DFA<dfa.decisionNumber>_accept = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_acceptS);
+	private static readonly short[] DFA<dfa.decisionNumber>_special = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_specialS);
+	private static readonly short[][] DFA<dfa.decisionNumber>_transition;
+
+	static DFA<dfa.decisionNumber>()
+	{
+		int numStates = DFA<dfa.decisionNumber>_transitionS.Length;
+		DFA<dfa.decisionNumber>_transition = new short[numStates][];
+		for ( int i=0; i \< numStates; i++ )
+		{
+			DFA<dfa.decisionNumber>_transition[i] = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_transitionS[i]);
+		}
+	}
+
+	public DFA<dfa.decisionNumber>( BaseRecognizer recognizer<if(dfa.specialStateSTs)>, SpecialStateTransitionHandler specialStateTransition<endif> )
+<if(dfa.specialStateSTs)>
+		: base(specialStateTransition)
+<endif>
+	{
+		this.recognizer = recognizer;
+		this.decisionNumber = <dfa.decisionNumber>;
+		this.eot = DFA<dfa.decisionNumber>_eot;
+		this.eof = DFA<dfa.decisionNumber>_eof;
+		this.min = DFA<dfa.decisionNumber>_min;
+		this.max = DFA<dfa.decisionNumber>_max;
+		this.accept = DFA<dfa.decisionNumber>_accept;
+		this.special = DFA<dfa.decisionNumber>_special;
+		this.transition = DFA<dfa.decisionNumber>_transition;
+	}
+
+	public override string Description { get { return "<dfa.description>"; } }
+
+	public override void Error(NoViableAltException nvae)
+	{
+		DebugRecognitionException(nvae);
+	}
+}<\n>
+<if(dfa.specialStateSTs)>
+private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStream _input)<! throws NoViableAltException!>
+{
+	<if(LEXER)>
+	IIntStream input = _input;
+	<endif>
+	<if(PARSER)>
+	ITokenStream input = (ITokenStream)_input;
+	<endif>
+	<if(TREE_PARSER)>
+	ITreeNodeStream input = (ITreeNodeStream)_input;
+	<endif>
+	int _s = s;
+	switch (s)
+	{
+	<dfa.specialStateSTs:{state |
+	case <i0>:<! compressed special state numbers 0..n-1 !>
+		<state>}; separator="\n">
+	}
+<if(backtracking)>
+	if (state.backtracking > 0) {state.failed=true; return -1;}
+<endif>
+	NoViableAltException nvae = new NoViableAltException(dfa.Description, <dfa.decisionNumber>, _s, input);
+	dfa.Error(nvae);
+	throw nvae;
+}
+<endif>
+>>
+
+/** A state in a cyclic DFA; it's a special state and part of a big switch on
+ *  state.
+ */
+cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
+int LA<decisionNumber>_<stateNumber> = input.LA(1);<\n>
+<if(semPredState)>
+<! get next lookahead symbol to test edges, then rewind !>
+<\n>int index<decisionNumber>_<stateNumber> = input.Index;
+input.Rewind();
+<endif>
+s = -1;
+<edges; separator="\nelse ">
+<if(semPredState)>
+<! return input cursor to state before we rewound !>
+<\n>input.Seek(index<decisionNumber>_<stateNumber>);
+<endif>
+if (s >= 0) return s;
+break;
+>>
+
+/** Just like a fixed DFA edge, test the lookahead and indicate what
+ *  state to jump to next if successful.
+ */
+cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
+if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
+>>
+
+/** An edge pointing at end-of-token; essentially matches any char;
+ *  always jump to the target.
+ */
+eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
+s = <targetStateNumber>;<\n>
+>>
+
+
+// D F A  E X P R E S S I O N S
+
+andPredicates(left,right) ::= "(<left>&&<right>)"
+
+orPredicates(operands) ::= "(<first(operands)><rest(operands):{o | ||<o>}>)"
+
+notPredicate(pred) ::= "!(<evalPredicate(...)>)"
+
+evalPredicate(pred,description) ::= "(<pred>)"
+
+evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"
+
+lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
+
+/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
+ *  somewhere.  Must ask for the lookahead directly.
+ */
+isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"
+
+lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
+(LA<decisionNumber>_<stateNumber><ge()><lower> && LA<decisionNumber>_<stateNumber><le()><upper>)
+%>
+
+isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"
+
+le() ::= "\<="
+ge() ::= ">="
+
+setTest(ranges) ::= <<
+<ranges; separator="||">
+>>
+
+// A T T R I B U T E S
+
+attributeScope(scope) ::= <<
+<if(scope.attributes)>
+protected sealed partial class <scope.name>_scope
+{
+	<scope.attributes:{it|public <it.decl>;}; separator="\n">
+}
+<if(scope.actions.scopeinit)>
+protected void <scope.name>_scopeInit( <scope.name>_scope scope )
+{
+	<scope.actions.scopeinit>
+}
+<else>
+protected virtual void <scope.name>_scopeInit( <scope.name>_scope scope ) {}
+<endif>
+<if(scope.actions.scopeafter)>
+protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
+{
+	<scope.actions.scopeafter>
+}
+<else>
+protected virtual void <scope.name>_scopeAfter( <scope.name>_scope scope ) {}
+<endif>
+protected readonly ListStack\<<scope.name>_scope\> <scope.name>_stack = new ListStack\<<scope.name>_scope\>();
+<endif>
+>>
+
+globalAttributeScope(scope) ::= <<
+<attributeScope(...)>
+>>
+
+ruleAttributeScope(scope) ::= <<
+<attributeScope(...)>
+>>
+
+returnStructName(it) ::= "<it.name>_return"
+
+returnType(ruleDescriptor) ::= <%
+<if(ruleDescriptor.returnScope.attributes && ruleDescriptor.hasMultipleReturnValues)>
+	<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
+<elseif(ruleDescriptor.hasMultipleReturnValues)>
+	<ruleReturnBaseType()>
+<elseif(ruleDescriptor.hasSingleReturnValue)>
+	<ruleDescriptor.singleValueReturnType>
+<else>
+	void
+<endif>
+%>
+
+/** Generate the C# type associated with a single or multiple return
+ *  values.
+ */
+ruleLabelType(referencedRule) ::= <%
+<if(referencedRule.returnScope.attributes&&referencedRule.hasMultipleReturnValues)>
+	<referencedRule.grammar.recognizerName>.<referencedRule:returnStructName()>
+<elseif(referencedRule.hasMultipleReturnValues)>
+	<ruleReturnBaseType()>
+<elseif(referencedRule.hasSingleReturnValue)>
+	<referencedRule.singleValueReturnType>
+<else>
+	void
+<endif>
+%>
+
+delegateName(it) ::= <<
+<if(it.label)><it.label><else>g<it.name><endif>
+>>
+
+/** Using a type to init value map, try to init a type; if not in table
+ *  must be an object, default value is "null".
+ */
+initValue(typeName) ::= <<
+default(<typeName>)
+>>
+
+/** Define a rule label including default value */
+ruleLabelDef(label) ::= <%
+<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> = <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;
+%>
+
+/** Define a return struct for a rule if the code needs to access its
+ *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
+ *  subgroups to stick in members.
+ */
+returnScope(scope) ::= <<
+<if(scope.attributes && ruleDescriptor.hasMultipleReturnValues)>
+<returnScopeModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> sealed partial class <ruleDescriptor:returnStructName()> : <ruleReturnBaseType()><@ruleReturnInterfaces()>
+{
+	<scope.attributes:{it|public <it.decl>;}; separator="\n">
+	<@ruleReturnMembers()>
+}
+<endif>
+>>
+
+ruleReturnBaseType() ::= <%
+<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>>
+%>
+
+@returnScope.ruleReturnMembers() ::= <<
+>>
+
+parameterScope(scope) ::= <<
+<scope.attributes:{it|<it.decl>}; separator=", ">
+>>
+
+parameterAttributeRef(attr) ::= <<
+<attr.name; format="id">
+>>
+
+parameterSetAttributeRef(attr,expr) ::= <<
+<attr.name; format="id"> =<expr>;
+>>
+
+scopeAttributeRef(scope,attr,index,negIndex) ::= <%
+<if(negIndex)>
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id">
+<else>
+<if(index)>
+<scope>_stack[<index>].<attr.name; format="id">
+<else>
+<scope>_stack.Peek().<attr.name; format="id">
+<endif>
+<endif>
+%>
+
+scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
+<if(negIndex)>
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id"> = <expr>;
+<else>
+<if(index)>
+<scope>_stack[<index>].<attr.name; format="id"> = <expr>;
+<else>
+<scope>_stack.Peek().<attr.name; format="id"> = <expr>;
+<endif>
+<endif>
+%>
+
+/** $x is either global scope or x is rule with dynamic scope; refers
+ *  to stack itself not top of stack.  This is useful for predicates
+ *  like {$function.Count>0 && $function::name.Equals("foo")}?
+ */
+isolatedDynamicScopeRef(scope) ::= "<scope>_stack"
+
+/** reference an attribute of rule; might only have single return value */
+ruleLabelRef(referencedRule,scope,attr) ::= <%
+<if(referencedRule.hasMultipleReturnValues)>
+(<scope>!=null?<scope>.<attr.name; format="id">:<initValue(attr.type)>)
+<else>
+<scope>
+<endif>
+%>
+
+returnAttributeRef(ruleDescriptor,attr) ::= <%
+<if(ruleDescriptor.hasMultipleReturnValues)>
+retval.<attr.name; format="id">
+<else>
+<attr.name; format="id">
+<endif>
+%>
+
+returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
+<if(ruleDescriptor.hasMultipleReturnValues)>
+retval.<attr.name; format="id"> =<expr>;
+<else>
+<attr.name; format="id"> =<expr>;
+<endif>
+%>
+
+/** How to translate $tokenLabel */
+tokenLabelRef(label) ::= "<label>"
+
+/** ids+=ID {$ids} or e+=expr {$e} */
+listLabelRef(label) ::= "list_<label>"
+
+
+// not sure the next are the right approach
+
+tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:null)"
+tokenLabelPropertyRef_type(scope,attr) ::= "(<scope>!=null?<scope>.Type:0)"
+tokenLabelPropertyRef_line(scope,attr) ::= "(<scope>!=null?<scope>.Line:0)"
+tokenLabelPropertyRef_pos(scope,attr) ::= "(<scope>!=null?<scope>.CharPositionInLine:0)"
+tokenLabelPropertyRef_channel(scope,attr) ::= "(<scope>!=null?<scope>.Channel:0)"
+tokenLabelPropertyRef_index(scope,attr) ::= "(<scope>!=null?<scope>.TokenIndex:0)"
+tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
+tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?int.Parse(<scope>.Text):0)"
+
+ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):default(<labelType>))"
+ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):default(<labelType>))"
+ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):default(<ASTLabelType>))"
+ruleLabelPropertyRef_text(scope,attr) ::= <%
+<if(TREE_PARSER)>
+(<scope>!=null?(input.TokenStream.ToString(
+  input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
+  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):null)
+<else>
+(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):null)
+<endif>
+%>
+
+ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?<scope>.Template:null)"
+
+/** Isolated $RULE ref ok in lexer as it's a Token */
+lexerRuleLabel(label) ::= "<label>"
+
+lexerRuleLabelPropertyRef_type(scope,attr) ::=
+    "(<scope>!=null?<scope>.Type:0)"
+
+lexerRuleLabelPropertyRef_line(scope,attr) ::=
+    "(<scope>!=null?<scope>.Line:0)"
+
+lexerRuleLabelPropertyRef_pos(scope,attr) ::=
+    "(<scope>!=null?<scope>.CharPositionInLine:-1)"
+
+lexerRuleLabelPropertyRef_channel(scope,attr) ::=
+    "(<scope>!=null?<scope>.Channel:0)"
+
+lexerRuleLabelPropertyRef_index(scope,attr) ::=
+    "(<scope>!=null?<scope>.TokenIndex:0)"
+
+lexerRuleLabelPropertyRef_text(scope,attr) ::=
+    "(<scope>!=null?<scope>.Text:null)"
+
+lexerRuleLabelPropertyRef_int(scope,attr) ::=
+    "(<scope>!=null?int.Parse(<scope>.Text):0)"
+
+// Somebody may ref $template or $tree or $stop within a rule:
+rulePropertyRef_start(scope,attr) ::= "retval.Start"
+rulePropertyRef_stop(scope,attr) ::= "retval.Stop"
+rulePropertyRef_tree(scope,attr) ::= "retval.Tree"
+rulePropertyRef_text(scope,attr) ::= <%
+<if(TREE_PARSER)>
+input.TokenStream.ToString(
+  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
+  input.TreeAdaptor.GetTokenStopIndex(retval.Start))
+<else>
+input.ToString(retval.Start,input.LT(-1))
+<endif>
+%>
+rulePropertyRef_st(scope,attr) ::= "retval.Template"
+
+lexerRulePropertyRef_text(scope,attr) ::= "Text"
+lexerRulePropertyRef_type(scope,attr) ::= "_type"
+lexerRulePropertyRef_line(scope,attr) ::= "state.tokenStartLine"
+lexerRulePropertyRef_pos(scope,attr) ::= "state.tokenStartCharPositionInLine"
+lexerRulePropertyRef_index(scope,attr) ::= "-1" // undefined token index in lexer
+lexerRulePropertyRef_channel(scope,attr) ::= "_channel"
+lexerRulePropertyRef_start(scope,attr) ::= "state.tokenStartCharIndex"
+lexerRulePropertyRef_stop(scope,attr) ::= "(CharIndex-1)"
+lexerRulePropertyRef_int(scope,attr) ::= "int.Parse(<scope>.Text)"
+
+// setting $st and $tree is allowed in local rule. everything else
+// is flagged as error
+ruleSetPropertyRef_tree(scope,attr,expr) ::= "retval.Tree = <expr>;"
+ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.Template =<expr>;"
+
+/** How to execute an action (only when not backtracking) */
+execAction(action) ::= <%
+<if(backtracking)>
+if (<actions.(actionScope).synpredgate>)<\n>
+{<\n>
+<@indentedAction()><\n>
+}
+<else>
+<action>
+<endif>
+%>
+
+@execAction.indentedAction() ::= <<
+	<action>
+>>
+
+/** How to always execute an action even when backtracking */
+execForcedAction(action) ::= "<action>"
+
+// M I S C (properties, etc...)
+
+bitset(name, words64) ::= <<
+public static readonly BitSet <name> = new BitSet(new ulong[]{<words64:{it|<it>UL};separator=",">});
+>>
+
+codeFileExtension() ::= ".cs"
+
+true_value() ::= "true"
+false_value() ::= "false"
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
new file mode 100644
index 0000000..efad5b5
--- /dev/null
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
@@ -0,0 +1,313 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/** Template overrides to add debugging to normal Java output;
+ *  If ASTs are built, then you'll also get ASTDbg.stg loaded.
+ */
+
+@outputFile.debugPreprocessor() ::= "#define ANTLR_DEBUG"
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+using Antlr.Runtime.Debug;
+using IOException = System.IO.IOException;
+>>
+
+@genericParser.members() ::= <<
+<if(grammar.grammarIsRoot)>
+public static readonly string[] ruleNames =
+	new string[]
+	{
+		"invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n	", separator=", ">
+	};<\n>
+<endif>
+<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
+	int ruleLevel = 0;
+	public virtual int RuleLevel { get { return ruleLevel; } }
+	public virtual void IncRuleLevel() { ruleLevel++; }
+	public virtual void DecRuleLevel() { ruleLevel--; }
+<if(profile)>
+	<ctorForProfilingRootGrammar()>
+<else>
+	<ctorForRootGrammar()>
+<endif>
+<ctorForPredefinedListener()>
+<else><! imported grammar !>
+	public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
+	public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
+	public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
+	<ctorForDelegateGrammar()>
+<endif>
+<if(profile)>
+public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
+{
+	int stopIndex = GetRuleMemoization(ruleIndex, input.Index);
+	((Profiler)dbg).ExamineRuleMemoization(input, ruleIndex, stopIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	return base.AlreadyParsedRule(input, ruleIndex);
+}<\n>
+public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
+{
+	((Profiler)dbg).Memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	base.Memoize(input, ruleIndex, ruleStartIndex);
+}<\n>
+<endif>
+protected virtual bool EvalPredicate( bool result, string predicate )
+{
+	dbg.SemanticPredicate( result, predicate );
+	return result;
+}<\n>
+>>
+
+ctorForRootGrammar() ::= <<
+<! bug: can't use <@super.members()> cut-n-paste instead !>
+<! Same except we add port number and profile stuff if root grammar !>
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
+	: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
+	: base( input, state )
+{
+	<parserCtorBody()>
+	<createListenerAndHandshake()>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<@finally()>
+}<\n>
+>>
+
+ctorForProfilingRootGrammar() ::= <<
+<! bug: can't use <@super.members()> cut-n-paste instead !>
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
+	: this( input, new Profiler(null), new RecognizerSharedState() )
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
+	: base( input, dbg, state )
+{
+	Profiler p = (Profiler)dbg;
+	p.setParser(this);
+	<parserCtorBody()>
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<@finally()>
+}
+<\n>
+>>
+
+/** Basically we don't want to set any dbg listeners are root will have it. */
+ctorForDelegateGrammar() ::= <<
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+	: base( input, dbg, state )
+{
+	<parserCtorBody()>
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>( input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+}<\n>
+>>
+
+ctorForPredefinedListener() ::= <<
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg )
+	<@superClassRef>: base( input, dbg, new RecognizerSharedState() )<@end>
+{
+<if(profile)>
+	Profiler p = (Profiler)dbg;
+	p.setParser(this);
+<endif>
+	<parserCtorBody()>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	<@finally()>
+}<\n>
+>>
+
+createListenerAndHandshake() ::= <<
+<if(TREE_PARSER)>
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, input.TreeAdaptor );<\n>
+<else>
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, null );<\n>
+<endif>
+DebugListener = proxy;
+try
+{
+	proxy.Handshake();
+}
+catch ( IOException ioe )
+{
+	ReportError( ioe );
+}
+>>
+
+@genericParser.superClassName() ::= "Debug<@super.superClassName()>"
+
+/*
+ * Many of the following rules were merged into CSharp2.stg.
+ */
+
+@rule.preamble() ::= <<
+if (RuleLevel == 0)
+	DebugListener.Commence();
+IncRuleLevel();
+>>
+//@rule.preamble() ::= <<
+//try
+//{
+//	dbg.EnterRule( GrammarFileName, "<ruleName>" );
+//	if ( RuleLevel == 0 )
+//	{
+//		dbg.Commence();
+//	}
+//	IncRuleLevel();
+//	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
+//>>
+
+@rule.postamble() ::= <<
+DecRuleLevel();
+if (RuleLevel == 0)
+	DebugListener.Terminate();
+>>
+//@rule.postamble() ::= <<
+//dbg.Location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
+//}
+//finally
+//{
+//	dbg.ExitRule( GrammarFileName, "<ruleName>" );
+//	DecRuleLevel();
+//	if ( RuleLevel == 0 )
+//	{
+//		dbg.Terminate();
+//	}
+//}<\n>
+//>>
+
+//@insertSynpreds.start() ::= "dbg.BeginBacktrack( state.backtracking );"
+//@insertSynpreds.stop() ::= "dbg.EndBacktrack( state.backtracking, success );"
+
+// Common debug event triggers used by region overrides below
+
+//enterSubRule() ::= <<
+//try
+//{
+//	dbg.EnterSubRule( <decisionNumber> );<\n>
+//>>
+
+//exitSubRule() ::= <<
+//}
+//finally
+//{
+//	dbg.ExitSubRule( <decisionNumber> );
+//}<\n>
+//>>
+
+//enterDecision() ::= <<
+//try
+//{
+//	dbg.EnterDecision( <decisionNumber> );<\n>
+//>>
+
+//exitDecision() ::= <<
+//}
+//finally
+//{
+//	dbg.ExitDecision( <decisionNumber> );
+//}<\n>
+//>>
+
+//enterAlt(n) ::= "dbg.EnterAlt( <n> );<\n>"
+
+// Region overrides that tell various constructs to add debugging triggers
+
+//@block.predecision() ::= "<enterSubRule()><enterDecision()>"
+
+//@block.postdecision() ::= "<exitDecision()>"
+
+//@block.postbranch() ::= "<exitSubRule()>"
+
+//@ruleBlock.predecision() ::= "<enterDecision()>"
+
+//@ruleBlock.postdecision() ::= "<exitDecision()>"
+
+//@ruleBlockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
+
+//@blockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
+
+//@positiveClosureBlock.preloop() ::= "<enterSubRule()>"
+
+//@positiveClosureBlock.postloop() ::= "<exitSubRule()>"
+
+//@positiveClosureBlock.predecision() ::= "<enterDecision()>"
+
+//@positiveClosureBlock.postdecision() ::= "<exitDecision()>"
+
+//@positiveClosureBlock.earlyExitException() ::=
+//	"dbg.RecognitionException( eee<decisionNumber> );<\n>"
+
+//@closureBlock.preloop() ::= "<enterSubRule()>"
+
+//@closureBlock.postloop() ::= "<exitSubRule()>"
+
+//@closureBlock.predecision() ::= "<enterDecision()>"
+
+//@closureBlock.postdecision() ::= "<exitDecision()>"
+
+//@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"
+
+//@element.prematch() ::=
+//	"dbg.Location( <it.line>, <it.pos> );"
+
+//@matchSet.mismatchedSetException() ::=
+//	"dbg.RecognitionException( mse );"
+
+//@dfaState.noViableAltException() ::= "dbg.RecognitionException( nvae );"
+
+//@dfaStateSwitch.noViableAltException() ::= "dbg.RecognitionException( nvae );"
+
+//dfaDecision(decisionNumber,description) ::= <<
+//try
+//{
+//	isCyclicDecision = true;
+//	<super.dfaDecision(...)>
+//}
+//catch ( NoViableAltException nvae )
+//{
+//	dbg.RecognitionException( nvae );
+//	throw nvae;
+//}
+//>>
+
+//@cyclicDFA.errorMethod() ::= <<
+//public override void Error( NoViableAltException nvae )
+//{
+//	((DebugParser)recognizer).dbg.RecognitionException( nvae );
+//}
+//>>
+
+/** Force predicate validation to trigger an event */
+evalPredicate(pred,description) ::= <<
+EvalPredicate(<pred>, "<description>")
+>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ST.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ST.stg
new file mode 100644
index 0000000..d6dd973
--- /dev/null
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/ST.stg
@@ -0,0 +1,171 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/** Template subgroup to add template rewrite output
+ *  If debugging, then you'll also get STDbg.stg loaded.
+ */
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+using Antlr.StringTemplate;
+using Antlr.StringTemplate.Language;
+<if(!backtracking)>
+using Hashtable = System.Collections.Hashtable;
+<endif>
+
+>>
+
+/** Add this to each rule's return value struct */
+@returnScope.ruleReturnMembers() ::= <<
+private StringTemplate _st;
+public StringTemplate Template { get { return _st; } set { _st = value; } }
+public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
+>>
+
+@genericParser.members() ::= <<
+<@super.members()>
+protected StringTemplateGroup templateLib = new StringTemplateGroup("<name>Templates", typeof(AngleBracketTemplateLexer) );
+
+public StringTemplateGroup TemplateLib
+{
+ 	get { return this.templateLib; }
+ 	set { this.templateLib = value; }
+}
+
+/// \<summary> Allows convenient multi-value initialization:
+///  "new STAttrMap().Add(...).Add(...)"
+/// \</summary>
+protected class STAttrMap : Hashtable
+{
+  public STAttrMap Add(string attrName, object value)
+  {
+    base.Add(attrName, value);
+    return this;
+  }
+  public STAttrMap Add(string attrName, int value)
+  {
+    base.Add(attrName, value);
+    return this;
+  }
+}
+>>
+
+/** x+=rule when output=template */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabel(elem=label+".Template",...)>
+>>
+
+rewriteTemplate(alts) ::= <<
+
+// TEMPLATE REWRITE
+<if(backtracking)>
+if ( <actions.(actionScope).synpredgate> )
+{
+  <alts:rewriteTemplateAlt(); separator="else ">
+  <if(rewriteMode)><replaceTextInLine()><endif>
+}
+<else>
+<alts:rewriteTemplateAlt(); separator="else ">
+<if(rewriteMode)><replaceTextInLine()><endif>
+<endif>
+>>
+
+replaceTextInLine() ::= <<
+<if(TREE_PARSER)>
+((TokenRewriteStream)input.TokenStream).Replace(
+  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
+  input.TreeAdaptor.GetTokenStopIndex(retval.Start),
+  retval.Template);
+<else>
+((TokenRewriteStream)input).Replace(
+  ((IToken)retval.Start).TokenIndex,
+  input.LT(-1).TokenIndex,
+  retval.Template);
+<endif>
+>>
+
+rewriteTemplateAlt() ::= <<
+// <it.description>
+<if(it.pred)>
+if (<it.pred>) {
+    retval.Template = <it.alt>;
+}<\n>
+<else>
+{
+    retval.Template = <it.alt>;
+}<\n>
+<endif>
+>>
+
+rewriteEmptyTemplate(alts) ::= <<
+null;
+>>
+
+/** Invoke a template with a set of attribute name/value pairs.
+ *  Set the value of the rule's template *after* having set
+ *  the attributes because the rule's template might be used as
+ *  an attribute to build a bigger template; you get a self-embedded
+ *  template.
+ */
+rewriteExternalTemplate(name,args) ::= <<
+templateLib.GetInstanceOf("<name>"<if(args)>,
+  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
+  <endif>)
+>>
+
+/** expr is a string expression that says what template to load */
+rewriteIndirectTemplate(expr,args) ::= <<
+templateLib.GetInstanceOf(<expr><if(args)>,
+  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
+  <endif>)
+>>
+
+/** Invoke an inline template with a set of attribute name/value pairs */
+rewriteInlineTemplate(args, template) ::= <<
+new StringTemplate(templateLib, "<template>"<if(args)>,
+  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
+  <endif>)
+>>
+
+/** plain -> {foo} action */
+rewriteAction(action) ::= <<
+<action>
+>>
+
+/** An action has %st.attrName=expr; or %{st}.attrName=expr; */
+actionSetAttribute(st,attrName,expr) ::= <<
+(<st>).SetAttribute("<attrName>",<expr>);
+>>
+
+/** Translate %{stringExpr} */
+actionStringConstructor(stringExpr) ::= <<
+new StringTemplate(templateLib,<stringExpr>)
+>>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index a5da1f7..bae33a1 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -73,6 +73,7 @@ outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
<@imports>
using System.Collections.Generic;
using Antlr.Runtime;
+using Antlr.Runtime.Misc;
<if(TREE_PARSER)>
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
@@ -1430,7 +1431,7 @@ protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
<else>
partial void <scope.name>_scopeAfter( <scope.name>_scope scope );
<endif>
-protected readonly Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.name>_scope\>();
+protected readonly ListStack\<<scope.name>_scope\> <scope.name>_stack = new ListStack\<<scope.name>_scope\>();
<endif>
>>

@@ -1524,10 +1525,10 @@ parameterSetAttributeRef(attr,expr) ::= <<

scopeAttributeRef(scope,attr,index,negIndex) ::= <%
<if(negIndex)>
-System.Linq.Enumerable.ElementAt(<scope>_stack, <negIndex>).<attr.name; format="id">
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id">
<else>
<if(index)>
-System.Linq.Enumerable.ElementAt(<scope>_stack, <scope>_stack.Count-<index>-1).<attr.name; format="id">
+<scope>_stack[<index>].<attr.name; format="id">
<else>
<scope>_stack.Peek().<attr.name; format="id">
<endif>
@@ -1536,10 +1537,10 @@ System.Linq.Enumerable.ElementAt(<scope>_stack, <scope>_stack.Count-<index>-1).<

scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
<if(negIndex)>
-System.Linq.Enumerable.ElementAt(<scope>_stack, <negIndex>).<attr.name; format="id"> = <expr>;
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id"> = <expr>;
<else>
<if(index)>
-System.Linq.Enumerable.ElementAt(<scope>_stack, <scope>_stack.Count-<index>-1).<attr.name; format="id"> = <expr>;
+<scope>_stack[<index>].<attr.name; format="id"> = <expr>;
<else>
<scope>_stack.Peek().<attr.name; format="id"> = <expr>;
<endif>
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll
new file mode 100644
index 0000000..b066b60
Binary files /dev/null and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll differ
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index d7d6b05..2689779 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ

