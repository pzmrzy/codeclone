commit 671c8c496da55cff08728939abda10bbb69f23a4
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Tue Mar 17 01:59:16 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Tue Mar 17 01:59:16 2009 -0800

C# Port:
* Grammar optimizations, including remove support for line-scanning in Group.g3

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 5898]

diff --git a/Antlr3.StringTemplate/Language/Action.g3 b/Antlr3.StringTemplate/Language/Action.g3
index 28a8a80..8a9f78e 100644
--- a/Antlr3.StringTemplate/Language/Action.g3
+++ b/Antlr3.StringTemplate/Language/Action.g3
@@ -308,10 +308,12 @@ indirectTemplate!
;

argList!
-	:	LPAREN RPAREN -> ARGS["ARGS"] // view()
-	|	(singleArg)=>singleArg -> singleArg						  // bold(name)
-	|	LPAREN argumentAssignment (COMMA argumentAssignment)* RPAREN
-		-> ^(ARGS["ARGS"] argumentAssignment+)
+	:	LPAREN
+		(	argumentAssignment (COMMA argumentAssignment)*
+		)?
+		RPAREN
+		-> ^(ARGS["ARGS"] argumentAssignment*)
+	|	singleArg // bold(name)
;

singleArg
diff --git a/Antlr3.StringTemplate/Language/ActionLexer.cs b/Antlr3.StringTemplate/Language/ActionLexer.cs
index c9a3cd3..475d6ab 100644
--- a/Antlr3.StringTemplate/Language/ActionLexer.cs
+++ b/Antlr3.StringTemplate/Language/ActionLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Action.g3 2009-03-16 18:28:08
+// $ANTLR 3.1.2 Language\\Action.g3 2009-03-16 19:22:22

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -330,8 +330,8 @@ public partial class ActionLexer : Lexer
{
int _type = ID;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:333:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )* )
-			// Language\\Action.g3:333:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
+			// Language\\Action.g3:335:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )* )
+			// Language\\Action.g3:335:4: ( 'a' .. 'z' | 'A' .. 'Z' | '_' ) ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
{
if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
{
@@ -345,7 +345,7 @@ public partial class ActionLexer : Lexer
Recover(mse);
throw mse;}

-			// Language\\Action.g3:333:28: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
+			// Language\\Action.g3:335:28: ( 'a' .. 'z' | 'A' .. 'Z' | '0' .. '9' | '_' | '/' )*
for ( ; ; )
{
int alt1=2;
@@ -396,10 +396,10 @@ public partial class ActionLexer : Lexer
{
int _type = INT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:337:4: ( ( '0' .. '9' )+ )
-			// Language\\Action.g3:337:4: ( '0' .. '9' )+
+			// Language\\Action.g3:339:4: ( ( '0' .. '9' )+ )
+			// Language\\Action.g3:339:4: ( '0' .. '9' )+
{
-			// Language\\Action.g3:337:4: ( '0' .. '9' )+
+			// Language\\Action.g3:339:4: ( '0' .. '9' )+
int cnt2=0;
for ( ; ; )
{
@@ -462,11 +462,11 @@ public partial class ActionLexer : Lexer
char uc = '\0';
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Action.g3:346:4: ( '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"' )
-			// Language\\Action.g3:346:4: '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"'
+			// Language\\Action.g3:348:4: ( '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"' )
+			// Language\\Action.g3:348:4: '\"' ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )* '\"'
{
Match('\"'); if (state.failed) return ;
-			// Language\\Action.g3:347:3: ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )*
+			// Language\\Action.g3:349:3: ( ESC_CHAR[out uc, true] |ch=~ ( '\\\\' | '\"' ) )*
for ( ; ; )
{
int alt3=3;
@@ -485,7 +485,7 @@ public partial class ActionLexer : Lexer
switch ( alt3 )
{
case 1:
-					// Language\\Action.g3:347:5: ESC_CHAR[out uc, true]
+					// Language\\Action.g3:349:5: ESC_CHAR[out uc, true]
{
mESC_CHAR(out uc, true); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -496,7 +496,7 @@ public partial class ActionLexer : Lexer
}
break;
case 2:
-					// Language\\Action.g3:348:5: ch=~ ( '\\\\' | '\"' )
+					// Language\\Action.g3:350:5: ch=~ ( '\\\\' | '\"' )
{
ch= input.LA(1);
input.Consume();
@@ -554,17 +554,17 @@ public partial class ActionLexer : Lexer
string subtext = string.Empty;
char uc = '\0';

-			// Language\\Action.g3:365:4: ( '{' (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |) (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}' )
-			// Language\\Action.g3:365:4: '{' (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |) (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}'
+			// Language\\Action.g3:367:4: ( '{' (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |) (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}' )
+			// Language\\Action.g3:367:4: '{' (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |) (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )* '}'
{
Match('{'); if (state.failed) return ;
-			// Language\\Action.g3:366:3: (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |)
+			// Language\\Action.g3:368:3: (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |)
int alt5=2;
alt5 = dfa5.Predict(input);
switch ( alt5 )
{
case 1:
-				// Language\\Action.g3:366:5: => TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )?
+				// Language\\Action.g3:368:5: => TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )?
{

mTEMPLATE_ARGS(out subtext, args); if (state.failed) return ;
@@ -572,7 +572,7 @@ public partial class ActionLexer : Lexer
{
builder.Append(subtext);
}
-				// Language\\Action.g3:366:82: (=> WS_CHAR )?
+				// Language\\Action.g3:368:82: (=> WS_CHAR )?
int alt4=2;
int LA4_0 = input.LA(1);

@@ -588,7 +588,7 @@ public partial class ActionLexer : Lexer
switch ( alt4 )
{
case 1:
-					// Language\\Action.g3:366:83: => WS_CHAR
+					// Language\\Action.g3:368:83: => WS_CHAR
{

mWS_CHAR(); if (state.failed) return ;
@@ -611,7 +611,7 @@ public partial class ActionLexer : Lexer
}
break;
case 2:
-				// Language\\Action.g3:374:3:
+				// Language\\Action.g3:376:3:
{


@@ -620,7 +620,7 @@ public partial class ActionLexer : Lexer

}

-			// Language\\Action.g3:375:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*
+			// Language\\Action.g3:377:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*
for ( ; ; )
{
int alt6=6;
@@ -628,7 +628,7 @@ public partial class ActionLexer : Lexer
switch ( alt6 )
{
case 1:
-					// Language\\Action.g3:375:5: => '\\\\{'
+					// Language\\Action.g3:377:5: => '\\\\{'
{

Match("\\{"); if (state.failed) return ;
@@ -641,7 +641,7 @@ public partial class ActionLexer : Lexer
}
break;
case 2:
-					// Language\\Action.g3:376:5: => '\\\\}'
+					// Language\\Action.g3:378:5: => '\\\\}'
{

Match("\\}"); if (state.failed) return ;
@@ -654,7 +654,7 @@ public partial class ActionLexer : Lexer
}
break;
case 3:
-					// Language\\Action.g3:377:5: ESC_CHAR[out uc, false]
+					// Language\\Action.g3:379:5: ESC_CHAR[out uc, false]
{
int ESC_CHAR1Start300 = GetCharIndex();
mESC_CHAR(out uc, false); if (state.failed) return ;
@@ -667,7 +667,7 @@ public partial class ActionLexer : Lexer
}
break;
case 4:
-					// Language\\Action.g3:378:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
+					// Language\\Action.g3:380:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
{
mNESTED_ANONYMOUS_TEMPLATE(out subtext); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -678,7 +678,7 @@ public partial class ActionLexer : Lexer
}
break;
case 5:
-					// Language\\Action.g3:379:5: ch=~ ( '\\\\' | '{' | '}' )
+					// Language\\Action.g3:381:5: ch=~ ( '\\\\' | '{' | '}' )
{
ch= input.LA(1);
input.Consume();
@@ -733,10 +733,10 @@ public partial class ActionLexer : Lexer
_text = string.Empty; // this template is empty text
args.Clear();

-			// Language\\Action.g3:397:4: ( ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|' )
-			// Language\\Action.g3:397:4: ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|'
+			// Language\\Action.g3:399:4: ( ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|' )
+			// Language\\Action.g3:399:4: ( WS_CHAR )? a= ID ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )* ( WS_CHAR )? '|'
{
-			// Language\\Action.g3:397:4: ( WS_CHAR )?
+			// Language\\Action.g3:399:4: ( WS_CHAR )?
int alt7=2;
int LA7_0 = input.LA(1);

@@ -764,7 +764,7 @@ public partial class ActionLexer : Lexer
{
args.Add((a!=null?a.Text:null));
}
-			// Language\\Action.g3:398:3: ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )*
+			// Language\\Action.g3:400:3: ( ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID )*
for ( ; ; )
{
int alt10=2;
@@ -790,9 +790,9 @@ public partial class ActionLexer : Lexer
switch ( alt10 )
{
case 1:
-					// Language\\Action.g3:398:5: ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID
+					// Language\\Action.g3:400:5: ( WS_CHAR )? ',' ( WS_CHAR )? a2= ID
{
-					// Language\\Action.g3:398:5: ( WS_CHAR )?
+					// Language\\Action.g3:400:5: ( WS_CHAR )?
int alt8=2;
int LA8_0 = input.LA(1);

@@ -814,7 +814,7 @@ public partial class ActionLexer : Lexer
}

Match(','); if (state.failed) return ;
-					// Language\\Action.g3:398:20: ( WS_CHAR )?
+					// Language\\Action.g3:400:20: ( WS_CHAR )?
int alt9=2;
int LA9_0 = input.LA(1);

@@ -855,7 +855,7 @@ public partial class ActionLexer : Lexer
;


-			// Language\\Action.g3:399:3: ( WS_CHAR )?
+			// Language\\Action.g3:401:3: ( WS_CHAR )?
int alt11=2;
int LA11_0 = input.LA(1);

@@ -901,15 +901,15 @@ public partial class ActionLexer : Lexer
string subtext = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Action.g3:411:4: ( '{' (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}' )
-			// Language\\Action.g3:411:4: '{' (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}'
+			// Language\\Action.g3:413:4: ( '{' (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}' )
+			// Language\\Action.g3:413:4: '{' (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )* '}'
{
Match('{'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
builder.Append('{');
}
-			// Language\\Action.g3:413:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*
+			// Language\\Action.g3:415:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*
for ( ; ; )
{
int alt12=6;
@@ -917,7 +917,7 @@ public partial class ActionLexer : Lexer
switch ( alt12 )
{
case 1:
-					// Language\\Action.g3:413:5: => '\\\\{'
+					// Language\\Action.g3:415:5: => '\\\\{'
{

Match("\\{"); if (state.failed) return ;
@@ -930,7 +930,7 @@ public partial class ActionLexer : Lexer
}
break;
case 2:
-					// Language\\Action.g3:414:5: => '\\\\}'
+					// Language\\Action.g3:416:5: => '\\\\}'
{

Match("\\}"); if (state.failed) return ;
@@ -943,7 +943,7 @@ public partial class ActionLexer : Lexer
}
break;
case 3:
-					// Language\\Action.g3:415:5: ESC_CHAR[out uc, false]
+					// Language\\Action.g3:417:5: ESC_CHAR[out uc, false]
{
int ESC_CHAR2Start460 = GetCharIndex();
mESC_CHAR(out uc, false); if (state.failed) return ;
@@ -956,7 +956,7 @@ public partial class ActionLexer : Lexer
}
break;
case 4:
-					// Language\\Action.g3:416:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
+					// Language\\Action.g3:418:5: NESTED_ANONYMOUS_TEMPLATE[out subtext]
{
mNESTED_ANONYMOUS_TEMPLATE(out subtext); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -967,7 +967,7 @@ public partial class ActionLexer : Lexer
}
break;
case 5:
-					// Language\\Action.g3:417:5: ch=~ ( '{' | '}' | '\\\\' )
+					// Language\\Action.g3:419:5: ch=~ ( '{' | '}' | '\\\\' )
{
ch= input.LA(1);
input.Consume();
@@ -1017,11 +1017,11 @@ public partial class ActionLexer : Lexer

uc = '\0';

-			// Language\\Action.g3:438:4: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) ) )
-			// Language\\Action.g3:438:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
+			// Language\\Action.g3:440:4: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) ) )
+			// Language\\Action.g3:440:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
{
Match('\\'); if (state.failed) return ;
-			// Language\\Action.g3:439:3: ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
+			// Language\\Action.g3:441:3: ( 'n' | 'r' | 't' | 'b' | 'f' |c=~ ( 'n' | 'r' | 't' | 'b' | 'f' ) )
int alt13=6;
int LA13_0 = input.LA(1);

@@ -1059,7 +1059,7 @@ public partial class ActionLexer : Lexer
switch ( alt13 )
{
case 1:
-				// Language\\Action.g3:439:5: 'n'
+				// Language\\Action.g3:441:5: 'n'
{
Match('n'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1070,7 +1070,7 @@ public partial class ActionLexer : Lexer
}
break;
case 2:
-				// Language\\Action.g3:440:5: 'r'
+				// Language\\Action.g3:442:5: 'r'
{
Match('r'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1081,7 +1081,7 @@ public partial class ActionLexer : Lexer
}
break;
case 3:
-				// Language\\Action.g3:441:5: 't'
+				// Language\\Action.g3:443:5: 't'
{
Match('t'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1092,7 +1092,7 @@ public partial class ActionLexer : Lexer
}
break;
case 4:
-				// Language\\Action.g3:442:5: 'b'
+				// Language\\Action.g3:444:5: 'b'
{
Match('b'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1103,7 +1103,7 @@ public partial class ActionLexer : Lexer
}
break;
case 5:
-				// Language\\Action.g3:443:5: 'f'
+				// Language\\Action.g3:445:5: 'f'
{
Match('f'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1114,7 +1114,7 @@ public partial class ActionLexer : Lexer
}
break;
case 6:
-				// Language\\Action.g3:444:5: c=~ ( 'n' | 'r' | 't' | 'b' | 'f' )
+				// Language\\Action.g3:446:5: c=~ ( 'n' | 'r' | 't' | 'b' | 'f' )
{
c= input.LA(1);
input.Consume();
@@ -1146,8 +1146,8 @@ public partial class ActionLexer : Lexer
{
int _type = LBRACK;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:444:11: ( '[' )
-			// Language\\Action.g3:444:11: '['
+			// Language\\Action.g3:446:11: ( '[' )
+			// Language\\Action.g3:446:11: '['
{
Match('['); if (state.failed) return ;

@@ -1169,8 +1169,8 @@ public partial class ActionLexer : Lexer
{
int _type = RBRACK;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:445:11: ( ']' )
-			// Language\\Action.g3:445:11: ']'
+			// Language\\Action.g3:447:11: ( ']' )
+			// Language\\Action.g3:447:11: ']'
{
Match(']'); if (state.failed) return ;

@@ -1192,8 +1192,8 @@ public partial class ActionLexer : Lexer
{
int _type = LPAREN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:446:11: ( '(' )
-			// Language\\Action.g3:446:11: '('
+			// Language\\Action.g3:448:11: ( '(' )
+			// Language\\Action.g3:448:11: '('
{
Match('('); if (state.failed) return ;

@@ -1215,8 +1215,8 @@ public partial class ActionLexer : Lexer
{
int _type = RPAREN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:447:11: ( ')' )
-			// Language\\Action.g3:447:11: ')'
+			// Language\\Action.g3:449:11: ( ')' )
+			// Language\\Action.g3:449:11: ')'
{
Match(')'); if (state.failed) return ;

@@ -1238,8 +1238,8 @@ public partial class ActionLexer : Lexer
{
int _type = COMMA;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:448:10: ( ',' )
-			// Language\\Action.g3:448:10: ','
+			// Language\\Action.g3:450:10: ( ',' )
+			// Language\\Action.g3:450:10: ','
{
Match(','); if (state.failed) return ;

@@ -1261,8 +1261,8 @@ public partial class ActionLexer : Lexer
{
int _type = DOT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:449:9: ( '.' )
-			// Language\\Action.g3:449:9: '.'
+			// Language\\Action.g3:451:9: ( '.' )
+			// Language\\Action.g3:451:9: '.'
{
Match('.'); if (state.failed) return ;

@@ -1284,8 +1284,8 @@ public partial class ActionLexer : Lexer
{
int _type = ASSIGN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:450:11: ( '=' )
-			// Language\\Action.g3:450:11: '='
+			// Language\\Action.g3:452:11: ( '=' )
+			// Language\\Action.g3:452:11: '='
{
Match('='); if (state.failed) return ;

@@ -1307,8 +1307,8 @@ public partial class ActionLexer : Lexer
{
int _type = COLON;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:451:10: ( ':' )
-			// Language\\Action.g3:451:10: ':'
+			// Language\\Action.g3:453:10: ( ':' )
+			// Language\\Action.g3:453:10: ':'
{
Match(':'); if (state.failed) return ;

@@ -1330,8 +1330,8 @@ public partial class ActionLexer : Lexer
{
int _type = PLUS;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:452:9: ( '+' )
-			// Language\\Action.g3:452:9: '+'
+			// Language\\Action.g3:454:9: ( '+' )
+			// Language\\Action.g3:454:9: '+'
{
Match('+'); if (state.failed) return ;

@@ -1353,8 +1353,8 @@ public partial class ActionLexer : Lexer
{
int _type = SEMI;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:453:9: ( ';' )
-			// Language\\Action.g3:453:9: ';'
+			// Language\\Action.g3:455:9: ( ';' )
+			// Language\\Action.g3:455:9: ';'
{
Match(';'); if (state.failed) return ;

@@ -1376,8 +1376,8 @@ public partial class ActionLexer : Lexer
{
int _type = NOT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:454:9: ( '!' )
-			// Language\\Action.g3:454:9: '!'
+			// Language\\Action.g3:456:9: ( '!' )
+			// Language\\Action.g3:456:9: '!'
{
Match('!'); if (state.failed) return ;

@@ -1399,8 +1399,8 @@ public partial class ActionLexer : Lexer
{
int _type = DOTDOTDOT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:455:13: ( '...' )
-			// Language\\Action.g3:455:13: '...'
+			// Language\\Action.g3:457:13: ( '...' )
+			// Language\\Action.g3:457:13: '...'
{
Match("..."); if (state.failed) return ;

@@ -1423,10 +1423,10 @@ public partial class ActionLexer : Lexer
{
int _type = WS;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Action.g3:458:4: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
-			// Language\\Action.g3:458:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
+			// Language\\Action.g3:460:4: ( ( ' ' | '\\t' | '\\r' | '\\n' )+ )
+			// Language\\Action.g3:460:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
{
-			// Language\\Action.g3:458:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
+			// Language\\Action.g3:460:4: ( ' ' | '\\t' | '\\r' | '\\n' )+
int cnt14=0;
for ( ; ; )
{
@@ -1485,7 +1485,7 @@ public partial class ActionLexer : Lexer
{
try
{
-			// Language\\Action.g3:465:4: ( ' ' | '\\t' | '\\r' | '\\n' )
+			// Language\\Action.g3:467:4: ( ' ' | '\\t' | '\\r' | '\\n' )
// Language\\Action.g3:
{
if ( (input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ' )
@@ -1707,10 +1707,10 @@ public partial class ActionLexer : Lexer
// $ANTLR start synpred1_Action
public void synpred1_Action_fragment()
{
-		// Language\\Action.g3:366:5: ( ( WS_CHAR )? ID )
-		// Language\\Action.g3:366:6: ( WS_CHAR )? ID
+		// Language\\Action.g3:368:5: ( ( WS_CHAR )? ID )
+		// Language\\Action.g3:368:6: ( WS_CHAR )? ID
{
-		// Language\\Action.g3:366:6: ( WS_CHAR )?
+		// Language\\Action.g3:368:6: ( WS_CHAR )?
int alt16=2;
int LA16_0 = input.LA(1);

@@ -1750,7 +1750,7 @@ public partial class ActionLexer : Lexer
// $ANTLR start synpred2_Action
public void synpred2_Action_fragment()
{
-		// Language\\Action.g3:366:83: ( WS_CHAR )
+		// Language\\Action.g3:368:83: ( WS_CHAR )
// Language\\Action.g3:
{
if ( (input.LA(1)>='\t' && input.LA(1)<='\n')||input.LA(1)=='\r'||input.LA(1)==' ' )
@@ -1773,8 +1773,8 @@ public partial class ActionLexer : Lexer
// $ANTLR start synpred3_Action
public void synpred3_Action_fragment()
{
-		// Language\\Action.g3:375:5: ( '\\\\{' )
-		// Language\\Action.g3:375:6: '\\\\{'
+		// Language\\Action.g3:377:5: ( '\\\\{' )
+		// Language\\Action.g3:377:6: '\\\\{'
{
Match("\\{"); if (state.failed) return ;

@@ -1786,8 +1786,8 @@ public partial class ActionLexer : Lexer
// $ANTLR start synpred4_Action
public void synpred4_Action_fragment()
{
-		// Language\\Action.g3:376:5: ( '\\\\}' )
-		// Language\\Action.g3:376:6: '\\\\}'
+		// Language\\Action.g3:378:5: ( '\\\\}' )
+		// Language\\Action.g3:378:6: '\\\\}'
{
Match("\\}"); if (state.failed) return ;

@@ -1799,8 +1799,8 @@ public partial class ActionLexer : Lexer
// $ANTLR start synpred5_Action
public void synpred5_Action_fragment()
{
-		// Language\\Action.g3:413:5: ( '\\\\{' )
-		// Language\\Action.g3:413:6: '\\\\{'
+		// Language\\Action.g3:415:5: ( '\\\\{' )
+		// Language\\Action.g3:415:6: '\\\\{'
{
Match("\\{"); if (state.failed) return ;

@@ -1812,8 +1812,8 @@ public partial class ActionLexer : Lexer
// $ANTLR start synpred6_Action
public void synpred6_Action_fragment()
{
-		// Language\\Action.g3:414:5: ( '\\\\}' )
-		// Language\\Action.g3:414:6: '\\\\}'
+		// Language\\Action.g3:416:5: ( '\\\\}' )
+		// Language\\Action.g3:416:6: '\\\\}'
{
Match("\\}"); if (state.failed) return ;

@@ -2018,7 +2018,7 @@ public partial class ActionLexer : Lexer
}
public override string GetDescription()
{
-			return "366:3: (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |)";
+			return "368:3: (=> TEMPLATE_ARGS[out subtext, args] (=> WS_CHAR )? |)";
}
}

@@ -2253,7 +2253,7 @@ public partial class ActionLexer : Lexer
}
public override string GetDescription()
{
-			return "()* loopback of 375:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*";
+			return "()* loopback of 377:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '\\\\' | '{' | '}' ) )*";
}
}

@@ -2390,7 +2390,7 @@ public partial class ActionLexer : Lexer
}
public override string GetDescription()
{
-			return "()* loopback of 413:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*";
+			return "()* loopback of 415:3: (=> '\\\\{' |=> '\\\\}' | ESC_CHAR[out uc, false] | NESTED_ANONYMOUS_TEMPLATE[out subtext] |ch=~ ( '{' | '}' | '\\\\' ) )*";
}
}

diff --git a/Antlr3.StringTemplate/Language/ActionParser.cs b/Antlr3.StringTemplate/Language/ActionParser.cs
index 98e5a38..2458147 100644
--- a/Antlr3.StringTemplate/Language/ActionParser.cs
+++ b/Antlr3.StringTemplate/Language/ActionParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Action.g3 2009-03-16 18:28:08
+// $ANTLR 3.1.2 Language\\Action.g3 2009-03-16 19:22:22

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -3130,7 +3130,7 @@ public partial class ActionParser : Parser
}

// $ANTLR start "argList"
-	// Language\\Action.g3:310:0: argList : ( LPAREN RPAREN -> ARGS[\"ARGS\"] |=> singleArg -> singleArg | LPAREN argumentAssignment ( COMMA argumentAssignment )* RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )+ ) );
+	// Language\\Action.g3:310:0: argList : ( LPAREN ( argumentAssignment ( COMMA argumentAssignment )* )? RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )* ) | singleArg );
private ActionParser.argList_return argList(  )
{
ActionParser.argList_return retval = new ActionParser.argList_return();
@@ -3139,157 +3139,163 @@ public partial class ActionParser : Parser
StringTemplateAST root_0 = null;

IToken LPAREN79=null;
-		IToken RPAREN80=null;
-		IToken LPAREN82=null;
-		IToken COMMA84=null;
-		IToken RPAREN86=null;
-		ActionParser.singleArg_return singleArg81 = default(ActionParser.singleArg_return);
-		ActionParser.argumentAssignment_return argumentAssignment83 = default(ActionParser.argumentAssignment_return);
-		ActionParser.argumentAssignment_return argumentAssignment85 = default(ActionParser.argumentAssignment_return);
+		IToken COMMA81=null;
+		IToken RPAREN83=null;
+		ActionParser.argumentAssignment_return argumentAssignment80 = default(ActionParser.argumentAssignment_return);
+		ActionParser.argumentAssignment_return argumentAssignment82 = default(ActionParser.argumentAssignment_return);
+		ActionParser.singleArg_return singleArg84 = default(ActionParser.singleArg_return);

StringTemplateAST LPAREN79_tree=null;
-		StringTemplateAST RPAREN80_tree=null;
-		StringTemplateAST LPAREN82_tree=null;
-		StringTemplateAST COMMA84_tree=null;
-		StringTemplateAST RPAREN86_tree=null;
+		StringTemplateAST COMMA81_tree=null;
+		StringTemplateAST RPAREN83_tree=null;
RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
-		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
-		RewriteRuleSubtreeStream stream_singleArg=new RewriteRuleSubtreeStream(adaptor,"rule singleArg");
+		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
RewriteRuleSubtreeStream stream_argumentAssignment=new RewriteRuleSubtreeStream(adaptor,"rule argumentAssignment");
try
{
-			// Language\\Action.g3:311:4: ( LPAREN RPAREN -> ARGS[\"ARGS\"] |=> singleArg -> singleArg | LPAREN argumentAssignment ( COMMA argumentAssignment )* RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )+ ) )
-			int alt24=3;
-			alt24 = dfa24.Predict(input);
-			switch ( alt24 )
+			// Language\\Action.g3:311:4: ( LPAREN ( argumentAssignment ( COMMA argumentAssignment )* )? RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )* ) | singleArg )
+			int alt25=2;
+			int LA25_0 = input.LA(1);
+
+			if ( (LA25_0==LPAREN) )
{
-			case 1:
-				// Language\\Action.g3:311:4: LPAREN RPAREN
+				switch ( input.LA(2) )
{
-				LPAREN79=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1053); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN79);
-
-				RPAREN80=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1055); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN80);
-
-
+				case ID:
+					{
+					int LA25_2 = input.LA(3);

-				{
-				// AST REWRITE
-				// elements:
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
+					if ( (LA25_2==ASSIGN) )
+					{
+						alt25=1;
+					}
+					else if ( (LA25_2==COLON||LA25_2==DOT||LA25_2==LPAREN||LA25_2==PLUS||LA25_2==RPAREN) )
+					{
+						alt25=2;
+					}
+					else
+					{
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae = new NoViableAltException("", 25, 2, input);

-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 311:18: -> ARGS[\"ARGS\"]
-				{
-					adaptor.AddChild(root_0, (StringTemplateAST)adaptor.Create(ARGS, "ARGS"));
+						throw nvae;
+					}
+					}
+					break;
+				case DOTDOTDOT:
+				case RPAREN:
+					{
+					alt25=1;
+					}
+					break;
+				case ANONYMOUS_TEMPLATE:
+				case FIRST:
+				case INT:
+				case LAST:
+				case LBRACK:
+				case LENGTH:
+				case LPAREN:
+				case REST:
+				case STRING:
+				case STRIP:
+				case SUPER:
+				case TRUNC:
+					{
+					alt25=2;
+					}
+					break;
+				default:
+					{
+						if (state.backtracking>0) {state.failed=true; return retval;}
+						NoViableAltException nvae = new NoViableAltException("", 25, 1, input);

+						throw nvae;
+					}
}

-				retval.tree = root_0;
-				}
-				}
+			}
+			else
+			{
+				if (state.backtracking>0) {state.failed=true; return retval;}
+				NoViableAltException nvae = new NoViableAltException("", 25, 0, input);

-				}
-				break;
-			case 2:
-				// Language\\Action.g3:312:4: => singleArg
+				throw nvae;
+			}
+			switch ( alt25 )
+			{
+			case 1:
+				// Language\\Action.g3:311:4: LPAREN ( argumentAssignment ( COMMA argumentAssignment )* )? RPAREN
{
+				LPAREN79=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1053); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN79);

-				PushFollow(Follow._singleArg_in_argList1070);
-				singleArg81=singleArg();
-
-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_singleArg.Add(singleArg81.Tree);
-
+				// Language\\Action.g3:312:3: ( argumentAssignment ( COMMA argumentAssignment )* )?
+				int alt24=2;
+				int LA24_0 = input.LA(1);

+				if ( (LA24_0==DOTDOTDOT||LA24_0==ID) )
{
-				// AST REWRITE
-				// elements: singleArg
-				// token labels:
-				// rule labels: retval
-				// token list labels:
-				// rule list labels:
-				// wildcard labels:
-				if ( state.backtracking == 0 ) {
-				retval.tree = root_0;
-				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);
-
-				root_0 = (StringTemplateAST)adaptor.Nil();
-				// 312:27: -> singleArg
+					alt24=1;
+				}
+				switch ( alt24 )
{
-					adaptor.AddChild(root_0, stream_singleArg.NextTree());
+				case 1:
+					// Language\\Action.g3:312:5: argumentAssignment ( COMMA argumentAssignment )*
+					{
+					PushFollow(Follow._argumentAssignment_in_argList1059);
+					argumentAssignment80=argumentAssignment();

-				}
+					state._fsp--;
+					if (state.failed) return retval;
+					if ( state.backtracking == 0 ) stream_argumentAssignment.Add(argumentAssignment80.Tree);
+					// Language\\Action.g3:312:24: ( COMMA argumentAssignment )*
+					for ( ; ; )
+					{
+						int alt23=2;
+						int LA23_0 = input.LA(1);

-				retval.tree = root_0;
-				}
-				}
+						if ( (LA23_0==COMMA) )
+						{
+							alt23=1;
+						}

-				}
-				break;
-			case 3:
-				// Language\\Action.g3:313:4: LPAREN argumentAssignment ( COMMA argumentAssignment )* RPAREN
-				{
-				LPAREN82=(IToken)Match(input,LPAREN,Follow._LPAREN_in_argList1087); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN82);

-				PushFollow(Follow._argumentAssignment_in_argList1089);
-				argumentAssignment83=argumentAssignment();
+						switch ( alt23 )
+						{
+						case 1:
+							// Language\\Action.g3:312:25: COMMA argumentAssignment
+							{
+							COMMA81=(IToken)Match(input,COMMA,Follow._COMMA_in_argList1062); if (state.failed) return retval;
+							if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA81);

-				state._fsp--;
-				if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_argumentAssignment.Add(argumentAssignment83.Tree);
-				// Language\\Action.g3:313:30: ( COMMA argumentAssignment )*
-				for ( ; ; )
-				{
-					int alt23=2;
-					int LA23_0 = input.LA(1);
+							PushFollow(Follow._argumentAssignment_in_argList1064);
+							argumentAssignment82=argumentAssignment();

-					if ( (LA23_0==COMMA) )
-					{
-						alt23=1;
-					}
+							state._fsp--;
+							if (state.failed) return retval;
+							if ( state.backtracking == 0 ) stream_argumentAssignment.Add(argumentAssignment82.Tree);

+							}
+							break;

-					switch ( alt23 )
-					{
-					case 1:
-						// Language\\Action.g3:313:31: COMMA argumentAssignment
-						{
-						COMMA84=(IToken)Match(input,COMMA,Follow._COMMA_in_argList1092); if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_COMMA.Add(COMMA84);
+						default:
+							goto loop23;
+						}
+					}

-						PushFollow(Follow._argumentAssignment_in_argList1094);
-						argumentAssignment85=argumentAssignment();
+					loop23:
+						;

-						state._fsp--;
-						if (state.failed) return retval;
-						if ( state.backtracking == 0 ) stream_argumentAssignment.Add(argumentAssignment85.Tree);

-						}
-						break;

-					default:
-						goto loop23;
}
-				}
-
-				loop23:
-					;
+					break;

+				}

-				RPAREN86=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1098); if (state.failed) return retval;
-				if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN86);
+				RPAREN83=(IToken)Match(input,RPAREN,Follow._RPAREN_in_argList1075); if (state.failed) return retval;
+				if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN83);



@@ -3306,17 +3312,14 @@ public partial class ActionParser : Parser
RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

root_0 = (StringTemplateAST)adaptor.Nil();
-				// 314:3: -> ^( ARGS[\"ARGS\"] ( argumentAssignment )+ )
+				// 315:3: -> ^( ARGS[\"ARGS\"] ( argumentAssignment )* )
{
-					// Language\\Action.g3:314:6: ^( ARGS[\"ARGS\"] ( argumentAssignment )+ )
+					// Language\\Action.g3:315:6: ^( ARGS[\"ARGS\"] ( argumentAssignment )* )
{
StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(ARGS, "ARGS"), root_1);

-					if ( !(stream_argumentAssignment.HasNext) )
-					{
-						throw new RewriteEarlyExitException();
-					}
+					// Language\\Action.g3:315:21: ( argumentAssignment )*
while ( stream_argumentAssignment.HasNext )
{
adaptor.AddChild(root_1, stream_argumentAssignment.NextTree());
@@ -3335,6 +3338,20 @@ public partial class ActionParser : Parser

}
break;
+			case 2:
+				// Language\\Action.g3:316:4: singleArg
+				{
+				root_0 = (StringTemplateAST)adaptor.Nil();
+
+				PushFollow(Follow._singleArg_in_argList1092);
+				singleArg84=singleArg();
+
+				state._fsp--;
+				if (state.failed) return retval;
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, singleArg84.Tree);
+
+				}
+				break;

}
retval.stop = input.LT(-1);
@@ -3366,7 +3383,7 @@ public partial class ActionParser : Parser
}

// $ANTLR start "singleArg"
-	// Language\\Action.g3:317:0: singleArg : LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) ;
+	// Language\\Action.g3:319:0: singleArg : LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) ;
private ActionParser.singleArg_return singleArg(  )
{
ActionParser.singleArg_return retval = new ActionParser.singleArg_return();
@@ -3374,31 +3391,31 @@ public partial class ActionParser : Parser

StringTemplateAST root_0 = null;

-		IToken LPAREN87=null;
-		IToken RPAREN89=null;
-		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr88 = default(ActionParser.nonAlternatingTemplateExpr_return);
+		IToken LPAREN85=null;
+		IToken RPAREN87=null;
+		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr86 = default(ActionParser.nonAlternatingTemplateExpr_return);

-		StringTemplateAST LPAREN87_tree=null;
-		StringTemplateAST RPAREN89_tree=null;
+		StringTemplateAST LPAREN85_tree=null;
+		StringTemplateAST RPAREN87_tree=null;
RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
RewriteRuleSubtreeStream stream_nonAlternatingTemplateExpr=new RewriteRuleSubtreeStream(adaptor,"rule nonAlternatingTemplateExpr");
try
{
-			// Language\\Action.g3:318:4: ( LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) )
-			// Language\\Action.g3:318:4: LPAREN nonAlternatingTemplateExpr RPAREN
+			// Language\\Action.g3:320:4: ( LPAREN nonAlternatingTemplateExpr RPAREN -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr ) )
+			// Language\\Action.g3:320:4: LPAREN nonAlternatingTemplateExpr RPAREN
{
-			LPAREN87=(IToken)Match(input,LPAREN,Follow._LPAREN_in_singleArg1121); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN87);
+			LPAREN85=(IToken)Match(input,LPAREN,Follow._LPAREN_in_singleArg1104); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_LPAREN.Add(LPAREN85);

-			PushFollow(Follow._nonAlternatingTemplateExpr_in_singleArg1123);
-			nonAlternatingTemplateExpr88=nonAlternatingTemplateExpr();
+			PushFollow(Follow._nonAlternatingTemplateExpr_in_singleArg1106);
+			nonAlternatingTemplateExpr86=nonAlternatingTemplateExpr();

state._fsp--;
if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_nonAlternatingTemplateExpr.Add(nonAlternatingTemplateExpr88.Tree);
-			RPAREN89=(IToken)Match(input,RPAREN,Follow._RPAREN_in_singleArg1125); if (state.failed) return retval;
-			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN89);
+			if ( state.backtracking == 0 ) stream_nonAlternatingTemplateExpr.Add(nonAlternatingTemplateExpr86.Tree);
+			RPAREN87=(IToken)Match(input,RPAREN,Follow._RPAREN_in_singleArg1108); if (state.failed) return retval;
+			if ( state.backtracking == 0 ) stream_RPAREN.Add(RPAREN87);



@@ -3415,9 +3432,9 @@ public partial class ActionParser : Parser
RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.tree:null);

root_0 = (StringTemplateAST)adaptor.Nil();
-			// 319:3: -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr )
+			// 321:3: -> ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr )
{
-				// Language\\Action.g3:319:6: ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr )
+				// Language\\Action.g3:321:6: ^( SINGLEVALUEARG[\"SINGLEVALUEARG\"] nonAlternatingTemplateExpr )
{
StringTemplateAST root_1 = (StringTemplateAST)adaptor.Nil();
root_1 = (StringTemplateAST)adaptor.BecomeRoot((StringTemplateAST)adaptor.Create(SINGLEVALUEARG, "SINGLEVALUEARG"), root_1);
@@ -3464,7 +3481,7 @@ public partial class ActionParser : Parser
}

// $ANTLR start "argumentAssignment"
-	// Language\\Action.g3:322:0: argumentAssignment : ( ID ASSIGN nonAlternatingTemplateExpr | DOTDOTDOT );
+	// Language\\Action.g3:324:0: argumentAssignment : ( ID ASSIGN nonAlternatingTemplateExpr | DOTDOTDOT );
private ActionParser.argumentAssignment_return argumentAssignment(  )
{
ActionParser.argumentAssignment_return retval = new ActionParser.argumentAssignment_return();
@@ -3472,71 +3489,71 @@ public partial class ActionParser : Parser

StringTemplateAST root_0 = null;

-		IToken ID90=null;
-		IToken ASSIGN91=null;
-		IToken DOTDOTDOT93=null;
-		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr92 = default(ActionParser.nonAlternatingTemplateExpr_return);
+		IToken ID88=null;
+		IToken ASSIGN89=null;
+		IToken DOTDOTDOT91=null;
+		ActionParser.nonAlternatingTemplateExpr_return nonAlternatingTemplateExpr90 = default(ActionParser.nonAlternatingTemplateExpr_return);

-		StringTemplateAST ID90_tree=null;
-		StringTemplateAST ASSIGN91_tree=null;
-		StringTemplateAST DOTDOTDOT93_tree=null;
+		StringTemplateAST ID88_tree=null;
+		StringTemplateAST ASSIGN89_tree=null;
+		StringTemplateAST DOTDOTDOT91_tree=null;

try
{
-			// Language\\Action.g3:323:4: ( ID ASSIGN nonAlternatingTemplateExpr | DOTDOTDOT )
-			int alt25=2;
-			int LA25_0 = input.LA(1);
+			// Language\\Action.g3:325:4: ( ID ASSIGN nonAlternatingTemplateExpr | DOTDOTDOT )
+			int alt26=2;
+			int LA26_0 = input.LA(1);

-			if ( (LA25_0==ID) )
+			if ( (LA26_0==ID) )
{
-				alt25=1;
+				alt26=1;
}
-			else if ( (LA25_0==DOTDOTDOT) )
+			else if ( (LA26_0==DOTDOTDOT) )
{
-				alt25=2;
+				alt26=2;
}
else
{
if (state.backtracking>0) {state.failed=true; return retval;}
-				NoViableAltException nvae = new NoViableAltException("", 25, 0, input);
+				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);

throw nvae;
}
-			switch ( alt25 )
+			switch ( alt26 )
{
case 1:
-				// Language\\Action.g3:323:4: ID ASSIGN nonAlternatingTemplateExpr
+				// Language\\Action.g3:325:4: ID ASSIGN nonAlternatingTemplateExpr
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				ID90=(IToken)Match(input,ID,Follow._ID_in_argumentAssignment1147); if (state.failed) return retval;
+				ID88=(IToken)Match(input,ID,Follow._ID_in_argumentAssignment1130); if (state.failed) return retval;
if ( state.backtracking==0 ) {
-				ID90_tree = (StringTemplateAST)adaptor.Create(ID90);
-				adaptor.AddChild(root_0, ID90_tree);
+				ID88_tree = (StringTemplateAST)adaptor.Create(ID88);
+				adaptor.AddChild(root_0, ID88_tree);
}
-				ASSIGN91=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment1149); if (state.failed) return retval;
+				ASSIGN89=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_argumentAssignment1132); if (state.failed) return retval;
if ( state.backtracking == 0 ) {
-				ASSIGN91_tree = (StringTemplateAST)adaptor.Create(ASSIGN91);
-				root_0 = (StringTemplateAST)adaptor.BecomeRoot(ASSIGN91_tree, root_0);
+				ASSIGN89_tree = (StringTemplateAST)adaptor.Create(ASSIGN89);
+				root_0 = (StringTemplateAST)adaptor.BecomeRoot(ASSIGN89_tree, root_0);
}
-				PushFollow(Follow._nonAlternatingTemplateExpr_in_argumentAssignment1152);
-				nonAlternatingTemplateExpr92=nonAlternatingTemplateExpr();
+				PushFollow(Follow._nonAlternatingTemplateExpr_in_argumentAssignment1135);
+				nonAlternatingTemplateExpr90=nonAlternatingTemplateExpr();

state._fsp--;
if (state.failed) return retval;
-				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr92.Tree);
+				if ( state.backtracking == 0 ) adaptor.AddChild(root_0, nonAlternatingTemplateExpr90.Tree);

}
break;
case 2:
-				// Language\\Action.g3:324:4: DOTDOTDOT
+				// Language\\Action.g3:326:4: DOTDOTDOT
{
root_0 = (StringTemplateAST)adaptor.Nil();

-				DOTDOTDOT93=(IToken)Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment1157); if (state.failed) return retval;
+				DOTDOTDOT91=(IToken)Match(input,DOTDOTDOT,Follow._DOTDOTDOT_in_argumentAssignment1140); if (state.failed) return retval;
if ( state.backtracking==0 ) {
-				DOTDOTDOT93_tree = (StringTemplateAST)adaptor.Create(DOTDOTDOT93);
-				adaptor.AddChild(root_0, DOTDOTDOT93_tree);
+				DOTDOTDOT91_tree = (StringTemplateAST)adaptor.Create(DOTDOTDOT91);
+				adaptor.AddChild(root_0, DOTDOTDOT91_tree);
}

}
@@ -3580,22 +3597,6 @@ public partial class ActionParser : Parser
}
}
// $ANTLR end synpred1_Action
-
-	// $ANTLR start synpred2_Action
-	public void synpred2_Action_fragment()
-	{
-		// Language\\Action.g3:312:4: ( singleArg )
-		// Language\\Action.g3:312:5: singleArg
-		{
-		PushFollow(Follow._singleArg_in_synpred2_Action1067);
-		singleArg();
-
-		state._fsp--;
-		if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred2_Action
#endregion

// Delegated rules
@@ -3619,36 +3620,16 @@ public partial class ActionParser : Parser
state.failed=false;
return success;
}
-	public bool synpred2_Action()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred2_Action_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}

#endregion

#region DFA
DFA15 dfa15;
-	DFA24 dfa24;

protected override void InitDFAs()
{
base.InitDFAs();
dfa15 = new DFA15( this, new SpecialStateTransitionHandler( specialStateTransition15 ) );
-		dfa24 = new DFA24( this, new SpecialStateTransitionHandler( specialStateTransition24 ) );
}

class DFA15 : DFA
@@ -3789,158 +3770,6 @@ public partial class ActionParser : Parser
dfa.Error(nvae);
throw nvae;
}
-	class DFA24 : DFA
-	{
-
-		const string DFA24_eotS =
-			"\x14\xFFFF";
-		const string DFA24_eofS =
-			"\x14\xFFFF";
-		const string DFA24_minS =
-			"\x1\x18\x1\x4\x1\xFFFF\x1\x7\x10\xFFFF";
-		const string DFA24_maxS =
-			"\x1\x18\x1\x28\x1\xFFFF\x1\x20\x10\xFFFF";
-		const string DFA24_acceptS =
-			"\x2\xFFFF\x1\x1\x1\xFFFF\xA\x2\x1\x3\x5\x2";
-		const string DFA24_specialS =
-			"\x1\xFFFF\x1\x0\x1\xFFFF\x1\x1\x10\xFFFF}>";
-		static readonly string[] DFA24_transitionS =
-			{
-				"\x1\x1",
-				"\x1\x6\x7\xFFFF\x1\xE\x2\xFFFF\x1\x7\x1\xFFFF\x1\x3\x1\xFFFF\x1\x6\x1"+
-				"\x9\x1\xD\x1\xA\x1\xFFFF\x1\x5\x6\xFFFF\x1\x8\x1\x2\x2\xFFFF\x1\x6\x1"+
-				"\xB\x1\x4\x2\xFFFF\x1\xC",
-				"",
-				"\x1\xE\x1\x12\x2\xFFFF\x1\x10\xC\xFFFF\x1\xF\x4\xFFFF\x1\x11\x2\xFFFF"+
-				"\x1\x13",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				""
-			};
-
-		static readonly short[] DFA24_eot = DFA.UnpackEncodedString(DFA24_eotS);
-		static readonly short[] DFA24_eof = DFA.UnpackEncodedString(DFA24_eofS);
-		static readonly char[] DFA24_min = DFA.UnpackEncodedStringToUnsignedChars(DFA24_minS);
-		static readonly char[] DFA24_max = DFA.UnpackEncodedStringToUnsignedChars(DFA24_maxS);
-		static readonly short[] DFA24_accept = DFA.UnpackEncodedString(DFA24_acceptS);
-		static readonly short[] DFA24_special = DFA.UnpackEncodedString(DFA24_specialS);
-		static readonly short[][] DFA24_transition;
-
-		static DFA24()
-		{
-			int numStates = DFA24_transitionS.Length;
-			DFA24_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA24_transition[i] = DFA.UnpackEncodedString(DFA24_transitionS[i]);
-			}
-		}
-
-		public DFA24( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 24;
-			this.eot = DFA24_eot;
-			this.eof = DFA24_eof;
-			this.min = DFA24_min;
-			this.max = DFA24_max;
-			this.accept = DFA24_accept;
-			this.special = DFA24_special;
-			this.transition = DFA24_transition;
-		}
-		public override string GetDescription()
-		{
-			return "310:0: argList : ( LPAREN RPAREN -> ARGS[\"ARGS\"] |=> singleArg -> singleArg | LPAREN argumentAssignment ( COMMA argumentAssignment )* RPAREN -> ^( ARGS[\"ARGS\"] ( argumentAssignment )+ ) );";
-		}
-	}
-
-	int specialStateTransition24( DFA dfa, int s, IIntStream _input )
-	{
-		ITokenStream input = (ITokenStream)_input;
-		int _s = s;
-		switch ( s )
-		{
-
-			case 0:
-				int LA24_1 = input.LA(1);
-
-
-				int index24_1 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA24_1==RPAREN) ) {s = 2;}
-
-				else if ( (LA24_1==ID) ) {s = 3;}
-
-				else if ( (LA24_1==SUPER) && (synpred2_Action())) {s = 4;}
-
-				else if ( (LA24_1==LPAREN) && (synpred2_Action())) {s = 5;}
-
-				else if ( (LA24_1==ANONYMOUS_TEMPLATE||LA24_1==INT||LA24_1==STRING) && (synpred2_Action())) {s = 6;}
-
-				else if ( (LA24_1==FIRST) && (synpred2_Action())) {s = 7;}
-
-				else if ( (LA24_1==REST) && (synpred2_Action())) {s = 8;}
-
-				else if ( (LA24_1==LAST) && (synpred2_Action())) {s = 9;}
-
-				else if ( (LA24_1==LENGTH) && (synpred2_Action())) {s = 10;}
-
-				else if ( (LA24_1==STRIP) && (synpred2_Action())) {s = 11;}
-
-				else if ( (LA24_1==TRUNC) && (synpred2_Action())) {s = 12;}
-
-				else if ( (LA24_1==LBRACK) && (synpred2_Action())) {s = 13;}
-
-				else if ( (LA24_1==DOTDOTDOT) ) {s = 14;}
-
-
-				input.Seek(index24_1);
-				if ( s>=0 ) return s;
-				break;
-
-			case 1:
-				int LA24_3 = input.LA(1);
-
-
-				int index24_3 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA24_3==ASSIGN) ) {s = 14;}
-
-				else if ( (LA24_3==LPAREN) && (synpred2_Action())) {s = 15;}
-
-				else if ( (LA24_3==DOT) && (synpred2_Action())) {s = 16;}
-
-				else if ( (LA24_3==PLUS) && (synpred2_Action())) {s = 17;}
-
-				else if ( (LA24_3==COLON) && (synpred2_Action())) {s = 18;}
-
-				else if ( (LA24_3==RPAREN) && (synpred2_Action())) {s = 19;}
-
-
-				input.Seek(index24_3);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 24, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}

#endregion

@@ -4034,23 +3863,20 @@ public partial class ActionParser : Parser
public static readonly BitSet _templatesExpr_in_indirectTemplate1020 = new BitSet(new ulong[]{0x100000000UL});
public static readonly BitSet _RPAREN_in_indirectTemplate1022 = new BitSet(new ulong[]{0x1000000UL});
public static readonly BitSet _argList_in_indirectTemplate1026 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_argList1053 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _RPAREN_in_argList1055 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _singleArg_in_argList1070 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_argList1087 = new BitSet(new ulong[]{0x21000UL});
-		public static readonly BitSet _argumentAssignment_in_argList1089 = new BitSet(new ulong[]{0x100000200UL});
-		public static readonly BitSet _COMMA_in_argList1092 = new BitSet(new ulong[]{0x21000UL});
-		public static readonly BitSet _argumentAssignment_in_argList1094 = new BitSet(new ulong[]{0x100000200UL});
-		public static readonly BitSet _RPAREN_in_argList1098 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LPAREN_in_singleArg1121 = new BitSet(new ulong[]{0x138817A8010UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_singleArg1123 = new BitSet(new ulong[]{0x100000000UL});
-		public static readonly BitSet _RPAREN_in_singleArg1125 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_argumentAssignment1147 = new BitSet(new ulong[]{0x80UL});
-		public static readonly BitSet _ASSIGN_in_argumentAssignment1149 = new BitSet(new ulong[]{0x138817A8010UL});
-		public static readonly BitSet _nonAlternatingTemplateExpr_in_argumentAssignment1152 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment1157 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_argList1053 = new BitSet(new ulong[]{0x100021000UL});
+		public static readonly BitSet _argumentAssignment_in_argList1059 = new BitSet(new ulong[]{0x100000200UL});
+		public static readonly BitSet _COMMA_in_argList1062 = new BitSet(new ulong[]{0x21000UL});
+		public static readonly BitSet _argumentAssignment_in_argList1064 = new BitSet(new ulong[]{0x100000200UL});
+		public static readonly BitSet _RPAREN_in_argList1075 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _singleArg_in_argList1092 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _LPAREN_in_singleArg1104 = new BitSet(new ulong[]{0x138817A8010UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_singleArg1106 = new BitSet(new ulong[]{0x100000000UL});
+		public static readonly BitSet _RPAREN_in_singleArg1108 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _ID_in_argumentAssignment1130 = new BitSet(new ulong[]{0x80UL});
+		public static readonly BitSet _ASSIGN_in_argumentAssignment1132 = new BitSet(new ulong[]{0x138817A8010UL});
+		public static readonly BitSet _nonAlternatingTemplateExpr_in_argumentAssignment1135 = new BitSet(new ulong[]{0x2UL});
+		public static readonly BitSet _DOTDOTDOT_in_argumentAssignment1140 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _templateInclude_in_synpred1_Action490 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _singleArg_in_synpred2_Action1067 = new BitSet(new ulong[]{0x2UL});

}
#endregion
diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
index 943e05c..1cacbc5 100644
--- a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
+++ b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\AngleBracketTemplateLexer.g3 2009-03-16 17:15:43
+// $ANTLR 3.1.2 Language\\AngleBracketTemplateLexer.g3 2009-03-16 20:58:36

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -357,9 +357,9 @@ public partial class AngleBracketTemplateLexer : Lexer


Match('('); if (state.failed) return ;
-					int expStart170 = GetCharIndex();
+					int expStart171 = GetCharIndex();
mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, expStart170, GetCharIndex()-1);
+					exp = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, expStart171, GetCharIndex()-1);
Match(")>"); if (state.failed) return ;

// Language\\AngleBracketTemplateLexer.g3:110:4: ( ( '\\r' )? '\\n' )?
@@ -450,9 +450,9 @@ public partial class AngleBracketTemplateLexer : Lexer


Match('('); if (state.failed) return ;
-					int expStart219 = GetCharIndex();
+					int expStart220 = GetCharIndex();
mIF_EXPR(); if (state.failed) return ;
-					exp = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, expStart219, GetCharIndex()-1);
+					exp = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, expStart220, GetCharIndex()-1);
Match(")>"); if (state.failed) return ;

// Language\\AngleBracketTemplateLexer.g3:117:4: ( ( '\\r' )? '\\n' )?
@@ -1189,10 +1189,10 @@ public partial class AngleBracketTemplateLexer : Lexer
int loopStartIndex = 0;
int col = 0;

-			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
{
-			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:189:4: ( ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) ) |ind= INDENT |ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' ) )+
int cnt28=0;
for ( ; ; )
{
@@ -1216,75 +1216,27 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt28 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:189:6: ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) )
+					// Language\\AngleBracketTemplateLexer.g3:189:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
{
-					// Language\\AngleBracketTemplateLexer.g3:189:6: ( '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . ) )
-					// Language\\AngleBracketTemplateLexer.g3:189:8: '\\\\' ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . )
+					// Language\\AngleBracketTemplateLexer.g3:189:6: ( '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) ) )
+					// Language\\AngleBracketTemplateLexer.g3:189:8: '\\\\' ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
{
Match('\\'); if (state.failed) return ;
-					// Language\\AngleBracketTemplateLexer.g3:190:5: ( options {k=1; } :=> '<' |=> '>' |=> '\\\\' |ch= . )
+					// Language\\AngleBracketTemplateLexer.g3:190:5: ( '<' | '>' | '\\\\' |ch=~ ( '<' | '>' | '\\\\' ) )
int alt27=4;
int LA27_0 = input.LA(1);

if ( (LA27_0=='<') )
{
-						int LA27_1 = input.LA(2);
-
-						if ( (synpred11_AngleBracketTemplateLexer()) )
-						{
-							alt27=1;
-						}
-						else if ( (true) )
-						{
-							alt27=4;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 27, 1, input);
-
-							throw nvae;
-						}
+						alt27=1;
}
else if ( (LA27_0=='>') )
{
-						int LA27_2 = input.LA(2);
-
-						if ( (synpred12_AngleBracketTemplateLexer()) )
-						{
-							alt27=2;
-						}
-						else if ( (true) )
-						{
-							alt27=4;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 27, 2, input);
-
-							throw nvae;
-						}
+						alt27=2;
}
else if ( (LA27_0=='\\') )
{
-						int LA27_3 = input.LA(2);
-
-						if ( (synpred13_AngleBracketTemplateLexer()) )
-						{
-							alt27=3;
-						}
-						else if ( (true) )
-						{
-							alt27=4;
-						}
-						else
-						{
-							if (state.backtracking>0) {state.failed=true; return ;}
-							NoViableAltException nvae = new NoViableAltException("", 27, 3, input);
-
-							throw nvae;
-						}
+						alt27=3;
}
else if ( ((LA27_0>='\u0000' && LA27_0<=';')||LA27_0=='='||(LA27_0>='?' && LA27_0<='[')||(LA27_0>=']' && LA27_0<='\uFFFF')) )
{
@@ -1300,9 +1252,8 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt27 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:191:6: => '<'
+						// Language\\AngleBracketTemplateLexer.g3:190:7: '<'
{
-
Match('<'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
@@ -1312,9 +1263,8 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:192:7: => '>'
+						// Language\\AngleBracketTemplateLexer.g3:191:7: '>'
{
-
Match('>'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
@@ -1324,9 +1274,8 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-						// Language\\AngleBracketTemplateLexer.g3:193:7: => '\\\\'
+						// Language\\AngleBracketTemplateLexer.g3:192:7: '\\\\'
{
-
Match('\\'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
@@ -1336,10 +1285,11 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 4:
-						// Language\\AngleBracketTemplateLexer.g3:194:7: ch= .
+						// Language\\AngleBracketTemplateLexer.g3:193:7: ch=~ ( '<' | '>' | '\\\\' )
{
-						ch = input.LA(1);
-						MatchAny(); if (state.failed) return ;
+						ch= input.LA(1);
+						input.Consume();
+						state.failed=false;
if ( state.backtracking == 0 )
{
builder.Append( "\\" + (char)ch );
@@ -1357,11 +1307,11 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:197:5: ind= INDENT
+					// Language\\AngleBracketTemplateLexer.g3:196:5: ind= INDENT
{
-					int indStart709 = GetCharIndex();
+					int indStart686 = GetCharIndex();
mINDENT(); if (state.failed) return ;
-					ind = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, indStart709, GetCharIndex()-1);
+					ind = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, indStart686, GetCharIndex()-1);
if ( state.backtracking == 0 )
{

@@ -1385,7 +1335,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:214:5: ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' )
+					// Language\\AngleBracketTemplateLexer.g3:213:5: ch=~ ( '\\\\' | ' ' | '\\t' | '<' | '\\r' | '\\n' )
{
ch= input.LA(1);
input.Consume();
@@ -1439,10 +1389,10 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ( ' ' | '\\t' )+ )
-			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ' ' | '\\t' )+
+			// Language\\AngleBracketTemplateLexer.g3:226:4: ( ( ' ' | '\\t' )+ )
+			// Language\\AngleBracketTemplateLexer.g3:226:4: ( ' ' | '\\t' )+
{
-			// Language\\AngleBracketTemplateLexer.g3:227:4: ( ' ' | '\\t' )+
+			// Language\\AngleBracketTemplateLexer.g3:226:4: ( ' ' | '\\t' )+
int cnt29=0;
for ( ; ; )
{
@@ -1504,10 +1454,10 @@ public partial class AngleBracketTemplateLexer : Lexer
_text = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:237:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:237:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
{
-			// Language\\AngleBracketTemplateLexer.g3:238:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:237:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '>' ) )+
int cnt32=0;
for ( ; ; )
{
@@ -1535,11 +1485,11 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt32 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:238:6: ESC
+					// Language\\AngleBracketTemplateLexer.g3:237:6: ESC
{
-					int ESC1Start789 = GetCharIndex();
+					int ESC1Start766 = GetCharIndex();
mESC(); if (state.failed) return ;
-					ESC1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC1Start789, GetCharIndex()-1);
+					ESC1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC1Start766, GetCharIndex()-1);
if ( state.backtracking == 0 )
{
builder.Append((ESC1!=null?ESC1.Text:null));
@@ -1548,11 +1498,11 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:239:5: st= SUBTEMPLATE
+					// Language\\AngleBracketTemplateLexer.g3:238:5: st= SUBTEMPLATE
{
-					int stStart807 = GetCharIndex();
+					int stStart784 = GetCharIndex();
mSUBTEMPLATE(); if (state.failed) return ;
-					st = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, stStart807, GetCharIndex()-1);
+					st = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, stStart784, GetCharIndex()-1);
if ( state.backtracking == 0 )
{
builder.Append((st!=null?st.Text:null));
@@ -1561,9 +1511,9 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:240:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					// Language\\AngleBracketTemplateLexer.g3:239:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
{
-					// Language\\AngleBracketTemplateLexer.g3:240:5: ( '=' | '+' )
+					// Language\\AngleBracketTemplateLexer.g3:239:5: ( '=' | '+' )
int alt30=2;
int LA30_0 = input.LA(1);

@@ -1585,7 +1535,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt30 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:240:7: '='
+						// Language\\AngleBracketTemplateLexer.g3:239:7: '='
{
Match('='); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1596,7 +1546,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:241:6: '+'
+						// Language\\AngleBracketTemplateLexer.g3:240:6: '+'
{
Match('+'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1609,7 +1559,7 @@ public partial class AngleBracketTemplateLexer : Lexer

}

-					// Language\\AngleBracketTemplateLexer.g3:243:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					// Language\\AngleBracketTemplateLexer.g3:242:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
int alt31=3;
int LA31_0 = input.LA(1);

@@ -1635,7 +1585,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt31 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:243:6: TEMPLATE[out subtext]
+						// Language\\AngleBracketTemplateLexer.g3:242:6: TEMPLATE[out subtext]
{
mTEMPLATE(out subtext); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1646,11 +1596,11 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:244:6: st= SUBTEMPLATE
+						// Language\\AngleBracketTemplateLexer.g3:243:6: st= SUBTEMPLATE
{
-						int stStart873 = GetCharIndex();
+						int stStart850 = GetCharIndex();
mSUBTEMPLATE(); if (state.failed) return ;
-						st = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, stStart873, GetCharIndex()-1);
+						st = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, stStart850, GetCharIndex()-1);
if ( state.backtracking == 0 )
{
builder.Append((st!=null?st.Text:null));
@@ -1659,7 +1609,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-						// Language\\AngleBracketTemplateLexer.g3:245:6: ch=~ ( '\"' | '<' | '{' )
+						// Language\\AngleBracketTemplateLexer.g3:244:6: ch=~ ( '\"' | '<' | '{' )
{
ch= input.LA(1);
input.Consume();
@@ -1678,7 +1628,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 4:
-					// Language\\AngleBracketTemplateLexer.g3:247:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '>' )
+					// Language\\AngleBracketTemplateLexer.g3:246:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '>' )
{
ch= input.LA(1);
input.Consume();
@@ -1731,7 +1681,7 @@ public partial class AngleBracketTemplateLexer : Lexer
_text = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\AngleBracketTemplateLexer.g3:259:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>' )
+			// Language\\AngleBracketTemplateLexer.g3:258:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>' )
int alt38=2;
int LA38_0 = input.LA(1);

@@ -1753,14 +1703,14 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt38 )
{
case 1:
-				// Language\\AngleBracketTemplateLexer.g3:259:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
+				// Language\\AngleBracketTemplateLexer.g3:258:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
{
Match('\"'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
builder.Append('"');
}
-				// Language\\AngleBracketTemplateLexer.g3:261:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
+				// Language\\AngleBracketTemplateLexer.g3:260:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
for ( ; ; )
{
int alt33=3;
@@ -1779,11 +1729,11 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt33 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:261:5: ESC
+						// Language\\AngleBracketTemplateLexer.g3:260:5: ESC
{
-						int ESC2Start966 = GetCharIndex();
+						int ESC2Start943 = GetCharIndex();
mESC(); if (state.failed) return ;
-						ESC2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC2Start966, GetCharIndex()-1);
+						ESC2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ESC2Start943, GetCharIndex()-1);
if ( state.backtracking == 0 )
{
builder.Append((ESC2!=null?ESC2.Text:null));
@@ -1792,7 +1742,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:262:5: ch=~ ( '\\\\' | '\"' )
+						// Language\\AngleBracketTemplateLexer.g3:261:5: ch=~ ( '\\\\' | '\"' )
{
ch= input.LA(1);
input.Consume();
@@ -1826,7 +1776,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-				// Language\\AngleBracketTemplateLexer.g3:269:4: '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>'
+				// Language\\AngleBracketTemplateLexer.g3:268:4: '<<' (=> ( '\\r' )? '\\n' )? ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )* '>>'
{
Match("<<"); if (state.failed) return ;

@@ -1836,7 +1786,7 @@ public partial class AngleBracketTemplateLexer : Lexer
builder.Append("<<");

}
-				// Language\\AngleBracketTemplateLexer.g3:273:3: (=> ( '\\r' )? '\\n' )?
+				// Language\\AngleBracketTemplateLexer.g3:272:3: (=> ( '\\r' )? '\\n' )?
int alt35=2;
int LA35_0 = input.LA(1);

@@ -1848,7 +1798,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA35_2 = input.LA(3);

-						if ( (synpred14_AngleBracketTemplateLexer()) )
+						if ( (synpred11_AngleBracketTemplateLexer()) )
{
alt35=1;
}
@@ -1858,7 +1808,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
int LA35_2 = input.LA(2);

-					if ( (synpred14_AngleBracketTemplateLexer()) )
+					if ( (synpred11_AngleBracketTemplateLexer()) )
{
alt35=1;
}
@@ -1866,10 +1816,10 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt35 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:273:5: => ( '\\r' )? '\\n'
+					// Language\\AngleBracketTemplateLexer.g3:272:5: => ( '\\r' )? '\\n'
{

-					// Language\\AngleBracketTemplateLexer.g3:273:20: ( '\\r' )?
+					// Language\\AngleBracketTemplateLexer.g3:272:20: ( '\\r' )?
int alt34=2;
int LA34_0 = input.LA(1);

@@ -1880,7 +1830,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt34 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:273:21: '\\r'
+						// Language\\AngleBracketTemplateLexer.g3:272:21: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1896,7 +1846,7 @@ public partial class AngleBracketTemplateLexer : Lexer

}

-				// Language\\AngleBracketTemplateLexer.g3:274:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*
+				// Language\\AngleBracketTemplateLexer.g3:273:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*
for ( ; ; )
{
int alt37=3;
@@ -1904,10 +1854,10 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt37 )
{
case 1:
-						// Language\\AngleBracketTemplateLexer.g3:275:4: => ( '\\r' )? '\\n'
+						// Language\\AngleBracketTemplateLexer.g3:274:4: => ( '\\r' )? '\\n'
{

-						// Language\\AngleBracketTemplateLexer.g3:275:22: ( '\\r' )?
+						// Language\\AngleBracketTemplateLexer.g3:274:22: ( '\\r' )?
int alt36=2;
int LA36_0 = input.LA(1);

@@ -1918,7 +1868,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt36 )
{
case 1:
-							// Language\\AngleBracketTemplateLexer.g3:275:23: '\\r'
+							// Language\\AngleBracketTemplateLexer.g3:274:23: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1932,7 +1882,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-						// Language\\AngleBracketTemplateLexer.g3:276:5: =>ch= .
+						// Language\\AngleBracketTemplateLexer.g3:275:5: =>ch= .
{

ch = input.LA(1);
@@ -1980,10 +1930,10 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
-			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:286:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
+			// Language\\AngleBracketTemplateLexer.g3:286:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
{
-			// Language\\AngleBracketTemplateLexer.g3:287:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:286:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
int cnt39=0;
for ( ; ; )
{
@@ -2011,28 +1961,28 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt39 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:287:6: ESC
+					// Language\\AngleBracketTemplateLexer.g3:286:6: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:288:5: SUBTEMPLATE
+					// Language\\AngleBracketTemplateLexer.g3:287:5: SUBTEMPLATE
{
mSUBTEMPLATE(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:289:5: NESTED_PARENS
+					// Language\\AngleBracketTemplateLexer.g3:288:5: NESTED_PARENS
{
mNESTED_PARENS(); if (state.failed) return ;

}
break;
case 4:
-					// Language\\AngleBracketTemplateLexer.g3:290:5: ~ ( '\\\\' | '{' | '(' | ')' )
+					// Language\\AngleBracketTemplateLexer.g3:289:5: ~ ( '\\\\' | '{' | '(' | ')' )
{
input.Consume();
state.failed=false;
@@ -2077,11 +2027,11 @@ public partial class AngleBracketTemplateLexer : Lexer

uc = '\0';

-			// Language\\AngleBracketTemplateLexer.g3:300:4: ( '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX ) )
-			// Language\\AngleBracketTemplateLexer.g3:300:4: '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
+			// Language\\AngleBracketTemplateLexer.g3:299:4: ( '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX ) )
+			// Language\\AngleBracketTemplateLexer.g3:299:4: '\\\\' ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
{
Match('\\'); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:301:3: ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
+			// Language\\AngleBracketTemplateLexer.g3:300:3: ( 'n' | 'r' | 't' | ' ' | 'u' a= HEX b= HEX c= HEX d= HEX )
int alt40=5;
switch ( input.LA(1) )
{
@@ -2122,7 +2072,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt40 )
{
case 1:
-				// Language\\AngleBracketTemplateLexer.g3:301:5: 'n'
+				// Language\\AngleBracketTemplateLexer.g3:300:5: 'n'
{
Match('n'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2133,7 +2083,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-				// Language\\AngleBracketTemplateLexer.g3:302:5: 'r'
+				// Language\\AngleBracketTemplateLexer.g3:301:5: 'r'
{
Match('r'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2144,7 +2094,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 3:
-				// Language\\AngleBracketTemplateLexer.g3:303:5: 't'
+				// Language\\AngleBracketTemplateLexer.g3:302:5: 't'
{
Match('t'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2155,7 +2105,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 4:
-				// Language\\AngleBracketTemplateLexer.g3:304:5: ' '
+				// Language\\AngleBracketTemplateLexer.g3:303:5: ' '
{
Match(' '); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2166,21 +2116,21 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 5:
-				// Language\\AngleBracketTemplateLexer.g3:305:5: 'u' a= HEX b= HEX c= HEX d= HEX
+				// Language\\AngleBracketTemplateLexer.g3:304:5: 'u' a= HEX b= HEX c= HEX d= HEX
{
Match('u'); if (state.failed) return ;
-				int aStart1214 = GetCharIndex();
+				int aStart1191 = GetCharIndex();
mHEX(); if (state.failed) return ;
-				a = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, aStart1214, GetCharIndex()-1);
-				int bStart1218 = GetCharIndex();
+				a = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, aStart1191, GetCharIndex()-1);
+				int bStart1195 = GetCharIndex();
mHEX(); if (state.failed) return ;
-				b = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, bStart1218, GetCharIndex()-1);
-				int cStart1222 = GetCharIndex();
+				b = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, bStart1195, GetCharIndex()-1);
+				int cStart1199 = GetCharIndex();
mHEX(); if (state.failed) return ;
-				c = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, cStart1222, GetCharIndex()-1);
-				int dStart1226 = GetCharIndex();
+				c = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, cStart1199, GetCharIndex()-1);
+				int dStart1203 = GetCharIndex();
mHEX(); if (state.failed) return ;
-				d = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, dStart1226, GetCharIndex()-1);
+				d = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, dStart1203, GetCharIndex()-1);
if ( state.backtracking == 0 )
{
uc = (char)int.Parse((a!=null?a.Text:null)+(b!=null?b.Text:null)+(c!=null?c.Text:null)+(d!=null?d.Text:null), System.Globalization.NumberStyles.AllowHexSpecifier);
@@ -2206,8 +2156,8 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:313:4: ( '\\\\' . )
-			// Language\\AngleBracketTemplateLexer.g3:313:4: '\\\\' .
+			// Language\\AngleBracketTemplateLexer.g3:312:4: ( '\\\\' . )
+			// Language\\AngleBracketTemplateLexer.g3:312:4: '\\\\' .
{
Match('\\'); if (state.failed) return ;
MatchAny(); if (state.failed) return ;
@@ -2226,7 +2176,7 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:318:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
+			// Language\\AngleBracketTemplateLexer.g3:317:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
// Language\\AngleBracketTemplateLexer.g3:
{
if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
@@ -2256,11 +2206,11 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:323:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
-			// Language\\AngleBracketTemplateLexer.g3:323:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
+			// Language\\AngleBracketTemplateLexer.g3:322:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
+			// Language\\AngleBracketTemplateLexer.g3:322:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
{
Match('{'); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:324:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
+			// Language\\AngleBracketTemplateLexer.g3:323:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
for ( ; ; )
{
int alt41=4;
@@ -2283,21 +2233,21 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt41 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:324:5: SUBTEMPLATE
+					// Language\\AngleBracketTemplateLexer.g3:323:5: SUBTEMPLATE
{
mSUBTEMPLATE(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:325:5: ESC
+					// Language\\AngleBracketTemplateLexer.g3:324:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:326:5: ~ ( '{' | '\\\\' | '}' )
+					// Language\\AngleBracketTemplateLexer.g3:325:5: ~ ( '{' | '\\\\' | '}' )
{
input.Consume();
state.failed=false;
@@ -2330,11 +2280,11 @@ public partial class AngleBracketTemplateLexer : Lexer
{
try
{
-			// Language\\AngleBracketTemplateLexer.g3:333:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
-			// Language\\AngleBracketTemplateLexer.g3:333:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
+			// Language\\AngleBracketTemplateLexer.g3:332:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
+			// Language\\AngleBracketTemplateLexer.g3:332:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
{
Match('('); if (state.failed) return ;
-			// Language\\AngleBracketTemplateLexer.g3:334:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
+			// Language\\AngleBracketTemplateLexer.g3:333:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
int cnt42=0;
for ( ; ; )
{
@@ -2358,21 +2308,21 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt42 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:334:5: NESTED_PARENS
+					// Language\\AngleBracketTemplateLexer.g3:333:5: NESTED_PARENS
{
mNESTED_PARENS(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\AngleBracketTemplateLexer.g3:335:5: ESC
+					// Language\\AngleBracketTemplateLexer.g3:334:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\AngleBracketTemplateLexer.g3:336:5: ~ ( '(' | '\\\\' | ')' )
+					// Language\\AngleBracketTemplateLexer.g3:335:5: ~ ( '(' | '\\\\' | ')' )
{
input.Consume();
state.failed=false;
@@ -2413,12 +2363,12 @@ public partial class AngleBracketTemplateLexer : Lexer

int startCol = CharPositionInLine;

-			// Language\\AngleBracketTemplateLexer.g3:347:4: ( '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )? )
-			// Language\\AngleBracketTemplateLexer.g3:347:4: '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )?
+			// Language\\AngleBracketTemplateLexer.g3:346:4: ( '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )? )
+			// Language\\AngleBracketTemplateLexer.g3:346:4: '<!' ( . )* '!>' ({...}? => ( '\\r' )? '\\n' )?
{
Match("<!"); if (state.failed) return ;

-			// Language\\AngleBracketTemplateLexer.g3:347:9: ( . )*
+			// Language\\AngleBracketTemplateLexer.g3:346:9: ( . )*
for ( ; ; )
{
int alt43=2;
@@ -2448,7 +2398,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt43 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:347:0: .
+					// Language\\AngleBracketTemplateLexer.g3:346:0: .
{
MatchAny(); if (state.failed) return ;

@@ -2466,7 +2416,7 @@ public partial class AngleBracketTemplateLexer : Lexer

Match("!>"); if (state.failed) return ;

-			// Language\\AngleBracketTemplateLexer.g3:348:3: ({...}? => ( '\\r' )? '\\n' )?
+			// Language\\AngleBracketTemplateLexer.g3:347:3: ({...}? => ( '\\r' )? '\\n' )?
int alt45=2;
int LA45_0 = input.LA(1);

@@ -2477,14 +2427,14 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt45 )
{
case 1:
-				// Language\\AngleBracketTemplateLexer.g3:348:5: {...}? => ( '\\r' )? '\\n'
+				// Language\\AngleBracketTemplateLexer.g3:347:5: {...}? => ( '\\r' )? '\\n'
{
if ( !((startCol==0)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "COMMENT", "startCol==0");
}
-				// Language\\AngleBracketTemplateLexer.g3:348:23: ( '\\r' )?
+				// Language\\AngleBracketTemplateLexer.g3:347:23: ( '\\r' )?
int alt44=2;
int LA44_0 = input.LA(1);

@@ -2495,7 +2445,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt44 )
{
case 1:
-					// Language\\AngleBracketTemplateLexer.g3:348:24: '\\r'
+					// Language\\AngleBracketTemplateLexer.g3:347:24: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -2613,43 +2563,7 @@ public partial class AngleBracketTemplateLexer : Lexer
// $ANTLR start synpred11_AngleBracketTemplateLexer
public void synpred11_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:191:6: ( '<' )
-		// Language\\AngleBracketTemplateLexer.g3:191:7: '<'
-		{
-		Match('<'); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred11_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred12_AngleBracketTemplateLexer
-	public void synpred12_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:192:7: ( '>' )
-		// Language\\AngleBracketTemplateLexer.g3:192:8: '>'
-		{
-		Match('>'); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred12_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred13_AngleBracketTemplateLexer
-	public void synpred13_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:193:7: ( '\\\\' )
-		// Language\\AngleBracketTemplateLexer.g3:193:8: '\\\\'
-		{
-		Match('\\'); if (state.failed) return ;
-
-		}
-	}
-	// $ANTLR end synpred13_AngleBracketTemplateLexer
-
-	// $ANTLR start synpred14_AngleBracketTemplateLexer
-	public void synpred14_AngleBracketTemplateLexer_fragment()
-	{
-		// Language\\AngleBracketTemplateLexer.g3:273:5: ( '\\r' | '\\n' )
+		// Language\\AngleBracketTemplateLexer.g3:272:5: ( '\\r' | '\\n' )
// Language\\AngleBracketTemplateLexer.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2667,15 +2581,15 @@ public partial class AngleBracketTemplateLexer : Lexer

}
}
-	// $ANTLR end synpred14_AngleBracketTemplateLexer
+	// $ANTLR end synpred11_AngleBracketTemplateLexer

-	// $ANTLR start synpred15_AngleBracketTemplateLexer
-	public void synpred15_AngleBracketTemplateLexer_fragment()
+	// $ANTLR start synpred12_AngleBracketTemplateLexer
+	public void synpred12_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:275:4: ( ( '\\r' )? '\\n>>' )
-		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '\\r' )? '\\n>>'
+		// Language\\AngleBracketTemplateLexer.g3:274:4: ( ( '\\r' )? '\\n>>' )
+		// Language\\AngleBracketTemplateLexer.g3:274:5: ( '\\r' )? '\\n>>'
{
-		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '\\r' )?
+		// Language\\AngleBracketTemplateLexer.g3:274:5: ( '\\r' )?
int alt47=2;
int LA47_0 = input.LA(1);

@@ -2686,7 +2600,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt47 )
{
case 1:
-			// Language\\AngleBracketTemplateLexer.g3:275:0: '\\r'
+			// Language\\AngleBracketTemplateLexer.g3:274:0: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -2700,12 +2614,12 @@ public partial class AngleBracketTemplateLexer : Lexer

}
}
-	// $ANTLR end synpred15_AngleBracketTemplateLexer
+	// $ANTLR end synpred12_AngleBracketTemplateLexer

-	// $ANTLR start synpred16_AngleBracketTemplateLexer
-	public void synpred16_AngleBracketTemplateLexer_fragment()
+	// $ANTLR start synpred13_AngleBracketTemplateLexer
+	public void synpred13_AngleBracketTemplateLexer_fragment()
{
-		// Language\\AngleBracketTemplateLexer.g3:276:5: ( '>' ~ '>' |~ '>' )
+		// Language\\AngleBracketTemplateLexer.g3:275:5: ( '>' ~ '>' |~ '>' )
int alt48=2;
int LA48_0 = input.LA(1);

@@ -2727,7 +2641,7 @@ public partial class AngleBracketTemplateLexer : Lexer
switch ( alt48 )
{
case 1:
-			// Language\\AngleBracketTemplateLexer.g3:276:6: '>' ~ '>'
+			// Language\\AngleBracketTemplateLexer.g3:275:6: '>' ~ '>'
{
Match('>'); if (state.failed) return ;
if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
@@ -2746,7 +2660,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
break;
case 2:
-			// Language\\AngleBracketTemplateLexer.g3:276:17: ~ '>'
+			// Language\\AngleBracketTemplateLexer.g3:275:17: ~ '>'
{
if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
{
@@ -2765,7 +2679,7 @@ public partial class AngleBracketTemplateLexer : Lexer
break;

}}
-	// $ANTLR end synpred16_AngleBracketTemplateLexer
+	// $ANTLR end synpred13_AngleBracketTemplateLexer

// $ANTLR start synpred2_AngleBracketTemplateLexer
public void synpred2_AngleBracketTemplateLexer_fragment()
@@ -3125,60 +3039,6 @@ public partial class AngleBracketTemplateLexer : Lexer
state.failed=false;
return success;
}
-	public bool synpred14_AngleBracketTemplateLexer()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred14_AngleBracketTemplateLexer_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred15_AngleBracketTemplateLexer()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred15_AngleBracketTemplateLexer_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred16_AngleBracketTemplateLexer()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred16_AngleBracketTemplateLexer_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}


#region DFA
@@ -3546,7 +3406,7 @@ public partial class AngleBracketTemplateLexer : Lexer
}
public override string GetDescription()
{
-			return "()* loopback of 274:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*";
+			return "()* loopback of 273:3: ( options {k=2; } :=> ( '\\r' )? '\\n' |=>ch= . )*";
}
}

@@ -3570,7 +3430,7 @@ public partial class AngleBracketTemplateLexer : Lexer

else if ( (LA37_0=='\n') ) {s = 3;}

-				else if ( ((LA37_0>='\u0000' && LA37_0<='\t')||(LA37_0>='\u000B' && LA37_0<='\f')||(LA37_0>='\u000E' && LA37_0<='=')||(LA37_0>='?' && LA37_0<='\uFFFF')) && (synpred16_AngleBracketTemplateLexer())) {s = 4;}
+				else if ( ((LA37_0>='\u0000' && LA37_0<='\t')||(LA37_0>='\u000B' && LA37_0<='\f')||(LA37_0>='\u000E' && LA37_0<='=')||(LA37_0>='?' && LA37_0<='\uFFFF')) && (synpred13_AngleBracketTemplateLexer())) {s = 4;}


input.Seek(index37_0);
@@ -3586,11 +3446,11 @@ public partial class AngleBracketTemplateLexer : Lexer
s = -1;
if ( (LA37_1=='>') ) {s = 5;}

-				else if ( (LA37_1=='\r') && (synpred16_AngleBracketTemplateLexer())) {s = 6;}
+				else if ( (LA37_1=='\r') && (synpred13_AngleBracketTemplateLexer())) {s = 6;}

-				else if ( (LA37_1=='\n') && (synpred16_AngleBracketTemplateLexer())) {s = 7;}
+				else if ( (LA37_1=='\n') && (synpred13_AngleBracketTemplateLexer())) {s = 7;}

-				else if ( ((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) && (synpred16_AngleBracketTemplateLexer())) {s = 8;}
+				else if ( ((LA37_1>='\u0000' && LA37_1<='\t')||(LA37_1>='\u000B' && LA37_1<='\f')||(LA37_1>='\u000E' && LA37_1<='=')||(LA37_1>='?' && LA37_1<='\uFFFF')) && (synpred13_AngleBracketTemplateLexer())) {s = 8;}


input.Seek(index37_1);
@@ -3604,9 +3464,9 @@ public partial class AngleBracketTemplateLexer : Lexer
int index37_2 = input.Index;
input.Rewind();
s = -1;
-				if ( (synpred15_AngleBracketTemplateLexer()) ) {s = 13;}
+				if ( (synpred12_AngleBracketTemplateLexer()) ) {s = 13;}

-				else if ( (synpred16_AngleBracketTemplateLexer()) ) {s = 8;}
+				else if ( (synpred13_AngleBracketTemplateLexer()) ) {s = 8;}


input.Seek(index37_2);
@@ -3620,9 +3480,9 @@ public partial class AngleBracketTemplateLexer : Lexer
int index37_3 = input.Index;
input.Rewind();
s = -1;
-				if ( (synpred15_AngleBracketTemplateLexer()) ) {s = 13;}
+				if ( (synpred12_AngleBracketTemplateLexer()) ) {s = 13;}

-				else if ( (synpred16_AngleBracketTemplateLexer()) ) {s = 8;}
+				else if ( (synpred13_AngleBracketTemplateLexer()) ) {s = 8;}


input.Seek(index37_3);
@@ -3636,7 +3496,7 @@ public partial class AngleBracketTemplateLexer : Lexer
int index37_5 = input.Index;
input.Rewind();
s = -1;
-				if ( (synpred16_AngleBracketTemplateLexer()) ) {s = 8;}
+				if ( (synpred13_AngleBracketTemplateLexer()) ) {s = 8;}

else if ( (true) ) {s = 18;}

diff --git a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3 b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3
index d6608c9..1480965 100644
--- a/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3
+++ b/Antlr3.StringTemplate/Language/AngleBracketTemplateLexer.g3
@@ -73,7 +73,7 @@ options

using StringBuffer = System.Text.StringBuilder;
}
-
+/**/
@lexer::namespace {Antlr3.ST.Language}

NEWLINE
@@ -187,11 +187,10 @@ LITERAL
int col = 0;
}
:	(	(	'\\'
-				(	options {k=1;}:
-					('<') => '<' { builder.Append('<'); } // allow escaped delimiter
-				|	('>') => '>' { builder.Append('>'); }
-				|	('\\') => '\\' { builder.Append('\\'); } // always replace \\ with \
-				|	ch=. { builder.Append( "\\" + (char)$ch ); }  // otherwise ignore escape char
+				(	'<' { builder.Append('<'); } // allow escaped delimiter
+				|	'>' { builder.Append('>'); }
+				|	'\\' { builder.Append('\\'); } // always replace \\ with \
+				|	ch=~('<'|'>'|'\\') { builder.Append( "\\" + (char)$ch ); }  // otherwise ignore escape char
)
)
|	ind=INDENT
diff --git a/Antlr3.StringTemplate/Language/Group.g3 b/Antlr3.StringTemplate/Language/Group.g3
index 8a96954..83050aa 100644
--- a/Antlr3.StringTemplate/Language/Group.g3
+++ b/Antlr3.StringTemplate/Language/Group.g3
@@ -302,64 +302,33 @@ STRING
)
|	ch=~('\\'|'"') {builder.Append((char)$ch);}
)*
-		(	{InColorizer}? => '"'?
-		|	'"'
-		)
+		'"'
{
Text = builder.ToString();
}
;

BIGSTRING
-@init
-{
-	System.Text.StringBuilder builder = new System.Text.StringBuilder();
-}
-	:	(	'<<'
-			{
-				if ( !InAnonymousTemplate && !InBlockComment )
-					InBigString=true;
-			}
-			( ('\r'|'\n') => ('\r')? '\n' )? // consume 1st \n
-			(	('\r\n>>') => '\r' '\n' // kill last \r\n
-			|	('\n>>') => '\n' // kill last \n
-			|	('\r'|'\n') => ('\r' { builder.Append('\r'); })? '\n' { builder.Append('\n'); } // else keep
-			|	('\\>') => '\\>' { builder.Append('>'); } // \> escape
-			|	('>' ~'>' | ~'>') => ch=. { builder.Append((char)$ch); }
-			)*
-			(	'>>'
-				{ InBigString = false; }
-			)?
-		)
+	:	'<<' ('\\>' | '\\' ~'>' | '>' ~'>' | ~('\\'|'>'))* '>>'
{
-			Text = builder.ToString();
+			System.Text.StringBuilder builder = new System.Text.StringBuilder( input.substring( state.tokenStartCharIndex + 2, GetCharIndex() - 3 ) );
+			$text = ProcessBigString( builder );
}
;

ANONYMOUS_TEMPLATE
-@init
-{
-	System.Text.StringBuilder builder = new System.Text.StringBuilder();
-}
-	:	(	'{'
-			{
-				if ( !InBigString && !InBlockComment )
-					InAnonymousTemplate=true;
-			}
-			(	('\r' { builder.Append('\r'); })? '\n' { builder.Append('\n'); } // else keep
-			|	('\\}') => '\\' '}' { builder.Append('}'); }  // \} escape
-			|	ch=~('\r'|'\n'|'}') { builder.Append((char)$ch); }
-			)*
-			(	'}'
-				{ InAnonymousTemplate = false; }
-			)?
-		)
+	:	'{'
+		(	'\\}'
+		|	'\\' ~'}'
+		|	~('\\' | '}')
+		)*
+		'}'
{
-			Text = builder.ToString();
+			System.Text.StringBuilder builder = new System.Text.StringBuilder( input.substring( state.tokenStartCharIndex + 1, GetCharIndex() - 2 ) );
+			$text = ProcessAnonymousTemplate( builder );
}
;

-
AT	:	'@' ;
LPAREN: '(' ;
RPAREN: ')' ;
@@ -375,10 +344,6 @@ PLUS:   '+' ;
ASSIGN:   '=' ;
OPTIONAL : '?' ;

-CLOSE_BIG_STRING : '>>';
-CLOSE_BLOCK_COMMENT : '*/';
-CLOSE_ANON_TEMPLATE : '}';
-
// Single-line comments
SL_COMMENT
:	'//'
@@ -388,17 +353,8 @@ SL_COMMENT

// multiple-line comments
ML_COMMENT
-	:	'/*'
-		{
-			if ( !InAnonymousTemplate && !InBigString )
-				InBlockComment=true;
-
-			$channel = HIDDEN;
-		}
-		(	~('*')
-			|	('*' ~'/') => '*'
-		)*
-		('*/' {InBlockComment = false;})?
+	:	'/*' .* '*/'
+		{ $channel = HIDDEN; }
;

// Whitespace -- ignored
@@ -409,7 +365,3 @@ WS  :   (   ' '
)+
{ $channel = HIDDEN; }
;
-
-ANYCHAR
-	:	.
-	;
diff --git a/Antlr3.StringTemplate/Language/GroupLexer.cs b/Antlr3.StringTemplate/Language/GroupLexer.cs
index fa3ce59..afc1618 100644
--- a/Antlr3.StringTemplate/Language/GroupLexer.cs
+++ b/Antlr3.StringTemplate/Language/GroupLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Group.g3 2009-03-07 08:51:18
+// $ANTLR 3.1.2 Language\\Group.g3 2009-03-16 20:26:39

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -44,41 +44,36 @@ using Antlr.Runtime;
using Stack = System.Collections.Generic.Stack<object>;
using List = System.Collections.IList;
using ArrayList = System.Collections.Generic.List<object>;
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary<object, object>;
+
namespace Antlr3.ST.Language
{
public partial class GroupLexer : Lexer
{
public const int EOF=-1;
public const int ANONYMOUS_TEMPLATE=4;
-	public const int ANYCHAR=5;
-	public const int ASSIGN=6;
-	public const int AT=7;
-	public const int BIGSTRING=8;
-	public const int CLOSE_ANON_TEMPLATE=9;
-	public const int CLOSE_BIG_STRING=10;
-	public const int CLOSE_BLOCK_COMMENT=11;
-	public const int COLON=12;
-	public const int COMMA=13;
-	public const int DEFINED_TO_BE=14;
-	public const int DOT=15;
-	public const int ID=16;
-	public const int KWDEFAULT=17;
-	public const int KWGROUP=18;
-	public const int KWIMPLEMENTS=19;
-	public const int LBRACK=20;
-	public const int LPAREN=21;
-	public const int ML_COMMENT=22;
-	public const int OPTIONAL=23;
-	public const int PLUS=24;
-	public const int RBRACK=25;
-	public const int RPAREN=26;
-	public const int SEMI=27;
-	public const int SL_COMMENT=28;
-	public const int STAR=29;
-	public const int STRING=30;
-	public const int WS=31;
+	public const int ASSIGN=5;
+	public const int AT=6;
+	public const int BIGSTRING=7;
+	public const int COLON=8;
+	public const int COMMA=9;
+	public const int DEFINED_TO_BE=10;
+	public const int DOT=11;
+	public const int ID=12;
+	public const int KWDEFAULT=13;
+	public const int KWGROUP=14;
+	public const int KWIMPLEMENTS=15;
+	public const int LBRACK=16;
+	public const int LPAREN=17;
+	public const int ML_COMMENT=18;
+	public const int OPTIONAL=19;
+	public const int PLUS=20;
+	public const int RBRACK=21;
+	public const int RPAREN=22;
+	public const int SEMI=23;
+	public const int SL_COMMENT=24;
+	public const int STAR=25;
+	public const int STRING=26;
+	public const int WS=27;

// delegates
// delegators
@@ -105,7 +100,7 @@ public partial class GroupLexer : Lexer
// Language\\Group.g3:42:13: ( 'default' )
// Language\\Group.g3:42:13: 'default'
{
-			Match("default"); if (state.failed) return ;
+			Match("default");


}
@@ -129,7 +124,7 @@ public partial class GroupLexer : Lexer
// Language\\Group.g3:43:11: ( 'group' )
// Language\\Group.g3:43:11: 'group'
{
-			Match("group"); if (state.failed) return ;
+			Match("group");


}
@@ -153,7 +148,7 @@ public partial class GroupLexer : Lexer
// Language\\Group.g3:44:16: ( 'implements' )
// Language\\Group.g3:44:16: 'implements'
{
-			Match("implements"); if (state.failed) return ;
+			Match("implements");


}
@@ -180,11 +175,10 @@ public partial class GroupLexer : Lexer
if ( (input.LA(1)>='A' && input.LA(1)<='Z')||input.LA(1)=='_'||(input.LA(1)>='a' && input.LA(1)<='z') )
{
input.Consume();
-			state.failed=false;
+
}
else
{
-				if (state.backtracking>0) {state.failed=true; return ;}
MismatchedSetException mse = new MismatchedSetException(null,input);
Recover(mse);
throw mse;}
@@ -207,7 +201,7 @@ public partial class GroupLexer : Lexer
// Language\\Group.g3:
{
input.Consume();
-					state.failed=false;
+

}
break;
@@ -245,10 +239,10 @@ public partial class GroupLexer : Lexer

System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Group.g3:298:4: ( '\"' ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )* ({...}? => ( '\"' )? | '\"' ) )
-			// Language\\Group.g3:298:4: '\"' ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )* ({...}? => ( '\"' )? | '\"' )
+			// Language\\Group.g3:298:4: ( '\"' ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )* '\"' )
+			// Language\\Group.g3:298:4: '\"' ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )* '\"'
{
-			Match('\"'); if (state.failed) return ;
+			Match('\"');
// Language\\Group.g3:299:3: ( '\\\\' ( '\"' |ch=~ '\"' ) |ch=~ ( '\\\\' | '\"' ) )*
for ( ; ; )
{
@@ -270,7 +264,7 @@ public partial class GroupLexer : Lexer
case 1:
// Language\\Group.g3:299:5: '\\\\' ( '\"' |ch=~ '\"' )
{
-					Match('\\'); if (state.failed) return ;
+					Match('\\');
// Language\\Group.g3:300:4: ( '\"' |ch=~ '\"' )
int alt2=2;
int LA2_0 = input.LA(1);
@@ -285,7 +279,6 @@ public partial class GroupLexer : Lexer
}
else
{
-						if (state.backtracking>0) {state.failed=true; return ;}
NoViableAltException nvae = new NoViableAltException("", 2, 0, input);

throw nvae;
@@ -295,11 +288,8 @@ public partial class GroupLexer : Lexer
case 1:
// Language\\Group.g3:300:6: '\"'
{
-						Match('\"'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append('"');
-						}
+						Match('\"');
+						builder.Append('"');

}
break;
@@ -308,11 +298,8 @@ public partial class GroupLexer : Lexer
{
ch= input.LA(1);
input.Consume();
-						state.failed=false;
-						if ( state.backtracking == 0 )
-						{
-							builder.Append("\\" + (char)ch);
-						}
+
+						builder.Append("\\" + (char)ch);

}
break;
@@ -327,11 +314,8 @@ public partial class GroupLexer : Lexer
{
ch= input.LA(1);
input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						builder.Append((char)ch);
-					}
+
+					builder.Append((char)ch);

}
break;
@@ -345,82 +329,10 @@ public partial class GroupLexer : Lexer
;


-			// Language\\Group.g3:305:3: ({...}? => ( '\"' )? | '\"' )
-			int alt5=2;
-			int LA5_0 = input.LA(1);
-
-			if ( (LA5_0=='\"') )
-			{
-				int LA5_1 = input.LA(2);
-
-				if ( ((InColorizer)) )
-				{
-					alt5=1;
-				}
-				else if ( (true) )
-				{
-					alt5=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 5, 1, input);
-
-					throw nvae;
-				}
-			}
-			else
-			{
-				alt5=1;}
-			switch ( alt5 )
-			{
-			case 1:
-				// Language\\Group.g3:305:5: {...}? => ( '\"' )?
-				{
-				if ( !((InColorizer)) )
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					throw new FailedPredicateException(input, "STRING", "InColorizer");
-				}
-				// Language\\Group.g3:305:23: ( '\"' )?
-				int alt4=2;
-				int LA4_0 = input.LA(1);
-
-				if ( (LA4_0=='\"') )
-				{
-					alt4=1;
-				}
-				switch ( alt4 )
-				{
-				case 1:
-					// Language\\Group.g3:305:0: '\"'
-					{
-					Match('\"'); if (state.failed) return ;
-
-					}
-					break;
-
-				}
-
-
-				}
-				break;
-			case 2:
-				// Language\\Group.g3:306:5: '\"'
-				{
-				Match('\"'); if (state.failed) return ;
-
-				}
-				break;
-
-			}
+			Match('\"');

-			if ( state.backtracking == 0 )
-			{
-
-							Text = builder.ToString();
-
-			}
+						Text = builder.ToString();
+

}

@@ -440,216 +352,101 @@ public partial class GroupLexer : Lexer
{
int _type = BIGSTRING;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			int ch;
-
-
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\Group.g3:318:4: ( ( '<<' (=> ( '\\r' )? '\\n' )? (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )* ( '>>' )? ) )
-			// Language\\Group.g3:318:4: ( '<<' (=> ( '\\r' )? '\\n' )? (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )* ( '>>' )? )
+			// Language\\Group.g3:312:4: ( '<<' ( '\\\\>' | '\\\\' ~ '>' | '>' ~ '>' |~ ( '\\\\' | '>' ) )* '>>' )
+			// Language\\Group.g3:312:4: '<<' ( '\\\\>' | '\\\\' ~ '>' | '>' ~ '>' |~ ( '\\\\' | '>' ) )* '>>'
{
-			// Language\\Group.g3:318:4: ( '<<' (=> ( '\\r' )? '\\n' )? (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )* ( '>>' )? )
-			// Language\\Group.g3:318:6: '<<' (=> ( '\\r' )? '\\n' )? (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )* ( '>>' )?
-			{
-			Match("<<"); if (state.failed) return ;
-
-			if ( state.backtracking == 0 )
-			{
-
-								if ( !InAnonymousTemplate && !InBlockComment )
-									InBigString=true;
-
-			}
-			// Language\\Group.g3:323:4: (=> ( '\\r' )? '\\n' )?
-			int alt7=2;
-			int LA7_0 = input.LA(1);
+			Match("<<");

-			if ( (LA7_0=='\r') )
+			// Language\\Group.g3:312:9: ( '\\\\>' | '\\\\' ~ '>' | '>' ~ '>' |~ ( '\\\\' | '>' ) )*
+			for ( ; ; )
{
-				int LA7_1 = input.LA(2);
+				int alt4=5;
+				int LA4_0 = input.LA(1);

-				if ( (LA7_1=='\n') )
+				if ( (LA4_0=='>') )
{
-					int LA7_4 = input.LA(3);
+					int LA4_1 = input.LA(2);

-					if ( (synpred1_Group()) )
+					if ( ((LA4_1>='\u0000' && LA4_1<='=')||(LA4_1>='?' && LA4_1<='\uFFFF')) )
{
-						alt7=1;
+						alt4=3;
}
-				}
-			}
-			else if ( (LA7_0=='\n') )
-			{
-				int LA7_2 = input.LA(2);
-
-				if ( (synpred1_Group()) )
-				{
-					alt7=1;
-				}
-			}
-			switch ( alt7 )
-			{
-			case 1:
-				// Language\\Group.g3:323:6: => ( '\\r' )? '\\n'
-				{

-				// Language\\Group.g3:323:21: ( '\\r' )?
-				int alt6=2;
-				int LA6_0 = input.LA(1);

-				if ( (LA6_0=='\r') )
-				{
-					alt6=1;
}
-				switch ( alt6 )
+				else if ( (LA4_0=='\\') )
{
-				case 1:
-					// Language\\Group.g3:323:22: '\\r'
-					{
-					Match('\r'); if (state.failed) return ;
+					int LA4_2 = input.LA(2);

+					if ( (LA4_2=='>') )
+					{
+						alt4=1;
+					}
+					else if ( ((LA4_2>='\u0000' && LA4_2<='=')||(LA4_2>='?' && LA4_2<='\uFFFF')) )
+					{
+						alt4=2;
}
-					break;
-
-				}

-				Match('\n'); if (state.failed) return ;

}
-				break;
+				else if ( ((LA4_0>='\u0000' && LA4_0<='=')||(LA4_0>='?' && LA4_0<='[')||(LA4_0>=']' && LA4_0<='\uFFFF')) )
+				{
+					alt4=4;
+				}

-			}

-			// Language\\Group.g3:324:4: (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )*
-			for ( ; ; )
-			{
-				int alt9=6;
-				alt9 = dfa9.Predict(input);
-				switch ( alt9 )
+				switch ( alt4 )
{
case 1:
-					// Language\\Group.g3:324:6: => '\\r' '\\n'
+					// Language\\Group.g3:312:10: '\\\\>'
{
+					Match("\\>");

-					Match('\r'); if (state.failed) return ;
-					Match('\n'); if (state.failed) return ;

}
break;
case 2:
-					// Language\\Group.g3:325:6: => '\\n'
+					// Language\\Group.g3:312:18: '\\\\' ~ '>'
{
+					Match('\\');
+					input.Consume();

-					Match('\n'); if (state.failed) return ;

}
break;
case 3:
-					// Language\\Group.g3:326:6: => ( '\\r' )? '\\n'
-					{
-
-					// Language\\Group.g3:326:21: ( '\\r' )?
-					int alt8=2;
-					int LA8_0 = input.LA(1);
-
-					if ( (LA8_0=='\r') )
-					{
-						alt8=1;
-					}
-					switch ( alt8 )
+					// Language\\Group.g3:312:30: '>' ~ '>'
{
-					case 1:
-						// Language\\Group.g3:326:22: '\\r'
-						{
-						Match('\r'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							 builder.Append('\r');
-						}
-
-						}
-						break;
-
-					}
+					Match('>');
+					input.Consume();

-					Match('\n'); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						 builder.Append('\n');
-					}

}
break;
case 4:
-					// Language\\Group.g3:327:6: => '\\\\>'
-					{
-
-					Match("\\>"); if (state.failed) return ;
-
-					if ( state.backtracking == 0 )
-					{
-						 builder.Append('>');
-					}
-
-					}
-					break;
-				case 5:
-					// Language\\Group.g3:328:6: =>ch= .
+					// Language\\Group.g3:312:41: ~ ( '\\\\' | '>' )
{
+					input.Consume();

-					ch = input.LA(1);
-					MatchAny(); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						 builder.Append((char)ch);
-					}

}
break;

default:
-					goto loop9;
+					goto loop4;
}
}

-			loop9:
+			loop4:
;


-			// Language\\Group.g3:330:4: ( '>>' )?
-			int alt10=2;
-			int LA10_0 = input.LA(1);
-
-			if ( (LA10_0=='>') )
-			{
-				alt10=1;
-			}
-			switch ( alt10 )
-			{
-			case 1:
-				// Language\\Group.g3:330:6: '>>'
-				{
-				Match(">>"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-					 InBigString = false;
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
+			Match(">>");

-			if ( state.backtracking == 0 )
-			{

-							Text = builder.ToString();
-
-			}
+						System.Text.StringBuilder builder = new System.Text.StringBuilder( input.substring( state.tokenStartCharIndex + 2, GetCharIndex() - 3 ) );
+						Text = ProcessBigString( builder );
+

}

@@ -669,173 +466,79 @@ public partial class GroupLexer : Lexer
{
int _type = ANONYMOUS_TEMPLATE;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			int ch;
-
-
-				System.Text.StringBuilder builder = new System.Text.StringBuilder();
-
-			// Language\\Group.g3:344:4: ( ( '{' ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )* ( '}' )? ) )
-			// Language\\Group.g3:344:4: ( '{' ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )* ( '}' )? )
-			{
-			// Language\\Group.g3:344:4: ( '{' ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )* ( '}' )? )
-			// Language\\Group.g3:344:6: '{' ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )* ( '}' )?
-			{
-			Match('{'); if (state.failed) return ;
-			if ( state.backtracking == 0 )
+			// Language\\Group.g3:320:4: ( '{' ( '\\\\}' | '\\\\' ~ '}' |~ ( '\\\\' | '}' ) )* '}' )
+			// Language\\Group.g3:320:4: '{' ( '\\\\}' | '\\\\' ~ '}' |~ ( '\\\\' | '}' ) )* '}'
{
-
-								if ( !InBigString && !InBlockComment )
-									InAnonymousTemplate=true;
-
-			}
-			// Language\\Group.g3:349:4: ( ( '\\r' )? '\\n' |=> '\\\\' '}' |ch=~ ( '\\r' | '\\n' | '}' ) )*
+			Match('{');
+			// Language\\Group.g3:321:3: ( '\\\\}' | '\\\\' ~ '}' |~ ( '\\\\' | '}' ) )*
for ( ; ; )
{
-				int alt12=4;
-				int LA12_0 = input.LA(1);
+				int alt5=4;
+				int LA5_0 = input.LA(1);

-				if ( (LA12_0=='\n'||LA12_0=='\r') )
-				{
-					alt12=1;
-				}
-				else if ( (LA12_0=='\\') )
+				if ( (LA5_0=='\\') )
{
-					int LA12_3 = input.LA(2);
+					int LA5_2 = input.LA(2);

-					if ( (LA12_3=='}') )
+					if ( (LA5_2=='}') )
{
-						int LA12_5 = input.LA(3);
-
-						if ( (synpred7_Group()) )
-						{
-							alt12=2;
-						}
-						else if ( (true) )
-						{
-							alt12=3;
-						}
-
-
+						alt5=1;
}
-
-					else
+					else if ( ((LA5_2>='\u0000' && LA5_2<='|')||(LA5_2>='~' && LA5_2<='\uFFFF')) )
{
-						alt12=3;
+						alt5=2;
}

+
}
-				else if ( ((LA12_0>='\u0000' && LA12_0<='\t')||(LA12_0>='\u000B' && LA12_0<='\f')||(LA12_0>='\u000E' && LA12_0<='[')||(LA12_0>=']' && LA12_0<='|')||(LA12_0>='~' && LA12_0<='\uFFFF')) )
+				else if ( ((LA5_0>='\u0000' && LA5_0<='[')||(LA5_0>=']' && LA5_0<='|')||(LA5_0>='~' && LA5_0<='\uFFFF')) )
{
-					alt12=3;
+					alt5=3;
}


-				switch ( alt12 )
+				switch ( alt5 )
{
case 1:
-					// Language\\Group.g3:349:6: ( '\\r' )? '\\n'
-					{
-					// Language\\Group.g3:349:6: ( '\\r' )?
-					int alt11=2;
-					int LA11_0 = input.LA(1);
-
-					if ( (LA11_0=='\r') )
+					// Language\\Group.g3:321:5: '\\\\}'
{
-						alt11=1;
-					}
-					switch ( alt11 )
-					{
-					case 1:
-						// Language\\Group.g3:349:7: '\\r'
-						{
-						Match('\r'); if (state.failed) return ;
-						if ( state.backtracking == 0 )
-						{
-							 builder.Append('\r');
-						}
-
-						}
-						break;
-
-					}
+					Match("\\}");

-					Match('\n'); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						 builder.Append('\n');
-					}

}
break;
case 2:
-					// Language\\Group.g3:350:6: => '\\\\' '}'
+					// Language\\Group.g3:322:5: '\\\\' ~ '}'
{
+					Match('\\');
+					input.Consume();

-					Match('\\'); if (state.failed) return ;
-					Match('}'); if (state.failed) return ;
-					if ( state.backtracking == 0 )
-					{
-						 builder.Append('}');
-					}

}
break;
case 3:
-					// Language\\Group.g3:351:6: ch=~ ( '\\r' | '\\n' | '}' )
+					// Language\\Group.g3:323:5: ~ ( '\\\\' | '}' )
{
-					ch= input.LA(1);
input.Consume();
-					state.failed=false;
-					if ( state.backtracking == 0 )
-					{
-						 builder.Append((char)ch);
-					}
+

}
break;

default:
-					goto loop12;
+					goto loop5;
}
}

-			loop12:
+			loop5:
;


-			// Language\\Group.g3:353:4: ( '}' )?
-			int alt13=2;
-			int LA13_0 = input.LA(1);
+			Match('}');

-			if ( (LA13_0=='}') )
-			{
-				alt13=1;
-			}
-			switch ( alt13 )
-			{
-			case 1:
-				// Language\\Group.g3:353:6: '}'
-				{
-				Match('}'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					 InAnonymousTemplate = false;
-				}
-
-				}
-				break;
-
-			}
-
-
-			}
-
-			if ( state.backtracking == 0 )
-			{
-
-							Text = builder.ToString();
-
-			}
+						System.Text.StringBuilder builder = new System.Text.StringBuilder( input.substring( state.tokenStartCharIndex + 1, GetCharIndex() - 2 ) );
+						Text = ProcessAnonymousTemplate( builder );
+

}

@@ -855,10 +558,10 @@ public partial class GroupLexer : Lexer
{
int _type = AT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:363:6: ( '@' )
-			// Language\\Group.g3:363:6: '@'
+			// Language\\Group.g3:332:6: ( '@' )
+			// Language\\Group.g3:332:6: '@'
{
-			Match('@'); if (state.failed) return ;
+			Match('@');

}

@@ -878,10 +581,10 @@ public partial class GroupLexer : Lexer
{
int _type = LPAREN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:364:9: ( '(' )
-			// Language\\Group.g3:364:9: '('
+			// Language\\Group.g3:333:9: ( '(' )
+			// Language\\Group.g3:333:9: '('
{
-			Match('('); if (state.failed) return ;
+			Match('(');

}

@@ -901,10 +604,10 @@ public partial class GroupLexer : Lexer
{
int _type = RPAREN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:365:9: ( ')' )
-			// Language\\Group.g3:365:9: ')'
+			// Language\\Group.g3:334:9: ( ')' )
+			// Language\\Group.g3:334:9: ')'
{
-			Match(')'); if (state.failed) return ;
+			Match(')');

}

@@ -924,10 +627,10 @@ public partial class GroupLexer : Lexer
{
int _type = LBRACK;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:366:9: ( '[' )
-			// Language\\Group.g3:366:9: '['
+			// Language\\Group.g3:335:9: ( '[' )
+			// Language\\Group.g3:335:9: '['
{
-			Match('['); if (state.failed) return ;
+			Match('[');

}

@@ -947,10 +650,10 @@ public partial class GroupLexer : Lexer
{
int _type = RBRACK;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:367:9: ( ']' )
-			// Language\\Group.g3:367:9: ']'
+			// Language\\Group.g3:336:9: ( ']' )
+			// Language\\Group.g3:336:9: ']'
{
-			Match(']'); if (state.failed) return ;
+			Match(']');

}

@@ -970,10 +673,10 @@ public partial class GroupLexer : Lexer
{
int _type = COMMA;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:368:9: ( ',' )
-			// Language\\Group.g3:368:9: ','
+			// Language\\Group.g3:337:9: ( ',' )
+			// Language\\Group.g3:337:9: ','
{
-			Match(','); if (state.failed) return ;
+			Match(',');

}

@@ -993,10 +696,10 @@ public partial class GroupLexer : Lexer
{
int _type = DOT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:369:7: ( '.' )
-			// Language\\Group.g3:369:7: '.'
+			// Language\\Group.g3:338:7: ( '.' )
+			// Language\\Group.g3:338:7: '.'
{
-			Match('.'); if (state.failed) return ;
+			Match('.');

}

@@ -1016,10 +719,10 @@ public partial class GroupLexer : Lexer
{
int _type = DEFINED_TO_BE;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:370:17: ( '::=' )
-			// Language\\Group.g3:370:17: '::='
+			// Language\\Group.g3:339:17: ( '::=' )
+			// Language\\Group.g3:339:17: '::='
{
-			Match("::="); if (state.failed) return ;
+			Match("::=");


}
@@ -1040,10 +743,10 @@ public partial class GroupLexer : Lexer
{
int _type = SEMI;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:371:9: ( ';' )
-			// Language\\Group.g3:371:9: ';'
+			// Language\\Group.g3:340:9: ( ';' )
+			// Language\\Group.g3:340:9: ';'
{
-			Match(';'); if (state.failed) return ;
+			Match(';');

}

@@ -1063,10 +766,10 @@ public partial class GroupLexer : Lexer
{
int _type = COLON;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:372:9: ( ':' )
-			// Language\\Group.g3:372:9: ':'
+			// Language\\Group.g3:341:9: ( ':' )
+			// Language\\Group.g3:341:9: ':'
{
-			Match(':'); if (state.failed) return ;
+			Match(':');

}

@@ -1086,10 +789,10 @@ public partial class GroupLexer : Lexer
{
int _type = STAR;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:373:9: ( '*' )
-			// Language\\Group.g3:373:9: '*'
+			// Language\\Group.g3:342:9: ( '*' )
+			// Language\\Group.g3:342:9: '*'
{
-			Match('*'); if (state.failed) return ;
+			Match('*');

}

@@ -1109,10 +812,10 @@ public partial class GroupLexer : Lexer
{
int _type = PLUS;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:374:9: ( '+' )
-			// Language\\Group.g3:374:9: '+'
+			// Language\\Group.g3:343:9: ( '+' )
+			// Language\\Group.g3:343:9: '+'
{
-			Match('+'); if (state.failed) return ;
+			Match('+');

}

@@ -1132,10 +835,10 @@ public partial class GroupLexer : Lexer
{
int _type = ASSIGN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:375:11: ( '=' )
-			// Language\\Group.g3:375:11: '='
+			// Language\\Group.g3:344:11: ( '=' )
+			// Language\\Group.g3:344:11: '='
{
-			Match('='); if (state.failed) return ;
+			Match('=');

}

@@ -1155,10 +858,10 @@ public partial class GroupLexer : Lexer
{
int _type = OPTIONAL;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:376:12: ( '?' )
-			// Language\\Group.g3:376:12: '?'
+			// Language\\Group.g3:345:12: ( '?' )
+			// Language\\Group.g3:345:12: '?'
{
-			Match('?'); if (state.failed) return ;
+			Match('?');

}

@@ -1171,165 +874,91 @@ public partial class GroupLexer : Lexer
}
// $ANTLR end "OPTIONAL"

-	// $ANTLR start "CLOSE_BIG_STRING"
-	private void mCLOSE_BIG_STRING()
+	// $ANTLR start "SL_COMMENT"
+	private void mSL_COMMENT()
{
try
{
-			int _type = CLOSE_BIG_STRING;
+			int _type = SL_COMMENT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:378:20: ( '>>' )
-			// Language\\Group.g3:378:20: '>>'
+			// Language\\Group.g3:349:4: ( '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )? )
+			// Language\\Group.g3:349:4: '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )?
{
-			Match(">>"); if (state.failed) return ;
+			Match("//");

+			// Language\\Group.g3:350:3: (~ ( '\\n' | '\\r' ) )*
+			for ( ; ; )
+			{
+				int alt6=2;
+				int LA6_0 = input.LA(1);

-			}
+				if ( ((LA6_0>='\u0000' && LA6_0<='\t')||(LA6_0>='\u000B' && LA6_0<='\f')||(LA6_0>='\u000E' && LA6_0<='\uFFFF')) )
+				{
+					alt6=1;
+				}

-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "CLOSE_BIG_STRING"

-	// $ANTLR start "CLOSE_BLOCK_COMMENT"
-	private void mCLOSE_BLOCK_COMMENT()
-	{
-		try
-		{
-			int _type = CLOSE_BLOCK_COMMENT;
-			int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:379:23: ( '*/' )
-			// Language\\Group.g3:379:23: '*/'
-			{
-			Match("*/"); if (state.failed) return ;
+				switch ( alt6 )
+				{
+				case 1:
+					// Language\\Group.g3:
+					{
+					input.Consume();


+					}
+					break;
+
+				default:
+					goto loop6;
+				}
}

-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "CLOSE_BLOCK_COMMENT"
-
-	// $ANTLR start "CLOSE_ANON_TEMPLATE"
-	private void mCLOSE_ANON_TEMPLATE()
-	{
-		try
-		{
-			int _type = CLOSE_ANON_TEMPLATE;
-			int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:380:23: ( '}' )
-			// Language\\Group.g3:380:23: '}'
-			{
-			Match('}'); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "CLOSE_ANON_TEMPLATE"
-
-	// $ANTLR start "SL_COMMENT"
-	private void mSL_COMMENT()
-	{
-		try
-		{
-			int _type = SL_COMMENT;
-			int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:384:4: ( '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )? )
-			// Language\\Group.g3:384:4: '//' (~ ( '\\n' | '\\r' ) )* ( ( '\\r' )? '\\n' )?
-			{
-			Match("//"); if (state.failed) return ;
-
-			// Language\\Group.g3:385:3: (~ ( '\\n' | '\\r' ) )*
-			for ( ; ; )
-			{
-				int alt14=2;
-				int LA14_0 = input.LA(1);
-
-				if ( ((LA14_0>='\u0000' && LA14_0<='\t')||(LA14_0>='\u000B' && LA14_0<='\f')||(LA14_0>='\u000E' && LA14_0<='\uFFFF')) )
-				{
-					alt14=1;
-				}
+			loop6:
+				;


-				switch ( alt14 )
-				{
-				case 1:
-					// Language\\Group.g3:
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-
-				default:
-					goto loop14;
-				}
-			}
-
-			loop14:
-				;
+			// Language\\Group.g3:350:19: ( ( '\\r' )? '\\n' )?
+			int alt8=2;
+			int LA8_0 = input.LA(1);

-
-			// Language\\Group.g3:385:19: ( ( '\\r' )? '\\n' )?
-			int alt16=2;
-			int LA16_0 = input.LA(1);
-
-			if ( (LA16_0=='\n'||LA16_0=='\r') )
+			if ( (LA8_0=='\n'||LA8_0=='\r') )
{
-				alt16=1;
+				alt8=1;
}
-			switch ( alt16 )
+			switch ( alt8 )
{
case 1:
-				// Language\\Group.g3:385:20: ( '\\r' )? '\\n'
+				// Language\\Group.g3:350:20: ( '\\r' )? '\\n'
{
-				// Language\\Group.g3:385:20: ( '\\r' )?
-				int alt15=2;
-				int LA15_0 = input.LA(1);
+				// Language\\Group.g3:350:20: ( '\\r' )?
+				int alt7=2;
+				int LA7_0 = input.LA(1);

-				if ( (LA15_0=='\r') )
+				if ( (LA7_0=='\r') )
{
-					alt15=1;
+					alt7=1;
}
-				switch ( alt15 )
+				switch ( alt7 )
{
case 1:
-					// Language\\Group.g3:385:21: '\\r'
+					// Language\\Group.g3:350:21: '\\r'
{
-					Match('\r'); if (state.failed) return ;
+					Match('\r');

}
break;

}

-				Match('\n'); if (state.failed) return ;
+				Match('\n');

}
break;

}

-			if ( state.backtracking == 0 )
-			{
-				 _channel = HIDDEN;
-			}
+			 _channel = HIDDEN;

}

@@ -1349,115 +978,60 @@ public partial class GroupLexer : Lexer
{
int _type = ML_COMMENT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:391:4: ( '/*' (~ ( '*' ) |=> '*' )* ( '*/' )? )
-			// Language\\Group.g3:391:4: '/*' (~ ( '*' ) |=> '*' )* ( '*/' )?
-			{
-			Match("/*"); if (state.failed) return ;
-
-			if ( state.backtracking == 0 )
+			// Language\\Group.g3:356:4: ( '/*' ( . )* '*/' )
+			// Language\\Group.g3:356:4: '/*' ( . )* '*/'
{
+			Match("/*");

-							if ( !InAnonymousTemplate && !InBigString )
-								InBlockComment=true;
-
-							_channel = HIDDEN;
-
-			}
-			// Language\\Group.g3:398:3: (~ ( '*' ) |=> '*' )*
+			// Language\\Group.g3:356:9: ( . )*
for ( ; ; )
{
-				int alt17=3;
-				int LA17_0 = input.LA(1);
+				int alt9=2;
+				int LA9_0 = input.LA(1);

-				if ( (LA17_0=='*') )
+				if ( (LA9_0=='*') )
{
-					int LA17_1 = input.LA(2);
+					int LA9_1 = input.LA(2);

-					if ( (LA17_1=='/') )
+					if ( (LA9_1=='/') )
{
-						int LA17_4 = input.LA(3);
-
-						if ( (synpred8_Group()) )
-						{
-							alt17=2;
-						}
-
-
-					}
-					else if ( (LA17_1=='*') && (synpred8_Group()))
-					{
-						alt17=2;
+						alt9=2;
}
-					else if ( ((LA17_1>='\u0000' && LA17_1<=')')||(LA17_1>='+' && LA17_1<='.')||(LA17_1>='0' && LA17_1<='\uFFFF')) && (synpred8_Group()))
+					else if ( ((LA9_1>='\u0000' && LA9_1<='.')||(LA9_1>='0' && LA9_1<='\uFFFF')) )
{
-						alt17=2;
+						alt9=1;
}

-					else
-					{
-						alt17=2;
-					}

}
-				else if ( ((LA17_0>='\u0000' && LA17_0<=')')||(LA17_0>='+' && LA17_0<='\uFFFF')) )
+				else if ( ((LA9_0>='\u0000' && LA9_0<=')')||(LA9_0>='+' && LA9_0<='\uFFFF')) )
{
-					alt17=1;
+					alt9=1;
}


-				switch ( alt17 )
+				switch ( alt9 )
{
case 1:
-					// Language\\Group.g3:398:5: ~ ( '*' )
+					// Language\\Group.g3:356:0: .
{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-				case 2:
-					// Language\\Group.g3:399:6: => '*'
-					{
-
-					Match('*'); if (state.failed) return ;
+					MatchAny();

}
break;

default:
-					goto loop17;
+					goto loop9;
}
}

-			loop17:
+			loop9:
;


-			// Language\\Group.g3:401:3: ( '*/' )?
-			int alt18=2;
-			int LA18_0 = input.LA(1);
-
-			if ( (LA18_0=='*') )
-			{
-				alt18=1;
-			}
-			switch ( alt18 )
-			{
-			case 1:
-				// Language\\Group.g3:401:4: '*/'
-				{
-				Match("*/"); if (state.failed) return ;
-
-				if ( state.backtracking == 0 )
-				{
-					InBlockComment = false;
-				}
-
-				}
-				break;
-
-			}
+			Match("*/");

+			 _channel = HIDDEN;

}

@@ -1477,109 +1051,105 @@ public partial class GroupLexer : Lexer
{
int _type = WS;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:405:9: ( ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+ )
-			// Language\\Group.g3:405:9: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
+			// Language\\Group.g3:361:9: ( ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+ )
+			// Language\\Group.g3:361:9: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
{
-			// Language\\Group.g3:405:9: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
-			int cnt20=0;
+			// Language\\Group.g3:361:9: ( ' ' | '\\t' | '\\f' | ( '\\r' )? '\\n' )+
+			int cnt11=0;
for ( ; ; )
{
-				int alt20=5;
+				int alt11=5;
switch ( input.LA(1) )
{
case ' ':
{
-					alt20=1;
+					alt11=1;
}
break;
case '\t':
{
-					alt20=2;
+					alt11=2;
}
break;
case '\f':
{
-					alt20=3;
+					alt11=3;
}
break;
case '\n':
case '\r':
{
-					alt20=4;
+					alt11=4;
}
break;

}

-				switch ( alt20 )
+				switch ( alt11 )
{
case 1:
-					// Language\\Group.g3:405:13: ' '
+					// Language\\Group.g3:361:13: ' '
{
-					Match(' '); if (state.failed) return ;
+					Match(' ');

}
break;
case 2:
-					// Language\\Group.g3:406:13: '\\t'
+					// Language\\Group.g3:362:13: '\\t'
{
-					Match('\t'); if (state.failed) return ;
+					Match('\t');

}
break;
case 3:
-					// Language\\Group.g3:407:13: '\\f'
+					// Language\\Group.g3:363:13: '\\f'
{
-					Match('\f'); if (state.failed) return ;
+					Match('\f');

}
break;
case 4:
-					// Language\\Group.g3:408:13: ( '\\r' )? '\\n'
+					// Language\\Group.g3:364:13: ( '\\r' )? '\\n'
{
-					// Language\\Group.g3:408:13: ( '\\r' )?
-					int alt19=2;
-					int LA19_0 = input.LA(1);
+					// Language\\Group.g3:364:13: ( '\\r' )?
+					int alt10=2;
+					int LA10_0 = input.LA(1);

-					if ( (LA19_0=='\r') )
+					if ( (LA10_0=='\r') )
{
-						alt19=1;
+						alt10=1;
}
-					switch ( alt19 )
+					switch ( alt10 )
{
case 1:
-						// Language\\Group.g3:408:14: '\\r'
+						// Language\\Group.g3:364:14: '\\r'
{
-						Match('\r'); if (state.failed) return ;
+						Match('\r');

}
break;

}

-					Match('\n'); if (state.failed) return ;
+					Match('\n');

}
break;

default:
-					if ( cnt20 >= 1 )
-						goto loop20;
+					if ( cnt11 >= 1 )
+						goto loop11;

-					if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee20 = new EarlyExitException( 20, input );
-					throw eee20;
+					EarlyExitException eee11 = new EarlyExitException( 11, input );
+					throw eee11;
}
-				cnt20++;
+				cnt11++;
}
-			loop20:
+			loop11:
;


-			if ( state.backtracking == 0 )
-			{
-				 _channel = HIDDEN;
-			}
+			 _channel = HIDDEN;

}

@@ -1592,229 +1162,178 @@ public partial class GroupLexer : Lexer
}
// $ANTLR end "WS"

-	// $ANTLR start "ANYCHAR"
-	private void mANYCHAR()
-	{
-		try
-		{
-			int _type = ANYCHAR;
-			int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Group.g3:414:4: ( . )
-			// Language\\Group.g3:414:4: .
-			{
-			MatchAny(); if (state.failed) return ;
-
-			}
-
-			state.type = _type;
-			state.channel = _channel;
-		}
-		finally
-		{
-		}
-	}
-	// $ANTLR end "ANYCHAR"
-
public override void mTokens()
{
-		// Language\\Group.g3:1:10: ( KWDEFAULT | KWGROUP | KWIMPLEMENTS | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | AT | LPAREN | RPAREN | LBRACK | RBRACK | COMMA | DOT | DEFINED_TO_BE | SEMI | COLON | STAR | PLUS | ASSIGN | OPTIONAL | CLOSE_BIG_STRING | CLOSE_BLOCK_COMMENT | CLOSE_ANON_TEMPLATE | SL_COMMENT | ML_COMMENT | WS | ANYCHAR )
-		int alt21=28;
-		alt21 = dfa21.Predict(input);
-		switch ( alt21 )
+		// Language\\Group.g3:1:10: ( KWDEFAULT | KWGROUP | KWIMPLEMENTS | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | AT | LPAREN | RPAREN | LBRACK | RBRACK | COMMA | DOT | DEFINED_TO_BE | SEMI | COLON | STAR | PLUS | ASSIGN | OPTIONAL | SL_COMMENT | ML_COMMENT | WS )
+		int alt12=24;
+		alt12 = dfa12.Predict(input);
+		switch ( alt12 )
{
case 1:
// Language\\Group.g3:1:10: KWDEFAULT
{
-			mKWDEFAULT(); if (state.failed) return ;
+			mKWDEFAULT();

}
break;
case 2:
// Language\\Group.g3:1:20: KWGROUP
{
-			mKWGROUP(); if (state.failed) return ;
+			mKWGROUP();

}
break;
case 3:
// Language\\Group.g3:1:28: KWIMPLEMENTS
{
-			mKWIMPLEMENTS(); if (state.failed) return ;
+			mKWIMPLEMENTS();

}
break;
case 4:
// Language\\Group.g3:1:41: ID
{
-			mID(); if (state.failed) return ;
+			mID();

}
break;
case 5:
// Language\\Group.g3:1:44: STRING
{
-			mSTRING(); if (state.failed) return ;
+			mSTRING();

}
break;
case 6:
// Language\\Group.g3:1:51: BIGSTRING
{
-			mBIGSTRING(); if (state.failed) return ;
+			mBIGSTRING();

}
break;
case 7:
// Language\\Group.g3:1:61: ANONYMOUS_TEMPLATE
{
-			mANONYMOUS_TEMPLATE(); if (state.failed) return ;
+			mANONYMOUS_TEMPLATE();

}
break;
case 8:
// Language\\Group.g3:1:80: AT
{
-			mAT(); if (state.failed) return ;
+			mAT();

}
break;
case 9:
// Language\\Group.g3:1:83: LPAREN
{
-			mLPAREN(); if (state.failed) return ;
+			mLPAREN();

}
break;
case 10:
// Language\\Group.g3:1:90: RPAREN
{
-			mRPAREN(); if (state.failed) return ;
+			mRPAREN();

}
break;
case 11:
// Language\\Group.g3:1:97: LBRACK
{
-			mLBRACK(); if (state.failed) return ;
+			mLBRACK();

}
break;
case 12:
// Language\\Group.g3:1:104: RBRACK
{
-			mRBRACK(); if (state.failed) return ;
+			mRBRACK();

}
break;
case 13:
// Language\\Group.g3:1:111: COMMA
{
-			mCOMMA(); if (state.failed) return ;
+			mCOMMA();

}
break;
case 14:
// Language\\Group.g3:1:117: DOT
{
-			mDOT(); if (state.failed) return ;
+			mDOT();

}
break;
case 15:
// Language\\Group.g3:1:121: DEFINED_TO_BE
{
-			mDEFINED_TO_BE(); if (state.failed) return ;
+			mDEFINED_TO_BE();

}
break;
case 16:
// Language\\Group.g3:1:135: SEMI
{
-			mSEMI(); if (state.failed) return ;
+			mSEMI();

}
break;
case 17:
// Language\\Group.g3:1:140: COLON
{
-			mCOLON(); if (state.failed) return ;
+			mCOLON();

}
break;
case 18:
// Language\\Group.g3:1:146: STAR
{
-			mSTAR(); if (state.failed) return ;
+			mSTAR();

}
break;
case 19:
// Language\\Group.g3:1:151: PLUS
{
-			mPLUS(); if (state.failed) return ;
+			mPLUS();

}
break;
case 20:
// Language\\Group.g3:1:156: ASSIGN
{
-			mASSIGN(); if (state.failed) return ;
+			mASSIGN();

}
break;
case 21:
// Language\\Group.g3:1:163: OPTIONAL
{
-			mOPTIONAL(); if (state.failed) return ;
+			mOPTIONAL();

}
break;
case 22:
-			// Language\\Group.g3:1:172: CLOSE_BIG_STRING
+			// Language\\Group.g3:1:172: SL_COMMENT
{
-			mCLOSE_BIG_STRING(); if (state.failed) return ;
+			mSL_COMMENT();

}
break;
case 23:
-			// Language\\Group.g3:1:189: CLOSE_BLOCK_COMMENT
+			// Language\\Group.g3:1:183: ML_COMMENT
{
-			mCLOSE_BLOCK_COMMENT(); if (state.failed) return ;
+			mML_COMMENT();

}
break;
case 24:
-			// Language\\Group.g3:1:209: CLOSE_ANON_TEMPLATE
-			{
-			mCLOSE_ANON_TEMPLATE(); if (state.failed) return ;
-
-			}
-			break;
-		case 25:
-			// Language\\Group.g3:1:229: SL_COMMENT
-			{
-			mSL_COMMENT(); if (state.failed) return ;
-
-			}
-			break;
-		case 26:
-			// Language\\Group.g3:1:240: ML_COMMENT
-			{
-			mML_COMMENT(); if (state.failed) return ;
-
-			}
-			break;
-		case 27:
-			// Language\\Group.g3:1:251: WS
-			{
-			mWS(); if (state.failed) return ;
-
-			}
-			break;
-		case 28:
-			// Language\\Group.g3:1:254: ANYCHAR
+			// Language\\Group.g3:1:194: WS
{
-			mANYCHAR(); if (state.failed) return ;
+			mWS();

}
break;
@@ -1823,650 +1342,51 @@ public partial class GroupLexer : Lexer

}

-	// $ANTLR start synpred1_Group
-	public void synpred1_Group_fragment()
-	{
-		// Language\\Group.g3:323:6: ( '\\r' | '\\n' )
-		// Language\\Group.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred1_Group
-
-	// $ANTLR start synpred2_Group
-	public void synpred2_Group_fragment()
-	{
-		// Language\\Group.g3:324:6: ( '\\r\\n>>' )
-		// Language\\Group.g3:324:7: '\\r\\n>>'
-		{
-		Match("\r\n>>"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred2_Group
-
-	// $ANTLR start synpred3_Group
-	public void synpred3_Group_fragment()
-	{
-		// Language\\Group.g3:325:6: ( '\\n>>' )
-		// Language\\Group.g3:325:7: '\\n>>'
-		{
-		Match("\n>>"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred3_Group
-
-	// $ANTLR start synpred4_Group
-	public void synpred4_Group_fragment()
-	{
-		// Language\\Group.g3:326:6: ( '\\r' | '\\n' )
-		// Language\\Group.g3:
-		{
-		if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred4_Group
-
-	// $ANTLR start synpred5_Group
-	public void synpred5_Group_fragment()
-	{
-		// Language\\Group.g3:327:6: ( '\\\\>' )
-		// Language\\Group.g3:327:7: '\\\\>'
-		{
-		Match("\\>"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred5_Group
-
-	// $ANTLR start synpred6_Group
-	public void synpred6_Group_fragment()
-	{
-		// Language\\Group.g3:328:6: ( '>' ~ '>' |~ '>' )
-		int alt22=2;
-		int LA22_0 = input.LA(1);
-
-		if ( (LA22_0=='>') )
-		{
-			alt22=1;
-		}
-		else if ( ((LA22_0>='\u0000' && LA22_0<='=')||(LA22_0>='?' && LA22_0<='\uFFFF')) )
-		{
-			alt22=2;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
-
-			throw nvae;
-		}
-		switch ( alt22 )
-		{
-		case 1:
-			// Language\\Group.g3:328:7: '>' ~ '>'
-			{
-			Match('>'); if (state.failed) return ;
-			if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-
-			}
-			break;
-		case 2:
-			// Language\\Group.g3:328:18: ~ '>'
-			{
-			if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
-			{
-				input.Consume();
-			state.failed=false;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				MismatchedSetException mse = new MismatchedSetException(null,input);
-				Recover(mse);
-				throw mse;}
-
-
-			}
-			break;
-
-		}}
-	// $ANTLR end synpred6_Group
-
-	// $ANTLR start synpred7_Group
-	public void synpred7_Group_fragment()
-	{
-		// Language\\Group.g3:350:6: ( '\\\\}' )
-		// Language\\Group.g3:350:7: '\\\\}'
-		{
-		Match("\\}"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred7_Group
-
-	// $ANTLR start synpred8_Group
-	public void synpred8_Group_fragment()
-	{
-		// Language\\Group.g3:399:6: ( '*' ~ '/' )
-		// Language\\Group.g3:399:7: '*' ~ '/'
-		{
-		Match('*'); if (state.failed) return ;
-		if ( (input.LA(1)>='\u0000' && input.LA(1)<='.')||(input.LA(1)>='0' && input.LA(1)<='\uFFFF') )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
-
-
-		}
-	}
-	// $ANTLR end synpred8_Group
-
-	public bool synpred1_Group()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred1_Group_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred4_Group()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred4_Group_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred6_Group()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred6_Group_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred3_Group()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred3_Group_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred5_Group()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred5_Group_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred2_Group()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred2_Group_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred7_Group()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred7_Group_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred8_Group()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred8_Group_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-

#region DFA
-	DFA9 dfa9;
-	DFA21 dfa21;
+	DFA12 dfa12;

protected override void InitDFAs()
{
base.InitDFAs();
-		dfa9 = new DFA9( this, new SpecialStateTransitionHandler( specialStateTransition9 ) );
-		dfa21 = new DFA21( this, new SpecialStateTransitionHandler( specialStateTransition21 ) );
+		dfa12 = new DFA12( this );
}

-	class DFA9 : DFA
-	{
-
-		const string DFA9_eotS =
-			"\x1\x2\x1\x8\x3\xFFFF\x1\x8\xB\xFFFF";
-		const string DFA9_eofS =
-			"\x11\xFFFF";
-		const string DFA9_minS =
-			"\x2\x0\x1\xFFFF\x1\xA\x2\x0\x1\xFFFF\x1\x0\x7\xFFFF\x1\x0\x1\xFFFF";
-		const string DFA9_maxS =
-			"\x2\xFFFF\x1\xFFFF\x1\xA\x1\x0\x1\xFFFF\x1\xFFFF\x1\x0\x7\xFFFF\x1\x0"+
-			"\x1\xFFFF";
-		const string DFA9_acceptS =
-			"\x2\xFFFF\x1\x6\x3\xFFFF\x1\x5\x1\xFFFF\x4\x5\x1\x1\x1\x3\x1\x2\x1\xFFFF"+
-			"\x1\x4";
-		const string DFA9_specialS =
-			"\x1\x0\x1\x1\x1\xFFFF\x1\x2\x1\x3\x1\x4\x1\xFFFF\x1\x5\x7\xFFFF\x1\x6"+
-			"\x1\xFFFF}>";
-		static readonly string[] DFA9_transitionS =
-			{
-				"\xA\x6\x1\x4\x2\x6\x1\x3\x30\x6\x1\x1\x1D\x6\x1\x5\xFFA3\x6",
-				"\xA\x6\x1\xA\x2\x6\x1\x9\x30\x6\x1\x7\x1D\x6\x1\xB\xFFA3\x6",
-				"",
-				"\x1\xC",
-				"\x1\xFFFF",
-				"\xA\x6\x1\xA\x2\x6\x1\x9\x30\x6\x1\xF\x1D\x6\x1\xB\xFFA3\x6",
-				"",
-				"\x1\xFFFF",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\xFFFF",
-				""
-			};
-
-		static readonly short[] DFA9_eot = DFA.UnpackEncodedString(DFA9_eotS);
-		static readonly short[] DFA9_eof = DFA.UnpackEncodedString(DFA9_eofS);
-		static readonly char[] DFA9_min = DFA.UnpackEncodedStringToUnsignedChars(DFA9_minS);
-		static readonly char[] DFA9_max = DFA.UnpackEncodedStringToUnsignedChars(DFA9_maxS);
-		static readonly short[] DFA9_accept = DFA.UnpackEncodedString(DFA9_acceptS);
-		static readonly short[] DFA9_special = DFA.UnpackEncodedString(DFA9_specialS);
-		static readonly short[][] DFA9_transition;
-
-		static DFA9()
-		{
-			int numStates = DFA9_transitionS.Length;
-			DFA9_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA9_transition[i] = DFA.UnpackEncodedString(DFA9_transitionS[i]);
-			}
-		}
-
-		public DFA9( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 9;
-			this.eot = DFA9_eot;
-			this.eof = DFA9_eof;
-			this.min = DFA9_min;
-			this.max = DFA9_max;
-			this.accept = DFA9_accept;
-			this.special = DFA9_special;
-			this.transition = DFA9_transition;
-		}
-		public override string GetDescription()
-		{
-			return "()* loopback of 324:4: (=> '\\r' '\\n' |=> '\\n' |=> ( '\\r' )? '\\n' |=> '\\\\>' |=>ch= . )*";
-		}
-	}
-
-	int specialStateTransition9( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-
-			case 0:
-				int LA9_0 = input.LA(1);
-
-
-				int index9_0 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA9_0=='>') ) {s = 1;}
-
-				else if ( (LA9_0=='\r') ) {s = 3;}
-
-				else if ( (LA9_0=='\n') ) {s = 4;}
-
-				else if ( (LA9_0=='\\') ) {s = 5;}
-
-				else if ( ((LA9_0>='\u0000' && LA9_0<='\t')||(LA9_0>='\u000B' && LA9_0<='\f')||(LA9_0>='\u000E' && LA9_0<='=')||(LA9_0>='?' && LA9_0<='[')||(LA9_0>=']' && LA9_0<='\uFFFF')) && (synpred6_Group())) {s = 6;}
-
-				else s = 2;
-
-
-				input.Seek(index9_0);
-				if ( s>=0 ) return s;
-				break;
-
-			case 1:
-				int LA9_1 = input.LA(1);
-
-
-				int index9_1 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA9_1=='>') ) {s = 7;}
-
-				else if ( (LA9_1=='\r') && (synpred6_Group())) {s = 9;}
-
-				else if ( (LA9_1=='\n') && (synpred6_Group())) {s = 10;}
-
-				else if ( (LA9_1=='\\') && (synpred6_Group())) {s = 11;}
-
-				else if ( ((LA9_1>='\u0000' && LA9_1<='\t')||(LA9_1>='\u000B' && LA9_1<='\f')||(LA9_1>='\u000E' && LA9_1<='=')||(LA9_1>='?' && LA9_1<='[')||(LA9_1>=']' && LA9_1<='\uFFFF')) && (synpred6_Group())) {s = 6;}
-
-				else s = 8;
-
-
-				input.Seek(index9_1);
-				if ( s>=0 ) return s;
-				break;
-
-			case 2:
-				int LA9_3 = input.LA(1);
-
-
-				int index9_3 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA9_3=='\n') && (synpred2_Group())) {s = 12;}
-
-				else if ( (synpred4_Group()) ) {s = 13;}
-
-				else if ( (synpred6_Group()) ) {s = 11;}
-
-
-				input.Seek(index9_3);
-				if ( s>=0 ) return s;
-				break;
-
-			case 3:
-				int LA9_4 = input.LA(1);
-
-
-				int index9_4 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (synpred3_Group()) ) {s = 14;}
-
-				else if ( (synpred4_Group()) ) {s = 13;}
-
-				else if ( (synpred6_Group()) ) {s = 11;}
-
-
-				input.Seek(index9_4);
-				if ( s>=0 ) return s;
-				break;
-
-			case 4:
-				int LA9_5 = input.LA(1);
-
-
-				int index9_5 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (LA9_5=='>') ) {s = 15;}
-
-				else if ( (LA9_5=='\r') && (synpred6_Group())) {s = 9;}
-
-				else if ( (LA9_5=='\n') && (synpred6_Group())) {s = 10;}
-
-				else if ( (LA9_5=='\\') && (synpred6_Group())) {s = 11;}
-
-				else if ( ((LA9_5>='\u0000' && LA9_5<='\t')||(LA9_5>='\u000B' && LA9_5<='\f')||(LA9_5>='\u000E' && LA9_5<='=')||(LA9_5>='?' && LA9_5<='[')||(LA9_5>=']' && LA9_5<='\uFFFF')) && (synpred6_Group())) {s = 6;}
-
-				else s = 8;
-
-
-				input.Seek(index9_5);
-				if ( s>=0 ) return s;
-				break;
-
-			case 5:
-				int LA9_7 = input.LA(1);
-
-
-				int index9_7 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (synpred6_Group()) ) {s = 11;}
-
-				else if ( (true) ) {s = 2;}
-
-
-				input.Seek(index9_7);
-				if ( s>=0 ) return s;
-				break;
-
-			case 6:
-				int LA9_15 = input.LA(1);
-
-
-				int index9_15 = input.Index;
-				input.Rewind();
-				s = -1;
-				if ( (synpred5_Group()) ) {s = 16;}
-
-				else if ( (synpred6_Group()) ) {s = 11;}
-
-
-				input.Seek(index9_15);
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 9, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-	class DFA21 : DFA
+	class DFA12 : DFA
{

-		const string DFA21_eotS =
-			"\x1\xFFFF\x3\x1F\x2\xFFFF\x1\x1D\x8\xFFFF\x1\x2D\x1\xFFFF\x1\x30\x3\xFFFF"+
-			"\x1\x1D\x1\xFFFF\x1\x1D\x3\xFFFF\x1\x1D\x2\xFFFF\x1\x1F\x1\xFFFF\x2\x1F"+
-			"\x17\xFFFF\x7\x1F\x1\x43\x2\x1F\x1\xFFFF\x1\x1F\x1\x47\x1\x1F\x1\xFFFF"+
-			"\x2\x1F\x1\x4B\x1\xFFFF";
-		const string DFA21_eofS =
-			"\x4C\xFFFF";
-		const string DFA21_minS =
-			"\x1\x0\x1\x65\x1\x72\x1\x6D\x2\xFFFF\x1\x3C\x8\xFFFF\x1\x3A\x1\xFFFF"+
-			"\x1\x2F\x3\xFFFF\x1\x3E\x1\xFFFF\x1\x2A\x3\xFFFF\x1\xA\x2\xFFFF\x1\x66"+
-			"\x1\xFFFF\x1\x6F\x1\x70\x17\xFFFF\x1\x61\x1\x75\x1\x6C\x1\x75\x1\x70"+
-			"\x1\x65\x1\x6C\x1\x2D\x1\x6D\x1\x74\x1\xFFFF\x1\x65\x1\x2D\x1\x6E\x1"+
-			"\xFFFF\x1\x74\x1\x73\x1\x2D\x1\xFFFF";
-		const string DFA21_maxS =
-			"\x1\xFFFF\x1\x65\x1\x72\x1\x6D\x2\xFFFF\x1\x3C\x8\xFFFF\x1\x3A\x1\xFFFF"+
-			"\x1\x2F\x3\xFFFF\x1\x3E\x1\xFFFF\x1\x2F\x3\xFFFF\x1\xA\x2\xFFFF\x1\x66"+
-			"\x1\xFFFF\x1\x6F\x1\x70\x17\xFFFF\x1\x61\x1\x75\x1\x6C\x1\x75\x1\x70"+
-			"\x1\x65\x1\x6C\x1\x7A\x1\x6D\x1\x74\x1\xFFFF\x1\x65\x1\x7A\x1\x6E\x1"+
-			"\xFFFF\x1\x74\x1\x73\x1\x7A\x1\xFFFF";
-		const string DFA21_acceptS =
-			"\x4\xFFFF\x1\x4\x1\x5\x1\xFFFF\x1\x7\x1\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1"+
-			"\xD\x1\xE\x1\xFFFF\x1\x10\x1\xFFFF\x1\x13\x1\x14\x1\x15\x1\xFFFF\x1\x18"+
-			"\x1\xFFFF\x3\x1B\x1\xFFFF\x1\x1B\x1\x1C\x1\xFFFF\x1\x4\x2\xFFFF\x1\x5"+
-			"\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x11\x1"+
-			"\x10\x1\x17\x1\x12\x1\x13\x1\x14\x1\x15\x1\x16\x1\x18\x1\x19\x1\x1A\x1"+
-			"\x1B\xA\xFFFF\x1\x2\x3\xFFFF\x1\x1\x3\xFFFF\x1\x3";
-		const string DFA21_specialS =
-			"\x1\x0\x4B\xFFFF}>";
-		static readonly string[] DFA21_transitionS =
-			{
-				"\x9\x1D\x1\x19\x1\x1C\x1\x1D\x1\x1A\x1\x1B\x12\x1D\x1\x18\x1\x1D\x1"+
-				"\x5\x5\x1D\x1\x9\x1\xA\x1\x11\x1\x12\x1\xD\x1\x1D\x1\xE\x1\x17\xA\x1D"+
-				"\x1\xF\x1\x10\x1\x6\x1\x13\x1\x15\x1\x14\x1\x8\x1A\x4\x1\xB\x1\x1D\x1"+
-				"\xC\x1\x1D\x1\x4\x1\x1D\x3\x4\x1\x1\x2\x4\x1\x2\x1\x4\x1\x3\x11\x4\x1"+
-				"\x7\x1\x1D\x1\x16\xFF82\x1D",
-				"\x1\x1E",
-				"\x1\x20",
-				"\x1\x21",
-				"",
-				"",
-				"\x1\x23",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\x1\x2C",
-				"",
-				"\x1\x2F",
-				"",
-				"",
-				"",
-				"\x1\x34",
-				"",
-				"\x1\x37\x4\xFFFF\x1\x36",
-				"",
-				"",
-				"",
-				"\x1\x38",
-				"",
-				"",
-				"\x1\x39",
-				"",
-				"\x1\x3A",
-				"\x1\x3B",
-				"",
-				"",
+		const string DFA12_eotS =
+			"\x1\xFFFF\x3\x4\xB\xFFFF\x1\x1B\x7\xFFFF\x3\x4\x4\xFFFF\x7\x4\x1\x28"+
+			"\x2\x4\x1\xFFFF\x1\x4\x1\x2C\x1\x4\x1\xFFFF\x2\x4\x1\x30\x1\xFFFF";
+		const string DFA12_eofS =
+			"\x31\xFFFF";
+		const string DFA12_minS =
+			"\x1\x9\x1\x65\x1\x72\x1\x6D\xB\xFFFF\x1\x3A\x5\xFFFF\x1\x2A\x1\xFFFF"+
+			"\x1\x66\x1\x6F\x1\x70\x4\xFFFF\x1\x61\x1\x75\x1\x6C\x1\x75\x1\x70\x1"+
+			"\x65\x1\x6C\x1\x2D\x1\x6D\x1\x74\x1\xFFFF\x1\x65\x1\x2D\x1\x6E\x1\xFFFF"+
+			"\x1\x74\x1\x73\x1\x2D\x1\xFFFF";
+		const string DFA12_maxS =
+			"\x1\x7B\x1\x65\x1\x72\x1\x6D\xB\xFFFF\x1\x3A\x5\xFFFF\x1\x2F\x1\xFFFF"+
+			"\x1\x66\x1\x6F\x1\x70\x4\xFFFF\x1\x61\x1\x75\x1\x6C\x1\x75\x1\x70\x1"+
+			"\x65\x1\x6C\x1\x7A\x1\x6D\x1\x74\x1\xFFFF\x1\x65\x1\x7A\x1\x6E\x1\xFFFF"+
+			"\x1\x74\x1\x73\x1\x7A\x1\xFFFF";
+		const string DFA12_acceptS =
+			"\x4\xFFFF\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD"+
+			"\x1\xE\x1\xFFFF\x1\x10\x1\x12\x1\x13\x1\x14\x1\x15\x1\xFFFF\x1\x18\x3"+
+			"\xFFFF\x1\xF\x1\x11\x1\x16\x1\x17\xA\xFFFF\x1\x2\x3\xFFFF\x1\x1\x3\xFFFF"+
+			"\x1\x3";
+		const string DFA12_specialS =
+			"\x31\xFFFF}>";
+		static readonly string[] DFA12_transitionS =
+			{
+				"\x2\x16\x1\xFFFF\x2\x16\x12\xFFFF\x1\x16\x1\xFFFF\x1\x5\x5\xFFFF\x1"+
+				"\x9\x1\xA\x1\x11\x1\x12\x1\xD\x1\xFFFF\x1\xE\x1\x15\xA\xFFFF\x1\xF\x1"+
+				"\x10\x1\x6\x1\x13\x1\xFFFF\x1\x14\x1\x8\x1A\x4\x1\xB\x1\xFFFF\x1\xC"+
+				"\x1\xFFFF\x1\x4\x1\xFFFF\x3\x4\x1\x1\x2\x4\x1\x2\x1\x4\x1\x3\x11\x4"+
+				"\x1\x7",
+				"\x1\x17",
+				"\x1\x18",
+				"\x1\x19",
"",
"",
"",
@@ -2478,153 +1398,78 @@ public partial class GroupLexer : Lexer
"",
"",
"",
+				"\x1\x1A",
"",
"",
"",
"",
"",
+				"\x1\x1D\x4\xFFFF\x1\x1C",
"",
+				"\x1\x1E",
+				"\x1\x1F",
+				"\x1\x20",
"",
"",
"",
"",
-				"\x1\x3C",
-				"\x1\x3D",
-				"\x1\x3E",
-				"\x1\x3F",
-				"\x1\x40",
-				"\x1\x41",
-				"\x1\x42",
-				"\x1\x1F\x2\xFFFF\xA\x1F\x7\xFFFF\x1A\x1F\x4\xFFFF\x1\x1F\x1\xFFFF\x1A"+
-				"\x1F",
-				"\x1\x44",
-				"\x1\x45",
+				"\x1\x21",
+				"\x1\x22",
+				"\x1\x23",
+				"\x1\x24",
+				"\x1\x25",
+				"\x1\x26",
+				"\x1\x27",
+				"\x1\x4\x2\xFFFF\xA\x4\x7\xFFFF\x1A\x4\x4\xFFFF\x1\x4\x1\xFFFF\x1A\x4",
+				"\x1\x29",
+				"\x1\x2A",
"",
-				"\x1\x46",
-				"\x1\x1F\x2\xFFFF\xA\x1F\x7\xFFFF\x1A\x1F\x4\xFFFF\x1\x1F\x1\xFFFF\x1A"+
-				"\x1F",
-				"\x1\x48",
+				"\x1\x2B",
+				"\x1\x4\x2\xFFFF\xA\x4\x7\xFFFF\x1A\x4\x4\xFFFF\x1\x4\x1\xFFFF\x1A\x4",
+				"\x1\x2D",
"",
-				"\x1\x49",
-				"\x1\x4A",
-				"\x1\x1F\x2\xFFFF\xA\x1F\x7\xFFFF\x1A\x1F\x4\xFFFF\x1\x1F\x1\xFFFF\x1A"+
-				"\x1F",
+				"\x1\x2E",
+				"\x1\x2F",
+				"\x1\x4\x2\xFFFF\xA\x4\x7\xFFFF\x1A\x4\x4\xFFFF\x1\x4\x1\xFFFF\x1A\x4",
""
};

-		static readonly short[] DFA21_eot = DFA.UnpackEncodedString(DFA21_eotS);
-		static readonly short[] DFA21_eof = DFA.UnpackEncodedString(DFA21_eofS);
-		static readonly char[] DFA21_min = DFA.UnpackEncodedStringToUnsignedChars(DFA21_minS);
-		static readonly char[] DFA21_max = DFA.UnpackEncodedStringToUnsignedChars(DFA21_maxS);
-		static readonly short[] DFA21_accept = DFA.UnpackEncodedString(DFA21_acceptS);
-		static readonly short[] DFA21_special = DFA.UnpackEncodedString(DFA21_specialS);
-		static readonly short[][] DFA21_transition;
+		static readonly short[] DFA12_eot = DFA.UnpackEncodedString(DFA12_eotS);
+		static readonly short[] DFA12_eof = DFA.UnpackEncodedString(DFA12_eofS);
+		static readonly char[] DFA12_min = DFA.UnpackEncodedStringToUnsignedChars(DFA12_minS);
+		static readonly char[] DFA12_max = DFA.UnpackEncodedStringToUnsignedChars(DFA12_maxS);
+		static readonly short[] DFA12_accept = DFA.UnpackEncodedString(DFA12_acceptS);
+		static readonly short[] DFA12_special = DFA.UnpackEncodedString(DFA12_specialS);
+		static readonly short[][] DFA12_transition;

-		static DFA21()
+		static DFA12()
{
-			int numStates = DFA21_transitionS.Length;
-			DFA21_transition = new short[numStates][];
+			int numStates = DFA12_transitionS.Length;
+			DFA12_transition = new short[numStates][];
for ( int i=0; i < numStates; i++ )
{
-				DFA21_transition[i] = DFA.UnpackEncodedString(DFA21_transitionS[i]);
+				DFA12_transition[i] = DFA.UnpackEncodedString(DFA12_transitionS[i]);
}
}

-		public DFA21( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
+		public DFA12( BaseRecognizer recognizer )
+		{
this.recognizer = recognizer;
-			this.decisionNumber = 21;
-			this.eot = DFA21_eot;
-			this.eof = DFA21_eof;
-			this.min = DFA21_min;
-			this.max = DFA21_max;
-			this.accept = DFA21_accept;
-			this.special = DFA21_special;
-			this.transition = DFA21_transition;
+			this.decisionNumber = 12;
+			this.eot = DFA12_eot;
+			this.eof = DFA12_eof;
+			this.min = DFA12_min;
+			this.max = DFA12_max;
+			this.accept = DFA12_accept;
+			this.special = DFA12_special;
+			this.transition = DFA12_transition;
}
public override string GetDescription()
{
-			return "1:0: Tokens : ( KWDEFAULT | KWGROUP | KWIMPLEMENTS | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | AT | LPAREN | RPAREN | LBRACK | RBRACK | COMMA | DOT | DEFINED_TO_BE | SEMI | COLON | STAR | PLUS | ASSIGN | OPTIONAL | CLOSE_BIG_STRING | CLOSE_BLOCK_COMMENT | CLOSE_ANON_TEMPLATE | SL_COMMENT | ML_COMMENT | WS | ANYCHAR );";
+			return "1:0: Tokens : ( KWDEFAULT | KWGROUP | KWIMPLEMENTS | ID | STRING | BIGSTRING | ANONYMOUS_TEMPLATE | AT | LPAREN | RPAREN | LBRACK | RBRACK | COMMA | DOT | DEFINED_TO_BE | SEMI | COLON | STAR | PLUS | ASSIGN | OPTIONAL | SL_COMMENT | ML_COMMENT | WS );";
}
}

-	int specialStateTransition21( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-
-			case 0:
-				int LA21_0 = input.LA(1);
-
-				s = -1;
-				if ( (LA21_0=='d') ) {s = 1;}
-
-				else if ( (LA21_0=='g') ) {s = 2;}
-
-				else if ( (LA21_0=='i') ) {s = 3;}
-
-				else if ( ((LA21_0>='A' && LA21_0<='Z')||LA21_0=='_'||(LA21_0>='a' && LA21_0<='c')||(LA21_0>='e' && LA21_0<='f')||LA21_0=='h'||(LA21_0>='j' && LA21_0<='z')) ) {s = 4;}
-
-				else if ( (LA21_0=='\"') ) {s = 5;}
-
-				else if ( (LA21_0=='<') ) {s = 6;}
-
-				else if ( (LA21_0=='{') ) {s = 7;}
-
-				else if ( (LA21_0=='@') ) {s = 8;}
-
-				else if ( (LA21_0=='(') ) {s = 9;}
-
-				else if ( (LA21_0==')') ) {s = 10;}
-
-				else if ( (LA21_0=='[') ) {s = 11;}
-
-				else if ( (LA21_0==']') ) {s = 12;}
-
-				else if ( (LA21_0==',') ) {s = 13;}
-
-				else if ( (LA21_0=='.') ) {s = 14;}
-
-				else if ( (LA21_0==':') ) {s = 15;}
-
-				else if ( (LA21_0==';') ) {s = 16;}
-
-				else if ( (LA21_0=='*') ) {s = 17;}
-
-				else if ( (LA21_0=='+') ) {s = 18;}
-
-				else if ( (LA21_0=='=') ) {s = 19;}
-
-				else if ( (LA21_0=='?') ) {s = 20;}
-
-				else if ( (LA21_0=='>') ) {s = 21;}
-
-				else if ( (LA21_0=='}') ) {s = 22;}
-
-				else if ( (LA21_0=='/') ) {s = 23;}
-
-				else if ( (LA21_0==' ') ) {s = 24;}
-
-				else if ( (LA21_0=='\t') ) {s = 25;}
-
-				else if ( (LA21_0=='\f') ) {s = 26;}
-
-				else if ( (LA21_0=='\r') ) {s = 27;}
-
-				else if ( (LA21_0=='\n') ) {s = 28;}
-
-				else if ( ((LA21_0>='\u0000' && LA21_0<='\b')||LA21_0=='\u000B'||(LA21_0>='\u000E' && LA21_0<='\u001F')||LA21_0=='!'||(LA21_0>='#' && LA21_0<='\'')||LA21_0=='-'||(LA21_0>='0' && LA21_0<='9')||LA21_0=='\\'||LA21_0=='^'||LA21_0=='`'||LA21_0=='|'||(LA21_0>='~' && LA21_0<='\uFFFF')) ) {s = 29;}
-
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 21, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}

#endregion

diff --git a/Antlr3.StringTemplate/Language/GroupLexerHelper.cs b/Antlr3.StringTemplate/Language/GroupLexerHelper.cs
index 215fe1f..89dafd7 100644
--- a/Antlr3.StringTemplate/Language/GroupLexerHelper.cs
+++ b/Antlr3.StringTemplate/Language/GroupLexerHelper.cs
@@ -32,121 +32,67 @@

namespace Antlr3.ST.Language
{
-    using System;
-    using Antlr.Runtime;
-
-    using IToken = Antlr.Runtime.IToken;
+    using StringBuilder = System.Text.StringBuilder;

partial class GroupLexer
{
-        [Flags]
-        public enum StateFlags
+        string ProcessAnonymousTemplate( StringBuilder builder )
{
-            LineScanning = 1 << 0,
-            InBlockComment = 1 << 1,
-            InDocComment = 1 << 2,
-            InTextBlock = 1 << 3,
-            InAction = 15 << 4,
-            InActionComment = 1 << 8,
-            InBigString = 1 << 9,
-            InAnonymousTemplate = 1 << 10
+            // handle escaped }
+            builder.Replace( @"\}", "}" );
+            return builder.ToString();
}

-        bool GetFlag( int bitfield, StateFlags flag )
-        {
-            return ( bitfield & (int)flag ) == (int)flag;
-        }
-        int SetFlag( int bitfield, StateFlags flag, bool value )
+        string ProcessBigString( StringBuilder builder )
{
-            bitfield &= ~(int)flag;
-            if ( value )
-                bitfield |= (int)flag;
-            return bitfield;
-        }
+            // handle escaped >
+            builder.Replace( @"\>", ">" );

-        int ScannerState
-        {
-            get;
-            set;
-        }
-        public bool InColorizer
-        {
-            get;
-            set;
-        }
-        public bool InBlockComment
-        {
-            get
+            // kill first newline
+            int trimStart = 0;
+            if ( builder.Length > 0 )
{
-                return GetFlag( ScannerState, StateFlags.InBlockComment );
-            }
-            set
-            {
-                //if ( !value )
-                //    InDocComment = value;
+                switch ( builder[0] )
+                {
+                case '\r':
+                    if ( builder.Length > 1 && builder[1] == '\n' )
+                        trimStart = 2;
+                    else
+                        trimStart = 1;
+                    break;

-                //if ( LineScanning && Line > _startLine )
-                //    return;
+                case '\n':
+                    trimStart = 1;
+                    break;

-                ScannerState = SetFlag( ScannerState, StateFlags.InBlockComment, value );
-            }
-        }
-        public bool InBigString
-        {
-            get
-            {
-                return GetFlag( ScannerState, StateFlags.InBigString );
-            }
-            set
-            {
-                ScannerState = SetFlag( ScannerState, StateFlags.InBigString, value );
+                default:
+                    break;
+                }
}
-        }
-        public bool InAnonymousTemplate
-        {
-            get
-            {
-                return GetFlag( ScannerState, StateFlags.InAnonymousTemplate );
-            }
-            set
-            {
-                ScannerState = SetFlag( ScannerState, StateFlags.InAnonymousTemplate, value );
-            }
-        }
-
-        public override IToken NextToken()
-        {
-            if ( !InColorizer )
-                return base.NextToken();
-
-            CommonToken token = (CommonToken)base.NextToken();
-
-            if ( InBlockComment && token.Type != EOF )
-            {
-                if ( token.Type == CLOSE_BLOCK_COMMENT )
-                    InBlockComment = false;

-                token.Type = ML_COMMENT;
-            }
-            else if ( InBigString && token.Type != EOF )
+            // kill last newline
+            int trimEnd = 0;
+            if ( builder.Length > trimStart )
{
-                if ( token.Type == CLOSE_BIG_STRING )
-                    InBigString = false;
+                switch ( builder[builder.Length - 1] )
+                {
+                case '\r':
+                    trimEnd = 1;
+                    break;

-                token.Type = BIGSTRING;
-            }
-            else if ( InAnonymousTemplate && token.Type != EOF )
-            {
-                if ( token.Type == CLOSE_ANON_TEMPLATE )
-                    InAnonymousTemplate = false;
+                case '\n':
+                    if ( builder[builder.Length - 2] == '\r' )
+                        trimEnd = 2;
+                    else
+                        trimEnd = 1;
+                    break;

-                token.Type = ANONYMOUS_TEMPLATE;
+                default:
+                    break;
+                }
}

-            if ( token.Type != EOF && token.StartIndex > token.StopIndex )
-                throw new OperationCanceledException();
-
-            return token;
+            return builder.ToString( trimStart, builder.Length - trimStart - trimEnd );
}
}
}
diff --git a/Antlr3.StringTemplate/Language/GroupParser.cs b/Antlr3.StringTemplate/Language/GroupParser.cs
index 78a57b7..3b9ed60 100644
--- a/Antlr3.StringTemplate/Language/GroupParser.cs
+++ b/Antlr3.StringTemplate/Language/GroupParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Group.g3 2009-03-16 17:25:52
+// $ANTLR 3.1.2 Language\\Group.g3 2009-03-16 20:26:39

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -53,37 +53,33 @@ namespace Antlr3.ST.Language
public partial class GroupParser : Parser
{
public static readonly string[] tokenNames = new string[] {
-		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "ANYCHAR", "ASSIGN", "AT", "BIGSTRING", "CLOSE_ANON_TEMPLATE", "CLOSE_BIG_STRING", "CLOSE_BLOCK_COMMENT", "COLON", "COMMA", "DEFINED_TO_BE", "DOT", "ID", "KWDEFAULT", "KWGROUP", "KWIMPLEMENTS", "LBRACK", "LPAREN", "ML_COMMENT", "OPTIONAL", "PLUS", "RBRACK", "RPAREN", "SEMI", "SL_COMMENT", "STAR", "STRING", "WS"
+		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ANONYMOUS_TEMPLATE", "ASSIGN", "AT", "BIGSTRING", "COLON", "COMMA", "DEFINED_TO_BE", "DOT", "ID", "KWDEFAULT", "KWGROUP", "KWIMPLEMENTS", "LBRACK", "LPAREN", "ML_COMMENT", "OPTIONAL", "PLUS", "RBRACK", "RPAREN", "SEMI", "SL_COMMENT", "STAR", "STRING", "WS"
};
public const int EOF=-1;
public const int ANONYMOUS_TEMPLATE=4;
-	public const int ANYCHAR=5;
-	public const int ASSIGN=6;
-	public const int AT=7;
-	public const int BIGSTRING=8;
-	public const int CLOSE_ANON_TEMPLATE=9;
-	public const int CLOSE_BIG_STRING=10;
-	public const int CLOSE_BLOCK_COMMENT=11;
-	public const int COLON=12;
-	public const int COMMA=13;
-	public const int DEFINED_TO_BE=14;
-	public const int DOT=15;
-	public const int ID=16;
-	public const int KWDEFAULT=17;
-	public const int KWGROUP=18;
-	public const int KWIMPLEMENTS=19;
-	public const int LBRACK=20;
-	public const int LPAREN=21;
-	public const int ML_COMMENT=22;
-	public const int OPTIONAL=23;
-	public const int PLUS=24;
-	public const int RBRACK=25;
-	public const int RPAREN=26;
-	public const int SEMI=27;
-	public const int SL_COMMENT=28;
-	public const int STAR=29;
-	public const int STRING=30;
-	public const int WS=31;
+	public const int ASSIGN=5;
+	public const int AT=6;
+	public const int BIGSTRING=7;
+	public const int COLON=8;
+	public const int COMMA=9;
+	public const int DEFINED_TO_BE=10;
+	public const int DOT=11;
+	public const int ID=12;
+	public const int KWDEFAULT=13;
+	public const int KWGROUP=14;
+	public const int KWIMPLEMENTS=15;
+	public const int LBRACK=16;
+	public const int LPAREN=17;
+	public const int ML_COMMENT=18;
+	public const int OPTIONAL=19;
+	public const int PLUS=20;
+	public const int RBRACK=21;
+	public const int RPAREN=22;
+	public const int SEMI=23;
+	public const int SL_COMMENT=24;
+	public const int STAR=25;
+	public const int STRING=26;
+	public const int WS=27;

// delegates
// delegators
@@ -1116,57 +1112,57 @@ public partial class GroupParser : Parser
#region Follow Sets
public static class Follow
{
-		public static readonly BitSet _KWGROUP_in_group93 = new BitSet(new ulong[]{0x10000UL});
-		public static readonly BitSet _ID_in_group97 = new BitSet(new ulong[]{0x8081000UL});
-		public static readonly BitSet _COLON_in_group105 = new BitSet(new ulong[]{0x10000UL});
-		public static readonly BitSet _ID_in_group109 = new BitSet(new ulong[]{0x8080000UL});
-		public static readonly BitSet _KWIMPLEMENTS_in_group120 = new BitSet(new ulong[]{0x10000UL});
-		public static readonly BitSet _ID_in_group124 = new BitSet(new ulong[]{0x8002000UL});
-		public static readonly BitSet _COMMA_in_group132 = new BitSet(new ulong[]{0x10000UL});
-		public static readonly BitSet _ID_in_group136 = new BitSet(new ulong[]{0x8002000UL});
-		public static readonly BitSet _SEMI_in_group150 = new BitSet(new ulong[]{0x10080UL});
-		public static readonly BitSet _template_in_group156 = new BitSet(new ulong[]{0x10080UL});
-		public static readonly BitSet _mapdef_in_group161 = new BitSet(new ulong[]{0x10080UL});
+		public static readonly BitSet _KWGROUP_in_group93 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ID_in_group97 = new BitSet(new ulong[]{0x808100UL});
+		public static readonly BitSet _COLON_in_group105 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ID_in_group109 = new BitSet(new ulong[]{0x808000UL});
+		public static readonly BitSet _KWIMPLEMENTS_in_group120 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ID_in_group124 = new BitSet(new ulong[]{0x800200UL});
+		public static readonly BitSet _COMMA_in_group132 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ID_in_group136 = new BitSet(new ulong[]{0x800200UL});
+		public static readonly BitSet _SEMI_in_group150 = new BitSet(new ulong[]{0x1040UL});
+		public static readonly BitSet _template_in_group156 = new BitSet(new ulong[]{0x1040UL});
+		public static readonly BitSet _mapdef_in_group161 = new BitSet(new ulong[]{0x1040UL});
public static readonly BitSet _EOF_in_group169 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _AT_in_template188 = new BitSet(new ulong[]{0x10000UL});
-		public static readonly BitSet _ID_in_template192 = new BitSet(new ulong[]{0x8000UL});
-		public static readonly BitSet _DOT_in_template194 = new BitSet(new ulong[]{0x10000UL});
-		public static readonly BitSet _ID_in_template198 = new BitSet(new ulong[]{0x200000UL});
-		public static readonly BitSet _ID_in_template211 = new BitSet(new ulong[]{0x200000UL});
-		public static readonly BitSet _LPAREN_in_template230 = new BitSet(new ulong[]{0x4010000UL});
-		public static readonly BitSet _args_in_template236 = new BitSet(new ulong[]{0x4000000UL});
-		public static readonly BitSet _RPAREN_in_template244 = new BitSet(new ulong[]{0x4000UL});
-		public static readonly BitSet _DEFINED_TO_BE_in_template248 = new BitSet(new ulong[]{0x40000100UL});
+		public static readonly BitSet _AT_in_template188 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ID_in_template192 = new BitSet(new ulong[]{0x800UL});
+		public static readonly BitSet _DOT_in_template194 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _ID_in_template198 = new BitSet(new ulong[]{0x20000UL});
+		public static readonly BitSet _ID_in_template211 = new BitSet(new ulong[]{0x20000UL});
+		public static readonly BitSet _LPAREN_in_template230 = new BitSet(new ulong[]{0x401000UL});
+		public static readonly BitSet _args_in_template236 = new BitSet(new ulong[]{0x400000UL});
+		public static readonly BitSet _RPAREN_in_template244 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _DEFINED_TO_BE_in_template248 = new BitSet(new ulong[]{0x4000080UL});
public static readonly BitSet _STRING_in_template256 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _BIGSTRING_in_template270 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_template286 = new BitSet(new ulong[]{0x4000UL});
-		public static readonly BitSet _DEFINED_TO_BE_in_template288 = new BitSet(new ulong[]{0x10000UL});
+		public static readonly BitSet _ID_in_template286 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _DEFINED_TO_BE_in_template288 = new BitSet(new ulong[]{0x1000UL});
public static readonly BitSet _ID_in_template292 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _arg_in_args308 = new BitSet(new ulong[]{0x2002UL});
-		public static readonly BitSet _COMMA_in_args313 = new BitSet(new ulong[]{0x10000UL});
-		public static readonly BitSet _arg_in_args315 = new BitSet(new ulong[]{0x2002UL});
-		public static readonly BitSet _ID_in_arg338 = new BitSet(new ulong[]{0x42UL});
-		public static readonly BitSet _ASSIGN_in_arg344 = new BitSet(new ulong[]{0x40000000UL});
+		public static readonly BitSet _arg_in_args308 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _COMMA_in_args313 = new BitSet(new ulong[]{0x1000UL});
+		public static readonly BitSet _arg_in_args315 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _ID_in_arg338 = new BitSet(new ulong[]{0x22UL});
+		public static readonly BitSet _ASSIGN_in_arg344 = new BitSet(new ulong[]{0x4000000UL});
public static readonly BitSet _STRING_in_arg348 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _ASSIGN_in_arg359 = new BitSet(new ulong[]{0x10UL});
public static readonly BitSet _ANONYMOUS_TEMPLATE_in_arg363 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _ID_in_mapdef391 = new BitSet(new ulong[]{0x4000UL});
-		public static readonly BitSet _DEFINED_TO_BE_in_mapdef395 = new BitSet(new ulong[]{0x100000UL});
+		public static readonly BitSet _ID_in_mapdef391 = new BitSet(new ulong[]{0x400UL});
+		public static readonly BitSet _DEFINED_TO_BE_in_mapdef395 = new BitSet(new ulong[]{0x10000UL});
public static readonly BitSet _map_in_mapdef399 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _LBRACK_in_map420 = new BitSet(new ulong[]{0x40020000UL});
-		public static readonly BitSet _mapPairs_in_map422 = new BitSet(new ulong[]{0x2000000UL});
+		public static readonly BitSet _LBRACK_in_map420 = new BitSet(new ulong[]{0x4002000UL});
+		public static readonly BitSet _mapPairs_in_map422 = new BitSet(new ulong[]{0x200000UL});
public static readonly BitSet _RBRACK_in_map425 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _keyValuePair_in_mapPairs438 = new BitSet(new ulong[]{0x2002UL});
-		public static readonly BitSet _COMMA_in_mapPairs442 = new BitSet(new ulong[]{0x40000000UL});
-		public static readonly BitSet _keyValuePair_in_mapPairs444 = new BitSet(new ulong[]{0x2002UL});
-		public static readonly BitSet _COMMA_in_mapPairs452 = new BitSet(new ulong[]{0x40020000UL});
+		public static readonly BitSet _keyValuePair_in_mapPairs438 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _COMMA_in_mapPairs442 = new BitSet(new ulong[]{0x4000000UL});
+		public static readonly BitSet _keyValuePair_in_mapPairs444 = new BitSet(new ulong[]{0x202UL});
+		public static readonly BitSet _COMMA_in_mapPairs452 = new BitSet(new ulong[]{0x4002000UL});
public static readonly BitSet _defaultValuePair_in_mapPairs454 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _defaultValuePair_in_mapPairs462 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _KWDEFAULT_in_defaultValuePair476 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _COLON_in_defaultValuePair478 = new BitSet(new ulong[]{0x40010100UL});
+		public static readonly BitSet _KWDEFAULT_in_defaultValuePair476 = new BitSet(new ulong[]{0x100UL});
+		public static readonly BitSet _COLON_in_defaultValuePair478 = new BitSet(new ulong[]{0x4001080UL});
public static readonly BitSet _keyValue_in_defaultValuePair482 = new BitSet(new ulong[]{0x2UL});
-		public static readonly BitSet _STRING_in_keyValuePair500 = new BitSet(new ulong[]{0x1000UL});
-		public static readonly BitSet _COLON_in_keyValuePair502 = new BitSet(new ulong[]{0x40010100UL});
+		public static readonly BitSet _STRING_in_keyValuePair500 = new BitSet(new ulong[]{0x100UL});
+		public static readonly BitSet _COLON_in_keyValuePair502 = new BitSet(new ulong[]{0x4001080UL});
public static readonly BitSet _keyValue_in_keyValuePair506 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _BIGSTRING_in_keyValue525 = new BitSet(new ulong[]{0x2UL});
public static readonly BitSet _STRING_in_keyValue534 = new BitSet(new ulong[]{0x2UL});
diff --git a/Antlr3.StringTemplate/Language/Template.g3 b/Antlr3.StringTemplate/Language/Template.g3
index a9b2091..8d4882e 100644
--- a/Antlr3.StringTemplate/Language/Template.g3
+++ b/Antlr3.StringTemplate/Language/Template.g3
@@ -119,7 +119,8 @@ template[StringTemplate self]
:	(	s=LITERAL  {self.AddChunk(new StringRef(self,$s.text));}
|	nl=NEWLINE
{
-				if ( input.LA(1)!=ELSE && input.LA(1)!=ENDIF )
+				int next = input.LA(1);
+				if ( next!=ELSE && next!=ENDIF )
{
self.AddChunk(new NewlineRef(self,$nl.text));
}
diff --git a/Antlr3.StringTemplate/Language/TemplateLexer.cs b/Antlr3.StringTemplate/Language/TemplateLexer.cs
index 2b23471..f077fdf 100644
--- a/Antlr3.StringTemplate/Language/TemplateLexer.cs
+++ b/Antlr3.StringTemplate/Language/TemplateLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-03-16 17:21:57
+// $ANTLR 3.1.2 Language\\Template.g3 2009-03-16 21:10:52

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -91,8 +91,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:257:15: ()
-			// Language\\Template.g3:257:15:
+			// Language\\Template.g3:258:15: ()
+			// Language\\Template.g3:258:15:
{


@@ -110,8 +110,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:258:19: ()
-			// Language\\Template.g3:258:19:
+			// Language\\Template.g3:259:19: ()
+			// Language\\Template.g3:259:19:
{


@@ -129,8 +129,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:259:17: ()
-			// Language\\Template.g3:259:17:
+			// Language\\Template.g3:260:17: ()
+			// Language\\Template.g3:260:17:
{


@@ -148,8 +148,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:260:18: ()
-			// Language\\Template.g3:260:18:
+			// Language\\Template.g3:261:18: ()
+			// Language\\Template.g3:261:18:
{


@@ -167,8 +167,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:261:23: ()
-			// Language\\Template.g3:261:23:
+			// Language\\Template.g3:262:23: ()
+			// Language\\Template.g3:262:23:
{


@@ -186,8 +186,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:262:23: ()
-			// Language\\Template.g3:262:23:
+			// Language\\Template.g3:263:23: ()
+			// Language\\Template.g3:263:23:
{


@@ -207,10 +207,10 @@ public partial class TemplateLexer : Lexer
{
int _type = NEWLINE;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Language\\Template.g3:265:4: ( ( '\\r' )? '\\n' )
-			// Language\\Template.g3:265:4: ( '\\r' )? '\\n'
+			// Language\\Template.g3:266:4: ( ( '\\r' )? '\\n' )
+			// Language\\Template.g3:266:4: ( '\\r' )? '\\n'
{
-			// Language\\Template.g3:265:4: ( '\\r' )?
+			// Language\\Template.g3:266:4: ( '\\r' )?
int alt1=2;
int LA1_0 = input.LA(1);

@@ -221,7 +221,7 @@ public partial class TemplateLexer : Lexer
switch ( alt1 )
{
case 1:
-				// Language\\Template.g3:265:5: '\\r'
+				// Language\\Template.g3:266:5: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -266,10 +266,10 @@ public partial class TemplateLexer : Lexer
bool atLeft = false;
string t = null;

-			// Language\\Template.g3:279:4: ( ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) ) )
-			// Language\\Template.g3:279:4: ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
+			// Language\\Template.g3:280:4: ( ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) ) )
+			// Language\\Template.g3:280:4: ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
{
-			// Language\\Template.g3:279:4: ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
+			// Language\\Template.g3:280:4: ( options {k=1; } :=> '$' ( ESC_CHAR[out uc] )+ '$' |=> COMMENT | (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' ) )
int alt26=3;
int LA26_0 = input.LA(1);

@@ -307,11 +307,11 @@ public partial class TemplateLexer : Lexer
switch ( alt26 )
{
case 1:
-				// Language\\Template.g3:280:4: => '$' ( ESC_CHAR[out uc] )+ '$'
+				// Language\\Template.g3:281:4: => '$' ( ESC_CHAR[out uc] )+ '$'
{

Match('$'); if (state.failed) return ;
-				// Language\\Template.g3:282:8: ( ESC_CHAR[out uc] )+
+				// Language\\Template.g3:283:8: ( ESC_CHAR[out uc] )+
int cnt2=0;
for ( ; ; )
{
@@ -327,7 +327,7 @@ public partial class TemplateLexer : Lexer
switch ( alt2 )
{
case 1:
-						// Language\\Template.g3:282:9: ESC_CHAR[out uc]
+						// Language\\Template.g3:283:9: ESC_CHAR[out uc]
{
mESC_CHAR(out uc); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -364,7 +364,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-				// Language\\Template.g3:287:5: => COMMENT
+				// Language\\Template.g3:288:5: => COMMENT
{

mCOMMENT(); if (state.failed) return ;
@@ -376,9 +376,9 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-				// Language\\Template.g3:289:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
+				// Language\\Template.g3:290:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
{
-				// Language\\Template.g3:289:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
+				// Language\\Template.g3:290:5: (=> '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )? |=> '$else$' ( ( '\\r' )? '\\n' )? |=> '$endif$' ({...}? => ( '\\r' )? '\\n' )? |=> '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? ) | '$' EXPR[out subtext] '$' )
int alt25=6;
int LA25_0 = input.LA(1);

@@ -428,12 +428,12 @@ public partial class TemplateLexer : Lexer
switch ( alt25 )
{
case 1:
-					// Language\\Template.g3:289:7: => '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:290:7: => '$if' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
{

Match("$if"); if (state.failed) return ;

-					// Language\\Template.g3:290:11: ( ' ' )*
+					// Language\\Template.g3:291:11: ( ' ' )*
for ( ; ; )
{
int alt3=2;
@@ -448,7 +448,7 @@ public partial class TemplateLexer : Lexer
switch ( alt3 )
{
case 1:
-							// Language\\Template.g3:290:12: ' '
+							// Language\\Template.g3:291:12: ' '
{
Match(' '); if (state.failed) return ;

@@ -477,7 +477,7 @@ public partial class TemplateLexer : Lexer
_type = TemplateParser.IF;

}
-					// Language\\Template.g3:295:5: ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:296:5: ( ( '\\r' )? '\\n' )?
int alt5=2;
int LA5_0 = input.LA(1);

@@ -488,9 +488,9 @@ public partial class TemplateLexer : Lexer
switch ( alt5 )
{
case 1:
-						// Language\\Template.g3:295:7: ( '\\r' )? '\\n'
+						// Language\\Template.g3:296:7: ( '\\r' )? '\\n'
{
-						// Language\\Template.g3:295:7: ( '\\r' )?
+						// Language\\Template.g3:296:7: ( '\\r' )?
int alt4=2;
int LA4_0 = input.LA(1);

@@ -501,7 +501,7 @@ public partial class TemplateLexer : Lexer
switch ( alt4 )
{
case 1:
-							// Language\\Template.g3:295:8: '\\r'
+							// Language\\Template.g3:296:8: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -521,12 +521,12 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-					// Language\\Template.g3:296:6: => '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:297:6: => '$elseif' ( ' ' )* '(' exp= IF_EXPR ')$' ( ( '\\r' )? '\\n' )?
{

Match("$elseif"); if (state.failed) return ;

-					// Language\\Template.g3:297:15: ( ' ' )*
+					// Language\\Template.g3:298:15: ( ' ' )*
for ( ; ; )
{
int alt6=2;
@@ -541,7 +541,7 @@ public partial class TemplateLexer : Lexer
switch ( alt6 )
{
case 1:
-							// Language\\Template.g3:297:16: ' '
+							// Language\\Template.g3:298:16: ' '
{
Match(' '); if (state.failed) return ;

@@ -570,7 +570,7 @@ public partial class TemplateLexer : Lexer
_type = TemplateParser.ELSEIF;

}
-					// Language\\Template.g3:302:5: ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:303:5: ( ( '\\r' )? '\\n' )?
int alt8=2;
int LA8_0 = input.LA(1);

@@ -581,9 +581,9 @@ public partial class TemplateLexer : Lexer
switch ( alt8 )
{
case 1:
-						// Language\\Template.g3:302:7: ( '\\r' )? '\\n'
+						// Language\\Template.g3:303:7: ( '\\r' )? '\\n'
{
-						// Language\\Template.g3:302:7: ( '\\r' )?
+						// Language\\Template.g3:303:7: ( '\\r' )?
int alt7=2;
int LA7_0 = input.LA(1);

@@ -594,7 +594,7 @@ public partial class TemplateLexer : Lexer
switch ( alt7 )
{
case 1:
-							// Language\\Template.g3:302:8: '\\r'
+							// Language\\Template.g3:303:8: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -614,7 +614,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-					// Language\\Template.g3:303:6: => '$else$' ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:304:6: => '$else$' ( ( '\\r' )? '\\n' )?
{

Match("$else$"); if (state.failed) return ;
@@ -626,7 +626,7 @@ public partial class TemplateLexer : Lexer
_type = (TemplateParser.ELSE);

}
-					// Language\\Template.g3:309:5: ( ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:310:5: ( ( '\\r' )? '\\n' )?
int alt10=2;
int LA10_0 = input.LA(1);

@@ -637,9 +637,9 @@ public partial class TemplateLexer : Lexer
switch ( alt10 )
{
case 1:
-						// Language\\Template.g3:309:7: ( '\\r' )? '\\n'
+						// Language\\Template.g3:310:7: ( '\\r' )? '\\n'
{
-						// Language\\Template.g3:309:7: ( '\\r' )?
+						// Language\\Template.g3:310:7: ( '\\r' )?
int alt9=2;
int LA9_0 = input.LA(1);

@@ -650,7 +650,7 @@ public partial class TemplateLexer : Lexer
switch ( alt9 )
{
case 1:
-							// Language\\Template.g3:309:8: '\\r'
+							// Language\\Template.g3:310:8: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -670,7 +670,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 4:
-					// Language\\Template.g3:310:6: => '$endif$' ({...}? => ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:311:6: => '$endif$' ({...}? => ( '\\r' )? '\\n' )?
{

Match("$endif$"); if (state.failed) return ;
@@ -682,7 +682,7 @@ public partial class TemplateLexer : Lexer
_type = TemplateParser.ENDIF;

}
-					// Language\\Template.g3:316:5: ({...}? => ( '\\r' )? '\\n' )?
+					// Language\\Template.g3:317:5: ({...}? => ( '\\r' )? '\\n' )?
int alt12=2;
int LA12_0 = input.LA(1);

@@ -693,14 +693,14 @@ public partial class TemplateLexer : Lexer
switch ( alt12 )
{
case 1:
-						// Language\\Template.g3:316:7: {...}? => ( '\\r' )? '\\n'
+						// Language\\Template.g3:317:7: {...}? => ( '\\r' )? '\\n'
{
if ( !((startCol==0)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "startCol==0");
}
-						// Language\\Template.g3:316:25: ( '\\r' )?
+						// Language\\Template.g3:317:25: ( '\\r' )?
int alt11=2;
int LA11_0 = input.LA(1);

@@ -711,7 +711,7 @@ public partial class TemplateLexer : Lexer
switch ( alt11 )
{
case 1:
-							// Language\\Template.g3:316:26: '\\r'
+							// Language\\Template.g3:317:26: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -731,7 +731,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 5:
-					// Language\\Template.g3:320:5: => '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
+					// Language\\Template.g3:321:5: => '$@' (ch=~ ( '$' | '(' ) )+ ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
{

if ( state.backtracking == 0 )
@@ -742,7 +742,7 @@ public partial class TemplateLexer : Lexer
}
Match("$@"); if (state.failed) return ;

-					// Language\\Template.g3:324:10: (ch=~ ( '$' | '(' ) )+
+					// Language\\Template.g3:325:10: (ch=~ ( '$' | '(' ) )+
int cnt13=0;
for ( ; ; )
{
@@ -758,7 +758,7 @@ public partial class TemplateLexer : Lexer
switch ( alt13 )
{
case 1:
-							// Language\\Template.g3:324:12: ch=~ ( '$' | '(' )
+							// Language\\Template.g3:325:12: ch=~ ( '$' | '(' )
{
ch= input.LA(1);
input.Consume();
@@ -789,7 +789,7 @@ public partial class TemplateLexer : Lexer
{
t = builder.ToString();
}
-					// Language\\Template.g3:326:5: ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
+					// Language\\Template.g3:327:5: ( '()$' | '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )? )
int alt24=2;
int LA24_0 = input.LA(1);

@@ -811,7 +811,7 @@ public partial class TemplateLexer : Lexer
switch ( alt24 )
{
case 1:
-						// Language\\Template.g3:326:7: '()$'
+						// Language\\Template.g3:327:7: '()$'
{
Match("()$"); if (state.failed) return ;

@@ -825,7 +825,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:330:7: '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )?
+						// Language\\Template.g3:331:7: '$' (=> ( '\\r' )? '\\n' )? ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+ (=> ( '\\r' )? '\\n' )? (=> '$@end$' | . ) ({...}? ( '\\r' )? '\\n' )?
{
Match('$'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -835,7 +835,7 @@ public partial class TemplateLexer : Lexer
builder.Append("::=");

}
-						// Language\\Template.g3:335:6: (=> ( '\\r' )? '\\n' )?
+						// Language\\Template.g3:336:6: (=> ( '\\r' )? '\\n' )?
int alt15=2;
int LA15_0 = input.LA(1);

@@ -865,10 +865,10 @@ public partial class TemplateLexer : Lexer
switch ( alt15 )
{
case 1:
-							// Language\\Template.g3:335:8: => ( '\\r' )? '\\n'
+							// Language\\Template.g3:336:8: => ( '\\r' )? '\\n'
{

-							// Language\\Template.g3:335:23: ( '\\r' )?
+							// Language\\Template.g3:336:23: ( '\\r' )?
int alt14=2;
int LA14_0 = input.LA(1);

@@ -879,7 +879,7 @@ public partial class TemplateLexer : Lexer
switch ( alt14 )
{
case 1:
-								// Language\\Template.g3:335:24: '\\r'
+								// Language\\Template.g3:336:24: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -899,7 +899,7 @@ public partial class TemplateLexer : Lexer
{
atLeft = false;
}
-						// Language\\Template.g3:337:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
+						// Language\\Template.g3:338:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+
int cnt18=0;
for ( ; ; )
{
@@ -908,14 +908,14 @@ public partial class TemplateLexer : Lexer
switch ( alt18 )
{
case 1:
-								// Language\\Template.g3:337:8: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
+								// Language\\Template.g3:338:8: {...}? => (=> ( '\\r' )? '\\n' |ch= . )
{
if ( !((!(UpcomingAtEND(1) || ( input.LA(1) == '\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\r' && input.LA(2) == '\n' && UpcomingAtEND(3) )))) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "!(UpcomingAtEND(1) || ( input.LA(1) == '\\n' && UpcomingAtEND(2) ) || ( input.LA(1) == '\\r' && input.LA(2) == '\\n' && UpcomingAtEND(3) ))");
}
-								// Language\\Template.g3:338:7: (=> ( '\\r' )? '\\n' |ch= . )
+								// Language\\Template.g3:339:7: (=> ( '\\r' )? '\\n' |ch= . )
int alt17=2;
int LA17_0 = input.LA(1);

@@ -973,10 +973,10 @@ public partial class TemplateLexer : Lexer
switch ( alt17 )
{
case 1:
-									// Language\\Template.g3:338:9: => ( '\\r' )? '\\n'
+									// Language\\Template.g3:339:9: => ( '\\r' )? '\\n'
{

-									// Language\\Template.g3:338:24: ( '\\r' )?
+									// Language\\Template.g3:339:24: ( '\\r' )?
int alt16=2;
int LA16_0 = input.LA(1);

@@ -987,7 +987,7 @@ public partial class TemplateLexer : Lexer
switch ( alt16 )
{
case 1:
-										// Language\\Template.g3:338:25: '\\r'
+										// Language\\Template.g3:339:25: '\\r'
{
Match('\r'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1009,7 +1009,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-									// Language\\Template.g3:339:9: ch= .
+									// Language\\Template.g3:340:9: ch= .
{
ch = input.LA(1);
MatchAny(); if (state.failed) return ;
@@ -1041,7 +1041,7 @@ public partial class TemplateLexer : Lexer
;


-						// Language\\Template.g3:342:6: (=> ( '\\r' )? '\\n' )?
+						// Language\\Template.g3:343:6: (=> ( '\\r' )? '\\n' )?
int alt20=2;
int LA20_0 = input.LA(1);

@@ -1097,10 +1097,10 @@ public partial class TemplateLexer : Lexer
switch ( alt20 )
{
case 1:
-							// Language\\Template.g3:342:8: => ( '\\r' )? '\\n'
+							// Language\\Template.g3:343:8: => ( '\\r' )? '\\n'
{

-							// Language\\Template.g3:342:23: ( '\\r' )?
+							// Language\\Template.g3:343:23: ( '\\r' )?
int alt19=2;
int LA19_0 = input.LA(1);

@@ -1111,7 +1111,7 @@ public partial class TemplateLexer : Lexer
switch ( alt19 )
{
case 1:
-								// Language\\Template.g3:342:24: '\\r'
+								// Language\\Template.g3:343:24: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1131,7 +1131,7 @@ public partial class TemplateLexer : Lexer

}

-						// Language\\Template.g3:343:6: (=> '$@end$' | . )
+						// Language\\Template.g3:344:6: (=> '$@end$' | . )
int alt21=2;
int LA21_0 = input.LA(1);

@@ -1161,7 +1161,7 @@ public partial class TemplateLexer : Lexer
switch ( alt21 )
{
case 1:
-							// Language\\Template.g3:343:8: => '$@end$'
+							// Language\\Template.g3:344:8: => '$@end$'
{

Match("$@end$"); if (state.failed) return ;
@@ -1170,7 +1170,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-							// Language\\Template.g3:344:8: .
+							// Language\\Template.g3:345:8: .
{
MatchAny(); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1183,7 +1183,7 @@ public partial class TemplateLexer : Lexer

}

-						// Language\\Template.g3:346:6: ({...}? ( '\\r' )? '\\n' )?
+						// Language\\Template.g3:347:6: ({...}? ( '\\r' )? '\\n' )?
int alt23=2;
int LA23_0 = input.LA(1);

@@ -1194,14 +1194,14 @@ public partial class TemplateLexer : Lexer
switch ( alt23 )
{
case 1:
-							// Language\\Template.g3:346:8: {...}? ( '\\r' )? '\\n'
+							// Language\\Template.g3:347:8: {...}? ( '\\r' )? '\\n'
{
if ( !((atLeft)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "ACTION", "atLeft");
}
-							// Language\\Template.g3:346:18: ( '\\r' )?
+							// Language\\Template.g3:347:18: ( '\\r' )?
int alt22=2;
int LA22_0 = input.LA(1);

@@ -1212,7 +1212,7 @@ public partial class TemplateLexer : Lexer
switch ( alt22 )
{
case 1:
-								// Language\\Template.g3:346:19: '\\r'
+								// Language\\Template.g3:347:19: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1244,7 +1244,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 6:
-					// Language\\Template.g3:351:6: '$' EXPR[out subtext] '$'
+					// Language\\Template.g3:352:6: '$' EXPR[out subtext] '$'
{
Match('$'); if (state.failed) return ;
mEXPR(out subtext); if (state.failed) return ;
@@ -1300,10 +1300,10 @@ public partial class TemplateLexer : Lexer
int col = CharPositionInLine;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Template.g3:369:4: ( ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+ )
-			// Language\\Template.g3:369:4: ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
+			// Language\\Template.g3:370:4: ( ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+ )
+			// Language\\Template.g3:370:4: ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
{
-			// Language\\Template.g3:369:4: ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
+			// Language\\Template.g3:370:4: ( '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) ) |ind= INDENT |ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' ) )+
int cnt28=0;
for ( ; ; )
{
@@ -1327,10 +1327,10 @@ public partial class TemplateLexer : Lexer
switch ( alt28 )
{
case 1:
-					// Language\\Template.g3:369:6: '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
+					// Language\\Template.g3:370:6: '\\\\' ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
{
Match('\\'); if (state.failed) return ;
-					// Language\\Template.g3:370:4: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
+					// Language\\Template.g3:371:4: ( '$' | '\\\\' |ch=~ ( '$' | '\\\\' ) )
int alt27=3;
int LA27_0 = input.LA(1);

@@ -1356,7 +1356,7 @@ public partial class TemplateLexer : Lexer
switch ( alt27 )
{
case 1:
-						// Language\\Template.g3:370:6: '$'
+						// Language\\Template.g3:371:6: '$'
{
Match('$'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1367,7 +1367,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:371:6: '\\\\'
+						// Language\\Template.g3:372:6: '\\\\'
{
Match('\\'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1378,7 +1378,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-						// Language\\Template.g3:372:6: ch=~ ( '$' | '\\\\' )
+						// Language\\Template.g3:373:6: ch=~ ( '$' | '\\\\' )
{
ch= input.LA(1);
input.Consume();
@@ -1397,7 +1397,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-					// Language\\Template.g3:374:5: ind= INDENT
+					// Language\\Template.g3:375:5: ind= INDENT
{
int indStart759 = GetCharIndex();
mINDENT(); if (state.failed) return ;
@@ -1426,7 +1426,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-					// Language\\Template.g3:392:5: ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' )
+					// Language\\Template.g3:393:5: ch=~ ( '$' | '\\r' | '\\n' | '\\\\' | ' ' | '\\t' )
{
ch= input.LA(1);
input.Consume();
@@ -1487,10 +1487,10 @@ public partial class TemplateLexer : Lexer
string subtext = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Template.g3:407:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+ )
-			// Language\\Template.g3:407:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
+			// Language\\Template.g3:408:4: ( ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+ )
+			// Language\\Template.g3:408:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
{
-			// Language\\Template.g3:407:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
+			// Language\\Template.g3:408:4: ( ESC |st= SUBTEMPLATE | ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) ) |ch=~ ( '\\\\' | '{' | '=' | '+' | '$' ) )+
int cnt31=0;
for ( ; ; )
{
@@ -1518,7 +1518,7 @@ public partial class TemplateLexer : Lexer
switch ( alt31 )
{
case 1:
-					// Language\\Template.g3:407:6: ESC
+					// Language\\Template.g3:408:6: ESC
{
int ESC1Start821 = GetCharIndex();
mESC(); if (state.failed) return ;
@@ -1531,7 +1531,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-					// Language\\Template.g3:408:5: st= SUBTEMPLATE
+					// Language\\Template.g3:409:5: st= SUBTEMPLATE
{
int stStart837 = GetCharIndex();
mSUBTEMPLATE(); if (state.failed) return ;
@@ -1544,9 +1544,9 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-					// Language\\Template.g3:409:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					// Language\\Template.g3:410:5: ( '=' | '+' ) ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
{
-					// Language\\Template.g3:409:5: ( '=' | '+' )
+					// Language\\Template.g3:410:5: ( '=' | '+' )
int alt29=2;
int LA29_0 = input.LA(1);

@@ -1568,7 +1568,7 @@ public partial class TemplateLexer : Lexer
switch ( alt29 )
{
case 1:
-						// Language\\Template.g3:409:7: '='
+						// Language\\Template.g3:410:7: '='
{
Match('='); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1579,7 +1579,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:410:6: '+'
+						// Language\\Template.g3:411:6: '+'
{
Match('+'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1592,7 +1592,7 @@ public partial class TemplateLexer : Lexer

}

-					// Language\\Template.g3:412:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
+					// Language\\Template.g3:413:4: ( TEMPLATE[out subtext] |st= SUBTEMPLATE |ch=~ ( '\"' | '<' | '{' ) )
int alt30=3;
int LA30_0 = input.LA(1);

@@ -1618,7 +1618,7 @@ public partial class TemplateLexer : Lexer
switch ( alt30 )
{
case 1:
-						// Language\\Template.g3:412:6: TEMPLATE[out subtext]
+						// Language\\Template.g3:413:6: TEMPLATE[out subtext]
{
mTEMPLATE(out subtext); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1629,7 +1629,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:413:6: st= SUBTEMPLATE
+						// Language\\Template.g3:414:6: st= SUBTEMPLATE
{
int stStart895 = GetCharIndex();
mSUBTEMPLATE(); if (state.failed) return ;
@@ -1642,7 +1642,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-						// Language\\Template.g3:414:6: ch=~ ( '\"' | '<' | '{' )
+						// Language\\Template.g3:415:6: ch=~ ( '\"' | '<' | '{' )
{
ch= input.LA(1);
input.Consume();
@@ -1661,7 +1661,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 4:
-					// Language\\Template.g3:416:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '$' )
+					// Language\\Template.g3:417:5: ch=~ ( '\\\\' | '{' | '=' | '+' | '$' )
{
ch= input.LA(1);
input.Consume();
@@ -1714,7 +1714,7 @@ public partial class TemplateLexer : Lexer
_text = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Language\\Template.g3:428:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>' )
+			// Language\\Template.g3:429:4: ( '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"' | '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>' )
int alt37=2;
int LA37_0 = input.LA(1);

@@ -1736,14 +1736,14 @@ public partial class TemplateLexer : Lexer
switch ( alt37 )
{
case 1:
-				// Language\\Template.g3:428:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
+				// Language\\Template.g3:429:4: '\"' ( ESC |ch=~ ( '\\\\' | '\"' ) )* '\"'
{
Match('\"'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
builder.Append('"');
}
-				// Language\\Template.g3:430:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
+				// Language\\Template.g3:431:3: ( ESC |ch=~ ( '\\\\' | '\"' ) )*
for ( ; ; )
{
int alt32=3;
@@ -1762,7 +1762,7 @@ public partial class TemplateLexer : Lexer
switch ( alt32 )
{
case 1:
-						// Language\\Template.g3:430:5: ESC
+						// Language\\Template.g3:431:5: ESC
{
int ESC2Start981 = GetCharIndex();
mESC(); if (state.failed) return ;
@@ -1775,7 +1775,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:431:5: ch=~ ( '\\\\' | '\"' )
+						// Language\\Template.g3:432:5: ch=~ ( '\\\\' | '\"' )
{
ch= input.LA(1);
input.Consume();
@@ -1809,7 +1809,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-				// Language\\Template.g3:438:4: '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>'
+				// Language\\Template.g3:439:4: '<<' (=> ( '\\r' )? '\\n' )? (=> ( '\\r' )? '\\n' |ch= . )* '>>'
{
Match("<<"); if (state.failed) return ;

@@ -1819,7 +1819,7 @@ public partial class TemplateLexer : Lexer
builder.Append("<<");

}
-				// Language\\Template.g3:442:4: (=> ( '\\r' )? '\\n' )?
+				// Language\\Template.g3:443:4: (=> ( '\\r' )? '\\n' )?
int alt34=2;
int LA34_0 = input.LA(1);

@@ -1849,10 +1849,10 @@ public partial class TemplateLexer : Lexer
switch ( alt34 )
{
case 1:
-					// Language\\Template.g3:442:6: => ( '\\r' )? '\\n'
+					// Language\\Template.g3:443:6: => ( '\\r' )? '\\n'
{

-					// Language\\Template.g3:442:21: ( '\\r' )?
+					// Language\\Template.g3:443:21: ( '\\r' )?
int alt33=2;
int LA33_0 = input.LA(1);

@@ -1863,7 +1863,7 @@ public partial class TemplateLexer : Lexer
switch ( alt33 )
{
case 1:
-						// Language\\Template.g3:442:22: '\\r'
+						// Language\\Template.g3:443:22: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1879,7 +1879,7 @@ public partial class TemplateLexer : Lexer

}

-				// Language\\Template.g3:444:3: (=> ( '\\r' )? '\\n' |ch= . )*
+				// Language\\Template.g3:445:3: (=> ( '\\r' )? '\\n' |ch= . )*
for ( ; ; )
{
int alt36=3;
@@ -1946,10 +1946,10 @@ public partial class TemplateLexer : Lexer
switch ( alt36 )
{
case 1:
-						// Language\\Template.g3:444:5: => ( '\\r' )? '\\n'
+						// Language\\Template.g3:445:5: => ( '\\r' )? '\\n'
{

-						// Language\\Template.g3:444:23: ( '\\r' )?
+						// Language\\Template.g3:445:23: ( '\\r' )?
int alt35=2;
int LA35_0 = input.LA(1);

@@ -1960,7 +1960,7 @@ public partial class TemplateLexer : Lexer
switch ( alt35 )
{
case 1:
-							// Language\\Template.g3:444:24: '\\r'
+							// Language\\Template.g3:445:24: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -1974,7 +1974,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-						// Language\\Template.g3:445:5: ch= .
+						// Language\\Template.g3:446:5: ch= .
{
ch = input.LA(1);
MatchAny(); if (state.failed) return ;
@@ -2021,10 +2021,10 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:456:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
-			// Language\\Template.g3:456:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			// Language\\Template.g3:457:4: ( ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+ )
+			// Language\\Template.g3:457:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
{
-			// Language\\Template.g3:456:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
+			// Language\\Template.g3:457:4: ( ESC | SUBTEMPLATE | NESTED_PARENS |~ ( '\\\\' | '{' | '(' | ')' ) )+
int cnt38=0;
for ( ; ; )
{
@@ -2052,28 +2052,28 @@ public partial class TemplateLexer : Lexer
switch ( alt38 )
{
case 1:
-					// Language\\Template.g3:456:6: ESC
+					// Language\\Template.g3:457:6: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\Template.g3:457:5: SUBTEMPLATE
+					// Language\\Template.g3:458:5: SUBTEMPLATE
{
mSUBTEMPLATE(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\Template.g3:458:5: NESTED_PARENS
+					// Language\\Template.g3:459:5: NESTED_PARENS
{
mNESTED_PARENS(); if (state.failed) return ;

}
break;
case 4:
-					// Language\\Template.g3:459:5: ~ ( '\\\\' | '{' | '(' | ')' )
+					// Language\\Template.g3:460:5: ~ ( '\\\\' | '{' | '(' | ')' )
{
input.Consume();
state.failed=false;
@@ -2118,7 +2118,7 @@ public partial class TemplateLexer : Lexer

uc = '\0';

-			// Language\\Template.g3:469:4: ( '\\\\n' | '\\\\r' | '\\\\t' | '\\\\ ' | '\\\\u' a= HEX b= HEX c= HEX d= HEX )
+			// Language\\Template.g3:470:4: ( '\\\\n' | '\\\\r' | '\\\\t' | '\\\\ ' | '\\\\u' a= HEX b= HEX c= HEX d= HEX )
int alt39=5;
int LA39_0 = input.LA(1);

@@ -2171,7 +2171,7 @@ public partial class TemplateLexer : Lexer
switch ( alt39 )
{
case 1:
-				// Language\\Template.g3:469:4: '\\\\n'
+				// Language\\Template.g3:470:4: '\\\\n'
{
Match("\\n"); if (state.failed) return ;

@@ -2183,7 +2183,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 2:
-				// Language\\Template.g3:470:4: '\\\\r'
+				// Language\\Template.g3:471:4: '\\\\r'
{
Match("\\r"); if (state.failed) return ;

@@ -2195,7 +2195,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 3:
-				// Language\\Template.g3:471:4: '\\\\t'
+				// Language\\Template.g3:472:4: '\\\\t'
{
Match("\\t"); if (state.failed) return ;

@@ -2207,7 +2207,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 4:
-				// Language\\Template.g3:472:4: '\\\\ '
+				// Language\\Template.g3:473:4: '\\\\ '
{
Match("\\ "); if (state.failed) return ;

@@ -2219,7 +2219,7 @@ public partial class TemplateLexer : Lexer
}
break;
case 5:
-				// Language\\Template.g3:473:4: '\\\\u' a= HEX b= HEX c= HEX d= HEX
+				// Language\\Template.g3:474:4: '\\\\u' a= HEX b= HEX c= HEX d= HEX
{
Match("\\u"); if (state.failed) return ;

@@ -2256,8 +2256,8 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:479:4: ( '\\\\' . )
-			// Language\\Template.g3:479:4: '\\\\' .
+			// Language\\Template.g3:480:4: ( '\\\\' . )
+			// Language\\Template.g3:480:4: '\\\\' .
{
Match('\\'); if (state.failed) return ;
MatchAny(); if (state.failed) return ;
@@ -2276,7 +2276,7 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:484:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
+			// Language\\Template.g3:485:4: ( '0' .. '9' | 'A' .. 'F' | 'a' .. 'f' )
// Language\\Template.g3:
{
if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
@@ -2306,11 +2306,11 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:489:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
-			// Language\\Template.g3:489:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
+			// Language\\Template.g3:490:4: ( '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}' )
+			// Language\\Template.g3:490:4: '{' ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )* '}'
{
Match('{'); if (state.failed) return ;
-			// Language\\Template.g3:490:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
+			// Language\\Template.g3:491:3: ( SUBTEMPLATE | ESC |~ ( '{' | '\\\\' | '}' ) )*
for ( ; ; )
{
int alt40=4;
@@ -2333,21 +2333,21 @@ public partial class TemplateLexer : Lexer
switch ( alt40 )
{
case 1:
-					// Language\\Template.g3:490:5: SUBTEMPLATE
+					// Language\\Template.g3:491:5: SUBTEMPLATE
{
mSUBTEMPLATE(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\Template.g3:491:5: ESC
+					// Language\\Template.g3:492:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\Template.g3:492:5: ~ ( '{' | '\\\\' | '}' )
+					// Language\\Template.g3:493:5: ~ ( '{' | '\\\\' | '}' )
{
input.Consume();
state.failed=false;
@@ -2380,11 +2380,11 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:499:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
-			// Language\\Template.g3:499:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
+			// Language\\Template.g3:500:4: ( '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')' )
+			// Language\\Template.g3:500:4: '(' ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+ ')'
{
Match('('); if (state.failed) return ;
-			// Language\\Template.g3:500:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
+			// Language\\Template.g3:501:3: ( NESTED_PARENS | ESC |~ ( '(' | '\\\\' | ')' ) )+
int cnt41=0;
for ( ; ; )
{
@@ -2408,21 +2408,21 @@ public partial class TemplateLexer : Lexer
switch ( alt41 )
{
case 1:
-					// Language\\Template.g3:500:5: NESTED_PARENS
+					// Language\\Template.g3:501:5: NESTED_PARENS
{
mNESTED_PARENS(); if (state.failed) return ;

}
break;
case 2:
-					// Language\\Template.g3:501:5: ESC
+					// Language\\Template.g3:502:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 3:
-					// Language\\Template.g3:502:5: ~ ( '(' | '\\\\' | ')' )
+					// Language\\Template.g3:503:5: ~ ( '(' | '\\\\' | ')' )
{
input.Consume();
state.failed=false;
@@ -2460,10 +2460,10 @@ public partial class TemplateLexer : Lexer
{
try
{
-			// Language\\Template.g3:509:4: ( ( ' ' | '\\t' )+ )
-			// Language\\Template.g3:509:4: ( ' ' | '\\t' )+
+			// Language\\Template.g3:510:4: ( ( ' ' | '\\t' )+ )
+			// Language\\Template.g3:510:4: ( ' ' | '\\t' )+
{
-			// Language\\Template.g3:509:4: ( ' ' | '\\t' )+
+			// Language\\Template.g3:510:4: ( ' ' | '\\t' )+
int cnt42=0;
for ( ; ; )
{
@@ -2519,12 +2519,12 @@ public partial class TemplateLexer : Lexer

int startCol = CharPositionInLine;

-			// Language\\Template.g3:518:4: ( '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )? )
-			// Language\\Template.g3:518:4: '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )?
+			// Language\\Template.g3:519:4: ( '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )? )
+			// Language\\Template.g3:519:4: '$!' ( . )* '!$' ({...}? => ( '\\r' )? '\\n' )?
{
Match("$!"); if (state.failed) return ;

-			// Language\\Template.g3:518:9: ( . )*
+			// Language\\Template.g3:519:9: ( . )*
for ( ; ; )
{
int alt43=2;
@@ -2554,7 +2554,7 @@ public partial class TemplateLexer : Lexer
switch ( alt43 )
{
case 1:
-					// Language\\Template.g3:518:0: .
+					// Language\\Template.g3:519:0: .
{
MatchAny(); if (state.failed) return ;

@@ -2572,7 +2572,7 @@ public partial class TemplateLexer : Lexer

Match("!$"); if (state.failed) return ;

-			// Language\\Template.g3:518:17: ({...}? => ( '\\r' )? '\\n' )?
+			// Language\\Template.g3:519:17: ({...}? => ( '\\r' )? '\\n' )?
int alt45=2;
int LA45_0 = input.LA(1);

@@ -2583,14 +2583,14 @@ public partial class TemplateLexer : Lexer
switch ( alt45 )
{
case 1:
-				// Language\\Template.g3:518:19: {...}? => ( '\\r' )? '\\n'
+				// Language\\Template.g3:519:19: {...}? => ( '\\r' )? '\\n'
{
if ( !((startCol==0)) )
{
if (state.backtracking>0) {state.failed=true; return ;}
throw new FailedPredicateException(input, "COMMENT", "startCol==0");
}
-				// Language\\Template.g3:518:37: ( '\\r' )?
+				// Language\\Template.g3:519:37: ( '\\r' )?
int alt44=2;
int LA44_0 = input.LA(1);

@@ -2601,7 +2601,7 @@ public partial class TemplateLexer : Lexer
switch ( alt44 )
{
case 1:
-					// Language\\Template.g3:518:38: '\\r'
+					// Language\\Template.g3:519:38: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -2683,8 +2683,8 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred1_Template
public void synpred1_Template_fragment()
{
-		// Language\\Template.g3:280:4: ( '$\\\\' )
-		// Language\\Template.g3:280:5: '$\\\\'
+		// Language\\Template.g3:281:4: ( '$\\\\' )
+		// Language\\Template.g3:281:5: '$\\\\'
{
Match("$\\"); if (state.failed) return ;

@@ -2696,7 +2696,7 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred10_Template
public void synpred10_Template_fragment()
{
-		// Language\\Template.g3:342:8: ( '\\r' | '\\n' )
+		// Language\\Template.g3:343:8: ( '\\r' | '\\n' )
// Language\\Template.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2719,8 +2719,8 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred11_Template
public void synpred11_Template_fragment()
{
-		// Language\\Template.g3:343:8: ( '$@end$' )
-		// Language\\Template.g3:343:9: '$@end$'
+		// Language\\Template.g3:344:8: ( '$@end$' )
+		// Language\\Template.g3:344:9: '$@end$'
{
Match("$@end$"); if (state.failed) return ;

@@ -2732,7 +2732,7 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred12_Template
public void synpred12_Template_fragment()
{
-		// Language\\Template.g3:442:6: ( '\\r' | '\\n' )
+		// Language\\Template.g3:443:6: ( '\\r' | '\\n' )
// Language\\Template.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2755,10 +2755,10 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred13_Template
public void synpred13_Template_fragment()
{
-		// Language\\Template.g3:444:5: ( ( '\\r' )? '\\n>>' )
-		// Language\\Template.g3:444:6: ( '\\r' )? '\\n>>'
+		// Language\\Template.g3:445:5: ( ( '\\r' )? '\\n>>' )
+		// Language\\Template.g3:445:6: ( '\\r' )? '\\n>>'
{
-		// Language\\Template.g3:444:6: ( '\\r' )?
+		// Language\\Template.g3:445:6: ( '\\r' )?
int alt47=2;
int LA47_0 = input.LA(1);

@@ -2769,7 +2769,7 @@ public partial class TemplateLexer : Lexer
switch ( alt47 )
{
case 1:
-			// Language\\Template.g3:444:0: '\\r'
+			// Language\\Template.g3:445:0: '\\r'
{
Match('\r'); if (state.failed) return ;

@@ -2788,8 +2788,8 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred2_Template
public void synpred2_Template_fragment()
{
-		// Language\\Template.g3:287:5: ( '$!' )
-		// Language\\Template.g3:287:6: '$!'
+		// Language\\Template.g3:288:5: ( '$!' )
+		// Language\\Template.g3:288:6: '$!'
{
Match("$!"); if (state.failed) return ;

@@ -2801,8 +2801,8 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred3_Template
public void synpred3_Template_fragment()
{
-		// Language\\Template.g3:289:7: ( '$if' ( ' ' | '(' ) )
-		// Language\\Template.g3:289:8: '$if' ( ' ' | '(' )
+		// Language\\Template.g3:290:7: ( '$if' ( ' ' | '(' ) )
+		// Language\\Template.g3:290:8: '$if' ( ' ' | '(' )
{
Match("$if"); if (state.failed) return ;

@@ -2826,8 +2826,8 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred4_Template
public void synpred4_Template_fragment()
{
-		// Language\\Template.g3:296:6: ( '$elseif' ( ' ' | '(' ) )
-		// Language\\Template.g3:296:7: '$elseif' ( ' ' | '(' )
+		// Language\\Template.g3:297:6: ( '$elseif' ( ' ' | '(' ) )
+		// Language\\Template.g3:297:7: '$elseif' ( ' ' | '(' )
{
Match("$elseif"); if (state.failed) return ;

@@ -2851,8 +2851,8 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred5_Template
public void synpred5_Template_fragment()
{
-		// Language\\Template.g3:303:6: ( '$else$' )
-		// Language\\Template.g3:303:7: '$else$'
+		// Language\\Template.g3:304:6: ( '$else$' )
+		// Language\\Template.g3:304:7: '$else$'
{
Match("$else$"); if (state.failed) return ;

@@ -2864,8 +2864,8 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred6_Template
public void synpred6_Template_fragment()
{
-		// Language\\Template.g3:310:6: ( '$endif$' )
-		// Language\\Template.g3:310:7: '$endif$'
+		// Language\\Template.g3:311:6: ( '$endif$' )
+		// Language\\Template.g3:311:7: '$endif$'
{
Match("$endif$"); if (state.failed) return ;

@@ -2877,8 +2877,8 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred7_Template
public void synpred7_Template_fragment()
{
-		// Language\\Template.g3:320:5: ( '$@' )
-		// Language\\Template.g3:320:6: '$@'
+		// Language\\Template.g3:321:5: ( '$@' )
+		// Language\\Template.g3:321:6: '$@'
{
Match("$@"); if (state.failed) return ;

@@ -2890,7 +2890,7 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred8_Template
public void synpred8_Template_fragment()
{
-		// Language\\Template.g3:335:8: ( '\\r' | '\\n' )
+		// Language\\Template.g3:336:8: ( '\\r' | '\\n' )
// Language\\Template.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -2913,7 +2913,7 @@ public partial class TemplateLexer : Lexer
// $ANTLR start synpred9_Template
public void synpred9_Template_fragment()
{
-		// Language\\Template.g3:338:9: ( '\\r' | '\\n' )
+		// Language\\Template.g3:339:9: ( '\\r' | '\\n' )
// Language\\Template.g3:
{
if ( input.LA(1)=='\n'||input.LA(1)=='\r' )
@@ -3245,7 +3245,7 @@ public partial class TemplateLexer : Lexer
}
public override string GetDescription()
{
-			return "()+ loopback of 337:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
+			return "()+ loopback of 338:6: ({...}? => (=> ( '\\r' )? '\\n' |ch= . ) )+";
}
}

diff --git a/Antlr3.StringTemplate/Language/TemplateParser.cs b/Antlr3.StringTemplate/Language/TemplateParser.cs
index cd4cc90..6333875 100644
--- a/Antlr3.StringTemplate/Language/TemplateParser.cs
+++ b/Antlr3.StringTemplate/Language/TemplateParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Language\\Template.g3 2009-03-16 17:21:57
+// $ANTLR 3.1.2 Language\\Template.g3 2009-03-16 21:10:52

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -150,7 +150,8 @@ public partial class TemplateParser : Parser
{
nl=(IToken)Match(input,NEWLINE,Follow._NEWLINE_in_template82);

-									if ( input.LA(1)!=ELSE && input.LA(1)!=ENDIF )
+									int next = input.LA(1);
+									if ( next!=ELSE && next!=ENDIF )
{
self.AddChunk(new NewlineRef(self,(nl!=null?nl.Text:null)));
}
@@ -159,7 +160,7 @@ public partial class TemplateParser : Parser
}
break;
case 3:
-					// Language\\Template.g3:127:5: action[self]
+					// Language\\Template.g3:128:5: action[self]
{
PushFollow(Follow._action_in_template93);
action(self);
@@ -179,7 +180,7 @@ public partial class TemplateParser : Parser
;


-			// Language\\Template.g3:129:3: ( EOF )?
+			// Language\\Template.g3:130:3: ( EOF )?
int alt2=2;
int LA2_0 = input.LA(1);

@@ -190,7 +191,7 @@ public partial class TemplateParser : Parser
switch ( alt2 )
{
case 1:
-				// Language\\Template.g3:129:0: EOF
+				// Language\\Template.g3:130:0: EOF
{
Match(input,EOF,Follow._EOF_in_template103);

@@ -217,7 +218,7 @@ public partial class TemplateParser : Parser


// $ANTLR start "action"
-	// Language\\Template.g3:132:0: action[StringTemplate self] : (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF );
+	// Language\\Template.g3:133:0: action[StringTemplate self] : (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF );
private void action( StringTemplate self )
{
IToken a=null;
@@ -228,7 +229,7 @@ public partial class TemplateParser : Parser

try
{
-			// Language\\Template.g3:133:4: (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF )
+			// Language\\Template.g3:134:4: (a= ACTION |i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF |rr= REGION_REF |rd= REGION_DEF )
int alt5=4;
switch ( input.LA(1) )
{
@@ -263,7 +264,7 @@ public partial class TemplateParser : Parser
switch ( alt5 )
{
case 1:
-				// Language\\Template.g3:133:4: a= ACTION
+				// Language\\Template.g3:134:4: a= ACTION
{
a=(IToken)Match(input,ACTION,Follow._ACTION_in_action118);

@@ -276,7 +277,7 @@ public partial class TemplateParser : Parser
}
break;
case 2:
-				// Language\\Template.g3:141:4: i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF
+				// Language\\Template.g3:142:4: i= IF template[subtemplate] (ei= ELSEIF template[elseIfSubtemplate] )* ( ELSE template[elseSubtemplate] )? ENDIF
{
i=(IToken)Match(input,IF,Follow._IF_in_action130);

@@ -293,7 +294,7 @@ public partial class TemplateParser : Parser
state._fsp--;

if ( c!=null ) c.SetSubtemplate(subtemplate);
-				// Language\\Template.g3:153:3: (ei= ELSEIF template[elseIfSubtemplate] )*
+				// Language\\Template.g3:154:3: (ei= ELSEIF template[elseIfSubtemplate] )*
for ( ; ; )
{
int alt3=2;
@@ -308,7 +309,7 @@ public partial class TemplateParser : Parser
switch ( alt3 )
{
case 1:
-						// Language\\Template.g3:153:5: ei= ELSEIF template[elseIfSubtemplate]
+						// Language\\Template.g3:154:5: ei= ELSEIF template[elseIfSubtemplate]
{
ei=(IToken)Match(input,ELSEIF,Follow._ELSEIF_in_action151);

@@ -337,7 +338,7 @@ public partial class TemplateParser : Parser
;


-				// Language\\Template.g3:167:3: ( ELSE template[elseSubtemplate] )?
+				// Language\\Template.g3:168:3: ( ELSE template[elseSubtemplate] )?
int alt4=2;
int LA4_0 = input.LA(1);

@@ -348,7 +349,7 @@ public partial class TemplateParser : Parser
switch ( alt4 )
{
case 1:
-					// Language\\Template.g3:167:5: ELSE template[elseSubtemplate]
+					// Language\\Template.g3:168:5: ELSE template[elseSubtemplate]
{
Match(input,ELSE,Follow._ELSE_in_action181);

@@ -374,7 +375,7 @@ public partial class TemplateParser : Parser
}
break;
case 3:
-				// Language\\Template.g3:181:4: rr= REGION_REF
+				// Language\\Template.g3:182:4: rr= REGION_REF
{
rr=(IToken)Match(input,REGION_REF,Follow._REGION_REF_in_action216);

@@ -427,7 +428,7 @@ public partial class TemplateParser : Parser
}
break;
case 4:
-				// Language\\Template.g3:229:4: rd= REGION_DEF
+				// Language\\Template.g3:230:4: rd= REGION_DEF
{
rd=(IToken)Match(input,REGION_DEF,Follow._REGION_DEF_in_action228);

diff --git a/Antlr3/Grammars/ANTLR.g3 b/Antlr3/Grammars/ANTLR.g3
index d434426..c70463e 100644
--- a/Antlr3/Grammars/ANTLR.g3
+++ b/Antlr3/Grammars/ANTLR.g3
@@ -844,17 +844,9 @@ SL_COMMENT

fragment
ML_COMMENT[ref int type]
-@init
-{
-	$type = ML_COMMENT;
-}
:	'/*'
-		(	('*' ~'/') => '*' {$type = DOC_COMMENT;}
-		|
-		)
-		(	('*' ~'/') => '*'
-		|	~'*'
-		)*
+		{type = (input.LA(1) == '*' && input.LA(2) != '/') ? DOC_COMMENT : ML_COMMENT;}
+		.*
'*/'
;

@@ -956,17 +948,14 @@ DOUBLE_QUOTE_STRING_LITERAL
;

DOUBLE_ANGLE_STRING_LITERAL
-	:	'<<'
-		(	~'>'
-		|	('>' ~'>') => '>'
-		)*
-		'>>'
+	:	'<<' .* '>>'
;

fragment
ESC
:	'\\'
-		(	'n'
+		(	// due to the way ESC is used, we don't need to handle the following character in different ways
+			/*'n'
|	'r'
|	't'
|	'b'
@@ -976,7 +965,7 @@ ESC
|	'\\'
|	'>'
|	'u' XDIGIT XDIGIT XDIGIT XDIGIT
-		|	. // unknown, leave as it is
+		|*/	. // unknown, leave as it is
)
;

diff --git a/Antlr3/Grammars/ANTLRLexer.cs b/Antlr3/Grammars/ANTLRLexer.cs
index a7b2d0f..4ddf983 100644
--- a/Antlr3/Grammars/ANTLRLexer.cs
+++ b/Antlr3/Grammars/ANTLRLexer.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-03-07 09:02:31
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-03-16 19:03:27

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -920,140 +920,58 @@ public partial class ANTLRLexer : Lexer
{
try
{
-
-				type = ML_COMMENT;
-
-			// Grammars\\ANTLR.g3:852:4: ( '/*' (=> '*' |) (=> '*' |~ '*' )* '*/' )
-			// Grammars\\ANTLR.g3:852:4: '/*' (=> '*' |) (=> '*' |~ '*' )* '*/'
+			// Grammars\\ANTLR.g3:848:4: ( '/*' ( . )* '*/' )
+			// Grammars\\ANTLR.g3:848:4: '/*' ( . )* '*/'
{
Match("/*"); if (state.failed) return ;

-			// Grammars\\ANTLR.g3:853:3: (=> '*' |)
-			int alt10=2;
-			int LA10_0 = input.LA(1);
-
-			if ( (LA10_0=='*') )
-			{
-				int LA10_1 = input.LA(2);
-
-				if ( (synpred2_ANTLR()) )
-				{
-					alt10=1;
-				}
-				else if ( (true) )
-				{
-					alt10=2;
-				}
-				else
-				{
-					if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 10, 1, input);
-
-					throw nvae;
-				}
-			}
-			else if ( ((LA10_0>='\u0000' && LA10_0<=')')||(LA10_0>='+' && LA10_0<='\uFFFF')) )
-			{
-				alt10=2;
-			}
-			else
-			{
-				if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
-
-				throw nvae;
-			}
-			switch ( alt10 )
+			if ( state.backtracking == 0 )
{
-			case 1:
-				// Grammars\\ANTLR.g3:853:5: => '*'
-				{
-
-				Match('*'); if (state.failed) return ;
-				if ( state.backtracking == 0 )
-				{
-					type = DOC_COMMENT;
-				}
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:855:3:
-				{
-
-
-				}
-				break;
-
+				type = (input.LA(1) == '*' && input.LA(2) != '/') ? DOC_COMMENT : ML_COMMENT;
}
-
-			// Grammars\\ANTLR.g3:856:3: (=> '*' |~ '*' )*
+			// Grammars\\ANTLR.g3:850:3: ( . )*
for ( ; ; )
{
-				int alt11=3;
-				int LA11_0 = input.LA(1);
+				int alt10=2;
+				int LA10_0 = input.LA(1);

-				if ( (LA11_0=='*') )
+				if ( (LA10_0=='*') )
{
-					int LA11_1 = input.LA(2);
-
-					if ( (LA11_1=='/') )
-					{
-						int LA11_3 = input.LA(3);
-
-						if ( (LA11_3=='*') && (synpred3_ANTLR()))
-						{
-							alt11=1;
-						}
-						else if ( ((LA11_3>='\u0000' && LA11_3<=')')||(LA11_3>='+' && LA11_3<='\uFFFF')) && (synpred3_ANTLR()))
-						{
-							alt11=1;
-						}
-
+					int LA10_1 = input.LA(2);

-					}
-					else if ( (LA11_1=='*') && (synpred3_ANTLR()))
+					if ( (LA10_1=='/') )
{
-						alt11=1;
+						alt10=2;
}
-					else if ( ((LA11_1>='\u0000' && LA11_1<=')')||(LA11_1>='+' && LA11_1<='.')||(LA11_1>='0' && LA11_1<='\uFFFF')) && (synpred3_ANTLR()))
+					else if ( ((LA10_1>='\u0000' && LA10_1<='.')||(LA10_1>='0' && LA10_1<='\uFFFF')) )
{
-						alt11=1;
+						alt10=1;
}


}
-				else if ( ((LA11_0>='\u0000' && LA11_0<=')')||(LA11_0>='+' && LA11_0<='\uFFFF')) )
+				else if ( ((LA10_0>='\u0000' && LA10_0<=')')||(LA10_0>='+' && LA10_0<='\uFFFF')) )
{
-					alt11=2;
+					alt10=1;
}


-				switch ( alt11 )
+				switch ( alt10 )
{
case 1:
-					// Grammars\\ANTLR.g3:856:5: => '*'
-					{
-
-					Match('*'); if (state.failed) return ;
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:857:5: ~ '*'
+					// Grammars\\ANTLR.g3:850:0: .
{
-					input.Consume();
-					state.failed=false;
+					MatchAny(); if (state.failed) return ;

}
break;

default:
-					goto loop11;
+					goto loop10;
}
}

-			loop11:
+			loop10:
;


@@ -1076,8 +994,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = OPEN_ELEMENT_OPTION;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:862:4: ( '<' )
-			// Grammars\\ANTLR.g3:862:4: '<'
+			// Grammars\\ANTLR.g3:854:4: ( '<' )
+			// Grammars\\ANTLR.g3:854:4: '<'
{
Match('<'); if (state.failed) return ;

@@ -1099,8 +1017,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = CLOSE_ELEMENT_OPTION;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:866:4: ( '>' )
-			// Grammars\\ANTLR.g3:866:4: '>'
+			// Grammars\\ANTLR.g3:858:4: ( '>' )
+			// Grammars\\ANTLR.g3:858:4: '>'
{
Match('>'); if (state.failed) return ;

@@ -1122,8 +1040,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = AMPERSAND;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:869:13: ( '@' )
-			// Grammars\\ANTLR.g3:869:13: '@'
+			// Grammars\\ANTLR.g3:861:13: ( '@' )
+			// Grammars\\ANTLR.g3:861:13: '@'
{
Match('@'); if (state.failed) return ;

@@ -1145,8 +1063,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = COMMA;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:871:9: ( ',' )
-			// Grammars\\ANTLR.g3:871:9: ','
+			// Grammars\\ANTLR.g3:863:9: ( ',' )
+			// Grammars\\ANTLR.g3:863:9: ','
{
Match(','); if (state.failed) return ;

@@ -1168,8 +1086,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = QUESTION;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:873:12: ( '?' )
-			// Grammars\\ANTLR.g3:873:12: '?'
+			// Grammars\\ANTLR.g3:865:12: ( '?' )
+			// Grammars\\ANTLR.g3:865:12: '?'
{
Match('?'); if (state.failed) return ;

@@ -1191,8 +1109,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = TREE_BEGIN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:875:14: ( '^(' )
-			// Grammars\\ANTLR.g3:875:14: '^('
+			// Grammars\\ANTLR.g3:867:14: ( '^(' )
+			// Grammars\\ANTLR.g3:867:14: '^('
{
Match("^("); if (state.failed) return ;

@@ -1215,8 +1133,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = LPAREN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:877:9: ( '(' )
-			// Grammars\\ANTLR.g3:877:9: '('
+			// Grammars\\ANTLR.g3:869:9: ( '(' )
+			// Grammars\\ANTLR.g3:869:9: '('
{
Match('('); if (state.failed) return ;

@@ -1238,8 +1156,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = RPAREN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:879:9: ( ')' )
-			// Grammars\\ANTLR.g3:879:9: ')'
+			// Grammars\\ANTLR.g3:871:9: ( ')' )
+			// Grammars\\ANTLR.g3:871:9: ')'
{
Match(')'); if (state.failed) return ;

@@ -1261,8 +1179,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = COLON;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:881:9: ( ':' )
-			// Grammars\\ANTLR.g3:881:9: ':'
+			// Grammars\\ANTLR.g3:873:9: ( ':' )
+			// Grammars\\ANTLR.g3:873:9: ':'
{
Match(':'); if (state.failed) return ;

@@ -1284,8 +1202,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = STAR;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:883:7: ( '*' )
-			// Grammars\\ANTLR.g3:883:7: '*'
+			// Grammars\\ANTLR.g3:875:7: ( '*' )
+			// Grammars\\ANTLR.g3:875:7: '*'
{
Match('*'); if (state.failed) return ;

@@ -1307,8 +1225,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = PLUS;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:885:7: ( '+' )
-			// Grammars\\ANTLR.g3:885:7: '+'
+			// Grammars\\ANTLR.g3:877:7: ( '+' )
+			// Grammars\\ANTLR.g3:877:7: '+'
{
Match('+'); if (state.failed) return ;

@@ -1330,8 +1248,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = ASSIGN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:887:10: ( '=' )
-			// Grammars\\ANTLR.g3:887:10: '='
+			// Grammars\\ANTLR.g3:879:10: ( '=' )
+			// Grammars\\ANTLR.g3:879:10: '='
{
Match('='); if (state.failed) return ;

@@ -1353,8 +1271,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = PLUS_ASSIGN;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:889:15: ( '+=' )
-			// Grammars\\ANTLR.g3:889:15: '+='
+			// Grammars\\ANTLR.g3:881:15: ( '+=' )
+			// Grammars\\ANTLR.g3:881:15: '+='
{
Match("+="); if (state.failed) return ;

@@ -1377,8 +1295,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = IMPLIES;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:891:11: ( '=>' )
-			// Grammars\\ANTLR.g3:891:11: '=>'
+			// Grammars\\ANTLR.g3:883:11: ( '=>' )
+			// Grammars\\ANTLR.g3:883:11: '=>'
{
Match("=>"); if (state.failed) return ;

@@ -1401,8 +1319,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = REWRITE;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:893:11: ( '->' )
-			// Grammars\\ANTLR.g3:893:11: '->'
+			// Grammars\\ANTLR.g3:885:11: ( '->' )
+			// Grammars\\ANTLR.g3:885:11: '->'
{
Match("->"); if (state.failed) return ;

@@ -1425,8 +1343,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = SEMI;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:895:7: ( ';' )
-			// Grammars\\ANTLR.g3:895:7: ';'
+			// Grammars\\ANTLR.g3:887:7: ( ';' )
+			// Grammars\\ANTLR.g3:887:7: ';'
{
Match(';'); if (state.failed) return ;

@@ -1448,8 +1366,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = ROOT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:897:8: ( '^' )
-			// Grammars\\ANTLR.g3:897:8: '^'
+			// Grammars\\ANTLR.g3:889:8: ( '^' )
+			// Grammars\\ANTLR.g3:889:8: '^'
{
Match('^'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1475,8 +1393,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = BANG;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:899:8: ( '!' )
-			// Grammars\\ANTLR.g3:899:8: '!'
+			// Grammars\\ANTLR.g3:891:8: ( '!' )
+			// Grammars\\ANTLR.g3:891:8: '!'
{
Match('!'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1502,8 +1420,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = OR;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:901:6: ( '|' )
-			// Grammars\\ANTLR.g3:901:6: '|'
+			// Grammars\\ANTLR.g3:893:6: ( '|' )
+			// Grammars\\ANTLR.g3:893:6: '|'
{
Match('|'); if (state.failed) return ;

@@ -1525,8 +1443,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = WILDCARD;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:903:12: ( '.' )
-			// Grammars\\ANTLR.g3:903:12: '.'
+			// Grammars\\ANTLR.g3:895:12: ( '.' )
+			// Grammars\\ANTLR.g3:895:12: '.'
{
Match('.'); if (state.failed) return ;

@@ -1548,8 +1466,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = ETC;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:905:7: ( '...' )
-			// Grammars\\ANTLR.g3:905:7: '...'
+			// Grammars\\ANTLR.g3:897:7: ( '...' )
+			// Grammars\\ANTLR.g3:897:7: '...'
{
Match("..."); if (state.failed) return ;

@@ -1572,8 +1490,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = RANGE;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:907:9: ( '..' )
-			// Grammars\\ANTLR.g3:907:9: '..'
+			// Grammars\\ANTLR.g3:899:9: ( '..' )
+			// Grammars\\ANTLR.g3:899:9: '..'
{
Match(".."); if (state.failed) return ;

@@ -1596,8 +1514,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = NOT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:909:7: ( '~' )
-			// Grammars\\ANTLR.g3:909:7: '~'
+			// Grammars\\ANTLR.g3:901:7: ( '~' )
+			// Grammars\\ANTLR.g3:901:7: '~'
{
Match('~'); if (state.failed) return ;

@@ -1619,8 +1537,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = RCURLY;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:911:9: ( '}' )
-			// Grammars\\ANTLR.g3:911:9: '}'
+			// Grammars\\ANTLR.g3:903:9: ( '}' )
+			// Grammars\\ANTLR.g3:903:9: '}'
{
Match('}'); if (state.failed) return ;

@@ -1642,8 +1560,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = DOLLAR;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:913:10: ( '$' )
-			// Grammars\\ANTLR.g3:913:10: '$'
+			// Grammars\\ANTLR.g3:905:10: ( '$' )
+			// Grammars\\ANTLR.g3:905:10: '$'
{
Match('$'); if (state.failed) return ;

@@ -1665,8 +1583,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = STRAY_BRACKET;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:916:4: ( ']' )
-			// Grammars\\ANTLR.g3:916:4: ']'
+			// Grammars\\ANTLR.g3:908:4: ( ']' )
+			// Grammars\\ANTLR.g3:908:4: ']'
{
Match(']'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -1699,37 +1617,37 @@ public partial class ANTLRLexer : Lexer
{
int _type = CHAR_LITERAL;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:928:4: ( '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
-			// Grammars\\ANTLR.g3:928:4: '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\''
+			// Grammars\\ANTLR.g3:920:4: ( '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
+			// Grammars\\ANTLR.g3:920:4: '\\'' ( ESC |~ ( '\\\\' | '\\'' ) )* '\\''
{
Match('\''); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:929:3: ( ESC |~ ( '\\\\' | '\\'' ) )*
+			// Grammars\\ANTLR.g3:921:3: ( ESC |~ ( '\\\\' | '\\'' ) )*
for ( ; ; )
{
-				int alt12=3;
-				int LA12_0 = input.LA(1);
+				int alt11=3;
+				int LA11_0 = input.LA(1);

-				if ( (LA12_0=='\\') )
+				if ( (LA11_0=='\\') )
{
-					alt12=1;
+					alt11=1;
}
-				else if ( ((LA12_0>='\u0000' && LA12_0<='&')||(LA12_0>='(' && LA12_0<='[')||(LA12_0>=']' && LA12_0<='\uFFFF')) )
+				else if ( ((LA11_0>='\u0000' && LA11_0<='&')||(LA11_0>='(' && LA11_0<='[')||(LA11_0>=']' && LA11_0<='\uFFFF')) )
{
-					alt12=2;
+					alt11=2;
}


-				switch ( alt12 )
+				switch ( alt11 )
{
case 1:
-					// Grammars\\ANTLR.g3:929:5: ESC
+					// Grammars\\ANTLR.g3:921:5: ESC
{
mESC(); if (state.failed) return ;

}
break;
case 2:
-					// Grammars\\ANTLR.g3:930:5: ~ ( '\\\\' | '\\'' )
+					// Grammars\\ANTLR.g3:922:5: ~ ( '\\\\' | '\\'' )
{
input.Consume();
state.failed=false;
@@ -1738,11 +1656,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop12;
+					goto loop11;
}
}

-			loop12:
+			loop11:
;


@@ -1781,45 +1699,45 @@ public partial class ANTLRLexer : Lexer

System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Grammars\\ANTLR.g3:947:4: ( '\"' (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"' )
-			// Grammars\\ANTLR.g3:947:4: '\"' (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"'
+			// Grammars\\ANTLR.g3:939:4: ( '\"' (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"' )
+			// Grammars\\ANTLR.g3:939:4: '\"' (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )* '\"'
{
Match('\"'); if (state.failed) return ;
if ( state.backtracking == 0 )
{
builder.Append('"');
}
-			// Grammars\\ANTLR.g3:948:3: (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )*
+			// Grammars\\ANTLR.g3:940:3: (=> '\\\\' '\"' | '\\\\' c=~ '\"' |c=~ ( '\\\\' | '\"' ) )*
for ( ; ; )
{
-				int alt13=4;
-				int LA13_0 = input.LA(1);
+				int alt12=4;
+				int LA12_0 = input.LA(1);

-				if ( (LA13_0=='\\') )
+				if ( (LA12_0=='\\') )
{
-					int LA13_2 = input.LA(2);
+					int LA12_2 = input.LA(2);

-					if ( (LA13_2=='\"') && (synpred4_ANTLR()))
+					if ( (LA12_2=='\"') && (synpred2_ANTLR()))
{
-						alt13=1;
+						alt12=1;
}
-					else if ( ((LA13_2>='\u0000' && LA13_2<='!')||(LA13_2>='#' && LA13_2<='\uFFFF')) )
+					else if ( ((LA12_2>='\u0000' && LA12_2<='!')||(LA12_2>='#' && LA12_2<='\uFFFF')) )
{
-						alt13=2;
+						alt12=2;
}


}
-				else if ( ((LA13_0>='\u0000' && LA13_0<='!')||(LA13_0>='#' && LA13_0<='[')||(LA13_0>=']' && LA13_0<='\uFFFF')) )
+				else if ( ((LA12_0>='\u0000' && LA12_0<='!')||(LA12_0>='#' && LA12_0<='[')||(LA12_0>=']' && LA12_0<='\uFFFF')) )
{
-					alt13=3;
+					alt12=3;
}


-				switch ( alt13 )
+				switch ( alt12 )
{
case 1:
-					// Grammars\\ANTLR.g3:948:5: => '\\\\' '\"'
+					// Grammars\\ANTLR.g3:940:5: => '\\\\' '\"'
{

Match('\\'); if (state.failed) return ;
@@ -1832,7 +1750,7 @@ public partial class ANTLRLexer : Lexer
}
break;
case 2:
-					// Grammars\\ANTLR.g3:949:5: '\\\\' c=~ '\"'
+					// Grammars\\ANTLR.g3:941:5: '\\\\' c=~ '\"'
{
Match('\\'); if (state.failed) return ;
c= input.LA(1);
@@ -1846,7 +1764,7 @@ public partial class ANTLRLexer : Lexer
}
break;
case 3:
-					// Grammars\\ANTLR.g3:950:5: c=~ ( '\\\\' | '\"' )
+					// Grammars\\ANTLR.g3:942:5: c=~ ( '\\\\' | '\"' )
{
c= input.LA(1);
input.Consume();
@@ -1860,11 +1778,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop13;
+					goto loop12;
}
}

-			loop13:
+			loop12:
;


@@ -1898,74 +1816,54 @@ public partial class ANTLRLexer : Lexer
{
int _type = DOUBLE_ANGLE_STRING_LITERAL;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:959:4: ( '<<' (~ '>' |=> '>' )* '>>' )
-			// Grammars\\ANTLR.g3:959:4: '<<' (~ '>' |=> '>' )* '>>'
+			// Grammars\\ANTLR.g3:951:4: ( '<<' ( . )* '>>' )
+			// Grammars\\ANTLR.g3:951:4: '<<' ( . )* '>>'
{
Match("<<"); if (state.failed) return ;

-			// Grammars\\ANTLR.g3:960:3: (~ '>' |=> '>' )*
+			// Grammars\\ANTLR.g3:951:9: ( . )*
for ( ; ; )
{
-				int alt14=3;
-				int LA14_0 = input.LA(1);
+				int alt13=2;
+				int LA13_0 = input.LA(1);

-				if ( (LA14_0=='>') )
+				if ( (LA13_0=='>') )
{
-					int LA14_1 = input.LA(2);
+					int LA13_1 = input.LA(2);

-					if ( (LA14_1=='>') )
+					if ( (LA13_1=='>') )
{
-						int LA14_3 = input.LA(3);
-
-						if ( (LA14_3=='>') && (synpred5_ANTLR()))
-						{
-							alt14=2;
-						}
-						else if ( ((LA14_3>='\u0000' && LA14_3<='=')||(LA14_3>='?' && LA14_3<='\uFFFF')) && (synpred5_ANTLR()))
-						{
-							alt14=2;
-						}
-
-
+						alt13=2;
}
-					else if ( ((LA14_1>='\u0000' && LA14_1<='=')||(LA14_1>='?' && LA14_1<='\uFFFF')) && (synpred5_ANTLR()))
+					else if ( ((LA13_1>='\u0000' && LA13_1<='=')||(LA13_1>='?' && LA13_1<='\uFFFF')) )
{
-						alt14=2;
+						alt13=1;
}


}
-				else if ( ((LA14_0>='\u0000' && LA14_0<='=')||(LA14_0>='?' && LA14_0<='\uFFFF')) )
+				else if ( ((LA13_0>='\u0000' && LA13_0<='=')||(LA13_0>='?' && LA13_0<='\uFFFF')) )
{
-					alt14=1;
+					alt13=1;
}


-				switch ( alt14 )
+				switch ( alt13 )
{
case 1:
-					// Grammars\\ANTLR.g3:960:5: ~ '>'
-					{
-					input.Consume();
-					state.failed=false;
-
-					}
-					break;
-				case 2:
-					// Grammars\\ANTLR.g3:961:5: => '>'
+					// Grammars\\ANTLR.g3:951:0: .
{
-
-					Match('>'); if (state.failed) return ;
+					MatchAny(); if (state.failed) return ;

}
break;

default:
-					goto loop14;
+					goto loop13;
}
}

-			loop14:
+			loop13:
;


@@ -1988,96 +1886,14 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:969:4: ( '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . ) )
-			// Grammars\\ANTLR.g3:969:4: '\\\\' ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . )
+			// Grammars\\ANTLR.g3:957:4: ( '\\\\' ( . ) )
+			// Grammars\\ANTLR.g3:957:4: '\\\\' ( . )
{
Match('\\'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:970:3: ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . )
-			int alt15=11;
-			alt15 = dfa15.Predict(input);
-			switch ( alt15 )
+			// Grammars\\ANTLR.g3:958:3: ( . )
+			// Grammars\\ANTLR.g3:969:7: .
{
-			case 1:
-				// Grammars\\ANTLR.g3:970:5: 'n'
-				{
-				Match('n'); if (state.failed) return ;
-
-				}
-				break;
-			case 2:
-				// Grammars\\ANTLR.g3:971:5: 'r'
-				{
-				Match('r'); if (state.failed) return ;
-
-				}
-				break;
-			case 3:
-				// Grammars\\ANTLR.g3:972:5: 't'
-				{
-				Match('t'); if (state.failed) return ;
-
-				}
-				break;
-			case 4:
-				// Grammars\\ANTLR.g3:973:5: 'b'
-				{
-				Match('b'); if (state.failed) return ;
-
-				}
-				break;
-			case 5:
-				// Grammars\\ANTLR.g3:974:5: 'f'
-				{
-				Match('f'); if (state.failed) return ;
-
-				}
-				break;
-			case 6:
-				// Grammars\\ANTLR.g3:975:5: '\"'
-				{
-				Match('\"'); if (state.failed) return ;
-
-				}
-				break;
-			case 7:
-				// Grammars\\ANTLR.g3:976:5: '\\''
-				{
-				Match('\''); if (state.failed) return ;
-
-				}
-				break;
-			case 8:
-				// Grammars\\ANTLR.g3:977:5: '\\\\'
-				{
-				Match('\\'); if (state.failed) return ;
-
-				}
-				break;
-			case 9:
-				// Grammars\\ANTLR.g3:978:5: '>'
-				{
-				Match('>'); if (state.failed) return ;
-
-				}
-				break;
-			case 10:
-				// Grammars\\ANTLR.g3:979:5: 'u' XDIGIT XDIGIT XDIGIT XDIGIT
-				{
-				Match('u'); if (state.failed) return ;
-				mXDIGIT(); if (state.failed) return ;
-				mXDIGIT(); if (state.failed) return ;
-				mXDIGIT(); if (state.failed) return ;
-				mXDIGIT(); if (state.failed) return ;
-
-				}
-				break;
-			case 11:
-				// Grammars\\ANTLR.g3:980:5: .
-				{
-				MatchAny(); if (state.failed) return ;
-
-				}
-				break;
+			MatchAny(); if (state.failed) return ;

}

@@ -2096,7 +1912,7 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:986:4: ( '0' .. '9' )
+			// Grammars\\ANTLR.g3:975:4: ( '0' .. '9' )
// Grammars\\ANTLR.g3:
{
if ( (input.LA(1)>='0' && input.LA(1)<='9') )
@@ -2126,7 +1942,7 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:991:4: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
+			// Grammars\\ANTLR.g3:980:4: ( '0' .. '9' | 'a' .. 'f' | 'A' .. 'F' )
// Grammars\\ANTLR.g3:
{
if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='F')||(input.LA(1)>='a' && input.LA(1)<='f') )
@@ -2158,23 +1974,23 @@ public partial class ANTLRLexer : Lexer
{
int _type = INT;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:996:4: ( ( '0' .. '9' )+ )
-			// Grammars\\ANTLR.g3:996:4: ( '0' .. '9' )+
+			// Grammars\\ANTLR.g3:985:4: ( ( '0' .. '9' )+ )
+			// Grammars\\ANTLR.g3:985:4: ( '0' .. '9' )+
{
-			// Grammars\\ANTLR.g3:996:4: ( '0' .. '9' )+
-			int cnt16=0;
+			// Grammars\\ANTLR.g3:985:4: ( '0' .. '9' )+
+			int cnt14=0;
for ( ; ; )
{
-				int alt16=2;
-				int LA16_0 = input.LA(1);
+				int alt14=2;
+				int LA14_0 = input.LA(1);

-				if ( ((LA16_0>='0' && LA16_0<='9')) )
+				if ( ((LA14_0>='0' && LA14_0<='9')) )
{
-					alt16=1;
+					alt14=1;
}


-				switch ( alt16 )
+				switch ( alt14 )
{
case 1:
// Grammars\\ANTLR.g3:
@@ -2186,16 +2002,16 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					if ( cnt16 >= 1 )
-						goto loop16;
+					if ( cnt14 >= 1 )
+						goto loop14;

if (state.backtracking>0) {state.failed=true; return ;}
-					EarlyExitException eee16 = new EarlyExitException( 16, input );
-					throw eee16;
+					EarlyExitException eee14 = new EarlyExitException( 14, input );
+					throw eee14;
}
-				cnt16++;
+				cnt14++;
}
-			loop16:
+			loop14:
;


@@ -2221,8 +2037,8 @@ public partial class ANTLRLexer : Lexer

string text_ = string.Empty;

-			// Grammars\\ANTLR.g3:1004:4: ( '[' NESTED_ARG_ACTION[out text_] ']' )
-			// Grammars\\ANTLR.g3:1004:4: '[' NESTED_ARG_ACTION[out text_] ']'
+			// Grammars\\ANTLR.g3:993:4: ( '[' NESTED_ARG_ACTION[out text_] ']' )
+			// Grammars\\ANTLR.g3:993:4: '[' NESTED_ARG_ACTION[out text_] ']'
{
Match('['); if (state.failed) return ;
mNESTED_ARG_ACTION(out text_); if (state.failed) return ;
@@ -2256,48 +2072,48 @@ public partial class ANTLRLexer : Lexer
text_ = string.Empty;
System.Text.StringBuilder builder = new System.Text.StringBuilder();

-			// Grammars\\ANTLR.g3:1018:4: ( (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )* )
-			// Grammars\\ANTLR.g3:1018:4: (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
+			// Grammars\\ANTLR.g3:1007:4: ( (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )* )
+			// Grammars\\ANTLR.g3:1007:4: (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
{
-			// Grammars\\ANTLR.g3:1018:4: (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
+			// Grammars\\ANTLR.g3:1007:4: (=> '\\\\' ']' | '\\\\' c=~ ( ']' ) | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL |c=~ ( '\\\\' | '\"' | '\\'' | ']' ) )*
for ( ; ; )
{
-				int alt17=6;
-				int LA17_0 = input.LA(1);
+				int alt15=6;
+				int LA15_0 = input.LA(1);

-				if ( (LA17_0=='\\') )
+				if ( (LA15_0=='\\') )
{
-					int LA17_2 = input.LA(2);
+					int LA15_2 = input.LA(2);

-					if ( (LA17_2==']') && (synpred6_ANTLR()))
+					if ( (LA15_2==']') && (synpred3_ANTLR()))
{
-						alt17=1;
+						alt15=1;
}
-					else if ( ((LA17_2>='\u0000' && LA17_2<='\\')||(LA17_2>='^' && LA17_2<='\uFFFF')) )
+					else if ( ((LA15_2>='\u0000' && LA15_2<='\\')||(LA15_2>='^' && LA15_2<='\uFFFF')) )
{
-						alt17=2;
+						alt15=2;
}


}
-				else if ( (LA17_0=='\"') )
+				else if ( (LA15_0=='\"') )
{
-					alt17=3;
+					alt15=3;
}
-				else if ( (LA17_0=='\'') )
+				else if ( (LA15_0=='\'') )
{
-					alt17=4;
+					alt15=4;
}
-				else if ( ((LA17_0>='\u0000' && LA17_0<='!')||(LA17_0>='#' && LA17_0<='&')||(LA17_0>='(' && LA17_0<='[')||(LA17_0>='^' && LA17_0<='\uFFFF')) )
+				else if ( ((LA15_0>='\u0000' && LA15_0<='!')||(LA15_0>='#' && LA15_0<='&')||(LA15_0>='(' && LA15_0<='[')||(LA15_0>='^' && LA15_0<='\uFFFF')) )
{
-					alt17=5;
+					alt15=5;
}


-				switch ( alt17 )
+				switch ( alt15 )
{
case 1:
-					// Grammars\\ANTLR.g3:1018:6: => '\\\\' ']'
+					// Grammars\\ANTLR.g3:1007:6: => '\\\\' ']'
{

Match('\\'); if (state.failed) return ;
@@ -2310,7 +2126,7 @@ public partial class ANTLRLexer : Lexer
}
break;
case 2:
-					// Grammars\\ANTLR.g3:1019:5: '\\\\' c=~ ( ']' )
+					// Grammars\\ANTLR.g3:1008:5: '\\\\' c=~ ( ']' )
{
Match('\\'); if (state.failed) return ;
c= input.LA(1);
@@ -2324,11 +2140,11 @@ public partial class ANTLRLexer : Lexer
}
break;
case 3:
-					// Grammars\\ANTLR.g3:1020:5: ACTION_STRING_LITERAL
+					// Grammars\\ANTLR.g3:1009:5: ACTION_STRING_LITERAL
{
-					int ACTION_STRING_LITERAL1Start993 = GetCharIndex();
+					int ACTION_STRING_LITERAL1Start857 = GetCharIndex();
mACTION_STRING_LITERAL(); if (state.failed) return ;
-					ACTION_STRING_LITERAL1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ACTION_STRING_LITERAL1Start993, GetCharIndex()-1);
+					ACTION_STRING_LITERAL1 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ACTION_STRING_LITERAL1Start857, GetCharIndex()-1);
if ( state.backtracking == 0 )
{
builder.Append((ACTION_STRING_LITERAL1!=null?ACTION_STRING_LITERAL1.Text:null));
@@ -2337,11 +2153,11 @@ public partial class ANTLRLexer : Lexer
}
break;
case 4:
-					// Grammars\\ANTLR.g3:1021:5: ACTION_CHAR_LITERAL
+					// Grammars\\ANTLR.g3:1010:5: ACTION_CHAR_LITERAL
{
-					int ACTION_CHAR_LITERAL2Start1001 = GetCharIndex();
+					int ACTION_CHAR_LITERAL2Start865 = GetCharIndex();
mACTION_CHAR_LITERAL(); if (state.failed) return ;
-					ACTION_CHAR_LITERAL2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ACTION_CHAR_LITERAL2Start1001, GetCharIndex()-1);
+					ACTION_CHAR_LITERAL2 = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, ACTION_CHAR_LITERAL2Start865, GetCharIndex()-1);
if ( state.backtracking == 0 )
{
builder.Append((ACTION_CHAR_LITERAL2!=null?ACTION_CHAR_LITERAL2.Text:null));
@@ -2350,7 +2166,7 @@ public partial class ANTLRLexer : Lexer
}
break;
case 5:
-					// Grammars\\ANTLR.g3:1022:5: c=~ ( '\\\\' | '\"' | '\\'' | ']' )
+					// Grammars\\ANTLR.g3:1011:5: c=~ ( '\\\\' | '\"' | '\\'' | ']' )
{
c= input.LA(1);
input.Consume();
@@ -2364,11 +2180,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop17;
+					goto loop15;
}
}

-			loop17:
+			loop15:
;


@@ -2399,22 +2215,22 @@ public partial class ANTLRLexer : Lexer
int actionLine = Line;
int actionColumn = CharPositionInLine;

-			// Grammars\\ANTLR.g3:1034:4: ( NESTED_ACTION ( '?' )? )
-			// Grammars\\ANTLR.g3:1034:4: NESTED_ACTION ( '?' )?
+			// Grammars\\ANTLR.g3:1023:4: ( NESTED_ACTION ( '?' )? )
+			// Grammars\\ANTLR.g3:1023:4: NESTED_ACTION ( '?' )?
{
mNESTED_ACTION(); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1035:3: ( '?' )?
-			int alt18=2;
-			int LA18_0 = input.LA(1);
+			// Grammars\\ANTLR.g3:1024:3: ( '?' )?
+			int alt16=2;
+			int LA16_0 = input.LA(1);

-			if ( (LA18_0=='?') )
+			if ( (LA16_0=='?') )
{
-				alt18=1;
+				alt16=1;
}
-			switch ( alt18 )
+			switch ( alt16 )
{
case 1:
-				// Grammars\\ANTLR.g3:1035:4: '?'
+				// Grammars\\ANTLR.g3:1024:4: '?'
{
Match('?'); if (state.failed) return ;
if ( state.backtracking == 0 )
@@ -2458,71 +2274,71 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:1052:4: ( '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}' )
-			// Grammars\\ANTLR.g3:1052:4: '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}'
+			// Grammars\\ANTLR.g3:1041:4: ( '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}' )
+			// Grammars\\ANTLR.g3:1041:4: '{' ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )* '}'
{
Match('{'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1053:3: ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )*
+			// Grammars\\ANTLR.g3:1042:3: ( NESTED_ACTION | ACTION_CHAR_LITERAL |=> COMMENT | ACTION_STRING_LITERAL | ACTION_ESC |~ ( '{' | '\\'' | '\"' | '\\\\' | '}' ) )*
for ( ; ; )
{
-				int alt19=7;
-				int LA19_0 = input.LA(1);
+				int alt17=7;
+				int LA17_0 = input.LA(1);

-				if ( (LA19_0=='{') )
+				if ( (LA17_0=='{') )
{
-					alt19=1;
+					alt17=1;
}
-				else if ( (LA19_0=='\'') )
+				else if ( (LA17_0=='\'') )
{
-					alt19=2;
+					alt17=2;
}
-				else if ( (LA19_0=='/') )
+				else if ( (LA17_0=='/') )
{
-					int LA19_4 = input.LA(2);
+					int LA17_4 = input.LA(2);

-					if ( (synpred7_ANTLR()) )
+					if ( (synpred4_ANTLR()) )
{
-						alt19=3;
+						alt17=3;
}
else if ( (true) )
{
-						alt19=6;
+						alt17=6;
}


}
-				else if ( (LA19_0=='\"') )
+				else if ( (LA17_0=='\"') )
{
-					alt19=4;
+					alt17=4;
}
-				else if ( (LA19_0=='\\') )
+				else if ( (LA17_0=='\\') )
{
-					alt19=5;
+					alt17=5;
}
-				else if ( ((LA19_0>='\u0000' && LA19_0<='!')||(LA19_0>='#' && LA19_0<='&')||(LA19_0>='(' && LA19_0<='.')||(LA19_0>='0' && LA19_0<='[')||(LA19_0>=']' && LA19_0<='z')||LA19_0=='|'||(LA19_0>='~' && LA19_0<='\uFFFF')) )
+				else if ( ((LA17_0>='\u0000' && LA17_0<='!')||(LA17_0>='#' && LA17_0<='&')||(LA17_0>='(' && LA17_0<='.')||(LA17_0>='0' && LA17_0<='[')||(LA17_0>=']' && LA17_0<='z')||LA17_0=='|'||(LA17_0>='~' && LA17_0<='\uFFFF')) )
{
-					alt19=6;
+					alt17=6;
}


-				switch ( alt19 )
+				switch ( alt17 )
{
case 1:
-					// Grammars\\ANTLR.g3:1053:5: NESTED_ACTION
+					// Grammars\\ANTLR.g3:1042:5: NESTED_ACTION
{
mNESTED_ACTION(); if (state.failed) return ;

}
break;
case 2:
-					// Grammars\\ANTLR.g3:1054:5: ACTION_CHAR_LITERAL
+					// Grammars\\ANTLR.g3:1043:5: ACTION_CHAR_LITERAL
{
mACTION_CHAR_LITERAL(); if (state.failed) return ;

}
break;
case 3:
-					// Grammars\\ANTLR.g3:1055:5: => COMMENT
+					// Grammars\\ANTLR.g3:1044:5: => COMMENT
{

mCOMMENT(); if (state.failed) return ;
@@ -2530,21 +2346,21 @@ public partial class ANTLRLexer : Lexer
}
break;
case 4:
-					// Grammars\\ANTLR.g3:1056:5: ACTION_STRING_LITERAL
+					// Grammars\\ANTLR.g3:1045:5: ACTION_STRING_LITERAL
{
mACTION_STRING_LITERAL(); if (state.failed) return ;

}
break;
case 5:
-					// Grammars\\ANTLR.g3:1057:5: ACTION_ESC
+					// Grammars\\ANTLR.g3:1046:5: ACTION_ESC
{
mACTION_ESC(); if (state.failed) return ;

}
break;
case 6:
-					// Grammars\\ANTLR.g3:1058:5: ~ ( '{' | '\\'' | '\"' | '\\\\' | '}' )
+					// Grammars\\ANTLR.g3:1047:5: ~ ( '{' | '\\'' | '\"' | '\\\\' | '}' )
{
input.Consume();
state.failed=false;
@@ -2553,11 +2369,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop19;
+					goto loop17;
}
}

-			loop19:
+			loop17:
;


@@ -2577,37 +2393,37 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:1065:4: ( '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
-			// Grammars\\ANTLR.g3:1065:4: '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\''
+			// Grammars\\ANTLR.g3:1054:4: ( '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\'' )
+			// Grammars\\ANTLR.g3:1054:4: '\\'' ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )* '\\''
{
Match('\''); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1066:3: ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )*
+			// Grammars\\ANTLR.g3:1055:3: ( ACTION_ESC |~ ( '\\\\' | '\\'' ) )*
for ( ; ; )
{
-				int alt20=3;
-				int LA20_0 = input.LA(1);
+				int alt18=3;
+				int LA18_0 = input.LA(1);

-				if ( (LA20_0=='\\') )
+				if ( (LA18_0=='\\') )
{
-					alt20=1;
+					alt18=1;
}
-				else if ( ((LA20_0>='\u0000' && LA20_0<='&')||(LA20_0>='(' && LA20_0<='[')||(LA20_0>=']' && LA20_0<='\uFFFF')) )
+				else if ( ((LA18_0>='\u0000' && LA18_0<='&')||(LA18_0>='(' && LA18_0<='[')||(LA18_0>=']' && LA18_0<='\uFFFF')) )
{
-					alt20=2;
+					alt18=2;
}


-				switch ( alt20 )
+				switch ( alt18 )
{
case 1:
-					// Grammars\\ANTLR.g3:1066:5: ACTION_ESC
+					// Grammars\\ANTLR.g3:1055:5: ACTION_ESC
{
mACTION_ESC(); if (state.failed) return ;

}
break;
case 2:
-					// Grammars\\ANTLR.g3:1067:5: ~ ( '\\\\' | '\\'' )
+					// Grammars\\ANTLR.g3:1056:5: ~ ( '\\\\' | '\\'' )
{
input.Consume();
state.failed=false;
@@ -2616,11 +2432,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop20;
+					goto loop18;
}
}

-			loop20:
+			loop18:
;


@@ -2640,37 +2456,37 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:1074:4: ( '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"' )
-			// Grammars\\ANTLR.g3:1074:4: '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"'
+			// Grammars\\ANTLR.g3:1063:4: ( '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"' )
+			// Grammars\\ANTLR.g3:1063:4: '\"' ( ACTION_ESC |~ ( '\\\\' | '\"' ) )* '\"'
{
Match('\"'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1075:3: ( ACTION_ESC |~ ( '\\\\' | '\"' ) )*
+			// Grammars\\ANTLR.g3:1064:3: ( ACTION_ESC |~ ( '\\\\' | '\"' ) )*
for ( ; ; )
{
-				int alt21=3;
-				int LA21_0 = input.LA(1);
+				int alt19=3;
+				int LA19_0 = input.LA(1);

-				if ( (LA21_0=='\\') )
+				if ( (LA19_0=='\\') )
{
-					alt21=1;
+					alt19=1;
}
-				else if ( ((LA21_0>='\u0000' && LA21_0<='!')||(LA21_0>='#' && LA21_0<='[')||(LA21_0>=']' && LA21_0<='\uFFFF')) )
+				else if ( ((LA19_0>='\u0000' && LA19_0<='!')||(LA19_0>='#' && LA19_0<='[')||(LA19_0>=']' && LA19_0<='\uFFFF')) )
{
-					alt21=2;
+					alt19=2;
}


-				switch ( alt21 )
+				switch ( alt19 )
{
case 1:
-					// Grammars\\ANTLR.g3:1075:5: ACTION_ESC
+					// Grammars\\ANTLR.g3:1064:5: ACTION_ESC
{
mACTION_ESC(); if (state.failed) return ;

}
break;
case 2:
-					// Grammars\\ANTLR.g3:1076:5: ~ ( '\\\\' | '\"' )
+					// Grammars\\ANTLR.g3:1065:5: ~ ( '\\\\' | '\"' )
{
input.Consume();
state.failed=false;
@@ -2679,11 +2495,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop21;
+					goto loop19;
}
}

-			loop21:
+			loop19:
;


@@ -2703,30 +2519,30 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:1083:4: ( '\\\\\\'' | '\\\\\\\"' | '\\\\' ~ ( '\\'' | '\"' ) )
-			int alt22=3;
-			int LA22_0 = input.LA(1);
+			// Grammars\\ANTLR.g3:1072:4: ( '\\\\\\'' | '\\\\\\\"' | '\\\\' ~ ( '\\'' | '\"' ) )
+			int alt20=3;
+			int LA20_0 = input.LA(1);

-			if ( (LA22_0=='\\') )
+			if ( (LA20_0=='\\') )
{
-				int LA22_1 = input.LA(2);
+				int LA20_1 = input.LA(2);

-				if ( (LA22_1=='\'') )
+				if ( (LA20_1=='\'') )
{
-					alt22=1;
+					alt20=1;
}
-				else if ( (LA22_1=='\"') )
+				else if ( (LA20_1=='\"') )
{
-					alt22=2;
+					alt20=2;
}
-				else if ( ((LA22_1>='\u0000' && LA22_1<='!')||(LA22_1>='#' && LA22_1<='&')||(LA22_1>='(' && LA22_1<='\uFFFF')) )
+				else if ( ((LA20_1>='\u0000' && LA20_1<='!')||(LA20_1>='#' && LA20_1<='&')||(LA20_1>='(' && LA20_1<='\uFFFF')) )
{
-					alt22=3;
+					alt20=3;
}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-					NoViableAltException nvae = new NoViableAltException("", 22, 1, input);
+					NoViableAltException nvae = new NoViableAltException("", 20, 1, input);

throw nvae;
}
@@ -2734,14 +2550,14 @@ public partial class ANTLRLexer : Lexer
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 22, 0, input);
+				NoViableAltException nvae = new NoViableAltException("", 20, 0, input);

throw nvae;
}
-			switch ( alt22 )
+			switch ( alt20 )
{
case 1:
-				// Grammars\\ANTLR.g3:1083:4: '\\\\\\''
+				// Grammars\\ANTLR.g3:1072:4: '\\\\\\''
{
Match("\\'"); if (state.failed) return ;

@@ -2749,7 +2565,7 @@ public partial class ANTLRLexer : Lexer
}
break;
case 2:
-				// Grammars\\ANTLR.g3:1084:4: '\\\\\\\"'
+				// Grammars\\ANTLR.g3:1073:4: '\\\\\\\"'
{
Match("\\\""); if (state.failed) return ;

@@ -2757,7 +2573,7 @@ public partial class ANTLRLexer : Lexer
}
break;
case 3:
-				// Grammars\\ANTLR.g3:1085:4: '\\\\' ~ ( '\\'' | '\"' )
+				// Grammars\\ANTLR.g3:1074:4: '\\\\' ~ ( '\\'' | '\"' )
{
Match('\\'); if (state.failed) return ;
input.Consume();
@@ -2781,23 +2597,23 @@ public partial class ANTLRLexer : Lexer
{
int _type = TOKEN_REF;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:1088:4: ( 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
-			// Grammars\\ANTLR.g3:1088:4: 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			// Grammars\\ANTLR.g3:1077:4: ( 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// Grammars\\ANTLR.g3:1077:4: 'A' .. 'Z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
{
MatchRange('A','Z'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1089:3: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			// Grammars\\ANTLR.g3:1078:3: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
for ( ; ; )
{
-				int alt23=2;
-				int LA23_0 = input.LA(1);
+				int alt21=2;
+				int LA21_0 = input.LA(1);

-				if ( ((LA23_0>='0' && LA23_0<='9')||(LA23_0>='A' && LA23_0<='Z')||LA23_0=='_'||(LA23_0>='a' && LA23_0<='z')) )
+				if ( ((LA21_0>='0' && LA21_0<='9')||(LA21_0>='A' && LA21_0<='Z')||LA21_0=='_'||(LA21_0>='a' && LA21_0<='z')) )
{
-					alt23=1;
+					alt21=1;
}


-				switch ( alt23 )
+				switch ( alt21 )
{
case 1:
// Grammars\\ANTLR.g3:
@@ -2809,11 +2625,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop23;
+					goto loop21;
}
}

-			loop23:
+			loop21:
;


@@ -2836,8 +2652,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = TOKENS;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:1094:4: ( 'tokens' WS_LOOP '{' )
-			// Grammars\\ANTLR.g3:1094:4: 'tokens' WS_LOOP '{'
+			// Grammars\\ANTLR.g3:1083:4: ( 'tokens' WS_LOOP '{' )
+			// Grammars\\ANTLR.g3:1083:4: 'tokens' WS_LOOP '{'
{
Match("tokens"); if (state.failed) return ;

@@ -2862,8 +2678,8 @@ public partial class ANTLRLexer : Lexer
{
int _type = OPTIONS;
int _channel = DEFAULT_TOKEN_CHANNEL;
-			// Grammars\\ANTLR.g3:1098:4: ( 'options' WS_LOOP '{' )
-			// Grammars\\ANTLR.g3:1098:4: 'options' WS_LOOP '{'
+			// Grammars\\ANTLR.g3:1087:4: ( 'options' WS_LOOP '{' )
+			// Grammars\\ANTLR.g3:1087:4: 'options' WS_LOOP '{'
{
Match("options"); if (state.failed) return ;

@@ -2891,23 +2707,23 @@ public partial class ANTLRLexer : Lexer

int t=0;

-			// Grammars\\ANTLR.g3:1107:4: ( 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
-			// Grammars\\ANTLR.g3:1107:4: 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			// Grammars\\ANTLR.g3:1096:4: ( 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* )
+			// Grammars\\ANTLR.g3:1096:4: 'a' .. 'z' ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
{
MatchRange('a','z'); if (state.failed) return ;
-			// Grammars\\ANTLR.g3:1107:13: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
+			// Grammars\\ANTLR.g3:1096:13: ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )*
for ( ; ; )
{
-				int alt24=2;
-				int LA24_0 = input.LA(1);
+				int alt22=2;
+				int LA22_0 = input.LA(1);

-				if ( ((LA24_0>='0' && LA24_0<='9')||(LA24_0>='A' && LA24_0<='Z')||LA24_0=='_'||(LA24_0>='a' && LA24_0<='z')) )
+				if ( ((LA22_0>='0' && LA22_0<='9')||(LA22_0>='A' && LA22_0<='Z')||LA22_0=='_'||(LA22_0>='a' && LA22_0<='z')) )
{
-					alt24=1;
+					alt22=1;
}


-				switch ( alt24 )
+				switch ( alt22 )
{
case 1:
// Grammars\\ANTLR.g3:
@@ -2919,11 +2735,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop24;
+					goto loop22;
}
}

-			loop24:
+			loop22:
;


@@ -2944,36 +2760,36 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:1113:4: ( ( WS | COMMENT )* )
-			// Grammars\\ANTLR.g3:1113:4: ( WS | COMMENT )*
+			// Grammars\\ANTLR.g3:1102:4: ( ( WS | COMMENT )* )
+			// Grammars\\ANTLR.g3:1102:4: ( WS | COMMENT )*
{
-			// Grammars\\ANTLR.g3:1113:4: ( WS | COMMENT )*
+			// Grammars\\ANTLR.g3:1102:4: ( WS | COMMENT )*
for ( ; ; )
{
-				int alt25=3;
-				int LA25_0 = input.LA(1);
+				int alt23=3;
+				int LA23_0 = input.LA(1);

-				if ( ((LA25_0>='\t' && LA25_0<='\n')||LA25_0=='\r'||LA25_0==' ') )
+				if ( ((LA23_0>='\t' && LA23_0<='\n')||LA23_0=='\r'||LA23_0==' ') )
{
-					alt25=1;
+					alt23=1;
}
-				else if ( (LA25_0=='/') )
+				else if ( (LA23_0=='/') )
{
-					alt25=2;
+					alt23=2;
}


-				switch ( alt25 )
+				switch ( alt23 )
{
case 1:
-					// Grammars\\ANTLR.g3:1113:6: WS
+					// Grammars\\ANTLR.g3:1102:6: WS
{
mWS(); if (state.failed) return ;

}
break;
case 2:
-					// Grammars\\ANTLR.g3:1114:5: COMMENT
+					// Grammars\\ANTLR.g3:1103:5: COMMENT
{
mCOMMENT(); if (state.failed) return ;

@@ -2981,11 +2797,11 @@ public partial class ANTLRLexer : Lexer
break;

default:
-					goto loop25;
+					goto loop23;
}
}

-			loop25:
+			loop23:
;


@@ -3004,21 +2820,21 @@ public partial class ANTLRLexer : Lexer
{
try
{
-			// Grammars\\ANTLR.g3:1120:4: ( ( WS )? )
-			// Grammars\\ANTLR.g3:1120:4: ( WS )?
+			// Grammars\\ANTLR.g3:1109:4: ( ( WS )? )
+			// Grammars\\ANTLR.g3:1109:4: ( WS )?
{
-			// Grammars\\ANTLR.g3:1120:4: ( WS )?
-			int alt26=2;
-			int LA26_0 = input.LA(1);
+			// Grammars\\ANTLR.g3:1109:4: ( WS )?
+			int alt24=2;
+			int LA24_0 = input.LA(1);

-			if ( ((LA26_0>='\t' && LA26_0<='\n')||LA26_0=='\r'||LA26_0==' ') )
+			if ( ((LA24_0>='\t' && LA24_0<='\n')||LA24_0=='\r'||LA24_0==' ') )
{
-				alt26=1;
+				alt24=1;
}
-			switch ( alt26 )
+			switch ( alt24 )
{
case 1:
-				// Grammars\\ANTLR.g3:1120:5: WS
+				// Grammars\\ANTLR.g3:1109:5: WS
{
mWS(); if (state.failed) return ;

@@ -3045,19 +2861,19 @@ public partial class ANTLRLexer : Lexer
IToken file=null;
IToken line=null;

-			// Grammars\\ANTLR.g3:1133:4: ( 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT )
-			// Grammars\\ANTLR.g3:1133:4: 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT
+			// Grammars\\ANTLR.g3:1122:4: ( 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT )
+			// Grammars\\ANTLR.g3:1122:4: 'src' ' ' file= ACTION_STRING_LITERAL ' ' line= INT
{
Match("src"); if (state.failed) return ;

Match(' '); if (state.failed) return ;
-			int fileStart1406 = GetCharIndex();
+			int fileStart1270 = GetCharIndex();
mACTION_STRING_LITERAL(); if (state.failed) return ;
-			file = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, fileStart1406, GetCharIndex()-1);
+			file = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, fileStart1270, GetCharIndex()-1);
Match(' '); if (state.failed) return ;
-			int lineStart1412 = GetCharIndex();
+			int lineStart1276 = GetCharIndex();
mINT(); if (state.failed) return ;
-			line = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, lineStart1412, GetCharIndex()-1);
+			line = new CommonToken(input, TokenConstants.INVALID_TOKEN_TYPE, TokenConstants.DEFAULT_CHANNEL, lineStart1276, GetCharIndex()-1);
if ( state.backtracking == 0 )
{

@@ -3078,9 +2894,9 @@ public partial class ANTLRLexer : Lexer
public override void mTokens()
{
// Grammars\\ANTLR.g3:1:10: ( CATCH | FINALLY | FRAGMENT | GRAMMAR | IMPORT | LEXER | PARSER | PRIVATE | PROTECTED | PUBLIC | RETURNS | SCOPE | THROWS | TREE | WS | COMMENT | OPEN_ELEMENT_OPTION | CLOSE_ELEMENT_OPTION | AMPERSAND | COMMA | QUESTION | TREE_BEGIN | LPAREN | RPAREN | COLON | STAR | PLUS | ASSIGN | PLUS_ASSIGN | IMPLIES | REWRITE | SEMI | ROOT | BANG | OR | WILDCARD | ETC | RANGE | NOT | RCURLY | DOLLAR | STRAY_BRACKET | CHAR_LITERAL | DOUBLE_QUOTE_STRING_LITERAL | DOUBLE_ANGLE_STRING_LITERAL | INT | ARG_ACTION | ACTION | TOKEN_REF | TOKENS | OPTIONS | RULE_REF )
-		int alt27=52;
-		alt27 = dfa27.Predict(input);
-		switch ( alt27 )
+		int alt25=52;
+		alt25 = dfa25.Predict(input);
+		switch ( alt25 )
{
case 1:
// Grammars\\ANTLR.g3:1:10: CATCH
@@ -3467,21 +3283,10 @@ public partial class ANTLRLexer : Lexer
// $ANTLR start synpred2_ANTLR
public void synpred2_ANTLR_fragment()
{
-		// Grammars\\ANTLR.g3:853:5: ( '*' ~ '/' )
-		// Grammars\\ANTLR.g3:853:6: '*' ~ '/'
-		{
-		Match('*'); if (state.failed) return ;
-		if ( (input.LA(1)>='\u0000' && input.LA(1)<='.')||(input.LA(1)>='0' && input.LA(1)<='\uFFFF') )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
+		// Grammars\\ANTLR.g3:940:5: ( '\\\\\\\"' )
+		// Grammars\\ANTLR.g3:940:6: '\\\\\\\"'
{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
+		Match("\\\""); if (state.failed) return ;


}
@@ -3491,21 +3296,10 @@ public partial class ANTLRLexer : Lexer
// $ANTLR start synpred3_ANTLR
public void synpred3_ANTLR_fragment()
{
-		// Grammars\\ANTLR.g3:856:5: ( '*' ~ '/' )
-		// Grammars\\ANTLR.g3:856:6: '*' ~ '/'
+		// Grammars\\ANTLR.g3:1007:6: ( '\\\\]' )
+		// Grammars\\ANTLR.g3:1007:7: '\\\\]'
{
-		Match('*'); if (state.failed) return ;
-		if ( (input.LA(1)>='\u0000' && input.LA(1)<='.')||(input.LA(1)>='0' && input.LA(1)<='\uFFFF') )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
+		Match("\\]"); if (state.failed) return ;


}
@@ -3515,76 +3309,26 @@ public partial class ANTLRLexer : Lexer
// $ANTLR start synpred4_ANTLR
public void synpred4_ANTLR_fragment()
{
-		// Grammars\\ANTLR.g3:948:5: ( '\\\\\\\"' )
-		// Grammars\\ANTLR.g3:948:6: '\\\\\\\"'
-		{
-		Match("\\\""); if (state.failed) return ;
+		// Grammars\\ANTLR.g3:1044:5: ( '//' | '/*' )
+		int alt26=2;
+		int LA26_0 = input.LA(1);

-
-		}
-	}
-	// $ANTLR end synpred4_ANTLR
-
-	// $ANTLR start synpred5_ANTLR
-	public void synpred5_ANTLR_fragment()
-	{
-		// Grammars\\ANTLR.g3:961:5: ( '>' ~ '>' )
-		// Grammars\\ANTLR.g3:961:6: '>' ~ '>'
+		if ( (LA26_0=='/') )
{
-		Match('>'); if (state.failed) return ;
-		if ( (input.LA(1)>='\u0000' && input.LA(1)<='=')||(input.LA(1)>='?' && input.LA(1)<='\uFFFF') )
-		{
-			input.Consume();
-		state.failed=false;
-		}
-		else
-		{
-			if (state.backtracking>0) {state.failed=true; return ;}
-			MismatchedSetException mse = new MismatchedSetException(null,input);
-			Recover(mse);
-			throw mse;}
+			int LA26_1 = input.LA(2);

-
-		}
-	}
-	// $ANTLR end synpred5_ANTLR
-
-	// $ANTLR start synpred6_ANTLR
-	public void synpred6_ANTLR_fragment()
-	{
-		// Grammars\\ANTLR.g3:1018:6: ( '\\\\]' )
-		// Grammars\\ANTLR.g3:1018:7: '\\\\]'
-		{
-		Match("\\]"); if (state.failed) return ;
-
-
-		}
-	}
-	// $ANTLR end synpred6_ANTLR
-
-	// $ANTLR start synpred7_ANTLR
-	public void synpred7_ANTLR_fragment()
-	{
-		// Grammars\\ANTLR.g3:1055:5: ( '//' | '/*' )
-		int alt28=2;
-		int LA28_0 = input.LA(1);
-
-		if ( (LA28_0=='/') )
-		{
-			int LA28_1 = input.LA(2);
-
-			if ( (LA28_1=='/') )
+			if ( (LA26_1=='/') )
{
-				alt28=1;
+				alt26=1;
}
-			else if ( (LA28_1=='*') )
+			else if ( (LA26_1=='*') )
{
-				alt28=2;
+				alt26=2;
}
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-				NoViableAltException nvae = new NoViableAltException("", 28, 1, input);
+				NoViableAltException nvae = new NoViableAltException("", 26, 1, input);

throw nvae;
}
@@ -3592,14 +3336,14 @@ public partial class ANTLRLexer : Lexer
else
{
if (state.backtracking>0) {state.failed=true; return ;}
-			NoViableAltException nvae = new NoViableAltException("", 28, 0, input);
+			NoViableAltException nvae = new NoViableAltException("", 26, 0, input);

throw nvae;
}
-		switch ( alt28 )
+		switch ( alt26 )
{
case 1:
-			// Grammars\\ANTLR.g3:1055:6: '//'
+			// Grammars\\ANTLR.g3:1044:6: '//'
{
Match("//"); if (state.failed) return ;

@@ -3607,7 +3351,7 @@ public partial class ANTLRLexer : Lexer
}
break;
case 2:
-			// Grammars\\ANTLR.g3:1055:13: '/*'
+			// Grammars\\ANTLR.g3:1044:13: '/*'
{
Match("/*"); if (state.failed) return ;

@@ -3616,7 +3360,7 @@ public partial class ANTLRLexer : Lexer
break;

}}
-	// $ANTLR end synpred7_ANTLR
+	// $ANTLR end synpred4_ANTLR

public bool synpred1_ANTLR()
{
@@ -3690,73 +3434,17 @@ public partial class ANTLRLexer : Lexer
state.failed=false;
return success;
}
-	public bool synpred5_ANTLR()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred5_ANTLR_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred6_ANTLR()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred6_ANTLR_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}
-	public bool synpred7_ANTLR()
-	{
-		state.backtracking++;
-		int start = input.Mark();
-		try
-		{
-			synpred7_ANTLR_fragment(); // can never throw exception
-		}
-		catch ( RecognitionException re )
-		{
-			System.Console.Error.WriteLine("impossible: "+re);
-		}
-		bool success = !state.failed;
-		input.Rewind(start);
-		state.backtracking--;
-		state.failed=false;
-		return success;
-	}


#region DFA
DFA9 dfa9;
-	DFA15 dfa15;
-	DFA27 dfa27;
+	DFA25 dfa25;

protected override void InitDFAs()
{
base.InitDFAs();
dfa9 = new DFA9( this, new SpecialStateTransitionHandler( specialStateTransition9 ) );
-		dfa15 = new DFA15( this, new SpecialStateTransitionHandler( specialStateTransition15 ) );
-		dfa27 = new DFA27( this );
+		dfa25 = new DFA25( this );
}

class DFA9 : DFA
@@ -4072,121 +3760,10 @@ public partial class ANTLRLexer : Lexer
dfa.Error(nvae);
throw nvae;
}
-	class DFA15 : DFA
-	{
-
-		const string DFA15_eotS =
-			"\xA\xFFFF\x1\xB\x2\xFFFF";
-		const string DFA15_eofS =
-			"\xD\xFFFF";
-		const string DFA15_minS =
-			"\x1\x0\x9\xFFFF\x1\x30\x2\xFFFF";
-		const string DFA15_maxS =
-			"\x1\xFFFF\x9\xFFFF\x1\x66\x2\xFFFF";
-		const string DFA15_acceptS =
-			"\x1\xFFFF\x1\x1\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1\x8\x1\x9\x1\xFFFF"+
-			"\x1\xB\x1\xA";
-		const string DFA15_specialS =
-			"\x1\x0\xC\xFFFF}>";
-		static readonly string[] DFA15_transitionS =
-			{
-				"\x22\xB\x1\x6\x4\xB\x1\x7\x16\xB\x1\x9\x1D\xB\x1\x8\x5\xB\x1\x4\x3\xB"+
-				"\x1\x5\x7\xB\x1\x1\x3\xB\x1\x2\x1\xB\x1\x3\x1\xA\xFF8A\xB",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"",
-				"\xA\xC\x7\xFFFF\x6\xC\x1A\xFFFF\x6\xC",
-				"",
-				""
-			};
-
-		static readonly short[] DFA15_eot = DFA.UnpackEncodedString(DFA15_eotS);
-		static readonly short[] DFA15_eof = DFA.UnpackEncodedString(DFA15_eofS);
-		static readonly char[] DFA15_min = DFA.UnpackEncodedStringToUnsignedChars(DFA15_minS);
-		static readonly char[] DFA15_max = DFA.UnpackEncodedStringToUnsignedChars(DFA15_maxS);
-		static readonly short[] DFA15_accept = DFA.UnpackEncodedString(DFA15_acceptS);
-		static readonly short[] DFA15_special = DFA.UnpackEncodedString(DFA15_specialS);
-		static readonly short[][] DFA15_transition;
-
-		static DFA15()
-		{
-			int numStates = DFA15_transitionS.Length;
-			DFA15_transition = new short[numStates][];
-			for ( int i=0; i < numStates; i++ )
-			{
-				DFA15_transition[i] = DFA.UnpackEncodedString(DFA15_transitionS[i]);
-			}
-		}
-
-		public DFA15( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
-			: base( specialStateTransition )	{
-			this.recognizer = recognizer;
-			this.decisionNumber = 15;
-			this.eot = DFA15_eot;
-			this.eof = DFA15_eof;
-			this.min = DFA15_min;
-			this.max = DFA15_max;
-			this.accept = DFA15_accept;
-			this.special = DFA15_special;
-			this.transition = DFA15_transition;
-		}
-		public override string GetDescription()
-		{
-			return "970:3: ( 'n' | 'r' | 't' | 'b' | 'f' | '\"' | '\\'' | '\\\\' | '>' | 'u' XDIGIT XDIGIT XDIGIT XDIGIT | . )";
-		}
-	}
-
-	int specialStateTransition15( DFA dfa, int s, IIntStream _input )
-	{
-		IIntStream input = _input;
-		int _s = s;
-		switch ( s )
-		{
-
-			case 0:
-				int LA15_0 = input.LA(1);
-
-				s = -1;
-				if ( (LA15_0=='n') ) {s = 1;}
-
-				else if ( (LA15_0=='r') ) {s = 2;}
-
-				else if ( (LA15_0=='t') ) {s = 3;}
-
-				else if ( (LA15_0=='b') ) {s = 4;}
-
-				else if ( (LA15_0=='f') ) {s = 5;}
-
-				else if ( (LA15_0=='\"') ) {s = 6;}
-
-				else if ( (LA15_0=='\'') ) {s = 7;}
-
-				else if ( (LA15_0=='\\') ) {s = 8;}
-
-				else if ( (LA15_0=='>') ) {s = 9;}
-
-				else if ( (LA15_0=='u') ) {s = 10;}
-
-				else if ( ((LA15_0>='\u0000' && LA15_0<='!')||(LA15_0>='#' && LA15_0<='&')||(LA15_0>='(' && LA15_0<='=')||(LA15_0>='?' && LA15_0<='[')||(LA15_0>=']' && LA15_0<='a')||(LA15_0>='c' && LA15_0<='e')||(LA15_0>='g' && LA15_0<='m')||(LA15_0>='o' && LA15_0<='q')||LA15_0=='s'||(LA15_0>='v' && LA15_0<='\uFFFF')) ) {s = 11;}
-
-				if ( s>=0 ) return s;
-				break;
-		}
-		if (state.backtracking>0) {state.failed=true; return -1;}
-		NoViableAltException nvae = new NoViableAltException(dfa.GetDescription(), 15, _s, input);
-		dfa.Error(nvae);
-		throw nvae;
-	}
-	class DFA27 : DFA
+	class DFA25 : DFA
{

-		const string DFA27_eotS =
+		const string DFA25_eotS =
"\x1\xFFFF\x9\x28\x2\xFFFF\x1\x38\x4\xFFFF\x1\x3A\x4\xFFFF\x1\x3C\x1\x3E"+
"\x4\xFFFF\x1\x40\xA\xFFFF\x1\x28\x1\xFFFF\xE\x28\x8\xFFFF\x1\x52\x1\xFFFF"+
"\x10\x28\x2\xFFFF\xE\x28\x1\x71\x2\x28\x1\x74\x4\x28\x1\x79\x5\x28\x1"+
@@ -4194,9 +3771,9 @@ public partial class ANTLRLexer : Lexer
"\x28\x1\x8A\x1\x28\x1\xFFFF\x1\x8C\x2\x28\x1\x8F\x1\x28\x1\x91\x2\xFFFF"+
"\x1\x92\x1\x28\x1\xFFFF\x1\x94\x2\xFFFF\x1\x28\x1\xFFFF\x1\x96\x2\xFFFF"+
"\x1\x28\x3\xFFFF\x1\x98\x1\xFFFF";
-		const string DFA27_eofS =
+		const string DFA25_eofS =
"\x99\xFFFF";
-		const string DFA27_minS =
+		const string DFA25_minS =
"\x1\x9\x1\x61\x1\x69\x1\x72\x1\x6D\x1\x65\x1\x61\x1\x65\x1\x63\x1\x68"+
"\x2\xFFFF\x1\x3C\x4\xFFFF\x1\x28\x4\xFFFF\x1\x3D\x1\x3E\x4\xFFFF\x1\x2E"+
"\xA\xFFFF\x1\x70\x1\xFFFF\x1\x74\x1\x6E\x2\x61\x1\x70\x1\x78\x1\x72\x1"+
@@ -4210,7 +3787,7 @@ public partial class ANTLRLexer : Lexer
"\x30\x1\x9\x1\x73\x1\x30\x1\x74\x1\x30\x2\xFFFF\x1\x30\x1\x65\x1\xFFFF"+
"\x1\x30\x2\xFFFF\x1\x9\x1\xFFFF\x1\x30\x2\xFFFF\x1\x64\x3\xFFFF\x1\x30"+
"\x1\xFFFF";
-		const string DFA27_maxS =
+		const string DFA25_maxS =
"\x1\x7E\x1\x61\x2\x72\x1\x6D\x1\x65\x1\x75\x1\x65\x1\x63\x1\x72\x2\xFFFF"+
"\x1\x3C\x4\xFFFF\x1\x28\x4\xFFFF\x1\x3D\x1\x3E\x4\xFFFF\x1\x2E\xA\xFFFF"+
"\x1\x70\x1\xFFFF\x1\x74\x1\x6E\x2\x61\x1\x70\x1\x78\x1\x72\x1\x6F\x1"+
@@ -4223,7 +3800,7 @@ public partial class ANTLRLexer : Lexer
"\x1\x7A\x1\xFFFF\x1\x7A\x1\x65\x1\x74\x1\x7A\x1\x73\x1\xFFFF\x1\x7A\x1"+
"\x7B\x1\x73\x1\x7A\x1\x74\x1\x7A\x2\xFFFF\x1\x7A\x1\x65\x1\xFFFF\x1\x7A"+
"\x2\xFFFF\x1\x7B\x1\xFFFF\x1\x7A\x2\xFFFF\x1\x64\x3\xFFFF\x1\x7A\x1\xFFFF";
-		const string DFA27_acceptS =
+		const string DFA25_acceptS =
"\xA\xFFFF\x1\xF\x1\x10\x1\xFFFF\x1\x12\x1\x13\x1\x14\x1\x15\x1\xFFFF"+
"\x1\x17\x1\x18\x1\x19\x1\x1A\x2\xFFFF\x1\x1F\x1\x20\x1\x22\x1\x23\x1"+
"\xFFFF\x1\x27\x1\x28\x1\x29\x1\x2A\x1\x2B\x1\x2C\x1\x2E\x1\x2F\x1\x30"+
@@ -4232,9 +3809,9 @@ public partial class ANTLRLexer : Lexer
"\x1\xE\x2\xFFFF\x1\x1\x4\xFFFF\x1\x6\x5\xFFFF\x1\xC\x6\xFFFF\x1\x5\x1"+
"\x7\x2\xFFFF\x1\xA\x1\xFFFF\x1\xD\x1\x32\x1\xFFFF\x1\x2\x1\xFFFF\x1\x4"+
"\x1\x8\x1\xFFFF\x1\xB\x1\x33\x1\x3\x1\xFFFF\x1\x9";
-		const string DFA27_specialS =
+		const string DFA25_specialS =
"\x99\xFFFF}>";
-		static readonly string[] DFA27_transitionS =
+		static readonly string[] DFA25_transitionS =
{
"\x2\xA\x2\xFFFF\x1\xA\x12\xFFFF\x1\xA\x1\x1A\x1\x22\x1\xFFFF\x1\x1F"+
"\x2\xFFFF\x1\x21\x1\x12\x1\x13\x1\x15\x1\x16\x1\xF\x1\x18\x1\x1C\x1"+
@@ -4398,35 +3975,35 @@ public partial class ANTLRLexer : Lexer
""
};

-		static readonly short[] DFA27_eot = DFA.UnpackEncodedString(DFA27_eotS);
-		static readonly short[] DFA27_eof = DFA.UnpackEncodedString(DFA27_eofS);
-		static readonly char[] DFA27_min = DFA.UnpackEncodedStringToUnsignedChars(DFA27_minS);
-		static readonly char[] DFA27_max = DFA.UnpackEncodedStringToUnsignedChars(DFA27_maxS);
-		static readonly short[] DFA27_accept = DFA.UnpackEncodedString(DFA27_acceptS);
-		static readonly short[] DFA27_special = DFA.UnpackEncodedString(DFA27_specialS);
-		static readonly short[][] DFA27_transition;
+		static readonly short[] DFA25_eot = DFA.UnpackEncodedString(DFA25_eotS);
+		static readonly short[] DFA25_eof = DFA.UnpackEncodedString(DFA25_eofS);
+		static readonly char[] DFA25_min = DFA.UnpackEncodedStringToUnsignedChars(DFA25_minS);
+		static readonly char[] DFA25_max = DFA.UnpackEncodedStringToUnsignedChars(DFA25_maxS);
+		static readonly short[] DFA25_accept = DFA.UnpackEncodedString(DFA25_acceptS);
+		static readonly short[] DFA25_special = DFA.UnpackEncodedString(DFA25_specialS);
+		static readonly short[][] DFA25_transition;

-		static DFA27()
+		static DFA25()
{
-			int numStates = DFA27_transitionS.Length;
-			DFA27_transition = new short[numStates][];
+			int numStates = DFA25_transitionS.Length;
+			DFA25_transition = new short[numStates][];
for ( int i=0; i < numStates; i++ )
{
-				DFA27_transition[i] = DFA.UnpackEncodedString(DFA27_transitionS[i]);
+				DFA25_transition[i] = DFA.UnpackEncodedString(DFA25_transitionS[i]);
}
}

-		public DFA27( BaseRecognizer recognizer )
+		public DFA25( BaseRecognizer recognizer )
{
this.recognizer = recognizer;
-			this.decisionNumber = 27;
-			this.eot = DFA27_eot;
-			this.eof = DFA27_eof;
-			this.min = DFA27_min;
-			this.max = DFA27_max;
-			this.accept = DFA27_accept;
-			this.special = DFA27_special;
-			this.transition = DFA27_transition;
+			this.decisionNumber = 25;
+			this.eot = DFA25_eot;
+			this.eof = DFA25_eof;
+			this.min = DFA25_min;
+			this.max = DFA25_max;
+			this.accept = DFA25_accept;
+			this.special = DFA25_special;
+			this.transition = DFA25_transition;
}
public override string GetDescription()
{
diff --git a/Antlr3/Grammars/ANTLRParser.cs b/Antlr3/Grammars/ANTLRParser.cs
index b92845f..b6b991f 100644
--- a/Antlr3/Grammars/ANTLRParser.cs
+++ b/Antlr3/Grammars/ANTLRParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-03-08 16:31:33
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-03-16 19:03:26

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219

