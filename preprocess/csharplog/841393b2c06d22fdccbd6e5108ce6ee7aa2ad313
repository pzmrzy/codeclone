commit 841393b2c06d22fdccbd6e5108ce6ee7aa2ad313
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Apr 16 15:20:16 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Apr 16 15:20:16 2009 -0800

C# Port:
* More Capitalized method names

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6036]

diff --git a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
index af0260a..2f6ea3f 100644
--- a/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ActionScript/ActionScriptTarget.cs
@@ -40,7 +40,7 @@ namespace Antlr3.Targets
public class ActionScriptTarget : Target
{

-        public override string getTargetCharLiteralFromANTLRCharLiteral(
+        public override string GetTargetCharLiteralFromANTLRCharLiteral(
CodeGenerator generator,
string literal )
{
@@ -49,7 +49,7 @@ namespace Antlr3.Targets
return c.ToString();
}

-        public override string getTokenTypeAsTargetLabel( CodeGenerator generator,
+        public override string GetTokenTypeAsTargetLabel( CodeGenerator generator,
int ttype )
{
// use ints for predefined types;
@@ -85,7 +85,7 @@ namespace Antlr3.Targets
* @param v
* @return
*/
-        public override string encodeIntAsCharEscape( int v )
+        public override string EncodeIntAsCharEscape( int v )
{
// encode as hex
if ( v <= 255 )
@@ -118,18 +118,18 @@ namespace Antlr3.Targets
*  This is to match how the BitSet constructor works, where the bits are
*  passed in in 32-bit chunks with low-order bits coming first.
*/
-        public override string getTarget64BitStringFromValue( ulong word )
+        public override string GetTarget64BitStringFromValue( ulong word )
{
StringBuilder buf = new StringBuilder( 22 ); // enough for the two "0x", "," and " "
buf.Append( "0x" );
-            writeHexWithPadding( buf, ( (uint)word ).ToString( "x" ) );
+            WriteHexWithPadding( buf, ( (uint)word ).ToString( "x" ) );
buf.Append( ", 0x" );
-            writeHexWithPadding( buf, ( word >> 32 ).ToString( "x" ) );
+            WriteHexWithPadding( buf, ( word >> 32 ).ToString( "x" ) );

return buf.ToString();
}

-        private void writeHexWithPadding( StringBuilder buf, string digits )
+        private void WriteHexWithPadding( StringBuilder buf, string digits )
{
// pad left with zeros
int padding = 8 - digits.Length;
diff --git a/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs b/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs
index 466b650..e1eb6ce 100644
--- a/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.C/CTarget.cs
@@ -42,9 +42,9 @@ namespace Antlr3.Targets

public class CTarget : Target
{
-        List<string> strings = new List<string>();
+        List<string> _strings = new List<string>();

-        protected override void genRecognizerFile( AntlrTool tool,
+        protected override void GenRecognizerFile( AntlrTool tool,
CodeGenerator generator,
Grammar grammar,
StringTemplate outputFileST )
@@ -53,12 +53,12 @@ namespace Antlr3.Targets
// Before we write this, and cause it to generate its string,
// we need to add all the string literals that we are going to match
//
-            outputFileST.SetAttribute( "literals", strings );
-            string fileName = generator.getRecognizerFileName( grammar.name, grammar.type );
-            generator.write( outputFileST, fileName );
+            outputFileST.SetAttribute( "literals", _strings );
+            string fileName = generator.GetRecognizerFileName( grammar.name, grammar.type );
+            generator.Write( outputFileST, fileName );
}

-        protected override void genRecognizerHeaderFile( AntlrTool tool,
+        protected override void GenRecognizerHeaderFile( AntlrTool tool,
CodeGenerator generator,
Grammar grammar,
StringTemplate headerFileST,
@@ -68,10 +68,10 @@ namespace Antlr3.Targets
// a file suffixed with .c, so we must substring and add the extName
// to it as we cannot assign into strings in Java.
///
-            string fileName = generator.getRecognizerFileName( grammar.name, grammar.type );
+            string fileName = generator.GetRecognizerFileName( grammar.name, grammar.type );
fileName = fileName.Substring( 0, fileName.Length - 2 ) + extName;

-            generator.write( headerFileST, fileName );
+            generator.Write( headerFileST, fileName );
}

/** Is scope in @scope::name {action} valid for this kind of grammar?
@@ -80,7 +80,7 @@ namespace Antlr3.Targets
*  moment so targets can add template actions w/o having to recompile
*  ANTLR.
*/
-        public override bool isValidActionScope( int grammarType, string scope )
+        public override bool IsValidActionScope( int grammarType, string scope )
{
switch ( grammarType )
{
@@ -141,7 +141,7 @@ namespace Antlr3.Targets
return false;
}

-        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator, string literal )
+        public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator, string literal )
{

if ( literal.StartsWith( "'\\u" ) )
@@ -169,7 +169,7 @@ namespace Antlr3.Targets
*  must produce the C array and cater for the case where the
*  lexer has been encoded with a string such as 'xyz\n',
*/
-        public override string getTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator, string literal )
+        public override string GetTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator, string literal )
{
int index;
//int outc;
@@ -245,12 +245,12 @@ namespace Antlr3.Targets
buf.Append( " ANTLR3_STRING_TERMINATOR}" );

bytes = buf.ToString();
-            index = strings.IndexOf( bytes );
+            index = _strings.IndexOf( bytes );

if ( index == -1 )
{
-                strings.Add( bytes );
-                index = strings.IndexOf( bytes );
+                _strings.Add( bytes );
+                index = _strings.IndexOf( bytes );
}

string strref = "lit_" + ( index + 1 ).ToString();
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp/CSharpTarget.cs b/Antlr3.Targets/Antlr3.Targets.CSharp/CSharpTarget.cs
index 159f562..57e35b6 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp/CSharpTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp/CSharpTarget.cs
@@ -36,7 +36,7 @@ namespace Antlr3.Targets

public class CSharpTarget : Target
{
-        public override string encodeIntAsCharEscape( int v )
+        public override string EncodeIntAsCharEscape( int v )
{
return "\\x" + v.ToString( "X" );
}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs b/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs
index c812845..99f1145 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp2/CSharp2Target.cs
@@ -36,7 +36,7 @@ namespace Antlr3.Targets

public class CSharp2Target : Target
{
-        public override string encodeIntAsCharEscape( int v )
+        public override string EncodeIntAsCharEscape( int v )
{
return "\\x" + v.ToString( "X" );
}
diff --git a/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs b/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
index 5ecc89b..96a89b9 100644
--- a/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
+++ b/Antlr3.Targets/Antlr3.Targets.CSharp3/CSharp3Target.cs
@@ -35,12 +35,12 @@ namespace Antlr3.Targets

public class CSharp3Target : Target
{
-        public override string encodeIntAsCharEscape( int v )
+        public override string EncodeIntAsCharEscape( int v )
{
return "\\x" + v.ToString( "X" );
}

-        public override string getTarget64BitStringFromValue( ulong word )
+        public override string GetTarget64BitStringFromValue( ulong word )
{
return "0x" + word.ToString( "X" );
}
diff --git a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
index c06576f..d77c6da 100644
--- a/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Cpp/CPPTarget.cs
@@ -40,7 +40,7 @@ namespace Antlr3.Targets

public class CPPTarget : Target
{
-        public string escapeChar( int c )
+        public string EscapeChar( int c )
{
// System.out.println("CPPTarget.escapeChar("+c+")");
switch ( c )
@@ -87,25 +87,25 @@ namespace Antlr3.Targets
*
* @param s The String to be changed into a literal
*/
-        public string escapeString( string s )
+        public string EscapeString( string s )
{
StringBuilder retval = new StringBuilder();
for ( int i = 0; i < s.Length; i++ )
{
-                retval.Append( escapeChar( s[i] ) );
+                retval.Append( EscapeChar( s[i] ) );
}

return retval.ToString();
}

-        protected override void genRecognizerHeaderFile( AntlrTool tool,
+        protected override void GenRecognizerHeaderFile( AntlrTool tool,
CodeGenerator generator,
Grammar grammar,
StringTemplate headerFileST,
string extName )
{
-            StringTemplateGroup templates = generator.getTemplates();
-            generator.write( headerFileST, grammar.name + extName );
+            StringTemplateGroup templates = generator.GetTemplates();
+            generator.Write( headerFileST, grammar.name + extName );
}

/** Convert from an ANTLR char literal found in a grammar file to
@@ -115,7 +115,7 @@ namespace Antlr3.Targets
*  around the incoming literal.
*  Depending on the charvocabulary the charliteral should be prefixed with a 'L'
*/
-        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator codegen, string literal )
+        public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator codegen, string literal )
{
int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
string prefix = "'";
@@ -123,7 +123,7 @@ namespace Antlr3.Targets
prefix = "L'";
else if ( ( c & 0x80 ) != 0 )	// if in char mode prevent sign extensions
return "" + c;
-            return prefix + escapeChar( c ) + "'";
+            return prefix + EscapeChar( c ) + "'";
}

/** Convert from an ANTLR string literal found in a grammar file to
@@ -133,20 +133,20 @@ namespace Antlr3.Targets
*  around the incoming literal.
*  Depending on the charvocabulary the string should be prefixed with a 'L'
*/
-        public override string getTargetStringLiteralFromANTLRStringLiteral( CodeGenerator codegen, string literal )
+        public override string GetTargetStringLiteralFromANTLRStringLiteral( CodeGenerator codegen, string literal )
{
StringBuilder buf = Grammar.getUnescapedStringFromGrammarStringLiteral( literal );
string prefix = "\"";
if ( codegen.grammar.MaxCharValue > 255 )
prefix = "L\"";
-            return prefix + escapeString( buf.ToString() ) + "\"";
+            return prefix + EscapeString( buf.ToString() ) + "\"";
}
/** Character constants get truncated to this value.
* TODO: This should be derived from the charVocabulary. Depending on it
* being 255 or 0xFFFF the templates should generate normal character
* constants or multibyte ones.
*/
-        public override int getMaxCharValue( CodeGenerator codegen )
+        public override int GetMaxCharValue( CodeGenerator codegen )
{
int maxval = 255; // codegen.grammar.get????();
if ( maxval <= 255 )
diff --git a/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs b/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
index 7a8d3c1..43b5332 100644
--- a/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Delphi/DelphiTarget.cs
@@ -53,13 +53,13 @@ namespace Antlr3.Targets
targetCharValueEscape['"'] = "'";
}

-        public override string encodeIntAsCharEscape( int v )
+        public override string EncodeIntAsCharEscape( int v )
{
string hex = ( v <= 127 ) ? v.ToString( "x2" ) : v.ToString( "x4" );
return "'#$" + hex + "'";
}

-        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator, string literal )
+        public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator, string literal )
{
StringBuilder buf = new StringBuilder();
int c = Grammar.getCharValueFromGrammarCharLiteral( literal );
@@ -73,7 +73,7 @@ namespace Antlr3.Targets
return buf.ToString();
}

-        public override string getTargetStringLiteralFromString( string s, bool quoted )
+        public override string GetTargetStringLiteralFromString( string s, bool quoted )
{
if ( s == null )
{
@@ -111,7 +111,7 @@ namespace Antlr3.Targets
return buf.ToString();
}

-        public override string getTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator, string literal )
+        public override string GetTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator, string literal )
{
literal = literal.Replace( "\\\'", "''" ); // \' to ' to normalize
literal = literal.Replace( "\\r\\n", "'#13#10'" );
@@ -123,7 +123,7 @@ namespace Antlr3.Targets
return buf.ToString();
}

-        public override string getTarget64BitStringFromValue( ulong word )
+        public override string GetTarget64BitStringFromValue( ulong word )
{
int numHexDigits = 8 * 2;
StringBuilder buf = new StringBuilder( numHexDigits + 2 );
diff --git a/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs b/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs
index c098f54..d81d88f 100644
--- a/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.JavaScript/JavaScriptTarget.cs
@@ -43,7 +43,7 @@ namespace Antlr3.Targets
*  This method overrides the parent class so that characters will always
*  be encoded as Unicode literals (e.g. \u0011).
*/
-        public override string encodeIntAsCharEscape( int v )
+        public override string EncodeIntAsCharEscape( int v )
{
string hex = v.ToString( "x4" );
return "\\u" + hex;
@@ -60,18 +60,18 @@ namespace Antlr3.Targets
*
*  Note: stole the following two methods from the ActionScript target.
*/
-        public override string getTarget64BitStringFromValue( ulong word )
+        public override string GetTarget64BitStringFromValue( ulong word )
{
StringBuilder buf = new StringBuilder( 22 ); // enough for the two "0x", "," and " "
buf.Append( "0x" );
-            writeHexWithPadding( buf, ( (uint)word ).ToString( "x" ) );
+            WriteHexWithPadding( buf, ( (uint)word ).ToString( "x" ) );
buf.Append( ", 0x" );
-            writeHexWithPadding( buf, ( word >> 32 ).ToString( "x" ) );
+            WriteHexWithPadding( buf, ( word >> 32 ).ToString( "x" ) );

return buf.ToString();
}

-        private void writeHexWithPadding( StringBuilder buf, string digits )
+        private void WriteHexWithPadding( StringBuilder buf, string digits )
{
digits = digits.ToUpperInvariant();
int padding = 8 - digits.Length;
diff --git a/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs b/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
index 828d7e5..a7e7234 100644
--- a/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.ObjC/ObjCTarget.cs
@@ -41,16 +41,16 @@ namespace Antlr3.Targets

public class ObjCTarget : Target
{
-        protected override void genRecognizerHeaderFile( AntlrTool tool,
+        protected override void GenRecognizerHeaderFile( AntlrTool tool,
CodeGenerator generator,
Grammar grammar,
StringTemplate headerFileST,
string extName )
{
-            generator.write( headerFileST, grammar.name + Grammar.grammarTypeToFileNameSuffix[grammar.type] + extName );
+            generator.Write( headerFileST, grammar.name + Grammar.grammarTypeToFileNameSuffix[grammar.type] + extName );
}

-        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator,
+        public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator,
string literal )
{
if ( literal.StartsWith( "'\\u" ) )
@@ -75,7 +75,7 @@ namespace Antlr3.Targets
*  around the incoming literal.  Just flip the quotes and replace
*  double quotes with \"
*/
-        public override string getTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator,
+        public override string GetTargetStringLiteralFromANTLRStringLiteral( CodeGenerator generator,
string literal )
{
literal = literal.Replace( "\"", "\\\"" );
@@ -87,7 +87,7 @@ namespace Antlr3.Targets
}

/** If we have a label, prefix it with the recognizer's name */
-        public override string getTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
+        public override string GetTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
{
string name = generator.grammar.getTokenDisplayName( ttype );
// If name is a literal, return the token type instead
@@ -101,7 +101,7 @@ namespace Antlr3.Targets
}

/** Target must be able to override the labels used for token types. Sometimes also depends on the token text.*/
-        string getTokenTextAndTypeAsTargetLabel( CodeGenerator generator, string text, int tokenType )
+        string GetTokenTextAndTypeAsTargetLabel( CodeGenerator generator, string text, int tokenType )
{
string name = generator.grammar.getTokenDisplayName( tokenType );
// If name is a literal, return the token type instead
diff --git a/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs b/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs
index 20982de..34be616 100644
--- a/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Perl5/Perl5Target.cs
@@ -50,7 +50,7 @@ namespace Antlr3.Targets
RuleLabelScope.predefinedLexerRulePropertiesScope.addAttribute( "self", null );
}

-        public override string getTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator,
+        public override string GetTargetCharLiteralFromANTLRCharLiteral( CodeGenerator generator,
string literal )
{
StringBuilder buf = new StringBuilder( 10 );
@@ -97,7 +97,7 @@ namespace Antlr3.Targets
return buf.ToString();
}

-        public override string encodeIntAsCharEscape( int v )
+        public override string EncodeIntAsCharEscape( int v )
{
int intValue;
if ( ( v & 0x8000 ) == 0 )
diff --git a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
index 4135515..caad321 100644
--- a/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Python/PythonTarget.cs
@@ -51,7 +51,7 @@ namespace Antlr3.Targets
public class PythonTarget : Target
{
/** Target must be able to override the labels used for token types */
-        public override string getTokenTypeAsTargetLabel( CodeGenerator generator,
+        public override string GetTokenTypeAsTargetLabel( CodeGenerator generator,
int ttype )
{
// use ints for predefined types;
@@ -72,7 +72,7 @@ namespace Antlr3.Targets
return name;
}

-        public override string getTargetCharLiteralFromANTLRCharLiteral(
+        public override string GetTargetCharLiteralFromANTLRCharLiteral(
CodeGenerator generator,
string literal )
{
@@ -80,12 +80,12 @@ namespace Antlr3.Targets
return ( (char)c ).ToString();
}

-        private IList<string> splitLines( string text )
+        private IList<string> SplitLines( string text )
{
return text.Split( '\n' );
}

-        public override IList postProcessAction( IList chunks, IToken actionToken )
+        public override IList PostProcessAction( IList chunks, IToken actionToken )
{
/* TODO
- check for and report TAB usage
diff --git a/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs b/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
index 4194b27..b1b6af4 100644
--- a/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
+++ b/Antlr3.Targets/Antlr3.Targets.Ruby/RubyTarget.cs
@@ -37,7 +37,7 @@ namespace Antlr3.Targets

public class RubyTarget : Target
{
-        public override string getTargetCharLiteralFromANTLRCharLiteral(
+        public override string GetTargetCharLiteralFromANTLRCharLiteral(
CodeGenerator generator,
string literal )
{
@@ -65,13 +65,13 @@ namespace Antlr3.Targets
return result;
}

-        public override int getMaxCharValue( CodeGenerator generator )
+        public override int GetMaxCharValue( CodeGenerator generator )
{
// we don't support unicode, yet.
return 0xFF;
}

-        public override string getTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
+        public override string GetTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
{
string name = generator.grammar.getTokenDisplayName( ttype );
// If name is a literal, return the token type instead
diff --git a/Antlr3.Test/TestAttributes.cs b/Antlr3.Test/TestAttributes.cs
index 920fd27..f2788fd 100644
--- a/Antlr3.Test/TestAttributes.cs
+++ b/Antlr3.Test/TestAttributes.cs
@@ -94,7 +94,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -123,7 +123,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -155,7 +155,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation = translator.translate();
@@ -178,7 +178,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
Rule r = g.getRule( "a" );
AttributeScope parameters = r.parameterScope;
var attrs = parameters.Attributes;
@@ -210,7 +210,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation = translator.translate();
@@ -234,7 +234,7 @@ namespace AntlrUnitTests
"19"
} );

-            List<string> actualArgs = CodeGenerator.getListOfArgumentsFromAction( action, ',' );
+            List<string> actualArgs = CodeGenerator.GetListOfArgumentsFromAction( action, ',' );
//assertEquals( "args mismatch", expectArgs, actualArgs );
assertTrue( "args mismatch", expectArgs.SequenceEqual( actualArgs ) );

@@ -258,7 +258,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation = translator.translate();
@@ -284,7 +284,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -316,7 +316,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -361,7 +361,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -410,7 +410,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -444,7 +444,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -476,7 +476,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -538,7 +538,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"b",
@@ -570,7 +570,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"b",
@@ -601,7 +601,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -640,7 +640,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
int i = 0;
string action = action1;
string expecting = expecting1;
@@ -708,7 +708,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -742,7 +742,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // codegen phase sets some vars we need
+            generator.GenRecognizer(); // codegen phase sets some vars we need
StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
string found = code.substring( code.IndexOf( "###" ) + 3, code.IndexOf( "!!!" ) );
@@ -762,7 +762,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

// error(132): <string>:2:9: reference $a is ambiguous; rule a is enclosing rule and referenced in the production
assertEquals( "unexpected errors: " + equeue, 1, equeue.errors.Count );
@@ -787,7 +787,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // codegen phase sets some vars we need
+            generator.GenRecognizer(); // codegen phase sets some vars we need

StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -814,7 +814,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // codegen phase sets some vars we need
+            generator.GenRecognizer(); // codegen phase sets some vars we need

StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -1067,7 +1067,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1095,7 +1095,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );

@@ -1128,7 +1128,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1162,7 +1162,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1194,7 +1194,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1224,7 +1224,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1261,7 +1261,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1294,7 +1294,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1325,7 +1325,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
null,
new CommonToken( ANTLRParser.ACTION, action ), 0 );
@@ -1357,7 +1357,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1388,7 +1388,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_ISOLATED_RULE_ATTRIBUTE;
object expectedArg = "n";
@@ -1417,7 +1417,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1449,7 +1449,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1485,7 +1485,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1518,7 +1518,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1546,7 +1546,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1574,7 +1574,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1602,7 +1602,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1630,7 +1630,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_ISOLATED_RULE_SCOPE;
object expectedArg = "a";
@@ -1655,7 +1655,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_ISOLATED_RULE_SCOPE;
object expectedArg = "x";
@@ -1738,7 +1738,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1770,7 +1770,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates

StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -1798,7 +1798,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1827,7 +1827,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1856,7 +1856,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1884,7 +1884,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
StringTemplate codeST = generator.RecognizerST;
@@ -1914,7 +1914,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -1960,7 +1960,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
@@ -2004,7 +2004,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -2042,7 +2042,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -2184,7 +2184,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -2214,7 +2214,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -2244,7 +2244,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -2278,7 +2278,7 @@ namespace AntlrUnitTests
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
string rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2310,7 +2310,7 @@ namespace AntlrUnitTests
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
string rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2337,7 +2337,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -2362,7 +2362,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -2388,7 +2388,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
@@ -2413,7 +2413,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -2443,7 +2443,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -2472,7 +2472,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT;
object expectedArg = "x";
@@ -2526,7 +2526,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_MISSING_RULE_ARGS;
object expectedArg = "r";
@@ -2548,7 +2548,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_RULE_HAS_NO_ARGS;
object expectedArg = "r";
@@ -2630,7 +2630,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_ARG_INIT_VALUES_ILLEGAL;
object expectedArg = "y";
@@ -2652,7 +2652,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_ARGS_ON_TOKEN_REF;
object expectedArg = "ID";
@@ -2674,7 +2674,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_RULE_HAS_NO_ARGS;
object expectedArg = "ID";
@@ -2697,7 +2697,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
@@ -2727,7 +2727,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
@@ -2757,7 +2757,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
@@ -2785,7 +2785,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates

assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
}
@@ -2801,7 +2801,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
}

@@ -2816,7 +2816,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
}

@@ -2831,7 +2831,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
assertEquals( "unexpected errors: " + equeue, 0, equeue.errors.Count );
}

@@ -2847,7 +2847,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_MISSING_RULE_ARGS;
object expectedArg = "R";
@@ -2870,7 +2870,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
@@ -2900,7 +2900,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
@@ -2929,7 +2929,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"R",
@@ -2970,7 +2970,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, lexerGrammar, "Java" );
lexerGrammar.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_RULE_HAS_NO_ARGS;
object expectedArg = "ID";
@@ -3004,7 +3004,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, lexerGrammar, "Java" );
lexerGrammar.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_MISSING_RULE_ARGS;
object expectedArg = "ID";
@@ -3036,7 +3036,7 @@ namespace AntlrUnitTests
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
string rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -3063,7 +3063,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

ActionTranslator translator = new ActionTranslator( generator, "a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3091,7 +3091,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_NONUNIQUE_REF;
object expectedArg = "ID";
@@ -3115,7 +3115,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_NONUNIQUE_REF;
object expectedArg = "ID";
@@ -3140,7 +3140,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"field",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3169,7 +3169,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3198,7 +3198,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3226,7 +3226,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3255,7 +3255,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3298,7 +3298,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3328,7 +3328,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3364,7 +3364,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3394,7 +3394,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();
ActionTranslator translator = new ActionTranslator( generator,
"RULE",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3430,7 +3430,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();
ActionTranslator translator = new ActionTranslator( generator,
"twoIDs",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -3477,7 +3477,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // codegen phase sets some vars we need
+            generator.GenRecognizer(); // codegen phase sets some vars we need
StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
string found = code.substring( code.IndexOf( "###" ) + 3, code.IndexOf( "!!!" ) );
@@ -3511,7 +3511,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // codegen phase sets some vars we need
+            generator.GenRecognizer(); // codegen phase sets some vars we need
StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
string found = code.substring( code.IndexOf( "###" ) + 3, code.IndexOf( "!!!" ) );
@@ -3538,7 +3538,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator, "b",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
string rawTranslation =
diff --git a/Antlr3.Test/TestDFAConversion.cs b/Antlr3.Test/TestDFAConversion.cs
index fc0de36..aead3d4 100644
--- a/Antlr3.Test/TestDFAConversion.cs
+++ b/Antlr3.Test/TestDFAConversion.cs
@@ -769,7 +769,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

Message msg = (Message)equeue.warnings[0];
assertTrue( "expecting no start rules; found " + msg.GetType().Name,
diff --git a/Antlr3.Test/TestLexer.cs b/Antlr3.Test/TestLexer.cs
index 9a9c80c..0190dae 100644
--- a/Antlr3.Test/TestLexer.cs
+++ b/Antlr3.Test/TestLexer.cs
@@ -275,7 +275,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // codegen phase sets some vars we need
+            generator.GenRecognizer(); // codegen phase sets some vars we need
StringTemplate codeST = generator.RecognizerST;
string code = codeST.ToString();
int m = code.IndexOf( "match(\"" );
diff --git a/Antlr3.Test/TestMessages.cs b/Antlr3.Test/TestMessages.cs
index 7c4eb4d..70a4562 100644
--- a/Antlr3.Test/TestMessages.cs
+++ b/Antlr3.Test/TestMessages.cs
@@ -67,7 +67,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"rule",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
diff --git a/Antlr3.Test/TestRewriteAST.cs b/Antlr3.Test/TestRewriteAST.cs
index 56daa6f..41a580b 100644
--- a/Antlr3.Test/TestRewriteAST.cs
+++ b/Antlr3.Test/TestRewriteAST.cs
@@ -939,7 +939,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

// $a is ambig; is it previous root or ref to a ref in alt?
assertEquals( "unexpected errors: " + equeue, 1, equeue.errors.Count );
@@ -1254,7 +1254,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_RULE_REF;
object expectedArg = "ugh";
@@ -1284,7 +1284,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS;
object expectedArg = "b";
@@ -1313,7 +1313,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE;
object expectedArg = "ICK";
@@ -1342,7 +1342,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE;
object expectedArg = "foo";
@@ -1371,7 +1371,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE;
object expectedArg = "'a'";
@@ -1400,7 +1400,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

int expectedMsgID = ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE;
object expectedArg = "'foo'";
diff --git a/Antlr3.Test/TestRewriteTemplates.cs b/Antlr3.Test/TestRewriteTemplates.cs
index 725ef4e..887f754 100644
--- a/Antlr3.Test/TestRewriteTemplates.cs
+++ b/Antlr3.Test/TestRewriteTemplates.cs
@@ -272,7 +272,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 0, equeue.warnings.Count );
}
@@ -295,7 +295,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 0, equeue.warnings.Count );
}
@@ -315,7 +315,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 2, equeue.warnings.Count );
}
@@ -336,7 +336,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 2, equeue.warnings.Count );
}
diff --git a/Antlr3.Test/TestSymbolDefinitions.cs b/Antlr3.Test/TestSymbolDefinitions.cs
index e365ee7..76698db 100644
--- a/Antlr3.Test/TestSymbolDefinitions.cs
+++ b/Antlr3.Test/TestSymbolDefinitions.cs
@@ -255,7 +255,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            StringTemplate recogST = generator.genRecognizer();
+            StringTemplate recogST = generator.GenRecognizer();
string code = recogST.ToString();
assertTrue( "not expecting label", code.IndexOf( "x=b();" ) < 0 );

diff --git a/Antlr3.Test/TestTemplates.cs b/Antlr3.Test/TestTemplates.cs
index e037636..dd0b3cd 100644
--- a/Antlr3.Test/TestTemplates.cs
+++ b/Antlr3.Test/TestTemplates.cs
@@ -71,7 +71,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -108,7 +108,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -146,7 +146,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -183,7 +183,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -219,7 +219,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator( generator,
"a",
@@ -256,7 +256,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator( generator,
"a",
new CommonToken( ANTLRParser.ACTION, action ), 1 );
@@ -291,7 +291,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates

assertNoErrors( equeue );
}
@@ -316,7 +316,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_INVALID_TEMPLATE_ACTION;
object expectedArg = "%x";
@@ -345,7 +345,7 @@ namespace AntlrUnitTests
AntlrTool antlr = newTool();
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer(); // forces load of templates
+            generator.GenRecognizer(); // forces load of templates

int expectedMsgID = ErrorManager.MSG_INVALID_TEMPLATE_ACTION;
object expectedArg = "%x.";
diff --git a/Antlr3.Test/TestTreeGrammarRewriteAST.cs b/Antlr3.Test/TestTreeGrammarRewriteAST.cs
index d28e3d0..b966ee6 100644
--- a/Antlr3.Test/TestTreeGrammarRewriteAST.cs
+++ b/Antlr3.Test/TestTreeGrammarRewriteAST.cs
@@ -262,7 +262,7 @@ namespace AntlrUnitTests
antlr.setOutputDirectory( null ); // write to /dev/null
CodeGenerator generator = new CodeGenerator( antlr, g, "Java" );
g.setCodeGenerator( generator );
-            generator.genRecognizer();
+            generator.GenRecognizer();

assertEquals( "unexpected errors: " + equeue, 1, equeue.errors.Count );

diff --git a/Antlr3/Analysis/DFA.cs b/Antlr3/Analysis/DFA.cs
index c24b07a..2482e09 100644
--- a/Antlr3/Analysis/DFA.cs
+++ b/Antlr3/Analysis/DFA.cs
@@ -632,8 +632,8 @@ namespace Antlr3.Analysis
break;
}
}
-                encoded.Add( _generator.target.encodeIntAsCharEscape( (char)n ) );
-                encoded.Add( _generator.target.encodeIntAsCharEscape( (char)(int)I ) );
+                encoded.Add( _generator.target.EncodeIntAsCharEscape( (char)n ) );
+                encoded.Add( _generator.target.EncodeIntAsCharEscape( (char)(int)I ) );
i += n;
}
return encoded;
@@ -645,7 +645,7 @@ namespace Antlr3.Analysis
this._generator = generator;
_description = NFADecisionStartState.Description;
_description =
-                generator.target.getTargetStringLiteralFromString( _description );
+                generator.target.GetTargetStringLiteralFromString( _description );

// create all the tables
//special = new List<int>( this.NumberOfStates ); // Vector<short>
@@ -710,7 +710,7 @@ namespace Antlr3.Analysis
{
DFAState ss = (DFAState)_specialStates[i];
StringTemplate stateST =
-                    generator.generateSpecialState( ss );
+                    generator.GenerateSpecialState( ss );
_specialStateSTs.Add( stateST );
}

diff --git a/Antlr3/Analysis/SemanticContext.cs b/Antlr3/Analysis/SemanticContext.cs
index ca07b39..62e9ae3 100644
--- a/Antlr3/Analysis/SemanticContext.cs
+++ b/Antlr3/Analysis/SemanticContext.cs
@@ -204,7 +204,7 @@ namespace Antlr3.Analysis
if ( generator != null )
{
eST.SetAttribute( "pred",
-                                         generator.translateAction( predEnclosingRuleName, predicateAST ) );
+                                         generator.TranslateAction( predEnclosingRuleName, predicateAST ) );
}
}
else
@@ -216,7 +216,7 @@ namespace Antlr3.Analysis
if ( generator != null )
{
string description =
-                        generator.target.getTargetStringLiteralFromString( this.ToString() );
+                        generator.target.GetTargetStringLiteralFromString( this.ToString() );
eST.SetAttribute( "description", description );
}
return eST;
diff --git a/Antlr3/AntlrTool.cs b/Antlr3/AntlrTool.cs
index 65f484b..51255f4 100644
--- a/Antlr3/AntlrTool.cs
+++ b/Antlr3/AntlrTool.cs
@@ -670,9 +670,9 @@ namespace Antlr3
{
CodeGenerator generator = new CodeGenerator( this, grammar, language );
grammar.setCodeGenerator( generator );
-                generator.setDebug( Debug );
-                generator.setProfile( Profile );
-                generator.setTrace( Trace );
+                generator.SetDebug( Debug );
+                generator.SetProfile( Profile );
+                generator.SetTrace( Trace );

// generate NFA early in case of crash later (for debugging)
if ( Generate_NFA_dot )
@@ -681,7 +681,7 @@ namespace Antlr3
}

// GENERATE CODE
-                generator.genRecognizer();
+                generator.GenRecognizer();

if ( Generate_DFA_dot )
{
diff --git a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
index 78a1811..e8c3de9 100644
--- a/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
+++ b/Antlr3/Codegen/ACyclicDFACodeGenerator.cs
@@ -74,7 +74,7 @@ namespace Antlr3.Codegen
string dfaLoopbackStateName = "dfaLoopbackState";
string dfaOptionalBlockStateName = "dfaOptionalBlockState";
string dfaEdgeName = "dfaEdge";
-            if ( parentGenerator.canGenerateSwitch( s ) )
+            if ( parentGenerator.CanGenerateSwitch( s ) )
{
dfaStateName = "dfaStateSwitch";
dfaLoopbackStateName = "dfaLoopbackStateSwitch";
@@ -128,13 +128,13 @@ namespace Antlr3.Codegen
// If the template wants all the label values delineated, do that
if ( edgeST.GetFormalArgument( "labels" ) != null )
{
-                    List<string> labels = edge.Label.Set.Select( value => parentGenerator.getTokenTypeAsTargetLabel( value ) ).ToList();
+                    List<string> labels = edge.Label.Set.Select( value => parentGenerator.GetTokenTypeAsTargetLabel( value ) ).ToList();
edgeST.SetAttribute( "labels", labels );
}
else
{ // else create an expression to evaluate (the general case)
edgeST.SetAttribute( "labelExpr",
-                                        parentGenerator.genLabelExpr( templates, edge, k ) );
+                                        parentGenerator.GenLabelExpr( templates, edge, k ) );
}

// stick in any gated predicates for any edge if not already a pred
@@ -184,7 +184,7 @@ namespace Antlr3.Codegen
Transition predEdge = (Transition)EOTTarget.Transition( i );
StringTemplate edgeST = templates.GetInstanceOf( dfaEdgeName );
edgeST.SetAttribute( "labelExpr",
-                                        parentGenerator.genSemanticPredicateExpr( templates, predEdge ) );
+                                        parentGenerator.GenSemanticPredicateExpr( templates, predEdge ) );
// the target must be an accept state
//System.Console.Out.WriteLine( "EOT edge" );
StringTemplate targetST =
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index 3240781..e332b48 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -69,6 +69,7 @@ namespace Antlr3.Codegen
using MethodImpl = System.Runtime.CompilerServices.MethodImplAttribute;
using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
using NFAState = Antlr3.Analysis.NFAState;
+    using Obsolete = System.ObsoleteAttribute;
using RecognitionException = Antlr.Runtime.RecognitionException;
using Rule = Antlr3.Tool.Rule;
using StringTemplate = Antlr3.ST.StringTemplate;
@@ -188,7 +189,7 @@ namespace Antlr3.Codegen

acyclicDFAGenerator = new ACyclicDFACodeGenerator( this );

-            loadLanguageTarget( language );
+            LoadLanguageTarget( language );
}

#region Properties
@@ -196,28 +197,28 @@ namespace Antlr3.Codegen
{
get
{
-                return getBaseTemplates();
+                return GetBaseTemplates();
}
}
public StringTemplate RecognizerST
{
get
{
-                return getRecognizerST();
+                return GetRecognizerST();
}
}
public StringTemplateGroup Templates
{
get
{
-                return getTemplates();
+                return GetTemplates();
}
}
public string VocabFileName
{
get
{
-                return getVocabFileName();
+                return GetVocabFileName();
}
}
public bool Debug
@@ -244,7 +245,7 @@ namespace Antlr3.Codegen
#endregion

[MethodImpl( MethodImplOptions.Synchronized )]
-        protected virtual void loadLanguageTarget( string language )
+        protected virtual void LoadLanguageTarget( string language )
{
if ( !_targets.TryGetValue( language, out target ) )
{
@@ -292,7 +293,7 @@ namespace Antlr3.Codegen
}

/** load the main language.stg template group file */
-        public virtual void loadTemplates( string language )
+        public virtual void LoadTemplates( string language )
{
// get a group loader containing main templates dir and target subdir
string templateDirs =
@@ -411,11 +412,11 @@ namespace Antlr3.Codegen
*
*  The target, such as JavaTarget, dictates which files get written.
*/
-        public virtual StringTemplate genRecognizer()
+        public virtual StringTemplate GenRecognizer()
{
//JSystem.@out.println("### generate "+grammar.name+" recognizer");
// LOAD OUTPUT TEMPLATES
-            loadTemplates( language );
+            LoadTemplates( language );
if ( templates == null )
{
return null;
@@ -426,7 +427,7 @@ namespace Antlr3.Codegen
{
return null;
}
-            target.performGrammarAnalysis( this, grammar );
+            target.PerformGrammarAnalysis( this, grammar );


// some grammar analysis errors will not yield reliable DFA
@@ -468,9 +469,9 @@ namespace Antlr3.Codegen
// Verify action scopes are ok for target and dump actions into output
// Templates can say <actions.parser.header> for example.
var actions = grammar.Actions;
-            verifyActionScopesOkForTarget( actions );
+            VerifyActionScopesOkForTarget( actions );
// translate $x::y references
-            translateActionAttributeReferences( actions );
+            TranslateActionAttributeReferences( actions );
StringTemplate gateST = templates.GetInstanceOf( "actionGate" );
if ( filterMode )
{
@@ -543,7 +544,7 @@ namespace Antlr3.Codegen
grammar.getDefaultActionScope( grammar.type ) );

string targetAppropriateFileNameString =
-                target.getTargetStringLiteralFromString( grammar.FileName );
+                target.GetTargetStringLiteralFromString( grammar.FileName );
outputFileST.SetAttribute( "fileName", targetAppropriateFileNameString );
headerFileST.SetAttribute( "fileName", targetAppropriateFileNameString );
outputFileST.SetAttribute( "ANTLRVersion", tool.VERSION );
@@ -571,15 +572,15 @@ namespace Antlr3.Codegen
}
}

-            genTokenTypeConstants( recognizerST );
-            genTokenTypeConstants( outputFileST );
-            genTokenTypeConstants( headerFileST );
+            GenTokenTypeConstants( recognizerST );
+            GenTokenTypeConstants( outputFileST );
+            GenTokenTypeConstants( headerFileST );

if ( grammar.type != Grammar.LEXER )
{
-                genTokenTypeNames( recognizerST );
-                genTokenTypeNames( outputFileST );
-                genTokenTypeNames( headerFileST );
+                GenTokenTypeNames( recognizerST );
+                GenTokenTypeNames( outputFileST );
+                GenTokenTypeNames( headerFileST );
}

// Now that we know what synpreds are used, we can set into template
@@ -597,19 +598,19 @@ namespace Antlr3.Codegen
// WRITE FILES
try
{
-                target.genRecognizerFile( tool, this, grammar, outputFileST );
+                target.GenRecognizerFile( tool, this, grammar, outputFileST );
if ( templates.IsDefined( "headerFile" ) )
{
StringTemplate extST = templates.GetInstanceOf( "headerFileExtension" );
-                    target.genRecognizerHeaderFile( tool, this, grammar, headerFileST, extST.ToString() );
+                    target.GenRecognizerHeaderFile( tool, this, grammar, headerFileST, extST.ToString() );
}
// write out the vocab interchange file; used by antlr,
// does not change per target
-                StringTemplate tokenVocabSerialization = genTokenVocabOutput();
+                StringTemplate tokenVocabSerialization = GenTokenVocabOutput();
string vocabFileName = VocabFileName;
if ( vocabFileName != null )
{
-                    write( tokenVocabSerialization, vocabFileName );
+                    Write( tokenVocabSerialization, vocabFileName );
}
//JSystem.@out.println(outputFileST.getDOTForDependencyGraph(false));
}
@@ -631,12 +632,12 @@ namespace Antlr3.Codegen
*  '@headerfile:name {action}' or something.  Make sure the
*  target likes the scopes in action table.
*/
-        protected virtual void verifyActionScopesOkForTarget( IDictionary<string, IDictionary<string, object>> actions )
+        protected virtual void VerifyActionScopesOkForTarget( IDictionary<string, IDictionary<string, object>> actions )
{
foreach ( var action in actions )
{
string scope = action.Key;
-                if ( !target.isValidActionScope( grammar.type, scope ) )
+                if ( !target.IsValidActionScope( grammar.type, scope ) )
{
// get any action from the scope to get error location
var scopeActions = action.Value;
@@ -652,18 +653,18 @@ namespace Antlr3.Codegen
/** Actions may reference $x::y attributes, call translateAction on
*  each action and replace that action in the Map.
*/
-        protected virtual void translateActionAttributeReferences( IDictionary<string, IDictionary<string, object>> actions )
+        protected virtual void TranslateActionAttributeReferences( IDictionary<string, IDictionary<string, object>> actions )
{
foreach ( var action in actions )
{
string scope = action.Key;
var scopeActions = action.Value;
-                translateActionAttributeReferencesForSingleScope( null, scopeActions );
+                TranslateActionAttributeReferencesForSingleScope( null, scopeActions );
}
}

/** Use for translating rule @init{...} actions that have no scope */
-        protected internal virtual void translateActionAttributeReferencesForSingleScope(
+        protected internal virtual void TranslateActionAttributeReferencesForSingleScope(
Rule r,
IDictionary<string,object> scopeActions )
{
@@ -676,7 +677,7 @@ namespace Antlr3.Codegen
foreach ( string name in actionNameSet )
{
GrammarAST actionAST = (GrammarAST)scopeActions.get( name );
-                IList chunks = translateAction( ruleName, actionAST );
+                IList chunks = TranslateAction( ruleName, actionAST );
scopeActions[name] = chunks; // replace with translation
}
}
@@ -699,7 +700,7 @@ namespace Antlr3.Codegen
*  Like Grosch I implemented local FOLLOW sets that are combined at run-time
*  upon error to avoid parsing overhead.
*/
-        public virtual void generateLocalFOLLOW( GrammarAST referencedElementNode,
+        public virtual void GenerateLocalFollow( GrammarAST referencedElementNode,
string referencedElementName,
string enclosingRuleName,
int elementIndex )
@@ -751,7 +752,7 @@ namespace Antlr3.Codegen
for ( int j = 0; j < words.Length; j++ )
{
ulong w = words[j];
-                wordStrings[j] = target.getTarget64BitStringFromValue( w );
+                wordStrings[j] = target.GetTarget64BitStringFromValue( w );
}
recognizerST.SetAttribute( "bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
referencedElementName,
@@ -782,7 +783,7 @@ namespace Antlr3.Codegen
*
*  Regardless, the output file and header file get a copy of the DFAs.
*/
-        public virtual StringTemplate genLookaheadDecision( StringTemplate recognizerST,
+        public virtual StringTemplate GenLookaheadDecision( StringTemplate recognizerST,
DFA dfa )
{
StringTemplate decisionST;
@@ -803,7 +804,7 @@ namespace Antlr3.Codegen
headerFileST.SetAttribute( "cyclicDFAs", dfa );
decisionST = templates.GetInstanceOf( "dfaDecision" );
string description = dfa.NFADecisionStartState.Description;
-                description = target.getTargetStringLiteralFromString( description );
+                description = target.GetTargetStringLiteralFromString( description );
if ( description != null )
{
decisionST.SetAttribute( "description", description );
@@ -820,7 +821,7 @@ namespace Antlr3.Codegen
*  because if you get here, the state is super complicated and needs an
*  if-then-else.  This is used by the new DFA scheme created June 2006.
*/
-        public virtual StringTemplate generateSpecialState( DFAState s )
+        public virtual StringTemplate GenerateSpecialState( DFAState s )
{
StringTemplate stateST;
stateST = templates.GetInstanceOf( "cyclicDFAState" );
@@ -846,7 +847,7 @@ namespace Antlr3.Codegen
{
edgeST = templates.GetInstanceOf( "cyclicDFAEdge" );
StringTemplate exprST =
-                        genLabelExpr( templates, edge, 1 );
+                        GenLabelExpr( templates, edge, 1 );
edgeST.SetAttribute( "labelExpr", exprST );
}
edgeST.SetAttribute( "edgeNumber", i + 1 );
@@ -885,28 +886,28 @@ namespace Antlr3.Codegen
}

/** Generate an expression for traversing an edge. */
-        protected internal virtual StringTemplate genLabelExpr( StringTemplateGroup templates,
+        protected internal virtual StringTemplate GenLabelExpr( StringTemplateGroup templates,
Transition edge,
int k )
{
Label label = edge.label;
if ( label.IsSemanticPredicate )
{
-                return genSemanticPredicateExpr( templates, edge );
+                return GenSemanticPredicateExpr( templates, edge );
}
if ( label.IsSet )
{
-                return genSetExpr( templates, label.Set, k, true );
+                return GenSetExpr( templates, label.Set, k, true );
}
// must be simple label
StringTemplate eST = templates.GetInstanceOf( "lookaheadTest" );
-            eST.SetAttribute( "atom", getTokenTypeAsTargetLabel( label.Atom ) );
+            eST.SetAttribute( "atom", GetTokenTypeAsTargetLabel( label.Atom ) );
eST.SetAttribute( "atomAsInt", label.Atom );
eST.SetAttribute( "k", k );
return eST;
}

-        protected internal virtual StringTemplate genSemanticPredicateExpr( StringTemplateGroup templates,
+        protected internal virtual StringTemplate GenSemanticPredicateExpr( StringTemplateGroup templates,
Transition edge )
{
DFA dfa = ( (DFAState)edge.target ).dfa; // which DFA are we in
@@ -918,7 +919,7 @@ namespace Antlr3.Codegen
/** For intervals such as [3..3, 30..35], generate an expression that
*  tests the lookahead similar to LA(1)==3 || (LA(1)>=30&&LA(1)<=35)
*/
-        public virtual StringTemplate genSetExpr( StringTemplateGroup templates,
+        public virtual StringTemplate GenSetExpr( StringTemplateGroup templates,
IIntSet set,
int k,
bool partOfDFA )
@@ -951,16 +952,16 @@ namespace Antlr3.Codegen
if ( a == b )
{
eST = templates.GetInstanceOf( testSTName );
-                    eST.SetAttribute( "atom", getTokenTypeAsTargetLabel( a ) );
+                    eST.SetAttribute( "atom", GetTokenTypeAsTargetLabel( a ) );
eST.SetAttribute( "atomAsInt", a );
//eST.setAttribute("k",Utils.integer(k));
}
else
{
eST = templates.GetInstanceOf( testRangeSTName );
-                    eST.SetAttribute( "lower", getTokenTypeAsTargetLabel( a ) );
+                    eST.SetAttribute( "lower", GetTokenTypeAsTargetLabel( a ) );
eST.SetAttribute( "lowerAsInt", a );
-                    eST.SetAttribute( "upper", getTokenTypeAsTargetLabel( b ) );
+                    eST.SetAttribute( "upper", GetTokenTypeAsTargetLabel( b ) );
eST.SetAttribute( "upperAsInt", b );
eST.SetAttribute( "rangeNumber", rangeNumber );
}
@@ -977,7 +978,7 @@ namespace Antlr3.Codegen
*  code template.  This is not the token vocab interchange file, but
*  rather a list of token type ID needed by the recognizer.
*/
-        protected virtual void genTokenTypeConstants( StringTemplate code )
+        protected virtual void GenTokenTypeConstants( StringTemplate code )
{
// make constants for the token types
foreach ( string tokenID in grammar.TokenIDs )
@@ -995,14 +996,14 @@ namespace Antlr3.Codegen
/** Generate a token names table that maps token type to a printable
*  name: either the label like INT or the literal like "begin".
*/
-        protected virtual void genTokenTypeNames( StringTemplate code )
+        protected virtual void GenTokenTypeNames( StringTemplate code )
{
for ( int t = Label.MIN_TOKEN_TYPE; t <= grammar.MaxTokenType; t++ )
{
string tokenName = grammar.getTokenDisplayName( t );
if ( tokenName != null )
{
-                    tokenName = target.getTargetStringLiteralFromString( tokenName, true );
+                    tokenName = target.GetTargetStringLiteralFromString( tokenName, true );
code.SetAttribute( "tokenNames", tokenName );
}
}
@@ -1018,14 +1019,14 @@ namespace Antlr3.Codegen
*  be converted to the target languages literals.  For most C-derived
*  languages no translation is needed.
*/
-        public virtual string getTokenTypeAsTargetLabel( int ttype )
+        public virtual string GetTokenTypeAsTargetLabel( int ttype )
{
if ( grammar.type == Grammar.LEXER )
{
string name = grammar.getTokenDisplayName( ttype );
-                return target.getTargetCharLiteralFromANTLRCharLiteral( this, name );
+                return target.GetTargetCharLiteralFromANTLRCharLiteral( this, name );
}
-            return target.getTokenTypeAsTargetLabel( this, ttype );
+            return target.GetTokenTypeAsTargetLabel( this, ttype );
}

/** Generate a token vocab file with all the token names/types.  For example:
@@ -1035,7 +1036,7 @@ namespace Antlr3.Codegen
*
*  This is independent of the target language; used by antlr internally
*/
-        protected virtual StringTemplate genTokenVocabOutput()
+        protected virtual StringTemplate GenTokenVocabOutput()
{
StringTemplate vocabFileST =
new StringTemplate( vocabFilePattern,
@@ -1064,16 +1065,16 @@ namespace Antlr3.Codegen
return vocabFileST;
}

-        public virtual IList translateAction( string ruleName,
+        public virtual IList TranslateAction( string ruleName,
GrammarAST actionTree )
{
if ( actionTree.Type == ANTLRParser.ARG_ACTION )
{
-                return translateArgAction( ruleName, actionTree );
+                return TranslateArgAction( ruleName, actionTree );
}
ActionTranslator translator = new ActionTranslator( this, ruleName, actionTree );
IList chunks = translator.translateToChunks();
-            chunks = target.postProcessAction( chunks, actionTree.token );
+            chunks = target.PostProcessAction( chunks, actionTree.token );
return chunks;
}

@@ -1082,11 +1083,11 @@ namespace Antlr3.Codegen
*  of chunks, must cat together into a StringTemplate>.  Don't translate
*  to strings early as we need to eval templates in context.
*/
-        public virtual List<StringTemplate> translateArgAction( string ruleName,
+        public virtual List<StringTemplate> TranslateArgAction( string ruleName,
GrammarAST actionTree )
{
string actionText = actionTree.token.Text;
-            List<string> args = getListOfArgumentsFromAction( actionText, ',' );
+            List<string> args = GetListOfArgumentsFromAction( actionText, ',' );
List<StringTemplate> translatedArgs = new List<StringTemplate>();
foreach ( string arg in args )
{
@@ -1099,7 +1100,7 @@ namespace Antlr3.Codegen
actionToken,
actionTree.outerAltNum );
IList chunks = translator.translateToChunks();
-                    chunks = target.postProcessAction( chunks, actionToken );
+                    chunks = target.PostProcessAction( chunks, actionToken );
StringTemplate catST = new StringTemplate( templates, "<chunks>" );
catST.SetAttribute( "chunks", chunks );
templates.CreateStringTemplate();
@@ -1113,11 +1114,11 @@ namespace Antlr3.Codegen
return translatedArgs;
}

-        public static List<string> getListOfArgumentsFromAction( string actionText,
+        public static List<string> GetListOfArgumentsFromAction( string actionText,
int separatorChar )
{
List<string> args = new List<string>();
-            getListOfArgumentsFromAction( actionText, 0, -1, separatorChar, args );
+            GetListOfArgumentsFromAction( actionText, 0, -1, separatorChar, args );
return args;
}

@@ -1129,7 +1130,7 @@ namespace Antlr3.Codegen
*  convert to a list of arguments.  Allow nested square brackets etc...
*  Set separatorChar to ';' or ',' or whatever you want.
*/
-        public static int getListOfArgumentsFromAction( string actionText,
+        public static int GetListOfArgumentsFromAction( string actionText,
int start,
int targetChar,
int separatorChar,
@@ -1176,17 +1177,17 @@ namespace Antlr3.Codegen
p++;
break;
case '(':
-                    p = getListOfArgumentsFromAction( actionText, p + 1, ')', separatorChar, args );
+                    p = GetListOfArgumentsFromAction( actionText, p + 1, ')', separatorChar, args );
break;
case '{':
-                    p = getListOfArgumentsFromAction( actionText, p + 1, '}', separatorChar, args );
+                    p = GetListOfArgumentsFromAction( actionText, p + 1, '}', separatorChar, args );
break;
case '<':
if ( actionText.IndexOf( '>', p + 1 ) >= p )
{
// do we see a matching '>' ahead?  if so, hope it's a generic
// and not less followed by expr with greater than
-                        p = getListOfArgumentsFromAction( actionText, p + 1, '>', separatorChar, args );
+                        p = GetListOfArgumentsFromAction( actionText, p + 1, '>', separatorChar, args );
}
else
{
@@ -1194,7 +1195,7 @@ namespace Antlr3.Codegen
}
break;
case '[':
-                    p = getListOfArgumentsFromAction( actionText, p + 1, ']', separatorChar, args );
+                    p = GetListOfArgumentsFromAction( actionText, p + 1, ']', separatorChar, args );
break;
default:
if ( c == separatorChar && targetChar == -1 )
@@ -1225,7 +1226,7 @@ namespace Antlr3.Codegen
*  an action, translate it to the appropriate template constructor
*  from the templateLib. This translates a *piece* of the action.
*/
-        public virtual StringTemplate translateTemplateConstructor( string ruleName,
+        public virtual StringTemplate TranslateTemplateConstructor( string ruleName,
int outerAltNum,
IToken actionToken,
string templateActionText )
@@ -1285,7 +1286,7 @@ namespace Antlr3.Codegen
}


-        public virtual void issueInvalidScopeError( string x,
+        public virtual void IssueInvalidScopeError( string x,
string y,
Rule enclosingRule,
IToken actionToken,
@@ -1318,7 +1319,7 @@ namespace Antlr3.Codegen
}
}

-        public virtual void issueInvalidAttributeError( string x,
+        public virtual void IssueInvalidAttributeError( string x,
string y,
Rule enclosingRule,
IToken actionToken,
@@ -1377,7 +1378,7 @@ namespace Antlr3.Codegen

}

-        public virtual void issueInvalidAttributeError( string x,
+        public virtual void IssueInvalidAttributeError( string x,
Rule enclosingRule,
IToken actionToken,
int outerAltNum )
@@ -1424,36 +1425,42 @@ namespace Antlr3.Codegen

// M I S C

-        public virtual StringTemplateGroup getTemplates()
+        [Obsolete]
+        public virtual StringTemplateGroup GetTemplates()
{
return templates;
}

-        public virtual StringTemplateGroup getBaseTemplates()
+        [Obsolete]
+        public virtual StringTemplateGroup GetBaseTemplates()
{
return baseTemplates;
}

-        public virtual void setDebug( bool debug )
+        [Obsolete]
+        public virtual void SetDebug( bool debug )
{
this.debug = debug;
}

-        public virtual void setTrace( bool trace )
+        [Obsolete]
+        public virtual void SetTrace( bool trace )
{
this.trace = trace;
}

-        public virtual void setProfile( bool profile )
+        [Obsolete]
+        public virtual void SetProfile( bool profile )
{
this.profile = profile;
if ( profile )
{
-                setDebug( true ); // requires debug events
+                SetDebug( true ); // requires debug events
}
}

-        public virtual StringTemplate getRecognizerST()
+        [Obsolete]
+        public virtual StringTemplate GetRecognizerST()
{
return outputFileST;
}
@@ -1461,7 +1468,7 @@ namespace Antlr3.Codegen
/** Generate TParser.java and TLexer.java from T.g if combined, else
*  just use T.java as output regardless of type.
*/
-        public virtual string getRecognizerFileName( string name, int type )
+        public virtual string GetRecognizerFileName( string name, int type )
{
StringTemplate extST = templates.GetInstanceOf( "codeFileExtension" );
string recognizerName = grammar.getRecognizerName();
@@ -1480,7 +1487,7 @@ namespace Antlr3.Codegen
/** What is the name of the vocab file generated for this grammar?
*  Returns null if no .tokens file should be generated.
*/
-        public virtual string getVocabFileName()
+        public virtual string GetVocabFileName()
{
if ( grammar.IsBuiltFromString )
{
@@ -1489,7 +1496,7 @@ namespace Antlr3.Codegen
return grammar.name + VOCAB_FILE_EXTENSION;
}

-        public virtual void write( StringTemplate code, string fileName )
+        public virtual void Write( StringTemplate code, string fileName )
{
DateTime start = DateTime.Now;
TextWriter w = tool.getOutputFile( grammar, fileName );
@@ -1508,7 +1515,7 @@ namespace Antlr3.Codegen
*  containing an edge label such as 20..52330 (the resulting byte codes
*  would overflow the method 65k limit probably).
*/
-        protected internal virtual bool canGenerateSwitch( DFAState s )
+        protected internal virtual bool CanGenerateSwitch( DFAState s )
{
if ( !GENERATE_SWITCHES_WHEN_POSSIBLE )
{
@@ -1554,7 +1561,7 @@ namespace Antlr3.Codegen
*  target language, however, label ::= <ID><INT> is probably ok in
*  all languages we care about.
*/
-        public virtual string createUniqueLabel( string name )
+        public virtual string CreateUniqueLabel( string name )
{
return name + ( uniqueLabelNumber++ );
//return new StringBuffer()
diff --git a/Antlr3/Codegen/Target.cs b/Antlr3/Codegen/Target.cs
index 7d9870c..a2205d0 100644
--- a/Antlr3/Codegen/Target.cs
+++ b/Antlr3/Codegen/Target.cs
@@ -91,17 +91,17 @@ namespace Antlr3.Codegen
targetCharValueEscape['"'] = "\\\"";
}

-        protected internal virtual void genRecognizerFile( AntlrTool tool,
+        protected internal virtual void GenRecognizerFile( AntlrTool tool,
CodeGenerator generator,
Grammar grammar,
StringTemplate outputFileST )
{
string fileName =
-                generator.getRecognizerFileName( grammar.name, grammar.type );
-            generator.write( outputFileST, fileName );
+                generator.GetRecognizerFileName( grammar.name, grammar.type );
+            generator.Write( outputFileST, fileName );
}

-        protected internal virtual void genRecognizerHeaderFile( AntlrTool tool,
+        protected internal virtual void GenRecognizerHeaderFile( AntlrTool tool,
CodeGenerator generator,
Grammar grammar,
StringTemplate headerFileST,
@@ -110,7 +110,7 @@ namespace Antlr3.Codegen
// no header file by default
}

-        protected internal virtual void performGrammarAnalysis( CodeGenerator generator,
+        protected internal virtual void PerformGrammarAnalysis( CodeGenerator generator,
Grammar grammar )
{
// Build NFAs from the grammar AST
@@ -126,7 +126,7 @@ namespace Antlr3.Codegen
*  moment so targets can add template actions w/o having to recompile
*  ANTLR.
*/
-        public virtual bool isValidActionScope( int grammarType, string scope )
+        public virtual bool IsValidActionScope( int grammarType, string scope )
{
switch ( grammarType )
{
@@ -163,7 +163,7 @@ namespace Antlr3.Codegen
}

/** Target must be able to override the labels used for token types */
-        public virtual string getTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
+        public virtual string GetTokenTypeAsTargetLabel( CodeGenerator generator, int ttype )
{
string name = generator.grammar.getTokenDisplayName( ttype );
// If name is a literal, return the token type instead
@@ -183,7 +183,7 @@ namespace Antlr3.Codegen
*
*  Expect single quotes around the incoming literal.
*/
-        public virtual string getTargetCharLiteralFromANTLRCharLiteral(
+        public virtual string GetTargetCharLiteralFromANTLRCharLiteral(
CodeGenerator generator,
string literal )
{
@@ -231,7 +231,7 @@ namespace Antlr3.Codegen
*  cannot handle both \" and " without a lot of messing around.
*
*/
-        public virtual string getTargetStringLiteralFromANTLRStringLiteral(
+        public virtual string GetTargetStringLiteralFromANTLRStringLiteral(
CodeGenerator generator,
string literal )
{
@@ -329,7 +329,7 @@ namespace Antlr3.Codegen
*
*  depending on the quoted arg.
*/
-        public virtual string getTargetStringLiteralFromString( string s, bool quoted )
+        public virtual string GetTargetStringLiteralFromString( string s, bool quoted )
{
if ( s == null )
{
@@ -361,15 +361,15 @@ namespace Antlr3.Codegen
return buf.ToString();
}

-        public virtual string getTargetStringLiteralFromString( string s )
+        public virtual string GetTargetStringLiteralFromString( string s )
{
-            return getTargetStringLiteralFromString( s, false );
+            return GetTargetStringLiteralFromString( s, false );
}

/** Convert long to 0xNNNNNNNNNNNNNNNN by default for spitting out
*  with bitsets.  I.e., convert bytes to hex string.
*/
-        public virtual string getTarget64BitStringFromValue( ulong word )
+        public virtual string GetTarget64BitStringFromValue( ulong word )
{
int numHexDigits = 8 * 2;
StringBuilder buf = new StringBuilder( numHexDigits + 2 );
@@ -387,7 +387,7 @@ namespace Antlr3.Codegen
return buf.ToString();
}

-        public virtual string encodeIntAsCharEscape( int v )
+        public virtual string EncodeIntAsCharEscape( int v )
{
if ( v <= 127 )
{
@@ -401,7 +401,7 @@ namespace Antlr3.Codegen
/** Some targets only support ASCII or 8-bit chars/strings.  For example,
*  C++ will probably want to return 0xFF here.
*/
-        public virtual int getMaxCharValue( CodeGenerator generator )
+        public virtual int GetMaxCharValue( CodeGenerator generator )
{
return Label.MAX_CHAR_VALUE;
}
@@ -409,7 +409,7 @@ namespace Antlr3.Codegen
/** Give target a chance to do some postprocessing on actions.
*  Python for example will have to fix the indention.
*/
-        public virtual IList postProcessAction( IList chunks, IToken actionToken )
+        public virtual IList PostProcessAction( IList chunks, IToken actionToken )
{
return chunks;
}
diff --git a/Antlr3/Grammars/ActionTranslator.cs b/Antlr3/Grammars/ActionTranslator.cs
index e0a1f60..a695022 100644
--- a/Antlr3/Grammars/ActionTranslator.cs
+++ b/Antlr3/Grammars/ActionTranslator.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ActionTranslator.g3 2009-04-10 15:22:09
+// $ANTLR 3.1.2 Grammars\\ActionTranslator.g3 2009-04-16 18:07:28

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -1175,7 +1175,7 @@ public partial class ActionTranslator : Lexer
{

chunks.Add(Text);
-						generator.issueInvalidScopeError((x!=null?x.Text:null),(y!=null?y.Text:null),
+						generator.IssueInvalidScopeError((x!=null?x.Text:null),(y!=null?y.Text:null),
enclosingRule,actionToken,
outerAltNum);

@@ -1523,7 +1523,7 @@ public partial class ActionTranslator : Lexer
ruleName = enclosingRule.name;
}
StringTemplate st =
-								generator.translateTemplateConstructor(ruleName,
+								generator.TranslateTemplateConstructor(ruleName,
outerAltNum,
actionToken,
action);
@@ -1678,7 +1678,7 @@ public partial class ActionTranslator : Lexer

string action = Text.Substring( 1, Text.Length - 1 );
StringTemplate st =
-								generator.translateTemplateConstructor(enclosingRule.name,
+								generator.TranslateTemplateConstructor(enclosingRule.name,
outerAltNum,
actionToken,
action);
@@ -2127,7 +2127,7 @@ public partial class ActionTranslator : Lexer
{

chunks.Add(Text);
-							generator.issueInvalidAttributeError((x!=null?x.Text:null),(y!=null?y.Text:null),
+							generator.IssueInvalidAttributeError((x!=null?x.Text:null),(y!=null?y.Text:null),
enclosingRule,actionToken,
outerAltNum);

@@ -2164,7 +2164,7 @@ public partial class ActionTranslator : Lexer
{

chunks.Add(Text);
-							generator.issueInvalidAttributeError((x!=null?x.Text:null),
+							generator.IssueInvalidAttributeError((x!=null?x.Text:null),
enclosingRule,actionToken,
outerAltNum);

diff --git a/Antlr3/Grammars/ActionTranslator.g3 b/Antlr3/Grammars/ActionTranslator.g3
index e8b7970..db2c8bb 100644
--- a/Antlr3/Grammars/ActionTranslator.g3
+++ b/Antlr3/Grammars/ActionTranslator.g3
@@ -551,7 +551,7 @@ ERROR_SCOPED_XY
:	'$' x=ID '::' y=ID
{
chunks.Add(Text);
-		generator.issueInvalidScopeError($x.text,$y.text,
+		generator.IssueInvalidScopeError($x.text,$y.text,
enclosingRule,actionToken,
outerAltNum);
}
@@ -621,7 +621,7 @@ TEMPLATE_INSTANCE
ruleName = enclosingRule.name;
}
StringTemplate st =
-				generator.translateTemplateConstructor(ruleName,
+				generator.TranslateTemplateConstructor(ruleName,
outerAltNum,
actionToken,
action);
@@ -639,7 +639,7 @@ INDIRECT_TEMPLATE_INSTANCE
{
string action = $text.Substring( 1, $text.Length - 1 );
StringTemplate st =
-				generator.translateTemplateConstructor(enclosingRule.name,
+				generator.TranslateTemplateConstructor(enclosingRule.name,
outerAltNum,
actionToken,
action);
@@ -713,7 +713,7 @@ ERROR_XY
:	'$' x=ID '.' y=ID
{
chunks.Add(Text);
-			generator.issueInvalidAttributeError($x.text,$y.text,
+			generator.IssueInvalidAttributeError($x.text,$y.text,
enclosingRule,actionToken,
outerAltNum);
}
@@ -723,7 +723,7 @@ ERROR_X
:	'$' x=ID
{
chunks.Add(Text);
-			generator.issueInvalidAttributeError($x.text,
+			generator.IssueInvalidAttributeError($x.text,
enclosingRule,actionToken,
outerAltNum);
}
diff --git a/Antlr3/Grammars/CodeGenTreeWalker.cs b/Antlr3/Grammars/CodeGenTreeWalker.cs
index 3e2c431..9e910ad 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalker.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-16 17:15:31
+// $ANTLR 3.1.2 Grammars\\CodeGenTreeWalker.g3 2009-04-16 18:07:30

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -1034,7 +1034,7 @@ public partial class CodeGenTreeWalker : TreeParser
StringTemplateGroup saveGroup = templates;
if ( ruleDescr.isSynPred )
{
-				templates = generator.getBaseTemplates();
+				templates = generator.GetBaseTemplates();
}

string description = string.Empty;
@@ -1327,7 +1327,7 @@ public partial class CodeGenTreeWalker : TreeParser
grammar.grammarTreeToString((GrammarAST)((GrammarAST)retval.start).GetFirstChildWithType(BLOCK),
false);
description =
-									generator.target.getTargetStringLiteralFromString(description);
+									generator.target.GetTargetStringLiteralFromString(description);
(b!=null?b.code:default(StringTemplate)).SetAttribute("description", description);
// do not generate lexer rules in combined grammar
string stName = null;
@@ -1414,11 +1414,11 @@ public partial class CodeGenTreeWalker : TreeParser
else
{
description = grammar.grammarTreeToString(((GrammarAST)retval.start),false);
-									description = generator.target.getTargetStringLiteralFromString(description);
+									description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);
}
Rule theRule = grammar.getRule(currentRuleName);
-								generator.translateActionAttributeReferencesForSingleScope(
+								generator.TranslateActionAttributeReferencesForSingleScope(
theRule,
theRule.Actions
);
@@ -1744,7 +1744,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( dfa != null )
{
retval.code = templates.GetInstanceOf(blockTemplateName);
-					decision = generator.genLookaheadDecision(recognizerST,dfa);
+					decision = generator.GenLookaheadDecision(recognizerST,dfa);
retval.code.SetAttribute("decision", decision);
retval.code.SetAttribute("decisionNumber", dfa.DecisionNumber);
retval.code.SetAttribute("maxK",dfa.MaxLookaheadDepth);
@@ -2072,10 +2072,10 @@ public partial class CodeGenTreeWalker : TreeParser
setcode.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
{
-								generator.generateLocalFOLLOW(s,"set",currentRuleName,i);
+								generator.GenerateLocalFollow(s,"set",currentRuleName,i);
}
setcode.SetAttribute("s",
-								generator.genSetExpr(templates,s.SetValue,1,false));
+								generator.GenSetExpr(templates,s.SetValue,1,false));
StringTemplate altcode=templates.GetInstanceOf("alt");
altcode.SetAttribute("elements.{el,line,pos}",
setcode,
@@ -2329,7 +2329,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							List chunks = generator.translateAction(currentRuleName,ACTION2);
+							List chunks = generator.TranslateAction(currentRuleName,ACTION2);
ruleST.SetAttribute("exceptions.{decl,action}",(ARG_ACTION3!=null?ARG_ACTION3.Text:null),chunks);

}
@@ -2370,7 +2370,7 @@ public partial class CodeGenTreeWalker : TreeParser
if ( state.backtracking == 0 )
{

-							List chunks = generator.translateAction(currentRuleName,ACTION4);
+							List chunks = generator.TranslateAction(currentRuleName,ACTION4);
ruleST.SetAttribute("finally",chunks);

}
@@ -2431,7 +2431,7 @@ public partial class CodeGenTreeWalker : TreeParser
currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
}
string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
-				description = generator.target.getTargetStringLiteralFromString(description);
+				description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);
retval.code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
if ( !currentAltHasASTRewrite && grammar.BuildAST )
@@ -2675,8 +2675,8 @@ public partial class CodeGenTreeWalker : TreeParser
{

retval.code = templates.GetInstanceOf("charRangeRef");
-								string low = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(a!=null?a.Text:null));
-								string high = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(b!=null?b.Text:null));
+								string low = generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,(a!=null?a.Text:null));
+								string high = generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,(b!=null?b.Text:null));
retval.code.SetAttribute("a", low);
retval.code.SetAttribute("b", high);
if ( label!=null )
@@ -2794,8 +2794,8 @@ public partial class CodeGenTreeWalker : TreeParser
{

retval.code = templates.GetInstanceOf("validateSemanticPredicate");
-								retval.code.SetAttribute("pred", generator.translateAction(currentRuleName,sp));
-								string description = generator.target.getTargetStringLiteralFromString((sp!=null?sp.Text:null));
+								retval.code.SetAttribute("pred", generator.TranslateAction(currentRuleName,sp));
+								string description = generator.target.GetTargetStringLiteralFromString((sp!=null?sp.Text:null));
retval.code.SetAttribute("description", description);

}
@@ -2975,7 +2975,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

retval.code = templates.GetInstanceOf("execAction");
-								retval.code.SetAttribute("action", generator.translateAction(currentRuleName,act));
+								retval.code.SetAttribute("action", generator.TranslateAction(currentRuleName,act));

}

@@ -2989,7 +2989,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

retval.code = templates.GetInstanceOf("execForcedAction");
-								retval.code.SetAttribute("action", generator.translateAction(currentRuleName,act2));
+								retval.code.SetAttribute("action", generator.TranslateAction(currentRuleName,act2));

}

@@ -3196,12 +3196,12 @@ public partial class CodeGenTreeWalker : TreeParser
(GrammarAST)n.GetChild(0),
astSuffix,
labelText);
-							code.SetAttribute("s",generator.genSetExpr(templates,elements,1,false));
+							code.SetAttribute("s",generator.GenSetExpr(templates,elements,1,false));
int i = ((TokenWithIndex)n.Token).TokenIndex;
code.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
{
-								generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
+								generator.GenerateLocalFollow(n,"set",currentRuleName,i);
}

}
@@ -3378,7 +3378,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
-							description = generator.target.getTargetStringLiteralFromString(description);
+							description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

}
@@ -3754,12 +3754,12 @@ public partial class CodeGenTreeWalker : TreeParser
}

if ( rarg!=null ) {
-									List args = generator.translateAction(currentRuleName,rarg);
+									List args = generator.TranslateAction(currentRuleName,rarg);
retval.code.SetAttribute("args", args);
}
int i = ((TokenWithIndex)r.Token).TokenIndex;
retval.code.SetAttribute("elementIndex", i);
-								generator.generateLocalFOLLOW(r,(r!=null?r.Text:null),currentRuleName,i);
+								generator.GenerateLocalFollow(r,(r!=null?r.Text:null),currentRuleName,i);
r.code = retval.code;

}
@@ -3841,7 +3841,7 @@ public partial class CodeGenTreeWalker : TreeParser
}
if ( targ!=null )
{
-											List args = generator.translateAction(currentRuleName,targ);
+											List args = generator.TranslateAction(currentRuleName,targ);
retval.code.SetAttribute("args", args);
}
}
@@ -3854,7 +3854,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
retval.code = getTokenElementST("tokenRef", (t!=null?t.Text:null), t, astSuffix, labelText);
string tokenLabel =
-										generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
+										generator.GetTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
retval.code.SetAttribute("token",tokenLabel);
if ( !currentAltHasASTRewrite && t.terminalOptions!=null )
{
@@ -3862,7 +3862,7 @@ public partial class CodeGenTreeWalker : TreeParser
}
int i = ((TokenWithIndex)t.Token).TokenIndex;
retval.code.SetAttribute("elementIndex", i);
-									generator.generateLocalFOLLOW(t,tokenLabel,currentRuleName,i);
+									generator.GenerateLocalFollow(t,tokenLabel,currentRuleName,i);
}
t.code = retval.code;

@@ -3881,7 +3881,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
retval.code = templates.GetInstanceOf("charRef");
retval.code.SetAttribute("char",
-									   generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,(c!=null?c.Text:null)));
+									   generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,(c!=null?c.Text:null)));
if ( label!=null )
{
retval.code.SetAttribute("label", labelText);
@@ -3889,14 +3889,14 @@ public partial class CodeGenTreeWalker : TreeParser
}
else { // else it's a token type reference
retval.code = getTokenElementST("tokenRef", "char_literal", c, astSuffix, labelText);
-									string tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType((c!=null?c.Text:null)));
+									string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.getTokenType((c!=null?c.Text:null)));
retval.code.SetAttribute("token",tokenLabel);
if ( c.terminalOptions!=null ) {
retval.code.SetAttribute("hetero",c.terminalOptions[Grammar.defaultTokenOption]);
}
int i = ((TokenWithIndex)c.Token).TokenIndex;
retval.code.SetAttribute("elementIndex", i);
-									generator.generateLocalFOLLOW(c,tokenLabel,currentRuleName,i);
+									generator.GenerateLocalFollow(c,tokenLabel,currentRuleName,i);
}

}
@@ -3914,7 +3914,7 @@ public partial class CodeGenTreeWalker : TreeParser
{
retval.code = templates.GetInstanceOf("lexerStringRef");
retval.code.SetAttribute("string",
-										generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,(s!=null?s.Text:null)));
+										generator.target.GetTargetStringLiteralFromANTLRStringLiteral(generator,(s!=null?s.Text:null)));
if ( label!=null )
{
retval.code.SetAttribute("label", labelText);
@@ -3924,7 +3924,7 @@ public partial class CodeGenTreeWalker : TreeParser
{ // else it's a token type reference
retval.code = getTokenElementST("tokenRef", "string_literal", s, astSuffix, labelText);
string tokenLabel =
-										generator.getTokenTypeAsTargetLabel(grammar.getTokenType((s!=null?s.Text:null)));
+										generator.GetTokenTypeAsTargetLabel(grammar.getTokenType((s!=null?s.Text:null)));
retval.code.SetAttribute("token",tokenLabel);
if ( s.terminalOptions!=null )
{
@@ -3932,7 +3932,7 @@ public partial class CodeGenTreeWalker : TreeParser
}
int i = ((TokenWithIndex)s.Token).TokenIndex;
retval.code.SetAttribute("elementIndex", i);
-									generator.generateLocalFOLLOW(s,tokenLabel,currentRuleName,i);
+									generator.GenerateLocalFollow(s,tokenLabel,currentRuleName,i);
}

}
@@ -4115,9 +4115,9 @@ public partial class CodeGenTreeWalker : TreeParser
code.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
{
-								generator.generateLocalFOLLOW(s,"set",currentRuleName,i);
+								generator.GenerateLocalFollow(s,"set",currentRuleName,i);
}
-							code.SetAttribute("s", generator.genSetExpr(templates,s.SetValue,1,false));
+							code.SetAttribute("s", generator.GenSetExpr(templates,s.SetValue,1,false));

}

@@ -4355,11 +4355,11 @@ public partial class CodeGenTreeWalker : TreeParser
if ( pred!=null )
{
//predText = #pred.getText();
-											predChunks = generator.translateAction(currentRuleName,pred);
+											predChunks = generator.TranslateAction(currentRuleName,pred);
}
string description =
grammar.grammarTreeToString(r,false);
-										description = generator.target.getTargetStringLiteralFromString(description);
+										description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("alts.{pred,alt,description}",
predChunks,
alt,
@@ -4927,7 +4927,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
-								description = generator.target.getTargetStringLiteralFromString(description);
+								description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

}
@@ -4955,7 +4955,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
-								description = generator.target.getTargetStringLiteralFromString(description);
+								description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

}
@@ -4983,7 +4983,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
-								description = generator.target.getTargetStringLiteralFromString(description);
+								description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

}
@@ -5103,7 +5103,7 @@ public partial class CodeGenTreeWalker : TreeParser
{

string description = grammar.grammarTreeToString(((GrammarAST)retval.start), false);
-							description = generator.target.getTargetStringLiteralFromString(description);
+							description = generator.target.GetTargetStringLiteralFromString(description);
retval.code.SetAttribute("description", description);

}
@@ -5338,12 +5338,12 @@ public partial class CodeGenTreeWalker : TreeParser
retval.code.SetAttribute("hetero", hetero);
if ( arg!=null )
{
-									List args = generator.translateAction(currentRuleName,arg);
+									List args = generator.TranslateAction(currentRuleName,arg);
retval.code.SetAttribute("args", args);
}
retval.code.SetAttribute("elementIndex", ((TokenWithIndex)((GrammarAST)retval.start).Token).TokenIndex);
int ttype = grammar.getTokenType(tokenName);
-								string tok = generator.getTokenTypeAsTargetLabel(ttype);
+								string tok = generator.GetTokenTypeAsTargetLabel(ttype);
retval.code.SetAttribute("token", tok);
if ( grammar.getTokenType(tokenName)==Label.INVALID )
{
@@ -5436,7 +5436,7 @@ public partial class CodeGenTreeWalker : TreeParser

// actions in rewrite rules yield a tree object
string actText = (ACTION23!=null?ACTION23.Text:null);
-								List chunks = generator.translateAction(currentRuleName,ACTION23);
+								List chunks = generator.TranslateAction(currentRuleName,ACTION23);
retval.code = templates.GetInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
retval.code.SetAttribute("action", chunks);

@@ -5583,7 +5583,7 @@ public partial class CodeGenTreeWalker : TreeParser
else if ( ind!=null )
{ // must be %({expr})(args)
code = templates.GetInstanceOf("rewriteIndirectTemplate");
-										List chunks=generator.translateAction(currentRuleName,ind);
+										List chunks=generator.TranslateAction(currentRuleName,ind);
code.SetAttribute("expr", chunks);
}

@@ -5622,7 +5622,7 @@ public partial class CodeGenTreeWalker : TreeParser
// because actions like %foo(name={$ID.text}) aren't
// broken up yet into trees.
a.outerAltNum = this.outerAltNum;
-														List chunks = generator.translateAction(currentRuleName,a);
+														List chunks = generator.TranslateAction(currentRuleName,a);
code.SetAttribute("args.{name,value}", (arg!=null?arg.Text:null), chunks);

}
@@ -5667,7 +5667,7 @@ public partial class CodeGenTreeWalker : TreeParser

string sl = (DOUBLE_QUOTE_STRING_LITERAL24!=null?DOUBLE_QUOTE_STRING_LITERAL24.Text:null);
string t = sl.Substring( 1, sl.Length - 2 ); // strip quotes
-											t = generator.target.getTargetStringLiteralFromString(t);
+											t = generator.target.GetTargetStringLiteralFromString(t);
code.SetAttribute("template",t);

}
@@ -5683,7 +5683,7 @@ public partial class CodeGenTreeWalker : TreeParser

string sl = (DOUBLE_ANGLE_STRING_LITERAL25!=null?DOUBLE_ANGLE_STRING_LITERAL25.Text:null);
string t = sl.Substring( 2, sl.Length - 4 ); // strip double angle quotes
-											t = generator.target.getTargetStringLiteralFromString(t);
+											t = generator.target.GetTargetStringLiteralFromString(t);
code.SetAttribute("template",t);

}
@@ -5709,7 +5709,7 @@ public partial class CodeGenTreeWalker : TreeParser
act.outerAltNum = this.outerAltNum;
code =templates.GetInstanceOf("rewriteAction");
code.SetAttribute("action",
-												  generator.translateAction(currentRuleName,act));
+												  generator.TranslateAction(currentRuleName,act));

}

diff --git a/Antlr3/Grammars/CodeGenTreeWalker.g3 b/Antlr3/Grammars/CodeGenTreeWalker.g3
index ab88d9f..c8e2fc9 100644
--- a/Antlr3/Grammars/CodeGenTreeWalker.g3
+++ b/Antlr3/Grammars/CodeGenTreeWalker.g3
@@ -208,7 +208,7 @@ rule returns [StringTemplate code=null]
StringTemplateGroup saveGroup = templates;
if ( ruleDescr.isSynPred )
{
-		templates = generator.getBaseTemplates();
+		templates = generator.GetBaseTemplates();
}

string description = string.Empty;
@@ -228,7 +228,7 @@ rule returns [StringTemplate code=null]
grammar.grammarTreeToString((GrammarAST)$start.GetFirstChildWithType(BLOCK),
false);
description =
-					generator.target.getTargetStringLiteralFromString(description);
+					generator.target.GetTargetStringLiteralFromString(description);
$b.code.SetAttribute("description", description);
// do not generate lexer rules in combined grammar
string stName = null;
@@ -289,11 +289,11 @@ rule returns [StringTemplate code=null]
else
{
description = grammar.grammarTreeToString($start,false);
-					description = generator.target.getTargetStringLiteralFromString(description);
+					description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
Rule theRule = grammar.getRule(currentRuleName);
-				generator.translateActionAttributeReferencesForSingleScope(
+				generator.TranslateActionAttributeReferencesForSingleScope(
theRule,
theRule.Actions
);
@@ -337,7 +337,7 @@ options { k=1; }
if ( $dfa != null )
{
$code = templates.GetInstanceOf($blockTemplateName);
-			decision = generator.genLookaheadDecision(recognizerST,$dfa);
+			decision = generator.GenLookaheadDecision(recognizerST,$dfa);
$code.SetAttribute("decision", decision);
$code.SetAttribute("decisionNumber", $dfa.DecisionNumber);
$code.SetAttribute("maxK",$dfa.MaxLookaheadDepth);
@@ -422,10 +422,10 @@ setBlock returns [StringTemplate code=null]
setcode.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
{
-				generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
+				generator.GenerateLocalFollow($s,"set",currentRuleName,i);
}
setcode.SetAttribute("s",
-				generator.genSetExpr(templates,$s.SetValue,1,false));
+				generator.GenSetExpr(templates,$s.SetValue,1,false));
StringTemplate altcode=templates.GetInstanceOf("alt");
altcode.SetAttribute("elements.{el,line,pos}",
setcode,
@@ -455,7 +455,7 @@ exceptionGroup[StringTemplate ruleST]
exceptionHandler[StringTemplate ruleST]
:	^('catch' ARG_ACTION ACTION)
{
-			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			List chunks = generator.TranslateAction(currentRuleName,$ACTION);
$ruleST.SetAttribute("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
}
;
@@ -463,7 +463,7 @@ exceptionHandler[StringTemplate ruleST]
finallyClause[StringTemplate ruleST]
:	^('finally' ACTION)
{
-			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			List chunks = generator.TranslateAction(currentRuleName,$ACTION);
$ruleST.SetAttribute("finally",chunks);
}
;
@@ -496,7 +496,7 @@ alternative returns [StringTemplate code]
currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
}
string description = grammar.grammarTreeToString($start, false);
-		description = generator.target.getTargetStringLiteralFromString(description);
+		description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
$code.SetAttribute("treeLevel", rewriteTreeNestingLevel);
if ( !currentAltHasASTRewrite && grammar.BuildAST )
@@ -548,8 +548,8 @@ options { k=1; }
|	^(CHAR_RANGE a=CHAR_LITERAL b=CHAR_LITERAL)
{
$code = templates.GetInstanceOf("charRangeRef");
-			string low = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
-			string high = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
+			string low = generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
+			string high = generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
$code.SetAttribute("a", low);
$code.SetAttribute("b", high);
if ( label!=null )
@@ -573,8 +573,8 @@ options { k=1; }
|   (sp=SEMPRED|sp=GATED_SEMPRED)
{
$code = templates.GetInstanceOf("validateSemanticPredicate");
-			$code.SetAttribute("pred", generator.translateAction(currentRuleName,$sp));
-			string description = generator.target.getTargetStringLiteralFromString($sp.text);
+			$code.SetAttribute("pred", generator.TranslateAction(currentRuleName,$sp));
+			string description = generator.target.GetTargetStringLiteralFromString($sp.text);
$code.SetAttribute("description", description);
}

@@ -591,12 +591,12 @@ element_action returns [StringTemplate code=null]
:	act=ACTION
{
$code = templates.GetInstanceOf("execAction");
-			$code.SetAttribute("action", generator.translateAction(currentRuleName,$act));
+			$code.SetAttribute("action", generator.TranslateAction(currentRuleName,$act));
}
|	act2=FORCED_ACTION
{
$code = templates.GetInstanceOf("execForcedAction");
-			$code.SetAttribute("action", generator.translateAction(currentRuleName,$act2));
+			$code.SetAttribute("action", generator.TranslateAction(currentRuleName,$act2));
}
;

@@ -653,12 +653,12 @@ notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [String
(GrammarAST)$n.GetChild(0),
astSuffix,
labelText);
-			$code.SetAttribute("s",generator.genSetExpr(templates,elements,1,false));
+			$code.SetAttribute("s",generator.GenSetExpr(templates,elements,1,false));
int i = ((TokenWithIndex)n.Token).TokenIndex;
$code.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
{
-				generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
+				generator.GenerateLocalFollow(n,"set",currentRuleName,i);
}
}
;
@@ -685,7 +685,7 @@ ebnf returns [StringTemplate code=null]
)
{
string description = grammar.grammarTreeToString($start, false);
-			description = generator.target.getTargetStringLiteralFromString(description);
+			description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
;
@@ -813,12 +813,12 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}

if ( $rarg!=null ) {
-				List args = generator.translateAction(currentRuleName,$rarg);
+				List args = generator.TranslateAction(currentRuleName,$rarg);
$code.SetAttribute("args", args);
}
int i = ((TokenWithIndex)r.Token).TokenIndex;
$code.SetAttribute("elementIndex", i);
-			generator.generateLocalFOLLOW($r,$r.text,currentRuleName,i);
+			generator.GenerateLocalFollow($r,$r.text,currentRuleName,i);
$r.code = $code;
}

@@ -865,7 +865,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
if ( $targ!=null )
{
-						List args = generator.translateAction(currentRuleName,$targ);
+						List args = generator.TranslateAction(currentRuleName,$targ);
$code.SetAttribute("args", args);
}
}
@@ -878,7 +878,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
{
$code = getTokenElementST("tokenRef", $t.text, $t, astSuffix, labelText);
string tokenLabel =
-					generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
+					generator.GetTokenTypeAsTargetLabel(grammar.getTokenType(t.Text));
$code.SetAttribute("token",tokenLabel);
if ( !currentAltHasASTRewrite && $t.terminalOptions!=null )
{
@@ -886,7 +886,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
int i = ((TokenWithIndex)$t.Token).TokenIndex;
$code.SetAttribute("elementIndex", i);
-				generator.generateLocalFOLLOW($t,tokenLabel,currentRuleName,i);
+				generator.GenerateLocalFollow($t,tokenLabel,currentRuleName,i);
}
$t.code = $code;
}
@@ -897,7 +897,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
{
$code = templates.GetInstanceOf("charRef");
$code.SetAttribute("char",
-				   generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
+				   generator.target.GetTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
if ( label!=null )
{
$code.SetAttribute("label", labelText);
@@ -905,14 +905,14 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
else { // else it's a token type reference
$code = getTokenElementST("tokenRef", "char_literal", $c, astSuffix, labelText);
-				string tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType($c.text));
+				string tokenLabel = generator.GetTokenTypeAsTargetLabel(grammar.getTokenType($c.text));
$code.SetAttribute("token",tokenLabel);
if ( $c.terminalOptions!=null ) {
$code.SetAttribute("hetero",$c.terminalOptions[Grammar.defaultTokenOption]);
}
int i = ((TokenWithIndex)$c.Token).TokenIndex;
$code.SetAttribute("elementIndex", i);
-				generator.generateLocalFOLLOW($c,tokenLabel,currentRuleName,i);
+				generator.GenerateLocalFollow($c,tokenLabel,currentRuleName,i);
}
}

@@ -922,7 +922,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
{
$code = templates.GetInstanceOf("lexerStringRef");
$code.SetAttribute("string",
-					generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
+					generator.target.GetTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
if ( label!=null )
{
$code.SetAttribute("label", labelText);
@@ -932,7 +932,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
{ // else it's a token type reference
$code = getTokenElementST("tokenRef", "string_literal", $s, astSuffix, labelText);
string tokenLabel =
-					generator.getTokenTypeAsTargetLabel(grammar.getTokenType($s.text));
+					generator.GetTokenTypeAsTargetLabel(grammar.getTokenType($s.text));
$code.SetAttribute("token",tokenLabel);
if ( $s.terminalOptions!=null )
{
@@ -940,7 +940,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
}
int i = ((TokenWithIndex)$s.Token).TokenIndex;
$code.SetAttribute("elementIndex", i);
-				generator.generateLocalFOLLOW($s,tokenLabel,currentRuleName,i);
+				generator.GenerateLocalFollow($s,tokenLabel,currentRuleName,i);
}
}

@@ -978,9 +978,9 @@ set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
$code.SetAttribute("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
{
-				generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
+				generator.GenerateLocalFollow($s,"set",currentRuleName,i);
}
-			$code.SetAttribute("s", generator.genSetExpr(templates,$s.SetValue,1,false));
+			$code.SetAttribute("s", generator.GenSetExpr(templates,$s.SetValue,1,false));
}
;

@@ -1052,11 +1052,11 @@ rewrite returns [StringTemplate code=null]
if ( $pred!=null )
{
//predText = #pred.getText();
-					predChunks = generator.translateAction(currentRuleName,$pred);
+					predChunks = generator.TranslateAction(currentRuleName,$pred);
}
string description =
grammar.grammarTreeToString($r,false);
-				description = generator.target.getTargetStringLiteralFromString(description);
+				description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("alts.{pred,alt,description}",
predChunks,
alt,
@@ -1143,21 +1143,21 @@ rewrite_ebnf returns [StringTemplate code=null]
{ $code = $rewrite_block.code; }
{
string description = grammar.grammarTreeToString($start, false);
-			description = generator.target.getTargetStringLiteralFromString(description);
+			description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
|	^( CLOSURE rewrite_block["rewriteClosureBlock"] )
{ $code = $rewrite_block.code; }
{
string description = grammar.grammarTreeToString($start, false);
-			description = generator.target.getTargetStringLiteralFromString(description);
+			description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
|	^( POSITIVE_CLOSURE rewrite_block["rewritePositiveClosureBlock"] )
{ $code = $rewrite_block.code; }
{
string description = grammar.grammarTreeToString($start, false);
-			description = generator.target.getTargetStringLiteralFromString(description);
+			description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
;
@@ -1195,7 +1195,7 @@ rewrite_tree returns [StringTemplate code]
)
{
string description = grammar.grammarTreeToString($start, false);
-			description = generator.target.getTargetStringLiteralFromString(description);
+			description = generator.target.GetTargetStringLiteralFromString(description);
$code.SetAttribute("description", description);
}
;
@@ -1268,12 +1268,12 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
$code.SetAttribute("hetero", hetero);
if ( $arg!=null )
{
-				List args = generator.translateAction(currentRuleName,$arg);
+				List args = generator.TranslateAction(currentRuleName,$arg);
$code.SetAttribute("args", args);
}
$code.SetAttribute("elementIndex", ((TokenWithIndex)$start.Token).TokenIndex);
int ttype = grammar.getTokenType(tokenName);
-			string tok = generator.getTokenTypeAsTargetLabel(ttype);
+			string tok = generator.GetTokenTypeAsTargetLabel(ttype);
$code.SetAttribute("token", tok);
if ( grammar.getTokenType(tokenName)==Label.INVALID )
{
@@ -1350,7 +1350,7 @@ rewrite_atom[bool isRoot] returns [StringTemplate code=null]
{
// actions in rewrite rules yield a tree object
string actText = $ACTION.text;
-			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			List chunks = generator.TranslateAction(currentRuleName,$ACTION);
$code = templates.GetInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
$code.SetAttribute("action", chunks);
}
@@ -1373,7 +1373,7 @@ rewrite_template returns [StringTemplate code=null]
else if ( $ind!=null )
{ // must be \%({expr})(args)
$code = templates.GetInstanceOf("rewriteIndirectTemplate");
-					List chunks=generator.translateAction(currentRuleName,$ind);
+					List chunks=generator.TranslateAction(currentRuleName,$ind);
$code.SetAttribute("expr", chunks);
}
}
@@ -1384,7 +1384,7 @@ rewrite_template returns [StringTemplate code=null]
// because actions like \%foo(name={\$ID.text}) aren't
// broken up yet into trees.
$a.outerAltNum = this.outerAltNum;
-						List chunks = generator.translateAction(currentRuleName,$a);
+						List chunks = generator.TranslateAction(currentRuleName,$a);
$code.SetAttribute("args.{name,value}", $arg.text, chunks);
}
)
@@ -1394,14 +1394,14 @@ rewrite_template returns [StringTemplate code=null]
{
string sl = $DOUBLE_QUOTE_STRING_LITERAL.text;
string t = sl.Substring( 1, sl.Length - 2 ); // strip quotes
-					t = generator.target.getTargetStringLiteralFromString(t);
+					t = generator.target.GetTargetStringLiteralFromString(t);
$code.SetAttribute("template",t);
}
|	DOUBLE_ANGLE_STRING_LITERAL
{
string sl = $DOUBLE_ANGLE_STRING_LITERAL.text;
string t = sl.Substring( 2, sl.Length - 4 ); // strip double angle quotes
-					t = generator.target.getTargetStringLiteralFromString(t);
+					t = generator.target.GetTargetStringLiteralFromString(t);
$code.SetAttribute("template",t);
}
)?
@@ -1413,6 +1413,6 @@ rewrite_template returns [StringTemplate code=null]
$act.outerAltNum = this.outerAltNum;
$code=templates.GetInstanceOf("rewriteAction");
$code.SetAttribute("action",
-							  generator.translateAction(currentRuleName,$act));
+							  generator.TranslateAction(currentRuleName,$act));
}
;
diff --git a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
index 4310b07..e138892 100644
--- a/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
+++ b/Antlr3/Grammars/CodeGenTreeWalkerHelper.cs
@@ -126,7 +126,7 @@ namespace Antlr3.Grammars
( r == null || !r.isSynPred ) )
{
// we will need a label to do the AST or tracking, make one
-                label = generator.createUniqueLabel( ruleTargetName );
+                label = generator.CreateUniqueLabel( ruleTargetName );
CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
grammar.defineRuleRefLabel( currentRuleName, labelTok, elementAST );
}
@@ -165,7 +165,7 @@ namespace Antlr3.Grammars
if ( ( grammar.BuildAST || suffix.Length > 0 ) && label == null &&
( r == null || !r.isSynPred ) )
{
-                label = generator.createUniqueLabel( elementName );
+                label = generator.CreateUniqueLabel( elementName );
CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
grammar.defineTokenRefLabel( currentRuleName, labelTok, elementAST );
}
@@ -267,7 +267,7 @@ namespace Antlr3.Grammars
else
{
// must be char or string literal
-                    label = generator.getTokenTypeAsTargetLabel(
+                    label = generator.GetTokenTypeAsTargetLabel(
grammar.getTokenType( t.Text ) );
}
labels.Add( label );
diff --git a/Antlr3/Tool/AttributeScope.cs b/Antlr3/Tool/AttributeScope.cs
index 66c36cc..68fc2ce 100644
--- a/Antlr3/Tool/AttributeScope.cs
+++ b/Antlr3/Tool/AttributeScope.cs
@@ -168,7 +168,7 @@ namespace Antlr3.Tool
public virtual void addAttributes( string definitions, int separator )
{
IList<string> attrs = new List<string>();
-            CodeGenerator.getListOfArgumentsFromAction( definitions, 0, -1, separator, attrs );
+            CodeGenerator.GetListOfArgumentsFromAction( definitions, 0, -1, separator, attrs );
foreach ( string a in attrs )
{
Attribute attr = new Attribute( a );
diff --git a/Antlr3/Tool/BuildDependencyGenerator.cs b/Antlr3/Tool/BuildDependencyGenerator.cs
index 4b32476..8828ad9 100644
--- a/Antlr3/Tool/BuildDependencyGenerator.cs
+++ b/Antlr3/Tool/BuildDependencyGenerator.cs
@@ -96,7 +96,7 @@ namespace Antlr3.Tool
grammar = tool.getRootGrammar( grammarFileName );
string language = (string)grammar.getOption( "language" );
generator = new CodeGenerator( tool, grammar, language );
-            generator.loadTemplates( language );
+            generator.LoadTemplates( language );
}

public virtual string TokenVocab
@@ -135,7 +135,7 @@ namespace Antlr3.Tool
}
// add generated recognizer; e.g., TParser.java
string recognizer =
-                generator.getRecognizerFileName( grammar.name, grammar.type );
+                generator.GetRecognizerFileName( grammar.name, grammar.type );
files.Add( new FileInfo( System.IO.Path.Combine( outputDir.FullName, recognizer ) ) );
// add output vocab file; e.g., T.tokens. This is always generated to
// the base output directory, which will be just . if there is no -o option
diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index 3ee2142..eb1bd19 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -786,7 +786,7 @@ namespace Antlr3.Tool
{
if ( generator != null )
{
-                    return generator.target.getMaxCharValue( generator );
+                    return generator.target.GetMaxCharValue( generator );
}
else
{
diff --git a/Antlr3/Tool/Rule.cs b/Antlr3/Tool/Rule.cs
index fd9faea..3b86693 100644
--- a/Antlr3/Tool/Rule.cs
+++ b/Antlr3/Tool/Rule.cs
@@ -450,7 +450,7 @@ namespace Antlr3.Tool
{
// convert token name like ID to ID, "void" to 31
int ttype = grammar.getTokenType( tokenName );
-                        string label = grammar.generator.getTokenTypeAsTargetLabel( ttype );
+                        string label = grammar.generator.GetTokenTypeAsTargetLabel( ttype );
tokens.Add( label );
}
}
@@ -589,7 +589,7 @@ namespace Antlr3.Tool
else
{
// else create new label
-                labelName = generator.createUniqueLabel( refdSymbol );
+                labelName = generator.CreateUniqueLabel( refdSymbol );
CommonToken label = new CommonToken( ANTLRParser.ID, labelName );
if ( grammar.type != Grammar.LEXER &&
char.IsUpper( refdSymbol[0] ) )

