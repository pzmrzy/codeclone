commit 07b0d96538709bc738e162b47e59694a888501fb
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Dec 13 19:24:39 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Dec 13 19:24:39 2009 -0800

C# Port:
* Merge CL6383

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6494]

diff --git a/Antlr3.Test/ST4/TestImports.cs b/Antlr3.Test/ST4/TestImports.cs
index c87156d..7c0d97a 100644
--- a/Antlr3.Test/ST4/TestImports.cs
+++ b/Antlr3.Test/ST4/TestImports.cs
@@ -199,5 +199,26 @@ namespace AntlrUnitTests.ST4
result = st.Render();
Assert.AreEqual(expected, result);
}
+
+        [TestMethod]
+        public void TestSuper()
+        {
+            string dir1 = GetRandomDir();
+            string a = "a() ::= <<dir1 a>>\n";
+            string b = "b() ::= <<dir1 b>>\n";
+            WriteFile(dir1, "a.st", a);
+            WriteFile(dir1, "b.st", b);
+            string dir2 = GetRandomDir();
+            a = "a() ::= << [<super.a()>] >>\n";
+            WriteFile(dir2, "a.st", a);
+
+            TemplateGroup group1 = new TemplateGroupDirectory(dir1);
+            TemplateGroup group2 = new TemplateGroupDirectory(dir2);
+            group2.ImportTemplates(group1);
+            Template st = group2.GetInstanceOf("a");
+            string expected = " [dir1 a] ";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
}
}
diff --git a/Antlr3.Test/ST4/TestRegions.cs b/Antlr3.Test/ST4/TestRegions.cs
index f1a404d..32f78b7 100644
--- a/Antlr3.Test/ST4/TestRegions.cs
+++ b/Antlr3.Test/ST4/TestRegions.cs
@@ -76,7 +76,7 @@ namespace AntlrUnitTests.ST4
string dir = GetRandomDir();
string g1 = "a() ::= <<[<@r()>]>>\n";
WriteFile(dir, "g1.stg", g1);
-            string g2 = "@a.r() ::= <<foo>>>\n";
+            string g2 = "@a.r() ::= <<foo>>\n";
WriteFile(dir, "g2.stg", g2);

TemplateGroup group1 = new TemplateGroupFile(dir + "/g1.stg");
@@ -89,6 +89,24 @@ namespace AntlrUnitTests.ST4
}

[TestMethod]
+        public void TestDefineRegionInSubgroupThatRefsSuper()
+        {
+            string dir = GetRandomDir();
+            string g1 = "a() ::= <<[<@r>foo<@end>]>>\n";
+            WriteFile(dir, "g1.stg", g1);
+            string g2 = "@a.r() ::= <<(<@super.r()>)>>\n";
+            WriteFile(dir, "g2.stg", g2);
+
+            TemplateGroup group1 = new TemplateGroupFile(dir + "/g1.stg");
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/g2.stg");
+            group2.ImportTemplates(group1); // define r in g2
+            Template st = group2.GetInstanceOf("a");
+            string expected = "[(foo)]";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
public void TestDefineRegionInSubgroup2()
{
string dir = GetRandomDir();
@@ -130,9 +148,11 @@ namespace AntlrUnitTests.ST4
WriteFile(dir, "g.stg", g);

TemplateGroup group = new TemplateGroupFile(dir + "/g.stg");
-            Template st = group.GetInstanceOf("a");
-            string expected = "[foo]";
-            string result = st.Render();
+            ErrorBuffer errors = new ErrorBuffer();
+            group.SetErrorListener(errors);
+            group.Load();
+            string expected = "redefinition of /region__a__r";
+            string result = errors.ToString();
Assert.AreEqual(expected, result);
}
}
diff --git a/StringTemplate4/Bytecode.cs b/StringTemplate4/Bytecode.cs
index 06dfd48..be2302e 100644
--- a/StringTemplate4/Bytecode.cs
+++ b/StringTemplate4/Bytecode.cs
@@ -87,36 +87,37 @@ namespace StringTemplate
public const short INSTR_STORE_OPTION = 9;
public const short INSTR_NEW = 10;  // create new template instance
public const short INSTR_NEW_IND = 11;  // create new template instance using value on stack
-        public const short INSTR_WRITE = 12;
-        public const short INSTR_WRITE_OPT = 13;
-        public const short INSTR_MAP = 14;  // <a:b()>, <a:b():c()>, <a:{...}>
-        public const short INSTR_ROT_MAP = 15;  // <a:b(),c()>
-        public const short INSTR_PAR_MAP = 16;  // <names,phones:{n,p | ...}>
-        public const short INSTR_BR = 17;
-        public const short INSTR_BRF = 18;
-        public const short INSTR_OPTIONS = 19;  // push options block
-        public const short INSTR_LIST = 20;
-        public const short INSTR_ADD = 21;
-        public const short INSTR_TOSTR = 22;
+        public const short INSTR_SUPER_NEW = 12;  // create new template instance using value on stack
+        public const short INSTR_WRITE = 13;
+        public const short INSTR_WRITE_OPT = 14;
+        public const short INSTR_MAP = 15;  // <a:b()>, <a:b():c()>, <a:{...}>
+        public const short INSTR_ROT_MAP = 16;  // <a:b(),c()>
+        public const short INSTR_PAR_MAP = 17;  // <names,phones:{n,p | ...}>
+        public const short INSTR_BR = 18;
+        public const short INSTR_BRF = 19;
+        public const short INSTR_OPTIONS = 20;  // push options block
+        public const short INSTR_LIST = 21;
+        public const short INSTR_ADD = 22;
+        public const short INSTR_TOSTR = 23;
// Predefined functions
-        public const short INSTR_NOOP = 23; // do nothing
-        public const short INSTR_FIRST = 24;
-        public const short INSTR_LAST = 25;
-        public const short INSTR_REST = 26;
-        public const short INSTR_TRUNC = 27;
-        public const short INSTR_STRIP = 28;
-        public const short INSTR_TRIM = 29;
-        public const short INSTR_LENGTH = 30;
-        public const short INSTR_STRLEN = 31;
-        public const short INSTR_REVERSE = 32;
+        public const short INSTR_NOOP = 24; // do nothing
+        public const short INSTR_FIRST = 25;
+        public const short INSTR_LAST = 26;
+        public const short INSTR_REST = 27;
+        public const short INSTR_TRUNC = 28;
+        public const short INSTR_STRIP = 29;
+        public const short INSTR_TRIM = 30;
+        public const short INSTR_LENGTH = 31;
+        public const short INSTR_STRLEN = 32;
+        public const short INSTR_REVERSE = 33;

-        public const short INSTR_NOT = 33;
-        public const short INSTR_OR = 34;
-        public const short INSTR_AND = 35;
+        public const short INSTR_NOT = 34;
+        public const short INSTR_OR = 35;
+        public const short INSTR_AND = 36;

-        public const short INSTR_INDENT = 36;
-        public const short INSTR_DEDENT = 37;
-        public const short INSTR_NEWLINE = 38;
+        public const short INSTR_INDENT = 37;
+        public const short INSTR_DEDENT = 38;
+        public const short INSTR_NEWLINE = 39;

/** Used for assembly/disassembly; describes instruction set */
// START: instr
@@ -135,6 +136,7 @@ namespace StringTemplate
new Instruction("store_option",INT),
new Instruction("new",STRING),
new Instruction("new_ind"),
+                new Instruction("super_new",STRING),
new Instruction("write"),
new Instruction("write_opt"),
new Instruction("map"),
diff --git a/StringTemplate4/Compiler.cs b/StringTemplate4/Compiler.cs
index 44b477e..026c14b 100644
--- a/StringTemplate4/Compiler.cs
+++ b/StringTemplate4/Compiler.cs
@@ -95,7 +95,7 @@ namespace StringTemplate
*/
private string templatePathPrefix;

-        private string nameOrEnclosingTemplateName;
+        private string enclosingTemplateName;

public static int subtemplateCount = 0; // public for testing access

@@ -107,7 +107,7 @@ namespace StringTemplate
public Compiler(string templatePathPrefix, string enclosingTemplateName)
{
this.templatePathPrefix = templatePathPrefix;
-            this.nameOrEnclosingTemplateName = enclosingTemplateName;
+            this.enclosingTemplateName = enclosingTemplateName;
}

public string TemplateReferencePrefix
@@ -133,7 +133,7 @@ namespace StringTemplate

TemplateLexer lexer = new TemplateLexer(new ANTLRStringStream(template), delimiterStartChar, delimiterStopChar);
UnbufferedTokenStream tokens = new UnbufferedTokenStream(lexer);
-            TemplateParser parser = new TemplateParser(tokens, this, nameOrEnclosingTemplateName);
+            TemplateParser parser = new TemplateParser(tokens, this, enclosingTemplateName);
try
{
parser.templateAndEOF(); // parse, trigger compile actions for single expr
@@ -155,7 +155,7 @@ namespace StringTemplate
public CompiledTemplate Compile(ITokenStream tokens, RecognizerSharedState state)
{
instrs = new byte[SUBTEMPLATE_INITIAL_CODE_SIZE];
-            TemplateParser parser = new TemplateParser(tokens, state, this, nameOrEnclosingTemplateName);
+            TemplateParser parser = new TemplateParser(tokens, state, this, enclosingTemplateName);
try
{
parser.template(); // parse, trigger compile actions for single expr
diff --git a/StringTemplate4/Group.g3 b/StringTemplate4/Group.g3
index 9f9e57e..a3ba919 100644
--- a/StringTemplate4/Group.g3
+++ b/StringTemplate4/Group.g3
@@ -92,14 +92,10 @@ templateDef[string prefix]
template = Misc.TrimOneStartingWS(template);
}
try {
-			CompiledTemplate st = null;
if ($enclosing != null)
-				st = this._group.DefineRegion(prefix, $enclosing.text, $region.text, template);
+				this._group.DefineRegion(prefix, $enclosing.text, $region.text, template);
else
-				st = this._group.DefineTemplate(prefix, $name.text, $formalArgs.args, template);
-
-			GroupLexer lexer = (GroupLexer)input.TokenSource;
-			lexer._enclosingTemplateName = fullName;
+				this._group.DefineTemplate(prefix, $name.text, $formalArgs.args, template);
}
catch (TemplateRecognitionException e) {
RecognitionException re = (RecognitionException)e.InnerException;
@@ -203,7 +199,7 @@ ANONYMOUS_TEMPLATE
new TemplateLexer(input, this._group.delimiterStartChar, this._group.delimiterStopChar);
lexer.subtemplateDepth = 1;
UnbufferedTokenStream tokens = new UnbufferedTokenStream(lexer);
-        TemplateParser parser = new TemplateParser(tokens, (ICodeGenerator)null, this._enclosingTemplateName);
+        TemplateParser parser = new TemplateParser(tokens, (ICodeGenerator)null, null);
parser.template();
}
// don't match '}' here; subparser matches it to terminate
diff --git a/StringTemplate4/GroupLexerHelper.cs b/StringTemplate4/GroupLexerHelper.cs
index baccd8f..af29d5e 100644
--- a/StringTemplate4/GroupLexerHelper.cs
+++ b/StringTemplate4/GroupLexerHelper.cs
@@ -34,7 +34,6 @@ namespace StringTemplate
{
partial class GroupLexer
{
-        protected internal string _enclosingTemplateName;
protected internal TemplateGroup _group;
}
}
diff --git a/StringTemplate4/Interpreter.cs b/StringTemplate4/Interpreter.cs
index 483ffd2..d2a6d7a 100644
--- a/StringTemplate4/Interpreter.cs
+++ b/StringTemplate4/Interpreter.cs
@@ -161,6 +161,23 @@ namespace StringTemplate
Console.Error.WriteLine("no such template " + name);
operands[++sp] = st;
break;
+                case Bytecode.INSTR_SUPER_NEW:
+                    nameIndex = GetShort(code, ip);
+                    ip += 2;
+                    name = self.code.strings[nameIndex];
+                    CompiledTemplate imported = group.LookupImportedTemplate(name);
+                    if (imported == null)
+                    {
+                        group.listener.Error("no imported template for " + name);
+                        operands[++sp] = new BlankTemplate();
+                        break;
+                    }
+                    // TODO: factor into STGroup
+                    st = imported.nativeGroup.CreateStringTemplate();
+                    st.groupThatCreatedThisInstance = group;
+                    st.code = imported;
+                    operands[++sp] = st;
+                    break;
case Bytecode.INSTR_STORE_ATTR:
nameIndex = GetShort(code, ip);
name = self.code.strings[nameIndex];
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
index 30d0578..575e76b 100644
--- a/StringTemplate4/TemplateGroup.cs
+++ b/StringTemplate4/TemplateGroup.cs
@@ -191,7 +191,7 @@ namespace StringTemplate
return code;
}

-        protected CompiledTemplate LookupImportedTemplate(string name)
+        protected internal CompiledTemplate LookupImportedTemplate(string name)
{
//Console.WriteLine("look for " + name + " in " + imports);

@@ -245,6 +245,7 @@ namespace StringTemplate
}

CompiledTemplate code = Compile(prefix, name, template);
+            code.name = name;
code.formalArguments = args;
RawDefineTemplate(prefix + name, code);
if (args != null)
@@ -271,10 +272,11 @@ namespace StringTemplate
string name,
string template)
{
-            CompiledTemplate code = Compile(prefix, name, template);
+            CompiledTemplate code = Compile(prefix, enclosingTemplateName, template);
+            code.name = prefix + GetMangledRegionName(enclosingTemplateName, name);
code.isRegion = true;
code.regionDefType = Template.RegionType.Explicit;
-            RawDefineTemplate(prefix + GetMangledRegionName(enclosingTemplateName, name), code);
+            RawDefineTemplate(code.name, code);
return code;
}

@@ -314,11 +316,10 @@ namespace StringTemplate
templates[name] = code;
}

-        protected CompiledTemplate Compile(string prefix, string name, string template)
+        protected CompiledTemplate Compile(string prefix, string enclosingTemplateName, string template)
{
-            Compiler c = new Compiler(prefix, name);
+            Compiler c = new Compiler(prefix, enclosingTemplateName);
CompiledTemplate code = c.Compile(template);
-            code.name = name;
code.nativeGroup = this;
return code;
}
@@ -411,6 +412,7 @@ namespace StringTemplate
/// </summary>
public virtual Template CreateStringTemplate()
{
+            // TODO: try making a mem pool
Template st = new Template();
return st;
}
diff --git a/StringTemplate4/TemplateLexer.cs b/StringTemplate4/TemplateLexer.cs
index 4d8eb72..368f3f9 100644
--- a/StringTemplate4/TemplateLexer.cs
+++ b/StringTemplate4/TemplateLexer.cs
@@ -80,6 +80,7 @@ namespace StringTemplate

public static readonly IToken SKIP = new TemplateToken(-1, "<skip>");

+        // TODO: enum?
// pasted from STParser
public const int RBRACK = 17;
public const int LBRACK = 16;
diff --git a/StringTemplate4/TemplateParser.g3 b/StringTemplate4/TemplateParser.g3
index 8d9ab8d..225a04e 100644
--- a/StringTemplate4/TemplateParser.g3
+++ b/StringTemplate4/TemplateParser.g3
@@ -281,22 +281,23 @@ memberExpr
;

callExpr
-options {k=2;} // prevent full LL(*) which fails, falling back on k=1; need k=2
+options {k=2;} // prevent full LL(*), which fails, falling back on k=1; need k=2
:	{Compiler.funcs.ContainsKey(input.LT(1).Text)}?
ID '(' expr ')' {Func($ID);}
-	|	ID {gen.Emit(Bytecode.INSTR_NEW, PrefixedName($ID.text));} '(' args? ')'
-	|	'@' ID '(' ')'	// convert <@r()> to <region__enclosingTemplate__r()>
+	|	(s='super' '.')? ID
+		{gen.Emit($s!=null?Bytecode.INSTR_SUPER_NEW:Bytecode.INSTR_NEW, PrefixedName($ID.text));}
+		'(' args? ')'
+	|	'@' (s='super' '.')? ID '(' ')'	// convert <@r()> to <region__enclosingTemplate__r()>
{
string mangled = TemplateGroup.GetMangledRegionName(_enclosingTemplateName, $ID.text);
gen.DefineBlankRegion(PrefixedName(mangled));
-		gen.Emit(Bytecode.INSTR_NEW, PrefixedName(mangled));
+		gen.Emit($s!=null?Bytecode.INSTR_SUPER_NEW:Bytecode.INSTR_NEW, PrefixedName(mangled));
}
|	primary
;

primary
-	:	'super'
-	|	o=ID	  {RefAttr($o);}
+	:	o=ID	  {RefAttr($o);}
/*		(	'.' p=ID {gen.Emit(Bytecode.INSTR_LOAD_PROP, $p.text);}
|	'.' '(' mapExpr ')' {gen.Emit(Bytecode.INSTR_LOAD_PROP_IND);}
)*

