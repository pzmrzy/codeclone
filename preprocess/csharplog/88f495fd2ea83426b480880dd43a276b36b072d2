commit 88f495fd2ea83426b480880dd43a276b36b072d2
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Thu Dec 18 17:58:29 2014 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Thu Dec 18 18:30:59 2014 -0600

Rename bin/ to build/

diff --git a/.gitignore b/.gitignore
index 7ee679b..2e1990c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -17,18 +17,19 @@ Thumbs.db
*.log
*.sbr
*.sln.ide/
-obj/
-[Dd]ebug*/
-[Rr]elease*/
_ReSharper*/
[Tt]est[Rr]esult*

+# Ignore build output
+bin/
+obj/
+
# Ignore prepared output folders
-bin/prep/Backup/
-bin/prep/Bootstrap/
-bin/prep/dist/
-bin/prep/nuget/
-bin/prep/Runtime/
-bin/prep/ST3/
-bin/prep/ST4/
-bin/prep/Tool/
+build/prep/Backup/
+build/prep/Bootstrap/
+build/prep/dist/
+build/prep/nuget/
+build/prep/Runtime/
+build/prep/ST3/
+build/prep/ST4/
+build/prep/Tool/
diff --git a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
index f067d7e..aabe61a 100644
--- a/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
+++ b/Antlr3.StringTemplate/Antlr3.StringTemplate.csproj
@@ -125,11 +125,11 @@
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
<PropertyGroup>
<!-- Folder containing AntlrBuildTask.dll -->
-    <AntlrBuildTaskPath>$(ProjectDir)..\bin\Bootstrap</AntlrBuildTaskPath>
+    <AntlrBuildTaskPath>$(ProjectDir)..\build\Bootstrap</AntlrBuildTaskPath>
<!-- Path to the ANTLR Tool itself. -->
-    <AntlrToolPath>$(ProjectDir)..\bin\Bootstrap\Antlr3.exe</AntlrToolPath>
+    <AntlrToolPath>$(ProjectDir)..\build\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
-  <Import Project="$(ProjectDir)..\bin\Bootstrap\Antlr3.targets" />
+  <Import Project="$(ProjectDir)..\build\Bootstrap\Antlr3.targets" />
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/Antlr3.sln b/Antlr3.sln
index 9cc0ba6..b15fb76 100644
--- a/Antlr3.sln
+++ b/Antlr3.sln
@@ -76,14 +76,14 @@ Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Antlr3.Targets.Python3", "A
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Build", "Build", "{D2D979DC-1305-4C44-B21A-9EB3EEE95F7B}"
ProjectSection(SolutionItems) = preProject
-		bin\prep\Antlr3.nuspec = bin\prep\Antlr3.nuspec
-		bin\prep\Antlr3.Runtime.Debug.nuspec = bin\prep\Antlr3.Runtime.Debug.nuspec
-		bin\prep\Antlr3.Runtime.nuspec = bin\prep\Antlr3.Runtime.nuspec
-		bin\prep\LICENSE.txt = bin\prep\LICENSE.txt
-		bin\prep\prepare.ps1 = bin\prep\prepare.ps1
-		bin\prep\StringTemplate3.nuspec = bin\prep\StringTemplate3.nuspec
-		bin\prep\StringTemplate4.nuspec = bin\prep\StringTemplate4.nuspec
-		bin\prep\StringTemplate4.Visualizer.nuspec = bin\prep\StringTemplate4.Visualizer.nuspec
+		build\prep\Antlr3.nuspec = build\prep\Antlr3.nuspec
+		build\prep\Antlr3.Runtime.Debug.nuspec = build\prep\Antlr3.Runtime.Debug.nuspec
+		build\prep\Antlr3.Runtime.nuspec = build\prep\Antlr3.Runtime.nuspec
+		build\prep\LICENSE.txt = build\prep\LICENSE.txt
+		build\prep\prepare.ps1 = build\prep\prepare.ps1
+		build\prep\StringTemplate3.nuspec = build\prep\StringTemplate3.nuspec
+		build\prep\StringTemplate4.nuspec = build\prep\StringTemplate4.nuspec
+		build\prep\StringTemplate4.Visualizer.nuspec = build\prep\StringTemplate4.Visualizer.nuspec
EndProjectSection
EndProject
Global
diff --git a/Antlr3/Antlr3.csproj b/Antlr3/Antlr3.csproj
index bf106f8..cbd5bf1 100644
--- a/Antlr3/Antlr3.csproj
+++ b/Antlr3/Antlr3.csproj
@@ -492,11 +492,11 @@
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
<PropertyGroup>
<!-- Folder containing AntlrBuildTask.dll -->
-    <AntlrBuildTaskPath>$(ProjectDir)..\bin\Bootstrap</AntlrBuildTaskPath>
+    <AntlrBuildTaskPath>$(ProjectDir)..\build\Bootstrap</AntlrBuildTaskPath>
<!-- Path to the ANTLR Tool itself. -->
-    <AntlrToolPath>$(ProjectDir)..\bin\Bootstrap\Antlr3.exe</AntlrToolPath>
+    <AntlrToolPath>$(ProjectDir)..\build\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
-  <Import Project="$(ProjectDir)..\bin\Bootstrap\Antlr3.targets" />
+  <Import Project="$(ProjectDir)..\build\Bootstrap\Antlr3.targets" />
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
index e8d69de..b837da4 100644
--- a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
+++ b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
@@ -144,11 +144,11 @@
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
<PropertyGroup>
<!-- Folder containing AntlrBuildTask.dll -->
-    <AntlrBuildTaskPath>$(ProjectDir)..\bin\Bootstrap</AntlrBuildTaskPath>
+    <AntlrBuildTaskPath>$(ProjectDir)..\build\Bootstrap</AntlrBuildTaskPath>
<!-- Path to the ANTLR Tool itself. -->
-    <AntlrToolPath>$(ProjectDir)..\bin\Bootstrap\Antlr3.exe</AntlrToolPath>
+    <AntlrToolPath>$(ProjectDir)..\build\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
-  <Import Project="$(ProjectDir)..\bin\Bootstrap\Antlr3.targets" />
+  <Import Project="$(ProjectDir)..\build\Bootstrap\Antlr3.targets" />
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/Runtime/Antlr3.Runtime.Test/Antlr3.Runtime.Test.csproj b/Runtime/Antlr3.Runtime.Test/Antlr3.Runtime.Test.csproj
index d00d11e..3995cb3 100644
--- a/Runtime/Antlr3.Runtime.Test/Antlr3.Runtime.Test.csproj
+++ b/Runtime/Antlr3.Runtime.Test/Antlr3.Runtime.Test.csproj
@@ -172,11 +172,11 @@
<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
<PropertyGroup>
<!-- Folder containing AntlrBuildTask.dll -->
-    <AntlrBuildTaskPath>$(ProjectDir)..\..\bin\Bootstrap</AntlrBuildTaskPath>
+    <AntlrBuildTaskPath>$(ProjectDir)..\..\build\Bootstrap</AntlrBuildTaskPath>
<!-- Path to the ANTLR Tool itself. -->
-    <AntlrToolPath>$(ProjectDir)..\..\bin\Bootstrap\Antlr3.exe</AntlrToolPath>
+    <AntlrToolPath>$(ProjectDir)..\..\build\Bootstrap\Antlr3.exe</AntlrToolPath>
</PropertyGroup>
-  <Import Project="$(ProjectDir)..\..\bin\Bootstrap\Antlr3.targets" />
+  <Import Project="$(ProjectDir)..\..\build\Bootstrap\Antlr3.targets" />
<!-- To modify your build process, add your task inside one of the targets below and uncomment it.
Other similar extension points exist, see Microsoft.Common.targets.
<Target Name="BeforeBuild">
diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
deleted file mode 100644
index f6b8832..0000000
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and /dev/null differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
deleted file mode 100644
index ff2c7f9..0000000
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and /dev/null differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
deleted file mode 100755
index d5688d9..0000000
Binary files a/bin/Bootstrap/Antlr3.exe and /dev/null differ
diff --git a/bin/Bootstrap/Antlr3.exe.config b/bin/Bootstrap/Antlr3.exe.config
deleted file mode 100644
index bd4cf43..0000000
--- a/bin/Bootstrap/Antlr3.exe.config
+++ /dev/null
@@ -1,3 +0,0 @@
-<?xml version="1.0"?>
-<configuration>
-	<startup><supportedRuntime version="v2.0.50727" sku="Client"/></startup></configuration>
diff --git a/bin/Bootstrap/Antlr3.targets b/bin/Bootstrap/Antlr3.targets
deleted file mode 100644
index c5f5c70..0000000
--- a/bin/Bootstrap/Antlr3.targets
+++ /dev/null
@@ -1,169 +0,0 @@
-ï»¿<!--
-   [The "BSD licence"]
-   Copyright (c) 2011 Sam Harwell
-   All rights reserved.
-
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions
-   are met:
-   1. Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-   2. Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-   3. The name of the author may not be used to endorse or promote products
-      derived from this software without specific prior written permission.
-
-   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
--->
-<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <PropertyGroup>
-    <BuildSystem>MSBuild</BuildSystem>
-    <TaskVersion>3.5.0.2</TaskVersion>
-    <TaskKeyToken>eb42632606e9261f</TaskKeyToken>
-    <AntlrBuildTaskAssemblyName Condition="'$(AntlrBuildTaskAssemblyName)'==''">AntlrBuildTask, Version=$(TaskVersion), Culture=neutral, PublicKeyToken=$(TaskKeyToken)</AntlrBuildTaskAssemblyName>
-  </PropertyGroup>
-
-  <PropertyGroup>
-    <LoadTimeSensitiveTargets>
-      $(LoadTimeSensitiveTargets);
-      AntlrCompile;
-    </LoadTimeSensitiveTargets>
-    <LoadTimeSensitiveProperties>
-      $(LoadTimeSensitiveProperties);
-      AntlrCompileDependsOn;
-    </LoadTimeSensitiveProperties>
-  </PropertyGroup>
-
-  <PropertyGroup>
-    <AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'==''">$(MSBuildBinPath)</AntlrBuildTaskLocation>
-    <AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'!=''">$(AntlrBuildTaskPath)</AntlrBuildTaskLocation>
-    <AntlrToolLocation Condition="'$(AntlrToolPath)'==''">$(MSBuildBinPath)\Antlr3\Antlr3.exe</AntlrToolLocation>
-    <AntlrToolLocation Condition="'$(AntlrToolPath)'!=''">$(AntlrToolPath)</AntlrToolLocation>
-  </PropertyGroup>
-
-  <PropertyGroup>
-    <AntlrGenCodeFileNames Condition="'$(AntlrGenCodeFileNames)'==''">$(MSBuildProjectFile).AntlrGeneratedCodeFileListAbsolute.txt</AntlrGenCodeFileNames>
-  </PropertyGroup>
-
-  <UsingTask Condition="'$(AntlrBuildTaskPath)'==''" TaskName="Antlr3.Build.Tasks.AntlrClassGenerationTask" AssemblyName="$(AntlrBuildTaskAssemblyName)" />
-  <UsingTask Condition="'$(AntlrBuildTaskPath)'!=''" TaskName="Antlr3.Build.Tasks.AntlrClassGenerationTask" AssemblyFile="$(AntlrBuildTaskPath)\AntlrBuildTask.dll" />
-
-  <PropertyGroup>
-    <PrepareResourcesDependsOn>
-      AntlrCompile;
-      AntlrCompileAddFilesGenerated;
-      $(PrepareResourcesDependsOn)
-    </PrepareResourcesDependsOn>
-  </PropertyGroup>
-
-  <PropertyGroup>
-    <AntlrCompileDependsOn>
-      AntlrCompileReadGeneratedFileList
-    </AntlrCompileDependsOn>
-  </PropertyGroup>
-
-  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
-    <AvailableItemName Include="Antlr3" />
-    <AvailableItemName Include="AntlrTokens" />
-    <AvailableItemName Include="AntlrAbstractGrammar" />
-  </ItemGroup>
-
-  <ItemDefinitionGroup>
-    <Antlr3>
-      <Generator>MSBuild:Compile</Generator>
-      <TargetLanguage/>
-      <DebugGrammar>false</DebugGrammar>
-      <ProfileGrammar>false</ProfileGrammar>
-    </Antlr3>
-  </ItemDefinitionGroup>
-
-  <Target Name="AntlrCompileReadGeneratedFileList">
-    <ReadLinesFromFile File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)">
-      <Output TaskParameter="Lines" ItemName="AntlrOutputCodeFilesList"/>
-    </ReadLinesFromFile>
-  </Target>
-
-  <PropertyGroup>
-    <!-- Add grammar compilation to the CoreCompileDependsOn so that the IDE inproc compilers (particularly VB)
-         can "see" the generated source files. -->
-    <CoreCompileDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true' ">
-      DesignTimeGrammarCompilation;
-      $(CoreCompileDependsOn)
-    </CoreCompileDependsOn>
-  </PropertyGroup>
-
-  <Target Name="DesignTimeGrammarCompilation">
-    <!-- Only if we are not actually performing a compile i.e. we are in design mode -->
-    <CallTarget Condition="'$(BuildingProject)' != 'true'"
-                Targets="AntlrCompile" />
-  </Target>
-
-  <Target Name="AntlrCompile"
-          DependsOnTargets="$(AntlrCompileDependsOn)"
-          Condition="'@(Antlr3)' != ''"
-          Inputs="@(Antlr3);@(AntlrTokens);@(AntlrAbstractGrammar)"
-          Outputs="@(AntlrOutputCodeFilesList);
-                  $(IntermediateOutputPath)$(AntlrGenCodeFileNames);">
-
-    <ItemGroup>
-      <AntlrGeneratedCodeFiles Remove="@(AntlrGeneratedCodeFiles)" />
-    </ItemGroup>
-
-    <PropertyGroup>
-      <_IntellisenseOnlyCompile>false</_IntellisenseOnlyCompile>
-      <_IntellisenseOnlyCompile Condition="'$(BuildingProject)' != 'true'">true</_IntellisenseOnlyCompile>
-    </PropertyGroup>
-    <AntlrClassGenerationTask
-      AntlrToolPath="$(AntlrToolLocation)"
-      BuildTaskPath="$(AntlrBuildTaskLocation)"
-      OutputPath="$(IntermediateOutputPath)"
-      TargetLanguage="%(Antlr3.TargetLanguage)"
-      SourceCodeFiles="@(Antlr3)"
-      ContinueOnError="$(_IntellisenseOnlyCompile)"
-      TokensFiles="@(AntlrTokens)"
-      AbstractGrammarFiles="@(AntlrAbstractGrammar)"
-      LanguageSourceExtensions="$(DefaultLanguageSourceExtension)"
-      DebugGrammar="%(Antlr3.DebugGrammar)"
-      ProfileGrammar="%(Antlr3.ProfileGrammar)">
-
-      <Output ItemName="AntlrGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
-    </AntlrClassGenerationTask>
-
-    <WriteLinesToFile
-      Condition="'$(_IntellisenseOnlyCompile)' != 'true'"
-      File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)"
-      Lines="@(AntlrGeneratedCodeFiles)"
-      Overwrite="true"/>
-  </Target>
-
-  <Target Name="AntlrCompileAddFilesGenerated"
-          AfterTargets="AntlrCompile"
-          Condition="'@(Antlr3)' != ''">
-
-    <ItemGroup>
-      <AntlrGeneratedCodeFiles Condition="'@(AntlrGeneratedCodeFiles)' == ''" Include="@(AntlrOutputCodeFilesList)" />
-    </ItemGroup>
-
-    <ItemGroup>
-      <FileWrites Include="@(AntlrGeneratedCodeFiles);
-                           $(IntermediateOutputPath)$(AntlrGenCodeFileNames);" />
-    </ItemGroup>
-
-    <ItemGroup>
-      <Compile Include="@(AntlrGeneratedCodeFiles)" />
-      <!-- The WinFX "GenerateTemporaryTargetAssembly" target requires generated code files be added here. -->
-      <_GeneratedCodeFiles Include="@(AntlrGeneratedCodeFiles)" />
-    </ItemGroup>
-
-  </Target>
-</Project>
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll
deleted file mode 100644
index 87f8cde..0000000
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll and /dev/null differ
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.dll b/bin/Bootstrap/Antlr4.StringTemplate.dll
deleted file mode 100644
index 16e9795..0000000
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.dll and /dev/null differ
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
deleted file mode 100644
index fee939f..0000000
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and /dev/null differ
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
deleted file mode 100644
index a94ed7c..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
+++ /dev/null
@@ -1,430 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2007-2008 Johannes Luber
- * Copyright (c) 2005-2007 Kunle Odutola
- * Copyright (c) 2011 Sam Harwell
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-@outputFile.imports() ::= <<
-<@super.imports()>
-
-<if(!TREE_PARSER)>
-<! tree parser would already have imported !>
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
-<endif>
->>
-
-@genericParser.members() ::= <<
-<@super.members()>
-<parserMembers()>
->>
-
-parserCtorBody() ::= <%
-<super.parserCtorBody()><\n>
-TreeAdaptor =
-<if(actions.(actionScope).treeAdaptorInitializer)>
-	<actions.(actionScope).treeAdaptorInitializer>
-<else>
-	new <actions.(actionScope).treeAdaptorType; null="CommonTreeAdaptor">()
-<end>
-;
-%>
-
-/** Add an adaptor property that knows how to build trees */
-parserMembers() ::= <<
-private <treeAdaptorType()> adaptor;
-
-public <treeAdaptorType()> TreeAdaptor
-{
-	get
-	{
-		return adaptor;
-	}
-
-	set
-	{
-		this.adaptor = value;
-		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
-	}
-}
->>
-
-treeAdaptorType() ::= <<
-<actions.(actionScope).treeAdaptorType; null="ITreeAdaptor">
->>
-
-ruleReturnBaseType() ::= <%
-Ast<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<ASTLabelType>, <labelType>>
-%>
-
-/** Add a variable to track rule's return AST */
-ruleDeclarations() ::= <<
-<super.ruleDeclarations()>
-<ASTLabelType> root_0 = default(<ASTLabelType>);<\n>
->>
-
-ruleLabelDefs() ::= <<
-<super.ruleLabelDefs()>
-<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-	:{it|<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
-<ruleDescriptor.tokenListLabels:{it|<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
-<ruleDescriptor.allTokenRefsInAltsWithRewrites
-	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
-<ruleDescriptor.allRuleRefsInAltsWithRewrites
-	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
->>
-
-/** When doing auto AST construction, we must define some variables;
- *  These should be turned off if doing rewrites.  This must be a "mode"
- *  as a rule could have both rewrite and AST within the same alternative
- *  block.
- */
-@alt.declarations() ::= <<
-<if(autoAST)>
-<if(outerAlt)>
-<if(!rewriteMode)>
-root_0 = (<ASTLabelType>)adaptor.Nil();
-<endif>
-<endif>
-<endif>
->>
-
-// T r a c k i n g  R u l e  E l e m e n t s
-
-/** ID and track it for use in a rewrite rule */
-tokenRefTrack(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefBang(...)> <! Track implies no auto AST construction!>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
->>
-
-/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
- *  to the tracking list stream_ID for use in the rewrite.
- */
-tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefTrack(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** ^(ID ...) track for rewrite */
-tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefBang(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
->>
-
-/** Match ^(label+=TOKEN ...) track for rewrite */
-tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefRuleRootTrack(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** rule when output=AST and tracking for rewrite */
-ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
-<super.ruleRef(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule.name>.Add(<label>.Tree);
->>
-
-/** x+=rule when output=AST and tracking for rewrite */
-ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefTrack(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-/** ^(rule ...) rewrite */
-ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRoot(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule>.Add(<label>.Tree);
->>
-
-/** ^(x+=rule ...) rewrite */
-ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRootTrack(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-// R e w r i t e
-
-rewriteCode(
-	alts, description,
-	referencedElementsDeep, // ALL referenced elements to right of ->
-	referencedTokenLabels,
-	referencedTokenListLabels,
-	referencedRuleLabels,
-	referencedRuleListLabels,
-	referencedWildcardLabels,
-	referencedWildcardListLabels,
-	rewriteBlockLevel, enclosingTreeLevel, treeLevel) ::= <<
-<\n>{
-// AST REWRITE
-// elements: <referencedElementsDeep; separator=", ">
-// token labels: <referencedTokenLabels; separator=", ">
-// rule labels: <referencedRuleLabels; separator=", ">
-// token list labels: <referencedTokenListLabels; separator=", ">
-// rule list labels: <referencedRuleListLabels; separator=", ">
-// wildcard labels: <[referencedWildcardLabels,referencedWildcardListLabels]; separator=", ">
-<if(backtracking)>
-if (<actions.(actionScope).synpredgate>) {
-<endif>
-<prevRuleRootRef()>.Tree = root_0;
-<rewriteCodeLabels()>
-root_0 = (<ASTLabelType>)adaptor.Nil();
-<alts:rewriteAlt(); separator="else ">
-<! if tree parser and rewrite=true !>
-<if(TREE_PARSER&&rewriteMode)>
-<prevRuleRootRef()>.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
-if (<prevRuleRootRef()>.Tree != null)
-	input.ReplaceChildren(adaptor.GetParent(retval.Start), adaptor.GetChildIndex(retval.Start), adaptor.GetChildIndex(_last), retval.Tree);
-<endif>
-<! if parser or tree-parser && rewrite!=true, we need to set result !>
-<if(!TREE_PARSER||!rewriteMode)>
-<prevRuleRootRef()>.Tree = root_0;
-<endif>
-<if(backtracking)>
-}
-<endif>
-}
-
->>
-
-rewriteCodeLabels() ::= <<
-<referencedTokenLabels
-    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
-    separator="\n"
->
-<referencedTokenListLabels
-    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
-    separator="\n"
->
-<referencedWildcardLabels
-	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
-	separator="\n"
->
-<referencedWildcardListLabels
-	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
-	separator="\n"
->
-<referencedRuleLabels
-    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
-    separator="\n"
->
-<referencedRuleListLabels
-    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
-    separator="\n"
->
->>
-
-/** Generate code for an optional rewrite block; note it uses the deep ref'd element
-  *  list rather shallow like other blocks.
-  */
-rewriteOptionalBlock(
-	alt,rewriteBlockLevel,
-	referencedElementsDeep, // all nested refs
-	referencedElements, // elements in immediately block; no nested blocks
-	description) ::=
-<<
-// <fileName>:<description>
-if (<referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||">)
-{
-	<alt>
-}
-<referencedElementsDeep:{el | stream_<el>.Reset();<\n>}>
->>
-
-rewriteClosureBlock(
-	alt,rewriteBlockLevel,
-	referencedElementsDeep, // all nested refs
-	referencedElements, // elements in immediately block; no nested blocks
-	description) ::=
-<<
-// <fileName>:<description>
-while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
-{
-	<alt>
-}
-<referencedElements:{el | stream_<el>.Reset();<\n>}>
->>
-
-rewritePositiveClosureBlock(
-	alt,rewriteBlockLevel,
-	referencedElementsDeep, // all nested refs
-	referencedElements, // elements in immediately block; no nested blocks
-	description) ::=
-<<
-if (!(<referencedElements:{el | stream_<el>.HasNext}; separator="||">))
-{
-	throw new RewriteEarlyExitException();
-}
-while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
-{
-	<alt>
-}
-<referencedElements:{el | stream_<el>.Reset();<\n>}>
->>
-
-rewriteAlt(a) ::= <<
-// <a.description>
-<if(a.pred)>
-if (<a.pred>)
-{
-	<a.alt>
-}
-<else>
-{
-	<a.alt>
-}
-<endif>
->>
-
-/** For empty rewrites: "r : ... -> ;" */
-rewriteEmptyAlt() ::= "root_0 = null;"
-
-rewriteTree(root,children,description,enclosingTreeLevel,treeLevel) ::= <<
-// <fileName>:<description>
-{
-<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
-<root:rewriteElement()>
-<children:rewriteElement()>
-adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
-}<\n>
->>
-
-rewriteElementList(elements) ::= "<elements:rewriteElement()>"
-
-rewriteElement(e) ::= <%
-<@pregen()>
-DebugLocation(<e.line>, <e.pos>);<\n>
-<e.el>
-%>
-
-/** Gen ID or ID[args] */
-rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
-adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
->>
-
-/** Gen $label ... where defined via label=ID */
-rewriteTokenLabelRef(label,elementIndex) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
->>
-
-/** Gen $label ... where defined via label+=ID */
-rewriteTokenListLabelRef(label,elementIndex) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
->>
-
-/** Gen ^($label ...) */
-rewriteTokenLabelRefRoot(label,elementIndex) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
->>
-
-/** Gen ^($label ...) where label+=... */
-rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot
-
-/** Gen ^(ID ...) or ^(ID[args] ...) */
-rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
->>
-
-rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
-adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
->>
-
-rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
->>
-
-/** plain -> {foo} action */
-rewriteAction(action) ::= <<
-root_0 = <action>;<\n>
->>
-
-/** What is the name of the previous value of this rule's root tree?  This
- *  let's us refer to $rule to mean previous value.  I am reusing the
- *  variable 'tree' sitting in retval struct to hold the value of root_0 right
- *  before I set it during rewrites.  The assign will be to retval.tree.
- */
-prevRuleRootRef() ::= "retval"
-
-rewriteRuleRef(rule) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<rule>.NextTree());<\n>
->>
-
-rewriteRuleRefRoot(rule) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<rule>.NextNode(), root_<treeLevel>);<\n>
->>
-
-rewriteNodeAction(action) ::= <<
-adaptor.AddChild(root_<treeLevel>, <action>);<\n>
->>
-
-rewriteNodeActionRoot(action) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<action>, root_<treeLevel>);<\n>
->>
-
-/** Gen $ruleLabel ... where defined via ruleLabel=rule */
-rewriteRuleLabelRef(label) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
->>
-
-/** Gen $ruleLabel ... where defined via ruleLabel+=rule */
-rewriteRuleListLabelRef(label) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
->>
-
-/** Gen ^($ruleLabel ...) where ruleLabel=rule */
-rewriteRuleLabelRefRoot(label) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
->>
-
-/** Gen ^($ruleLabel ...) where ruleLabel+=rule */
-rewriteRuleListLabelRefRoot(label) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
->>
-
-rewriteWildcardLabelRef(label) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
->>
-
-createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
-<if(terminalOptions.node)>
-<! new MethodNode(IDLabel, args) !>
-new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
-<else>
-(<ASTLabelType>)adaptor.Create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
-<endif>
-%>
-
-createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
-<if(terminalOptions.node)>
-new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
-<else>
-<if(args)> <! must create new node from old !>
-adaptor.Create(<token>, <args; separator=", ">)
-<else>
-stream_<token>.NextNode()
-<endif>
-<endif>
-%>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
deleted file mode 100644
index e7b2904..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
+++ /dev/null
@@ -1,94 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2007-2008 Johannes Luber
- * Copyright (c) 2005-2007 Kunle Odutola
- * Copyright (c) 2005 Terence Parr
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** Template overrides to add debugging to AST stuff.  Dynamic inheritance
- *  hierarchy is set up as ASTDbg : AST : Dbg : Java by code generator.
- */
-
-parserMembers() ::= <<
-	protected DebugTreeAdaptor adaptor;
-
-	public ITreeAdaptor TreeAdaptor
-	{
-		get
-		{
-			return adaptor;
-		}
-		set
-		{
-<if(grammar.grammarIsRoot)>
-			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
-<else>
-			this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
-<endif><\n>
-			<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
-		}
-	}<\n>
->>
-
-parserCtorBody() ::= <<
-<super.parserCtorBody()>
->>
-
-createListenerAndHandshake() ::= <<
-DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, <if(TREE_PARSER)>input.TreeAdaptor<else>adaptor<endif> );
-DebugListener = proxy;
-<inputStreamType> = new Debug<inputStreamType>( input, proxy );
-try
-{
-	proxy.Handshake();
-}
-catch ( IOException ioe )
-{
-	ReportError( ioe );
-}
->>
-
-@ctorForRootGrammar.finally() ::= <<
-ITreeAdaptor adap = new CommonTreeAdaptor();
-TreeAdaptor = adap;
-proxy.TreeAdaptor = adap;
->>
-
-@ctorForProfilingRootGrammar.finally() ::=<<
-ITreeAdaptor adap = new CommonTreeAdaptor();
-TreeAdaptor = adap;
->>
-
-@ctorForPredefinedListener.superClassRef() ::= ": base( input, dbg )"
-
-@ctorForPredefinedListener.finally() ::=<<
-<if(grammar.grammarIsRoot)><! don't create new adaptor for delegates !>
-ITreeAdaptor adap = new CommonTreeAdaptor();
-TreeAdaptor = adap;<\n>
-<endif>
->>
-
-//@rewriteElement.pregen() ::= "dbg.Location( <e.line>, <e.pos> );"
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
deleted file mode 100644
index 1585287..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
+++ /dev/null
@@ -1,192 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2007-2008 Johannes Luber
- * Copyright (c) 2005-2007 Kunle Odutola
- * Copyright (c) 2011 Sam Harwell
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** Templates for building ASTs during normal parsing.
- *
- *  Deal with many combinations.  Dimensions are:
- *  Auto build or rewrite
- *    no label, label, list label  (label/no-label handled together)
- *    child, root
- *    token, set, rule, wildcard
- *
- *  The situation is not too bad as rewrite (->) usage makes ^ and !
- *  invalid. There is no huge explosion of combinations.
- */
-
-@rule.setErrorReturnValue() ::= <<
-retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
-<! System.out.WriteLine("<ruleName> returns "+((CommonTree)retval.tree).toStringTree()); !>
->>
-
-// TOKEN AST STUFF
-
-/** ID and output=AST */
-tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
-<super.tokenRef(...)>
-<if(backtracking)>if (state.backtracking == 0) {<endif>
-<label>_tree = <createNodeFromToken(...)>;
-adaptor.AddChild(root_0, <label>_tree);
-<if(backtracking)>}<endif>
->>
-
-/** ID! and output=AST (same as plain tokenRef) */
-tokenRefBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"
-
-/** ID^ and output=AST */
-tokenRefRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
-<super.tokenRef(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<label>_tree = <createNodeFromToken(...)>;
-root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
-<if(backtracking)>}<endif>
->>
-
-/** ids+=ID! and output=AST */
-tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefBang(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** label+=TOKEN when output=AST but not rewrite alt */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRef(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** Match label+=TOKEN^ when output=AST but not rewrite alt */
-tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefRuleRoot(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-// SET AST
-
-// the match set stuff is interesting in that it uses an argument list
-// to pass code to the default matchSet; another possible way to alter
-// inherited code.  I don't use the region stuff because I need to pass
-// different chunks depending on the operator.  I don't like making
-// the template name have the operator as the number of templates gets
-// large but this is the most flexible--this is as opposed to having
-// the code generator call matchSet then add root code or ruleroot code
-// plus list label plus ...  The combinations might require complicated
-// rather than just added on code.  Investigate that refactoring when
-// I have more time.
-
-matchSet(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= <<
-<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);}, ...)>
->>
-
-matchRuleBlockSet(s,label,elementIndex,postmatchCode,treeLevel="0",terminalOptions={}) ::= <<
-<matchSet(...)>
->>
-
-matchSetBang(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= "<super.matchSet(...)>"
-
-// note there is no matchSetTrack because -> rewrites force sets to be
-// plain old blocks of alts: (A|B|...|C)
-
-matchSetRuleRoot(s,label,elementIndex,debug,terminalOptions={}) ::= <<
-<if(label)>
-<label>=(<labelType>)input.LT(1);
-<endif>
-<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);}, ...)>
->>
-
-// RULE REF AST
-
-/** rule when output=AST */
-ruleRef(rule,label,elementIndex,args,scope) ::= <<
-<super.ruleRef(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <label>.Tree);
->>
-
-/** rule! is same as normal rule ref */
-ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(...)>"
-
-/** rule^ */
-ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
-<super.ruleRef(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
->>
-
-/** x+=rule when output=AST */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRef(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-/** x+=rule! when output=AST is a rule ref with list addition */
-ruleRefBangAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefBang(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-/** x+=rule^ */
-ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRoot(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-// WILDCARD AST
-
-wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
-<super.wildcard(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
-adaptor.AddChild(root_0, <label>_tree);
-<if(backtracking)>}<endif>
->>
-
-wildcardBang(label,elementIndex) ::= "<super.wildcard(token=[],...)>"
-
-wildcardRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
-<super.wildcard(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
-root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
-<if(backtracking)>}<endif>
->>
-
-createNodeFromToken(label,terminalOptions={}) ::= <%
-<if(terminalOptions.node)>
-new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
-<else>
-(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
-<endif>
-%>
-
-ruleCleanUp() ::= <<
-<super.ruleCleanUp()>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
-adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
-<if(backtracking)>}<endif>
->>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
deleted file mode 100644
index 316282f..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
+++ /dev/null
@@ -1,380 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2007-2008 Johannes Luber
- * Copyright (c) 2005-2007 Kunle Odutola
- * Copyright (c) 2011 Sam Harwell
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** Templates for building ASTs during tree parsing.
- *
- *  Deal with many combinations.  Dimensions are:
- *  Auto build or rewrite
- *    no label, label, list label  (label/no-label handled together)
- *    child, root
- *    token, set, rule, wildcard
- *
- *  Each combination has its own template except that label/no label
- *  is combined into tokenRef, ruleRef, ...
- */
-
-/** Add a variable to track last element matched */
-ruleDeclarations() ::= <<
-<super.ruleDeclarations()>
-<if(!ruleDescriptor.isSynPred)>
-<ASTLabelType> _first_0 = default(<ASTLabelType>);
-<ASTLabelType> _last = default(<ASTLabelType>);
-<endif>
->>
-
-/** What to emit when there is no rewrite rule.  For auto build
- *  mode, does nothing.
- */
-noRewrite(rewriteBlockLevel=false, treeLevel=false) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(rewriteMode)>
-retval.Tree = (<ASTLabelType>)_first_0;
-if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
-    retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
-<endif>
-<if(backtracking)>}<endif>
-<endif>
->>
-
-/** match ^(root children) in tree parser; override here to
- *  add tree construction actions.
- */
-tree(root, actionsAfterRoot, children, nullableChildList,
-     enclosingTreeLevel, treeLevel) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-{
-<ASTLabelType> _save_last_<treeLevel> = _last;
-<ASTLabelType> _first_<treeLevel> = default(<ASTLabelType>);
-<if(!rewriteMode)>
-<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
-<endif>
-<root:element()>
-<if(rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
-<if(root.el.rule)>
-if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
-<else>
-if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>;
-<endif>
-<endif>
-<actionsAfterRoot:element()>
-<if(nullableChildList)>
-if (input.LA(1) == TokenTypes.Down) {
-    Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-    <children:element()>
-    Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
-}
-<else>
-Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-<children:element()>
-Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
-<endif>
-<if(!rewriteMode)>
-adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
-<endif>
-_last = _save_last_<treeLevel>;
-}
-<else>
-<super.tree(...)>
-<endif>
->>
-
-// TOKEN AST STUFF
-
-/** ID! and output=AST (same as plain tokenRef) 'cept add
- *  setting of _last
- */
-tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
-<else>
-<super.tokenRefBang(...)>
-<endif>
->>
-
-/** ID auto construct */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<endif><\n>
-adaptor.AddChild(root_<treeLevel>, <label>_tree);
-<if(backtracking)>}<endif>
-<else> <! rewrite mode !>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
-if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
-<endif>
-<else>
-<super.tokenRef(...)>
-<endif>
->>
-
-/** label+=TOKEN auto construct */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<tokenRef(...)>
-<listLabelElem(elem=label,...)>
-<else>
-<super.tokenRefAndListLabel(...)>
-<endif>
->>
-
-/** ^(ID ...) auto construct */
-tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<endif><\n>
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
-<if(backtracking)>}<endif>
-<endif>
-<else>
-<super.tokenRefRuleRoot(...)>
-<endif>
->>
-
-/** Match ^(label+=TOKEN ...) auto construct */
-tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<tokenRefRuleRoot(...)>
-<listLabelElem(elem=label,...)>
-<else>
-<super.tokenRefRuleRootAndListLabel(...)>
-<endif>
->>
-
-/** Match . wildcard and auto dup the node/subtree */
-wildcard(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.wildcard(...)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<label>_tree = (<ASTLabelType>)adaptor.DupTree(<label>);
-adaptor.AddChild(root_<treeLevel>, <label>_tree);
-<if(backtracking)>}<endif>
-<else> <! rewrite mode !>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
-if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
-<endif>
-<else>
-<super.wildcard(...)>
-<endif>
->>
-
-// SET AST
-
-matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.matchSet(postmatchCode={
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<endif><\n>
-adaptor.AddChild(root_<treeLevel>, <label>_tree);
-<if(backtracking)>\}<endif>
-<endif>
-}, ...
-)>
-<else>
-<super.matchSet(...)>
-<endif>
->>
-
-matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<matchSet(...)>
-<noRewrite(...)> <! set return tree !>
-<else>
-<super.matchRuleBlockSet(...)>
-<endif>
->>
-
-matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.matchSet(...)>
-<else>
-<super.matchSetBang(...)>
-<endif>
->>
-
-matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<super.matchSet(postmatchCode={
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<endif><\n>
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
-<if(backtracking)>\}<endif>
-<endif>
-}, ...
-)>
-<else>
-<super.matchSetRuleRoot(...)>
-<endif>
->>
-
-// RULE REF AST
-
-/** rule auto construct */
-ruleRef(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRef(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
-<if(!rewriteMode)>
-adaptor.AddChild(root_<treeLevel>, <label>.Tree);
-<else> <! rewrite mode !>
-if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
-<endif>
-<else>
-<super.ruleRef(...)>
-<endif>
->>
-
-/** x+=rule auto construct */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<ruleRef(...)>
-<listLabelElem(elem={<label>.Tree},...)>
-<else>
-<super.ruleRefAndListLabel(...)>
-<endif>
->>
-
-/** ^(rule ...) auto construct */
-ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRef(...)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
-<endif>
-<else>
-<super.ruleRefRuleRoot(...)>
-<endif>
->>
-
-/** ^(x+=rule ...) auto construct */
-ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<ruleRefRuleRoot(...)>
-<listLabelElem(elem={<label>.Tree},...)>
-<else>
-<super.ruleRefRuleRootAndListLabel(...)>
-<endif>
->>
-
-/** rule when output=AST and tracking for rewrite */
-ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRefTrack(...)>
-<else>
-<super.ruleRefTrack(...)>
-<endif>
->>
-
-/** x+=rule when output=AST and tracking for rewrite */
-ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRefTrackAndListLabel(...)>
-<else>
-<super.ruleRefTrackAndListLabel(...)>
-<endif>
->>
-
-/** ^(rule ...) rewrite */
-ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRefRootTrack(...)>
-<else>
-<super.ruleRefRuleRootTrack(...)>
-<endif>
->>
-
-/** ^(x+=rule ...) rewrite */
-ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRefRuleRootTrackAndListLabel(...)>
-<else>
-<super.ruleRefRuleRootTrackAndListLabel(...)>
-<endif>
->>
-
-/** Streams for token refs are tree nodes now; override to
- *  change NextToken to NextNode.
- */
-createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
-<if(terminalOptions.node)>
-new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
-<else>
-stream_<token>.NextNode()
-<endif>
-%>
-
-ruleCleanUp() ::= <<
-<super.ruleCleanUp()>
-<if(!ruleDescriptor.isSynPred)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
-<if(backtracking)>}<endif>
-<endif>
-<endif>
->>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
deleted file mode 100644
index 8f15ef2..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
+++ /dev/null
@@ -1,1772 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2007-2008 Johannes Luber
- * Copyright (c) 2005-2007 Kunle Odutola
- * Copyright (c) 2011 Sam Harwell
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-csharpVisibilityMap ::= [
-	"private":"private",
-	"protected":"protected",
-	"public":"public",
-	"fragment":"private",
-	default:"private"
-]
-
-/** The overall file structure of a recognizer; stores methods for rules
- *  and cyclic DFAs plus support code.
- */
-outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
-			docComment, recognizer,
-			name, tokens, tokenNames, rules, cyclicDFAs,
-			bitsets, buildTemplate, buildAST, rewriteMode, profile,
-			backtracking, synpreds, memoize, numRules,
-			fileName, ANTLRVersion, generatedTimestamp, trace,
-			scopes, superClass, literals) ::=
-<<
-//------------------------------------------------------------------------------
-// \<auto-generated>
-//     This code was generated by a tool.
-//     ANTLR Version: <ANTLRVersion>
-//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// \</auto-generated>
-//------------------------------------------------------------------------------
-
-// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>
-
-<if(trace)>
-#define ANTLR_TRACE
-<endif>
-<@debugPreprocessor()>
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 168, 219
-// Unreachable code detected.
-#pragma warning disable 162
-// Missing XML comment for publicly visible type or member 'Type_or_Member'
-#pragma warning disable 1591
-
-<actions.(actionScope).header>
-
-<@imports>
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Antlr.Runtime.Misc;
-<if(TREE_PARSER)>
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
-<endif>
-using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;
-<@end>
-<if(actions.(actionScope).namespace)>
-namespace <actions.(actionScope).namespace>
-{
-<endif>
-<docComment>
-<recognizer>
-<if(actions.(actionScope).namespace)>
-
-} // namespace <actions.(actionScope).namespace>
-<endif>
->>
-
-lexerInputStreamType() ::= <<
-<actions.(actionScope).inputStreamType; null="ICharStream">
->>
-
-lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
-      superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>}) ::= <<
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
-[System.CLSCompliant(false)]
-<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
-{
-	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
-	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
-	<actions.lexer.members>
-
-    // delegates
-    <grammar.delegates:
-         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    // delegators
-    <grammar.delegators:
-         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    <last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
-
-	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
-	{
-		OnCreated();
-	}
-
-	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
-		: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
-	{
-	}
-
-	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
-		: base(input, state)
-	{
-<if(memoize)>
-<if(grammar.grammarIsRoot)>
-		state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<numRules>+1];<\n><! index from 1..n !>
-<endif>
-<endif>
-		<grammar.directDelegates:
-		 {g|<g:delegateName()> = new <g.recognizerName>(input, this.state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-		<grammar.delegators:
-		 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
-		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-
-		OnCreated();
-	}
-	public override string GrammarFileName { get { return "<fileName>"; } }
-
-	private static readonly bool[] decisionCanBacktrack = new bool[0];
-
-<if(grammar.hasDelegates)>
-	public override <lexerInputStreamType()> CharStream
-	{
-		get
-		{
-			return base.CharStream;
-		}
-		set
-		{
-			base.CharStream = value;
-			<grammar.directDelegates:
-			 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-			<grammar.delegators:
-			 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
-			<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-		}
-	}
-
-<if(grammar.delegates)>
-	public override void SetState(RecognizerSharedState state)
-	{
-		base.SetState(state);
-		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
-	}
-<endif>
-
-<endif>
-<if(filterMode)>
-	<filteringNextToken()>
-<endif>
-
-	[Conditional("ANTLR_TRACE")]
-	protected virtual void OnCreated() {}
-	[Conditional("ANTLR_TRACE")]
-	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
-	[Conditional("ANTLR_TRACE")]
-	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}
-
-    <rules; separator="\n">
-
-	<insertLexerSynpreds(synpreds)>
-
-	#region DFA
-	<cyclicDFAs:{dfa | DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif>);}; separator="\n">
-	}
-
-	<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
-	#endregion
-
-}
->>
-
-/** A override of Lexer.nextToken() that backtracks over mTokens() looking
- *  for matches.  No error can be generated upon error; just rewind, consume
- *  a token and then try again.  backtracking needs to be set as well.
- *  Make rule memoization happen only at levels above 1 as we start mTokens
- *  at backtracking==1.
- */
-filteringNextToken() ::= <<
-public override IToken NextToken()
-{
-	while (true)
-	{
-		if (input.LA(1) == CharStreamConstants.EndOfFile)
-		{
-			IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
-			eof.Line = Line;
-			eof.CharPositionInLine = CharPositionInLine;
-			return eof;
-		}
-		state.token = null;
-		state.channel = TokenChannels.Default;
-		state.tokenStartCharIndex = input.Index;
-		state.tokenStartCharPositionInLine = input.CharPositionInLine;
-		state.tokenStartLine = input.Line;
-		state.text = null;
-		try
-		{
-			int m = input.Mark();
-			state.backtracking=1;<! means we won't throw slow exception !>
-			state.failed=false;
-			mTokens();
-			state.backtracking=0;
-			<! mTokens backtracks with synpred at backtracking==2
-			   and we set the synpredgate to allow actions at level 1. !>
-			if (state.failed)
-			{
-				input.Rewind(m);
-				input.Consume();<! advance one char and try again !>
-			}
-			else
-			{
-				Emit();
-				return state.token;
-			}
-		}
-		catch (RecognitionException re)
-		{
-			// shouldn't happen in backtracking mode, but...
-			ReportError(re);
-			Recover(re);
-		}
-	}
-}
-
-public override void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex)
-{
-	if (state.backtracking > 1)
-		base.Memoize(input, ruleIndex, ruleStartIndex);
-}
-
-public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
-{
-	if (state.backtracking > 1)
-		return base.AlreadyParsedRule(input, ruleIndex);
-
-	return false;
-}
->>
-
-actionGate() ::= "state.backtracking == 0"
-
-filteringActionGate() ::= "state.backtracking == 1"
-
-/** How to generate a parser */
-genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
-              bitsets, inputStreamType, superClass,
-              labelType, members, rewriteElementType,
-              filterMode, ASTLabelType="object") ::= <<
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
-[System.CLSCompliant(false)]
-<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
-{
-<if(grammar.grammarIsRoot)>
-	internal static readonly string[] tokenNames = new string[] {
-		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
-	};
-<endif>
-	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
-
-<if(grammar.delegates)>
-	// delegates
-	<grammar.delegates:
-		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-<endif>
-<if(grammar.delegators)>
-	// delegators
-	<grammar.delegators:
-		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
-<endif>
-
-<if(grammar.delegates)>
-	public override void SetState(RecognizerSharedState state)
-	{
-		base.SetState(state);
-		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
-	}
-
-<if(TREE_PARSER)>
-	public override void SetTreeNodeStream(ITreeNodeStream input)
-	{
-		base.SetTreeNodeStream(input);
-		<grammar.delegates:{g|<g:delegateName()>.SetTreeNodeStream(input);}; separator="\n">
-	}
-<endif>
-<endif>
-
-	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
-	<@members()>
-
-	public override string[] TokenNames { get { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; } }
-	public override string GrammarFileName { get { return "<fileName>"; } }
-
-	<members>
-
-	[Conditional("ANTLR_TRACE")]
-	protected virtual void OnCreated() {}
-	[Conditional("ANTLR_TRACE")]
-	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
-	[Conditional("ANTLR_TRACE")]
-	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}
-
-	#region Rules
-	<rules; separator="\n">
-	#endregion Rules
-
-<if(grammar.delegatedRules)>
-<! generate rule/method definitions for imported rules so they
-   appear to be defined in this recognizer. !>
-	#region Delegated rules
-<grammar.delegatedRules:{ruleDescriptor|
-	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", "><endif>); \}}; separator="\n">
-	#endregion Delegated rules
-<endif>
-
-	<insertSynpreds(synpreds)>
-
-<if(cyclicDFAs)>
-	#region DFA
-	<cyclicDFAs:{dfa | private DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>( this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif> );}; separator="\n">
-	}
-
-	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
-	#endregion DFA
-<endif>
-
-<if(bitsets)>
-	#region Follow sets
-	private static class Follow
-	{
-		<bitsets:{it|<bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>}; separator="\n">
-	}
-	#endregion Follow sets
-<endif>
-}
->>
-
-@genericParser.members() ::= <<
-#if ANTLR_DEBUG
-private static readonly bool[] decisionCanBacktrack =
-	new bool[]
-	{
-		false, // invalid decision
-		<grammar.decisions:{d | <d.dfa.hasSynPred>}; wrap="\n", separator=", ">
-	};
-#else
-private static readonly bool[] decisionCanBacktrack = new bool[0];
-#endif
-<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
-<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
-	: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
-{
-}
-<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
-	: base(input, state)
-{
-<if(grammar.directDelegates)>
-	<grammar.directDelegates:
-	 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-<endif>
-<if(grammar.indirectDelegates)>
-	<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
-<endif>
-<if(grammar.delegators)>
-	<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-<endif>
-	<parserCtorBody()>
-	OnCreated();
-}
->>
-
-// imported grammars are 'public' (can't be internal because their return scope classes must be accessible)
-parserModifier(grammar, actions) ::= <<
-<if(grammar.grammarIsRoot)><actions.(actionScope).modifier; null="public"><else>public<endif>
->>
-
-parserCtorBody() ::= <<
-<if(memoize)>
-<if(grammar.grammarIsRoot)>
-this.state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<length(grammar.allImportedRules)>+1];<\n><! index from 1..n !>
-<endif>
-<endif>
-<grammar.delegators:
- {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
->>
-
-parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
-       ASTLabelType="object", superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Parser<endif>}, labelType="IToken",
-       members={<actions.parser.members>}) ::= <<
-<genericParser(inputStreamType="ITokenStream", rewriteElementType="IToken", ...)>
->>
-
-/** How to generate a tree parser; same as parser except the input
- *  stream is a different type.
- */
-treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
-           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="object",
-           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif><endif>},
-           members={<actions.treeparser.members>}) ::= <<
-<genericParser(inputStreamType="ITreeNodeStream", rewriteElementType="Node", ...)>
->>
-
-/** A simpler version of a rule template that is specific to the imaginary
- *  rules created for syntactic predicates.  As they never have return values
- *  nor parameters etc..., just give simplest possible method.  Don't do
- *  any of the normal memoization stuff in here either; it's a waste.
- *  As predicates cannot be inlined into the invoking rule, they need to
- *  be in a rule by themselves.
- */
-synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
-<<
-[Conditional("ANTLR_TRACE")]
-protected virtual void EnterRule_<ruleName>_fragment() {}
-[Conditional("ANTLR_TRACE")]
-protected virtual void LeaveRule_<ruleName>_fragment() {}
-
-// $ANTLR start <ruleName>
-<ruleModifier(grammar,ruleDescriptor)> void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
-{
-	<ruleLabelDefs()>
-	EnterRule_<ruleName>_fragment();
-	EnterRule("<ruleName>_fragment", <ruleDescriptor.index>);
-	TraceIn("<ruleName>_fragment", <ruleDescriptor.index>);
-	try
-	{
-		<block>
-	}
-	finally
-	{
-		TraceOut("<ruleName>_fragment", <ruleDescriptor.index>);
-		LeaveRule("<ruleName>_fragment", <ruleDescriptor.index>);
-		LeaveRule_<ruleName>_fragment();
-	}
-}
-// $ANTLR end <ruleName>
->>
-
-insertLexerSynpreds(synpreds) ::= <<
-<insertSynpreds(synpreds)>
->>
-
-insertSynpreds(synpreds) ::= <<
-<if(synpreds)>
-#region Synpreds
-private bool EvaluatePredicate(System.Action fragment)
-{
-	bool success = false;
-	state.backtracking++;
-	<@start()>
-	try { DebugBeginBacktrack(state.backtracking);
-	int start = input.Mark();
-	try
-	{
-		fragment();
-	}
-	catch ( RecognitionException re )
-	{
-		System.Console.Error.WriteLine("impossible: "+re);
-	}
-	success = !state.failed;
-	input.Rewind(start);
-	} finally { DebugEndBacktrack(state.backtracking, success); }
-	<@stop()>
-	state.backtracking--;
-	state.failed=false;
-	return success;
-}
-#endregion Synpreds
-<endif>
->>
-
-ruleMemoization(name) ::= <<
-<if(memoize)>
-if (state.backtracking > 0 && AlreadyParsedRule(input, <ruleDescriptor.index>)) { <returnFromRule()> }
-<endif>
->>
-
-/** How to test for failure and return from rule */
-checkRuleBacktrackFailure() ::= <<
-<if(backtracking)>if (state.failed) <returnFromRule()><endif>
->>
-
-/** This rule has failed, exit indicating failure during backtrack */
-ruleBacktrackFailure() ::= <<
-<if(backtracking)>if (state.backtracking>0) {state.failed=true; <returnFromRule()>}<endif>
->>
-
-ruleWrapperMap ::= [
-	"bottomup":{<ruleWrapperBottomup()>},
-	"topdown":{<ruleWrapperTopdown()>},
-	default:""
-]
-
-ruleWrapperBottomup() ::= <<
-<if(TREE_PARSER && filterMode)>
-protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Bottomup() { return bottomup(); }
-<endif>
->>
-
-ruleWrapperTopdown() ::= <<
-<if(TREE_PARSER && filterMode)>
-protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Topdown() { return topdown(); }
-<endif>
->>
-
-/** How to generate code for a rule.  This includes any return type
- *  data aggregates required for multiple return values.
- */
-rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memoize) ::= <<
-<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
-<returnScope(ruleDescriptor.returnScope)>
-
-[Conditional("ANTLR_TRACE")]
-protected virtual void EnterRule_<ruleName>() {}
-[Conditional("ANTLR_TRACE")]
-protected virtual void LeaveRule_<ruleName>() {}
-<ruleWrapperMap.(ruleName)>
-// $ANTLR start "<ruleName>"
-// <fileName>:<description>
-[GrammarRule("<ruleName>")]
-<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)
-{
-	EnterRule_<ruleName>();
-	EnterRule("<ruleName>", <ruleDescriptor.index>);
-	TraceIn("<ruleName>", <ruleDescriptor.index>);
-    <ruleScopeSetUp()>
-    <ruleDeclarations()>
-    <ruleLabelDefs()>
-    <ruleDescriptor.actions.init>
-	try { DebugEnterRule(GrammarFileName, "<ruleName>");
-	DebugLocation(<ruleDescriptor.tree.line>, <ruleDescriptor.EORNode.charPositionInLine>);
-	<@preamble()>
-	try
-	{
-		<ruleMemoization(name=ruleName)>
-		<block>
-		<ruleCleanUp()>
-		<(ruleDescriptor.actions.after):execAction()>
-	}
-<if(exceptions)>
-	<exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
-<else>
-<if(!emptyRule)>
-<if(actions.(actionScope).rulecatch)>
-	<actions.(actionScope).rulecatch>
-<else>
-	catch (RecognitionException re)
-	{
-		ReportError(re);
-		Recover(input,re);
-	<@setErrorReturnValue()>
-	}
-<endif>
-<endif>
-<endif>
-	finally
-	{
-		TraceOut("<ruleName>", <ruleDescriptor.index>);
-		LeaveRule("<ruleName>", <ruleDescriptor.index>);
-		LeaveRule_<ruleName>();
-        <memoize()>
-        <ruleScopeCleanUp()>
-        <finally>
-    }
- 	DebugLocation(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);
-	} finally { DebugExitRule(GrammarFileName, "<ruleName>"); }
-	<@postamble()>
-	<returnFromRule()><\n>
-}
-// $ANTLR end "<ruleName>"
->>
-
-// imported grammars need to have internal rules
-ruleModifier(grammar,ruleDescriptor) ::= <<
-<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>internal<endif>
->>
-
-// imported grammars need to have public return scopes
-returnScopeModifier(grammar,ruleDescriptor) ::= <<
-<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>public<endif>
->>
-
-catch(decl,action) ::= <<
-catch (<e.decl>)
-{
-	<e.action>
-}
->>
-
-ruleDeclarations() ::= <<
-<if(ruleDescriptor.hasMultipleReturnValues)>
-<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>();
-retval.Start = (<labelType>)input.LT(1);
-<elseif(ruleDescriptor.returnScope)>
-<ruleDescriptor.returnScope.attributes:{ a |
-<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
-}>
-<endif>
-<if(memoize)>
-int <ruleDescriptor.name>_StartIndex = input.Index;
-<endif>
->>
-
-ruleScopeSetUp() ::= <<
-<ruleDescriptor.useScopes:{it|<it>_stack.Push(new <it>_scope());<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
-<ruleDescriptor.ruleScope:{it|<it.name>_stack.Push(new <it.name>_scope());<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
->>
-
-ruleScopeCleanUp() ::= <<
-<ruleDescriptor.useScopes:{it|<it>_scopeAfter(<it>_stack.Peek());<it>_stack.Pop();}; separator="\n">
-<ruleDescriptor.ruleScope:{it|<it.name>_scopeAfter(<it.name>_stack.Peek());<it.name>_stack.Pop();}; separator="\n">
->>
-
-ruleLabelDefs() ::= <<
-<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
->
-<ruleDescriptor.tokenListLabels
-    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
->
-<[ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
->
-<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
-<ruleDescriptor.ruleListLabels:ruleLabelDef(); separator="\n">
->>
-
-lexerRuleLabelDefs() ::= <<
-<[ruleDescriptor.tokenLabels,
-  ruleDescriptor.tokenListLabels,
-  ruleDescriptor.ruleLabels]
-    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
->
-<[ruleDescriptor.charListLabels,
-  ruleDescriptor.charLabels]
-	:{it|int <it.label.text> = 0;}; separator="\n"
->
-<[ruleDescriptor.tokenListLabels,
-  ruleDescriptor.ruleListLabels]
-    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
->
-<ruleDescriptor.charListLabels:{it|List\<int> list_<it.label.text> = null;}; separator="\n"
->
->>
-
-returnFromRule() ::= <%
-return
-<if(!ruleDescriptor.isSynPred)>
-<if(ruleDescriptor.hasReturnValue)>
-<if(ruleDescriptor.hasSingleReturnValue)>
-<! This comment is a hack to make sure the following
-   single space appears in the output. !> <ruleDescriptor.singleValueReturnName>
-<else>
-<!!> retval
-<endif>
-<endif>
-<endif>
-;
-%>
-
-ruleCleanUp() ::= <<
-<if(ruleDescriptor.hasMultipleReturnValues)>
-<if(!TREE_PARSER)>
-retval.Stop = (<labelType>)input.LT(-1);
-<endif>
-<endif>
->>
-
-memoize() ::= <<
-<if(memoize)>
-<if(backtracking)>
-if (state.backtracking > 0) { Memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex); }
-<endif>
-<endif>
->>
-
-/** How to generate a rule in the lexer; naked blocks are used for
- *  fragment rules.
- */
-lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
-
-[Conditional("ANTLR_TRACE")]
-protected virtual void EnterRule_<ruleName>() {}
-[Conditional("ANTLR_TRACE")]
-protected virtual void LeaveRule_<ruleName>() {}
-
-// $ANTLR start "<ruleName>"
-[GrammarRule("<ruleName>")]
-<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>)
-{
-	EnterRule_<ruleName>();
-	EnterRule("<ruleName>", <ruleDescriptor.index>);
-	TraceIn("<ruleName>", <ruleDescriptor.index>);
-    <ruleScopeSetUp()>
-    <ruleDeclarations()>
-		try
-		{
-<if(nakedBlock)>
-		<ruleMemoization(name=ruleName)>
-		<lexerRuleLabelDefs()>
-		<ruleDescriptor.actions.init>
-		<block>
-<else>
-		int _type = <ruleName>;
-		int _channel = DefaultTokenChannel;
-		<ruleMemoization(name=ruleName)>
-		<lexerRuleLabelDefs()>
-		<ruleDescriptor.actions.init>
-		<block>
-		<ruleCleanUp()>
-		state.type = _type;
-		state.channel = _channel;
-		<(ruleDescriptor.actions.after):execAction()>
-<endif>
-	}
-	finally
-	{
-		TraceOut("<ruleName>", <ruleDescriptor.index>);
-		LeaveRule("<ruleName>", <ruleDescriptor.index>);
-		LeaveRule_<ruleName>();
-        <ruleScopeCleanUp()>
-        <memoize()>
-    }
-}
-// $ANTLR end "<ruleName>"
->>
-
-/** How to generate code for the implicitly-defined lexer grammar rule
- *  that chooses between lexer rules.
- */
-tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
-
-public override void mTokens()
-{
-	<block><\n>
-}
->>
-
-// S U B R U L E S
-
-/** A (...) subrule with multiple alternatives */
-block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
-// <fileName>:<description>
-int alt<decisionNumber>=<maxAlt>;
-<decls>
-<@predecision()>
-try { DebugEnterSubRule(<decisionNumber>);
-try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
-<decision>
-} finally { DebugExitDecision(<decisionNumber>); }
-<@postdecision()>
-<@prebranch()>
-switch (alt<decisionNumber>)
-{
-<alts:{a|<altSwitchCase(i,a)>}>
-}
-} finally { DebugExitSubRule(<decisionNumber>); }
-<@postbranch()>
->>
-
-/** A rule block with multiple alternatives */
-ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
-// <fileName>:<description>
-int alt<decisionNumber>=<maxAlt>;
-<decls>
-<@predecision()>
-try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
-<decision>
-} finally { DebugExitDecision(<decisionNumber>); }
-<@postdecision()>
-switch (alt<decisionNumber>)
-{
-<alts:{a|<altSwitchCase(i,a)>}>
-}
->>
-
-ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
-// <fileName>:<description>
-<decls>
-<@prealt()>
-DebugEnterAlt(1);
-<alts>
-<@postalt()>
->>
-
-/** A special case of a (...) subrule with a single alternative */
-blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
-// <fileName>:<description>
-<decls>
-<@prealt()>
-DebugEnterAlt(1);
-<alts>
-<@postalt()>
->>
-
-/** A (..)+ block with 1 or more alternatives */
-positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
-// <fileName>:<description>
-int cnt<decisionNumber>=0;
-<decls>
-<@preloop()>
-try { DebugEnterSubRule(<decisionNumber>);
-while (true)
-{
-	int alt<decisionNumber>=<maxAlt>;
-	<@predecision()>
-	try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
-	<decision>
-	} finally { DebugExitDecision(<decisionNumber>); }
-	<@postdecision()>
-	switch (alt<decisionNumber>)
-	{
-	<alts:{a|<altSwitchCase(i,a)>}>
-	default:
-		if (cnt<decisionNumber> >= 1)
-			goto loop<decisionNumber>;
-
-		<ruleBacktrackFailure()>
-		EarlyExitException eee<decisionNumber> = new EarlyExitException( <decisionNumber>, input );
-		DebugRecognitionException(eee<decisionNumber>);
-		<@earlyExitException()>
-		throw eee<decisionNumber>;
-	}
-	cnt<decisionNumber>++;
-}
-loop<decisionNumber>:
-	;
-
-} finally { DebugExitSubRule(<decisionNumber>); }
-<@postloop()>
->>
-
-positiveClosureBlockSingleAlt ::= positiveClosureBlock
-
-/** A (..)* block with 1 or more alternatives */
-closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
-// <fileName>:<description>
-<decls>
-<@preloop()>
-try { DebugEnterSubRule(<decisionNumber>);
-while (true)
-{
-	int alt<decisionNumber>=<maxAlt>;
-	<@predecision()>
-	try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
-	<decision>
-	} finally { DebugExitDecision(<decisionNumber>); }
-	<@postdecision()>
-	switch ( alt<decisionNumber> )
-	{
-	<alts:{a|<altSwitchCase(i,a)>}>
-	default:
-		goto loop<decisionNumber>;
-	}
-}
-
-loop<decisionNumber>:
-	;
-
-} finally { DebugExitSubRule(<decisionNumber>); }
-<@postloop()>
->>
-
-closureBlockSingleAlt ::= closureBlock
-
-/** Optional blocks (x)? are translated to (x|) by before code generation
- *  so we can just use the normal block template
- */
-optionalBlock ::= block
-
-optionalBlockSingleAlt ::= block
-
-/** A case in a switch that jumps to an alternative given the alternative
- *  number.  A DFA predicts the alternative and then a simple switch
- *  does the jump to the code that actually matches that alternative.
- */
-altSwitchCase(altNum,alt) ::= <<
-case <altNum>:
-	<@prealt()>
-	DebugEnterAlt(<altNum>);
-	<alt>
-	break;<\n>
->>
-
-/** An alternative is just a list of elements; at outermost level */
-alt(elements,altNum,description,autoAST,outerAlt,treeLevel,rew) ::= <<
-// <fileName>:<description>
-{
-<@declarations()>
-<elements:element()>
-<rew>
-<@cleanup()>
-}
->>
-
-/** What to emit when there is no rewrite.  For auto build
- *  mode, does nothing.
- */
-noRewrite(rewriteBlockLevel, treeLevel) ::= ""
-
-// E L E M E N T S
-
-/** Dump the elements one per line */
-element(it) ::= <%
-<@prematch()>
-DebugLocation(<it.line>, <it.pos>);<\n>
-<it.el><\n>
-%>
-
-/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
-<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
->>
-
-/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRef(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-listLabelElem(label,elem,elemType) ::= <<
-if (list_<label>==null) list_<label>=new List\<<elemType; null={<labelType>}>\>();
-list_<label>.Add(<elem>);<\n>
->>
-
-/** match a character */
-charRef(char,label) ::= <<
-<if(label)>
-<label> = input.LA(1);<\n>
-<endif>
-Match(<char>); <checkRuleBacktrackFailure()>
->>
-
-/** match a character range */
-charRangeRef(a,b,label) ::= <<
-<if(label)>
-<label> = input.LA(1);<\n>
-<endif>
-MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
->>
-
-/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,elementIndex,postmatchCode="",terminalOptions={}) ::= <<
-<if(label)>
-<matchSetLabel()>
-<endif>
-if (<s>)
-{
-	input.Consume();
-	<postmatchCode>
-	<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
-}
-else
-{
-	<ruleBacktrackFailure()>
-	MismatchedSetException mse = new MismatchedSetException(null,input);
-	DebugRecognitionException(mse);
-	<@mismatchedSetException()>
-<if(LEXER)>
-	Recover(mse);
-	throw mse;
-<else>
-	throw mse;
-	<! use following code to make it recover inline; remove throw mse;
-	recoverFromMismatchedSet(input,mse,Follow._set_in_<ruleName><elementIndex>);
-	!>
-<endif>
-}<\n>
->>
-
-matchSetUnchecked(s,label,elementIndex,postmatchCode=false) ::= <%
-<if(label)>
-<matchSetLabel()><\n>
-<endif>
-input.Consume();<\n>
-<if(postmatchCode)>
-<postmatchCode><\n>
-<endif>
-<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
-%>
-
-matchSetLabel() ::= <%
-<if(LEXER)>
-<label>= input.LA(1);
-<else>
-<label>=(<labelType>)input.LT(1);
-<endif>
-%>
-
-matchRuleBlockSet ::= matchSet
-
-matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
-<matchSet(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** Match a string literal */
-lexerStringRef(string,label,elementIndex) ::= <%
-<if(label)>
-int <label>Start = CharIndex;<\n>
-Match(<string>); <checkRuleBacktrackFailure()><\n>
-int <label>StartLine<elementIndex> = Line;<\n>
-int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
-<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start, CharIndex-1);<\n>
-<label>.Line = <label>StartLine<elementIndex>;<\n>
-<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
-<else>
-Match(<string>); <checkRuleBacktrackFailure()><\n>
-<endif>
-%>
-
-wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
-<if(label)>
-<label>=(<labelType>)input.LT(1);<\n>
-<endif>
-MatchAny(input); <checkRuleBacktrackFailure()>
->>
-
-wildcardAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<wildcard(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** Match . wildcard in lexer */
-wildcardChar(label, elementIndex) ::= <<
-<if(label)>
-<label> = input.LA(1);<\n>
-<endif>
-MatchAny(); <checkRuleBacktrackFailure()>
->>
-
-wildcardCharListLabel(label, elementIndex) ::= <<
-<wildcardChar(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** Match a rule reference by invoking it possibly with arguments
- *  and a return value or values.  The 'rule' argument was the
- *  target rule name, but now is type Rule, whose toString is
- *  same: the rule name.  Now though you can access full rule
- *  descriptor stuff.
- */
-ruleRef(rule,label,elementIndex,args,scope) ::= <<
-PushFollow(Follow._<rule.name>_in_<ruleName><elementIndex>);
-<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name; format="id">(<args; separator=", ">);
-PopFollow();
-<checkRuleBacktrackFailure()>
->>
-
-/** ids+=r */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRef(...)>
-<listLabelElem(elem=label,elemType={<ASTLabelType>},...)>
->>
-
-/** A lexer rule reference.
- *
- *  The 'rule' argument was the target rule name, but now
- *  is type Rule, whose toString is same: the rule name.
- *  Now though you can access full rule descriptor stuff.
- */
-lexerRuleRef(rule,label,args,elementIndex,scope) ::= <%
-<if(label)>
-int <label>Start<elementIndex> = CharIndex;<\n>
-int <label>StartLine<elementIndex> = Line;<\n>
-int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
-<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()><\n>
-<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
-<label>.Line = <label>StartLine<elementIndex>;<\n>
-<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
-<else>
-<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
-<endif>
-%>
-
-/** i+=INT in lexer */
-lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
-<lexerRuleRef(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** EOF in the lexer */
-lexerMatchEOF(label,elementIndex) ::= <%
-<if(label)>
-int <label>Start<elementIndex> = CharIndex;<\n>
-int <label>StartLine<elementIndex> = Line;<\n>
-int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
-Match(EOF); <checkRuleBacktrackFailure()><\n>
-<labelType> <label> = new <labelType>(input, EOF, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
-<label>.Line = <label>StartLine<elementIndex>;<\n>
-<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
-<else>
-Match(EOF); <checkRuleBacktrackFailure()>
-<endif>
-%>
-
-// used for left-recursive rules
-recRuleDefArg()                       ::= "int <recRuleArg()>"
-recRuleArg()                          ::= "_p"
-recRuleAltPredicate(ruleName,opPrec)  ::= "<recRuleArg()> \<= <opPrec>"
-recRuleSetResultAction()              ::= "root_0=$<ruleName>_primary.tree;"
-recRuleSetReturnAction(src,name)      ::= "$<name>=$<src>.<name>;"
-
-/** match ^(root children) in tree parser */
-tree(root, actionsAfterRoot, children, nullableChildList,
-     enclosingTreeLevel, treeLevel) ::= <<
-<root:element()>
-<actionsAfterRoot:element()>
-<if(nullableChildList)>
-if (input.LA(1) == TokenTypes.Down)
-{
-	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-	<children:element()>
-	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
-}
-<else>
-Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-<children:element()>
-Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
-<endif>
->>
-
-/** Every predicate is used as a validating predicate (even when it is
- *  also hoisted into a prediction expression).
- */
-validateSemanticPredicate(pred,description) ::= <<
-if (!(<evalPredicate(...)>))
-{
-	<ruleBacktrackFailure()>
-	throw new FailedPredicateException(input, "<ruleName>", "<description>");
-}
->>
-
-// F i x e d  D F A  (if-then-else)
-
-dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
-<edges; separator="\nelse ">
-<if((!isTrue.(last(edges).labelExpr)) && (!last(edges).predicates))>
-else
-{
-<if(eotPredictsAlt)>
-	alt<decisionNumber> = <eotPredictsAlt>;
-<else>
-	<ruleBacktrackFailure()>
-	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input, <k>);
-	DebugRecognitionException(nvae);
-	<@noViableAltException()>
-	throw nvae;
-<endif>
-}
-<endif>
->>
-
-/** Same as a normal DFA state except that we don't examine lookahead
- *  for the bypass alternative.  It delays error detection but this
- *  is faster, smaller, and more what people expect.  For (X)? people
- *  expect "if ( LA(1)==X ) match(X);" and that's it.
- */
-dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
-<edges; separator="\nelse ">
->>
-
-/** A DFA state that is actually the loopback decision of a closure
- *  loop.  If end-of-token (EOT) predicts any of the targets then it
- *  should act like a default clause (i.e., no error can be generated).
- *  This is used only in the lexer so that for ('a')* on the end of a rule
- *  anything other than 'a' predicts exiting.
- */
-dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
-<edges; separator="\nelse "><\n>
-<if(eotPredictsAlt)>
-<if(!edges)>
-alt<decisionNumber> = <eotPredictsAlt>;<! if no edges, don't gen ELSE !>
-<else>
-else
-{
-	alt<decisionNumber> = <eotPredictsAlt>;
-}<\n>
-<endif>
-<endif>
->>
-
-/** An accept state indicates a unique alternative has been predicted */
-dfaAcceptState(alt) ::= "alt<decisionNumber> = <alt>;"
-
-/** A simple edge with an expression.  If the expression is satisfied,
- *  enter to the target state.  To handle gated productions, we may
- *  have to evaluate some predicates for this edge.
- */
-dfaEdge(labelExpr, targetState, predicates) ::= <<
-if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>)
-{
-	<targetState>
-}
->>
-
-// F i x e d  D F A  (switch case)
-
-/** A DFA state where a SWITCH may be generated.  The code generator
- *  decides if this is possible: CodeGenerator.canGenerateSwitch().
- */
-dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-switch (input.LA(<k>))
-{
-<edges; separator="\n">
-default:
-<if(eotPredictsAlt)>
-	alt<decisionNumber>=<eotPredictsAlt>;
-	break;<\n>
-<else>
-	{
-		<ruleBacktrackFailure()>
-		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input, <k>);
-		DebugRecognitionException(nvae);
-		<@noViableAltException()>
-		throw nvae;
-	}
-<endif>
-}<\n>
->>
-
-dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-switch (input.LA(<k>))
-{
-<edges; separator="\n">
-}<\n>
->>
-
-dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-switch (input.LA(<k>))
-{
-<edges; separator="\n">
-<if(eotPredictsAlt)>
-default:
-	alt<decisionNumber>=<eotPredictsAlt>;
-	break;<\n>
-<endif>
-}<\n>
->>
-
-dfaEdgeSwitch(labels, targetState) ::= <<
-<labels:{it|case <it>:}; separator="\n">
-	{
-	<targetState>
-	}
-	break;
->>
-
-// C y c l i c  D F A
-
-/** The code to initiate execution of a cyclic DFA; this is used
- *  in the rule to predict an alt just like the fixed DFA case.
- *  The <name> attribute is inherited via the parser, lexer, ...
- */
-dfaDecision(decisionNumber,description) ::= <<
-try
-{
-	alt<decisionNumber> = dfa<decisionNumber>.Predict(input);
-}
-catch (NoViableAltException nvae)
-{
-	DebugRecognitionException(nvae);
-	throw;
-}
->>
-
-/* Dump DFA tables as run-length-encoded Strings of octal values.
- * Can't use hex as compiler translates them before compilation.
- * These strings are split into multiple, concatenated strings.
- * Java puts them back together at compile time thankfully.
- * Java cannot handle large static arrays, so we're stuck with this
- * encode/decode approach.  See analysis and runtime DFA for
- * the encoding methods.
- */
-cyclicDFA(dfa) ::= <<
-private class DFA<dfa.decisionNumber> : DFA
-{
-	private const string DFA<dfa.decisionNumber>_eotS =
-		"<dfa.javaCompressedEOT; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_eofS =
-		"<dfa.javaCompressedEOF; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_minS =
-		"<dfa.javaCompressedMin; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_maxS =
-		"<dfa.javaCompressedMax; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_acceptS =
-		"<dfa.javaCompressedAccept; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_specialS =
-		"<dfa.javaCompressedSpecial; wrap="\"+\n\t\t\"">}>";
-	private static readonly string[] DFA<dfa.decisionNumber>_transitionS =
-		{
-			<dfa.javaCompressedTransition:{s|"<s; wrap="\"+\n\"">"}; separator=",\n">
-		};
-
-	private static readonly short[] DFA<dfa.decisionNumber>_eot = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eotS);
-	private static readonly short[] DFA<dfa.decisionNumber>_eof = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eofS);
-	private static readonly char[] DFA<dfa.decisionNumber>_min = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_minS);
-	private static readonly char[] DFA<dfa.decisionNumber>_max = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_maxS);
-	private static readonly short[] DFA<dfa.decisionNumber>_accept = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_acceptS);
-	private static readonly short[] DFA<dfa.decisionNumber>_special = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_specialS);
-	private static readonly short[][] DFA<dfa.decisionNumber>_transition;
-
-	static DFA<dfa.decisionNumber>()
-	{
-		int numStates = DFA<dfa.decisionNumber>_transitionS.Length;
-		DFA<dfa.decisionNumber>_transition = new short[numStates][];
-		for ( int i=0; i \< numStates; i++ )
-		{
-			DFA<dfa.decisionNumber>_transition[i] = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_transitionS[i]);
-		}
-	}
-
-	public DFA<dfa.decisionNumber>( BaseRecognizer recognizer<if(dfa.specialStateSTs)>, SpecialStateTransitionHandler specialStateTransition<endif> )
-<if(dfa.specialStateSTs)>
-		: base(specialStateTransition)
-<endif>
-	{
-		this.recognizer = recognizer;
-		this.decisionNumber = <dfa.decisionNumber>;
-		this.eot = DFA<dfa.decisionNumber>_eot;
-		this.eof = DFA<dfa.decisionNumber>_eof;
-		this.min = DFA<dfa.decisionNumber>_min;
-		this.max = DFA<dfa.decisionNumber>_max;
-		this.accept = DFA<dfa.decisionNumber>_accept;
-		this.special = DFA<dfa.decisionNumber>_special;
-		this.transition = DFA<dfa.decisionNumber>_transition;
-	}
-
-	public override string Description { get { return "<dfa.description>"; } }
-
-	public override void Error(NoViableAltException nvae)
-	{
-		DebugRecognitionException(nvae);
-	}
-}<\n>
-<if(dfa.specialStateSTs)>
-private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStream _input)<! throws NoViableAltException!>
-{
-	<if(LEXER)>
-	IIntStream input = _input;
-	<endif>
-	<if(PARSER)>
-	ITokenStream input = (ITokenStream)_input;
-	<endif>
-	<if(TREE_PARSER)>
-	ITreeNodeStream input = (ITreeNodeStream)_input;
-	<endif>
-	int _s = s;
-	s = -1;
-	<! pull these outside the switch cases to save space on locals !>
-	int LA<dfa.decisionNumber>_1 = input.LA(1);
-	int index<dfa.decisionNumber>_1 = input.Index;
-	switch (_s)
-	{
-	<dfa.specialStateSTs:{state |case <i0>:<! compressed special state numbers 0..n-1 !>
-	<state>}; separator="\n">
-
-	default:
-		break;
-	}
-
-	if (s >= 0)
-		return s;
-
-<if(backtracking)>
-	if (state.backtracking > 0) {state.failed=true; return -1;}
-<endif>
-	NoViableAltException nvae = new NoViableAltException(dfa.Description, <dfa.decisionNumber>, _s, input);
-	dfa.Error(nvae);
-	throw nvae;
-}
-<endif>
->>
-
-/** A state in a cyclic DFA; it's a special state and part of a big switch on
- *  state.
- */
-cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
-{
-<if(semPredState)>
-	<! get next lookahead symbol to test edges, then rewind !>
-	input.Rewind();
-<endif>
-	<edges; separator="\nelse ">
-<if(semPredState)>
-	<! return input cursor to state before we rewound !>
-	input.Seek(index<decisionNumber>_1);
-<endif>
-	break;
-}
->>
-
-/** Just like a fixed DFA edge, test the lookahead and indicate what
- *  state to jump to next if successful.
- */
-cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
-if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
->>
-
-/** An edge pointing at end-of-token; essentially matches any char;
- *  always jump to the target.
- */
-eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
-s = <targetStateNumber>;<\n>
->>
-
-
-// D F A  E X P R E S S I O N S
-
-andPredicates(left,right) ::= "(<left>&&<right>)"
-
-orPredicates(operands) ::= "(<operands; separator=\"||\">)"
-
-notPredicate(pred) ::= "!(<evalPredicate(...)>)"
-
-evalPredicate(pred,description) ::= "(<pred>)"
-
-evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"
-
-lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<k>==<atom>"
-
-/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
- *  somewhere.  Must ask for the lookahead directly.
- */
-isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"
-
-lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
-(LA<decisionNumber>_<k><ge()><lower> && LA<decisionNumber>_<k><le()><upper>)
-%>
-
-isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"
-
-le() ::= "\<="
-ge() ::= ">="
-
-setTest(ranges) ::= <<
-<ranges; separator="||">
->>
-
-// A T T R I B U T E S
-
-attributeScope(scope) ::= <<
-<if(scope)>
-<if(scope.attributes)>
-protected sealed partial class <scope.name>_scope
-{
-	<scope.attributes:{it|public <it.decl>;}; separator="\n">
-}
-<if(scope.actions.scopeinit)>
-protected void <scope.name>_scopeInit( <scope.name>_scope scope )
-{
-	<scope.actions.scopeinit>
-}
-<else>
-protected virtual void <scope.name>_scopeInit( <scope.name>_scope scope ) {}
-<endif>
-<if(scope.actions.scopeafter)>
-protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
-{
-	<scope.actions.scopeafter>
-}
-<else>
-protected virtual void <scope.name>_scopeAfter( <scope.name>_scope scope ) {}
-<endif>
-protected readonly ListStack\<<scope.name>_scope> <scope.name>_stack = new ListStack\<<scope.name>_scope>();
-<endif>
-<endif>
->>
-
-globalAttributeScope(scope) ::= <<
-<attributeScope(...)>
->>
-
-ruleAttributeScope(scope) ::= <<
-<attributeScope(...)>
->>
-
-returnStructName(it) ::= "<it.name>_return"
-
-returnType(ruleDescriptor) ::= <%
-<if(ruleDescriptor.returnScope.attributes && ruleDescriptor.hasMultipleReturnValues)>
-	<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
-<elseif(ruleDescriptor.hasMultipleReturnValues)>
-	<ruleReturnBaseType()>
-<elseif(ruleDescriptor.hasSingleReturnValue)>
-	<ruleDescriptor.singleValueReturnType>
-<else>
-	void
-<endif>
-%>
-
-/** Generate the C# type associated with a single or multiple return
- *  values.
- */
-ruleLabelType(referencedRule) ::= <%
-<if(referencedRule.hasMultipleReturnValues)>
-	<ruleReturnBaseType()>
-<elseif(referencedRule.hasSingleReturnValue)>
-	<referencedRule.singleValueReturnType>
-<else>
-	void
-<endif>
-%>
-
-delegateName(it) ::= <<
-<if(it.label)><it.label><else>g<it.name><endif>
->>
-
-/** Using a type to init value map, try to init a type; if not in table
- *  must be an object, default value is "null".
- */
-initValue(typeName) ::= <<
-default(<typeName>)
->>
-
-/** Define a rule label including default value */
-ruleLabelDef(label) ::= <%
-<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> = <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;
-%>
-
-/** Define a return struct for a rule if the code needs to access its
- *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
- *  subgroups to stick in members.
- */
-returnScope(scope) ::= <<
-<if(scope.attributes && ruleDescriptor.hasMultipleReturnValues)>
-<returnScopeModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> sealed partial class <ruleDescriptor:returnStructName()> : <ruleReturnBaseType()><@ruleReturnInterfaces()>
-{
-	<scope.attributes:{it|public <it.decl>;}; separator="\n">
-	<@ruleReturnMembers()>
-}
-<endif>
->>
-
-ruleReturnBaseType() ::= <%
-<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>>
-%>
-
-@returnScope.ruleReturnMembers() ::= <<
->>
-
-parameterScope(scope) ::= <<
-<scope.attributes:{it|<it.decl>}; separator=", ">
->>
-
-parameterAttributeRef(attr) ::= <<
-<attr.name; format="id">
->>
-
-parameterSetAttributeRef(attr,expr) ::= <<
-<attr.name; format="id"> =<expr>;
->>
-
-scopeAttributeRef(scope,attr,index,negIndex) ::= <%
-<if(negIndex)>
-<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id">
-<else>
-<if(index)>
-<scope>_stack[<index>].<attr.name; format="id">
-<else>
-<scope>_stack.Peek().<attr.name; format="id">
-<endif>
-<endif>
-%>
-
-scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
-<if(negIndex)>
-<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id"> = <expr>;
-<else>
-<if(index)>
-<scope>_stack[<index>].<attr.name; format="id"> = <expr>;
-<else>
-<scope>_stack.Peek().<attr.name; format="id"> = <expr>;
-<endif>
-<endif>
-%>
-
-/** $x is either global scope or x is rule with dynamic scope; refers
- *  to stack itself not top of stack.  This is useful for predicates
- *  like {$function.Count>0 && $function::name.Equals("foo")}?
- */
-isolatedDynamicScopeRef(scope) ::= "<scope>_stack"
-
-/** reference an attribute of rule; might only have single return value */
-ruleLabelRef(referencedRule,scope,attr) ::= <%
-<if(referencedRule.hasMultipleReturnValues)>
-(<scope>!=null?((<returnType(referencedRule)>)<scope>).<attr.name; format="id">:<initValue(attr.type)>)
-<else>
-<scope>
-<endif>
-%>
-
-returnAttributeRef(ruleDescriptor,attr) ::= <%
-<if(ruleDescriptor.hasMultipleReturnValues)>
-retval.<attr.name; format="id">
-<else>
-<attr.name; format="id">
-<endif>
-%>
-
-returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
-<if(ruleDescriptor.hasMultipleReturnValues)>
-retval.<attr.name; format="id"> =<expr>;
-<else>
-<attr.name; format="id"> =<expr>;
-<endif>
-%>
-
-/** How to translate $tokenLabel */
-tokenLabelRef(label) ::= "<label>"
-
-/** ids+=ID {$ids} or e+=expr {$e} */
-listLabelRef(label) ::= "list_<label>"
-
-
-// not sure the next are the right approach
-
-tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:default(string))"
-tokenLabelPropertyRef_type(scope,attr) ::= "(<scope>!=null?<scope>.Type:0)"
-tokenLabelPropertyRef_line(scope,attr) ::= "(<scope>!=null?<scope>.Line:0)"
-tokenLabelPropertyRef_pos(scope,attr) ::= "(<scope>!=null?<scope>.CharPositionInLine:0)"
-tokenLabelPropertyRef_channel(scope,attr) ::= "(<scope>!=null?<scope>.Channel:0)"
-tokenLabelPropertyRef_index(scope,attr) ::= "(<scope>!=null?<scope>.TokenIndex:0)"
-tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
-tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?int.Parse(<scope>.Text):0)"
-
-ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):default(<labelType>))"
-ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):default(<labelType>))"
-ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):default(<ASTLabelType>))"
-ruleLabelPropertyRef_text(scope,attr) ::= <%
-<if(TREE_PARSER)>
-(<scope>!=null?(input.TokenStream.ToString(
-  input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
-  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):default(string))
-<else>
-(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):default(string))
-<endif>
-%>
-
-ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?<scope>.Template:null)"
-
-/** Isolated $RULE ref ok in lexer as it's a Token */
-lexerRuleLabel(label) ::= "<label>"
-
-lexerRuleLabelPropertyRef_type(scope,attr) ::=
-    "(<scope>!=null?<scope>.Type:0)"
-
-lexerRuleLabelPropertyRef_line(scope,attr) ::=
-    "(<scope>!=null?<scope>.Line:0)"
-
-lexerRuleLabelPropertyRef_pos(scope,attr) ::=
-    "(<scope>!=null?<scope>.CharPositionInLine:-1)"
-
-lexerRuleLabelPropertyRef_channel(scope,attr) ::=
-    "(<scope>!=null?<scope>.Channel:0)"
-
-lexerRuleLabelPropertyRef_index(scope,attr) ::=
-    "(<scope>!=null?<scope>.TokenIndex:0)"
-
-lexerRuleLabelPropertyRef_text(scope,attr) ::=
-    "(<scope>!=null?<scope>.Text:default(string))"
-
-lexerRuleLabelPropertyRef_int(scope,attr) ::=
-    "(<scope>!=null?int.Parse(<scope>.Text):0)"
-
-// Somebody may ref $template or $tree or $stop within a rule:
-rulePropertyRef_start(scope,attr) ::= "retval.Start"
-rulePropertyRef_stop(scope,attr) ::= "retval.Stop"
-rulePropertyRef_tree(scope,attr) ::= "retval.Tree"
-rulePropertyRef_text(scope,attr) ::= <%
-<if(TREE_PARSER)>
-input.TokenStream.ToString(
-  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
-  input.TreeAdaptor.GetTokenStopIndex(retval.Start))
-<else>
-input.ToString(retval.Start,input.LT(-1))
-<endif>
-%>
-rulePropertyRef_st(scope,attr) ::= "retval.Template"
-
-lexerRulePropertyRef_text(scope,attr) ::= "Text"
-lexerRulePropertyRef_type(scope,attr) ::= "_type"
-lexerRulePropertyRef_line(scope,attr) ::= "state.tokenStartLine"
-lexerRulePropertyRef_pos(scope,attr) ::= "state.tokenStartCharPositionInLine"
-lexerRulePropertyRef_index(scope,attr) ::= "-1" // undefined token index in lexer
-lexerRulePropertyRef_channel(scope,attr) ::= "_channel"
-lexerRulePropertyRef_start(scope,attr) ::= "state.tokenStartCharIndex"
-lexerRulePropertyRef_stop(scope,attr) ::= "(CharIndex-1)"
-lexerRulePropertyRef_int(scope,attr) ::= "int.Parse(<scope>.Text)"
-
-// setting $st and $tree is allowed in local rule. everything else
-// is flagged as error
-ruleSetPropertyRef_tree(scope,attr,expr) ::= "retval.Tree = <expr>;"
-ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.Template =<expr>;"
-
-/** How to execute an action (only when not backtracking) */
-execAction(action) ::= <%
-<if(backtracking)>
-if (<actions.(actionScope).synpredgate>)<\n>
-{<\n>
-<@indentedAction()><\n>
-}
-<else>
-<action>
-<endif>
-%>
-
-@execAction.indentedAction() ::= <<
-	<action>
->>
-
-/** How to always execute an action even when backtracking */
-execForcedAction(action) ::= "<action>"
-
-// M I S C (properties, etc...)
-
-bitset(name, words64) ::= <<
-public static readonly BitSet <name> = new BitSet(new ulong[]{<words64:{it|<it>UL};separator=",">});
->>
-
-codeFileExtension() ::= ".cs"
-
-true_value() ::= "true"
-false_value() ::= "false"
-
-isTrue ::= [
-	"true" : true,
-	default : false
-]
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
deleted file mode 100644
index b537ff1..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
+++ /dev/null
@@ -1,313 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2007-2008 Johannes Luber
- * Copyright (c) 2005-2007 Kunle Odutola
- * Copyright (c) 2011 Sam Harwell
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-/** Template overrides to add debugging to normal Java output;
- *  If ASTs are built, then you'll also get ASTDbg.stg loaded.
- */
-
-@outputFile.debugPreprocessor() ::= "#define ANTLR_DEBUG"
-
-@outputFile.imports() ::= <<
-<@super.imports()>
-using Antlr.Runtime.Debug;
-using IOException = System.IO.IOException;
->>
-
-@genericParser.members() ::= <<
-<if(grammar.grammarIsRoot)>
-public static readonly string[] ruleNames =
-	new string[]
-	{
-		"invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n	", separator=", ">
-	};<\n>
-<endif>
-<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
-int ruleLevel = 0;
-public virtual int RuleLevel { get { return ruleLevel; } }
-public virtual void IncRuleLevel() { ruleLevel++; }
-public virtual void DecRuleLevel() { ruleLevel--; }
-<if(profile)>
-<ctorForProfilingRootGrammar()>
-<else>
-<ctorForRootGrammar()>
-<endif>
-<ctorForPredefinedListener()>
-<else><! imported grammar !>
-public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
-public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
-public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
-<ctorForDelegateGrammar()>
-<endif>
-<if(profile)>
-public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
-{
-	int stopIndex = GetRuleMemoization(ruleIndex, input.Index);
-	((Profiler)dbg).ExamineRuleMemoization(input, ruleIndex, stopIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-	return base.AlreadyParsedRule(input, ruleIndex);
-}<\n>
-public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
-{
-	((Profiler)dbg).Memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-	base.Memoize(input, ruleIndex, ruleStartIndex);
-}<\n>
-<endif>
-protected virtual bool EvalPredicate( bool result, string predicate )
-{
-	dbg.SemanticPredicate( result, predicate );
-	return result;
-}<\n>
->>
-
-ctorForRootGrammar() ::= <<
-<! bug: can't use <@super.members()> cut-n-paste instead !>
-<! Same except we add port number and profile stuff if root grammar !>
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
-	: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
-{
-}
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
-	: base( input, state )
-{
-	<createListenerAndHandshake()>
-	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
-	<parserCtorBody()>
-	<@finally()>
-}<\n>
->>
-
-ctorForProfilingRootGrammar() ::= <<
-<! bug: can't use <@super.members()> cut-n-paste instead !>
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
-	: this( input, new Profiler(null), new RecognizerSharedState() )
-{
-}
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
-	: base( input, dbg, state )
-{
-	Profiler p = (Profiler)dbg;
-	p.setParser(this);
-	<grammar.directDelegates:
-	 {g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
-	<parserCtorBody()>
-	<@finally()>
-}
-<\n>
->>
-
-/** Basically we don't want to set any dbg listeners are root will have it. */
-ctorForDelegateGrammar() ::= <<
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
-	: base( input, dbg, state )
-{
-	<grammar.directDelegates:
-	 {g|<g:delegateName()> = new <g.recognizerName>( input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
-	<parserCtorBody()>
-}<\n>
->>
-
-ctorForPredefinedListener() ::= <<
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg )
-	<@superClassRef>: base( input, dbg, new RecognizerSharedState() )<@end>
-{
-<if(profile)>
-	Profiler p = (Profiler)dbg;
-	p.setParser(this);
-<endif>
-	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
-	<parserCtorBody()>
-	<@finally()>
-}<\n>
->>
-
-createListenerAndHandshake() ::= <<
-<if(TREE_PARSER)>
-DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, input.TreeAdaptor );<\n>
-<else>
-DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, null );<\n>
-<endif>
-DebugListener = proxy;
-try
-{
-	proxy.Handshake();
-}
-catch ( IOException ioe )
-{
-	ReportError( ioe );
-}
->>
-
-@genericParser.superClassName() ::= "Debug<@super.superClassName()>"
-
-/*
- * Many of the following rules were merged into CSharp2.stg.
- */
-
-@rule.preamble() ::= <<
-if (RuleLevel == 0)
-	DebugListener.Commence();
-IncRuleLevel();
->>
-//@rule.preamble() ::= <<
-//try
-//{
-//	dbg.EnterRule( GrammarFileName, "<ruleName>" );
-//	if ( RuleLevel == 0 )
-//	{
-//		dbg.Commence();
-//	}
-//	IncRuleLevel();
-//	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
-//>>
-
-@rule.postamble() ::= <<
-DecRuleLevel();
-if (RuleLevel == 0)
-	DebugListener.Terminate();
->>
-//@rule.postamble() ::= <<
-//dbg.Location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
-//}
-//finally
-//{
-//	dbg.ExitRule( GrammarFileName, "<ruleName>" );
-//	DecRuleLevel();
-//	if ( RuleLevel == 0 )
-//	{
-//		dbg.Terminate();
-//	}
-//}<\n>
-//>>
-
-//@insertSynpreds.start() ::= "dbg.BeginBacktrack( state.backtracking );"
-//@insertSynpreds.stop() ::= "dbg.EndBacktrack( state.backtracking, success );"
-
-// Common debug event triggers used by region overrides below
-
-//enterSubRule() ::= <<
-//try
-//{
-//	dbg.EnterSubRule( <decisionNumber> );<\n>
-//>>
-
-//exitSubRule() ::= <<
-//}
-//finally
-//{
-//	dbg.ExitSubRule( <decisionNumber> );
-//}<\n>
-//>>
-
-//enterDecision() ::= <<
-//try
-//{
-//	dbg.EnterDecision( <decisionNumber> );<\n>
-//>>
-
-//exitDecision() ::= <<
-//}
-//finally
-//{
-//	dbg.ExitDecision( <decisionNumber> );
-//}<\n>
-//>>
-
-//enterAlt(n) ::= "dbg.EnterAlt( <n> );<\n>"
-
-// Region overrides that tell various constructs to add debugging triggers
-
-//@block.predecision() ::= "<enterSubRule()><enterDecision()>"
-
-//@block.postdecision() ::= "<exitDecision()>"
-
-//@block.postbranch() ::= "<exitSubRule()>"
-
-//@ruleBlock.predecision() ::= "<enterDecision()>"
-
-//@ruleBlock.postdecision() ::= "<exitDecision()>"
-
-//@ruleBlockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
-
-//@blockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
-
-//@positiveClosureBlock.preloop() ::= "<enterSubRule()>"
-
-//@positiveClosureBlock.postloop() ::= "<exitSubRule()>"
-
-//@positiveClosureBlock.predecision() ::= "<enterDecision()>"
-
-//@positiveClosureBlock.postdecision() ::= "<exitDecision()>"
-
-//@positiveClosureBlock.earlyExitException() ::=
-//	"dbg.RecognitionException( eee<decisionNumber> );<\n>"
-
-//@closureBlock.preloop() ::= "<enterSubRule()>"
-
-//@closureBlock.postloop() ::= "<exitSubRule()>"
-
-//@closureBlock.predecision() ::= "<enterDecision()>"
-
-//@closureBlock.postdecision() ::= "<exitDecision()>"
-
-//@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"
-
-//@element.prematch() ::=
-//	"dbg.Location( <it.line>, <it.pos> );"
-
-//@matchSet.mismatchedSetException() ::=
-//	"dbg.RecognitionException( mse );"
-
-//@dfaState.noViableAltException() ::= "dbg.RecognitionException( nvae );"
-
-//@dfaStateSwitch.noViableAltException() ::= "dbg.RecognitionException( nvae );"
-
-//dfaDecision(decisionNumber,description) ::= <<
-//try
-//{
-//	isCyclicDecision = true;
-//	<super.dfaDecision(...)>
-//}
-//catch ( NoViableAltException nvae )
-//{
-//	dbg.RecognitionException( nvae );
-//	throw nvae;
-//}
-//>>
-
-//@cyclicDFA.errorMethod() ::= <<
-//public override void Error( NoViableAltException nvae )
-//{
-//	((DebugParser)recognizer).dbg.RecognitionException( nvae );
-//}
-//>>
-
-/** Force predicate validation to trigger an event */
-evalPredicate(pred,description) ::= <<
-EvalPredicate(<pred>, "<description>")
->>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ST.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ST.stg
deleted file mode 100644
index d6dd973..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/ST.stg
+++ /dev/null
@@ -1,171 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2007-2008 Johannes Luber
- * Copyright (c) 2005-2007 Kunle Odutola
- * Copyright (c) 2011 Sam Harwell
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-/** Template subgroup to add template rewrite output
- *  If debugging, then you'll also get STDbg.stg loaded.
- */
-
-@outputFile.imports() ::= <<
-<@super.imports()>
-using Antlr.StringTemplate;
-using Antlr.StringTemplate.Language;
-<if(!backtracking)>
-using Hashtable = System.Collections.Hashtable;
-<endif>
-
->>
-
-/** Add this to each rule's return value struct */
-@returnScope.ruleReturnMembers() ::= <<
-private StringTemplate _st;
-public StringTemplate Template { get { return _st; } set { _st = value; } }
-public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
->>
-
-@genericParser.members() ::= <<
-<@super.members()>
-protected StringTemplateGroup templateLib = new StringTemplateGroup("<name>Templates", typeof(AngleBracketTemplateLexer) );
-
-public StringTemplateGroup TemplateLib
-{
- 	get { return this.templateLib; }
- 	set { this.templateLib = value; }
-}
-
-/// \<summary> Allows convenient multi-value initialization:
-///  "new STAttrMap().Add(...).Add(...)"
-/// \</summary>
-protected class STAttrMap : Hashtable
-{
-  public STAttrMap Add(string attrName, object value)
-  {
-    base.Add(attrName, value);
-    return this;
-  }
-  public STAttrMap Add(string attrName, int value)
-  {
-    base.Add(attrName, value);
-    return this;
-  }
-}
->>
-
-/** x+=rule when output=template */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRef(...)>
-<listLabel(elem=label+".Template",...)>
->>
-
-rewriteTemplate(alts) ::= <<
-
-// TEMPLATE REWRITE
-<if(backtracking)>
-if ( <actions.(actionScope).synpredgate> )
-{
-  <alts:rewriteTemplateAlt(); separator="else ">
-  <if(rewriteMode)><replaceTextInLine()><endif>
-}
-<else>
-<alts:rewriteTemplateAlt(); separator="else ">
-<if(rewriteMode)><replaceTextInLine()><endif>
-<endif>
->>
-
-replaceTextInLine() ::= <<
-<if(TREE_PARSER)>
-((TokenRewriteStream)input.TokenStream).Replace(
-  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
-  input.TreeAdaptor.GetTokenStopIndex(retval.Start),
-  retval.Template);
-<else>
-((TokenRewriteStream)input).Replace(
-  ((IToken)retval.Start).TokenIndex,
-  input.LT(-1).TokenIndex,
-  retval.Template);
-<endif>
->>
-
-rewriteTemplateAlt() ::= <<
-// <it.description>
-<if(it.pred)>
-if (<it.pred>) {
-    retval.Template = <it.alt>;
-}<\n>
-<else>
-{
-    retval.Template = <it.alt>;
-}<\n>
-<endif>
->>
-
-rewriteEmptyTemplate(alts) ::= <<
-null;
->>
-
-/** Invoke a template with a set of attribute name/value pairs.
- *  Set the value of the rule's template *after* having set
- *  the attributes because the rule's template might be used as
- *  an attribute to build a bigger template; you get a self-embedded
- *  template.
- */
-rewriteExternalTemplate(name,args) ::= <<
-templateLib.GetInstanceOf("<name>"<if(args)>,
-  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
-  <endif>)
->>
-
-/** expr is a string expression that says what template to load */
-rewriteIndirectTemplate(expr,args) ::= <<
-templateLib.GetInstanceOf(<expr><if(args)>,
-  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
-  <endif>)
->>
-
-/** Invoke an inline template with a set of attribute name/value pairs */
-rewriteInlineTemplate(args, template) ::= <<
-new StringTemplate(templateLib, "<template>"<if(args)>,
-  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
-  <endif>)
->>
-
-/** plain -> {foo} action */
-rewriteAction(action) ::= <<
-<action>
->>
-
-/** An action has %st.attrName=expr; or %{st}.attrName=expr; */
-actionSetAttribute(st,attrName,expr) ::= <<
-(<st>).SetAttribute("<attrName>",<expr>);
->>
-
-/** Translate %{stringExpr} */
-actionStringConstructor(stringExpr) ::= <<
-new StringTemplate(templateLib,<stringExpr>)
->>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
deleted file mode 100644
index d1d765a..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
+++ /dev/null
@@ -1,428 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-@outputFile.imports() ::= <<
-<@super.imports()>
-
-<if(!TREE_PARSER)>
-<! tree parser would already have imported !>
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
-<endif>
->>
-
-@genericParser.members() ::= <<
-<@super.members()>
-<parserMembers()>
->>
-
-parserCtorBody() ::= <<
-<super.parserCtorBody()>
-<treeAdaptorType()> treeAdaptor = default(<treeAdaptorType()>);
-CreateTreeAdaptor(ref treeAdaptor);
-TreeAdaptor = treeAdaptor<if(!actions.(actionScope).treeAdaptorType)> ?? new CommonTreeAdaptor()<endif>;
->>
-
-/** Add an adaptor property that knows how to build trees */
-parserMembers() ::= <<
-// Implement this function in your helper file to use a custom tree adaptor
-partial void CreateTreeAdaptor(ref <treeAdaptorType()> adaptor);
-
-private <treeAdaptorType()> adaptor;
-
-public <treeAdaptorType()> TreeAdaptor
-{
-	get
-	{
-		return adaptor;
-	}
-
-	set
-	{
-		this.adaptor = value;
-		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
-	}
-}
->>
-
-treeAdaptorType() ::= <<
-<actions.(actionScope).treeAdaptorType; null="ITreeAdaptor">
->>
-
-ruleReturnBaseType() ::= <%
-Ast<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<ASTLabelType>, <labelType>>
-%>
-
-/** Add a variable to track rule's return AST */
-ruleDeclarations() ::= <<
-<super.ruleDeclarations()>
-<ASTLabelType> root_0 = default(<ASTLabelType>);<\n>
->>
-
-ruleLabelDefs(ruleDescriptor, labelType, ASTLabelType, rewriteElementType) ::= <%
-<super.ruleLabelDefs(...)>
-<if(!ruleDescriptor.isSynPred)>
-<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-	:{it|<\n><ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}>
-<ruleDescriptor.tokenListLabels:{it|<\n><ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}>
-<ruleDescriptor.allTokenRefsInAltsWithRewrites
-	:{it|<\n>RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}>
-<ruleDescriptor.allRuleRefsInAltsWithRewrites
-	:{it|<\n>RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}>
-<endif>
-%>
-
-/** When doing auto AST construction, we must define some variables;
- *  These should be turned off if doing rewrites.  This must be a "mode"
- *  as a rule could have both rewrite and AST within the same alternative
- *  block.
- */
-@alt.declarations() ::= <<
-<if(autoAST && outerAlt && !rewriteMode && !ruleDescriptor.isSynPred)>
-root_0 = (<ASTLabelType>)adaptor.Nil();
-<endif>
->>
-
-// T r a c k i n g  R u l e  E l e m e n t s
-
-/** ID and track it for use in a rewrite rule */
-tokenRefTrack(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefBang(...)> <! Track implies no auto AST construction!>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
->>
-
-/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
- *  to the tracking list stream_ID for use in the rewrite.
- */
-tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefTrack(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** ^(ID ...) track for rewrite */
-tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefBang(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
->>
-
-/** Match ^(label+=TOKEN ...) track for rewrite */
-tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefRuleRootTrack(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** rule when output=AST and tracking for rewrite */
-ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
-<super.ruleRef(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule.name>.Add(<label>.Tree);
->>
-
-/** x+=rule when output=AST and tracking for rewrite */
-ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefTrack(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-/** ^(rule ...) rewrite */
-ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRoot(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule>.Add(<label>.Tree);
->>
-
-/** ^(x+=rule ...) rewrite */
-ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRootTrack(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-// R e w r i t e
-
-rewriteCode(
-	alts, description,
-	referencedElementsDeep, // ALL referenced elements to right of ->
-	referencedTokenLabels,
-	referencedTokenListLabels,
-	referencedRuleLabels,
-	referencedRuleListLabels,
-	referencedWildcardLabels,
-	referencedWildcardListLabels,
-	rewriteBlockLevel, enclosingTreeLevel, treeLevel) ::= <<
-<\n>{
-// AST REWRITE
-// elements: <referencedElementsDeep; separator=", ">
-// token labels: <referencedTokenLabels; separator=", ">
-// rule labels: <referencedRuleLabels; separator=", ">
-// token list labels: <referencedTokenListLabels; separator=", ">
-// rule list labels: <referencedRuleListLabels; separator=", ">
-// wildcard labels: <[referencedWildcardLabels,referencedWildcardListLabels]; separator=", ">
-<if(backtracking)>
-if (<actions.(actionScope).synpredgate>) {
-<endif>
-<prevRuleRootRef()>.Tree = root_0;
-<rewriteCodeLabels()>
-root_0 = (<ASTLabelType>)adaptor.Nil();
-<alts:rewriteAlt(); separator="else ">
-<! if tree parser and rewrite=true !>
-<if(TREE_PARSER&&rewriteMode)>
-<prevRuleRootRef()>.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
-if (<prevRuleRootRef()>.Tree != null)
-	input.ReplaceChildren(adaptor.GetParent(retval.Start), adaptor.GetChildIndex(retval.Start), adaptor.GetChildIndex(_last), retval.Tree);
-<endif>
-<! if parser or tree-parser && rewrite!=true, we need to set result !>
-<if(!TREE_PARSER||!rewriteMode)>
-<prevRuleRootRef()>.Tree = root_0;
-<endif>
-<if(backtracking)>
-}
-<endif>
-}
-
->>
-
-rewriteCodeLabels() ::= <<
-<referencedTokenLabels
-	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
-	separator="\n"
->
-<referencedTokenListLabels
-	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
-	separator="\n"
->
-<referencedWildcardLabels
-	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
-	separator="\n"
->
-<referencedWildcardListLabels
-	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
-	separator="\n"
->
-<referencedRuleLabels
-	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
-	separator="\n"
->
-<referencedRuleListLabels
-	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
-	separator="\n"
->
->>
-
-/** Generate code for an optional rewrite block; note it uses the deep ref'd element
-  *  list rather shallow like other blocks.
-  */
-rewriteOptionalBlock(
-	alt,rewriteBlockLevel,
-	referencedElementsDeep, // all nested refs
-	referencedElements, // elements in immediately block; no nested blocks
-	description) ::=
-<<
-// <fileName>:<description>
-if (<referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||">)
-{
-	<alt>
-}
-<referencedElementsDeep:{el | stream_<el>.Reset();<\n>}>
->>
-
-rewriteClosureBlock(
-	alt,rewriteBlockLevel,
-	referencedElementsDeep, // all nested refs
-	referencedElements, // elements in immediately block; no nested blocks
-	description) ::=
-<<
-// <fileName>:<description>
-while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
-{
-	<alt>
-}
-<referencedElements:{el | stream_<el>.Reset();<\n>}>
->>
-
-rewritePositiveClosureBlock(
-	alt,rewriteBlockLevel,
-	referencedElementsDeep, // all nested refs
-	referencedElements, // elements in immediately block; no nested blocks
-	description) ::=
-<<
-if (!(<referencedElements:{el | stream_<el>.HasNext}; separator="||">))
-{
-	throw new RewriteEarlyExitException();
-}
-while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
-{
-	<alt>
-}
-<referencedElements:{el | stream_<el>.Reset();<\n>}>
->>
-
-rewriteAlt(a) ::= <<
-// <a.description>
-<if(a.pred)>
-if (<a.pred>)
-{
-	<a.alt>
-}
-<else>
-{
-	<a.alt>
-}
-<endif>
->>
-
-/** For empty rewrites: "r : ... -> ;" */
-rewriteEmptyAlt() ::= "root_0 = null;"
-
-rewriteTree(root,children,description,enclosingTreeLevel,treeLevel) ::= <<
-// <fileName>:<description>
-{
-<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
-<root:rewriteElement()>
-<children:rewriteElement()>
-adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
-}<\n>
->>
-
-rewriteElementList(elements) ::= "<elements:rewriteElement()>"
-
-rewriteElement(e) ::= <%
-<@pregen()>
-DebugLocation(<e.line>, <e.pos>);<\n>
-<e.el>
-%>
-
-/** Gen ID or ID[args] */
-rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
-adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
->>
-
-/** Gen $label ... where defined via label=ID */
-rewriteTokenLabelRef(label,elementIndex) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
->>
-
-/** Gen $label ... where defined via label+=ID */
-rewriteTokenListLabelRef(label,elementIndex) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
->>
-
-/** Gen ^($label ...) */
-rewriteTokenLabelRefRoot(label,elementIndex) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
->>
-
-/** Gen ^($label ...) where label+=... */
-rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot
-
-/** Gen ^(ID ...) or ^(ID[args] ...) */
-rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
->>
-
-rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
-adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
->>
-
-rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
->>
-
-/** plain -> {foo} action */
-rewriteAction(action) ::= <<
-root_0 = <action>;<\n>
->>
-
-/** What is the name of the previous value of this rule's root tree?  This
- *  let's us refer to $rule to mean previous value.  I am reusing the
- *  variable 'tree' sitting in retval struct to hold the value of root_0 right
- *  before I set it during rewrites.  The assign will be to retval.tree.
- */
-prevRuleRootRef() ::= "retval"
-
-rewriteRuleRef(rule) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<rule>.NextTree());<\n>
->>
-
-rewriteRuleRefRoot(rule) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<rule>.NextNode(), root_<treeLevel>);<\n>
->>
-
-rewriteNodeAction(action) ::= <<
-adaptor.AddChild(root_<treeLevel>, <action>);<\n>
->>
-
-rewriteNodeActionRoot(action) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<action>, root_<treeLevel>);<\n>
->>
-
-/** Gen $ruleLabel ... where defined via ruleLabel=rule */
-rewriteRuleLabelRef(label) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
->>
-
-/** Gen $ruleLabel ... where defined via ruleLabel+=rule */
-rewriteRuleListLabelRef(label) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
->>
-
-/** Gen ^($ruleLabel ...) where ruleLabel=rule */
-rewriteRuleLabelRefRoot(label) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
->>
-
-/** Gen ^($ruleLabel ...) where ruleLabel+=rule */
-rewriteRuleListLabelRefRoot(label) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
->>
-
-rewriteWildcardLabelRef(label) ::= <<
-adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
->>
-
-createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
-<if(terminalOptions.node)>
-<! new MethodNode(IDLabel, args) !>
-new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
-<else>
-(<ASTLabelType>)adaptor.Create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
-<endif>
-%>
-
-createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
-<if(terminalOptions.node)>
-new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
-<else>
-<if(args)> <! must create new node from old !>
-adaptor.Create(<token>, <args; separator=", ">)
-<else>
-stream_<token>.NextNode()
-<endif>
-<endif>
-%>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
deleted file mode 100644
index b4b245a..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** Template overrides to add debugging to AST stuff.  Dynamic inheritance
- *  hierarchy is set up as ASTDbg : AST : Dbg : Java by code generator.
- */
-
-parserMembers() ::= <<
-	// Implement this function in your helper file to use a custom tree adaptor
-	partial void InitializeTreeAdaptor();
-	protected DebugTreeAdaptor adaptor;
-
-	public ITreeAdaptor TreeAdaptor
-	{
-		get
-		{
-			return adaptor;
-		}
-		set
-		{
-<if(grammar.grammarIsRoot)>
-			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
-<else>
-			this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
-<endif><\n>
-			<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
-		}
-	}<\n>
->>
-
-parserCtorBody() ::= <<
-<super.parserCtorBody()>
->>
-
-createListenerAndHandshake() ::= <<
-DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, <if(TREE_PARSER)>input.TreeAdaptor<else>adaptor<endif> );
-DebugListener = proxy;
-<inputStreamType> = new Debug<inputStreamType>( input, proxy );
-try
-{
-	proxy.Handshake();
-}
-catch ( IOException ioe )
-{
-	ReportError( ioe );
-}
->>
-
-@ctorForRootGrammar.finally() ::= <<
-ITreeAdaptor adap = new CommonTreeAdaptor();
-TreeAdaptor = adap;
-proxy.TreeAdaptor = adap;
->>
-
-@ctorForProfilingRootGrammar.finally() ::=<<
-ITreeAdaptor adap = new CommonTreeAdaptor();
-TreeAdaptor = adap;
->>
-
-@ctorForPredefinedListener.superClassRef() ::= ": base( input, dbg )"
-
-@ctorForPredefinedListener.finally() ::=<<
-<if(grammar.grammarIsRoot)><! don't create new adaptor for delegates !>
-ITreeAdaptor adap = new CommonTreeAdaptor();
-TreeAdaptor = adap;<\n>
-<endif>
->>
-
-//@rewriteElement.pregen() ::= "dbg.Location( <e.line>, <e.pos> );"
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
deleted file mode 100644
index b97d44b..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
+++ /dev/null
@@ -1,203 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** Templates for building ASTs during normal parsing.
- *
- *  Deal with many combinations.  Dimensions are:
- *  Auto build or rewrite
- *    no label, label, list label  (label/no-label handled together)
- *    child, root
- *    token, set, rule, wildcard
- *
- *  The situation is not too bad as rewrite (->) usage makes ^ and !
- *  invalid. There is no huge explosion of combinations.
- */
-
-@rule.setErrorReturnValue() ::= <<
-retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
-<! System.out.WriteLine("<ruleName> returns "+((CommonTree)retval.tree).toStringTree()); !>
->>
-
-// TOKEN AST STUFF
-
-/** ID and output=AST */
-tokenRef(token,label,elementIndex,terminalOptions={}) ::= <%
-<super.tokenRef(...)>
-<if(!ruleDescriptor.isSynPred)>
-<if(backtracking)><\n>if (state.backtracking == 0) {<endif>
-<\n><label>_tree = <createNodeFromToken(...)>;
-<\n>adaptor.AddChild(root_0, <label>_tree);
-<if(backtracking)><\n>}<endif>
-<endif>
-%>
-
-/** ID! and output=AST (same as plain tokenRef) */
-tokenRefBang(token,label,elementIndex,terminalOptions={}) ::= "<super.tokenRef(...)>"
-
-/** ID^ and output=AST */
-tokenRefRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <%
-<super.tokenRef(...)>
-<if(!ruleDescriptor.isSynPred)>
-<if(backtracking)><\n>if (<actions.(actionScope).synpredgate>) {<endif>
-<\n><label>_tree = <createNodeFromToken(...)>;
-<\n>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
-<if(backtracking)><\n>}<endif>
-<endif>
-%>
-
-/** ids+=ID! and output=AST */
-tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefBang(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** label+=TOKEN when output=AST but not rewrite alt */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRef(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** Match label+=TOKEN^ when output=AST but not rewrite alt */
-tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRefRuleRoot(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-// SET AST
-
-// the match set stuff is interesting in that it uses an argument list
-// to pass code to the default matchSet; another possible way to alter
-// inherited code.  I don't use the region stuff because I need to pass
-// different chunks depending on the operator.  I don't like making
-// the template name have the operator as the number of templates gets
-// large but this is the most flexible--this is as opposed to having
-// the code generator call matchSet then add root code or ruleroot code
-// plus list label plus ...  The combinations might require complicated
-// rather than just added on code.  Investigate that refactoring when
-// I have more time.
-
-matchSet(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= <<
-<super.matchSet(postmatchCode={<if(!ruleDescriptor.isSynPred)><if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);<endif>}, ...)>
->>
-
-matchRuleBlockSet(s,label,elementIndex,postmatchCode,treeLevel="0",terminalOptions={}) ::= <<
-<matchSet(...)>
->>
-
-matchSetBang(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= "<super.matchSet(...)>"
-
-// note there is no matchSetTrack because -> rewrites force sets to be
-// plain old blocks of alts: (A|B|...|C)
-
-matchSetRuleRoot(s,label,elementIndex,debug,terminalOptions={}) ::= <<
-<if(label)>
-<label>=(<labelType>)input.LT(1);
-<endif>
-<super.matchSet(postmatchCode={<if(!ruleDescriptor.isSynPred)><if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);<endif>}, ...)>
->>
-
-// RULE REF AST
-
-/** rule when output=AST */
-ruleRef(rule,label,elementIndex,args,scope) ::= <%
-<super.ruleRef(...)>
-<if(!ruleDescriptor.isSynPred)>
-<\n><if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <label>.Tree);
-<endif>
-%>
-
-/** rule! is same as normal rule ref */
-ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(...)>"
-
-/** rule^ */
-ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
-<super.ruleRef(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
->>
-
-/** x+=rule when output=AST */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRef(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-/** x+=rule! when output=AST is a rule ref with list addition */
-ruleRefBangAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefBang(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-/** x+=rule^ */
-ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRoot(...)>
-<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
->>
-
-// WILDCARD AST
-
-wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
-<super.wildcard(...)>
-<if(!ruleDescriptor.isSynPred)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
-adaptor.AddChild(root_0, <label>_tree);
-<if(backtracking)>}<endif>
-<endif>
->>
-
-wildcardBang(label,elementIndex) ::= "<super.wildcard(token=[],...)>"
-
-wildcardRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
-<super.wildcard(...)>
-<if(!ruleDescriptor.isSynPred)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
-root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
-<if(backtracking)>}<endif>
-<endif>
->>
-
-createNodeFromToken(label,terminalOptions={}) ::= <%
-<if(terminalOptions.node)>
-new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
-<else>
-(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
-<endif>
-%>
-
-ruleCleanUp() ::= <<
-<super.ruleCleanUp()>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
-adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
-<if(backtracking)>}<endif>
->>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
deleted file mode 100644
index c5529b2..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
+++ /dev/null
@@ -1,377 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-/** Templates for building ASTs during tree parsing.
- *
- *  Deal with many combinations.  Dimensions are:
- *  Auto build or rewrite
- *    no label, label, list label  (label/no-label handled together)
- *    child, root
- *    token, set, rule, wildcard
- *
- *  Each combination has its own template except that label/no label
- *  is combined into tokenRef, ruleRef, ...
- */
-
-/** Add a variable to track last element matched */
-ruleDeclarations() ::= <<
-<super.ruleDeclarations()>
-<if(!ruleDescriptor.isSynPred)>
-<ASTLabelType> _first_0 = default(<ASTLabelType>);
-<ASTLabelType> _last = default(<ASTLabelType>);
-<endif>
->>
-
-/** What to emit when there is no rewrite rule.  For auto build
- *  mode, does nothing.
- */
-noRewrite(rewriteBlockLevel=false, treeLevel=false) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(rewriteMode)>
-retval.Tree = (<ASTLabelType>)_first_0;
-if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
-	retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
-<endif>
-<if(backtracking)>}<endif>
-<endif>
->>
-
-/** match ^(root children) in tree parser; override here to
- *  add tree construction actions.
- */
-tree(root, actionsAfterRoot, children, nullableChildList,
-     enclosingTreeLevel, treeLevel) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-{
-<ASTLabelType> _save_last_<treeLevel> = _last;
-<ASTLabelType> _first_<treeLevel> = default(<ASTLabelType>);
-<if(!rewriteMode)>
-<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
-<endif>
-<root:element()>
-<if(rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
-<if(root.el.rule)>
-if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
-<else>
-if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>;
-<endif>
-<endif>
-<actionsAfterRoot:element()>
-<if(nullableChildList)>
-if (input.LA(1) == TokenTypes.Down) {
-	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-	<children:element()>
-	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
-}
-<else>
-Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-<children:element()>
-Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
-<endif>
-<if(!rewriteMode)>
-adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
-<endif>
-_last = _save_last_<treeLevel>;
-}
-<else>
-<super.tree(...)>
-<endif>
->>
-
-// TOKEN AST STUFF
-
-/** ID! and output=AST (same as plain tokenRef) 'cept add
- *  setting of _last
- */
-tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
-<else>
-<super.tokenRefBang(...)>
-<endif>
->>
-
-/** ID auto construct */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<endif><\n>
-adaptor.AddChild(root_<treeLevel>, <label>_tree);
-<if(backtracking)>}<endif>
-<else> <! rewrite mode !>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
-if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
-<endif>
-<else>
-<super.tokenRef(...)>
-<endif>
->>
-
-/** label+=TOKEN auto construct */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<tokenRef(...)>
-<listLabelElem(elem=label,...)>
-<else>
-<super.tokenRefAndListLabel(...)>
-<endif>
->>
-
-/** ^(ID ...) auto construct */
-tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<endif><\n>
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
-<if(backtracking)>}<endif>
-<endif>
-<else>
-<super.tokenRefRuleRoot(...)>
-<endif>
->>
-
-/** Match ^(label+=TOKEN ...) auto construct */
-tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<tokenRefRuleRoot(...)>
-<listLabelElem(elem=label,...)>
-<else>
-<super.tokenRefRuleRootAndListLabel(...)>
-<endif>
->>
-
-/** Match . wildcard and auto dup the node/subtree */
-wildcard(token,label,elementIndex,terminalOptions) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.wildcard(...)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<label>_tree = (<ASTLabelType>)adaptor.DupTree(<label>);
-adaptor.AddChild(root_<treeLevel>, <label>_tree);
-<if(backtracking)>}<endif>
-<else> <! rewrite mode !>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
-if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
-<endif>
-<else>
-<super.wildcard(...)>
-<endif>
->>
-
-// SET AST
-
-matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.matchSet(postmatchCode={
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<endif><\n>
-adaptor.AddChild(root_<treeLevel>, <label>_tree);
-<if(backtracking)>\}<endif>
-<endif>
-}, ...
-)>
-<else>
-<super.matchSet(...)>
-<endif>
->>
-
-matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<matchSet(...)>
-<noRewrite(...)> <! set return tree !>
-<else>
-<super.matchRuleBlockSet(...)>
-<endif>
->>
-
-matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.matchSet(...)>
-<else>
-<super.matchSetBang(...)>
-<endif>
->>
-
-matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<super.matchSet(postmatchCode={
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
-<endif><\n>
-root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
-<if(backtracking)>\}<endif>
-<endif>
-}, ...
-)>
-<else>
-<super.matchSetRuleRoot(...)>
-<endif>
->>
-
-// RULE REF AST
-
-/** rule auto construct */
-ruleRef(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRef(...)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
-<if(!rewriteMode)>
-adaptor.AddChild(root_<treeLevel>, <label>.Tree);
-<else> <! rewrite mode !>
-if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
-<endif>
-<else>
-<super.ruleRef(...)>
-<endif>
->>
-
-/** x+=rule auto construct */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<ruleRef(...)>
-<listLabelElem(elem={<label>.Tree},...)>
-<else>
-<super.ruleRefAndListLabel(...)>
-<endif>
->>
-
-/** ^(rule ...) auto construct */
-ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRef(...)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
-<endif>
-<else>
-<super.ruleRefRuleRoot(...)>
-<endif>
->>
-
-/** ^(x+=rule ...) auto construct */
-ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-<ruleRefRuleRoot(...)>
-<listLabelElem(elem={<label>.Tree},...)>
-<else>
-<super.ruleRefRuleRootAndListLabel(...)>
-<endif>
->>
-
-/** rule when output=AST and tracking for rewrite */
-ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRefTrack(...)>
->>
-
-/** x+=rule when output=AST and tracking for rewrite */
-ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRefTrackAndListLabel(...)>
-<else>
-<super.ruleRefTrackAndListLabel(...)>
-<endif>
->>
-
-/** ^(rule ...) rewrite */
-ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRefRootTrack(...)>
-<else>
-<super.ruleRefRuleRootTrack(...)>
-<endif>
->>
-
-/** ^(x+=rule ...) rewrite */
-ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<if(!ruleDescriptor.isSynPred)>
-_last = (<ASTLabelType>)input.LT(1);
-<super.ruleRefRuleRootTrackAndListLabel(...)>
-<else>
-<super.ruleRefRuleRootTrackAndListLabel(...)>
-<endif>
->>
-
-/** Streams for token refs are tree nodes now; override to
- *  change NextToken to NextNode.
- */
-createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
-<if(terminalOptions.node)>
-new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
-<else>
-stream_<token>.NextNode()
-<endif>
-%>
-
-ruleCleanUp() ::= <<
-<super.ruleCleanUp()>
-<if(!ruleDescriptor.isSynPred)>
-<if(!rewriteMode)>
-<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
-retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
-<if(backtracking)>}<endif>
-<endif>
-<endif>
->>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
deleted file mode 100644
index c9229e1..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ /dev/null
@@ -1,1749 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-csharpVisibilityMap ::= [
-	"private":"private",
-	"protected":"protected",
-	"public":"public",
-	"fragment":"private",
-	default:"private"
-]
-
-/** The overall file structure of a recognizer; stores methods for rules
- *  and cyclic DFAs plus support code.
- */
-outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
-			docComment, recognizer,
-			name, tokens, tokenNames, rules, cyclicDFAs,
-			bitsets, buildTemplate, buildAST, rewriteMode, profile,
-			backtracking, synpreds, memoize, numRules,
-			fileName, ANTLRVersion, generatedTimestamp, trace,
-			scopes, superClass, literals) ::=
-<<
-//------------------------------------------------------------------------------
-// \<auto-generated>
-//     This code was generated by a tool.
-//     ANTLR Version: <ANTLRVersion>
-//
-//     Changes to this file may cause incorrect behavior and will be lost if
-//     the code is regenerated.
-// \</auto-generated>
-//------------------------------------------------------------------------------
-
-// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>
-
-// The variable 'variable' is assigned but its value is never used.
-#pragma warning disable 219
-// Unreachable code detected.
-#pragma warning disable 162
-// Missing XML comment for publicly visible type or member 'Type_or_Member'
-#pragma warning disable 1591
-// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
-#pragma warning disable 3019
-
-<actions.(actionScope).header>
-
-<@imports>
-using System.Collections.Generic;
-using Antlr.Runtime;
-using Antlr.Runtime.Misc;
-<if(TREE_PARSER)>
-using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
-<endif>
-<@end>
-<if(actions.(actionScope).namespace)>
-namespace <actions.(actionScope).namespace>
-{
-<endif>
-<docComment>
-<recognizer>
-<if(actions.(actionScope).namespace)>
-
-} // namespace <actions.(actionScope).namespace>
-<endif>
->>
-
-lexerInputStreamType() ::= <<
-<actions.(actionScope).inputStreamType; null="ICharStream">
->>
-
-lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
-	  superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>},
-	  rewriteElementType={}, ASTLabelType={}) ::= <<
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
-[System.CLSCompliant(false)]
-<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
-{
-	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
-	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
-	<actions.lexer.members>
-
-	// delegates
-	<grammar.delegates:
-		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-	// delegators
-	<grammar.delegators:
-		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
-
-	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
-	{
-		OnCreated();
-	}
-
-	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
-		: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
-	{
-	}
-
-	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
-		: base(input, state)
-	{
-<if(memoize)>
-<if(grammar.grammarIsRoot)>
-		state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<numRules>+1];<\n><! index from 1..n !>
-<endif>
-<endif>
-		<grammar.directDelegates:
-		 {g|<g:delegateName()> = new <g.recognizerName>(input, this.state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-		<grammar.delegators:
-		 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
-		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-
-		OnCreated();
-	}
-	public override string GrammarFileName { get { return "<fileName>"; } }
-
-<if(grammar.hasDelegates)>
-	public override <lexerInputStreamType()> CharStream
-	{
-		get
-		{
-			return base.CharStream;
-		}
-		set
-		{
-			base.CharStream = value;
-			<grammar.directDelegates:
-			 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-			<grammar.delegators:
-			 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
-			<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-		}
-	}
-
-<if(grammar.delegates)>
-	public override void SetState(RecognizerSharedState state)
-	{
-		base.SetState(state);
-		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
-	}
-<endif>
-
-<endif>
-<if(filterMode)>
-	<filteringNextToken()>
-<endif>
-
-
-	partial void OnCreated();
-	partial void EnterRule(string ruleName, int ruleIndex);
-	partial void LeaveRule(string ruleName, int ruleIndex);
-
-	<rules; separator="\n">
-
-	<insertLexerSynpreds(synpreds)>
-
-	#region DFA
-	<cyclicDFAs:{dfa | DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif>);}; separator="\n">
-	}
-
-	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
-	#endregion
-
-}
->>
-
-/** A override of Lexer.nextToken() that backtracks over mTokens() looking
- *  for matches.  No error can be generated upon error; just rewind, consume
- *  a token and then try again.  backtracking needs to be set as well.
- *  Make rule memoization happen only at levels above 1 as we start mTokens
- *  at backtracking==1.
- */
-filteringNextToken() ::= <<
-public override IToken NextToken()
-{
-	while (true)
-	{
-		if (input.LA(1) == CharStreamConstants.EndOfFile)
-		{
-			IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
-			eof.Line = Line;
-			eof.CharPositionInLine = CharPositionInLine;
-			return eof;
-		}
-		state.token = null;
-		state.channel = TokenChannels.Default;
-		state.tokenStartCharIndex = input.Index;
-		state.tokenStartCharPositionInLine = input.CharPositionInLine;
-		state.tokenStartLine = input.Line;
-		state.text = null;
-		try
-		{
-			int m = input.Mark();
-			state.backtracking=1;<! means we won't throw slow exception !>
-			state.failed=false;
-			mTokens();
-			state.backtracking=0;
-			<! mTokens backtracks with synpred at backtracking==2
-			   and we set the synpredgate to allow actions at level 1. !>
-			if (state.failed)
-			{
-				input.Rewind(m);
-				input.Consume();<! advance one char and try again !>
-			}
-			else
-			{
-				Emit();
-				return state.token;
-			}
-		}
-		catch (RecognitionException re)
-		{
-			// shouldn't happen in backtracking mode, but...
-			ReportError(re);
-			Recover(re);
-		}
-	}
-}
-
-public override void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex)
-{
-	if (state.backtracking > 1)
-		base.Memoize(input, ruleIndex, ruleStartIndex);
-}
-
-public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
-{
-	if (state.backtracking > 1)
-		return base.AlreadyParsedRule(input, ruleIndex);
-
-	return false;
-}
->>
-
-actionGate() ::= "state.backtracking == 0"
-
-filteringActionGate() ::= "state.backtracking == 1"
-
-/** How to generate a parser */
-genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
-              bitsets, inputStreamType, superClass,
-              labelType, members, rewriteElementType,
-              filterMode, ASTLabelType="object") ::= <<
-[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
-[System.CLSCompliant(false)]
-<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
-{
-<if(grammar.grammarIsRoot)>
-	internal static readonly string[] tokenNames = new string[] {
-		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
-	};
-<endif>
-	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
-
-<if(grammar.delegates)>
-	// delegates
-	<grammar.delegates:
-		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-<endif>
-<if(grammar.delegators)>
-	// delegators
-	<grammar.delegators:
-		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
-<endif>
-
-<if(grammar.delegates)>
-	public override void SetState(RecognizerSharedState state)
-	{
-		base.SetState(state);
-		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
-	}
-
-<if(TREE_PARSER)>
-	public override void SetTreeNodeStream(ITreeNodeStream input)
-	{
-		base.SetTreeNodeStream(input);
-		<grammar.delegates:{g|<g:delegateName()>.SetTreeNodeStream(input);}; separator="\n">
-	}
-<endif>
-<endif>
-
-	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
-	<@members()>
-
-	public override string[] TokenNames { get { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; } }
-	public override string GrammarFileName { get { return "<fileName>"; } }
-
-	<members>
-
-	partial void OnCreated();
-	partial void EnterRule(string ruleName, int ruleIndex);
-	partial void LeaveRule(string ruleName, int ruleIndex);
-
-	#region Rules
-	<rules; separator="\n">
-	#endregion Rules
-
-<if(grammar.delegatedRules)>
-<! generate rule/method definitions for imported rules so they
-   appear to be defined in this recognizer. !>
-	#region Delegated rules
-<grammar.delegatedRules:{ruleDescriptor|
-	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)<!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", "><endif>); \}}; separator="\n">
-	#endregion Delegated rules
-<endif>
-
-	<insertSynpreds(synpreds)>
-
-<if(cyclicDFAs)>
-	#region DFA
-	<cyclicDFAs:{dfa | private DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
-
-	protected override void InitDFAs()
-	{
-		base.InitDFAs();
-		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>( this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif> );}; separator="\n">
-	}
-
-	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
-	#endregion DFA
-<endif>
-
-<if(bitsets)>
-	#region Follow sets
-	private static class Follow
-	{
-		<bitsets:{it|<bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>}; separator="\n">
-	}
-	#endregion Follow sets
-<endif>
-}
->>
-
-@genericParser.members() ::= <<
-<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
-<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
-	: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
-{
-}
-<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
-	: base(input, state)
-{
-<if(grammar.directDelegates)>
-	<grammar.directDelegates:
-		{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-<endif>
-<if(grammar.indirectDelegates)>
-	<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
-<endif>
-<if(grammar.delegators)>
-	<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-<endif>
-	<parserCtorBody()>
-	OnCreated();
-}
->>
-
-// imported grammars are 'public' (can't be internal because their return scope classes must be accessible)
-parserModifier(grammar, actions) ::= <<
-<if(grammar.grammarIsRoot)><actions.(actionScope).modifier; null="public"><else>public<endif>
->>
-
-parserCtorBody() ::= <<
-<if(memoize)>
-<if(grammar.grammarIsRoot)>
-this.state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<length(grammar.allImportedRules)>+1];<\n><! index from 1..n !>
-<endif>
-<endif>
-<grammar.delegators:
- {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
->>
-
-parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
-       ASTLabelType="object", superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Parser<endif>}, labelType="IToken",
-       members={<actions.parser.members>}) ::= <<
-<genericParser(inputStreamType="ITokenStream", rewriteElementType="IToken", filterMode=false, ...)>
->>
-
-/** How to generate a tree parser; same as parser except the input
- *  stream is a different type.
- */
-treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
-           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="object",
-           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif><endif>},
-           members={<actions.treeparser.members>}) ::= <<
-<genericParser(inputStreamType="ITreeNodeStream", rewriteElementType="Node", ...)>
->>
-
-/** A simpler version of a rule template that is specific to the imaginary
- *  rules created for syntactic predicates.  As they never have return values
- *  nor parameters etc..., just give simplest possible method.  Don't do
- *  any of the normal memoization stuff in here either; it's a waste.
- *  As predicates cannot be inlined into the invoking rule, they need to
- *  be in a rule by themselves.
- */
-synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
-<<
-
-partial void EnterRule_<ruleName>_fragment();
-partial void LeaveRule_<ruleName>_fragment();
-
-// $ANTLR start <ruleName>
-<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
-{
-	<ruleLabelDefs(...)>
-	EnterRule_<ruleName>_fragment();
-	EnterRule("<ruleName>_fragment", <ruleDescriptor.index>);
-	TraceIn("<ruleName>_fragment", <ruleDescriptor.index>);
-	try
-	{
-		<block>
-	}
-	finally
-	{
-		TraceOut("<ruleName>_fragment", <ruleDescriptor.index>);
-		LeaveRule("<ruleName>_fragment", <ruleDescriptor.index>);
-		LeaveRule_<ruleName>_fragment();
-	}
-}
-// $ANTLR end <ruleName>
->>
-
-insertLexerSynpreds(synpreds) ::= <<
-<insertSynpreds(synpreds)>
->>
-
-insertSynpreds(synpreds) ::= <<
-<if(synpreds)>
-#region Synpreds
-private bool EvaluatePredicate(System.Action fragment)
-{
-	bool success = false;
-	state.backtracking++;
-	<@start()>
-	try { DebugBeginBacktrack(state.backtracking);
-	int start = input.Mark();
-	try
-	{
-		fragment();
-	}
-	catch ( RecognitionException re )
-	{
-		System.Console.Error.WriteLine("impossible: "+re);
-	}
-	success = !state.failed;
-	input.Rewind(start);
-	} finally { DebugEndBacktrack(state.backtracking, success); }
-	<@stop()>
-	state.backtracking--;
-	state.failed=false;
-	return success;
-}
-#endregion Synpreds
-<endif>
->>
-
-ruleMemoization(name) ::= <<
-<if(memoize)>
-if (state.backtracking > 0 && AlreadyParsedRule(input, <ruleDescriptor.index>)) { <returnFromRule()> }
-<endif>
->>
-
-/** How to test for failure and return from rule */
-checkRuleBacktrackFailure() ::= <<
-<if(backtracking)>if (state.failed) <returnFromRule()><endif>
->>
-
-/** This rule has failed, exit indicating failure during backtrack */
-ruleBacktrackFailure() ::= <<
-<if(backtracking)>if (state.backtracking>0) {state.failed=true; <returnFromRule()>}<endif>
->>
-
-ruleWrapperMap ::= [
-	"bottomup":{<ruleWrapperBottomup()>},
-	"topdown":{<ruleWrapperTopdown()>},
-	default:""
-]
-
-ruleWrapperBottomup() ::= <<
-<if(TREE_PARSER && filterMode)>
-protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Bottomup() { <if(buildAST)>return <endif>bottomup(); }
-<endif>
->>
-
-ruleWrapperTopdown() ::= <<
-<if(TREE_PARSER && filterMode)>
-protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Topdown() { <if(buildAST)>return <endif>topdown(); }
-<endif>
->>
-
-/** How to generate code for a rule.  This includes any return type
- *  data aggregates required for multiple return values.
- */
-rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memoize) ::= <<
-<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
-<returnScope(ruleDescriptor.returnScope)>
-partial void EnterRule_<ruleName>();
-partial void LeaveRule_<ruleName>();
-<ruleWrapperMap.(ruleName)>
-// $ANTLR start "<ruleName>"
-// <fileName>:<description>
-[GrammarRule("<ruleName>")]
-<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)
-{
-	EnterRule_<ruleName>();
-	EnterRule("<ruleName>", <ruleDescriptor.index>);
-	TraceIn("<ruleName>", <ruleDescriptor.index>);
-	<ruleScopeSetUp()>
-	<ruleDeclarations()>
-	<ruleLabelDefs(...)>
-	<ruleDescriptor.actions.init>
-	try { DebugEnterRule(GrammarFileName, "<ruleName>");
-	DebugLocation(<ruleDescriptor.tree.line>, <ruleDescriptor.EORNode.charPositionInLine>);
-	<@preamble()>
-	try
-	{
-		<ruleMemoization(name=ruleName)>
-		<block>
-		<ruleCleanUp()>
-		<(ruleDescriptor.actions.after):execAction()>
-	}
-<if(exceptions)>
-	<exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
-<else>
-<if(!emptyRule)>
-<if(actions.(actionScope).rulecatch)>
-	<actions.(actionScope).rulecatch>
-<else>
-	catch (RecognitionException re)
-	{
-		ReportError(re);
-		Recover(input,re);
-		<@setErrorReturnValue()>
-	}
-<endif>
-<endif>
-<endif>
-	finally
-	{
-		TraceOut("<ruleName>", <ruleDescriptor.index>);
-		LeaveRule("<ruleName>", <ruleDescriptor.index>);
-		LeaveRule_<ruleName>();
-		<memoize()>
-		<ruleScopeCleanUp()>
-		<finally>
-	}
-	DebugLocation(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);
-	} finally { DebugExitRule(GrammarFileName, "<ruleName>"); }
-	<@postamble()>
-	<returnFromRule()><\n>
-}
-// $ANTLR end "<ruleName>"
->>
-
-// imported grammars need to have internal rules
-ruleModifier(grammar,ruleDescriptor) ::= <<
-<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>internal<endif>
->>
-
-// imported grammars need to have public return scopes
-returnScopeModifier(grammar,ruleDescriptor) ::= <<
-<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>public<endif>
->>
-
-catch(decl,action) ::= <<
-catch (<e.decl>)
-{
-	<e.action>
-}
->>
-
-ruleDeclarations() ::= <<
-<if(ruleDescriptor.hasMultipleReturnValues)>
-<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>(<if(ruleDescriptor.returnScope.attributes)>this<endif>);
-retval.Start = (<labelType>)input.LT(1);
-<elseif(ruleDescriptor.returnScope)>
-<ruleDescriptor.returnScope.attributes:{ a |
-<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
-}>
-<endif>
-<if(memoize)>
-int <ruleDescriptor.name>_StartIndex = input.Index;
-<endif>
->>
-
-ruleScopeSetUp() ::= <<
-<ruleDescriptor.useScopes:{it|<it>_stack.Push(new <it>_scope(this));<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
-<ruleDescriptor.ruleScope:{it|<it.name>_stack.Push(new <it.name>_scope(this));<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
->>
-
-ruleScopeCleanUp() ::= <<
-<ruleDescriptor.useScopes:{it|<it>_scopeAfter(<it>_stack.Peek());<it>_stack.Pop();}; separator="\n">
-<ruleDescriptor.ruleScope:{it|<it.name>_scopeAfter(<it.name>_stack.Peek());<it.name>_stack.Pop();}; separator="\n">
->>
-
-ruleLabelDefs(ruleDescriptor, labelType, ASTLabelType, rewriteElementType) ::= <<
-<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-	:{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
->
-<ruleDescriptor.tokenListLabels
-	:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
->
-<[ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-	:{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
->
-<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
-<ruleDescriptor.ruleListLabels:ruleLabelDef(); separator="\n">
->>
-
-lexerRuleLabelDefs() ::= <<
-<[ruleDescriptor.tokenLabels,
-  ruleDescriptor.tokenListLabels,
-  ruleDescriptor.ruleLabels]
-	:{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
->
-<[ruleDescriptor.charListLabels,
-  ruleDescriptor.charLabels]
-	:{it|int <it.label.text> = 0;}; separator="\n"
->
-<[ruleDescriptor.tokenListLabels,
-  ruleDescriptor.ruleListLabels]
-	:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
->
-<ruleDescriptor.charListLabels:{it|List\<int> list_<it.label.text> = null;}; separator="\n"
->
->>
-
-returnFromRule() ::= <%
-return
-<if(!ruleDescriptor.isSynPred)>
-<if(ruleDescriptor.hasReturnValue)>
-<if(ruleDescriptor.hasSingleReturnValue)>
-<! This comment is a hack to make sure the following
-   single space appears in the output. !> <ruleDescriptor.singleValueReturnName>
-<else>
-<!!> retval
-<endif>
-<endif>
-<endif>
-;
-%>
-
-ruleCleanUp() ::= <<
-<if(ruleDescriptor.hasMultipleReturnValues)>
-<if(!TREE_PARSER)>
-retval.Stop = (<labelType>)input.LT(-1);
-<endif>
-<endif>
->>
-
-memoize() ::= <<
-<if(memoize)>
-<if(backtracking)>
-if (state.backtracking > 0) { Memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex); }
-<endif>
-<endif>
->>
-
-/** How to generate a rule in the lexer; naked blocks are used for
- *  fragment rules.
- */
-lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
-
-partial void EnterRule_<ruleName>();
-partial void LeaveRule_<ruleName>();
-
-// $ANTLR start "<ruleName>"
-[GrammarRule("<ruleName>")]
-<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>)
-{
-	EnterRule_<ruleName>();
-	EnterRule("<ruleName>", <ruleDescriptor.index>);
-	TraceIn("<ruleName>", <ruleDescriptor.index>);
-	<ruleScopeSetUp()>
-	<ruleDeclarations()>
-	try
-	{
-<if(nakedBlock)>
-		<ruleMemoization(name=ruleName)>
-		<lexerRuleLabelDefs()>
-		<ruleDescriptor.actions.init>
-		<block>
-<else>
-		int _type = <ruleName>;
-		int _channel = DefaultTokenChannel;
-		<ruleMemoization(name=ruleName)>
-		<lexerRuleLabelDefs()>
-		<ruleDescriptor.actions.init>
-		<block>
-		<ruleCleanUp()>
-		state.type = _type;
-		state.channel = _channel;
-		<(ruleDescriptor.actions.after):execAction()>
-<endif>
-	}
-	finally
-	{
-		TraceOut("<ruleName>", <ruleDescriptor.index>);
-		LeaveRule("<ruleName>", <ruleDescriptor.index>);
-		LeaveRule_<ruleName>();
-		<ruleScopeCleanUp()>
-		<memoize()>
-	}
-}
-// $ANTLR end "<ruleName>"
->>
-
-/** How to generate code for the implicitly-defined lexer grammar rule
- *  that chooses between lexer rules.
- */
-tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
-
-public override void mTokens()
-{
-	<block><\n>
-}
->>
-
-// S U B R U L E S
-
-/** A (...) subrule with multiple alternatives */
-block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
-// <fileName>:<description>
-int alt<decisionNumber>=<maxAlt>;
-<decls>
-<@predecision()>
-try { DebugEnterSubRule(<decisionNumber>);
-try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
-<decision>
-} finally { DebugExitDecision(<decisionNumber>); }
-<@postdecision()>
-<@prebranch()>
-switch (alt<decisionNumber>)
-{
-<alts:{a|<altSwitchCase(i,a)>}>
-}
-} finally { DebugExitSubRule(<decisionNumber>); }
-<@postbranch()>
->>
-
-/** A rule block with multiple alternatives */
-ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
-// <fileName>:<description>
-int alt<decisionNumber>=<maxAlt>;
-<decls>
-<@predecision()>
-try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
-<decision>
-} finally { DebugExitDecision(<decisionNumber>); }
-<@postdecision()>
-switch (alt<decisionNumber>)
-{
-<alts:{a|<altSwitchCase(i,a)>}>
-}
->>
-
-ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
-// <fileName>:<description>
-<decls>
-<@prealt()>
-DebugEnterAlt(1);
-<alts>
-<@postalt()>
->>
-
-/** A special case of a (...) subrule with a single alternative */
-blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
-// <fileName>:<description>
-<decls>
-<@prealt()>
-DebugEnterAlt(1);
-<alts>
-<@postalt()>
->>
-
-/** A (..)+ block with 1 or more alternatives */
-positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
-// <fileName>:<description>
-int cnt<decisionNumber>=0;
-<decls>
-<@preloop()>
-try { DebugEnterSubRule(<decisionNumber>);
-while (true)
-{
-	int alt<decisionNumber>=<maxAlt>;
-	<@predecision()>
-	try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
-	<decision>
-	} finally { DebugExitDecision(<decisionNumber>); }
-	<@postdecision()>
-	switch (alt<decisionNumber>)
-	{
-	<alts:{a|<altSwitchCase(i,a)>}>
-	default:
-		if (cnt<decisionNumber> >= 1)
-			goto loop<decisionNumber>;
-
-		<ruleBacktrackFailure()>
-		EarlyExitException eee<decisionNumber> = new EarlyExitException( <decisionNumber>, input );
-		DebugRecognitionException(eee<decisionNumber>);
-		<@earlyExitException()>
-		throw eee<decisionNumber>;
-	}
-	cnt<decisionNumber>++;
-}
-loop<decisionNumber>:
-	;
-
-} finally { DebugExitSubRule(<decisionNumber>); }
-<@postloop()>
->>
-
-positiveClosureBlockSingleAlt ::= positiveClosureBlock
-
-/** A (..)* block with 1 or more alternatives */
-closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
-// <fileName>:<description>
-<decls>
-<@preloop()>
-try { DebugEnterSubRule(<decisionNumber>);
-while (true)
-{
-	int alt<decisionNumber>=<maxAlt>;
-	<@predecision()>
-	try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
-	<decision>
-	} finally { DebugExitDecision(<decisionNumber>); }
-	<@postdecision()>
-	switch ( alt<decisionNumber> )
-	{
-	<alts:{a|<altSwitchCase(i,a)>}>
-	default:
-		goto loop<decisionNumber>;
-	}
-}
-
-loop<decisionNumber>:
-	;
-
-} finally { DebugExitSubRule(<decisionNumber>); }
-<@postloop()>
->>
-
-closureBlockSingleAlt ::= closureBlock
-
-/** Optional blocks (x)? are translated to (x|) by before code generation
- *  so we can just use the normal block template
- */
-optionalBlock ::= block
-
-optionalBlockSingleAlt ::= block
-
-/** A case in a switch that jumps to an alternative given the alternative
- *  number.  A DFA predicts the alternative and then a simple switch
- *  does the jump to the code that actually matches that alternative.
- */
-altSwitchCase(altNum,alt) ::= <<
-case <altNum>:
-	<@prealt()>
-	DebugEnterAlt(<altNum>);
-	<alt>
-	break;<\n>
->>
-
-/** An alternative is just a list of elements; at outermost level */
-alt(elements,altNum,description,autoAST,outerAlt,treeLevel,rew) ::= <<
-// <fileName>:<description>
-{
-<@declarations()>
-<elements:element()>
-<rew>
-<@cleanup()>
-}
->>
-
-/** What to emit when there is no rewrite.  For auto build
- *  mode, does nothing.
- */
-noRewrite(rewriteBlockLevel, treeLevel) ::= ""
-
-// E L E M E N T S
-
-/** Dump the elements one per line */
-element(it) ::= <%
-<@prematch()>
-DebugLocation(<it.line>, <it.pos>);<\n>
-<it.el><\n>
-%>
-
-/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
-<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
->>
-
-/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<tokenRef(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-listLabel(label,elem) ::= <<
-#error The listLabel template should not be used with this target.<\n>
->>
-
-listLabelElem(label,elem,elemType) ::= <<
-if (list_<label>==null) list_<label>=new List\<<elemType; null={<labelType>}>\>();
-list_<label>.Add(<elem>);<\n>
->>
-
-/** match a character */
-charRef(char,label) ::= <<
-<if(label)>
-<label> = input.LA(1);<\n>
-<endif>
-Match(<char>); <checkRuleBacktrackFailure()>
->>
-
-/** match a character range */
-charRangeRef(a,b,label) ::= <<
-<if(label)>
-<label> = input.LA(1);<\n>
-<endif>
-MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
->>
-
-/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,elementIndex,postmatchCode="",terminalOptions={}) ::= <<
-<if(label)>
-<matchSetLabel()>
-<endif>
-if (<s>)
-{
-	input.Consume();
-	<postmatchCode>
-	<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
-}
-else
-{
-	<ruleBacktrackFailure()>
-	MismatchedSetException mse = new MismatchedSetException(null,input);
-	DebugRecognitionException(mse);
-	<@mismatchedSetException()>
-<if(LEXER)>
-	Recover(mse);
-	throw mse;
-<else>
-	throw mse;
-	<! use following code to make it recover inline; remove throw mse;
-	recoverFromMismatchedSet(input,mse,Follow._set_in_<ruleName><elementIndex>);
-	!>
-<endif>
-}<\n>
->>
-
-matchSetUnchecked(s,label,elementIndex,postmatchCode=false) ::= <%
-<if(label)>
-<matchSetLabel()><\n>
-<endif>
-input.Consume();<\n>
-<if(postmatchCode)>
-<postmatchCode><\n>
-<endif>
-<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
-%>
-
-matchSetLabel() ::= <%
-<if(LEXER)>
-<label>= input.LA(1);
-<else>
-<label>=(<labelType>)input.LT(1);
-<endif>
-%>
-
-matchRuleBlockSet ::= matchSet
-
-matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
-<matchSet(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** Match a string literal */
-lexerStringRef(string,label,elementIndex) ::= <%
-<if(label)>
-int <label>Start = CharIndex;<\n>
-Match(<string>); <checkRuleBacktrackFailure()><\n>
-int <label>StartLine<elementIndex> = Line;<\n>
-int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
-<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start, CharIndex-1);<\n>
-<label>.Line = <label>StartLine<elementIndex>;<\n>
-<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
-<else>
-Match(<string>); <checkRuleBacktrackFailure()><\n>
-<endif>
-%>
-
-wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
-<if(label)>
-<label>=(<labelType>)input.LT(1);<\n>
-<endif>
-MatchAny(input); <checkRuleBacktrackFailure()>
->>
-
-wildcardAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
-<wildcard(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** Match . wildcard in lexer */
-wildcardChar(label, elementIndex) ::= <<
-<if(label)>
-<label> = input.LA(1);<\n>
-<endif>
-MatchAny(); <checkRuleBacktrackFailure()>
->>
-
-wildcardCharListLabel(label, elementIndex) ::= <<
-<wildcardChar(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** Match a rule reference by invoking it possibly with arguments
- *  and a return value or values.  The 'rule' argument was the
- *  target rule name, but now is type Rule, whose toString is
- *  same: the rule name.  Now though you can access full rule
- *  descriptor stuff.
- */
-ruleRef(rule,label,elementIndex,args,scope) ::= <<
-PushFollow(Follow._<rule.name>_in_<ruleName><elementIndex>);
-<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name; format="id">(<args; separator=", ">);
-PopFollow();
-<checkRuleBacktrackFailure()>
->>
-
-/** ids+=r */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRef(...)>
-<listLabelElem(elem=label,elemType={<ASTLabelType>},...)>
->>
-
-/** A lexer rule reference.
- *
- *  The 'rule' argument was the target rule name, but now
- *  is type Rule, whose toString is same: the rule name.
- *  Now though you can access full rule descriptor stuff.
- */
-lexerRuleRef(rule,label,args,elementIndex,scope) ::= <%
-<if(label)>
-int <label>Start<elementIndex> = CharIndex;<\n>
-int <label>StartLine<elementIndex> = Line;<\n>
-int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
-<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()><\n>
-<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
-<label>.Line = <label>StartLine<elementIndex>;<\n>
-<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
-<else>
-<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
-<endif>
-%>
-
-/** i+=INT in lexer */
-lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
-<lexerRuleRef(...)>
-<listLabelElem(elem=label,elemType=labelType,...)>
->>
-
-/** EOF in the lexer */
-lexerMatchEOF(label,elementIndex) ::= <%
-<if(label)>
-int <label>Start<elementIndex> = CharIndex;<\n>
-int <label>StartLine<elementIndex> = Line;<\n>
-int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
-Match(EOF); <checkRuleBacktrackFailure()><\n>
-<labelType> <label> = new <labelType>(input, EOF, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
-<label>.Line = <label>StartLine<elementIndex>;<\n>
-<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
-<else>
-Match(EOF); <checkRuleBacktrackFailure()>
-<endif>
-%>
-
-// used for left-recursive rules
-recRuleDefArg()                       ::= "int <recRuleArg()>"
-recRuleArg()                          ::= "_p"
-recRuleAltPredicate(ruleName,opPrec)  ::= "<recRuleArg()> \<= <opPrec>"
-recRuleSetResultAction()              ::= "root_0=$<ruleName>_primary.tree;"
-
-/** match ^(root children) in tree parser */
-tree(root, actionsAfterRoot, children, nullableChildList,
-     enclosingTreeLevel, treeLevel) ::= <<
-<root:element()>
-<actionsAfterRoot:element()>
-<if(nullableChildList)>
-if (input.LA(1) == TokenTypes.Down)
-{
-	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-	<children:element()>
-	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
-}
-<else>
-Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-<children:element()>
-Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
-<endif>
->>
-
-/** Every predicate is used as a validating predicate (even when it is
- *  also hoisted into a prediction expression).
- */
-validateSemanticPredicate(pred,description) ::= <<
-if (!(<evalPredicate(...)>))
-{
-	<ruleBacktrackFailure()>
-	throw new FailedPredicateException(input, "<ruleName>", "<description>");
-}
->>
-
-// F i x e d  D F A  (if-then-else)
-
-dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
-<edges; separator="\nelse ">
-else
-{
-<if(eotPredictsAlt)>
-	alt<decisionNumber> = <eotPredictsAlt>;
-<else>
-	<ruleBacktrackFailure()>
-	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input, <k>);
-	DebugRecognitionException(nvae);
-	<@noViableAltException()>
-	throw nvae;
-<endif>
-}
->>
-
-/** Same as a normal DFA state except that we don't examine lookahead
- *  for the bypass alternative.  It delays error detection but this
- *  is faster, smaller, and more what people expect.  For (X)? people
- *  expect "if ( LA(1)==X ) match(X);" and that's it.
- */
-dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
-<edges; separator="\nelse ">
->>
-
-/** A DFA state that is actually the loopback decision of a closure
- *  loop.  If end-of-token (EOT) predicts any of the targets then it
- *  should act like a default clause (i.e., no error can be generated).
- *  This is used only in the lexer so that for ('a')* on the end of a rule
- *  anything other than 'a' predicts exiting.
- */
-dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
-<edges; separator="\nelse "><\n>
-<if(eotPredictsAlt)>
-<if(!edges)>
-alt<decisionNumber> = <eotPredictsAlt>;<! if no edges, don't gen ELSE !>
-<else>
-else
-{
-	alt<decisionNumber> = <eotPredictsAlt>;
-}<\n>
-<endif>
-<endif>
->>
-
-/** An accept state indicates a unique alternative has been predicted */
-dfaAcceptState(alt) ::= "alt<decisionNumber> = <alt>;"
-
-/** A simple edge with an expression.  If the expression is satisfied,
- *  enter to the target state.  To handle gated productions, we may
- *  have to evaluate some predicates for this edge.
- */
-dfaEdge(labelExpr, targetState, predicates) ::= <<
-if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>)
-{
-	<targetState>
-}
->>
-
-// F i x e d  D F A  (switch case)
-
-/** A DFA state where a SWITCH may be generated.  The code generator
- *  decides if this is possible: CodeGenerator.canGenerateSwitch().
- */
-dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-switch (input.LA(<k>))
-{
-<edges; separator="\n">
-default:
-<if(eotPredictsAlt)>
-	alt<decisionNumber>=<eotPredictsAlt>;
-	break;<\n>
-<else>
-	{
-		<ruleBacktrackFailure()>
-		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input, <k>);
-		DebugRecognitionException(nvae);
-		<@noViableAltException()>
-		throw nvae;
-	}
-<endif>
-}<\n>
->>
-
-dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-switch (input.LA(<k>))
-{
-<edges; separator="\n">
-}<\n>
->>
-
-dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-switch (input.LA(<k>))
-{
-<edges; separator="\n">
-<if(eotPredictsAlt)>
-default:
-	alt<decisionNumber>=<eotPredictsAlt>;
-	break;<\n>
-<endif>
-}<\n>
->>
-
-dfaEdgeSwitch(labels, targetState) ::= <<
-<labels:{it|case <it>:}; separator="\n">
-	{
-	<targetState>
-	}
-	break;
->>
-
-// C y c l i c  D F A
-
-/** The code to initiate execution of a cyclic DFA; this is used
- *  in the rule to predict an alt just like the fixed DFA case.
- *  The <name> attribute is inherited via the parser, lexer, ...
- */
-dfaDecision(decisionNumber,description) ::= <<
-try
-{
-	alt<decisionNumber> = dfa<decisionNumber>.Predict(input);
-}
-catch (NoViableAltException nvae)
-{
-	DebugRecognitionException(nvae);
-	throw;
-}
->>
-
-/* Dump DFA tables as run-length-encoded Strings of octal values.
- * Can't use hex as compiler translates them before compilation.
- * These strings are split into multiple, concatenated strings.
- * Java puts them back together at compile time thankfully.
- * Java cannot handle large static arrays, so we're stuck with this
- * encode/decode approach.  See analysis and runtime DFA for
- * the encoding methods.
- */
-cyclicDFA(dfa) ::= <<
-private class DFA<dfa.decisionNumber> : DFA
-{
-	private const string DFA<dfa.decisionNumber>_eotS =
-		"<dfa.javaCompressedEOT; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_eofS =
-		"<dfa.javaCompressedEOF; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_minS =
-		"<dfa.javaCompressedMin; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_maxS =
-		"<dfa.javaCompressedMax; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_acceptS =
-		"<dfa.javaCompressedAccept; wrap="\"+\n\t\t\"">";
-	private const string DFA<dfa.decisionNumber>_specialS =
-		"<dfa.javaCompressedSpecial; wrap="\"+\n\t\t\"">}>";
-	private static readonly string[] DFA<dfa.decisionNumber>_transitionS =
-		{
-			<dfa.javaCompressedTransition:{s|"<s; wrap="\"+\n\"">"}; separator=",\n">
-		};
-
-	private static readonly short[] DFA<dfa.decisionNumber>_eot = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eotS);
-	private static readonly short[] DFA<dfa.decisionNumber>_eof = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eofS);
-	private static readonly char[] DFA<dfa.decisionNumber>_min = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_minS);
-	private static readonly char[] DFA<dfa.decisionNumber>_max = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_maxS);
-	private static readonly short[] DFA<dfa.decisionNumber>_accept = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_acceptS);
-	private static readonly short[] DFA<dfa.decisionNumber>_special = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_specialS);
-	private static readonly short[][] DFA<dfa.decisionNumber>_transition;
-
-	static DFA<dfa.decisionNumber>()
-	{
-		int numStates = DFA<dfa.decisionNumber>_transitionS.Length;
-		DFA<dfa.decisionNumber>_transition = new short[numStates][];
-		for ( int i=0; i \< numStates; i++ )
-		{
-			DFA<dfa.decisionNumber>_transition[i] = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_transitionS[i]);
-		}
-	}
-
-	public DFA<dfa.decisionNumber>( BaseRecognizer recognizer<if(dfa.specialStateSTs)>, SpecialStateTransitionHandler specialStateTransition<endif> )
-<if(dfa.specialStateSTs)>
-		: base(specialStateTransition)
-<endif>
-	{
-		this.recognizer = recognizer;
-		this.decisionNumber = <dfa.decisionNumber>;
-		this.eot = DFA<dfa.decisionNumber>_eot;
-		this.eof = DFA<dfa.decisionNumber>_eof;
-		this.min = DFA<dfa.decisionNumber>_min;
-		this.max = DFA<dfa.decisionNumber>_max;
-		this.accept = DFA<dfa.decisionNumber>_accept;
-		this.special = DFA<dfa.decisionNumber>_special;
-		this.transition = DFA<dfa.decisionNumber>_transition;
-	}
-
-	public override string Description { get { return "<dfa.description>"; } }
-
-	public override void Error(NoViableAltException nvae)
-	{
-		DebugRecognitionException(nvae);
-	}
-}<\n>
-<if(dfa.specialStateSTs)>
-private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStream _input)<! throws NoViableAltException!>
-{
-	<if(LEXER)>
-	IIntStream input = _input;
-	<endif>
-	<if(PARSER)>
-	ITokenStream input = (ITokenStream)_input;
-	<endif>
-	<if(TREE_PARSER)>
-	ITreeNodeStream input = (ITreeNodeStream)_input;
-	<endif>
-	int _s = s;
-	s = -1;
-	<! pull these outside the switch cases to save space on locals !>
-	int LA<dfa.decisionNumber>_1 = input.LA(1);
-	int index<dfa.decisionNumber>_1 = input.Index;
-	switch (_s)
-	{
-	<dfa.specialStateSTs:{state |case <i0>:<! compressed special state numbers 0..n-1 !>
-	<state>}; separator="\n">
-
-	default:
-		break;
-	}
-
-	if (s >= 0)
-		return s;
-
-<if(backtracking)>
-	if (state.backtracking > 0) {state.failed=true; return -1;}
-<endif>
-	NoViableAltException nvae = new NoViableAltException(dfa.Description, <dfa.decisionNumber>, _s, input);
-	dfa.Error(nvae);
-	throw nvae;
-}
-<endif>
->>
-
-/** A state in a cyclic DFA; it's a special state and part of a big switch on
- *  state.
- */
-cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
-{
-<if(semPredState)>
-	<! get next lookahead symbol to test edges, then rewind !>
-	input.Rewind();
-<endif>
-	<edges; separator="\nelse ">
-<if(semPredState)>
-	<! return input cursor to state before we rewound !>
-	input.Seek(index<decisionNumber>_1);
-<endif>
-	break;
-}
->>
-
-/** Just like a fixed DFA edge, test the lookahead and indicate what
- *  state to jump to next if successful.
- */
-cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
-if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
->>
-
-/** An edge pointing at end-of-token; essentially matches any char;
- *  always jump to the target.
- */
-eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
-s = <targetStateNumber>;<\n>
->>
-
-
-// D F A  E X P R E S S I O N S
-
-andPredicates(left,right) ::= "(<left>&&<right>)"
-
-orPredicates(operands) ::= "(<operands; separator=\"||\">)"
-
-notPredicate(pred) ::= "!(<evalPredicate(...)>)"
-
-evalPredicate(pred,description) ::= "(<pred>)"
-
-evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"
-
-lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<k>==<atom>"
-
-/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
- *  somewhere.  Must ask for the lookahead directly.
- */
-isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"
-
-lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
-(LA<decisionNumber>_<k><ge()><lower> && LA<decisionNumber>_<k><le()><upper>)
-%>
-
-isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"
-
-le() ::= "\<="
-ge() ::= ">="
-
-setTest(ranges) ::= <<
-<ranges; separator="||">
->>
-
-// A T T R I B U T E S
-
-attributeScope(scope) ::= <<
-<if(scope)>
-<if(scope.attributes)>
-protected sealed partial class <scope.name>_scope
-{
-	<scope.attributes:{it|public <it.decl>;}; separator="\n">
-
-	public <scope.name>_scope(<grammar.recognizerName> grammar) { OnCreated(grammar); }
-	partial void OnCreated(<grammar.recognizerName> grammar);
-}
-<if(scope.actions.scopeinit)>
-protected void <scope.name>_scopeInit( <scope.name>_scope scope )
-{
-	<scope.actions.scopeinit>
-}
-<else>
-partial void <scope.name>_scopeInit( <scope.name>_scope scope );
-<endif>
-<if(scope.actions.scopeafter)>
-protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
-{
-	<scope.actions.scopeafter>
-}
-<else>
-partial void <scope.name>_scopeAfter( <scope.name>_scope scope );
-<endif>
-protected readonly ListStack\<<scope.name>_scope> <scope.name>_stack = new ListStack\<<scope.name>_scope>();
-<endif>
-<endif>
->>
-
-globalAttributeScope(scope) ::= <<
-<attributeScope(...)>
->>
-
-ruleAttributeScope(scope) ::= <<
-<attributeScope(...)>
->>
-
-returnStructName(it) ::= "<it.name>_return"
-
-returnType(ruleDescriptor) ::= <%
-<if(ruleDescriptor.returnScope.attributes && ruleDescriptor.hasMultipleReturnValues)>
-	<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
-<elseif(ruleDescriptor.hasMultipleReturnValues)>
-	<ruleReturnBaseType()>
-<elseif(ruleDescriptor.hasSingleReturnValue)>
-	<ruleDescriptor.singleValueReturnType>
-<else>
-	void
-<endif>
-%>
-
-/** Generate the C# type associated with a single or multiple return
- *  values.
- */
-ruleLabelType(referencedRule) ::= <%
-<if(referencedRule.hasMultipleReturnValues)>
-	<ruleReturnBaseType()>
-<elseif(referencedRule.hasSingleReturnValue)>
-	<referencedRule.singleValueReturnType>
-<else>
-	void
-<endif>
-%>
-
-delegateName(it) ::= <<
-<if(it.label)><it.label><else>g<it.name><endif>
->>
-
-/** Using a type to init value map, try to init a type; if not in table
- *  must be an object, default value is "null".
- */
-initValue(typeName) ::= <<
-default(<typeName>)
->>
-
-/** Define a rule label including default value */
-ruleLabelDef(label) ::= <%
-<ruleLabelType(label.referencedRule)> <label.label.text> = <initValue(ruleLabelType(label.referencedRule))>;
-%>
-
-/** Define a return struct for a rule if the code needs to access its
- *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
- *  subgroups to stick in members.
- */
-returnScope(scope) ::= <<
-<if(scope.attributes && ruleDescriptor.hasMultipleReturnValues)>
-<returnScopeModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> sealed partial class <ruleDescriptor:returnStructName()> : <ruleReturnBaseType()><@ruleReturnInterfaces()>
-{
-	<scope.attributes:{it|public <it.decl>;}; separator="\n">
-	<@ruleReturnMembers()>
-}
-<endif>
->>
-
-ruleReturnBaseType() ::= <%
-<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>>
-%>
-
-@returnScope.ruleReturnMembers() ::= <<
-public <ruleDescriptor:returnStructName()>(<grammar.recognizerName> grammar) {OnCreated(grammar);}
-partial void OnCreated(<grammar.recognizerName> grammar);
->>
-
-parameterScope(scope) ::= <<
-<scope.attributes:{it|<it.decl>}; separator=", ">
->>
-
-parameterAttributeRef(attr) ::= <<
-<attr.name; format="id">
->>
-
-parameterSetAttributeRef(attr,expr) ::= <<
-<attr.name; format="id"> =<expr>;
->>
-
-scopeAttributeRef(scope,attr,index,negIndex) ::= <%
-<if(negIndex)>
-<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id">
-<else>
-<if(index)>
-<scope>_stack[<index>].<attr.name; format="id">
-<else>
-<scope>_stack.Peek().<attr.name; format="id">
-<endif>
-<endif>
-%>
-
-scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
-<if(negIndex)>
-<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id"> = <expr>;
-<else>
-<if(index)>
-<scope>_stack[<index>].<attr.name; format="id"> = <expr>;
-<else>
-<scope>_stack.Peek().<attr.name; format="id"> = <expr>;
-<endif>
-<endif>
-%>
-
-/** $x is either global scope or x is rule with dynamic scope; refers
- *  to stack itself not top of stack.  This is useful for predicates
- *  like {$function.Count>0 && $function::name.Equals("foo")}?
- */
-isolatedDynamicScopeRef(scope) ::= "<scope>_stack"
-
-/** reference an attribute of rule; might only have single return value */
-ruleLabelRef(referencedRule,scope,attr) ::= <%
-<if(referencedRule.hasMultipleReturnValues)>
-(<scope>!=null?((<returnType(referencedRule)>)<scope>).<attr.name; format="id">:<initValue(attr.type)>)
-<else>
-<scope>
-<endif>
-%>
-
-returnAttributeRef(ruleDescriptor,attr) ::= <%
-<if(ruleDescriptor.hasMultipleReturnValues)>
-retval.<attr.name; format="id">
-<else>
-<attr.name; format="id">
-<endif>
-%>
-
-returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
-<if(ruleDescriptor.hasMultipleReturnValues)>
-retval.<attr.name; format="id"> =<expr>;
-<else>
-<attr.name; format="id"> =<expr>;
-<endif>
-%>
-
-/** How to translate $tokenLabel */
-tokenLabelRef(label) ::= "<label>"
-
-/** ids+=ID {$ids} or e+=expr {$e} */
-listLabelRef(label) ::= "list_<label>"
-
-
-// not sure the next are the right approach
-
-tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:default(string))"
-tokenLabelPropertyRef_type(scope,attr) ::= "(<scope>!=null?<scope>.Type:0)"
-tokenLabelPropertyRef_line(scope,attr) ::= "(<scope>!=null?<scope>.Line:0)"
-tokenLabelPropertyRef_pos(scope,attr) ::= "(<scope>!=null?<scope>.CharPositionInLine:0)"
-tokenLabelPropertyRef_channel(scope,attr) ::= "(<scope>!=null?<scope>.Channel:0)"
-tokenLabelPropertyRef_index(scope,attr) ::= "(<scope>!=null?<scope>.TokenIndex:0)"
-tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
-tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?int.Parse(<scope>.Text):0)"
-
-ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):default(<labelType>))"
-ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):default(<labelType>))"
-ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):default(<ASTLabelType>))"
-ruleLabelPropertyRef_text(scope,attr) ::= <%
-<if(TREE_PARSER)>
-(<scope>!=null?(input.TokenStream.ToString(
-  input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
-  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):default(string))
-<else>
-(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):default(string))
-<endif>
-%>
-
-ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?<scope>.Template:null)"
-
-/** Isolated $RULE ref ok in lexer as it's a Token */
-lexerRuleLabel(label) ::= "<label>"
-
-lexerRuleLabelPropertyRef_type(scope,attr) ::=
-    "(<scope>!=null?<scope>.Type:0)"
-
-lexerRuleLabelPropertyRef_line(scope,attr) ::=
-    "(<scope>!=null?<scope>.Line:0)"
-
-lexerRuleLabelPropertyRef_pos(scope,attr) ::=
-    "(<scope>!=null?<scope>.CharPositionInLine:-1)"
-
-lexerRuleLabelPropertyRef_channel(scope,attr) ::=
-    "(<scope>!=null?<scope>.Channel:0)"
-
-lexerRuleLabelPropertyRef_index(scope,attr) ::=
-    "(<scope>!=null?<scope>.TokenIndex:0)"
-
-lexerRuleLabelPropertyRef_text(scope,attr) ::=
-    "(<scope>!=null?<scope>.Text:default(string))"
-
-lexerRuleLabelPropertyRef_int(scope,attr) ::=
-    "(<scope>!=null?int.Parse(<scope>.Text):0)"
-
-// Somebody may ref $template or $tree or $stop within a rule:
-rulePropertyRef_start(scope,attr) ::= "retval.Start"
-rulePropertyRef_stop(scope,attr) ::= "retval.Stop"
-rulePropertyRef_tree(scope,attr) ::= "retval.Tree"
-rulePropertyRef_text(scope,attr) ::= <%
-<if(TREE_PARSER)>
-input.TokenStream.ToString(
-  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
-  input.TreeAdaptor.GetTokenStopIndex(retval.Start))
-<else>
-input.ToString(retval.Start,input.LT(-1))
-<endif>
-%>
-rulePropertyRef_st(scope,attr) ::= "retval.Template"
-
-lexerRulePropertyRef_text(scope,attr) ::= "Text"
-lexerRulePropertyRef_type(scope,attr) ::= "_type"
-lexerRulePropertyRef_line(scope,attr) ::= "state.tokenStartLine"
-lexerRulePropertyRef_pos(scope,attr) ::= "state.tokenStartCharPositionInLine"
-lexerRulePropertyRef_index(scope,attr) ::= "-1" // undefined token index in lexer
-lexerRulePropertyRef_channel(scope,attr) ::= "_channel"
-lexerRulePropertyRef_start(scope,attr) ::= "state.tokenStartCharIndex"
-lexerRulePropertyRef_stop(scope,attr) ::= "(CharIndex-1)"
-lexerRulePropertyRef_int(scope,attr) ::= "int.Parse(<scope>.Text)"
-
-// setting $st and $tree is allowed in local rule. everything else
-// is flagged as error
-ruleSetPropertyRef_tree(scope,attr,expr) ::= "retval.Tree = <expr>;"
-ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.Template =<expr>;"
-
-/** How to execute an action (only when not backtracking) */
-execAction(action) ::= <%
-<if(backtracking)>
-if (<actions.(actionScope).synpredgate>)<\n>
-{<\n>
-<@indentedAction()><\n>
-}
-<else>
-<action>
-<endif>
-%>
-
-@execAction.indentedAction() ::= <<
-	<action>
->>
-
-/** How to always execute an action even when backtracking */
-execForcedAction(action) ::= "<action>"
-
-// M I S C (properties, etc...)
-
-bitset(name, words64) ::= <<
-public static readonly BitSet <name> = new BitSet(new ulong[]{<words64:{it|<it>UL};separator=",">});
->>
-
-codeFileExtension() ::= ".cs"
-
-true_value() ::= "true"
-false_value() ::= "false"
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
deleted file mode 100644
index c250e44..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
+++ /dev/null
@@ -1,312 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-/** Template overrides to add debugging to normal Java output;
- *  If ASTs are built, then you'll also get ASTDbg.stg loaded.
- */
-
-@outputFile.imports() ::= <<
-<@super.imports()>
-using Antlr.Runtime.Debug;
-using IOException = System.IO.IOException;
->>
-
-@genericParser.members() ::= <<
-<if(grammar.grammarIsRoot)>
-public static readonly string[] ruleNames =
-	new string[]
-	{
-		"invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n	", separator=", ">
-	};<\n>
-<endif>
-<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
-int ruleLevel = 0;
-public virtual int RuleLevel { get { return ruleLevel; } }
-public virtual void IncRuleLevel() { ruleLevel++; }
-public virtual void DecRuleLevel() { ruleLevel--; }
-<if(profile)>
-<ctorForProfilingRootGrammar()>
-<else>
-<ctorForRootGrammar()>
-<endif>
-<ctorForPredefinedListener()>
-<else><! imported grammar !>
-public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
-public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
-public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
-<ctorForDelegateGrammar()>
-<endif>
-<if(profile)>
-public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
-{
-	int stopIndex = GetRuleMemoization(ruleIndex, input.Index);
-	((Profiler)dbg).ExamineRuleMemoization(input, ruleIndex, stopIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-	return base.AlreadyParsedRule(input, ruleIndex);
-}<\n>
-public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
-{
-	((Profiler)dbg).Memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-	base.Memoize(input, ruleIndex, ruleStartIndex);
-}<\n>
-<endif>
-protected virtual bool EvalPredicate( bool result, string predicate )
-{
-	dbg.SemanticPredicate( result, predicate );
-	return result;
-}<\n>
->>
-
-ctorForRootGrammar() ::= <<
-<! bug: can't use <@super.members()> cut-n-paste instead !>
-<! Same except we add port number and profile stuff if root grammar !>
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
-	: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
-{
-}
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
-	: base( input, state )
-{
-	<createListenerAndHandshake()>
-	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
-	<parserCtorBody()>
-	<@finally()>
-}<\n>
->>
-
-ctorForProfilingRootGrammar() ::= <<
-<! bug: can't use <@super.members()> cut-n-paste instead !>
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
-	: this( input, new Profiler(null), new RecognizerSharedState() )
-{
-}
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
-	: base( input, dbg, state )
-{
-	Profiler p = (Profiler)dbg;
-	p.setParser(this);
-	<grammar.directDelegates:
-	 {g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
-	<parserCtorBody()>
-	<@finally()>
-}
-<\n>
->>
-
-/** Basically we don't want to set any dbg listeners are root will have it. */
-ctorForDelegateGrammar() ::= <<
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
-	: base( input, dbg, state )
-{
-	<grammar.directDelegates:
-	 {g|<g:delegateName()> = new <g.recognizerName>( input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
-	<parserCtorBody()>
-}<\n>
->>
-
-ctorForPredefinedListener() ::= <<
-<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg )
-	<@superClassRef>: base( input, dbg, new RecognizerSharedState() )<@end>
-{
-<if(profile)>
-	Profiler p = (Profiler)dbg;
-	p.setParser(this);
-<endif>
-	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
-	<parserCtorBody()>
-	<@finally()>
-}<\n>
->>
-
-createListenerAndHandshake() ::= <<
-<if(TREE_PARSER)>
-DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, input.TreeAdaptor );<\n>
-<else>
-DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, null );<\n>
-<endif>
-DebugListener = proxy;
-try
-{
-	proxy.Handshake();
-}
-catch ( IOException ioe )
-{
-	ReportError( ioe );
-}
->>
-
-@genericParser.superClassName() ::= "Debug<@super.superClassName()>"
-
-/*
- * Much of the following rules were merged into CSharp3.stg.
- */
-
-@rule.preamble() ::= <<
-if (RuleLevel == 0)
-	DebugListener.Commence();
-IncRuleLevel();
->>
-//@rule.preamble() ::= <<
-//try
-//{
-//	dbg.EnterRule( GrammarFileName, "<ruleName>" );
-//	if ( RuleLevel == 0 )
-//	{
-//		dbg.Commence();
-//	}
-//	IncRuleLevel();
-//	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
-//>>
-
-@rule.postamble() ::= <<
-DecRuleLevel();
-if (RuleLevel == 0)
-	DebugListener.Terminate();
->>
-//@rule.postamble() ::= <<
-//dbg.Location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
-//}
-//finally
-//{
-//	dbg.ExitRule( GrammarFileName, "<ruleName>" );
-//	DecRuleLevel();
-//	if ( RuleLevel == 0 )
-//	{
-//		dbg.Terminate();
-//	}
-//}<\n>
-//>>
-
-//@insertSynpreds.start() ::= "dbg.BeginBacktrack( state.backtracking );"
-//@insertSynpreds.stop() ::= "dbg.EndBacktrack( state.backtracking, success );"
-
-// Common debug event triggers used by region overrides below
-
-//enterSubRule() ::= <<
-//try
-//{
-//	dbg.EnterSubRule( <decisionNumber> );<\n>
-//>>
-
-//exitSubRule() ::= <<
-//}
-//finally
-//{
-//	dbg.ExitSubRule( <decisionNumber> );
-//}<\n>
-//>>
-
-//enterDecision() ::= <<
-//try
-//{
-//	dbg.EnterDecision( <decisionNumber> );<\n>
-//>>
-
-//exitDecision() ::= <<
-//}
-//finally
-//{
-//	dbg.ExitDecision( <decisionNumber> );
-//}<\n>
-//>>
-
-//enterAlt(n) ::= "dbg.EnterAlt( <n> );<\n>"
-
-// Region overrides that tell various constructs to add debugging triggers
-
-//@block.predecision() ::= "<enterSubRule()><enterDecision()>"
-
-//@block.postdecision() ::= "<exitDecision()>"
-
-//@block.postbranch() ::= "<exitSubRule()>"
-
-//@ruleBlock.predecision() ::= "<enterDecision()>"
-
-//@ruleBlock.postdecision() ::= "<exitDecision()>"
-
-//@ruleBlockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
-
-//@blockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
-
-//@positiveClosureBlock.preloop() ::= "<enterSubRule()>"
-
-//@positiveClosureBlock.postloop() ::= "<exitSubRule()>"
-
-//@positiveClosureBlock.predecision() ::= "<enterDecision()>"
-
-//@positiveClosureBlock.postdecision() ::= "<exitDecision()>"
-
-//@positiveClosureBlock.earlyExitException() ::=
-//	"dbg.RecognitionException( eee<decisionNumber> );<\n>"
-
-//@closureBlock.preloop() ::= "<enterSubRule()>"
-
-//@closureBlock.postloop() ::= "<exitSubRule()>"
-
-//@closureBlock.predecision() ::= "<enterDecision()>"
-
-//@closureBlock.postdecision() ::= "<exitDecision()>"
-
-//@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"
-
-//@element.prematch() ::=
-//	"dbg.Location( <it.line>, <it.pos> );"
-
-//@matchSet.mismatchedSetException() ::=
-//	"dbg.RecognitionException( mse );"
-
-//@dfaState.noViableAltException() ::= "dbg.RecognitionException( nvae );"
-
-//@dfaStateSwitch.noViableAltException() ::= "dbg.RecognitionException( nvae );"
-
-//dfaDecision(decisionNumber,description) ::= <<
-//try
-//{
-//	isCyclicDecision = true;
-//	<super.dfaDecision(...)>
-//}
-//catch ( NoViableAltException nvae )
-//{
-//	dbg.RecognitionException( nvae );
-//	throw nvae;
-//}
-//>>
-
-//@cyclicDFA.errorMethod() ::= <<
-//public override void Error( NoViableAltException nvae )
-//{
-//	((DebugParser)recognizer).dbg.RecognitionException( nvae );
-//}
-//>>
-
-/** Force predicate validation to trigger an event */
-evalPredicate(pred,description) ::= <<
-EvalPredicate(<pred>, "<description>")
->>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
deleted file mode 100644
index fd1322f..0000000
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ST.stg
+++ /dev/null
@@ -1,153 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-/** Template subgroup to add template rewrite output
- *  If debugging, then you'll also get STDbg.stg loaded.
- */
-
-@outputFile.imports() ::= <<
-<@super.imports()>
-using Antlr3.ST;
-using Antlr3.ST.Language;
->>
-
-@genericParser.members() ::= <<
-<@super.members()>
-private StringTemplateGroup _templateGroup = new StringTemplateGroup("<name>Templates", typeof(AngleBracketTemplateLexer) );
-
-public StringTemplateGroup TemplateGroup
-{
-	get { return _templateGroup; }
-	set { _templateGroup = value; }
-}
->>
-
-ruleReturnBaseType() ::= <%
-Template<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<StringTemplate, <labelType>>
-%>
-
-/** x+=rule when output=template */
-ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRef(...)>
-<listLabelElem(elem={<label>.Template},elemType="StringTemplate",...)>
->>
-
-rewriteTemplate(alts) ::= <<
-
-// TEMPLATE REWRITE
-<if(backtracking)>
-if (<actions.(actionScope).synpredgate>)
-{
-	<alts:rewriteTemplateAlt(); separator="else ">
-	<if(rewriteMode)><replaceTextInLine()><endif>
-}
-<else>
-<alts:rewriteTemplateAlt(); separator="else ">
-<if(rewriteMode)><replaceTextInLine()><endif>
-<endif>
->>
-
-replaceTextInLine() ::= <<
-<if(TREE_PARSER)>
-((TokenRewriteStream)input.TokenStream).Replace(
-	input.TreeAdaptor.GetTokenStartIndex(retval.Start),
-	input.TreeAdaptor.GetTokenStopIndex(retval.Start),
-	retval.Template);
-<else>
-((TokenRewriteStream)input).Replace(
-	retval.Start.TokenIndex,
-	input.LT(-1).TokenIndex,
-	retval.Template);
-<endif>
->>
-
-rewriteTemplateAlt(it) ::= <<
-// <it.description>
-<if(it.pred)>
-if (<it.pred>)
-{
-	retval.Template = <it.alt>;
-}<\n>
-<else>
-{
-	retval.Template = <it.alt>;
-}<\n>
-<endif>
->>
-
-rewriteEmptyTemplate(alts) ::= <<
-null;
->>
-
-/** Invoke a template with a set of attribute name/value pairs.
- *  Set the value of the rule's template *after* having set
- *  the attributes because the rule's template might be used as
- *  an attribute to build a bigger template; you get a self-embedded
- *  template.
- */
-rewriteExternalTemplate(name,args) ::= <%
-TemplateGroup.GetInstanceOf("<name>"<optionalArguments(args)>)
-%>
-
-/** expr is a string expression that says what template to load */
-rewriteIndirectTemplate(expr,args) ::= <%
-TemplateGroup.GetInstanceOf(<expr><optionalArguments(args)>)
-%>
-
-/** Invoke an inline template with a set of attribute name/value pairs */
-rewriteInlineTemplate(args, template) ::= <%
-new StringTemplate(TemplateGroup, "<template>"<optionalArguments(args)>)
-%>
-
-optionalArguments(args) ::= <<
-<if(args)>,
-	new Dictionary\<string, object>() { <args:optionalArgument(); separator=", "> }
-<endif>
->>
-
-optionalArgument(it) ::= <<
-{"<it.name>", <it.value>}
->>
-
-/** plain -> {foo} action */
-rewriteAction(action) ::= <<
-<action>
->>
-
-/** An action has %st.attrName=expr; or %{st}.attrName=expr; */
-actionSetAttribute(st,attrName,expr) ::= <<
-(<st>).SetAttribute("<attrName>",<expr>);
->>
-
-/** Translate %{stringExpr} */
-actionStringConstructor(stringExpr) ::= <<
-new StringTemplate(TemplateGroup,<stringExpr>)
->>
diff --git a/bin/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg b/bin/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg
deleted file mode 100644
index e39b1b6..0000000
--- a/bin/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-/** How to generate rules derived from left-recursive rules.
- *  These rely on recRuleDefArg(), recRuleAltPredicate(),
- *  recRuleArg(), recRuleSetResultAction(), recRuleSetReturnAction()
- *  templates in main language.stg
- */
-group LeftRecursiveRules;
-
-recRuleName(ruleName) ::= "<ruleName>_"
-recPrimaryName(ruleName) ::= "<ruleName>_primary"
-
-recRuleStart(ruleName, minPrec, userRetvals, userRetvalAssignments) ::= <<
-<ruleName><if(userRetvals)> returns [<userRetvals>]<endif>
-  : <recRuleName(...)>[<minPrec>]
-    <if(userRetvals)>
-    {
-        <userRetvalAssignments; separator="\n">
-    }
-    <endif>
-  ;
->>
-
-recRule(ruleName, precArgDef, argName, alts, setResultAction, buildAST,
-        userRetvals, userRetvalAssignments) ::= <<
-<recRuleName(...)>[<precArgDef>]<if(userRetvals)> returns [<userRetvals>]<endif>
-    :   <recPrimaryName(...)>
-        <if(buildAST)>
-        {
-            <setResultAction>
-        }
-        <endif>
-        <if(userRetvals)>
-        {
-            <userRetvalAssignments; separator="\n">
-        }
-        <endif>
-        ( options {backtrack=false;}
-        : ( options {backtrack=false;}
-          : <alts; separator="\n          | ">
-          )
-        )*
-    ;
->>
-
-recPrimaryRule(ruleName, alts, userRetvals) ::= <<
-<recPrimaryName(...)><if(userRetvals)> returns [<userRetvals>]<endif>
-options {backtrack=true;}
-    : <alts; separator="\n    | ">
-    ;
->>
-
-recRuleAlt(alt, pred) ::= "{<pred>}?=> <alt>"
-
-recRuleRef(ruleName, arg) ::= "<recRuleName(...)>[<arg>]"
-
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll
deleted file mode 100644
index 625f969..0000000
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll and /dev/null differ
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
deleted file mode 100644
index 35279af..0000000
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and /dev/null differ
diff --git a/bin/Bootstrap/Tool/Templates/depend.stg b/bin/Bootstrap/Tool/Templates/depend.stg
deleted file mode 100644
index c093054..0000000
--- a/bin/Bootstrap/Tool/Templates/depend.stg
+++ /dev/null
@@ -1,12 +0,0 @@
-/** templates used to generate make-compatible dependencies */
-group depend;
-
-/** Generate "f : x, y, z" dependencies for input
- *  dependencies and generated files. in and out
- *  are File objects.  For example, you can say
- *  <f.canonicalPath>
- */
-dependencies(grammarFileName,in,out) ::= <<
-<if(in)><grammarFileName>: <in; separator=", "><endif>
-<out:{f | <f> : <grammarFileName>}; separator="\n">
->>
diff --git a/bin/Bootstrap/Tool/Templates/dot/dot.stg b/bin/Bootstrap/Tool/Templates/dot/dot.stg
deleted file mode 100644
index efcac2c..0000000
--- a/bin/Bootstrap/Tool/Templates/dot/dot.stg
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * [The "BSD license"]
- * Copyright (c) 2011 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC.
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-dfa(decisionRanks,states,edges,rankdir,startState,useBox) ::= <<
-digraph NFA {
-<if(rankdir)>rankdir=<rankdir>;<endif>
-<decisionRanks; separator="\n">
-<states; separator="\n">
-<edges; separator="\n">
-}
->>
-
-nfa(decisionRanks,states,edges,rankdir,startState) ::= <<
-digraph NFA {
-rankdir=LR;
-<decisionRanks; separator="\n">
-<states; separator="\n">
-<edges; separator="\n">
-}
->>
-
-decision-rank(states) ::= <<
-{rank=same; rankdir=TB; <states; separator="; ">}
->>
-
-edge(src,target,label,arrowhead) ::= <<
-<src> -> <target> [fontsize=11, fontname="Courier", arrowsize=.7, label = "<label>"<if(arrowhead)>, arrowhead = <arrowhead><endif>];
->>
-
-action-edge(src,target,label,arrowhead) ::= <<
-<src> -> <target> [fontsize=11, fontname="Courier", arrowsize=.7, label = "<label>"<if(arrowhead)>, arrowhead = <arrowhead><endif>];
->>
-
-epsilon-edge(src,target,label,arrowhead) ::= <<
-<src> -> <target> [fontname="Times-Italic", label = "e"];
->>
-
-state(name,useBox) ::= <<
-node [fontsize=11, shape = <if(useBox)>box<else>circle, fixedsize=true, width=.4<endif>]; <name>
->>
-
-stopstate(name,useBox) ::= <<
-node [fontsize=11, shape = <if(useBox)>polygon,sides=4,peripheries=2<else>doublecircle, fixedsize=true, width=.6<endif>]; <name>
->>
diff --git a/bin/Bootstrap/Tool/Templates/messages/formats/antlr.stg b/bin/Bootstrap/Tool/Templates/messages/formats/antlr.stg
deleted file mode 100644
index 9fb4612..0000000
--- a/bin/Bootstrap/Tool/Templates/messages/formats/antlr.stg
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- [The "BSD license"]
- Copyright (c) 2006 Kay Roepke
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-/*
- New style messages. This file contains the actual layout of the messages emitted by ANTLR.
- The text itself is coming out of the languages/*stg files, according to the chosen locale.
- This file contains the default format ANTLR uses.
-*/
-
-group antlr;
-
-location(file, line, column) ::= "<file>:<line>:<column>:"
-
-message(id, text) ::= "(<id>) <text>"
-
-report(location, message, type) ::= "<type>(<message.id>): <location> <message.text>"
-
-wantsSingleLineMessage() ::= "false"
\ No newline at end of file
diff --git a/bin/Bootstrap/Tool/Templates/messages/formats/vs2005.stg b/bin/Bootstrap/Tool/Templates/messages/formats/vs2005.stg
deleted file mode 100644
index 0c94e48..0000000
--- a/bin/Bootstrap/Tool/Templates/messages/formats/vs2005.stg
+++ /dev/null
@@ -1,42 +0,0 @@
-/*
- [The "BSD license"]
- Copyright (c) 2006 Kay Roepke
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-/*
- New style messages. This file contains the actual layout of the messages emitted by ANTLR.
- The text itself is coming out of the languages/*stg files, according to the chosen locale.
- This file contains the default format ANTLR uses.
-*/
-
-group antlr;
-
-location(file, line, column) ::= "<file>(<line>,<column>)"
-
-message(id, text) ::= "error <id> : <text>"
-
-report(location, message, type) ::= "<location> : <type> <message.id> : <message.text>"
-
-wantsSingleLineMessage() ::= "true"
diff --git a/bin/Bootstrap/Tool/Templates/messages/languages/en.stg b/bin/Bootstrap/Tool/Templates/messages/languages/en.stg
deleted file mode 100644
index b5e42d5..0000000
--- a/bin/Bootstrap/Tool/Templates/messages/languages/en.stg
+++ /dev/null
@@ -1,300 +0,0 @@
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-/*
- New style messages. This file only contains the messages in English, but no
- information about which file, line, or column it occurred in.
- The location and message ids are taken out of the formats directory.
-														Kay Roepke
-*/
-group en_US;
-
-// TOOL ERRORS
-// file errors
-CANNOT_WRITE_FILE(arg,exception,stackTrace) ::= <<
-cannot write file <arg>: <exception>
-<stackTrace; separator="\n">
->>
-CANNOT_CLOSE_FILE(arg,exception,stackTrace) ::= "cannot close file <arg>: <exception>"
-CANNOT_FIND_TOKENS_FILE(arg) ::= "cannot find tokens file <arg>"
-ERROR_READING_TOKENS_FILE(arg,exception,stackTrace) ::= <<
-problem reading token vocabulary file <arg>: <exception>
-<stackTrace; separator="\n">
->>
-DIR_NOT_FOUND(arg,exception,stackTrace) ::= "directory not found: <arg>"
-OUTPUT_DIR_IS_FILE(arg,exception,stackTrace) ::= "output directory is a file: <arg>"
-CANNOT_OPEN_FILE(arg,exception,stackTrace) ::= "cannot find or open file: <arg><if(exception)>; reason: <exception><endif>"
-CIRCULAR_DEPENDENCY() ::= "your grammars contain a circular dependency and cannot be sorted into a valid build order."
-
-INTERNAL_ERROR(arg,arg2,exception,stackTrace) ::= <<
-internal error: <arg> <arg2><if(exception)>: <exception><endif>
-<stackTrace; separator="\n">
->>
-INTERNAL_WARNING(arg) ::= "internal warning: <arg>"
-ERROR_CREATING_ARTIFICIAL_RULE(arg,exception,stackTrace) ::= <<
-problems creating lexer rule listing all tokens: <exception>
-<stackTrace; separator="\n">
->>
-TOKENS_FILE_SYNTAX_ERROR(arg,arg2) ::=
-	"problems parsing token vocabulary file <arg> on line <arg2>"
-CANNOT_GEN_DOT_FILE(arg,exception,stackTrace) ::=
-	"cannot write DFA DOT file <arg>: <exception>"
-BAD_ACTION_AST_STRUCTURE(exception,stackTrace) ::=
-	"bad internal tree structure for action '<arg>': <exception>"
-BAD_AST_STRUCTURE(arg,exception,stackTrace) ::= <<
-bad internal tree structure '<arg>': <exception>
-<stackTrace; separator="\n">
->>
-FILE_AND_GRAMMAR_NAME_DIFFER(arg,arg2) ::=
-  "file <arg2> contains grammar <arg>; names must be identical"
-FILENAME_EXTENSION_ERROR(arg) ::=
-  "file <arg> must end in a file extension, normally .g"
-
-// code gen errors
-MISSING_CODE_GEN_TEMPLATES(arg) ::=
-	"cannot find code generation templates <arg>.stg"
-MISSING_CYCLIC_DFA_CODE_GEN_TEMPLATES() ::=
-	"cannot find code generation cyclic DFA templates for language <arg>"
-CODE_GEN_TEMPLATES_INCOMPLETE(arg) ::=
-	"at least one code generation template missing for language <arg>"
-CANNOT_CREATE_TARGET_GENERATOR(arg,exception,stackTrace) ::=
-	"cannot create target <arg> code generator: <exception>"
-STRING_TEMPLATE_ERROR(arg,exception,stackTrace) ::=
-	"template error: <arg>"
-CANNOT_COMPUTE_SAMPLE_INPUT_SEQ() ::=
-	"cannot generate a sample input sequence from lookahead DFA"
-
-// grammar interpretation errors
-/*
-NO_VIABLE_DFA_ALT(arg,arg2) ::=
-	"no viable transition from state <arg> on <arg2> while interpreting DFA"
-*/
-
-// GRAMMAR ERRORS
-SYNTAX_ERROR(arg) ::= "syntax error: <arg>"
-RULE_REDEFINITION(arg) ::=
-	"rule <arg> redefinition"
-LEXER_RULES_NOT_ALLOWED(arg) ::=
-	"lexer rule <arg> not allowed in parser"
-PARSER_RULES_NOT_ALLOWED(arg) ::=
-	"parser rule <arg> not allowed in lexer"
-CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL(arg) ::=
-	"cannot find an attribute name in attribute declaration"
-NO_TOKEN_DEFINITION(arg) ::=
-	"no lexer rule corresponding to token: <arg>"
-UNDEFINED_RULE_REF(arg) ::=
-	"reference to undefined rule: <arg>"
-LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE(arg) ::=
-	"literal has no associated lexer rule: <arg>"
-CANNOT_ALIAS_TOKENS_IN_LEXER(arg) ::=
-	"literals are illegal in lexer tokens{} section: <arg>"
-ATTRIBUTE_REF_NOT_IN_RULE(arg,arg2) ::=
-	"reference to attribute outside of a rule: <arg><if(arg2)>.<arg2><endif>"
-UNKNOWN_ATTRIBUTE_IN_SCOPE(arg,arg2) ::=
-	"unknown attribute for <arg>: <arg2>"
-UNKNOWN_RULE_ATTRIBUTE(arg,arg2) ::=
-	"unknown attribute for rule <arg>: <arg2>"
-UNKNOWN_SIMPLE_ATTRIBUTE(arg,args2) ::=
-	"attribute is not a token, parameter, or return value: <arg>"
-ISOLATED_RULE_SCOPE(arg) ::=
-	"missing attribute access on rule scope: <arg>"
-INVALID_RULE_PARAMETER_REF(arg,arg2) ::=
-	"cannot access rule <arg>'s parameter: <arg2>"
-INVALID_RULE_SCOPE_ATTRIBUTE_REF(arg,arg2) ::=
-	"cannot access rule <arg>'s dynamically-scoped attribute: <arg2>"
-SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE(arg) ::=
-	"symbol <arg> conflicts with global dynamic scope with same name"
-WRITE_TO_READONLY_ATTR(arg,arg2,arg3) ::=
-	"cannot write to read only attribute: $<arg><if(arg2)>.<arg2><endif>"
-LABEL_CONFLICTS_WITH_RULE(arg) ::=
-	"label <arg> conflicts with rule with same name"
-LABEL_CONFLICTS_WITH_TOKEN(arg) ::=
-	"label <arg> conflicts with token with same name"
-LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE(arg,arg2) ::=
-	"label <arg> conflicts with rule <arg2>'s dynamically-scoped attribute with same name"
-LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL(arg,arg2) ::=
-	"label <arg> conflicts with rule <arg2>'s return value or parameter with same name"
-ATTRIBUTE_CONFLICTS_WITH_RULE(arg,arg2) ::=
-	"rule <arg2>'s dynamically-scoped attribute <arg> conflicts with the rule name"
-ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL(arg,arg2) ::=
-	"rule <arg2>'s dynamically-scoped attribute <arg> conflicts with<arg2>'s return value or parameter with same name"
-LABEL_TYPE_CONFLICT(arg,arg2) ::=
-	"label <arg> type mismatch with previous definition: <arg2>"
-ARG_RETVAL_CONFLICT(arg,arg2) ::=
-	"rule <arg2>'s argument <arg> conflicts a return value with same name"
-NONUNIQUE_REF(arg) ::=
-	"<arg> is a non-unique reference"
-FORWARD_ELEMENT_REF(arg) ::=
-	"illegal forward reference: <arg>"
-MISSING_RULE_ARGS(arg) ::=
-	"missing parameter(s) on rule reference: <arg>"
-RULE_HAS_NO_ARGS(arg) ::=
-	"rule <arg> has no defined parameters"
-ARGS_ON_TOKEN_REF(arg) ::=
-	"token reference <arg> may not have parameters"
-ILLEGAL_OPTION(arg) ::=
-	"illegal option <arg>"
-LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT(arg) ::=
-	"rule '+=' list labels are not allowed w/o output option: <arg>"
-UNDEFINED_TOKEN_REF_IN_REWRITE(arg) ::=
-  "reference to undefined token in rewrite rule: <arg>"
-REWRITE_ELEMENT_NOT_PRESENT_ON_LHS(arg) ::=
-  "reference to rewrite element <arg> without reference on left of ->"
-UNDEFINED_LABEL_REF_IN_REWRITE(arg) ::=
-  "reference to undefined label in rewrite rule: $<arg>"
-NO_GRAMMAR_START_RULE (arg) ::=
-  "grammar <arg>: no start rule (no rule can obviously be followed by EOF)"
-EMPTY_COMPLEMENT(arg) ::= <<
-<if(arg)>
-set complement ~<arg> is empty
-<else>
-set complement is empty
-<endif>
->>
-UNKNOWN_DYNAMIC_SCOPE(arg) ::=
-  "unknown dynamic scope: <arg>"
-UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE(arg,arg2) ::=
-  "unknown dynamically-scoped attribute for scope <arg>: <arg2>"
-RULE_REF_AMBIG_WITH_RULE_IN_ALT(arg) ::=
-  "reference $<arg> is ambiguous; rule <arg> is enclosing rule and referenced in the production (assuming enclosing rule)"
-ISOLATED_RULE_ATTRIBUTE(arg) ::=
-  "reference to locally-defined rule scope attribute without rule name: <arg>"
-INVALID_ACTION_SCOPE(arg,arg2) ::=
-  "unknown or invalid action scope for <arg2> grammar: <arg>"
-ACTION_REDEFINITION(arg) ::=
-  "redefinition of <arg> action"
-DOUBLE_QUOTES_ILLEGAL(arg) ::=
-  "string literals must use single quotes (such as \'begin\'): <arg>"
-INVALID_TEMPLATE_ACTION(arg) ::=
-  "invalid StringTemplate % shorthand syntax: '<arg>'"
-MISSING_ATTRIBUTE_NAME() ::=
-  "missing attribute name on $ reference"
-ARG_INIT_VALUES_ILLEGAL(arg) ::=
-  "rule parameters may not have init values: <arg>"
-REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION(arg) ::=
-  "<if(arg)>rule <arg> uses <endif>rewrite syntax or operator with no output option; setting output=AST"
-AST_OP_WITH_NON_AST_OUTPUT_OPTION(arg) ::=
-  "AST operator with non-AST output option: <arg>"
-NO_RULES(arg) ::= "grammar file <arg> has no rules"
-MISSING_AST_TYPE_IN_TREE_GRAMMAR(arg) ::=
-  "tree grammar <arg> has no ASTLabelType option"
-REWRITE_FOR_MULTI_ELEMENT_ALT(arg) ::=
-  "with rewrite=true, alt <arg> not simple node or obvious tree element; text attribute for rule not guaranteed to be correct"
-RULE_INVALID_SET(arg) ::=
-  "Cannot complement rule <arg>; not a simple set or element"
-HETERO_ILLEGAL_IN_REWRITE_ALT(arg) ::=
-  "alts with rewrites can't use heterogeneous types left of ->"
-NO_SUCH_GRAMMAR_SCOPE(arg,arg2) ::=
-  "reference to undefined grammar in rule reference: <arg>.<arg2>"
-NO_SUCH_RULE_IN_SCOPE(arg,arg2) ::=
-  "rule <arg2> is not defined in grammar <arg>"
-TOKEN_ALIAS_CONFLICT(arg,arg2) ::=
-  "cannot alias <arg>; string already assigned to <arg2>"
-TOKEN_ALIAS_REASSIGNMENT(arg,arg2) ::=
-  "cannot alias <arg>; token name already assigned to <arg2>"
-TOKEN_VOCAB_IN_DELEGATE(arg,arg2) ::=
-  "tokenVocab option ignored in imported grammar <arg>"
-INVALID_IMPORT(arg,arg2) ::=
-  "<arg.grammarTypeString> grammar <arg.name> cannot import <arg2.grammarTypeString> grammar <arg2.name>"
-IMPORTED_TOKENS_RULE_EMPTY(arg,arg2) ::=
-  "no lexer rules contributed to <arg> from imported grammar <arg2>"
-IMPORT_NAME_CLASH(arg,arg2) ::=
-  "combined grammar <arg.name> and imported <arg2.grammarTypeString> grammar <arg2.name> both generate <arg2.recognizerName>; import ignored"
-AST_OP_IN_ALT_WITH_REWRITE(arg,arg2) ::=
-  "rule <arg> alt <arg2> uses rewrite syntax and also an AST operator"
-WILDCARD_AS_ROOT(arg) ::= "Wildcard invalid as root; wildcard can itself be a tree"
-CONFLICTING_OPTION_IN_TREE_FILTER(arg,arg2) ::= "option <arg>=<arg2> conflicts with tree grammar filter mode"
-ILLEGAL_OPTION_VALUE(arg, arg2) ::= "value '<arg2>' invalid for option <arg>"
-ALL_OPS_NEED_SAME_ASSOC(arg) ::= "all operators of alt <alt> of left-recursive rule must have same associativity"
-RANGE_OP_ILLEGAL(arg) ::= "the .. range operator isn't allowed in parser rules"
-
-// GRAMMAR WARNINGS
-
-GRAMMAR_NONDETERMINISM(input,conflictingAlts,paths,disabled,hasPredicateBlockedByAction) ::=
-<<
-<if(paths)>
-Decision can match input such as "<input>" using multiple alternatives:
-<paths:{ it |  alt <it.alt> via NFA path <it.states; separator=","><\n>}>
-<else>
-Decision can match input such as "<input>" using multiple alternatives: <conflictingAlts; separator=", ">
-<endif>
-<if(disabled)><\n>As a result, alternative(s) <disabled; separator=","> were disabled for that input<endif><if(hasPredicateBlockedByAction)><\n>Semantic predicates were present but were hidden by actions.<endif>
->>
-
-DANGLING_STATE(danglingAlts,input) ::= <<
-the decision cannot distinguish between alternative(s) <danglingAlts; separator=","> for input such as "<input>"
->>
-
-UNREACHABLE_ALTS(alts) ::= <<
-The following alternatives can never be matched: <alts; separator=","><\n>
->>
-
-INSUFFICIENT_PREDICATES(upon,altToLocations,hasPredicateBlockedByAction) ::= <<
-Input such as "<upon>" is insufficiently covered with predicates at locations: <altToLocations.keys:{alt|alt <alt>: <altToLocations.(alt):{loc| line <loc.line>:<loc.column> at <loc.text>}; separator=", ">}; separator=", "><if(hasPredicateBlockedByAction)><\n>Semantic predicates were present but were hidden by actions.<endif>
->>
-
-DUPLICATE_SET_ENTRY(arg) ::=
-	"duplicate token type <arg> when collapsing subrule into set"
-
-ANALYSIS_ABORTED(enclosingRule) ::= <<
-ANTLR could not analyze this decision in rule <enclosingRule>; often this is because of recursive rule references visible from the left edge of alternatives.  ANTLR will re-analyze the decision with a fixed lookahead of k=1.  Consider using "options {k=1;}" for that decision and possibly adding a syntactic predicate.
->>
-
-RECURSION_OVERLOW(alt,input,targetRules,callSiteStates) ::= <<
-Alternative <alt>: after matching input such as <input> decision cannot predict what comes next due to recursion overflow <targetRules,callSiteStates:{t,c|to <t> from <c:{s|<s.enclosingRule.name>};separator=", ">}; separator=" and ">
->>
-
-LEFT_RECURSION(targetRules,alt,callSiteStates) ::= <<
-Alternative <alt> discovers infinite left-recursion <targetRules,callSiteStates:{t,c|to <t> from <c:{s|<s.enclosingRule>};separator=", ">}; separator=" and ">
->>
-
-UNREACHABLE_TOKENS(tokens) ::= <<
-The following token definitions can never be matched because prior tokens match the same input: <tokens; separator=",">
->>
-
-TOKEN_NONDETERMINISM(input,conflictingTokens,paths,disabled,hasPredicateBlockedByAction) ::=
-<<
-<if(paths)>
-Decision can match input such as "<input>" using multiple alternatives:
-<paths:{ it | alt <it.alt> via NFA path <it.states; separator=","><\n>}>
-<else>
-Multiple token rules can match input such as "<input>": <conflictingTokens; separator=", "><\n>
-<endif>
-<if(disabled)><\n>As a result, token(s) <disabled; separator=","> were disabled for that input<endif><if(hasPredicateBlockedByAction)><\n>Semantic predicates were present but were hidden by actions.<endif>
->>
-
-LEFT_RECURSION_CYCLES(listOfCycles) ::= <<
-The following sets of rules are mutually left-recursive <listOfCycles:{c| [<c:{r|<r.name>}; separator=", ">]}; separator=" and ">
->>
-
-NONREGULAR_DECISION(ruleName,alts) ::= <<
-[fatal] rule <ruleName> has non-LL(*) decision due to recursive rule invocations reachable from alts <alts; separator=",">.  Resolve by left-factoring or using syntactic predicates or using backtrack=true option.
->>
-
-/* l10n for message levels */
-warning() ::= "warning"
-error() ::= "error"
diff --git a/bin/prep/7z.dll b/bin/prep/7z.dll
deleted file mode 100644
index 8e8be61..0000000
Binary files a/bin/prep/7z.dll and /dev/null differ
diff --git a/bin/prep/7z.exe b/bin/prep/7z.exe
deleted file mode 100755
index aec56e4..0000000
Binary files a/bin/prep/7z.exe and /dev/null differ
diff --git a/bin/prep/Antlr3.Runtime.Debug.nuspec b/bin/prep/Antlr3.Runtime.Debug.nuspec
deleted file mode 100644
index 48ada48..0000000
--- a/bin/prep/Antlr3.Runtime.Debug.nuspec
+++ /dev/null
@@ -1,34 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
-  <metadata>
-    <id>Antlr3.Runtime.Debug</id>
-    <version>0.0.0</version>
-    <authors>Sam Harwell, Terence Parr</authors>
-    <owners>Sam Harwell</owners>
-    <description>The runtime library for parsers generated by the C# target of ANTLR 3. This package supports projects targeting .NET 2.0 or newer, and built using Visual Studio 2008 or newer.</description>
-    <language>en-us</language>
-    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
-    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
-    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
-    <copyright>Copyright Â© Sam Harwell 2013</copyright>
-    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$version$</releaseNotes>
-    <requireLicenseAcceptance>true</requireLicenseAcceptance>
-    <tags>antlr antlr3 parsing</tags>
-    <title>ANTLR 3 Runtime</title>
-    <summary>The runtime library for parsers generated by the C# target of ANTLR 3.</summary>
-    <dependencies>
-      <dependency id="Antlr3.Runtime" version="$version$" />
-    </dependencies>
-  </metadata>
-  <files>
-    <!-- Runtime Libraries -->
-
-    <file src="Tool\Antlr3.Runtime.Debug.dll" target="lib\net20"/>
-    <file src="Tool\Antlr3.Runtime.Debug.pdb" target="lib\net20"/>
-    <file src="Tool\Antlr3.Runtime.Debug.xml" target="lib\net20"/>
-
-    <!-- Source Code -->
-
-    <file exclude="..\..\Runtime\Antlr3.Runtime.Debug\obj\**\*.cs" src="..\..\Runtime\Antlr3.Runtime.Debug\**\*.cs" target="src"/>
-  </files>
-</package>
diff --git a/bin/prep/Antlr3.Runtime.nuspec b/bin/prep/Antlr3.Runtime.nuspec
deleted file mode 100644
index 4ebbba2..0000000
--- a/bin/prep/Antlr3.Runtime.nuspec
+++ /dev/null
@@ -1,31 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
-  <metadata>
-    <id>Antlr3.Runtime</id>
-    <version>0.0.0</version>
-    <authors>Sam Harwell, Terence Parr</authors>
-    <owners>Sam Harwell</owners>
-    <description>The runtime library for parsers generated by the C# target of ANTLR 3. This package supports projects targeting .NET 2.0 or newer, and built using Visual Studio 2008 or newer.</description>
-    <language>en-us</language>
-    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
-    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
-    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
-    <copyright>Copyright Â© Sam Harwell 2013</copyright>
-    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$version$</releaseNotes>
-    <requireLicenseAcceptance>true</requireLicenseAcceptance>
-    <tags>antlr antlr3 parsing</tags>
-    <title>ANTLR 3 Runtime</title>
-    <summary>The runtime library for parsers generated by the C# target of ANTLR 3.</summary>
-  </metadata>
-  <files>
-    <!-- Runtime Libraries -->
-
-    <file src="Runtime\Antlr3.Runtime.dll" target="lib\net20"/>
-    <file src="Runtime\Antlr3.Runtime.pdb" target="lib\net20"/>
-    <file src="Runtime\Antlr3.Runtime.xml" target="lib\net20"/>
-
-    <!-- Source Code -->
-
-    <file exclude="..\..\Runtime\Antlr3.Runtime\obj\**\*.cs" src="..\..\Runtime\Antlr3.Runtime\**\*.cs" target="src"/>
-  </files>
-</package>
diff --git a/bin/prep/Antlr3.nuspec b/bin/prep/Antlr3.nuspec
deleted file mode 100644
index 195d813..0000000
--- a/bin/prep/Antlr3.nuspec
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
-  <metadata minClientVersion="2.5">
-    <id>Antlr3</id>
-    <version>0.0.0</version>
-    <authors>Sam Harwell, Terence Parr</authors>
-    <owners>Sam Harwell</owners>
-    <description>The C# target of the ANTLR 3 parser generator. This package supports projects targeting .NET 2.0 or newer, and built using Visual Studio 2008 or newer.</description>
-    <language>en-us</language>
-    <projectUrl>https://github.com/sharwell/antlr4cs</projectUrl>
-    <licenseUrl>https://raw.github.com/sharwell/antlr4cs/master/LICENSE.txt</licenseUrl>
-    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
-    <copyright>Copyright Â© Sam Harwell 2013</copyright>
-    <releaseNotes>https://github.com/sharwell/antlr4cs/releases/v$version$</releaseNotes>
-    <requireLicenseAcceptance>true</requireLicenseAcceptance>
-    <tags>antlr antlr3 parsing</tags>
-    <title>ANTLR 3</title>
-    <summary>The C# target of the ANTLR 3 parser generator.</summary>
-    <dependencies>
-      <dependency id="Antlr3.Runtime" version="$version$" />
-      <dependency id="Antlr3.Runtime.Debug" version="$version$" />
-      <dependency id="StringTemplate3" version="$version$" />
-    </dependencies>
-  </metadata>
-  <files>
-    <!-- Tools -->
-
-    <file src="Bootstrap\**\*.*" target="tools"/>
-
-    <!-- Build Configuration -->
-
-    <file src="Tool\Antlr3.props" target="build"/>
-    <file src="Tool\Antlr3.targets" target="build"/>
-    <file src="Tool\AntlrBuildTask.dll" target="build"/>
-  </files>
-</package>
diff --git a/bin/prep/LICENSE.txt b/bin/prep/LICENSE.txt
deleted file mode 100644
index f63a069..0000000
--- a/bin/prep/LICENSE.txt
+++ /dev/null
@@ -1,27 +0,0 @@
-[The "BSD license"]
-Copyright (c) 2011 Terence Parr
-C# Port (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/bin/prep/NuGet.exe b/bin/prep/NuGet.exe
deleted file mode 100644
index be85ec2..0000000
Binary files a/bin/prep/NuGet.exe and /dev/null differ
diff --git a/bin/prep/StringTemplate3.nuspec b/bin/prep/StringTemplate3.nuspec
deleted file mode 100644
index 488c5e3..0000000
--- a/bin/prep/StringTemplate3.nuspec
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
-  <metadata>
-    <id>StringTemplate3</id>
-    <version>0.0.0</version>
-    <authors>Sam Harwell, Terence Parr</authors>
-    <owners>Sam Harwell</owners>
-    <description>The C# port of StringTemplate 3.</description>
-    <language>en-us</language>
-    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
-    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
-    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
-    <copyright>Copyright Â© Sam Harwell 2013</copyright>
-    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$ANTLRVersion$</releaseNotes>
-    <requireLicenseAcceptance>true</requireLicenseAcceptance>
-    <tags>stringtemplate st3 stringtemplate3 template</tags>
-    <title>StringTemplate 3</title>
-    <summary>The C# port of StringTemplate 3.</summary>
-    <dependencies>
-      <dependency id="Antlr3.Runtime" version="$ANTLRVersion$" />
-    </dependencies>
-  </metadata>
-  <files>
-    <!-- Runtime Libraries -->
-
-    <file src="ST3\Antlr3.StringTemplate.dll" target="lib\net35-client"/>
-    <file src="ST3\Antlr3.StringTemplate.pdb" target="lib\net35-client"/>
-    <file src="ST3\Antlr3.StringTemplate.xml" target="lib\net35-client"/>
-
-    <!-- Source Code -->
-
-    <file exclude="..\..\Antlr3.StringTemplate\obj\**\*.cs" src="..\..\Antlr3.StringTemplate\**\*.cs" target="src"/>
-    <file src="..\..\Antlr3.StringTemplate\obj\$Configuration$\**\*.cs" target="src\obj\$Configuration$"/>
-    <file src="..\..\Antlr3.StringTemplate\obj\$Configuration$\**\*.tokens" target="src\obj\$Configuration$"/>
-  </files>
-</package>
diff --git a/bin/prep/StringTemplate4.Visualizer.nuspec b/bin/prep/StringTemplate4.Visualizer.nuspec
deleted file mode 100644
index 68984d6..0000000
--- a/bin/prep/StringTemplate4.Visualizer.nuspec
+++ /dev/null
@@ -1,38 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
-  <metadata>
-    <id>StringTemplate4.Visualizer</id>
-    <version>0.0.0</version>
-    <authors>Sam Harwell, Terence Parr</authors>
-    <owners>Sam Harwell</owners>
-    <description>Provides the visualizer runtime for StringTemplate 4.</description>
-    <language>en-us</language>
-    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
-    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
-    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
-    <copyright>Copyright Â© Sam Harwell 2013</copyright>
-    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$ANTLRVersion$</releaseNotes>
-    <requireLicenseAcceptance>true</requireLicenseAcceptance>
-    <tags>stringtemplate st4 stringtemplate4 stviz template</tags>
-    <title>StringTemplate 4 Visualizer</title>
-    <summary>Provides the visualizer runtime for StringTemplate 4.</summary>
-    <dependencies>
-      <dependency id="Antlr3.Runtime" version="$ANTLRVersion$" />
-      <dependency id="StringTemplate4" version="$version$" />
-    </dependencies>
-  </metadata>
-  <files>
-    <!-- Runtime Libraries -->
-
-    <file src="ST4\Antlr4.StringTemplate.Visualizer.dll" target="lib\net35-client"/>
-    <file src="ST4\Antlr4.StringTemplate.Visualizer.pdb" target="lib\net35-client"/>
-    <file src="ST4\Antlr4.StringTemplate.Visualizer.xml" target="lib\net35-client"/>
-
-    <!-- Source Code -->
-
-    <file exclude="..\..\Antlr4.StringTemplate.Visualizer\obj\**\*.cs" src="..\..\Antlr4.StringTemplate.Visualizer\**\*.cs" target="src"/>
-    <file src="..\..\Antlr4.StringTemplate.Visualizer\**\*.xaml" target="src"/>
-    <file src="..\..\Antlr4.StringTemplate.Visualizer\obj\$Configuration$\**\*.cs" target="src\obj\$Configuration$"/>
-    <file src="..\..\Antlr4.StringTemplate.Visualizer\obj\$Configuration$\**\*.tokens" target="src\obj\$Configuration$"/>
-  </files>
-</package>
diff --git a/bin/prep/StringTemplate4.nuspec b/bin/prep/StringTemplate4.nuspec
deleted file mode 100644
index b2924b4..0000000
--- a/bin/prep/StringTemplate4.nuspec
+++ /dev/null
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="utf-8"?>
-<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
-  <metadata>
-    <id>StringTemplate4</id>
-    <version>0.0.0</version>
-    <authors>Sam Harwell, Terence Parr</authors>
-    <owners>Sam Harwell</owners>
-    <description>The C# port of StringTemplate 4.</description>
-    <language>en-us</language>
-    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
-    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
-    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
-    <copyright>Copyright Â© Sam Harwell 2013</copyright>
-    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$ANTLRVersion$</releaseNotes>
-    <requireLicenseAcceptance>true</requireLicenseAcceptance>
-    <tags>stringtemplate st4 stringtemplate4 template</tags>
-    <title>StringTemplate 4</title>
-    <summary>The C# port of StringTemplate 4.</summary>
-    <dependencies>
-      <dependency id="Antlr3.Runtime" version="$ANTLRVersion$" />
-    </dependencies>
-  </metadata>
-  <files>
-    <!-- Runtime Libraries -->
-
-    <file src="ST4\Antlr4.StringTemplate.dll" target="lib\net35-client"/>
-    <file src="ST4\Antlr4.StringTemplate.pdb" target="lib\net35-client"/>
-    <file src="ST4\Antlr4.StringTemplate.xml" target="lib\net35-client"/>
-
-    <!-- Source Code -->
-
-    <file exclude="..\..\Antlr4.StringTemplate\obj\**\*.cs" src="..\..\Antlr4.StringTemplate\**\*.cs" target="src"/>
-    <file src="..\..\Antlr4.StringTemplate\obj\$Configuration$\**\*.cs" target="src\obj\$Configuration$"/>
-    <file src="..\..\Antlr4.StringTemplate\obj\$Configuration$\**\*.tokens" target="src\obj\$Configuration$"/>
-  </files>
-</package>
diff --git a/bin/prep/prepare.ps1 b/bin/prep/prepare.ps1
deleted file mode 100644
index 8de575a..0000000
--- a/bin/prep/prepare.ps1
+++ /dev/null
@@ -1,220 +0,0 @@
-# build the solution
-$SolutionPath = "..\..\Antlr3.sln"
-
-# make sure the script was run from the expected path
-if (!(Test-Path $SolutionPath)) {
-  echo "The script was run from an invalid working directory."
-  exit 1
-}
-
-$BuildConfig = "Release"
-$DebugBuild = false
-
-# clean up from any previous builds
-$CleanItems = "Runtime", "Tool", "Bootstrap", "ST3", "ST4"
-$CleanItems | ForEach-Object {
-  if (Test-Path $_) {
-    Remove-Item -Force -Recurse $_
-  }
-}
-
-# build the project
-$msbuild = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe"
-#if (!(Test-Path $msbuild)) {
-#    [void][System.Reflection.Assembly]::Load('Microsoft.Build.Utilities.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
-#    $msbuild = [Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToDotNetFrameworkFile("msbuild.exe", "VersionLatest")
-#}
-
-&$msbuild /nologo /m /nr:false /t:rebuild /p:Configuration=$BuildConfig $SolutionPath
-if ($LASTEXITCODE -ne 0) {
-  echo "Build Failed, Aborting!"
-  exit $p.ExitCode
-}
-
-# back up the bootstrap folder
-$ArchivePath = ".\Backup\Bootstrap-" + [System.IO.Path]::GetFileNameWithoutExtension([System.IO.Path]::GetRandomFileName()) + ".7z"
-.\7z.exe a -r $ArchivePath "..\Bootstrap\*"
-
-# copy the new bootstrap files
-if ($DebugBuild) {
-  $BootstrapBinaries = "Antlr3.exe", "Antlr3.exe.config", "Antlr3.Runtime.dll", "Antlr3.Runtime.Debug.dll", "Antlr4.StringTemplate.dll", "Antlr4.StringTemplate.Visualizer.dll", "Antlr3.targets", "Antlr3.props", "AntlrBuildTask.dll"
-}
-else {
-  $BootstrapBinaries = "Antlr3.exe", "Antlr3.exe.config", "Antlr3.Runtime.dll", "Antlr3.Runtime.Debug.dll", "Antlr4.StringTemplate.dll", "Antlr3.targets", "Antlr3.props", "AntlrBuildTask.dll"
-}
-
-$BootstrapBinaries | ForEach-Object {
-    copy -force "..\$BuildConfig\$_" "..\Bootstrap"
-    if ($LASTEXITCODE -ne 0) {
-      echo "Bootstrap update failed, Aborting!"
-      exit $p.ExitCode
-    }
-}
-
-if ($LASTEXITCODE -ne 0) {
-  echo "Bootstrap update failed, Aborting!"
-  exit $p.ExitCode
-}
-
-if (-not (Test-Path "..\Bootstrap\Codegen\Templates\CSharp2")) {
-  mkdir "..\Bootstrap\Codegen\Templates\CSharp2"
-}
-
-copy -force "..\$BuildConfig\Codegen\Templates\LeftRecursiveRules.stg" "..\Bootstrap\Codegen\Templates"
-if ($LASTEXITCODE -ne 0) {
-  echo "Bootstrap update failed, Aborting!"
-  exit $p.ExitCode
-}
-
-copy -force "..\$BuildConfig\Codegen\Templates\CSharp2\*" "..\Bootstrap\Codegen\Templates\CSharp2"
-if ($LASTEXITCODE -ne 0) {
-  echo "Bootstrap update failed, Aborting!"
-  exit $p.ExitCode
-}
-
-copy -force "..\$BuildConfig\Codegen\Templates\CSharp3\*" "..\Bootstrap\Codegen\Templates\CSharp3"
-if ($LASTEXITCODE -ne 0) {
-  echo "Bootstrap update failed, Aborting!"
-  exit $p.ExitCode
-}
-
-copy -force "..\$BuildConfig\Targets\Antlr3.Targets.CSharp2.dll" "..\Bootstrap\Targets"
-if ($LASTEXITCODE -ne 0) {
-  echo "Bootstrap update failed, Aborting!"
-  exit $p.ExitCode
-}
-
-copy -force "..\$BuildConfig\Targets\Antlr3.Targets.CSharp3.dll" "..\Bootstrap\Targets"
-if ($LASTEXITCODE -ne 0) {
-  echo "Bootstrap update failed, Aborting!"
-  exit $p.ExitCode
-}
-
-copy -r -force "..\$BuildConfig\Tool\*" "..\Bootstrap\Tool"
-if ($LASTEXITCODE -ne 0) {
-  echo "Bootstrap update failed, Aborting!"
-  exit $p.ExitCode
-}
-
-Remove-Item -force "..\Bootstrap\Tool\Templates\messages\formats\gnu.stg"
-
-# build the project again with the new bootstrap files
-&$msbuild /nologo /m /nr:false /t:rebuild /p:Configuration=$BuildConfig $SolutionPath
-if ($LASTEXITCODE -ne 0) {
-  echo "Build Failed, Aborting!"
-  exit $p.ExitCode
-}
-
-# copy files from the build
-mkdir Runtime
-mkdir Tool
-mkdir Bootstrap
-mkdir ST3
-mkdir ST4
-copy "..\$BuildConfig\Antlr3.Runtime.dll" ".\Runtime"
-copy "..\$BuildConfig\Antlr3.Runtime.pdb" ".\Runtime"
-copy "..\$BuildConfig\Antlr3.Runtime.xml" ".\Runtime"
-copy "LICENSE.txt" ".\Runtime"
-
-copy "..\$BuildConfig\Antlr3.exe" ".\Tool"
-copy "..\$BuildConfig\Antlr3.exe.config" ".\Tool"
-copy "..\$BuildConfig\Antlr3.Runtime.dll" ".\Tool"
-copy "..\$BuildConfig\Antlr3.Runtime.Debug.dll" ".\Tool"
-copy "..\$BuildConfig\Antlr4.StringTemplate.dll" ".\Tool"
-if ($DebugBuild) {
-  copy "..\$BuildConfig\Antlr4.StringTemplate.Visualizer.dll" ".\Tool"
-}
-copy "..\$BuildConfig\Antlr3.props" ".\Tool"
-copy "..\$BuildConfig\Antlr3.targets" ".\Tool"
-copy "..\$BuildConfig\AntlrBuildTask.dll" ".\Tool"
-copy "LICENSE.txt" ".\Tool"
-
-copy ".\Tool\*" ".\Bootstrap"
-
-# copy ST4 binaries and all symbol files to the full Tool folder
-copy "..\$BuildConfig\Antlr3.pdb" ".\Tool"
-copy "..\$BuildConfig\Antlr3.Runtime.pdb" ".\Tool"
-copy "..\$BuildConfig\Antlr3.Runtime.Debug.pdb" ".\Tool"
-copy "..\$BuildConfig\Antlr4.StringTemplate.pdb" ".\Tool"
-if ($DebugBuild) {
-  copy "..\$BuildConfig\Antlr4.StringTemplate.Visualizer.pdb" ".\Tool"
-}
-copy "..\$BuildConfig\AntlrBuildTask.pdb" ".\Tool"
-copy "..\$BuildConfig\Antlr3.xml" ".\Tool"
-copy "..\$BuildConfig\Antlr3.Runtime.xml" ".\Tool"
-copy "..\$BuildConfig\Antlr3.Runtime.Debug.xml" ".\Tool"
-copy "..\$BuildConfig\Antlr4.StringTemplate.xml" ".\Tool"
-if ($DebugBuild) {
-  copy "..\$BuildConfig\Antlr4.StringTemplate.Visualizer.xml" ".\Tool"
-}
-copy "..\$BuildConfig\AntlrBuildTask.xml" ".\Tool"
-
-mkdir "Tool\Codegen"
-mkdir "Tool\Targets"
-mkdir "Tool\Tool"
-copy -r "..\$BuildConfig\Codegen\*" ".\Tool\Codegen"
-copy -r "..\$BuildConfig\Targets\*.dll" ".\Tool\Targets"
-copy -r "..\$BuildConfig\Targets\*.pdb" ".\Tool\Targets"
-copy -r "..\$BuildConfig\Targets\*.xml" ".\Tool\Targets"
-copy -r "..\$BuildConfig\Tool\*" ".\Tool\Tool"
-
-mkdir "Bootstrap\Codegen\Templates\CSharp2"
-mkdir "Bootstrap\Codegen\Templates\CSharp3"
-mkdir "Bootstrap\Tool"
-mkdir "Bootstrap\Targets"
-copy "..\$BuildConfig\Codegen\Templates\LeftRecursiveRules.stg" ".\Bootstrap\Codegen\Templates"
-copy "..\$BuildConfig\Codegen\Templates\CSharp2\*" ".\Bootstrap\Codegen\Templates\CSharp2"
-copy "..\$BuildConfig\Codegen\Templates\CSharp3\*" ".\Bootstrap\Codegen\Templates\CSharp3"
-copy "..\$BuildConfig\Targets\Antlr3.Targets.CSharp2.dll" ".\Bootstrap\Targets"
-copy "..\$BuildConfig\Targets\Antlr3.Targets.CSharp3.dll" ".\Bootstrap\Targets"
-copy -r "..\$BuildConfig\Tool\*" ".\Bootstrap\Tool"
-Remove-Item ".\Bootstrap\Tool\Templates\messages\formats\gnu.stg"
-
-# ST3 dist
-copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.StringTemplate.dll" ".\ST3"
-copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.Runtime.dll" ".\ST3"
-copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.StringTemplate.pdb" ".\ST3"
-copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.Runtime.pdb" ".\ST3"
-copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.StringTemplate.xml" ".\ST3"
-copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.Runtime.xml" ".\ST3"
-copy "LICENSE.txt" ".\ST3"
-
-# ST4 dist
-copy "..\$BuildConfig\Antlr3.Runtime.dll" ".\ST4"
-copy "..\$BuildConfig\Antlr4.StringTemplate.dll" ".\ST4"
-copy "..\$BuildConfig\Antlr4.StringTemplate.Visualizer.dll" ".\ST4"
-copy "..\$BuildConfig\Antlr3.Runtime.pdb" ".\ST4"
-copy "..\$BuildConfig\Antlr4.StringTemplate.pdb" ".\ST4"
-copy "..\$BuildConfig\Antlr4.StringTemplate.Visualizer.pdb" ".\ST4"
-copy "..\$BuildConfig\Antlr3.Runtime.xml" ".\ST4"
-copy "..\$BuildConfig\Antlr4.StringTemplate.xml" ".\ST4"
-copy "..\$BuildConfig\Antlr4.StringTemplate.Visualizer.xml" ".\ST4"
-copy "LICENSE.txt" ".\ST4"
-
-# compress the distributable packages
-$AntlrVersion = "3.5.0.3-alpha001"
-$STVersion = "4.0.7.2-alpha001"
-
-$ArchivePath = ".\dist\antlr-dotnet-csharpbootstrap-" + $AntlrVersion + ".7z"
-.\7z.exe a -r -mx9 $ArchivePath ".\Bootstrap\*"
-$ArchivePath = ".\dist\antlr-dotnet-csharpruntime-" + $AntlrVersion + ".7z"
-.\7z.exe a -r -mx9 $ArchivePath ".\Runtime\*"
-$ArchivePath = ".\dist\antlr-dotnet-tool-" + $AntlrVersion + ".7z"
-.\7z.exe a -r -mx9 $ArchivePath ".\Tool\*"
-$ArchivePath = ".\dist\antlr-dotnet-st3-" + $AntlrVersion + ".7z"
-.\7z.exe a -r -mx9 $ArchivePath ".\ST3\*"
-$ArchivePath = ".\dist\antlr-dotnet-st4-" + $STVersion + ".7z"
-.\7z.exe a -r -mx9 $ArchivePath ".\ST4\*"
-
-# Build the NuGet packages
-
-if (-not (Test-Path nuget)) {
-  mkdir "nuget"
-}
-
-.\NuGet.exe pack .\Antlr3.Runtime.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $AntlrVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
-.\NuGet.exe pack .\Antlr3.Runtime.Debug.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $AntlrVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
-.\NuGet.exe pack .\Antlr3.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $AntlrVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
-.\NuGet.exe pack .\StringTemplate3.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $AntlrVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
-.\NuGet.exe pack .\StringTemplate4.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $STVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
-.\NuGet.exe pack .\StringTemplate4.Visualizer.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $STVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
diff --git a/build/Bootstrap/Antlr3.Runtime.Debug.dll b/build/Bootstrap/Antlr3.Runtime.Debug.dll
new file mode 100644
index 0000000..f6b8832
Binary files /dev/null and b/build/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/build/Bootstrap/Antlr3.Runtime.dll b/build/Bootstrap/Antlr3.Runtime.dll
new file mode 100644
index 0000000..ff2c7f9
Binary files /dev/null and b/build/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/build/Bootstrap/Antlr3.exe b/build/Bootstrap/Antlr3.exe
new file mode 100644
index 0000000..d5688d9
Binary files /dev/null and b/build/Bootstrap/Antlr3.exe differ
diff --git a/build/Bootstrap/Antlr3.exe.config b/build/Bootstrap/Antlr3.exe.config
new file mode 100644
index 0000000..bd4cf43
--- /dev/null
+++ b/build/Bootstrap/Antlr3.exe.config
@@ -0,0 +1,3 @@
+<?xml version="1.0"?>
+<configuration>
+	<startup><supportedRuntime version="v2.0.50727" sku="Client"/></startup></configuration>
diff --git a/build/Bootstrap/Antlr3.targets b/build/Bootstrap/Antlr3.targets
new file mode 100644
index 0000000..c5f5c70
--- /dev/null
+++ b/build/Bootstrap/Antlr3.targets
@@ -0,0 +1,169 @@
+ï»¿<!--
+   [The "BSD licence"]
+   Copyright (c) 2011 Sam Harwell
+   All rights reserved.
+
+   Redistribution and use in source and binary forms, with or without
+   modification, are permitted provided that the following conditions
+   are met:
+   1. Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+   2. Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+   3. The name of the author may not be used to endorse or promote products
+      derived from this software without specific prior written permission.
+
+   THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+   IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+   OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+   IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+-->
+<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <PropertyGroup>
+    <BuildSystem>MSBuild</BuildSystem>
+    <TaskVersion>3.5.0.2</TaskVersion>
+    <TaskKeyToken>eb42632606e9261f</TaskKeyToken>
+    <AntlrBuildTaskAssemblyName Condition="'$(AntlrBuildTaskAssemblyName)'==''">AntlrBuildTask, Version=$(TaskVersion), Culture=neutral, PublicKeyToken=$(TaskKeyToken)</AntlrBuildTaskAssemblyName>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <LoadTimeSensitiveTargets>
+      $(LoadTimeSensitiveTargets);
+      AntlrCompile;
+    </LoadTimeSensitiveTargets>
+    <LoadTimeSensitiveProperties>
+      $(LoadTimeSensitiveProperties);
+      AntlrCompileDependsOn;
+    </LoadTimeSensitiveProperties>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'==''">$(MSBuildBinPath)</AntlrBuildTaskLocation>
+    <AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'!=''">$(AntlrBuildTaskPath)</AntlrBuildTaskLocation>
+    <AntlrToolLocation Condition="'$(AntlrToolPath)'==''">$(MSBuildBinPath)\Antlr3\Antlr3.exe</AntlrToolLocation>
+    <AntlrToolLocation Condition="'$(AntlrToolPath)'!=''">$(AntlrToolPath)</AntlrToolLocation>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrGenCodeFileNames Condition="'$(AntlrGenCodeFileNames)'==''">$(MSBuildProjectFile).AntlrGeneratedCodeFileListAbsolute.txt</AntlrGenCodeFileNames>
+  </PropertyGroup>
+
+  <UsingTask Condition="'$(AntlrBuildTaskPath)'==''" TaskName="Antlr3.Build.Tasks.AntlrClassGenerationTask" AssemblyName="$(AntlrBuildTaskAssemblyName)" />
+  <UsingTask Condition="'$(AntlrBuildTaskPath)'!=''" TaskName="Antlr3.Build.Tasks.AntlrClassGenerationTask" AssemblyFile="$(AntlrBuildTaskPath)\AntlrBuildTask.dll" />
+
+  <PropertyGroup>
+    <PrepareResourcesDependsOn>
+      AntlrCompile;
+      AntlrCompileAddFilesGenerated;
+      $(PrepareResourcesDependsOn)
+    </PrepareResourcesDependsOn>
+  </PropertyGroup>
+
+  <PropertyGroup>
+    <AntlrCompileDependsOn>
+      AntlrCompileReadGeneratedFileList
+    </AntlrCompileDependsOn>
+  </PropertyGroup>
+
+  <ItemGroup Condition="'$(BuildingInsideVisualStudio)'=='true'">
+    <AvailableItemName Include="Antlr3" />
+    <AvailableItemName Include="AntlrTokens" />
+    <AvailableItemName Include="AntlrAbstractGrammar" />
+  </ItemGroup>
+
+  <ItemDefinitionGroup>
+    <Antlr3>
+      <Generator>MSBuild:Compile</Generator>
+      <TargetLanguage/>
+      <DebugGrammar>false</DebugGrammar>
+      <ProfileGrammar>false</ProfileGrammar>
+    </Antlr3>
+  </ItemDefinitionGroup>
+
+  <Target Name="AntlrCompileReadGeneratedFileList">
+    <ReadLinesFromFile File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)">
+      <Output TaskParameter="Lines" ItemName="AntlrOutputCodeFilesList"/>
+    </ReadLinesFromFile>
+  </Target>
+
+  <PropertyGroup>
+    <!-- Add grammar compilation to the CoreCompileDependsOn so that the IDE inproc compilers (particularly VB)
+         can "see" the generated source files. -->
+    <CoreCompileDependsOn Condition="'$(BuildingInsideVisualStudio)' == 'true' ">
+      DesignTimeGrammarCompilation;
+      $(CoreCompileDependsOn)
+    </CoreCompileDependsOn>
+  </PropertyGroup>
+
+  <Target Name="DesignTimeGrammarCompilation">
+    <!-- Only if we are not actually performing a compile i.e. we are in design mode -->
+    <CallTarget Condition="'$(BuildingProject)' != 'true'"
+                Targets="AntlrCompile" />
+  </Target>
+
+  <Target Name="AntlrCompile"
+          DependsOnTargets="$(AntlrCompileDependsOn)"
+          Condition="'@(Antlr3)' != ''"
+          Inputs="@(Antlr3);@(AntlrTokens);@(AntlrAbstractGrammar)"
+          Outputs="@(AntlrOutputCodeFilesList);
+                  $(IntermediateOutputPath)$(AntlrGenCodeFileNames);">
+
+    <ItemGroup>
+      <AntlrGeneratedCodeFiles Remove="@(AntlrGeneratedCodeFiles)" />
+    </ItemGroup>
+
+    <PropertyGroup>
+      <_IntellisenseOnlyCompile>false</_IntellisenseOnlyCompile>
+      <_IntellisenseOnlyCompile Condition="'$(BuildingProject)' != 'true'">true</_IntellisenseOnlyCompile>
+    </PropertyGroup>
+    <AntlrClassGenerationTask
+      AntlrToolPath="$(AntlrToolLocation)"
+      BuildTaskPath="$(AntlrBuildTaskLocation)"
+      OutputPath="$(IntermediateOutputPath)"
+      TargetLanguage="%(Antlr3.TargetLanguage)"
+      SourceCodeFiles="@(Antlr3)"
+      ContinueOnError="$(_IntellisenseOnlyCompile)"
+      TokensFiles="@(AntlrTokens)"
+      AbstractGrammarFiles="@(AntlrAbstractGrammar)"
+      LanguageSourceExtensions="$(DefaultLanguageSourceExtension)"
+      DebugGrammar="%(Antlr3.DebugGrammar)"
+      ProfileGrammar="%(Antlr3.ProfileGrammar)">
+
+      <Output ItemName="AntlrGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
+    </AntlrClassGenerationTask>
+
+    <WriteLinesToFile
+      Condition="'$(_IntellisenseOnlyCompile)' != 'true'"
+      File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)"
+      Lines="@(AntlrGeneratedCodeFiles)"
+      Overwrite="true"/>
+  </Target>
+
+  <Target Name="AntlrCompileAddFilesGenerated"
+          AfterTargets="AntlrCompile"
+          Condition="'@(Antlr3)' != ''">
+
+    <ItemGroup>
+      <AntlrGeneratedCodeFiles Condition="'@(AntlrGeneratedCodeFiles)' == ''" Include="@(AntlrOutputCodeFilesList)" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <FileWrites Include="@(AntlrGeneratedCodeFiles);
+                           $(IntermediateOutputPath)$(AntlrGenCodeFileNames);" />
+    </ItemGroup>
+
+    <ItemGroup>
+      <Compile Include="@(AntlrGeneratedCodeFiles)" />
+      <!-- The WinFX "GenerateTemporaryTargetAssembly" target requires generated code files be added here. -->
+      <_GeneratedCodeFiles Include="@(AntlrGeneratedCodeFiles)" />
+    </ItemGroup>
+
+  </Target>
+</Project>
diff --git a/build/Bootstrap/Antlr4.StringTemplate.Visualizer.dll b/build/Bootstrap/Antlr4.StringTemplate.Visualizer.dll
new file mode 100644
index 0000000..87f8cde
Binary files /dev/null and b/build/Bootstrap/Antlr4.StringTemplate.Visualizer.dll differ
diff --git a/build/Bootstrap/Antlr4.StringTemplate.dll b/build/Bootstrap/Antlr4.StringTemplate.dll
new file mode 100644
index 0000000..16e9795
Binary files /dev/null and b/build/Bootstrap/Antlr4.StringTemplate.dll differ
diff --git a/build/Bootstrap/AntlrBuildTask.dll b/build/Bootstrap/AntlrBuildTask.dll
new file mode 100644
index 0000000..fee939f
Binary files /dev/null and b/build/Bootstrap/AntlrBuildTask.dll differ
diff --git a/build/Bootstrap/Codegen/Templates/CSharp2/AST.stg b/build/Bootstrap/Codegen/Templates/CSharp2/AST.stg
new file mode 100644
index 0000000..a94ed7c
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp2/AST.stg
@@ -0,0 +1,430 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+
+<if(!TREE_PARSER)>
+<! tree parser would already have imported !>
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
+<endif>
+>>
+
+@genericParser.members() ::= <<
+<@super.members()>
+<parserMembers()>
+>>
+
+parserCtorBody() ::= <%
+<super.parserCtorBody()><\n>
+TreeAdaptor =
+<if(actions.(actionScope).treeAdaptorInitializer)>
+	<actions.(actionScope).treeAdaptorInitializer>
+<else>
+	new <actions.(actionScope).treeAdaptorType; null="CommonTreeAdaptor">()
+<end>
+;
+%>
+
+/** Add an adaptor property that knows how to build trees */
+parserMembers() ::= <<
+private <treeAdaptorType()> adaptor;
+
+public <treeAdaptorType()> TreeAdaptor
+{
+	get
+	{
+		return adaptor;
+	}
+
+	set
+	{
+		this.adaptor = value;
+		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+	}
+}
+>>
+
+treeAdaptorType() ::= <<
+<actions.(actionScope).treeAdaptorType; null="ITreeAdaptor">
+>>
+
+ruleReturnBaseType() ::= <%
+Ast<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<ASTLabelType>, <labelType>>
+%>
+
+/** Add a variable to track rule's return AST */
+ruleDeclarations() ::= <<
+<super.ruleDeclarations()>
+<ASTLabelType> root_0 = default(<ASTLabelType>);<\n>
+>>
+
+ruleLabelDefs() ::= <<
+<super.ruleLabelDefs()>
+<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
+	:{it|<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
+<ruleDescriptor.tokenListLabels:{it|<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
+<ruleDescriptor.allTokenRefsInAltsWithRewrites
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
+<ruleDescriptor.allRuleRefsInAltsWithRewrites
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
+>>
+
+/** When doing auto AST construction, we must define some variables;
+ *  These should be turned off if doing rewrites.  This must be a "mode"
+ *  as a rule could have both rewrite and AST within the same alternative
+ *  block.
+ */
+@alt.declarations() ::= <<
+<if(autoAST)>
+<if(outerAlt)>
+<if(!rewriteMode)>
+root_0 = (<ASTLabelType>)adaptor.Nil();
+<endif>
+<endif>
+<endif>
+>>
+
+// T r a c k i n g  R u l e  E l e m e n t s
+
+/** ID and track it for use in a rewrite rule */
+tokenRefTrack(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefBang(...)> <! Track implies no auto AST construction!>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
+>>
+
+/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
+ *  to the tracking list stream_ID for use in the rewrite.
+ */
+tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefTrack(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** ^(ID ...) track for rewrite */
+tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefBang(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
+>>
+
+/** Match ^(label+=TOKEN ...) track for rewrite */
+tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefRuleRootTrack(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** rule when output=AST and tracking for rewrite */
+ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule.name>.Add(<label>.Tree);
+>>
+
+/** x+=rule when output=AST and tracking for rewrite */
+ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefTrack(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** ^(rule ...) rewrite */
+ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRoot(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule>.Add(<label>.Tree);
+>>
+
+/** ^(x+=rule ...) rewrite */
+ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRootTrack(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+// R e w r i t e
+
+rewriteCode(
+	alts, description,
+	referencedElementsDeep, // ALL referenced elements to right of ->
+	referencedTokenLabels,
+	referencedTokenListLabels,
+	referencedRuleLabels,
+	referencedRuleListLabels,
+	referencedWildcardLabels,
+	referencedWildcardListLabels,
+	rewriteBlockLevel, enclosingTreeLevel, treeLevel) ::= <<
+<\n>{
+// AST REWRITE
+// elements: <referencedElementsDeep; separator=", ">
+// token labels: <referencedTokenLabels; separator=", ">
+// rule labels: <referencedRuleLabels; separator=", ">
+// token list labels: <referencedTokenListLabels; separator=", ">
+// rule list labels: <referencedRuleListLabels; separator=", ">
+// wildcard labels: <[referencedWildcardLabels,referencedWildcardListLabels]; separator=", ">
+<if(backtracking)>
+if (<actions.(actionScope).synpredgate>) {
+<endif>
+<prevRuleRootRef()>.Tree = root_0;
+<rewriteCodeLabels()>
+root_0 = (<ASTLabelType>)adaptor.Nil();
+<alts:rewriteAlt(); separator="else ">
+<! if tree parser and rewrite=true !>
+<if(TREE_PARSER&&rewriteMode)>
+<prevRuleRootRef()>.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+if (<prevRuleRootRef()>.Tree != null)
+	input.ReplaceChildren(adaptor.GetParent(retval.Start), adaptor.GetChildIndex(retval.Start), adaptor.GetChildIndex(_last), retval.Tree);
+<endif>
+<! if parser or tree-parser && rewrite!=true, we need to set result !>
+<if(!TREE_PARSER||!rewriteMode)>
+<prevRuleRootRef()>.Tree = root_0;
+<endif>
+<if(backtracking)>
+}
+<endif>
+}
+
+>>
+
+rewriteCodeLabels() ::= <<
+<referencedTokenLabels
+    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
+    separator="\n"
+>
+<referencedTokenListLabels
+    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
+    separator="\n"
+>
+<referencedWildcardLabels
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
+	separator="\n"
+>
+<referencedWildcardListLabels
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
+	separator="\n"
+>
+<referencedRuleLabels
+    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
+    separator="\n"
+>
+<referencedRuleListLabels
+    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
+    separator="\n"
+>
+>>
+
+/** Generate code for an optional rewrite block; note it uses the deep ref'd element
+  *  list rather shallow like other blocks.
+  */
+rewriteOptionalBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+// <fileName>:<description>
+if (<referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||">)
+{
+	<alt>
+}
+<referencedElementsDeep:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewriteClosureBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+// <fileName>:<description>
+while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
+{
+	<alt>
+}
+<referencedElements:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewritePositiveClosureBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+if (!(<referencedElements:{el | stream_<el>.HasNext}; separator="||">))
+{
+	throw new RewriteEarlyExitException();
+}
+while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
+{
+	<alt>
+}
+<referencedElements:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewriteAlt(a) ::= <<
+// <a.description>
+<if(a.pred)>
+if (<a.pred>)
+{
+	<a.alt>
+}
+<else>
+{
+	<a.alt>
+}
+<endif>
+>>
+
+/** For empty rewrites: "r : ... -> ;" */
+rewriteEmptyAlt() ::= "root_0 = null;"
+
+rewriteTree(root,children,description,enclosingTreeLevel,treeLevel) ::= <<
+// <fileName>:<description>
+{
+<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
+<root:rewriteElement()>
+<children:rewriteElement()>
+adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
+}<\n>
+>>
+
+rewriteElementList(elements) ::= "<elements:rewriteElement()>"
+
+rewriteElement(e) ::= <%
+<@pregen()>
+DebugLocation(<e.line>, <e.pos>);<\n>
+<e.el>
+%>
+
+/** Gen ID or ID[args] */
+rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
+adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
+>>
+
+/** Gen $label ... where defined via label=ID */
+rewriteTokenLabelRef(label,elementIndex) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
+>>
+
+/** Gen $label ... where defined via label+=ID */
+rewriteTokenListLabelRef(label,elementIndex) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
+>>
+
+/** Gen ^($label ...) */
+rewriteTokenLabelRefRoot(label,elementIndex) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+/** Gen ^($label ...) where label+=... */
+rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot
+
+/** Gen ^(ID ...) or ^(ID[args] ...) */
+rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
+>>
+
+rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
+adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
+>>
+
+rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
+>>
+
+/** plain -> {foo} action */
+rewriteAction(action) ::= <<
+root_0 = <action>;<\n>
+>>
+
+/** What is the name of the previous value of this rule's root tree?  This
+ *  let's us refer to $rule to mean previous value.  I am reusing the
+ *  variable 'tree' sitting in retval struct to hold the value of root_0 right
+ *  before I set it during rewrites.  The assign will be to retval.tree.
+ */
+prevRuleRootRef() ::= "retval"
+
+rewriteRuleRef(rule) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<rule>.NextTree());<\n>
+>>
+
+rewriteRuleRefRoot(rule) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<rule>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+rewriteNodeAction(action) ::= <<
+adaptor.AddChild(root_<treeLevel>, <action>);<\n>
+>>
+
+rewriteNodeActionRoot(action) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<action>, root_<treeLevel>);<\n>
+>>
+
+/** Gen $ruleLabel ... where defined via ruleLabel=rule */
+rewriteRuleLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+/** Gen $ruleLabel ... where defined via ruleLabel+=rule */
+rewriteRuleListLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+/** Gen ^($ruleLabel ...) where ruleLabel=rule */
+rewriteRuleLabelRefRoot(label) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+/** Gen ^($ruleLabel ...) where ruleLabel+=rule */
+rewriteRuleListLabelRefRoot(label) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+rewriteWildcardLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
+<if(terminalOptions.node)>
+<! new MethodNode(IDLabel, args) !>
+new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
+<else>
+(<ASTLabelType>)adaptor.Create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
+<endif>
+%>
+
+createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
+<else>
+<if(args)> <! must create new node from old !>
+adaptor.Create(<token>, <args; separator=", ">)
+<else>
+stream_<token>.NextNode()
+<endif>
+<endif>
+%>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg b/build/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
new file mode 100644
index 0000000..e7b2904
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
@@ -0,0 +1,94 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2005 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Template overrides to add debugging to AST stuff.  Dynamic inheritance
+ *  hierarchy is set up as ASTDbg : AST : Dbg : Java by code generator.
+ */
+
+parserMembers() ::= <<
+	protected DebugTreeAdaptor adaptor;
+
+	public ITreeAdaptor TreeAdaptor
+	{
+		get
+		{
+			return adaptor;
+		}
+		set
+		{
+<if(grammar.grammarIsRoot)>
+			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
+<else>
+			this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+<endif><\n>
+			<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+		}
+	}<\n>
+>>
+
+parserCtorBody() ::= <<
+<super.parserCtorBody()>
+>>
+
+createListenerAndHandshake() ::= <<
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, <if(TREE_PARSER)>input.TreeAdaptor<else>adaptor<endif> );
+DebugListener = proxy;
+<inputStreamType> = new Debug<inputStreamType>( input, proxy );
+try
+{
+	proxy.Handshake();
+}
+catch ( IOException ioe )
+{
+	ReportError( ioe );
+}
+>>
+
+@ctorForRootGrammar.finally() ::= <<
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;
+proxy.TreeAdaptor = adap;
+>>
+
+@ctorForProfilingRootGrammar.finally() ::=<<
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;
+>>
+
+@ctorForPredefinedListener.superClassRef() ::= ": base( input, dbg )"
+
+@ctorForPredefinedListener.finally() ::=<<
+<if(grammar.grammarIsRoot)><! don't create new adaptor for delegates !>
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;<\n>
+<endif>
+>>
+
+//@rewriteElement.pregen() ::= "dbg.Location( <e.line>, <e.pos> );"
diff --git a/build/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg b/build/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
new file mode 100644
index 0000000..1585287
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
@@ -0,0 +1,192 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Templates for building ASTs during normal parsing.
+ *
+ *  Deal with many combinations.  Dimensions are:
+ *  Auto build or rewrite
+ *    no label, label, list label  (label/no-label handled together)
+ *    child, root
+ *    token, set, rule, wildcard
+ *
+ *  The situation is not too bad as rewrite (->) usage makes ^ and !
+ *  invalid. There is no huge explosion of combinations.
+ */
+
+@rule.setErrorReturnValue() ::= <<
+retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
+<! System.out.WriteLine("<ruleName> returns "+((CommonTree)retval.tree).toStringTree()); !>
+>>
+
+// TOKEN AST STUFF
+
+/** ID and output=AST */
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
+<super.tokenRef(...)>
+<if(backtracking)>if (state.backtracking == 0) {<endif>
+<label>_tree = <createNodeFromToken(...)>;
+adaptor.AddChild(root_0, <label>_tree);
+<if(backtracking)>}<endif>
+>>
+
+/** ID! and output=AST (same as plain tokenRef) */
+tokenRefBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"
+
+/** ID^ and output=AST */
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
+<super.tokenRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = <createNodeFromToken(...)>;
+root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
+<if(backtracking)>}<endif>
+>>
+
+/** ids+=ID! and output=AST */
+tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefBang(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** label+=TOKEN when output=AST but not rewrite alt */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match label+=TOKEN^ when output=AST but not rewrite alt */
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefRuleRoot(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+// SET AST
+
+// the match set stuff is interesting in that it uses an argument list
+// to pass code to the default matchSet; another possible way to alter
+// inherited code.  I don't use the region stuff because I need to pass
+// different chunks depending on the operator.  I don't like making
+// the template name have the operator as the number of templates gets
+// large but this is the most flexible--this is as opposed to having
+// the code generator call matchSet then add root code or ruleroot code
+// plus list label plus ...  The combinations might require complicated
+// rather than just added on code.  Investigate that refactoring when
+// I have more time.
+
+matchSet(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= <<
+<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);}, ...)>
+>>
+
+matchRuleBlockSet(s,label,elementIndex,postmatchCode,treeLevel="0",terminalOptions={}) ::= <<
+<matchSet(...)>
+>>
+
+matchSetBang(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= "<super.matchSet(...)>"
+
+// note there is no matchSetTrack because -> rewrites force sets to be
+// plain old blocks of alts: (A|B|...|C)
+
+matchSetRuleRoot(s,label,elementIndex,debug,terminalOptions={}) ::= <<
+<if(label)>
+<label>=(<labelType>)input.LT(1);
+<endif>
+<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);}, ...)>
+>>
+
+// RULE REF AST
+
+/** rule when output=AST */
+ruleRef(rule,label,elementIndex,args,scope) ::= <<
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <label>.Tree);
+>>
+
+/** rule! is same as normal rule ref */
+ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(...)>"
+
+/** rule^ */
+ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
+>>
+
+/** x+=rule when output=AST */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** x+=rule! when output=AST is a rule ref with list addition */
+ruleRefBangAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefBang(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** x+=rule^ */
+ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRoot(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+// WILDCARD AST
+
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
+<super.wildcard(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
+adaptor.AddChild(root_0, <label>_tree);
+<if(backtracking)>}<endif>
+>>
+
+wildcardBang(label,elementIndex) ::= "<super.wildcard(token=[],...)>"
+
+wildcardRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
+<super.wildcard(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
+root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
+<if(backtracking)>}<endif>
+>>
+
+createNodeFromToken(label,terminalOptions={}) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
+<else>
+(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
+<endif>
+%>
+
+ruleCleanUp() ::= <<
+<super.ruleCleanUp()>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
+<if(backtracking)>}<endif>
+>>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg b/build/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
new file mode 100644
index 0000000..316282f
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
@@ -0,0 +1,380 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Templates for building ASTs during tree parsing.
+ *
+ *  Deal with many combinations.  Dimensions are:
+ *  Auto build or rewrite
+ *    no label, label, list label  (label/no-label handled together)
+ *    child, root
+ *    token, set, rule, wildcard
+ *
+ *  Each combination has its own template except that label/no label
+ *  is combined into tokenRef, ruleRef, ...
+ */
+
+/** Add a variable to track last element matched */
+ruleDeclarations() ::= <<
+<super.ruleDeclarations()>
+<if(!ruleDescriptor.isSynPred)>
+<ASTLabelType> _first_0 = default(<ASTLabelType>);
+<ASTLabelType> _last = default(<ASTLabelType>);
+<endif>
+>>
+
+/** What to emit when there is no rewrite rule.  For auto build
+ *  mode, does nothing.
+ */
+noRewrite(rewriteBlockLevel=false, treeLevel=false) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(rewriteMode)>
+retval.Tree = (<ASTLabelType>)_first_0;
+if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
+    retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
+<endif>
+<if(backtracking)>}<endif>
+<endif>
+>>
+
+/** match ^(root children) in tree parser; override here to
+ *  add tree construction actions.
+ */
+tree(root, actionsAfterRoot, children, nullableChildList,
+     enclosingTreeLevel, treeLevel) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+{
+<ASTLabelType> _save_last_<treeLevel> = _last;
+<ASTLabelType> _first_<treeLevel> = default(<ASTLabelType>);
+<if(!rewriteMode)>
+<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
+<endif>
+<root:element()>
+<if(rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+<if(root.el.rule)>
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
+<else>
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>;
+<endif>
+<endif>
+<actionsAfterRoot:element()>
+<if(nullableChildList)>
+if (input.LA(1) == TokenTypes.Down) {
+    Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+    <children:element()>
+    Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+}
+<else>
+Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+<children:element()>
+Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+<endif>
+<if(!rewriteMode)>
+adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
+<endif>
+_last = _save_last_<treeLevel>;
+}
+<else>
+<super.tree(...)>
+<endif>
+>>
+
+// TOKEN AST STUFF
+
+/** ID! and output=AST (same as plain tokenRef) 'cept add
+ *  setting of _last
+ */
+tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+<else>
+<super.tokenRefBang(...)>
+<endif>
+>>
+
+/** ID auto construct */
+tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>}<endif>
+<else> <! rewrite mode !>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
+<endif>
+<else>
+<super.tokenRef(...)>
+<endif>
+>>
+
+/** label+=TOKEN auto construct */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<tokenRef(...)>
+<listLabelElem(elem=label,...)>
+<else>
+<super.tokenRefAndListLabel(...)>
+<endif>
+>>
+
+/** ^(ID ...) auto construct */
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
+<if(backtracking)>}<endif>
+<endif>
+<else>
+<super.tokenRefRuleRoot(...)>
+<endif>
+>>
+
+/** Match ^(label+=TOKEN ...) auto construct */
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<tokenRefRuleRoot(...)>
+<listLabelElem(elem=label,...)>
+<else>
+<super.tokenRefRuleRootAndListLabel(...)>
+<endif>
+>>
+
+/** Match . wildcard and auto dup the node/subtree */
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.wildcard(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.DupTree(<label>);
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>}<endif>
+<else> <! rewrite mode !>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
+<endif>
+<else>
+<super.wildcard(...)>
+<endif>
+>>
+
+// SET AST
+
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.matchSet(postmatchCode={
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>\}<endif>
+<endif>
+}, ...
+)>
+<else>
+<super.matchSet(...)>
+<endif>
+>>
+
+matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<matchSet(...)>
+<noRewrite(...)> <! set return tree !>
+<else>
+<super.matchRuleBlockSet(...)>
+<endif>
+>>
+
+matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.matchSet(...)>
+<else>
+<super.matchSetBang(...)>
+<endif>
+>>
+
+matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<super.matchSet(postmatchCode={
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
+<if(backtracking)>\}<endif>
+<endif>
+}, ...
+)>
+<else>
+<super.matchSetRuleRoot(...)>
+<endif>
+>>
+
+// RULE REF AST
+
+/** rule auto construct */
+ruleRef(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+<if(!rewriteMode)>
+adaptor.AddChild(root_<treeLevel>, <label>.Tree);
+<else> <! rewrite mode !>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
+<endif>
+<else>
+<super.ruleRef(...)>
+<endif>
+>>
+
+/** x+=rule auto construct */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<ruleRef(...)>
+<listLabelElem(elem={<label>.Tree},...)>
+<else>
+<super.ruleRefAndListLabel(...)>
+<endif>
+>>
+
+/** ^(rule ...) auto construct */
+ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
+<endif>
+<else>
+<super.ruleRefRuleRoot(...)>
+<endif>
+>>
+
+/** ^(x+=rule ...) auto construct */
+ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<ruleRefRuleRoot(...)>
+<listLabelElem(elem={<label>.Tree},...)>
+<else>
+<super.ruleRefRuleRootAndListLabel(...)>
+<endif>
+>>
+
+/** rule when output=AST and tracking for rewrite */
+ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefTrack(...)>
+<else>
+<super.ruleRefTrack(...)>
+<endif>
+>>
+
+/** x+=rule when output=AST and tracking for rewrite */
+ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefTrackAndListLabel(...)>
+<else>
+<super.ruleRefTrackAndListLabel(...)>
+<endif>
+>>
+
+/** ^(rule ...) rewrite */
+ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefRootTrack(...)>
+<else>
+<super.ruleRefRuleRootTrack(...)>
+<endif>
+>>
+
+/** ^(x+=rule ...) rewrite */
+ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefRuleRootTrackAndListLabel(...)>
+<else>
+<super.ruleRefRuleRootTrackAndListLabel(...)>
+<endif>
+>>
+
+/** Streams for token refs are tree nodes now; override to
+ *  change NextToken to NextNode.
+ */
+createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
+<else>
+stream_<token>.NextNode()
+<endif>
+%>
+
+ruleCleanUp() ::= <<
+<super.ruleCleanUp()>
+<if(!ruleDescriptor.isSynPred)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+<if(backtracking)>}<endif>
+<endif>
+<endif>
+>>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg b/build/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
new file mode 100644
index 0000000..8f15ef2
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
@@ -0,0 +1,1772 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+csharpVisibilityMap ::= [
+	"private":"private",
+	"protected":"protected",
+	"public":"public",
+	"fragment":"private",
+	default:"private"
+]
+
+/** The overall file structure of a recognizer; stores methods for rules
+ *  and cyclic DFAs plus support code.
+ */
+outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
+			docComment, recognizer,
+			name, tokens, tokenNames, rules, cyclicDFAs,
+			bitsets, buildTemplate, buildAST, rewriteMode, profile,
+			backtracking, synpreds, memoize, numRules,
+			fileName, ANTLRVersion, generatedTimestamp, trace,
+			scopes, superClass, literals) ::=
+<<
+//------------------------------------------------------------------------------
+// \<auto-generated>
+//     This code was generated by a tool.
+//     ANTLR Version: <ANTLRVersion>
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// \</auto-generated>
+//------------------------------------------------------------------------------
+
+// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>
+
+<if(trace)>
+#define ANTLR_TRACE
+<endif>
+<@debugPreprocessor()>
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 168, 219
+// Unreachable code detected.
+#pragma warning disable 162
+// Missing XML comment for publicly visible type or member 'Type_or_Member'
+#pragma warning disable 1591
+
+<actions.(actionScope).header>
+
+<@imports>
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Misc;
+<if(TREE_PARSER)>
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
+<endif>
+using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;
+<@end>
+<if(actions.(actionScope).namespace)>
+namespace <actions.(actionScope).namespace>
+{
+<endif>
+<docComment>
+<recognizer>
+<if(actions.(actionScope).namespace)>
+
+} // namespace <actions.(actionScope).namespace>
+<endif>
+>>
+
+lexerInputStreamType() ::= <<
+<actions.(actionScope).inputStreamType; null="ICharStream">
+>>
+
+lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
+      superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>}) ::= <<
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
+[System.CLSCompliant(false)]
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+{
+	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
+	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+	<actions.lexer.members>
+
+    // delegates
+    <grammar.delegates:
+         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+    // delegators
+    <grammar.delegators:
+         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+    <last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
+	{
+		OnCreated();
+	}
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+		: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
+	{
+	}
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+		: base(input, state)
+	{
+<if(memoize)>
+<if(grammar.grammarIsRoot)>
+		state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<numRules>+1];<\n><! index from 1..n !>
+<endif>
+<endif>
+		<grammar.directDelegates:
+		 {g|<g:delegateName()> = new <g.recognizerName>(input, this.state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+		<grammar.delegators:
+		 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+
+		OnCreated();
+	}
+	public override string GrammarFileName { get { return "<fileName>"; } }
+
+	private static readonly bool[] decisionCanBacktrack = new bool[0];
+
+<if(grammar.hasDelegates)>
+	public override <lexerInputStreamType()> CharStream
+	{
+		get
+		{
+			return base.CharStream;
+		}
+		set
+		{
+			base.CharStream = value;
+			<grammar.directDelegates:
+			 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+			<grammar.delegators:
+			 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+			<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+		}
+	}
+
+<if(grammar.delegates)>
+	public override void SetState(RecognizerSharedState state)
+	{
+		base.SetState(state);
+		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
+	}
+<endif>
+
+<endif>
+<if(filterMode)>
+	<filteringNextToken()>
+<endif>
+
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void OnCreated() {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}
+
+    <rules; separator="\n">
+
+	<insertLexerSynpreds(synpreds)>
+
+	#region DFA
+	<cyclicDFAs:{dfa | DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif>);}; separator="\n">
+	}
+
+	<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
+	#endregion
+
+}
+>>
+
+/** A override of Lexer.nextToken() that backtracks over mTokens() looking
+ *  for matches.  No error can be generated upon error; just rewind, consume
+ *  a token and then try again.  backtracking needs to be set as well.
+ *  Make rule memoization happen only at levels above 1 as we start mTokens
+ *  at backtracking==1.
+ */
+filteringNextToken() ::= <<
+public override IToken NextToken()
+{
+	while (true)
+	{
+		if (input.LA(1) == CharStreamConstants.EndOfFile)
+		{
+			IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
+			eof.Line = Line;
+			eof.CharPositionInLine = CharPositionInLine;
+			return eof;
+		}
+		state.token = null;
+		state.channel = TokenChannels.Default;
+		state.tokenStartCharIndex = input.Index;
+		state.tokenStartCharPositionInLine = input.CharPositionInLine;
+		state.tokenStartLine = input.Line;
+		state.text = null;
+		try
+		{
+			int m = input.Mark();
+			state.backtracking=1;<! means we won't throw slow exception !>
+			state.failed=false;
+			mTokens();
+			state.backtracking=0;
+			<! mTokens backtracks with synpred at backtracking==2
+			   and we set the synpredgate to allow actions at level 1. !>
+			if (state.failed)
+			{
+				input.Rewind(m);
+				input.Consume();<! advance one char and try again !>
+			}
+			else
+			{
+				Emit();
+				return state.token;
+			}
+		}
+		catch (RecognitionException re)
+		{
+			// shouldn't happen in backtracking mode, but...
+			ReportError(re);
+			Recover(re);
+		}
+	}
+}
+
+public override void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex)
+{
+	if (state.backtracking > 1)
+		base.Memoize(input, ruleIndex, ruleStartIndex);
+}
+
+public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
+{
+	if (state.backtracking > 1)
+		return base.AlreadyParsedRule(input, ruleIndex);
+
+	return false;
+}
+>>
+
+actionGate() ::= "state.backtracking == 0"
+
+filteringActionGate() ::= "state.backtracking == 1"
+
+/** How to generate a parser */
+genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
+              bitsets, inputStreamType, superClass,
+              labelType, members, rewriteElementType,
+              filterMode, ASTLabelType="object") ::= <<
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
+[System.CLSCompliant(false)]
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+{
+<if(grammar.grammarIsRoot)>
+	internal static readonly string[] tokenNames = new string[] {
+		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
+	};
+<endif>
+	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
+
+<if(grammar.delegates)>
+	// delegates
+	<grammar.delegates:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
+	// delegators
+	<grammar.delegators:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+<endif>
+
+<if(grammar.delegates)>
+	public override void SetState(RecognizerSharedState state)
+	{
+		base.SetState(state);
+		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
+	}
+
+<if(TREE_PARSER)>
+	public override void SetTreeNodeStream(ITreeNodeStream input)
+	{
+		base.SetTreeNodeStream(input);
+		<grammar.delegates:{g|<g:delegateName()>.SetTreeNodeStream(input);}; separator="\n">
+	}
+<endif>
+<endif>
+
+	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+	<@members()>
+
+	public override string[] TokenNames { get { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; } }
+	public override string GrammarFileName { get { return "<fileName>"; } }
+
+	<members>
+
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void OnCreated() {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}
+
+	#region Rules
+	<rules; separator="\n">
+	#endregion Rules
+
+<if(grammar.delegatedRules)>
+<! generate rule/method definitions for imported rules so they
+   appear to be defined in this recognizer. !>
+	#region Delegated rules
+<grammar.delegatedRules:{ruleDescriptor|
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", "><endif>); \}}; separator="\n">
+	#endregion Delegated rules
+<endif>
+
+	<insertSynpreds(synpreds)>
+
+<if(cyclicDFAs)>
+	#region DFA
+	<cyclicDFAs:{dfa | private DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>( this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif> );}; separator="\n">
+	}
+
+	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
+	#endregion DFA
+<endif>
+
+<if(bitsets)>
+	#region Follow sets
+	private static class Follow
+	{
+		<bitsets:{it|<bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>}; separator="\n">
+	}
+	#endregion Follow sets
+<endif>
+}
+>>
+
+@genericParser.members() ::= <<
+#if ANTLR_DEBUG
+private static readonly bool[] decisionCanBacktrack =
+	new bool[]
+	{
+		false, // invalid decision
+		<grammar.decisions:{d | <d.dfa.hasSynPred>}; wrap="\n", separator=", ">
+	};
+#else
+private static readonly bool[] decisionCanBacktrack = new bool[0];
+#endif
+<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: base(input, state)
+{
+<if(grammar.directDelegates)>
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+<endif>
+<if(grammar.indirectDelegates)>
+	<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
+	<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+<endif>
+	<parserCtorBody()>
+	OnCreated();
+}
+>>
+
+// imported grammars are 'public' (can't be internal because their return scope classes must be accessible)
+parserModifier(grammar, actions) ::= <<
+<if(grammar.grammarIsRoot)><actions.(actionScope).modifier; null="public"><else>public<endif>
+>>
+
+parserCtorBody() ::= <<
+<if(memoize)>
+<if(grammar.grammarIsRoot)>
+this.state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<length(grammar.allImportedRules)>+1];<\n><! index from 1..n !>
+<endif>
+<endif>
+<grammar.delegators:
+ {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+>>
+
+parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
+       ASTLabelType="object", superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Parser<endif>}, labelType="IToken",
+       members={<actions.parser.members>}) ::= <<
+<genericParser(inputStreamType="ITokenStream", rewriteElementType="IToken", ...)>
+>>
+
+/** How to generate a tree parser; same as parser except the input
+ *  stream is a different type.
+ */
+treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
+           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="object",
+           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif><endif>},
+           members={<actions.treeparser.members>}) ::= <<
+<genericParser(inputStreamType="ITreeNodeStream", rewriteElementType="Node", ...)>
+>>
+
+/** A simpler version of a rule template that is specific to the imaginary
+ *  rules created for syntactic predicates.  As they never have return values
+ *  nor parameters etc..., just give simplest possible method.  Don't do
+ *  any of the normal memoization stuff in here either; it's a waste.
+ *  As predicates cannot be inlined into the invoking rule, they need to
+ *  be in a rule by themselves.
+ */
+synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
+<<
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>_fragment() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>_fragment() {}
+
+// $ANTLR start <ruleName>
+<ruleModifier(grammar,ruleDescriptor)> void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	<ruleLabelDefs()>
+	EnterRule_<ruleName>_fragment();
+	EnterRule("<ruleName>_fragment", <ruleDescriptor.index>);
+	TraceIn("<ruleName>_fragment", <ruleDescriptor.index>);
+	try
+	{
+		<block>
+	}
+	finally
+	{
+		TraceOut("<ruleName>_fragment", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>_fragment", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>_fragment();
+	}
+}
+// $ANTLR end <ruleName>
+>>
+
+insertLexerSynpreds(synpreds) ::= <<
+<insertSynpreds(synpreds)>
+>>
+
+insertSynpreds(synpreds) ::= <<
+<if(synpreds)>
+#region Synpreds
+private bool EvaluatePredicate(System.Action fragment)
+{
+	bool success = false;
+	state.backtracking++;
+	<@start()>
+	try { DebugBeginBacktrack(state.backtracking);
+	int start = input.Mark();
+	try
+	{
+		fragment();
+	}
+	catch ( RecognitionException re )
+	{
+		System.Console.Error.WriteLine("impossible: "+re);
+	}
+	success = !state.failed;
+	input.Rewind(start);
+	} finally { DebugEndBacktrack(state.backtracking, success); }
+	<@stop()>
+	state.backtracking--;
+	state.failed=false;
+	return success;
+}
+#endregion Synpreds
+<endif>
+>>
+
+ruleMemoization(name) ::= <<
+<if(memoize)>
+if (state.backtracking > 0 && AlreadyParsedRule(input, <ruleDescriptor.index>)) { <returnFromRule()> }
+<endif>
+>>
+
+/** How to test for failure and return from rule */
+checkRuleBacktrackFailure() ::= <<
+<if(backtracking)>if (state.failed) <returnFromRule()><endif>
+>>
+
+/** This rule has failed, exit indicating failure during backtrack */
+ruleBacktrackFailure() ::= <<
+<if(backtracking)>if (state.backtracking>0) {state.failed=true; <returnFromRule()>}<endif>
+>>
+
+ruleWrapperMap ::= [
+	"bottomup":{<ruleWrapperBottomup()>},
+	"topdown":{<ruleWrapperTopdown()>},
+	default:""
+]
+
+ruleWrapperBottomup() ::= <<
+<if(TREE_PARSER && filterMode)>
+protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Bottomup() { return bottomup(); }
+<endif>
+>>
+
+ruleWrapperTopdown() ::= <<
+<if(TREE_PARSER && filterMode)>
+protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Topdown() { return topdown(); }
+<endif>
+>>
+
+/** How to generate code for a rule.  This includes any return type
+ *  data aggregates required for multiple return values.
+ */
+rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memoize) ::= <<
+<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
+<returnScope(ruleDescriptor.returnScope)>
+
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>() {}
+<ruleWrapperMap.(ruleName)>
+// $ANTLR start "<ruleName>"
+// <fileName>:<description>
+[GrammarRule("<ruleName>")]
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	EnterRule_<ruleName>();
+	EnterRule("<ruleName>", <ruleDescriptor.index>);
+	TraceIn("<ruleName>", <ruleDescriptor.index>);
+    <ruleScopeSetUp()>
+    <ruleDeclarations()>
+    <ruleLabelDefs()>
+    <ruleDescriptor.actions.init>
+	try { DebugEnterRule(GrammarFileName, "<ruleName>");
+	DebugLocation(<ruleDescriptor.tree.line>, <ruleDescriptor.EORNode.charPositionInLine>);
+	<@preamble()>
+	try
+	{
+		<ruleMemoization(name=ruleName)>
+		<block>
+		<ruleCleanUp()>
+		<(ruleDescriptor.actions.after):execAction()>
+	}
+<if(exceptions)>
+	<exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
+<else>
+<if(!emptyRule)>
+<if(actions.(actionScope).rulecatch)>
+	<actions.(actionScope).rulecatch>
+<else>
+	catch (RecognitionException re)
+	{
+		ReportError(re);
+		Recover(input,re);
+	<@setErrorReturnValue()>
+	}
+<endif>
+<endif>
+<endif>
+	finally
+	{
+		TraceOut("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>();
+        <memoize()>
+        <ruleScopeCleanUp()>
+        <finally>
+    }
+ 	DebugLocation(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);
+	} finally { DebugExitRule(GrammarFileName, "<ruleName>"); }
+	<@postamble()>
+	<returnFromRule()><\n>
+}
+// $ANTLR end "<ruleName>"
+>>
+
+// imported grammars need to have internal rules
+ruleModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>internal<endif>
+>>
+
+// imported grammars need to have public return scopes
+returnScopeModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>public<endif>
+>>
+
+catch(decl,action) ::= <<
+catch (<e.decl>)
+{
+	<e.action>
+}
+>>
+
+ruleDeclarations() ::= <<
+<if(ruleDescriptor.hasMultipleReturnValues)>
+<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>();
+retval.Start = (<labelType>)input.LT(1);
+<elseif(ruleDescriptor.returnScope)>
+<ruleDescriptor.returnScope.attributes:{ a |
+<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
+}>
+<endif>
+<if(memoize)>
+int <ruleDescriptor.name>_StartIndex = input.Index;
+<endif>
+>>
+
+ruleScopeSetUp() ::= <<
+<ruleDescriptor.useScopes:{it|<it>_stack.Push(new <it>_scope());<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
+<ruleDescriptor.ruleScope:{it|<it.name>_stack.Push(new <it.name>_scope());<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
+>>
+
+ruleScopeCleanUp() ::= <<
+<ruleDescriptor.useScopes:{it|<it>_scopeAfter(<it>_stack.Peek());<it>_stack.Pop();}; separator="\n">
+<ruleDescriptor.ruleScope:{it|<it.name>_scopeAfter(<it.name>_stack.Peek());<it.name>_stack.Pop();}; separator="\n">
+>>
+
+ruleLabelDefs() ::= <<
+<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
+    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<ruleDescriptor.tokenListLabels
+    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<[ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
+    :{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
+<ruleDescriptor.ruleListLabels:ruleLabelDef(); separator="\n">
+>>
+
+lexerRuleLabelDefs() ::= <<
+<[ruleDescriptor.tokenLabels,
+  ruleDescriptor.tokenListLabels,
+  ruleDescriptor.ruleLabels]
+    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<[ruleDescriptor.charListLabels,
+  ruleDescriptor.charLabels]
+	:{it|int <it.label.text> = 0;}; separator="\n"
+>
+<[ruleDescriptor.tokenListLabels,
+  ruleDescriptor.ruleListLabels]
+    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<ruleDescriptor.charListLabels:{it|List\<int> list_<it.label.text> = null;}; separator="\n"
+>
+>>
+
+returnFromRule() ::= <%
+return
+<if(!ruleDescriptor.isSynPred)>
+<if(ruleDescriptor.hasReturnValue)>
+<if(ruleDescriptor.hasSingleReturnValue)>
+<! This comment is a hack to make sure the following
+   single space appears in the output. !> <ruleDescriptor.singleValueReturnName>
+<else>
+<!!> retval
+<endif>
+<endif>
+<endif>
+;
+%>
+
+ruleCleanUp() ::= <<
+<if(ruleDescriptor.hasMultipleReturnValues)>
+<if(!TREE_PARSER)>
+retval.Stop = (<labelType>)input.LT(-1);
+<endif>
+<endif>
+>>
+
+memoize() ::= <<
+<if(memoize)>
+<if(backtracking)>
+if (state.backtracking > 0) { Memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex); }
+<endif>
+<endif>
+>>
+
+/** How to generate a rule in the lexer; naked blocks are used for
+ *  fragment rules.
+ */
+lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
+
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>() {}
+
+// $ANTLR start "<ruleName>"
+[GrammarRule("<ruleName>")]
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	EnterRule_<ruleName>();
+	EnterRule("<ruleName>", <ruleDescriptor.index>);
+	TraceIn("<ruleName>", <ruleDescriptor.index>);
+    <ruleScopeSetUp()>
+    <ruleDeclarations()>
+		try
+		{
+<if(nakedBlock)>
+		<ruleMemoization(name=ruleName)>
+		<lexerRuleLabelDefs()>
+		<ruleDescriptor.actions.init>
+		<block>
+<else>
+		int _type = <ruleName>;
+		int _channel = DefaultTokenChannel;
+		<ruleMemoization(name=ruleName)>
+		<lexerRuleLabelDefs()>
+		<ruleDescriptor.actions.init>
+		<block>
+		<ruleCleanUp()>
+		state.type = _type;
+		state.channel = _channel;
+		<(ruleDescriptor.actions.after):execAction()>
+<endif>
+	}
+	finally
+	{
+		TraceOut("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>();
+        <ruleScopeCleanUp()>
+        <memoize()>
+    }
+}
+// $ANTLR end "<ruleName>"
+>>
+
+/** How to generate code for the implicitly-defined lexer grammar rule
+ *  that chooses between lexer rules.
+ */
+tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
+
+public override void mTokens()
+{
+	<block><\n>
+}
+>>
+
+// S U B R U L E S
+
+/** A (...) subrule with multiple alternatives */
+block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int alt<decisionNumber>=<maxAlt>;
+<decls>
+<@predecision()>
+try { DebugEnterSubRule(<decisionNumber>);
+try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+<decision>
+} finally { DebugExitDecision(<decisionNumber>); }
+<@postdecision()>
+<@prebranch()>
+switch (alt<decisionNumber>)
+{
+<alts:{a|<altSwitchCase(i,a)>}>
+}
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postbranch()>
+>>
+
+/** A rule block with multiple alternatives */
+ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int alt<decisionNumber>=<maxAlt>;
+<decls>
+<@predecision()>
+try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+<decision>
+} finally { DebugExitDecision(<decisionNumber>); }
+<@postdecision()>
+switch (alt<decisionNumber>)
+{
+<alts:{a|<altSwitchCase(i,a)>}>
+}
+>>
+
+ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@prealt()>
+DebugEnterAlt(1);
+<alts>
+<@postalt()>
+>>
+
+/** A special case of a (...) subrule with a single alternative */
+blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@prealt()>
+DebugEnterAlt(1);
+<alts>
+<@postalt()>
+>>
+
+/** A (..)+ block with 1 or more alternatives */
+positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int cnt<decisionNumber>=0;
+<decls>
+<@preloop()>
+try { DebugEnterSubRule(<decisionNumber>);
+while (true)
+{
+	int alt<decisionNumber>=<maxAlt>;
+	<@predecision()>
+	try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+	<decision>
+	} finally { DebugExitDecision(<decisionNumber>); }
+	<@postdecision()>
+	switch (alt<decisionNumber>)
+	{
+	<alts:{a|<altSwitchCase(i,a)>}>
+	default:
+		if (cnt<decisionNumber> >= 1)
+			goto loop<decisionNumber>;
+
+		<ruleBacktrackFailure()>
+		EarlyExitException eee<decisionNumber> = new EarlyExitException( <decisionNumber>, input );
+		DebugRecognitionException(eee<decisionNumber>);
+		<@earlyExitException()>
+		throw eee<decisionNumber>;
+	}
+	cnt<decisionNumber>++;
+}
+loop<decisionNumber>:
+	;
+
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postloop()>
+>>
+
+positiveClosureBlockSingleAlt ::= positiveClosureBlock
+
+/** A (..)* block with 1 or more alternatives */
+closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@preloop()>
+try { DebugEnterSubRule(<decisionNumber>);
+while (true)
+{
+	int alt<decisionNumber>=<maxAlt>;
+	<@predecision()>
+	try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);
+	<decision>
+	} finally { DebugExitDecision(<decisionNumber>); }
+	<@postdecision()>
+	switch ( alt<decisionNumber> )
+	{
+	<alts:{a|<altSwitchCase(i,a)>}>
+	default:
+		goto loop<decisionNumber>;
+	}
+}
+
+loop<decisionNumber>:
+	;
+
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postloop()>
+>>
+
+closureBlockSingleAlt ::= closureBlock
+
+/** Optional blocks (x)? are translated to (x|) by before code generation
+ *  so we can just use the normal block template
+ */
+optionalBlock ::= block
+
+optionalBlockSingleAlt ::= block
+
+/** A case in a switch that jumps to an alternative given the alternative
+ *  number.  A DFA predicts the alternative and then a simple switch
+ *  does the jump to the code that actually matches that alternative.
+ */
+altSwitchCase(altNum,alt) ::= <<
+case <altNum>:
+	<@prealt()>
+	DebugEnterAlt(<altNum>);
+	<alt>
+	break;<\n>
+>>
+
+/** An alternative is just a list of elements; at outermost level */
+alt(elements,altNum,description,autoAST,outerAlt,treeLevel,rew) ::= <<
+// <fileName>:<description>
+{
+<@declarations()>
+<elements:element()>
+<rew>
+<@cleanup()>
+}
+>>
+
+/** What to emit when there is no rewrite.  For auto build
+ *  mode, does nothing.
+ */
+noRewrite(rewriteBlockLevel, treeLevel) ::= ""
+
+// E L E M E N T S
+
+/** Dump the elements one per line */
+element(it) ::= <%
+<@prematch()>
+DebugLocation(<it.line>, <it.pos>);<\n>
+<it.el><\n>
+%>
+
+/** match a token optionally with a label in front */
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
+<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
+>>
+
+/** ids+=ID */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+listLabelElem(label,elem,elemType) ::= <<
+if (list_<label>==null) list_<label>=new List\<<elemType; null={<labelType>}>\>();
+list_<label>.Add(<elem>);<\n>
+>>
+
+/** match a character */
+charRef(char,label) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+Match(<char>); <checkRuleBacktrackFailure()>
+>>
+
+/** match a character range */
+charRangeRef(a,b,label) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
+>>
+
+/** For now, sets are interval tests and must be tested inline */
+matchSet(s,label,elementIndex,postmatchCode="",terminalOptions={}) ::= <<
+<if(label)>
+<matchSetLabel()>
+<endif>
+if (<s>)
+{
+	input.Consume();
+	<postmatchCode>
+	<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
+}
+else
+{
+	<ruleBacktrackFailure()>
+	MismatchedSetException mse = new MismatchedSetException(null,input);
+	DebugRecognitionException(mse);
+	<@mismatchedSetException()>
+<if(LEXER)>
+	Recover(mse);
+	throw mse;
+<else>
+	throw mse;
+	<! use following code to make it recover inline; remove throw mse;
+	recoverFromMismatchedSet(input,mse,Follow._set_in_<ruleName><elementIndex>);
+	!>
+<endif>
+}<\n>
+>>
+
+matchSetUnchecked(s,label,elementIndex,postmatchCode=false) ::= <%
+<if(label)>
+<matchSetLabel()><\n>
+<endif>
+input.Consume();<\n>
+<if(postmatchCode)>
+<postmatchCode><\n>
+<endif>
+<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
+%>
+
+matchSetLabel() ::= <%
+<if(LEXER)>
+<label>= input.LA(1);
+<else>
+<label>=(<labelType>)input.LT(1);
+<endif>
+%>
+
+matchRuleBlockSet ::= matchSet
+
+matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
+<matchSet(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match a string literal */
+lexerStringRef(string,label,elementIndex) ::= <%
+<if(label)>
+int <label>Start = CharIndex;<\n>
+Match(<string>); <checkRuleBacktrackFailure()><\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+Match(<string>); <checkRuleBacktrackFailure()><\n>
+<endif>
+%>
+
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
+<if(label)>
+<label>=(<labelType>)input.LT(1);<\n>
+<endif>
+MatchAny(input); <checkRuleBacktrackFailure()>
+>>
+
+wildcardAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<wildcard(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match . wildcard in lexer */
+wildcardChar(label, elementIndex) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+MatchAny(); <checkRuleBacktrackFailure()>
+>>
+
+wildcardCharListLabel(label, elementIndex) ::= <<
+<wildcardChar(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match a rule reference by invoking it possibly with arguments
+ *  and a return value or values.  The 'rule' argument was the
+ *  target rule name, but now is type Rule, whose toString is
+ *  same: the rule name.  Now though you can access full rule
+ *  descriptor stuff.
+ */
+ruleRef(rule,label,elementIndex,args,scope) ::= <<
+PushFollow(Follow._<rule.name>_in_<ruleName><elementIndex>);
+<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name; format="id">(<args; separator=", ">);
+PopFollow();
+<checkRuleBacktrackFailure()>
+>>
+
+/** ids+=r */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabelElem(elem=label,elemType={<ASTLabelType>},...)>
+>>
+
+/** A lexer rule reference.
+ *
+ *  The 'rule' argument was the target rule name, but now
+ *  is type Rule, whose toString is same: the rule name.
+ *  Now though you can access full rule descriptor stuff.
+ */
+lexerRuleRef(rule,label,args,elementIndex,scope) ::= <%
+<if(label)>
+int <label>Start<elementIndex> = CharIndex;<\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()><\n>
+<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
+<endif>
+%>
+
+/** i+=INT in lexer */
+lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
+<lexerRuleRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** EOF in the lexer */
+lexerMatchEOF(label,elementIndex) ::= <%
+<if(label)>
+int <label>Start<elementIndex> = CharIndex;<\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+Match(EOF); <checkRuleBacktrackFailure()><\n>
+<labelType> <label> = new <labelType>(input, EOF, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+Match(EOF); <checkRuleBacktrackFailure()>
+<endif>
+%>
+
+// used for left-recursive rules
+recRuleDefArg()                       ::= "int <recRuleArg()>"
+recRuleArg()                          ::= "_p"
+recRuleAltPredicate(ruleName,opPrec)  ::= "<recRuleArg()> \<= <opPrec>"
+recRuleSetResultAction()              ::= "root_0=$<ruleName>_primary.tree;"
+recRuleSetReturnAction(src,name)      ::= "$<name>=$<src>.<name>;"
+
+/** match ^(root children) in tree parser */
+tree(root, actionsAfterRoot, children, nullableChildList,
+     enclosingTreeLevel, treeLevel) ::= <<
+<root:element()>
+<actionsAfterRoot:element()>
+<if(nullableChildList)>
+if (input.LA(1) == TokenTypes.Down)
+{
+	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+	<children:element()>
+	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+}
+<else>
+Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+<children:element()>
+Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+<endif>
+>>
+
+/** Every predicate is used as a validating predicate (even when it is
+ *  also hoisted into a prediction expression).
+ */
+validateSemanticPredicate(pred,description) ::= <<
+if (!(<evalPredicate(...)>))
+{
+	<ruleBacktrackFailure()>
+	throw new FailedPredicateException(input, "<ruleName>", "<description>");
+}
+>>
+
+// F i x e d  D F A  (if-then-else)
+
+dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
+<edges; separator="\nelse ">
+<if((!isTrue.(last(edges).labelExpr)) && (!last(edges).predicates))>
+else
+{
+<if(eotPredictsAlt)>
+	alt<decisionNumber> = <eotPredictsAlt>;
+<else>
+	<ruleBacktrackFailure()>
+	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input, <k>);
+	DebugRecognitionException(nvae);
+	<@noViableAltException()>
+	throw nvae;
+<endif>
+}
+<endif>
+>>
+
+/** Same as a normal DFA state except that we don't examine lookahead
+ *  for the bypass alternative.  It delays error detection but this
+ *  is faster, smaller, and more what people expect.  For (X)? people
+ *  expect "if ( LA(1)==X ) match(X);" and that's it.
+ */
+dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
+<edges; separator="\nelse ">
+>>
+
+/** A DFA state that is actually the loopback decision of a closure
+ *  loop.  If end-of-token (EOT) predicts any of the targets then it
+ *  should act like a default clause (i.e., no error can be generated).
+ *  This is used only in the lexer so that for ('a')* on the end of a rule
+ *  anything other than 'a' predicts exiting.
+ */
+dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
+<edges; separator="\nelse "><\n>
+<if(eotPredictsAlt)>
+<if(!edges)>
+alt<decisionNumber> = <eotPredictsAlt>;<! if no edges, don't gen ELSE !>
+<else>
+else
+{
+	alt<decisionNumber> = <eotPredictsAlt>;
+}<\n>
+<endif>
+<endif>
+>>
+
+/** An accept state indicates a unique alternative has been predicted */
+dfaAcceptState(alt) ::= "alt<decisionNumber> = <alt>;"
+
+/** A simple edge with an expression.  If the expression is satisfied,
+ *  enter to the target state.  To handle gated productions, we may
+ *  have to evaluate some predicates for this edge.
+ */
+dfaEdge(labelExpr, targetState, predicates) ::= <<
+if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>)
+{
+	<targetState>
+}
+>>
+
+// F i x e d  D F A  (switch case)
+
+/** A DFA state where a SWITCH may be generated.  The code generator
+ *  decides if this is possible: CodeGenerator.canGenerateSwitch().
+ */
+dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+default:
+<if(eotPredictsAlt)>
+	alt<decisionNumber>=<eotPredictsAlt>;
+	break;<\n>
+<else>
+	{
+		<ruleBacktrackFailure()>
+		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input, <k>);
+		DebugRecognitionException(nvae);
+		<@noViableAltException()>
+		throw nvae;
+	}
+<endif>
+}<\n>
+>>
+
+dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+}<\n>
+>>
+
+dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+<if(eotPredictsAlt)>
+default:
+	alt<decisionNumber>=<eotPredictsAlt>;
+	break;<\n>
+<endif>
+}<\n>
+>>
+
+dfaEdgeSwitch(labels, targetState) ::= <<
+<labels:{it|case <it>:}; separator="\n">
+	{
+	<targetState>
+	}
+	break;
+>>
+
+// C y c l i c  D F A
+
+/** The code to initiate execution of a cyclic DFA; this is used
+ *  in the rule to predict an alt just like the fixed DFA case.
+ *  The <name> attribute is inherited via the parser, lexer, ...
+ */
+dfaDecision(decisionNumber,description) ::= <<
+try
+{
+	alt<decisionNumber> = dfa<decisionNumber>.Predict(input);
+}
+catch (NoViableAltException nvae)
+{
+	DebugRecognitionException(nvae);
+	throw;
+}
+>>
+
+/* Dump DFA tables as run-length-encoded Strings of octal values.
+ * Can't use hex as compiler translates them before compilation.
+ * These strings are split into multiple, concatenated strings.
+ * Java puts them back together at compile time thankfully.
+ * Java cannot handle large static arrays, so we're stuck with this
+ * encode/decode approach.  See analysis and runtime DFA for
+ * the encoding methods.
+ */
+cyclicDFA(dfa) ::= <<
+private class DFA<dfa.decisionNumber> : DFA
+{
+	private const string DFA<dfa.decisionNumber>_eotS =
+		"<dfa.javaCompressedEOT; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_eofS =
+		"<dfa.javaCompressedEOF; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_minS =
+		"<dfa.javaCompressedMin; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_maxS =
+		"<dfa.javaCompressedMax; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_acceptS =
+		"<dfa.javaCompressedAccept; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_specialS =
+		"<dfa.javaCompressedSpecial; wrap="\"+\n\t\t\"">}>";
+	private static readonly string[] DFA<dfa.decisionNumber>_transitionS =
+		{
+			<dfa.javaCompressedTransition:{s|"<s; wrap="\"+\n\"">"}; separator=",\n">
+		};
+
+	private static readonly short[] DFA<dfa.decisionNumber>_eot = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eotS);
+	private static readonly short[] DFA<dfa.decisionNumber>_eof = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eofS);
+	private static readonly char[] DFA<dfa.decisionNumber>_min = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_minS);
+	private static readonly char[] DFA<dfa.decisionNumber>_max = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_maxS);
+	private static readonly short[] DFA<dfa.decisionNumber>_accept = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_acceptS);
+	private static readonly short[] DFA<dfa.decisionNumber>_special = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_specialS);
+	private static readonly short[][] DFA<dfa.decisionNumber>_transition;
+
+	static DFA<dfa.decisionNumber>()
+	{
+		int numStates = DFA<dfa.decisionNumber>_transitionS.Length;
+		DFA<dfa.decisionNumber>_transition = new short[numStates][];
+		for ( int i=0; i \< numStates; i++ )
+		{
+			DFA<dfa.decisionNumber>_transition[i] = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_transitionS[i]);
+		}
+	}
+
+	public DFA<dfa.decisionNumber>( BaseRecognizer recognizer<if(dfa.specialStateSTs)>, SpecialStateTransitionHandler specialStateTransition<endif> )
+<if(dfa.specialStateSTs)>
+		: base(specialStateTransition)
+<endif>
+	{
+		this.recognizer = recognizer;
+		this.decisionNumber = <dfa.decisionNumber>;
+		this.eot = DFA<dfa.decisionNumber>_eot;
+		this.eof = DFA<dfa.decisionNumber>_eof;
+		this.min = DFA<dfa.decisionNumber>_min;
+		this.max = DFA<dfa.decisionNumber>_max;
+		this.accept = DFA<dfa.decisionNumber>_accept;
+		this.special = DFA<dfa.decisionNumber>_special;
+		this.transition = DFA<dfa.decisionNumber>_transition;
+	}
+
+	public override string Description { get { return "<dfa.description>"; } }
+
+	public override void Error(NoViableAltException nvae)
+	{
+		DebugRecognitionException(nvae);
+	}
+}<\n>
+<if(dfa.specialStateSTs)>
+private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStream _input)<! throws NoViableAltException!>
+{
+	<if(LEXER)>
+	IIntStream input = _input;
+	<endif>
+	<if(PARSER)>
+	ITokenStream input = (ITokenStream)_input;
+	<endif>
+	<if(TREE_PARSER)>
+	ITreeNodeStream input = (ITreeNodeStream)_input;
+	<endif>
+	int _s = s;
+	s = -1;
+	<! pull these outside the switch cases to save space on locals !>
+	int LA<dfa.decisionNumber>_1 = input.LA(1);
+	int index<dfa.decisionNumber>_1 = input.Index;
+	switch (_s)
+	{
+	<dfa.specialStateSTs:{state |case <i0>:<! compressed special state numbers 0..n-1 !>
+	<state>}; separator="\n">
+
+	default:
+		break;
+	}
+
+	if (s >= 0)
+		return s;
+
+<if(backtracking)>
+	if (state.backtracking > 0) {state.failed=true; return -1;}
+<endif>
+	NoViableAltException nvae = new NoViableAltException(dfa.Description, <dfa.decisionNumber>, _s, input);
+	dfa.Error(nvae);
+	throw nvae;
+}
+<endif>
+>>
+
+/** A state in a cyclic DFA; it's a special state and part of a big switch on
+ *  state.
+ */
+cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
+{
+<if(semPredState)>
+	<! get next lookahead symbol to test edges, then rewind !>
+	input.Rewind();
+<endif>
+	<edges; separator="\nelse ">
+<if(semPredState)>
+	<! return input cursor to state before we rewound !>
+	input.Seek(index<decisionNumber>_1);
+<endif>
+	break;
+}
+>>
+
+/** Just like a fixed DFA edge, test the lookahead and indicate what
+ *  state to jump to next if successful.
+ */
+cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
+if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
+>>
+
+/** An edge pointing at end-of-token; essentially matches any char;
+ *  always jump to the target.
+ */
+eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
+s = <targetStateNumber>;<\n>
+>>
+
+
+// D F A  E X P R E S S I O N S
+
+andPredicates(left,right) ::= "(<left>&&<right>)"
+
+orPredicates(operands) ::= "(<operands; separator=\"||\">)"
+
+notPredicate(pred) ::= "!(<evalPredicate(...)>)"
+
+evalPredicate(pred,description) ::= "(<pred>)"
+
+evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"
+
+lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<k>==<atom>"
+
+/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
+ *  somewhere.  Must ask for the lookahead directly.
+ */
+isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"
+
+lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
+(LA<decisionNumber>_<k><ge()><lower> && LA<decisionNumber>_<k><le()><upper>)
+%>
+
+isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"
+
+le() ::= "\<="
+ge() ::= ">="
+
+setTest(ranges) ::= <<
+<ranges; separator="||">
+>>
+
+// A T T R I B U T E S
+
+attributeScope(scope) ::= <<
+<if(scope)>
+<if(scope.attributes)>
+protected sealed partial class <scope.name>_scope
+{
+	<scope.attributes:{it|public <it.decl>;}; separator="\n">
+}
+<if(scope.actions.scopeinit)>
+protected void <scope.name>_scopeInit( <scope.name>_scope scope )
+{
+	<scope.actions.scopeinit>
+}
+<else>
+protected virtual void <scope.name>_scopeInit( <scope.name>_scope scope ) {}
+<endif>
+<if(scope.actions.scopeafter)>
+protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
+{
+	<scope.actions.scopeafter>
+}
+<else>
+protected virtual void <scope.name>_scopeAfter( <scope.name>_scope scope ) {}
+<endif>
+protected readonly ListStack\<<scope.name>_scope> <scope.name>_stack = new ListStack\<<scope.name>_scope>();
+<endif>
+<endif>
+>>
+
+globalAttributeScope(scope) ::= <<
+<attributeScope(...)>
+>>
+
+ruleAttributeScope(scope) ::= <<
+<attributeScope(...)>
+>>
+
+returnStructName(it) ::= "<it.name>_return"
+
+returnType(ruleDescriptor) ::= <%
+<if(ruleDescriptor.returnScope.attributes && ruleDescriptor.hasMultipleReturnValues)>
+	<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
+<elseif(ruleDescriptor.hasMultipleReturnValues)>
+	<ruleReturnBaseType()>
+<elseif(ruleDescriptor.hasSingleReturnValue)>
+	<ruleDescriptor.singleValueReturnType>
+<else>
+	void
+<endif>
+%>
+
+/** Generate the C# type associated with a single or multiple return
+ *  values.
+ */
+ruleLabelType(referencedRule) ::= <%
+<if(referencedRule.hasMultipleReturnValues)>
+	<ruleReturnBaseType()>
+<elseif(referencedRule.hasSingleReturnValue)>
+	<referencedRule.singleValueReturnType>
+<else>
+	void
+<endif>
+%>
+
+delegateName(it) ::= <<
+<if(it.label)><it.label><else>g<it.name><endif>
+>>
+
+/** Using a type to init value map, try to init a type; if not in table
+ *  must be an object, default value is "null".
+ */
+initValue(typeName) ::= <<
+default(<typeName>)
+>>
+
+/** Define a rule label including default value */
+ruleLabelDef(label) ::= <%
+<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> = <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;
+%>
+
+/** Define a return struct for a rule if the code needs to access its
+ *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
+ *  subgroups to stick in members.
+ */
+returnScope(scope) ::= <<
+<if(scope.attributes && ruleDescriptor.hasMultipleReturnValues)>
+<returnScopeModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> sealed partial class <ruleDescriptor:returnStructName()> : <ruleReturnBaseType()><@ruleReturnInterfaces()>
+{
+	<scope.attributes:{it|public <it.decl>;}; separator="\n">
+	<@ruleReturnMembers()>
+}
+<endif>
+>>
+
+ruleReturnBaseType() ::= <%
+<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>>
+%>
+
+@returnScope.ruleReturnMembers() ::= <<
+>>
+
+parameterScope(scope) ::= <<
+<scope.attributes:{it|<it.decl>}; separator=", ">
+>>
+
+parameterAttributeRef(attr) ::= <<
+<attr.name; format="id">
+>>
+
+parameterSetAttributeRef(attr,expr) ::= <<
+<attr.name; format="id"> =<expr>;
+>>
+
+scopeAttributeRef(scope,attr,index,negIndex) ::= <%
+<if(negIndex)>
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id">
+<else>
+<if(index)>
+<scope>_stack[<index>].<attr.name; format="id">
+<else>
+<scope>_stack.Peek().<attr.name; format="id">
+<endif>
+<endif>
+%>
+
+scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
+<if(negIndex)>
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id"> = <expr>;
+<else>
+<if(index)>
+<scope>_stack[<index>].<attr.name; format="id"> = <expr>;
+<else>
+<scope>_stack.Peek().<attr.name; format="id"> = <expr>;
+<endif>
+<endif>
+%>
+
+/** $x is either global scope or x is rule with dynamic scope; refers
+ *  to stack itself not top of stack.  This is useful for predicates
+ *  like {$function.Count>0 && $function::name.Equals("foo")}?
+ */
+isolatedDynamicScopeRef(scope) ::= "<scope>_stack"
+
+/** reference an attribute of rule; might only have single return value */
+ruleLabelRef(referencedRule,scope,attr) ::= <%
+<if(referencedRule.hasMultipleReturnValues)>
+(<scope>!=null?((<returnType(referencedRule)>)<scope>).<attr.name; format="id">:<initValue(attr.type)>)
+<else>
+<scope>
+<endif>
+%>
+
+returnAttributeRef(ruleDescriptor,attr) ::= <%
+<if(ruleDescriptor.hasMultipleReturnValues)>
+retval.<attr.name; format="id">
+<else>
+<attr.name; format="id">
+<endif>
+%>
+
+returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
+<if(ruleDescriptor.hasMultipleReturnValues)>
+retval.<attr.name; format="id"> =<expr>;
+<else>
+<attr.name; format="id"> =<expr>;
+<endif>
+%>
+
+/** How to translate $tokenLabel */
+tokenLabelRef(label) ::= "<label>"
+
+/** ids+=ID {$ids} or e+=expr {$e} */
+listLabelRef(label) ::= "list_<label>"
+
+
+// not sure the next are the right approach
+
+tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:default(string))"
+tokenLabelPropertyRef_type(scope,attr) ::= "(<scope>!=null?<scope>.Type:0)"
+tokenLabelPropertyRef_line(scope,attr) ::= "(<scope>!=null?<scope>.Line:0)"
+tokenLabelPropertyRef_pos(scope,attr) ::= "(<scope>!=null?<scope>.CharPositionInLine:0)"
+tokenLabelPropertyRef_channel(scope,attr) ::= "(<scope>!=null?<scope>.Channel:0)"
+tokenLabelPropertyRef_index(scope,attr) ::= "(<scope>!=null?<scope>.TokenIndex:0)"
+tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
+tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?int.Parse(<scope>.Text):0)"
+
+ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):default(<labelType>))"
+ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):default(<labelType>))"
+ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):default(<ASTLabelType>))"
+ruleLabelPropertyRef_text(scope,attr) ::= <%
+<if(TREE_PARSER)>
+(<scope>!=null?(input.TokenStream.ToString(
+  input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
+  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):default(string))
+<else>
+(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):default(string))
+<endif>
+%>
+
+ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?<scope>.Template:null)"
+
+/** Isolated $RULE ref ok in lexer as it's a Token */
+lexerRuleLabel(label) ::= "<label>"
+
+lexerRuleLabelPropertyRef_type(scope,attr) ::=
+    "(<scope>!=null?<scope>.Type:0)"
+
+lexerRuleLabelPropertyRef_line(scope,attr) ::=
+    "(<scope>!=null?<scope>.Line:0)"
+
+lexerRuleLabelPropertyRef_pos(scope,attr) ::=
+    "(<scope>!=null?<scope>.CharPositionInLine:-1)"
+
+lexerRuleLabelPropertyRef_channel(scope,attr) ::=
+    "(<scope>!=null?<scope>.Channel:0)"
+
+lexerRuleLabelPropertyRef_index(scope,attr) ::=
+    "(<scope>!=null?<scope>.TokenIndex:0)"
+
+lexerRuleLabelPropertyRef_text(scope,attr) ::=
+    "(<scope>!=null?<scope>.Text:default(string))"
+
+lexerRuleLabelPropertyRef_int(scope,attr) ::=
+    "(<scope>!=null?int.Parse(<scope>.Text):0)"
+
+// Somebody may ref $template or $tree or $stop within a rule:
+rulePropertyRef_start(scope,attr) ::= "retval.Start"
+rulePropertyRef_stop(scope,attr) ::= "retval.Stop"
+rulePropertyRef_tree(scope,attr) ::= "retval.Tree"
+rulePropertyRef_text(scope,attr) ::= <%
+<if(TREE_PARSER)>
+input.TokenStream.ToString(
+  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
+  input.TreeAdaptor.GetTokenStopIndex(retval.Start))
+<else>
+input.ToString(retval.Start,input.LT(-1))
+<endif>
+%>
+rulePropertyRef_st(scope,attr) ::= "retval.Template"
+
+lexerRulePropertyRef_text(scope,attr) ::= "Text"
+lexerRulePropertyRef_type(scope,attr) ::= "_type"
+lexerRulePropertyRef_line(scope,attr) ::= "state.tokenStartLine"
+lexerRulePropertyRef_pos(scope,attr) ::= "state.tokenStartCharPositionInLine"
+lexerRulePropertyRef_index(scope,attr) ::= "-1" // undefined token index in lexer
+lexerRulePropertyRef_channel(scope,attr) ::= "_channel"
+lexerRulePropertyRef_start(scope,attr) ::= "state.tokenStartCharIndex"
+lexerRulePropertyRef_stop(scope,attr) ::= "(CharIndex-1)"
+lexerRulePropertyRef_int(scope,attr) ::= "int.Parse(<scope>.Text)"
+
+// setting $st and $tree is allowed in local rule. everything else
+// is flagged as error
+ruleSetPropertyRef_tree(scope,attr,expr) ::= "retval.Tree = <expr>;"
+ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.Template =<expr>;"
+
+/** How to execute an action (only when not backtracking) */
+execAction(action) ::= <%
+<if(backtracking)>
+if (<actions.(actionScope).synpredgate>)<\n>
+{<\n>
+<@indentedAction()><\n>
+}
+<else>
+<action>
+<endif>
+%>
+
+@execAction.indentedAction() ::= <<
+	<action>
+>>
+
+/** How to always execute an action even when backtracking */
+execForcedAction(action) ::= "<action>"
+
+// M I S C (properties, etc...)
+
+bitset(name, words64) ::= <<
+public static readonly BitSet <name> = new BitSet(new ulong[]{<words64:{it|<it>UL};separator=",">});
+>>
+
+codeFileExtension() ::= ".cs"
+
+true_value() ::= "true"
+false_value() ::= "false"
+
+isTrue ::= [
+	"true" : true,
+	default : false
+]
diff --git a/build/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg b/build/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
new file mode 100644
index 0000000..b537ff1
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
@@ -0,0 +1,313 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/** Template overrides to add debugging to normal Java output;
+ *  If ASTs are built, then you'll also get ASTDbg.stg loaded.
+ */
+
+@outputFile.debugPreprocessor() ::= "#define ANTLR_DEBUG"
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+using Antlr.Runtime.Debug;
+using IOException = System.IO.IOException;
+>>
+
+@genericParser.members() ::= <<
+<if(grammar.grammarIsRoot)>
+public static readonly string[] ruleNames =
+	new string[]
+	{
+		"invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n	", separator=", ">
+	};<\n>
+<endif>
+<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
+int ruleLevel = 0;
+public virtual int RuleLevel { get { return ruleLevel; } }
+public virtual void IncRuleLevel() { ruleLevel++; }
+public virtual void DecRuleLevel() { ruleLevel--; }
+<if(profile)>
+<ctorForProfilingRootGrammar()>
+<else>
+<ctorForRootGrammar()>
+<endif>
+<ctorForPredefinedListener()>
+<else><! imported grammar !>
+public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
+public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
+public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
+<ctorForDelegateGrammar()>
+<endif>
+<if(profile)>
+public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
+{
+	int stopIndex = GetRuleMemoization(ruleIndex, input.Index);
+	((Profiler)dbg).ExamineRuleMemoization(input, ruleIndex, stopIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	return base.AlreadyParsedRule(input, ruleIndex);
+}<\n>
+public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
+{
+	((Profiler)dbg).Memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	base.Memoize(input, ruleIndex, ruleStartIndex);
+}<\n>
+<endif>
+protected virtual bool EvalPredicate( bool result, string predicate )
+{
+	dbg.SemanticPredicate( result, predicate );
+	return result;
+}<\n>
+>>
+
+ctorForRootGrammar() ::= <<
+<! bug: can't use <@super.members()> cut-n-paste instead !>
+<! Same except we add port number and profile stuff if root grammar !>
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
+	: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
+	: base( input, state )
+{
+	<createListenerAndHandshake()>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
+	<@finally()>
+}<\n>
+>>
+
+ctorForProfilingRootGrammar() ::= <<
+<! bug: can't use <@super.members()> cut-n-paste instead !>
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
+	: this( input, new Profiler(null), new RecognizerSharedState() )
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
+	: base( input, dbg, state )
+{
+	Profiler p = (Profiler)dbg;
+	p.setParser(this);
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
+	<@finally()>
+}
+<\n>
+>>
+
+/** Basically we don't want to set any dbg listeners are root will have it. */
+ctorForDelegateGrammar() ::= <<
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+	: base( input, dbg, state )
+{
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>( input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
+}<\n>
+>>
+
+ctorForPredefinedListener() ::= <<
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg )
+	<@superClassRef>: base( input, dbg, new RecognizerSharedState() )<@end>
+{
+<if(profile)>
+	Profiler p = (Profiler)dbg;
+	p.setParser(this);
+<endif>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	<parserCtorBody()>
+	<@finally()>
+}<\n>
+>>
+
+createListenerAndHandshake() ::= <<
+<if(TREE_PARSER)>
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, input.TreeAdaptor );<\n>
+<else>
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, null );<\n>
+<endif>
+DebugListener = proxy;
+try
+{
+	proxy.Handshake();
+}
+catch ( IOException ioe )
+{
+	ReportError( ioe );
+}
+>>
+
+@genericParser.superClassName() ::= "Debug<@super.superClassName()>"
+
+/*
+ * Many of the following rules were merged into CSharp2.stg.
+ */
+
+@rule.preamble() ::= <<
+if (RuleLevel == 0)
+	DebugListener.Commence();
+IncRuleLevel();
+>>
+//@rule.preamble() ::= <<
+//try
+//{
+//	dbg.EnterRule( GrammarFileName, "<ruleName>" );
+//	if ( RuleLevel == 0 )
+//	{
+//		dbg.Commence();
+//	}
+//	IncRuleLevel();
+//	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
+//>>
+
+@rule.postamble() ::= <<
+DecRuleLevel();
+if (RuleLevel == 0)
+	DebugListener.Terminate();
+>>
+//@rule.postamble() ::= <<
+//dbg.Location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
+//}
+//finally
+//{
+//	dbg.ExitRule( GrammarFileName, "<ruleName>" );
+//	DecRuleLevel();
+//	if ( RuleLevel == 0 )
+//	{
+//		dbg.Terminate();
+//	}
+//}<\n>
+//>>
+
+//@insertSynpreds.start() ::= "dbg.BeginBacktrack( state.backtracking );"
+//@insertSynpreds.stop() ::= "dbg.EndBacktrack( state.backtracking, success );"
+
+// Common debug event triggers used by region overrides below
+
+//enterSubRule() ::= <<
+//try
+//{
+//	dbg.EnterSubRule( <decisionNumber> );<\n>
+//>>
+
+//exitSubRule() ::= <<
+//}
+//finally
+//{
+//	dbg.ExitSubRule( <decisionNumber> );
+//}<\n>
+//>>
+
+//enterDecision() ::= <<
+//try
+//{
+//	dbg.EnterDecision( <decisionNumber> );<\n>
+//>>
+
+//exitDecision() ::= <<
+//}
+//finally
+//{
+//	dbg.ExitDecision( <decisionNumber> );
+//}<\n>
+//>>
+
+//enterAlt(n) ::= "dbg.EnterAlt( <n> );<\n>"
+
+// Region overrides that tell various constructs to add debugging triggers
+
+//@block.predecision() ::= "<enterSubRule()><enterDecision()>"
+
+//@block.postdecision() ::= "<exitDecision()>"
+
+//@block.postbranch() ::= "<exitSubRule()>"
+
+//@ruleBlock.predecision() ::= "<enterDecision()>"
+
+//@ruleBlock.postdecision() ::= "<exitDecision()>"
+
+//@ruleBlockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
+
+//@blockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
+
+//@positiveClosureBlock.preloop() ::= "<enterSubRule()>"
+
+//@positiveClosureBlock.postloop() ::= "<exitSubRule()>"
+
+//@positiveClosureBlock.predecision() ::= "<enterDecision()>"
+
+//@positiveClosureBlock.postdecision() ::= "<exitDecision()>"
+
+//@positiveClosureBlock.earlyExitException() ::=
+//	"dbg.RecognitionException( eee<decisionNumber> );<\n>"
+
+//@closureBlock.preloop() ::= "<enterSubRule()>"
+
+//@closureBlock.postloop() ::= "<exitSubRule()>"
+
+//@closureBlock.predecision() ::= "<enterDecision()>"
+
+//@closureBlock.postdecision() ::= "<exitDecision()>"
+
+//@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"
+
+//@element.prematch() ::=
+//	"dbg.Location( <it.line>, <it.pos> );"
+
+//@matchSet.mismatchedSetException() ::=
+//	"dbg.RecognitionException( mse );"
+
+//@dfaState.noViableAltException() ::= "dbg.RecognitionException( nvae );"
+
+//@dfaStateSwitch.noViableAltException() ::= "dbg.RecognitionException( nvae );"
+
+//dfaDecision(decisionNumber,description) ::= <<
+//try
+//{
+//	isCyclicDecision = true;
+//	<super.dfaDecision(...)>
+//}
+//catch ( NoViableAltException nvae )
+//{
+//	dbg.RecognitionException( nvae );
+//	throw nvae;
+//}
+//>>
+
+//@cyclicDFA.errorMethod() ::= <<
+//public override void Error( NoViableAltException nvae )
+//{
+//	((DebugParser)recognizer).dbg.RecognitionException( nvae );
+//}
+//>>
+
+/** Force predicate validation to trigger an event */
+evalPredicate(pred,description) ::= <<
+EvalPredicate(<pred>, "<description>")
+>>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp2/ST.stg b/build/Bootstrap/Codegen/Templates/CSharp2/ST.stg
new file mode 100644
index 0000000..d6dd973
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp2/ST.stg
@@ -0,0 +1,171 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/** Template subgroup to add template rewrite output
+ *  If debugging, then you'll also get STDbg.stg loaded.
+ */
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+using Antlr.StringTemplate;
+using Antlr.StringTemplate.Language;
+<if(!backtracking)>
+using Hashtable = System.Collections.Hashtable;
+<endif>
+
+>>
+
+/** Add this to each rule's return value struct */
+@returnScope.ruleReturnMembers() ::= <<
+private StringTemplate _st;
+public StringTemplate Template { get { return _st; } set { _st = value; } }
+public override string ToString() { return (Template==null) ? string.Empty : Template.ToString(); }
+>>
+
+@genericParser.members() ::= <<
+<@super.members()>
+protected StringTemplateGroup templateLib = new StringTemplateGroup("<name>Templates", typeof(AngleBracketTemplateLexer) );
+
+public StringTemplateGroup TemplateLib
+{
+ 	get { return this.templateLib; }
+ 	set { this.templateLib = value; }
+}
+
+/// \<summary> Allows convenient multi-value initialization:
+///  "new STAttrMap().Add(...).Add(...)"
+/// \</summary>
+protected class STAttrMap : Hashtable
+{
+  public STAttrMap Add(string attrName, object value)
+  {
+    base.Add(attrName, value);
+    return this;
+  }
+  public STAttrMap Add(string attrName, int value)
+  {
+    base.Add(attrName, value);
+    return this;
+  }
+}
+>>
+
+/** x+=rule when output=template */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabel(elem=label+".Template",...)>
+>>
+
+rewriteTemplate(alts) ::= <<
+
+// TEMPLATE REWRITE
+<if(backtracking)>
+if ( <actions.(actionScope).synpredgate> )
+{
+  <alts:rewriteTemplateAlt(); separator="else ">
+  <if(rewriteMode)><replaceTextInLine()><endif>
+}
+<else>
+<alts:rewriteTemplateAlt(); separator="else ">
+<if(rewriteMode)><replaceTextInLine()><endif>
+<endif>
+>>
+
+replaceTextInLine() ::= <<
+<if(TREE_PARSER)>
+((TokenRewriteStream)input.TokenStream).Replace(
+  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
+  input.TreeAdaptor.GetTokenStopIndex(retval.Start),
+  retval.Template);
+<else>
+((TokenRewriteStream)input).Replace(
+  ((IToken)retval.Start).TokenIndex,
+  input.LT(-1).TokenIndex,
+  retval.Template);
+<endif>
+>>
+
+rewriteTemplateAlt() ::= <<
+// <it.description>
+<if(it.pred)>
+if (<it.pred>) {
+    retval.Template = <it.alt>;
+}<\n>
+<else>
+{
+    retval.Template = <it.alt>;
+}<\n>
+<endif>
+>>
+
+rewriteEmptyTemplate(alts) ::= <<
+null;
+>>
+
+/** Invoke a template with a set of attribute name/value pairs.
+ *  Set the value of the rule's template *after* having set
+ *  the attributes because the rule's template might be used as
+ *  an attribute to build a bigger template; you get a self-embedded
+ *  template.
+ */
+rewriteExternalTemplate(name,args) ::= <<
+templateLib.GetInstanceOf("<name>"<if(args)>,
+  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
+  <endif>)
+>>
+
+/** expr is a string expression that says what template to load */
+rewriteIndirectTemplate(expr,args) ::= <<
+templateLib.GetInstanceOf(<expr><if(args)>,
+  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
+  <endif>)
+>>
+
+/** Invoke an inline template with a set of attribute name/value pairs */
+rewriteInlineTemplate(args, template) ::= <<
+new StringTemplate(templateLib, "<template>"<if(args)>,
+  new STAttrMap()<args:{a | .Add("<a.name>", <a.value>)}>
+  <endif>)
+>>
+
+/** plain -> {foo} action */
+rewriteAction(action) ::= <<
+<action>
+>>
+
+/** An action has %st.attrName=expr; or %{st}.attrName=expr; */
+actionSetAttribute(st,attrName,expr) ::= <<
+(<st>).SetAttribute("<attrName>",<expr>);
+>>
+
+/** Translate %{stringExpr} */
+actionStringConstructor(stringExpr) ::= <<
+new StringTemplate(templateLib,<stringExpr>)
+>>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/build/Bootstrap/Codegen/Templates/CSharp3/AST.stg
new file mode 100644
index 0000000..d1d765a
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp3/AST.stg
@@ -0,0 +1,428 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+
+<if(!TREE_PARSER)>
+<! tree parser would already have imported !>
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
+<endif>
+>>
+
+@genericParser.members() ::= <<
+<@super.members()>
+<parserMembers()>
+>>
+
+parserCtorBody() ::= <<
+<super.parserCtorBody()>
+<treeAdaptorType()> treeAdaptor = default(<treeAdaptorType()>);
+CreateTreeAdaptor(ref treeAdaptor);
+TreeAdaptor = treeAdaptor<if(!actions.(actionScope).treeAdaptorType)> ?? new CommonTreeAdaptor()<endif>;
+>>
+
+/** Add an adaptor property that knows how to build trees */
+parserMembers() ::= <<
+// Implement this function in your helper file to use a custom tree adaptor
+partial void CreateTreeAdaptor(ref <treeAdaptorType()> adaptor);
+
+private <treeAdaptorType()> adaptor;
+
+public <treeAdaptorType()> TreeAdaptor
+{
+	get
+	{
+		return adaptor;
+	}
+
+	set
+	{
+		this.adaptor = value;
+		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+	}
+}
+>>
+
+treeAdaptorType() ::= <<
+<actions.(actionScope).treeAdaptorType; null="ITreeAdaptor">
+>>
+
+ruleReturnBaseType() ::= <%
+Ast<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<ASTLabelType>, <labelType>>
+%>
+
+/** Add a variable to track rule's return AST */
+ruleDeclarations() ::= <<
+<super.ruleDeclarations()>
+<ASTLabelType> root_0 = default(<ASTLabelType>);<\n>
+>>
+
+ruleLabelDefs(ruleDescriptor, labelType, ASTLabelType, rewriteElementType) ::= <%
+<super.ruleLabelDefs(...)>
+<if(!ruleDescriptor.isSynPred)>
+<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
+	:{it|<\n><ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}>
+<ruleDescriptor.tokenListLabels:{it|<\n><ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}>
+<ruleDescriptor.allTokenRefsInAltsWithRewrites
+	:{it|<\n>RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}>
+<ruleDescriptor.allRuleRefsInAltsWithRewrites
+	:{it|<\n>RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}>
+<endif>
+%>
+
+/** When doing auto AST construction, we must define some variables;
+ *  These should be turned off if doing rewrites.  This must be a "mode"
+ *  as a rule could have both rewrite and AST within the same alternative
+ *  block.
+ */
+@alt.declarations() ::= <<
+<if(autoAST && outerAlt && !rewriteMode && !ruleDescriptor.isSynPred)>
+root_0 = (<ASTLabelType>)adaptor.Nil();
+<endif>
+>>
+
+// T r a c k i n g  R u l e  E l e m e n t s
+
+/** ID and track it for use in a rewrite rule */
+tokenRefTrack(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefBang(...)> <! Track implies no auto AST construction!>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
+>>
+
+/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
+ *  to the tracking list stream_ID for use in the rewrite.
+ */
+tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefTrack(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** ^(ID ...) track for rewrite */
+tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefBang(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
+>>
+
+/** Match ^(label+=TOKEN ...) track for rewrite */
+tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefRuleRootTrack(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** rule when output=AST and tracking for rewrite */
+ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule.name>.Add(<label>.Tree);
+>>
+
+/** x+=rule when output=AST and tracking for rewrite */
+ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefTrack(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** ^(rule ...) rewrite */
+ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRoot(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule>.Add(<label>.Tree);
+>>
+
+/** ^(x+=rule ...) rewrite */
+ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRootTrack(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+// R e w r i t e
+
+rewriteCode(
+	alts, description,
+	referencedElementsDeep, // ALL referenced elements to right of ->
+	referencedTokenLabels,
+	referencedTokenListLabels,
+	referencedRuleLabels,
+	referencedRuleListLabels,
+	referencedWildcardLabels,
+	referencedWildcardListLabels,
+	rewriteBlockLevel, enclosingTreeLevel, treeLevel) ::= <<
+<\n>{
+// AST REWRITE
+// elements: <referencedElementsDeep; separator=", ">
+// token labels: <referencedTokenLabels; separator=", ">
+// rule labels: <referencedRuleLabels; separator=", ">
+// token list labels: <referencedTokenListLabels; separator=", ">
+// rule list labels: <referencedRuleListLabels; separator=", ">
+// wildcard labels: <[referencedWildcardLabels,referencedWildcardListLabels]; separator=", ">
+<if(backtracking)>
+if (<actions.(actionScope).synpredgate>) {
+<endif>
+<prevRuleRootRef()>.Tree = root_0;
+<rewriteCodeLabels()>
+root_0 = (<ASTLabelType>)adaptor.Nil();
+<alts:rewriteAlt(); separator="else ">
+<! if tree parser and rewrite=true !>
+<if(TREE_PARSER&&rewriteMode)>
+<prevRuleRootRef()>.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+if (<prevRuleRootRef()>.Tree != null)
+	input.ReplaceChildren(adaptor.GetParent(retval.Start), adaptor.GetChildIndex(retval.Start), adaptor.GetChildIndex(_last), retval.Tree);
+<endif>
+<! if parser or tree-parser && rewrite!=true, we need to set result !>
+<if(!TREE_PARSER||!rewriteMode)>
+<prevRuleRootRef()>.Tree = root_0;
+<endif>
+<if(backtracking)>
+}
+<endif>
+}
+
+>>
+
+rewriteCodeLabels() ::= <<
+<referencedTokenLabels
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
+	separator="\n"
+>
+<referencedTokenListLabels
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
+	separator="\n"
+>
+<referencedWildcardLabels
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
+	separator="\n"
+>
+<referencedWildcardListLabels
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
+	separator="\n"
+>
+<referencedRuleLabels
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
+	separator="\n"
+>
+<referencedRuleListLabels
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
+	separator="\n"
+>
+>>
+
+/** Generate code for an optional rewrite block; note it uses the deep ref'd element
+  *  list rather shallow like other blocks.
+  */
+rewriteOptionalBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+// <fileName>:<description>
+if (<referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||">)
+{
+	<alt>
+}
+<referencedElementsDeep:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewriteClosureBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+// <fileName>:<description>
+while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
+{
+	<alt>
+}
+<referencedElements:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewritePositiveClosureBlock(
+	alt,rewriteBlockLevel,
+	referencedElementsDeep, // all nested refs
+	referencedElements, // elements in immediately block; no nested blocks
+	description) ::=
+<<
+if (!(<referencedElements:{el | stream_<el>.HasNext}; separator="||">))
+{
+	throw new RewriteEarlyExitException();
+}
+while ( <referencedElements:{el | stream_<el>.HasNext}; separator="||"> )
+{
+	<alt>
+}
+<referencedElements:{el | stream_<el>.Reset();<\n>}>
+>>
+
+rewriteAlt(a) ::= <<
+// <a.description>
+<if(a.pred)>
+if (<a.pred>)
+{
+	<a.alt>
+}
+<else>
+{
+	<a.alt>
+}
+<endif>
+>>
+
+/** For empty rewrites: "r : ... -> ;" */
+rewriteEmptyAlt() ::= "root_0 = null;"
+
+rewriteTree(root,children,description,enclosingTreeLevel,treeLevel) ::= <<
+// <fileName>:<description>
+{
+<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
+<root:rewriteElement()>
+<children:rewriteElement()>
+adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
+}<\n>
+>>
+
+rewriteElementList(elements) ::= "<elements:rewriteElement()>"
+
+rewriteElement(e) ::= <%
+<@pregen()>
+DebugLocation(<e.line>, <e.pos>);<\n>
+<e.el>
+%>
+
+/** Gen ID or ID[args] */
+rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
+adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
+>>
+
+/** Gen $label ... where defined via label=ID */
+rewriteTokenLabelRef(label,elementIndex) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
+>>
+
+/** Gen $label ... where defined via label+=ID */
+rewriteTokenListLabelRef(label,elementIndex) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextNode());<\n>
+>>
+
+/** Gen ^($label ...) */
+rewriteTokenLabelRefRoot(label,elementIndex) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+/** Gen ^($label ...) where label+=... */
+rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot
+
+/** Gen ^(ID ...) or ^(ID[args] ...) */
+rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
+>>
+
+rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
+adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
+>>
+
+rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
+>>
+
+/** plain -> {foo} action */
+rewriteAction(action) ::= <<
+root_0 = <action>;<\n>
+>>
+
+/** What is the name of the previous value of this rule's root tree?  This
+ *  let's us refer to $rule to mean previous value.  I am reusing the
+ *  variable 'tree' sitting in retval struct to hold the value of root_0 right
+ *  before I set it during rewrites.  The assign will be to retval.tree.
+ */
+prevRuleRootRef() ::= "retval"
+
+rewriteRuleRef(rule) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<rule>.NextTree());<\n>
+>>
+
+rewriteRuleRefRoot(rule) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<rule>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+rewriteNodeAction(action) ::= <<
+adaptor.AddChild(root_<treeLevel>, <action>);<\n>
+>>
+
+rewriteNodeActionRoot(action) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<action>, root_<treeLevel>);<\n>
+>>
+
+/** Gen $ruleLabel ... where defined via ruleLabel=rule */
+rewriteRuleLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+/** Gen $ruleLabel ... where defined via ruleLabel+=rule */
+rewriteRuleListLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+/** Gen ^($ruleLabel ...) where ruleLabel=rule */
+rewriteRuleLabelRefRoot(label) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+/** Gen ^($ruleLabel ...) where ruleLabel+=rule */
+rewriteRuleListLabelRefRoot(label) ::= <<
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(), root_<treeLevel>);<\n>
+>>
+
+rewriteWildcardLabelRef(label) ::= <<
+adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
+>>
+
+createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
+<if(terminalOptions.node)>
+<! new MethodNode(IDLabel, args) !>
+new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
+<else>
+(<ASTLabelType>)adaptor.Create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
+<endif>
+%>
+
+createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
+<else>
+<if(args)> <! must create new node from old !>
+adaptor.Create(<token>, <args; separator=", ">)
+<else>
+stream_<token>.NextNode()
+<endif>
+<endif>
+%>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg b/build/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
new file mode 100644
index 0000000..b4b245a
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
@@ -0,0 +1,98 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Template overrides to add debugging to AST stuff.  Dynamic inheritance
+ *  hierarchy is set up as ASTDbg : AST : Dbg : Java by code generator.
+ */
+
+parserMembers() ::= <<
+	// Implement this function in your helper file to use a custom tree adaptor
+	partial void InitializeTreeAdaptor();
+	protected DebugTreeAdaptor adaptor;
+
+	public ITreeAdaptor TreeAdaptor
+	{
+		get
+		{
+			return adaptor;
+		}
+		set
+		{
+<if(grammar.grammarIsRoot)>
+			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
+<else>
+			this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+<endif><\n>
+			<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+		}
+	}<\n>
+>>
+
+parserCtorBody() ::= <<
+<super.parserCtorBody()>
+>>
+
+createListenerAndHandshake() ::= <<
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, <if(TREE_PARSER)>input.TreeAdaptor<else>adaptor<endif> );
+DebugListener = proxy;
+<inputStreamType> = new Debug<inputStreamType>( input, proxy );
+try
+{
+	proxy.Handshake();
+}
+catch ( IOException ioe )
+{
+	ReportError( ioe );
+}
+>>
+
+@ctorForRootGrammar.finally() ::= <<
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;
+proxy.TreeAdaptor = adap;
+>>
+
+@ctorForProfilingRootGrammar.finally() ::=<<
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;
+>>
+
+@ctorForPredefinedListener.superClassRef() ::= ": base( input, dbg )"
+
+@ctorForPredefinedListener.finally() ::=<<
+<if(grammar.grammarIsRoot)><! don't create new adaptor for delegates !>
+ITreeAdaptor adap = new CommonTreeAdaptor();
+TreeAdaptor = adap;<\n>
+<endif>
+>>
+
+//@rewriteElement.pregen() ::= "dbg.Location( <e.line>, <e.pos> );"
diff --git a/build/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg b/build/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
new file mode 100644
index 0000000..b97d44b
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
@@ -0,0 +1,203 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Templates for building ASTs during normal parsing.
+ *
+ *  Deal with many combinations.  Dimensions are:
+ *  Auto build or rewrite
+ *    no label, label, list label  (label/no-label handled together)
+ *    child, root
+ *    token, set, rule, wildcard
+ *
+ *  The situation is not too bad as rewrite (->) usage makes ^ and !
+ *  invalid. There is no huge explosion of combinations.
+ */
+
+@rule.setErrorReturnValue() ::= <<
+retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
+<! System.out.WriteLine("<ruleName> returns "+((CommonTree)retval.tree).toStringTree()); !>
+>>
+
+// TOKEN AST STUFF
+
+/** ID and output=AST */
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <%
+<super.tokenRef(...)>
+<if(!ruleDescriptor.isSynPred)>
+<if(backtracking)><\n>if (state.backtracking == 0) {<endif>
+<\n><label>_tree = <createNodeFromToken(...)>;
+<\n>adaptor.AddChild(root_0, <label>_tree);
+<if(backtracking)><\n>}<endif>
+<endif>
+%>
+
+/** ID! and output=AST (same as plain tokenRef) */
+tokenRefBang(token,label,elementIndex,terminalOptions={}) ::= "<super.tokenRef(...)>"
+
+/** ID^ and output=AST */
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <%
+<super.tokenRef(...)>
+<if(!ruleDescriptor.isSynPred)>
+<if(backtracking)><\n>if (<actions.(actionScope).synpredgate>) {<endif>
+<\n><label>_tree = <createNodeFromToken(...)>;
+<\n>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
+<if(backtracking)><\n>}<endif>
+<endif>
+%>
+
+/** ids+=ID! and output=AST */
+tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefBang(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** label+=TOKEN when output=AST but not rewrite alt */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match label+=TOKEN^ when output=AST but not rewrite alt */
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRefRuleRoot(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+// SET AST
+
+// the match set stuff is interesting in that it uses an argument list
+// to pass code to the default matchSet; another possible way to alter
+// inherited code.  I don't use the region stuff because I need to pass
+// different chunks depending on the operator.  I don't like making
+// the template name have the operator as the number of templates gets
+// large but this is the most flexible--this is as opposed to having
+// the code generator call matchSet then add root code or ruleroot code
+// plus list label plus ...  The combinations might require complicated
+// rather than just added on code.  Investigate that refactoring when
+// I have more time.
+
+matchSet(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= <<
+<super.matchSet(postmatchCode={<if(!ruleDescriptor.isSynPred)><if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);<endif>}, ...)>
+>>
+
+matchRuleBlockSet(s,label,elementIndex,postmatchCode,treeLevel="0",terminalOptions={}) ::= <<
+<matchSet(...)>
+>>
+
+matchSetBang(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= "<super.matchSet(...)>"
+
+// note there is no matchSetTrack because -> rewrites force sets to be
+// plain old blocks of alts: (A|B|...|C)
+
+matchSetRuleRoot(s,label,elementIndex,debug,terminalOptions={}) ::= <<
+<if(label)>
+<label>=(<labelType>)input.LT(1);
+<endif>
+<super.matchSet(postmatchCode={<if(!ruleDescriptor.isSynPred)><if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);<endif>}, ...)>
+>>
+
+// RULE REF AST
+
+/** rule when output=AST */
+ruleRef(rule,label,elementIndex,args,scope) ::= <%
+<super.ruleRef(...)>
+<if(!ruleDescriptor.isSynPred)>
+<\n><if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <label>.Tree);
+<endif>
+%>
+
+/** rule! is same as normal rule ref */
+ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(...)>"
+
+/** rule^ */
+ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
+>>
+
+/** x+=rule when output=AST */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** x+=rule! when output=AST is a rule ref with list addition */
+ruleRefBangAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefBang(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+/** x+=rule^ */
+ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRefRuleRoot(...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
+>>
+
+// WILDCARD AST
+
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
+<super.wildcard(...)>
+<if(!ruleDescriptor.isSynPred)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
+adaptor.AddChild(root_0, <label>_tree);
+<if(backtracking)>}<endif>
+<endif>
+>>
+
+wildcardBang(label,elementIndex) ::= "<super.wildcard(token=[],...)>"
+
+wildcardRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
+<super.wildcard(...)>
+<if(!ruleDescriptor.isSynPred)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
+root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
+<if(backtracking)>}<endif>
+<endif>
+>>
+
+createNodeFromToken(label,terminalOptions={}) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
+<else>
+(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
+<endif>
+%>
+
+ruleCleanUp() ::= <<
+<super.ruleCleanUp()>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
+<if(backtracking)>}<endif>
+>>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg b/build/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
new file mode 100644
index 0000000..c5529b2
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
@@ -0,0 +1,377 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Templates for building ASTs during tree parsing.
+ *
+ *  Deal with many combinations.  Dimensions are:
+ *  Auto build or rewrite
+ *    no label, label, list label  (label/no-label handled together)
+ *    child, root
+ *    token, set, rule, wildcard
+ *
+ *  Each combination has its own template except that label/no label
+ *  is combined into tokenRef, ruleRef, ...
+ */
+
+/** Add a variable to track last element matched */
+ruleDeclarations() ::= <<
+<super.ruleDeclarations()>
+<if(!ruleDescriptor.isSynPred)>
+<ASTLabelType> _first_0 = default(<ASTLabelType>);
+<ASTLabelType> _last = default(<ASTLabelType>);
+<endif>
+>>
+
+/** What to emit when there is no rewrite rule.  For auto build
+ *  mode, does nothing.
+ */
+noRewrite(rewriteBlockLevel=false, treeLevel=false) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(rewriteMode)>
+retval.Tree = (<ASTLabelType>)_first_0;
+if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
+	retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
+<endif>
+<if(backtracking)>}<endif>
+<endif>
+>>
+
+/** match ^(root children) in tree parser; override here to
+ *  add tree construction actions.
+ */
+tree(root, actionsAfterRoot, children, nullableChildList,
+     enclosingTreeLevel, treeLevel) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+{
+<ASTLabelType> _save_last_<treeLevel> = _last;
+<ASTLabelType> _first_<treeLevel> = default(<ASTLabelType>);
+<if(!rewriteMode)>
+<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
+<endif>
+<root:element()>
+<if(rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+<if(root.el.rule)>
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
+<else>
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>;
+<endif>
+<endif>
+<actionsAfterRoot:element()>
+<if(nullableChildList)>
+if (input.LA(1) == TokenTypes.Down) {
+	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+	<children:element()>
+	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+}
+<else>
+Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+<children:element()>
+Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+<endif>
+<if(!rewriteMode)>
+adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);
+<endif>
+_last = _save_last_<treeLevel>;
+}
+<else>
+<super.tree(...)>
+<endif>
+>>
+
+// TOKEN AST STUFF
+
+/** ID! and output=AST (same as plain tokenRef) 'cept add
+ *  setting of _last
+ */
+tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+<else>
+<super.tokenRefBang(...)>
+<endif>
+>>
+
+/** ID auto construct */
+tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>}<endif>
+<else> <! rewrite mode !>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
+<endif>
+<else>
+<super.tokenRef(...)>
+<endif>
+>>
+
+/** label+=TOKEN auto construct */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<tokenRef(...)>
+<listLabelElem(elem=label,...)>
+<else>
+<super.tokenRefAndListLabel(...)>
+<endif>
+>>
+
+/** ^(ID ...) auto construct */
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.tokenRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
+<if(backtracking)>}<endif>
+<endif>
+<else>
+<super.tokenRefRuleRoot(...)>
+<endif>
+>>
+
+/** Match ^(label+=TOKEN ...) auto construct */
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<tokenRefRuleRoot(...)>
+<listLabelElem(elem=label,...)>
+<else>
+<super.tokenRefRuleRootAndListLabel(...)>
+<endif>
+>>
+
+/** Match . wildcard and auto dup the node/subtree */
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.wildcard(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<label>_tree = (<ASTLabelType>)adaptor.DupTree(<label>);
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>}<endif>
+<else> <! rewrite mode !>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
+<endif>
+<else>
+<super.wildcard(...)>
+<endif>
+>>
+
+// SET AST
+
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.matchSet(postmatchCode={
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+adaptor.AddChild(root_<treeLevel>, <label>_tree);
+<if(backtracking)>\}<endif>
+<endif>
+}, ...
+)>
+<else>
+<super.matchSet(...)>
+<endif>
+>>
+
+matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<matchSet(...)>
+<noRewrite(...)> <! set return tree !>
+<else>
+<super.matchRuleBlockSet(...)>
+<endif>
+>>
+
+matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.matchSet(...)>
+<else>
+<super.matchSetBang(...)>
+<endif>
+>>
+
+matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<super.matchSet(postmatchCode={
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+<if(terminalOptions.node)>
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<else>
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
+<endif><\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
+<if(backtracking)>\}<endif>
+<endif>
+}, ...
+)>
+<else>
+<super.matchSetRuleRoot(...)>
+<endif>
+>>
+
+// RULE REF AST
+
+/** rule auto construct */
+ruleRef(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRef(...)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+<if(!rewriteMode)>
+adaptor.AddChild(root_<treeLevel>, <label>.Tree);
+<else> <! rewrite mode !>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
+<endif>
+<else>
+<super.ruleRef(...)>
+<endif>
+>>
+
+/** x+=rule auto construct */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<ruleRef(...)>
+<listLabelElem(elem={<label>.Tree},...)>
+<else>
+<super.ruleRefAndListLabel(...)>
+<endif>
+>>
+
+/** ^(rule ...) auto construct */
+ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRef(...)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
+<endif>
+<else>
+<super.ruleRefRuleRoot(...)>
+<endif>
+>>
+
+/** ^(x+=rule ...) auto construct */
+ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+<ruleRefRuleRoot(...)>
+<listLabelElem(elem={<label>.Tree},...)>
+<else>
+<super.ruleRefRuleRootAndListLabel(...)>
+<endif>
+>>
+
+/** rule when output=AST and tracking for rewrite */
+ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefTrack(...)>
+>>
+
+/** x+=rule when output=AST and tracking for rewrite */
+ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefTrackAndListLabel(...)>
+<else>
+<super.ruleRefTrackAndListLabel(...)>
+<endif>
+>>
+
+/** ^(rule ...) rewrite */
+ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefRootTrack(...)>
+<else>
+<super.ruleRefRuleRootTrack(...)>
+<endif>
+>>
+
+/** ^(x+=rule ...) rewrite */
+ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
+_last = (<ASTLabelType>)input.LT(1);
+<super.ruleRefRuleRootTrackAndListLabel(...)>
+<else>
+<super.ruleRefRuleRootTrackAndListLabel(...)>
+<endif>
+>>
+
+/** Streams for token refs are tree nodes now; override to
+ *  change NextToken to NextNode.
+ */
+createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
+<if(terminalOptions.node)>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
+<else>
+stream_<token>.NextNode()
+<endif>
+%>
+
+ruleCleanUp() ::= <<
+<super.ruleCleanUp()>
+<if(!ruleDescriptor.isSynPred)>
+<if(!rewriteMode)>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
+retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
+<if(backtracking)>}<endif>
+<endif>
+<endif>
+>>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/build/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
new file mode 100644
index 0000000..c9229e1
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -0,0 +1,1749 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+csharpVisibilityMap ::= [
+	"private":"private",
+	"protected":"protected",
+	"public":"public",
+	"fragment":"private",
+	default:"private"
+]
+
+/** The overall file structure of a recognizer; stores methods for rules
+ *  and cyclic DFAs plus support code.
+ */
+outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
+			docComment, recognizer,
+			name, tokens, tokenNames, rules, cyclicDFAs,
+			bitsets, buildTemplate, buildAST, rewriteMode, profile,
+			backtracking, synpreds, memoize, numRules,
+			fileName, ANTLRVersion, generatedTimestamp, trace,
+			scopes, superClass, literals) ::=
+<<
+//------------------------------------------------------------------------------
+// \<auto-generated>
+//     This code was generated by a tool.
+//     ANTLR Version: <ANTLRVersion>
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// \</auto-generated>
+//------------------------------------------------------------------------------
+
+// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>
+
+// The variable 'variable' is assigned but its value is never used.
+#pragma warning disable 219
+// Unreachable code detected.
+#pragma warning disable 162
+// Missing XML comment for publicly visible type or member 'Type_or_Member'
+#pragma warning disable 1591
+// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
+#pragma warning disable 3019
+
+<actions.(actionScope).header>
+
+<@imports>
+using System.Collections.Generic;
+using Antlr.Runtime;
+using Antlr.Runtime.Misc;
+<if(TREE_PARSER)>
+using Antlr.Runtime.Tree;
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
+<endif>
+<@end>
+<if(actions.(actionScope).namespace)>
+namespace <actions.(actionScope).namespace>
+{
+<endif>
+<docComment>
+<recognizer>
+<if(actions.(actionScope).namespace)>
+
+} // namespace <actions.(actionScope).namespace>
+<endif>
+>>
+
+lexerInputStreamType() ::= <<
+<actions.(actionScope).inputStreamType; null="ICharStream">
+>>
+
+lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
+	  superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>},
+	  rewriteElementType={}, ASTLabelType={}) ::= <<
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
+[System.CLSCompliant(false)]
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+{
+	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
+	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+	<actions.lexer.members>
+
+	// delegates
+	<grammar.delegates:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	// delegators
+	<grammar.delegators:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
+	{
+		OnCreated();
+	}
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+		: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
+	{
+	}
+
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+		: base(input, state)
+	{
+<if(memoize)>
+<if(grammar.grammarIsRoot)>
+		state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<numRules>+1];<\n><! index from 1..n !>
+<endif>
+<endif>
+		<grammar.directDelegates:
+		 {g|<g:delegateName()> = new <g.recognizerName>(input, this.state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+		<grammar.delegators:
+		 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+
+		OnCreated();
+	}
+	public override string GrammarFileName { get { return "<fileName>"; } }
+
+<if(grammar.hasDelegates)>
+	public override <lexerInputStreamType()> CharStream
+	{
+		get
+		{
+			return base.CharStream;
+		}
+		set
+		{
+			base.CharStream = value;
+			<grammar.directDelegates:
+			 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+			<grammar.delegators:
+			 {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+			<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+		}
+	}
+
+<if(grammar.delegates)>
+	public override void SetState(RecognizerSharedState state)
+	{
+		base.SetState(state);
+		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
+	}
+<endif>
+
+<endif>
+<if(filterMode)>
+	<filteringNextToken()>
+<endif>
+
+
+	partial void OnCreated();
+	partial void EnterRule(string ruleName, int ruleIndex);
+	partial void LeaveRule(string ruleName, int ruleIndex);
+
+	<rules; separator="\n">
+
+	<insertLexerSynpreds(synpreds)>
+
+	#region DFA
+	<cyclicDFAs:{dfa | DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif>);}; separator="\n">
+	}
+
+	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
+	#endregion
+
+}
+>>
+
+/** A override of Lexer.nextToken() that backtracks over mTokens() looking
+ *  for matches.  No error can be generated upon error; just rewind, consume
+ *  a token and then try again.  backtracking needs to be set as well.
+ *  Make rule memoization happen only at levels above 1 as we start mTokens
+ *  at backtracking==1.
+ */
+filteringNextToken() ::= <<
+public override IToken NextToken()
+{
+	while (true)
+	{
+		if (input.LA(1) == CharStreamConstants.EndOfFile)
+		{
+			IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
+			eof.Line = Line;
+			eof.CharPositionInLine = CharPositionInLine;
+			return eof;
+		}
+		state.token = null;
+		state.channel = TokenChannels.Default;
+		state.tokenStartCharIndex = input.Index;
+		state.tokenStartCharPositionInLine = input.CharPositionInLine;
+		state.tokenStartLine = input.Line;
+		state.text = null;
+		try
+		{
+			int m = input.Mark();
+			state.backtracking=1;<! means we won't throw slow exception !>
+			state.failed=false;
+			mTokens();
+			state.backtracking=0;
+			<! mTokens backtracks with synpred at backtracking==2
+			   and we set the synpredgate to allow actions at level 1. !>
+			if (state.failed)
+			{
+				input.Rewind(m);
+				input.Consume();<! advance one char and try again !>
+			}
+			else
+			{
+				Emit();
+				return state.token;
+			}
+		}
+		catch (RecognitionException re)
+		{
+			// shouldn't happen in backtracking mode, but...
+			ReportError(re);
+			Recover(re);
+		}
+	}
+}
+
+public override void Memoize(IIntStream input, int ruleIndex, int ruleStartIndex)
+{
+	if (state.backtracking > 1)
+		base.Memoize(input, ruleIndex, ruleStartIndex);
+}
+
+public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
+{
+	if (state.backtracking > 1)
+		return base.AlreadyParsedRule(input, ruleIndex);
+
+	return false;
+}
+>>
+
+actionGate() ::= "state.backtracking == 0"
+
+filteringActionGate() ::= "state.backtracking == 1"
+
+/** How to generate a parser */
+genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
+              bitsets, inputStreamType, superClass,
+              labelType, members, rewriteElementType,
+              filterMode, ASTLabelType="object") ::= <<
+[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
+[System.CLSCompliant(false)]
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+{
+<if(grammar.grammarIsRoot)>
+	internal static readonly string[] tokenNames = new string[] {
+		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
+	};
+<endif>
+	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
+
+<if(grammar.delegates)>
+	// delegates
+	<grammar.delegates:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
+	// delegators
+	<grammar.delegators:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+<endif>
+
+<if(grammar.delegates)>
+	public override void SetState(RecognizerSharedState state)
+	{
+		base.SetState(state);
+		<grammar.delegates:{g|<g:delegateName()>.SetState(state);}; separator="\n">
+	}
+
+<if(TREE_PARSER)>
+	public override void SetTreeNodeStream(ITreeNodeStream input)
+	{
+		base.SetTreeNodeStream(input);
+		<grammar.delegates:{g|<g:delegateName()>.SetTreeNodeStream(input);}; separator="\n">
+	}
+<endif>
+<endif>
+
+	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+	<@members()>
+
+	public override string[] TokenNames { get { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; } }
+	public override string GrammarFileName { get { return "<fileName>"; } }
+
+	<members>
+
+	partial void OnCreated();
+	partial void EnterRule(string ruleName, int ruleIndex);
+	partial void LeaveRule(string ruleName, int ruleIndex);
+
+	#region Rules
+	<rules; separator="\n">
+	#endregion Rules
+
+<if(grammar.delegatedRules)>
+<! generate rule/method definitions for imported rules so they
+   appear to be defined in this recognizer. !>
+	#region Delegated rules
+<grammar.delegatedRules:{ruleDescriptor|
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)<!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", "><endif>); \}}; separator="\n">
+	#endregion Delegated rules
+<endif>
+
+	<insertSynpreds(synpreds)>
+
+<if(cyclicDFAs)>
+	#region DFA
+	<cyclicDFAs:{dfa | private DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
+
+	protected override void InitDFAs()
+	{
+		base.InitDFAs();
+		<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>( this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif> );}; separator="\n">
+	}
+
+	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
+	#endregion DFA
+<endif>
+
+<if(bitsets)>
+	#region Follow sets
+	private static class Follow
+	{
+		<bitsets:{it|<bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>}; separator="\n">
+	}
+	#endregion Follow sets
+<endif>
+}
+>>
+
+@genericParser.members() ::= <<
+<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: base(input, state)
+{
+<if(grammar.directDelegates)>
+	<grammar.directDelegates:
+		{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+<endif>
+<if(grammar.indirectDelegates)>
+	<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
+	<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+<endif>
+	<parserCtorBody()>
+	OnCreated();
+}
+>>
+
+// imported grammars are 'public' (can't be internal because their return scope classes must be accessible)
+parserModifier(grammar, actions) ::= <<
+<if(grammar.grammarIsRoot)><actions.(actionScope).modifier; null="public"><else>public<endif>
+>>
+
+parserCtorBody() ::= <<
+<if(memoize)>
+<if(grammar.grammarIsRoot)>
+this.state.ruleMemo = new System.Collections.Generic.Dictionary\<int, int>[<length(grammar.allImportedRules)>+1];<\n><! index from 1..n !>
+<endif>
+<endif>
+<grammar.delegators:
+ {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+>>
+
+parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
+       ASTLabelType="object", superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Parser<endif>}, labelType="IToken",
+       members={<actions.parser.members>}) ::= <<
+<genericParser(inputStreamType="ITokenStream", rewriteElementType="IToken", filterMode=false, ...)>
+>>
+
+/** How to generate a tree parser; same as parser except the input
+ *  stream is a different type.
+ */
+treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
+           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="object",
+           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif><endif>},
+           members={<actions.treeparser.members>}) ::= <<
+<genericParser(inputStreamType="ITreeNodeStream", rewriteElementType="Node", ...)>
+>>
+
+/** A simpler version of a rule template that is specific to the imaginary
+ *  rules created for syntactic predicates.  As they never have return values
+ *  nor parameters etc..., just give simplest possible method.  Don't do
+ *  any of the normal memoization stuff in here either; it's a waste.
+ *  As predicates cannot be inlined into the invoking rule, they need to
+ *  be in a rule by themselves.
+ */
+synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
+<<
+
+partial void EnterRule_<ruleName>_fragment();
+partial void LeaveRule_<ruleName>_fragment();
+
+// $ANTLR start <ruleName>
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	<ruleLabelDefs(...)>
+	EnterRule_<ruleName>_fragment();
+	EnterRule("<ruleName>_fragment", <ruleDescriptor.index>);
+	TraceIn("<ruleName>_fragment", <ruleDescriptor.index>);
+	try
+	{
+		<block>
+	}
+	finally
+	{
+		TraceOut("<ruleName>_fragment", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>_fragment", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>_fragment();
+	}
+}
+// $ANTLR end <ruleName>
+>>
+
+insertLexerSynpreds(synpreds) ::= <<
+<insertSynpreds(synpreds)>
+>>
+
+insertSynpreds(synpreds) ::= <<
+<if(synpreds)>
+#region Synpreds
+private bool EvaluatePredicate(System.Action fragment)
+{
+	bool success = false;
+	state.backtracking++;
+	<@start()>
+	try { DebugBeginBacktrack(state.backtracking);
+	int start = input.Mark();
+	try
+	{
+		fragment();
+	}
+	catch ( RecognitionException re )
+	{
+		System.Console.Error.WriteLine("impossible: "+re);
+	}
+	success = !state.failed;
+	input.Rewind(start);
+	} finally { DebugEndBacktrack(state.backtracking, success); }
+	<@stop()>
+	state.backtracking--;
+	state.failed=false;
+	return success;
+}
+#endregion Synpreds
+<endif>
+>>
+
+ruleMemoization(name) ::= <<
+<if(memoize)>
+if (state.backtracking > 0 && AlreadyParsedRule(input, <ruleDescriptor.index>)) { <returnFromRule()> }
+<endif>
+>>
+
+/** How to test for failure and return from rule */
+checkRuleBacktrackFailure() ::= <<
+<if(backtracking)>if (state.failed) <returnFromRule()><endif>
+>>
+
+/** This rule has failed, exit indicating failure during backtrack */
+ruleBacktrackFailure() ::= <<
+<if(backtracking)>if (state.backtracking>0) {state.failed=true; <returnFromRule()>}<endif>
+>>
+
+ruleWrapperMap ::= [
+	"bottomup":{<ruleWrapperBottomup()>},
+	"topdown":{<ruleWrapperTopdown()>},
+	default:""
+]
+
+ruleWrapperBottomup() ::= <<
+<if(TREE_PARSER && filterMode)>
+protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Bottomup() { <if(buildAST)>return <endif>bottomup(); }
+<endif>
+>>
+
+ruleWrapperTopdown() ::= <<
+<if(TREE_PARSER && filterMode)>
+protected override <if(buildAST)>IAstRuleReturnScope<else>void<endif> Topdown() { <if(buildAST)>return <endif>topdown(); }
+<endif>
+>>
+
+/** How to generate code for a rule.  This includes any return type
+ *  data aggregates required for multiple return values.
+ */
+rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memoize) ::= <<
+<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
+<returnScope(ruleDescriptor.returnScope)>
+partial void EnterRule_<ruleName>();
+partial void LeaveRule_<ruleName>();
+<ruleWrapperMap.(ruleName)>
+// $ANTLR start "<ruleName>"
+// <fileName>:<description>
+[GrammarRule("<ruleName>")]
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	EnterRule_<ruleName>();
+	EnterRule("<ruleName>", <ruleDescriptor.index>);
+	TraceIn("<ruleName>", <ruleDescriptor.index>);
+	<ruleScopeSetUp()>
+	<ruleDeclarations()>
+	<ruleLabelDefs(...)>
+	<ruleDescriptor.actions.init>
+	try { DebugEnterRule(GrammarFileName, "<ruleName>");
+	DebugLocation(<ruleDescriptor.tree.line>, <ruleDescriptor.EORNode.charPositionInLine>);
+	<@preamble()>
+	try
+	{
+		<ruleMemoization(name=ruleName)>
+		<block>
+		<ruleCleanUp()>
+		<(ruleDescriptor.actions.after):execAction()>
+	}
+<if(exceptions)>
+	<exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
+<else>
+<if(!emptyRule)>
+<if(actions.(actionScope).rulecatch)>
+	<actions.(actionScope).rulecatch>
+<else>
+	catch (RecognitionException re)
+	{
+		ReportError(re);
+		Recover(input,re);
+		<@setErrorReturnValue()>
+	}
+<endif>
+<endif>
+<endif>
+	finally
+	{
+		TraceOut("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>();
+		<memoize()>
+		<ruleScopeCleanUp()>
+		<finally>
+	}
+	DebugLocation(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);
+	} finally { DebugExitRule(GrammarFileName, "<ruleName>"); }
+	<@postamble()>
+	<returnFromRule()><\n>
+}
+// $ANTLR end "<ruleName>"
+>>
+
+// imported grammars need to have internal rules
+ruleModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>internal<endif>
+>>
+
+// imported grammars need to have public return scopes
+returnScopeModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>public<endif>
+>>
+
+catch(decl,action) ::= <<
+catch (<e.decl>)
+{
+	<e.action>
+}
+>>
+
+ruleDeclarations() ::= <<
+<if(ruleDescriptor.hasMultipleReturnValues)>
+<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>(<if(ruleDescriptor.returnScope.attributes)>this<endif>);
+retval.Start = (<labelType>)input.LT(1);
+<elseif(ruleDescriptor.returnScope)>
+<ruleDescriptor.returnScope.attributes:{ a |
+<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
+}>
+<endif>
+<if(memoize)>
+int <ruleDescriptor.name>_StartIndex = input.Index;
+<endif>
+>>
+
+ruleScopeSetUp() ::= <<
+<ruleDescriptor.useScopes:{it|<it>_stack.Push(new <it>_scope(this));<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
+<ruleDescriptor.ruleScope:{it|<it.name>_stack.Push(new <it.name>_scope(this));<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
+>>
+
+ruleScopeCleanUp() ::= <<
+<ruleDescriptor.useScopes:{it|<it>_scopeAfter(<it>_stack.Peek());<it>_stack.Pop();}; separator="\n">
+<ruleDescriptor.ruleScope:{it|<it.name>_scopeAfter(<it.name>_stack.Peek());<it.name>_stack.Pop();}; separator="\n">
+>>
+
+ruleLabelDefs(ruleDescriptor, labelType, ASTLabelType, rewriteElementType) ::= <<
+<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
+	:{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<ruleDescriptor.tokenListLabels
+	:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<[ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
+	:{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
+<ruleDescriptor.ruleListLabels:ruleLabelDef(); separator="\n">
+>>
+
+lexerRuleLabelDefs() ::= <<
+<[ruleDescriptor.tokenLabels,
+  ruleDescriptor.tokenListLabels,
+  ruleDescriptor.ruleLabels]
+	:{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<[ruleDescriptor.charListLabels,
+  ruleDescriptor.charLabels]
+	:{it|int <it.label.text> = 0;}; separator="\n"
+>
+<[ruleDescriptor.tokenListLabels,
+  ruleDescriptor.ruleListLabels]
+	:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<ruleDescriptor.charListLabels:{it|List\<int> list_<it.label.text> = null;}; separator="\n"
+>
+>>
+
+returnFromRule() ::= <%
+return
+<if(!ruleDescriptor.isSynPred)>
+<if(ruleDescriptor.hasReturnValue)>
+<if(ruleDescriptor.hasSingleReturnValue)>
+<! This comment is a hack to make sure the following
+   single space appears in the output. !> <ruleDescriptor.singleValueReturnName>
+<else>
+<!!> retval
+<endif>
+<endif>
+<endif>
+;
+%>
+
+ruleCleanUp() ::= <<
+<if(ruleDescriptor.hasMultipleReturnValues)>
+<if(!TREE_PARSER)>
+retval.Stop = (<labelType>)input.LT(-1);
+<endif>
+<endif>
+>>
+
+memoize() ::= <<
+<if(memoize)>
+<if(backtracking)>
+if (state.backtracking > 0) { Memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex); }
+<endif>
+<endif>
+>>
+
+/** How to generate a rule in the lexer; naked blocks are used for
+ *  fragment rules.
+ */
+lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
+
+partial void EnterRule_<ruleName>();
+partial void LeaveRule_<ruleName>();
+
+// $ANTLR start "<ruleName>"
+[GrammarRule("<ruleName>")]
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>)
+{
+	EnterRule_<ruleName>();
+	EnterRule("<ruleName>", <ruleDescriptor.index>);
+	TraceIn("<ruleName>", <ruleDescriptor.index>);
+	<ruleScopeSetUp()>
+	<ruleDeclarations()>
+	try
+	{
+<if(nakedBlock)>
+		<ruleMemoization(name=ruleName)>
+		<lexerRuleLabelDefs()>
+		<ruleDescriptor.actions.init>
+		<block>
+<else>
+		int _type = <ruleName>;
+		int _channel = DefaultTokenChannel;
+		<ruleMemoization(name=ruleName)>
+		<lexerRuleLabelDefs()>
+		<ruleDescriptor.actions.init>
+		<block>
+		<ruleCleanUp()>
+		state.type = _type;
+		state.channel = _channel;
+		<(ruleDescriptor.actions.after):execAction()>
+<endif>
+	}
+	finally
+	{
+		TraceOut("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule("<ruleName>", <ruleDescriptor.index>);
+		LeaveRule_<ruleName>();
+		<ruleScopeCleanUp()>
+		<memoize()>
+	}
+}
+// $ANTLR end "<ruleName>"
+>>
+
+/** How to generate code for the implicitly-defined lexer grammar rule
+ *  that chooses between lexer rules.
+ */
+tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
+
+public override void mTokens()
+{
+	<block><\n>
+}
+>>
+
+// S U B R U L E S
+
+/** A (...) subrule with multiple alternatives */
+block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int alt<decisionNumber>=<maxAlt>;
+<decls>
+<@predecision()>
+try { DebugEnterSubRule(<decisionNumber>);
+try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
+<decision>
+} finally { DebugExitDecision(<decisionNumber>); }
+<@postdecision()>
+<@prebranch()>
+switch (alt<decisionNumber>)
+{
+<alts:{a|<altSwitchCase(i,a)>}>
+}
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postbranch()>
+>>
+
+/** A rule block with multiple alternatives */
+ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int alt<decisionNumber>=<maxAlt>;
+<decls>
+<@predecision()>
+try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
+<decision>
+} finally { DebugExitDecision(<decisionNumber>); }
+<@postdecision()>
+switch (alt<decisionNumber>)
+{
+<alts:{a|<altSwitchCase(i,a)>}>
+}
+>>
+
+ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@prealt()>
+DebugEnterAlt(1);
+<alts>
+<@postalt()>
+>>
+
+/** A special case of a (...) subrule with a single alternative */
+blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@prealt()>
+DebugEnterAlt(1);
+<alts>
+<@postalt()>
+>>
+
+/** A (..)+ block with 1 or more alternatives */
+positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+int cnt<decisionNumber>=0;
+<decls>
+<@preloop()>
+try { DebugEnterSubRule(<decisionNumber>);
+while (true)
+{
+	int alt<decisionNumber>=<maxAlt>;
+	<@predecision()>
+	try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
+	<decision>
+	} finally { DebugExitDecision(<decisionNumber>); }
+	<@postdecision()>
+	switch (alt<decisionNumber>)
+	{
+	<alts:{a|<altSwitchCase(i,a)>}>
+	default:
+		if (cnt<decisionNumber> >= 1)
+			goto loop<decisionNumber>;
+
+		<ruleBacktrackFailure()>
+		EarlyExitException eee<decisionNumber> = new EarlyExitException( <decisionNumber>, input );
+		DebugRecognitionException(eee<decisionNumber>);
+		<@earlyExitException()>
+		throw eee<decisionNumber>;
+	}
+	cnt<decisionNumber>++;
+}
+loop<decisionNumber>:
+	;
+
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postloop()>
+>>
+
+positiveClosureBlockSingleAlt ::= positiveClosureBlock
+
+/** A (..)* block with 1 or more alternatives */
+closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
+// <fileName>:<description>
+<decls>
+<@preloop()>
+try { DebugEnterSubRule(<decisionNumber>);
+while (true)
+{
+	int alt<decisionNumber>=<maxAlt>;
+	<@predecision()>
+	try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
+	<decision>
+	} finally { DebugExitDecision(<decisionNumber>); }
+	<@postdecision()>
+	switch ( alt<decisionNumber> )
+	{
+	<alts:{a|<altSwitchCase(i,a)>}>
+	default:
+		goto loop<decisionNumber>;
+	}
+}
+
+loop<decisionNumber>:
+	;
+
+} finally { DebugExitSubRule(<decisionNumber>); }
+<@postloop()>
+>>
+
+closureBlockSingleAlt ::= closureBlock
+
+/** Optional blocks (x)? are translated to (x|) by before code generation
+ *  so we can just use the normal block template
+ */
+optionalBlock ::= block
+
+optionalBlockSingleAlt ::= block
+
+/** A case in a switch that jumps to an alternative given the alternative
+ *  number.  A DFA predicts the alternative and then a simple switch
+ *  does the jump to the code that actually matches that alternative.
+ */
+altSwitchCase(altNum,alt) ::= <<
+case <altNum>:
+	<@prealt()>
+	DebugEnterAlt(<altNum>);
+	<alt>
+	break;<\n>
+>>
+
+/** An alternative is just a list of elements; at outermost level */
+alt(elements,altNum,description,autoAST,outerAlt,treeLevel,rew) ::= <<
+// <fileName>:<description>
+{
+<@declarations()>
+<elements:element()>
+<rew>
+<@cleanup()>
+}
+>>
+
+/** What to emit when there is no rewrite.  For auto build
+ *  mode, does nothing.
+ */
+noRewrite(rewriteBlockLevel, treeLevel) ::= ""
+
+// E L E M E N T S
+
+/** Dump the elements one per line */
+element(it) ::= <%
+<@prematch()>
+DebugLocation(<it.line>, <it.pos>);<\n>
+<it.el><\n>
+%>
+
+/** match a token optionally with a label in front */
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
+<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
+>>
+
+/** ids+=ID */
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<tokenRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+listLabel(label,elem) ::= <<
+#error The listLabel template should not be used with this target.<\n>
+>>
+
+listLabelElem(label,elem,elemType) ::= <<
+if (list_<label>==null) list_<label>=new List\<<elemType; null={<labelType>}>\>();
+list_<label>.Add(<elem>);<\n>
+>>
+
+/** match a character */
+charRef(char,label) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+Match(<char>); <checkRuleBacktrackFailure()>
+>>
+
+/** match a character range */
+charRangeRef(a,b,label) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
+>>
+
+/** For now, sets are interval tests and must be tested inline */
+matchSet(s,label,elementIndex,postmatchCode="",terminalOptions={}) ::= <<
+<if(label)>
+<matchSetLabel()>
+<endif>
+if (<s>)
+{
+	input.Consume();
+	<postmatchCode>
+	<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
+}
+else
+{
+	<ruleBacktrackFailure()>
+	MismatchedSetException mse = new MismatchedSetException(null,input);
+	DebugRecognitionException(mse);
+	<@mismatchedSetException()>
+<if(LEXER)>
+	Recover(mse);
+	throw mse;
+<else>
+	throw mse;
+	<! use following code to make it recover inline; remove throw mse;
+	recoverFromMismatchedSet(input,mse,Follow._set_in_<ruleName><elementIndex>);
+	!>
+<endif>
+}<\n>
+>>
+
+matchSetUnchecked(s,label,elementIndex,postmatchCode=false) ::= <%
+<if(label)>
+<matchSetLabel()><\n>
+<endif>
+input.Consume();<\n>
+<if(postmatchCode)>
+<postmatchCode><\n>
+<endif>
+<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
+%>
+
+matchSetLabel() ::= <%
+<if(LEXER)>
+<label>= input.LA(1);
+<else>
+<label>=(<labelType>)input.LT(1);
+<endif>
+%>
+
+matchRuleBlockSet ::= matchSet
+
+matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
+<matchSet(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match a string literal */
+lexerStringRef(string,label,elementIndex) ::= <%
+<if(label)>
+int <label>Start = CharIndex;<\n>
+Match(<string>); <checkRuleBacktrackFailure()><\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+Match(<string>); <checkRuleBacktrackFailure()><\n>
+<endif>
+%>
+
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
+<if(label)>
+<label>=(<labelType>)input.LT(1);<\n>
+<endif>
+MatchAny(input); <checkRuleBacktrackFailure()>
+>>
+
+wildcardAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
+<wildcard(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match . wildcard in lexer */
+wildcardChar(label, elementIndex) ::= <<
+<if(label)>
+<label> = input.LA(1);<\n>
+<endif>
+MatchAny(); <checkRuleBacktrackFailure()>
+>>
+
+wildcardCharListLabel(label, elementIndex) ::= <<
+<wildcardChar(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** Match a rule reference by invoking it possibly with arguments
+ *  and a return value or values.  The 'rule' argument was the
+ *  target rule name, but now is type Rule, whose toString is
+ *  same: the rule name.  Now though you can access full rule
+ *  descriptor stuff.
+ */
+ruleRef(rule,label,elementIndex,args,scope) ::= <<
+PushFollow(Follow._<rule.name>_in_<ruleName><elementIndex>);
+<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name; format="id">(<args; separator=", ">);
+PopFollow();
+<checkRuleBacktrackFailure()>
+>>
+
+/** ids+=r */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabelElem(elem=label,elemType={<ASTLabelType>},...)>
+>>
+
+/** A lexer rule reference.
+ *
+ *  The 'rule' argument was the target rule name, but now
+ *  is type Rule, whose toString is same: the rule name.
+ *  Now though you can access full rule descriptor stuff.
+ */
+lexerRuleRef(rule,label,args,elementIndex,scope) ::= <%
+<if(label)>
+int <label>Start<elementIndex> = CharIndex;<\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()><\n>
+<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
+<endif>
+%>
+
+/** i+=INT in lexer */
+lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
+<lexerRuleRef(...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
+>>
+
+/** EOF in the lexer */
+lexerMatchEOF(label,elementIndex) ::= <%
+<if(label)>
+int <label>Start<elementIndex> = CharIndex;<\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+Match(EOF); <checkRuleBacktrackFailure()><\n>
+<labelType> <label> = new <labelType>(input, EOF, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
+<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
+<else>
+Match(EOF); <checkRuleBacktrackFailure()>
+<endif>
+%>
+
+// used for left-recursive rules
+recRuleDefArg()                       ::= "int <recRuleArg()>"
+recRuleArg()                          ::= "_p"
+recRuleAltPredicate(ruleName,opPrec)  ::= "<recRuleArg()> \<= <opPrec>"
+recRuleSetResultAction()              ::= "root_0=$<ruleName>_primary.tree;"
+
+/** match ^(root children) in tree parser */
+tree(root, actionsAfterRoot, children, nullableChildList,
+     enclosingTreeLevel, treeLevel) ::= <<
+<root:element()>
+<actionsAfterRoot:element()>
+<if(nullableChildList)>
+if (input.LA(1) == TokenTypes.Down)
+{
+	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+	<children:element()>
+	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+}
+<else>
+Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+<children:element()>
+Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+<endif>
+>>
+
+/** Every predicate is used as a validating predicate (even when it is
+ *  also hoisted into a prediction expression).
+ */
+validateSemanticPredicate(pred,description) ::= <<
+if (!(<evalPredicate(...)>))
+{
+	<ruleBacktrackFailure()>
+	throw new FailedPredicateException(input, "<ruleName>", "<description>");
+}
+>>
+
+// F i x e d  D F A  (if-then-else)
+
+dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
+<edges; separator="\nelse ">
+else
+{
+<if(eotPredictsAlt)>
+	alt<decisionNumber> = <eotPredictsAlt>;
+<else>
+	<ruleBacktrackFailure()>
+	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input, <k>);
+	DebugRecognitionException(nvae);
+	<@noViableAltException()>
+	throw nvae;
+<endif>
+}
+>>
+
+/** Same as a normal DFA state except that we don't examine lookahead
+ *  for the bypass alternative.  It delays error detection but this
+ *  is faster, smaller, and more what people expect.  For (X)? people
+ *  expect "if ( LA(1)==X ) match(X);" and that's it.
+ */
+dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
+<edges; separator="\nelse ">
+>>
+
+/** A DFA state that is actually the loopback decision of a closure
+ *  loop.  If end-of-token (EOT) predicts any of the targets then it
+ *  should act like a default clause (i.e., no error can be generated).
+ *  This is used only in the lexer so that for ('a')* on the end of a rule
+ *  anything other than 'a' predicts exiting.
+ */
+dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
+<edges; separator="\nelse "><\n>
+<if(eotPredictsAlt)>
+<if(!edges)>
+alt<decisionNumber> = <eotPredictsAlt>;<! if no edges, don't gen ELSE !>
+<else>
+else
+{
+	alt<decisionNumber> = <eotPredictsAlt>;
+}<\n>
+<endif>
+<endif>
+>>
+
+/** An accept state indicates a unique alternative has been predicted */
+dfaAcceptState(alt) ::= "alt<decisionNumber> = <alt>;"
+
+/** A simple edge with an expression.  If the expression is satisfied,
+ *  enter to the target state.  To handle gated productions, we may
+ *  have to evaluate some predicates for this edge.
+ */
+dfaEdge(labelExpr, targetState, predicates) ::= <<
+if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>)
+{
+	<targetState>
+}
+>>
+
+// F i x e d  D F A  (switch case)
+
+/** A DFA state where a SWITCH may be generated.  The code generator
+ *  decides if this is possible: CodeGenerator.canGenerateSwitch().
+ */
+dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+default:
+<if(eotPredictsAlt)>
+	alt<decisionNumber>=<eotPredictsAlt>;
+	break;<\n>
+<else>
+	{
+		<ruleBacktrackFailure()>
+		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input, <k>);
+		DebugRecognitionException(nvae);
+		<@noViableAltException()>
+		throw nvae;
+	}
+<endif>
+}<\n>
+>>
+
+dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+}<\n>
+>>
+
+dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
+switch (input.LA(<k>))
+{
+<edges; separator="\n">
+<if(eotPredictsAlt)>
+default:
+	alt<decisionNumber>=<eotPredictsAlt>;
+	break;<\n>
+<endif>
+}<\n>
+>>
+
+dfaEdgeSwitch(labels, targetState) ::= <<
+<labels:{it|case <it>:}; separator="\n">
+	{
+	<targetState>
+	}
+	break;
+>>
+
+// C y c l i c  D F A
+
+/** The code to initiate execution of a cyclic DFA; this is used
+ *  in the rule to predict an alt just like the fixed DFA case.
+ *  The <name> attribute is inherited via the parser, lexer, ...
+ */
+dfaDecision(decisionNumber,description) ::= <<
+try
+{
+	alt<decisionNumber> = dfa<decisionNumber>.Predict(input);
+}
+catch (NoViableAltException nvae)
+{
+	DebugRecognitionException(nvae);
+	throw;
+}
+>>
+
+/* Dump DFA tables as run-length-encoded Strings of octal values.
+ * Can't use hex as compiler translates them before compilation.
+ * These strings are split into multiple, concatenated strings.
+ * Java puts them back together at compile time thankfully.
+ * Java cannot handle large static arrays, so we're stuck with this
+ * encode/decode approach.  See analysis and runtime DFA for
+ * the encoding methods.
+ */
+cyclicDFA(dfa) ::= <<
+private class DFA<dfa.decisionNumber> : DFA
+{
+	private const string DFA<dfa.decisionNumber>_eotS =
+		"<dfa.javaCompressedEOT; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_eofS =
+		"<dfa.javaCompressedEOF; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_minS =
+		"<dfa.javaCompressedMin; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_maxS =
+		"<dfa.javaCompressedMax; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_acceptS =
+		"<dfa.javaCompressedAccept; wrap="\"+\n\t\t\"">";
+	private const string DFA<dfa.decisionNumber>_specialS =
+		"<dfa.javaCompressedSpecial; wrap="\"+\n\t\t\"">}>";
+	private static readonly string[] DFA<dfa.decisionNumber>_transitionS =
+		{
+			<dfa.javaCompressedTransition:{s|"<s; wrap="\"+\n\"">"}; separator=",\n">
+		};
+
+	private static readonly short[] DFA<dfa.decisionNumber>_eot = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eotS);
+	private static readonly short[] DFA<dfa.decisionNumber>_eof = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_eofS);
+	private static readonly char[] DFA<dfa.decisionNumber>_min = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_minS);
+	private static readonly char[] DFA<dfa.decisionNumber>_max = DFA.UnpackEncodedStringToUnsignedChars(DFA<dfa.decisionNumber>_maxS);
+	private static readonly short[] DFA<dfa.decisionNumber>_accept = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_acceptS);
+	private static readonly short[] DFA<dfa.decisionNumber>_special = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_specialS);
+	private static readonly short[][] DFA<dfa.decisionNumber>_transition;
+
+	static DFA<dfa.decisionNumber>()
+	{
+		int numStates = DFA<dfa.decisionNumber>_transitionS.Length;
+		DFA<dfa.decisionNumber>_transition = new short[numStates][];
+		for ( int i=0; i \< numStates; i++ )
+		{
+			DFA<dfa.decisionNumber>_transition[i] = DFA.UnpackEncodedString(DFA<dfa.decisionNumber>_transitionS[i]);
+		}
+	}
+
+	public DFA<dfa.decisionNumber>( BaseRecognizer recognizer<if(dfa.specialStateSTs)>, SpecialStateTransitionHandler specialStateTransition<endif> )
+<if(dfa.specialStateSTs)>
+		: base(specialStateTransition)
+<endif>
+	{
+		this.recognizer = recognizer;
+		this.decisionNumber = <dfa.decisionNumber>;
+		this.eot = DFA<dfa.decisionNumber>_eot;
+		this.eof = DFA<dfa.decisionNumber>_eof;
+		this.min = DFA<dfa.decisionNumber>_min;
+		this.max = DFA<dfa.decisionNumber>_max;
+		this.accept = DFA<dfa.decisionNumber>_accept;
+		this.special = DFA<dfa.decisionNumber>_special;
+		this.transition = DFA<dfa.decisionNumber>_transition;
+	}
+
+	public override string Description { get { return "<dfa.description>"; } }
+
+	public override void Error(NoViableAltException nvae)
+	{
+		DebugRecognitionException(nvae);
+	}
+}<\n>
+<if(dfa.specialStateSTs)>
+private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStream _input)<! throws NoViableAltException!>
+{
+	<if(LEXER)>
+	IIntStream input = _input;
+	<endif>
+	<if(PARSER)>
+	ITokenStream input = (ITokenStream)_input;
+	<endif>
+	<if(TREE_PARSER)>
+	ITreeNodeStream input = (ITreeNodeStream)_input;
+	<endif>
+	int _s = s;
+	s = -1;
+	<! pull these outside the switch cases to save space on locals !>
+	int LA<dfa.decisionNumber>_1 = input.LA(1);
+	int index<dfa.decisionNumber>_1 = input.Index;
+	switch (_s)
+	{
+	<dfa.specialStateSTs:{state |case <i0>:<! compressed special state numbers 0..n-1 !>
+	<state>}; separator="\n">
+
+	default:
+		break;
+	}
+
+	if (s >= 0)
+		return s;
+
+<if(backtracking)>
+	if (state.backtracking > 0) {state.failed=true; return -1;}
+<endif>
+	NoViableAltException nvae = new NoViableAltException(dfa.Description, <dfa.decisionNumber>, _s, input);
+	dfa.Error(nvae);
+	throw nvae;
+}
+<endif>
+>>
+
+/** A state in a cyclic DFA; it's a special state and part of a big switch on
+ *  state.
+ */
+cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
+{
+<if(semPredState)>
+	<! get next lookahead symbol to test edges, then rewind !>
+	input.Rewind();
+<endif>
+	<edges; separator="\nelse ">
+<if(semPredState)>
+	<! return input cursor to state before we rewound !>
+	input.Seek(index<decisionNumber>_1);
+<endif>
+	break;
+}
+>>
+
+/** Just like a fixed DFA edge, test the lookahead and indicate what
+ *  state to jump to next if successful.
+ */
+cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
+if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
+>>
+
+/** An edge pointing at end-of-token; essentially matches any char;
+ *  always jump to the target.
+ */
+eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
+s = <targetStateNumber>;<\n>
+>>
+
+
+// D F A  E X P R E S S I O N S
+
+andPredicates(left,right) ::= "(<left>&&<right>)"
+
+orPredicates(operands) ::= "(<operands; separator=\"||\">)"
+
+notPredicate(pred) ::= "!(<evalPredicate(...)>)"
+
+evalPredicate(pred,description) ::= "(<pred>)"
+
+evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"
+
+lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<k>==<atom>"
+
+/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
+ *  somewhere.  Must ask for the lookahead directly.
+ */
+isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"
+
+lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
+(LA<decisionNumber>_<k><ge()><lower> && LA<decisionNumber>_<k><le()><upper>)
+%>
+
+isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"
+
+le() ::= "\<="
+ge() ::= ">="
+
+setTest(ranges) ::= <<
+<ranges; separator="||">
+>>
+
+// A T T R I B U T E S
+
+attributeScope(scope) ::= <<
+<if(scope)>
+<if(scope.attributes)>
+protected sealed partial class <scope.name>_scope
+{
+	<scope.attributes:{it|public <it.decl>;}; separator="\n">
+
+	public <scope.name>_scope(<grammar.recognizerName> grammar) { OnCreated(grammar); }
+	partial void OnCreated(<grammar.recognizerName> grammar);
+}
+<if(scope.actions.scopeinit)>
+protected void <scope.name>_scopeInit( <scope.name>_scope scope )
+{
+	<scope.actions.scopeinit>
+}
+<else>
+partial void <scope.name>_scopeInit( <scope.name>_scope scope );
+<endif>
+<if(scope.actions.scopeafter)>
+protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
+{
+	<scope.actions.scopeafter>
+}
+<else>
+partial void <scope.name>_scopeAfter( <scope.name>_scope scope );
+<endif>
+protected readonly ListStack\<<scope.name>_scope> <scope.name>_stack = new ListStack\<<scope.name>_scope>();
+<endif>
+<endif>
+>>
+
+globalAttributeScope(scope) ::= <<
+<attributeScope(...)>
+>>
+
+ruleAttributeScope(scope) ::= <<
+<attributeScope(...)>
+>>
+
+returnStructName(it) ::= "<it.name>_return"
+
+returnType(ruleDescriptor) ::= <%
+<if(ruleDescriptor.returnScope.attributes && ruleDescriptor.hasMultipleReturnValues)>
+	<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
+<elseif(ruleDescriptor.hasMultipleReturnValues)>
+	<ruleReturnBaseType()>
+<elseif(ruleDescriptor.hasSingleReturnValue)>
+	<ruleDescriptor.singleValueReturnType>
+<else>
+	void
+<endif>
+%>
+
+/** Generate the C# type associated with a single or multiple return
+ *  values.
+ */
+ruleLabelType(referencedRule) ::= <%
+<if(referencedRule.hasMultipleReturnValues)>
+	<ruleReturnBaseType()>
+<elseif(referencedRule.hasSingleReturnValue)>
+	<referencedRule.singleValueReturnType>
+<else>
+	void
+<endif>
+%>
+
+delegateName(it) ::= <<
+<if(it.label)><it.label><else>g<it.name><endif>
+>>
+
+/** Using a type to init value map, try to init a type; if not in table
+ *  must be an object, default value is "null".
+ */
+initValue(typeName) ::= <<
+default(<typeName>)
+>>
+
+/** Define a rule label including default value */
+ruleLabelDef(label) ::= <%
+<ruleLabelType(label.referencedRule)> <label.label.text> = <initValue(ruleLabelType(label.referencedRule))>;
+%>
+
+/** Define a return struct for a rule if the code needs to access its
+ *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
+ *  subgroups to stick in members.
+ */
+returnScope(scope) ::= <<
+<if(scope.attributes && ruleDescriptor.hasMultipleReturnValues)>
+<returnScopeModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> sealed partial class <ruleDescriptor:returnStructName()> : <ruleReturnBaseType()><@ruleReturnInterfaces()>
+{
+	<scope.attributes:{it|public <it.decl>;}; separator="\n">
+	<@ruleReturnMembers()>
+}
+<endif>
+>>
+
+ruleReturnBaseType() ::= <%
+<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>>
+%>
+
+@returnScope.ruleReturnMembers() ::= <<
+public <ruleDescriptor:returnStructName()>(<grammar.recognizerName> grammar) {OnCreated(grammar);}
+partial void OnCreated(<grammar.recognizerName> grammar);
+>>
+
+parameterScope(scope) ::= <<
+<scope.attributes:{it|<it.decl>}; separator=", ">
+>>
+
+parameterAttributeRef(attr) ::= <<
+<attr.name; format="id">
+>>
+
+parameterSetAttributeRef(attr,expr) ::= <<
+<attr.name; format="id"> =<expr>;
+>>
+
+scopeAttributeRef(scope,attr,index,negIndex) ::= <%
+<if(negIndex)>
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id">
+<else>
+<if(index)>
+<scope>_stack[<index>].<attr.name; format="id">
+<else>
+<scope>_stack.Peek().<attr.name; format="id">
+<endif>
+<endif>
+%>
+
+scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
+<if(negIndex)>
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id"> = <expr>;
+<else>
+<if(index)>
+<scope>_stack[<index>].<attr.name; format="id"> = <expr>;
+<else>
+<scope>_stack.Peek().<attr.name; format="id"> = <expr>;
+<endif>
+<endif>
+%>
+
+/** $x is either global scope or x is rule with dynamic scope; refers
+ *  to stack itself not top of stack.  This is useful for predicates
+ *  like {$function.Count>0 && $function::name.Equals("foo")}?
+ */
+isolatedDynamicScopeRef(scope) ::= "<scope>_stack"
+
+/** reference an attribute of rule; might only have single return value */
+ruleLabelRef(referencedRule,scope,attr) ::= <%
+<if(referencedRule.hasMultipleReturnValues)>
+(<scope>!=null?((<returnType(referencedRule)>)<scope>).<attr.name; format="id">:<initValue(attr.type)>)
+<else>
+<scope>
+<endif>
+%>
+
+returnAttributeRef(ruleDescriptor,attr) ::= <%
+<if(ruleDescriptor.hasMultipleReturnValues)>
+retval.<attr.name; format="id">
+<else>
+<attr.name; format="id">
+<endif>
+%>
+
+returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
+<if(ruleDescriptor.hasMultipleReturnValues)>
+retval.<attr.name; format="id"> =<expr>;
+<else>
+<attr.name; format="id"> =<expr>;
+<endif>
+%>
+
+/** How to translate $tokenLabel */
+tokenLabelRef(label) ::= "<label>"
+
+/** ids+=ID {$ids} or e+=expr {$e} */
+listLabelRef(label) ::= "list_<label>"
+
+
+// not sure the next are the right approach
+
+tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:default(string))"
+tokenLabelPropertyRef_type(scope,attr) ::= "(<scope>!=null?<scope>.Type:0)"
+tokenLabelPropertyRef_line(scope,attr) ::= "(<scope>!=null?<scope>.Line:0)"
+tokenLabelPropertyRef_pos(scope,attr) ::= "(<scope>!=null?<scope>.CharPositionInLine:0)"
+tokenLabelPropertyRef_channel(scope,attr) ::= "(<scope>!=null?<scope>.Channel:0)"
+tokenLabelPropertyRef_index(scope,attr) ::= "(<scope>!=null?<scope>.TokenIndex:0)"
+tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
+tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?int.Parse(<scope>.Text):0)"
+
+ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):default(<labelType>))"
+ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):default(<labelType>))"
+ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):default(<ASTLabelType>))"
+ruleLabelPropertyRef_text(scope,attr) ::= <%
+<if(TREE_PARSER)>
+(<scope>!=null?(input.TokenStream.ToString(
+  input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
+  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):default(string))
+<else>
+(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):default(string))
+<endif>
+%>
+
+ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?<scope>.Template:null)"
+
+/** Isolated $RULE ref ok in lexer as it's a Token */
+lexerRuleLabel(label) ::= "<label>"
+
+lexerRuleLabelPropertyRef_type(scope,attr) ::=
+    "(<scope>!=null?<scope>.Type:0)"
+
+lexerRuleLabelPropertyRef_line(scope,attr) ::=
+    "(<scope>!=null?<scope>.Line:0)"
+
+lexerRuleLabelPropertyRef_pos(scope,attr) ::=
+    "(<scope>!=null?<scope>.CharPositionInLine:-1)"
+
+lexerRuleLabelPropertyRef_channel(scope,attr) ::=
+    "(<scope>!=null?<scope>.Channel:0)"
+
+lexerRuleLabelPropertyRef_index(scope,attr) ::=
+    "(<scope>!=null?<scope>.TokenIndex:0)"
+
+lexerRuleLabelPropertyRef_text(scope,attr) ::=
+    "(<scope>!=null?<scope>.Text:default(string))"
+
+lexerRuleLabelPropertyRef_int(scope,attr) ::=
+    "(<scope>!=null?int.Parse(<scope>.Text):0)"
+
+// Somebody may ref $template or $tree or $stop within a rule:
+rulePropertyRef_start(scope,attr) ::= "retval.Start"
+rulePropertyRef_stop(scope,attr) ::= "retval.Stop"
+rulePropertyRef_tree(scope,attr) ::= "retval.Tree"
+rulePropertyRef_text(scope,attr) ::= <%
+<if(TREE_PARSER)>
+input.TokenStream.ToString(
+  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
+  input.TreeAdaptor.GetTokenStopIndex(retval.Start))
+<else>
+input.ToString(retval.Start,input.LT(-1))
+<endif>
+%>
+rulePropertyRef_st(scope,attr) ::= "retval.Template"
+
+lexerRulePropertyRef_text(scope,attr) ::= "Text"
+lexerRulePropertyRef_type(scope,attr) ::= "_type"
+lexerRulePropertyRef_line(scope,attr) ::= "state.tokenStartLine"
+lexerRulePropertyRef_pos(scope,attr) ::= "state.tokenStartCharPositionInLine"
+lexerRulePropertyRef_index(scope,attr) ::= "-1" // undefined token index in lexer
+lexerRulePropertyRef_channel(scope,attr) ::= "_channel"
+lexerRulePropertyRef_start(scope,attr) ::= "state.tokenStartCharIndex"
+lexerRulePropertyRef_stop(scope,attr) ::= "(CharIndex-1)"
+lexerRulePropertyRef_int(scope,attr) ::= "int.Parse(<scope>.Text)"
+
+// setting $st and $tree is allowed in local rule. everything else
+// is flagged as error
+ruleSetPropertyRef_tree(scope,attr,expr) ::= "retval.Tree = <expr>;"
+ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.Template =<expr>;"
+
+/** How to execute an action (only when not backtracking) */
+execAction(action) ::= <%
+<if(backtracking)>
+if (<actions.(actionScope).synpredgate>)<\n>
+{<\n>
+<@indentedAction()><\n>
+}
+<else>
+<action>
+<endif>
+%>
+
+@execAction.indentedAction() ::= <<
+	<action>
+>>
+
+/** How to always execute an action even when backtracking */
+execForcedAction(action) ::= "<action>"
+
+// M I S C (properties, etc...)
+
+bitset(name, words64) ::= <<
+public static readonly BitSet <name> = new BitSet(new ulong[]{<words64:{it|<it>UL};separator=",">});
+>>
+
+codeFileExtension() ::= ".cs"
+
+true_value() ::= "true"
+false_value() ::= "false"
diff --git a/build/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg b/build/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
new file mode 100644
index 0000000..c250e44
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
@@ -0,0 +1,312 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/** Template overrides to add debugging to normal Java output;
+ *  If ASTs are built, then you'll also get ASTDbg.stg loaded.
+ */
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+using Antlr.Runtime.Debug;
+using IOException = System.IO.IOException;
+>>
+
+@genericParser.members() ::= <<
+<if(grammar.grammarIsRoot)>
+public static readonly string[] ruleNames =
+	new string[]
+	{
+		"invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n	", separator=", ">
+	};<\n>
+<endif>
+<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
+int ruleLevel = 0;
+public virtual int RuleLevel { get { return ruleLevel; } }
+public virtual void IncRuleLevel() { ruleLevel++; }
+public virtual void DecRuleLevel() { ruleLevel--; }
+<if(profile)>
+<ctorForProfilingRootGrammar()>
+<else>
+<ctorForRootGrammar()>
+<endif>
+<ctorForPredefinedListener()>
+<else><! imported grammar !>
+public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
+public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
+public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
+<ctorForDelegateGrammar()>
+<endif>
+<if(profile)>
+public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
+{
+	int stopIndex = GetRuleMemoization(ruleIndex, input.Index);
+	((Profiler)dbg).ExamineRuleMemoization(input, ruleIndex, stopIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	return base.AlreadyParsedRule(input, ruleIndex);
+}<\n>
+public override void Memoize( IIntStream input, int ruleIndex, int ruleStartIndex )
+{
+	((Profiler)dbg).Memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	base.Memoize(input, ruleIndex, ruleStartIndex);
+}<\n>
+<endif>
+protected virtual bool EvalPredicate( bool result, string predicate )
+{
+	dbg.SemanticPredicate( result, predicate );
+	return result;
+}<\n>
+>>
+
+ctorForRootGrammar() ::= <<
+<! bug: can't use <@super.members()> cut-n-paste instead !>
+<! Same except we add port number and profile stuff if root grammar !>
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
+	: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
+	: base( input, state )
+{
+	<createListenerAndHandshake()>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
+	<@finally()>
+}<\n>
+>>
+
+ctorForProfilingRootGrammar() ::= <<
+<! bug: can't use <@super.members()> cut-n-paste instead !>
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
+	: this( input, new Profiler(null), new RecognizerSharedState() )
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
+	: base( input, dbg, state )
+{
+	Profiler p = (Profiler)dbg;
+	p.setParser(this);
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>( input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
+	<@finally()>
+}
+<\n>
+>>
+
+/** Basically we don't want to set any dbg listeners are root will have it. */
+ctorForDelegateGrammar() ::= <<
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+	: base( input, dbg, state )
+{
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>( input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}> );}; separator="\n">
+	<parserCtorBody()>
+}<\n>
+>>
+
+ctorForPredefinedListener() ::= <<
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg )
+	<@superClassRef>: base( input, dbg, new RecognizerSharedState() )<@end>
+{
+<if(profile)>
+	Profiler p = (Profiler)dbg;
+	p.setParser(this);
+<endif>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	<parserCtorBody()>
+	<@finally()>
+}<\n>
+>>
+
+createListenerAndHandshake() ::= <<
+<if(TREE_PARSER)>
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, input.TreeAdaptor );<\n>
+<else>
+DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, null );<\n>
+<endif>
+DebugListener = proxy;
+try
+{
+	proxy.Handshake();
+}
+catch ( IOException ioe )
+{
+	ReportError( ioe );
+}
+>>
+
+@genericParser.superClassName() ::= "Debug<@super.superClassName()>"
+
+/*
+ * Much of the following rules were merged into CSharp3.stg.
+ */
+
+@rule.preamble() ::= <<
+if (RuleLevel == 0)
+	DebugListener.Commence();
+IncRuleLevel();
+>>
+//@rule.preamble() ::= <<
+//try
+//{
+//	dbg.EnterRule( GrammarFileName, "<ruleName>" );
+//	if ( RuleLevel == 0 )
+//	{
+//		dbg.Commence();
+//	}
+//	IncRuleLevel();
+//	dbg.Location( <ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine> );<\n>
+//>>
+
+@rule.postamble() ::= <<
+DecRuleLevel();
+if (RuleLevel == 0)
+	DebugListener.Terminate();
+>>
+//@rule.postamble() ::= <<
+//dbg.Location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
+//}
+//finally
+//{
+//	dbg.ExitRule( GrammarFileName, "<ruleName>" );
+//	DecRuleLevel();
+//	if ( RuleLevel == 0 )
+//	{
+//		dbg.Terminate();
+//	}
+//}<\n>
+//>>
+
+//@insertSynpreds.start() ::= "dbg.BeginBacktrack( state.backtracking );"
+//@insertSynpreds.stop() ::= "dbg.EndBacktrack( state.backtracking, success );"
+
+// Common debug event triggers used by region overrides below
+
+//enterSubRule() ::= <<
+//try
+//{
+//	dbg.EnterSubRule( <decisionNumber> );<\n>
+//>>
+
+//exitSubRule() ::= <<
+//}
+//finally
+//{
+//	dbg.ExitSubRule( <decisionNumber> );
+//}<\n>
+//>>
+
+//enterDecision() ::= <<
+//try
+//{
+//	dbg.EnterDecision( <decisionNumber> );<\n>
+//>>
+
+//exitDecision() ::= <<
+//}
+//finally
+//{
+//	dbg.ExitDecision( <decisionNumber> );
+//}<\n>
+//>>
+
+//enterAlt(n) ::= "dbg.EnterAlt( <n> );<\n>"
+
+// Region overrides that tell various constructs to add debugging triggers
+
+//@block.predecision() ::= "<enterSubRule()><enterDecision()>"
+
+//@block.postdecision() ::= "<exitDecision()>"
+
+//@block.postbranch() ::= "<exitSubRule()>"
+
+//@ruleBlock.predecision() ::= "<enterDecision()>"
+
+//@ruleBlock.postdecision() ::= "<exitDecision()>"
+
+//@ruleBlockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
+
+//@blockSingleAlt.prealt() ::= "<enterAlt(n=\"1\")>"
+
+//@positiveClosureBlock.preloop() ::= "<enterSubRule()>"
+
+//@positiveClosureBlock.postloop() ::= "<exitSubRule()>"
+
+//@positiveClosureBlock.predecision() ::= "<enterDecision()>"
+
+//@positiveClosureBlock.postdecision() ::= "<exitDecision()>"
+
+//@positiveClosureBlock.earlyExitException() ::=
+//	"dbg.RecognitionException( eee<decisionNumber> );<\n>"
+
+//@closureBlock.preloop() ::= "<enterSubRule()>"
+
+//@closureBlock.postloop() ::= "<exitSubRule()>"
+
+//@closureBlock.predecision() ::= "<enterDecision()>"
+
+//@closureBlock.postdecision() ::= "<exitDecision()>"
+
+//@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"
+
+//@element.prematch() ::=
+//	"dbg.Location( <it.line>, <it.pos> );"
+
+//@matchSet.mismatchedSetException() ::=
+//	"dbg.RecognitionException( mse );"
+
+//@dfaState.noViableAltException() ::= "dbg.RecognitionException( nvae );"
+
+//@dfaStateSwitch.noViableAltException() ::= "dbg.RecognitionException( nvae );"
+
+//dfaDecision(decisionNumber,description) ::= <<
+//try
+//{
+//	isCyclicDecision = true;
+//	<super.dfaDecision(...)>
+//}
+//catch ( NoViableAltException nvae )
+//{
+//	dbg.RecognitionException( nvae );
+//	throw nvae;
+//}
+//>>
+
+//@cyclicDFA.errorMethod() ::= <<
+//public override void Error( NoViableAltException nvae )
+//{
+//	((DebugParser)recognizer).dbg.RecognitionException( nvae );
+//}
+//>>
+
+/** Force predicate validation to trigger an event */
+evalPredicate(pred,description) ::= <<
+EvalPredicate(<pred>, "<description>")
+>>
diff --git a/build/Bootstrap/Codegen/Templates/CSharp3/ST.stg b/build/Bootstrap/Codegen/Templates/CSharp3/ST.stg
new file mode 100644
index 0000000..fd1322f
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/CSharp3/ST.stg
@@ -0,0 +1,153 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Pixel Mine, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+/** Template subgroup to add template rewrite output
+ *  If debugging, then you'll also get STDbg.stg loaded.
+ */
+
+@outputFile.imports() ::= <<
+<@super.imports()>
+using Antlr3.ST;
+using Antlr3.ST.Language;
+>>
+
+@genericParser.members() ::= <<
+<@super.members()>
+private StringTemplateGroup _templateGroup = new StringTemplateGroup("<name>Templates", typeof(AngleBracketTemplateLexer) );
+
+public StringTemplateGroup TemplateGroup
+{
+	get { return _templateGroup; }
+	set { _templateGroup = value; }
+}
+>>
+
+ruleReturnBaseType() ::= <%
+Template<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<StringTemplate, <labelType>>
+%>
+
+/** x+=rule when output=template */
+ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<ruleRef(...)>
+<listLabelElem(elem={<label>.Template},elemType="StringTemplate",...)>
+>>
+
+rewriteTemplate(alts) ::= <<
+
+// TEMPLATE REWRITE
+<if(backtracking)>
+if (<actions.(actionScope).synpredgate>)
+{
+	<alts:rewriteTemplateAlt(); separator="else ">
+	<if(rewriteMode)><replaceTextInLine()><endif>
+}
+<else>
+<alts:rewriteTemplateAlt(); separator="else ">
+<if(rewriteMode)><replaceTextInLine()><endif>
+<endif>
+>>
+
+replaceTextInLine() ::= <<
+<if(TREE_PARSER)>
+((TokenRewriteStream)input.TokenStream).Replace(
+	input.TreeAdaptor.GetTokenStartIndex(retval.Start),
+	input.TreeAdaptor.GetTokenStopIndex(retval.Start),
+	retval.Template);
+<else>
+((TokenRewriteStream)input).Replace(
+	retval.Start.TokenIndex,
+	input.LT(-1).TokenIndex,
+	retval.Template);
+<endif>
+>>
+
+rewriteTemplateAlt(it) ::= <<
+// <it.description>
+<if(it.pred)>
+if (<it.pred>)
+{
+	retval.Template = <it.alt>;
+}<\n>
+<else>
+{
+	retval.Template = <it.alt>;
+}<\n>
+<endif>
+>>
+
+rewriteEmptyTemplate(alts) ::= <<
+null;
+>>
+
+/** Invoke a template with a set of attribute name/value pairs.
+ *  Set the value of the rule's template *after* having set
+ *  the attributes because the rule's template might be used as
+ *  an attribute to build a bigger template; you get a self-embedded
+ *  template.
+ */
+rewriteExternalTemplate(name,args) ::= <%
+TemplateGroup.GetInstanceOf("<name>"<optionalArguments(args)>)
+%>
+
+/** expr is a string expression that says what template to load */
+rewriteIndirectTemplate(expr,args) ::= <%
+TemplateGroup.GetInstanceOf(<expr><optionalArguments(args)>)
+%>
+
+/** Invoke an inline template with a set of attribute name/value pairs */
+rewriteInlineTemplate(args, template) ::= <%
+new StringTemplate(TemplateGroup, "<template>"<optionalArguments(args)>)
+%>
+
+optionalArguments(args) ::= <<
+<if(args)>,
+	new Dictionary\<string, object>() { <args:optionalArgument(); separator=", "> }
+<endif>
+>>
+
+optionalArgument(it) ::= <<
+{"<it.name>", <it.value>}
+>>
+
+/** plain -> {foo} action */
+rewriteAction(action) ::= <<
+<action>
+>>
+
+/** An action has %st.attrName=expr; or %{st}.attrName=expr; */
+actionSetAttribute(st,attrName,expr) ::= <<
+(<st>).SetAttribute("<attrName>",<expr>);
+>>
+
+/** Translate %{stringExpr} */
+actionStringConstructor(stringExpr) ::= <<
+new StringTemplate(TemplateGroup,<stringExpr>)
+>>
diff --git a/build/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg b/build/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg
new file mode 100644
index 0000000..e39b1b6
--- /dev/null
+++ b/build/Bootstrap/Codegen/Templates/LeftRecursiveRules.stg
@@ -0,0 +1,82 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2010 Terence Parr
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** How to generate rules derived from left-recursive rules.
+ *  These rely on recRuleDefArg(), recRuleAltPredicate(),
+ *  recRuleArg(), recRuleSetResultAction(), recRuleSetReturnAction()
+ *  templates in main language.stg
+ */
+group LeftRecursiveRules;
+
+recRuleName(ruleName) ::= "<ruleName>_"
+recPrimaryName(ruleName) ::= "<ruleName>_primary"
+
+recRuleStart(ruleName, minPrec, userRetvals, userRetvalAssignments) ::= <<
+<ruleName><if(userRetvals)> returns [<userRetvals>]<endif>
+  : <recRuleName(...)>[<minPrec>]
+    <if(userRetvals)>
+    {
+        <userRetvalAssignments; separator="\n">
+    }
+    <endif>
+  ;
+>>
+
+recRule(ruleName, precArgDef, argName, alts, setResultAction, buildAST,
+        userRetvals, userRetvalAssignments) ::= <<
+<recRuleName(...)>[<precArgDef>]<if(userRetvals)> returns [<userRetvals>]<endif>
+    :   <recPrimaryName(...)>
+        <if(buildAST)>
+        {
+            <setResultAction>
+        }
+        <endif>
+        <if(userRetvals)>
+        {
+            <userRetvalAssignments; separator="\n">
+        }
+        <endif>
+        ( options {backtrack=false;}
+        : ( options {backtrack=false;}
+          : <alts; separator="\n          | ">
+          )
+        )*
+    ;
+>>
+
+recPrimaryRule(ruleName, alts, userRetvals) ::= <<
+<recPrimaryName(...)><if(userRetvals)> returns [<userRetvals>]<endif>
+options {backtrack=true;}
+    : <alts; separator="\n    | ">
+    ;
+>>
+
+recRuleAlt(alt, pred) ::= "{<pred>}?=> <alt>"
+
+recRuleRef(ruleName, arg) ::= "<recRuleName(...)>[<arg>]"
+
diff --git a/build/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll b/build/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll
new file mode 100644
index 0000000..625f969
Binary files /dev/null and b/build/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll differ
diff --git a/build/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/build/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
new file mode 100644
index 0000000..35279af
Binary files /dev/null and b/build/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ
diff --git a/build/Bootstrap/Tool/Templates/depend.stg b/build/Bootstrap/Tool/Templates/depend.stg
new file mode 100644
index 0000000..c093054
--- /dev/null
+++ b/build/Bootstrap/Tool/Templates/depend.stg
@@ -0,0 +1,12 @@
+/** templates used to generate make-compatible dependencies */
+group depend;
+
+/** Generate "f : x, y, z" dependencies for input
+ *  dependencies and generated files. in and out
+ *  are File objects.  For example, you can say
+ *  <f.canonicalPath>
+ */
+dependencies(grammarFileName,in,out) ::= <<
+<if(in)><grammarFileName>: <in; separator=", "><endif>
+<out:{f | <f> : <grammarFileName>}; separator="\n">
+>>
diff --git a/build/Bootstrap/Tool/Templates/dot/dot.stg b/build/Bootstrap/Tool/Templates/dot/dot.stg
new file mode 100644
index 0000000..efcac2c
--- /dev/null
+++ b/build/Bootstrap/Tool/Templates/dot/dot.stg
@@ -0,0 +1,73 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+dfa(decisionRanks,states,edges,rankdir,startState,useBox) ::= <<
+digraph NFA {
+<if(rankdir)>rankdir=<rankdir>;<endif>
+<decisionRanks; separator="\n">
+<states; separator="\n">
+<edges; separator="\n">
+}
+>>
+
+nfa(decisionRanks,states,edges,rankdir,startState) ::= <<
+digraph NFA {
+rankdir=LR;
+<decisionRanks; separator="\n">
+<states; separator="\n">
+<edges; separator="\n">
+}
+>>
+
+decision-rank(states) ::= <<
+{rank=same; rankdir=TB; <states; separator="; ">}
+>>
+
+edge(src,target,label,arrowhead) ::= <<
+<src> -> <target> [fontsize=11, fontname="Courier", arrowsize=.7, label = "<label>"<if(arrowhead)>, arrowhead = <arrowhead><endif>];
+>>
+
+action-edge(src,target,label,arrowhead) ::= <<
+<src> -> <target> [fontsize=11, fontname="Courier", arrowsize=.7, label = "<label>"<if(arrowhead)>, arrowhead = <arrowhead><endif>];
+>>
+
+epsilon-edge(src,target,label,arrowhead) ::= <<
+<src> -> <target> [fontname="Times-Italic", label = "e"];
+>>
+
+state(name,useBox) ::= <<
+node [fontsize=11, shape = <if(useBox)>box<else>circle, fixedsize=true, width=.4<endif>]; <name>
+>>
+
+stopstate(name,useBox) ::= <<
+node [fontsize=11, shape = <if(useBox)>polygon,sides=4,peripheries=2<else>doublecircle, fixedsize=true, width=.6<endif>]; <name>
+>>
diff --git a/build/Bootstrap/Tool/Templates/messages/formats/antlr.stg b/build/Bootstrap/Tool/Templates/messages/formats/antlr.stg
new file mode 100644
index 0000000..9fb4612
--- /dev/null
+++ b/build/Bootstrap/Tool/Templates/messages/formats/antlr.stg
@@ -0,0 +1,42 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2006 Kay Roepke
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+/*
+ New style messages. This file contains the actual layout of the messages emitted by ANTLR.
+ The text itself is coming out of the languages/*stg files, according to the chosen locale.
+ This file contains the default format ANTLR uses.
+*/
+
+group antlr;
+
+location(file, line, column) ::= "<file>:<line>:<column>:"
+
+message(id, text) ::= "(<id>) <text>"
+
+report(location, message, type) ::= "<type>(<message.id>): <location> <message.text>"
+
+wantsSingleLineMessage() ::= "false"
\ No newline at end of file
diff --git a/build/Bootstrap/Tool/Templates/messages/formats/vs2005.stg b/build/Bootstrap/Tool/Templates/messages/formats/vs2005.stg
new file mode 100644
index 0000000..0c94e48
--- /dev/null
+++ b/build/Bootstrap/Tool/Templates/messages/formats/vs2005.stg
@@ -0,0 +1,42 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2006 Kay Roepke
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+/*
+ New style messages. This file contains the actual layout of the messages emitted by ANTLR.
+ The text itself is coming out of the languages/*stg files, according to the chosen locale.
+ This file contains the default format ANTLR uses.
+*/
+
+group antlr;
+
+location(file, line, column) ::= "<file>(<line>,<column>)"
+
+message(id, text) ::= "error <id> : <text>"
+
+report(location, message, type) ::= "<location> : <type> <message.id> : <message.text>"
+
+wantsSingleLineMessage() ::= "true"
diff --git a/build/Bootstrap/Tool/Templates/messages/languages/en.stg b/build/Bootstrap/Tool/Templates/messages/languages/en.stg
new file mode 100644
index 0000000..b5e42d5
--- /dev/null
+++ b/build/Bootstrap/Tool/Templates/messages/languages/en.stg
@@ -0,0 +1,300 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2010 Terence Parr
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+/*
+ New style messages. This file only contains the messages in English, but no
+ information about which file, line, or column it occurred in.
+ The location and message ids are taken out of the formats directory.
+														Kay Roepke
+*/
+group en_US;
+
+// TOOL ERRORS
+// file errors
+CANNOT_WRITE_FILE(arg,exception,stackTrace) ::= <<
+cannot write file <arg>: <exception>
+<stackTrace; separator="\n">
+>>
+CANNOT_CLOSE_FILE(arg,exception,stackTrace) ::= "cannot close file <arg>: <exception>"
+CANNOT_FIND_TOKENS_FILE(arg) ::= "cannot find tokens file <arg>"
+ERROR_READING_TOKENS_FILE(arg,exception,stackTrace) ::= <<
+problem reading token vocabulary file <arg>: <exception>
+<stackTrace; separator="\n">
+>>
+DIR_NOT_FOUND(arg,exception,stackTrace) ::= "directory not found: <arg>"
+OUTPUT_DIR_IS_FILE(arg,exception,stackTrace) ::= "output directory is a file: <arg>"
+CANNOT_OPEN_FILE(arg,exception,stackTrace) ::= "cannot find or open file: <arg><if(exception)>; reason: <exception><endif>"
+CIRCULAR_DEPENDENCY() ::= "your grammars contain a circular dependency and cannot be sorted into a valid build order."
+
+INTERNAL_ERROR(arg,arg2,exception,stackTrace) ::= <<
+internal error: <arg> <arg2><if(exception)>: <exception><endif>
+<stackTrace; separator="\n">
+>>
+INTERNAL_WARNING(arg) ::= "internal warning: <arg>"
+ERROR_CREATING_ARTIFICIAL_RULE(arg,exception,stackTrace) ::= <<
+problems creating lexer rule listing all tokens: <exception>
+<stackTrace; separator="\n">
+>>
+TOKENS_FILE_SYNTAX_ERROR(arg,arg2) ::=
+	"problems parsing token vocabulary file <arg> on line <arg2>"
+CANNOT_GEN_DOT_FILE(arg,exception,stackTrace) ::=
+	"cannot write DFA DOT file <arg>: <exception>"
+BAD_ACTION_AST_STRUCTURE(exception,stackTrace) ::=
+	"bad internal tree structure for action '<arg>': <exception>"
+BAD_AST_STRUCTURE(arg,exception,stackTrace) ::= <<
+bad internal tree structure '<arg>': <exception>
+<stackTrace; separator="\n">
+>>
+FILE_AND_GRAMMAR_NAME_DIFFER(arg,arg2) ::=
+  "file <arg2> contains grammar <arg>; names must be identical"
+FILENAME_EXTENSION_ERROR(arg) ::=
+  "file <arg> must end in a file extension, normally .g"
+
+// code gen errors
+MISSING_CODE_GEN_TEMPLATES(arg) ::=
+	"cannot find code generation templates <arg>.stg"
+MISSING_CYCLIC_DFA_CODE_GEN_TEMPLATES() ::=
+	"cannot find code generation cyclic DFA templates for language <arg>"
+CODE_GEN_TEMPLATES_INCOMPLETE(arg) ::=
+	"at least one code generation template missing for language <arg>"
+CANNOT_CREATE_TARGET_GENERATOR(arg,exception,stackTrace) ::=
+	"cannot create target <arg> code generator: <exception>"
+STRING_TEMPLATE_ERROR(arg,exception,stackTrace) ::=
+	"template error: <arg>"
+CANNOT_COMPUTE_SAMPLE_INPUT_SEQ() ::=
+	"cannot generate a sample input sequence from lookahead DFA"
+
+// grammar interpretation errors
+/*
+NO_VIABLE_DFA_ALT(arg,arg2) ::=
+	"no viable transition from state <arg> on <arg2> while interpreting DFA"
+*/
+
+// GRAMMAR ERRORS
+SYNTAX_ERROR(arg) ::= "syntax error: <arg>"
+RULE_REDEFINITION(arg) ::=
+	"rule <arg> redefinition"
+LEXER_RULES_NOT_ALLOWED(arg) ::=
+	"lexer rule <arg> not allowed in parser"
+PARSER_RULES_NOT_ALLOWED(arg) ::=
+	"parser rule <arg> not allowed in lexer"
+CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL(arg) ::=
+	"cannot find an attribute name in attribute declaration"
+NO_TOKEN_DEFINITION(arg) ::=
+	"no lexer rule corresponding to token: <arg>"
+UNDEFINED_RULE_REF(arg) ::=
+	"reference to undefined rule: <arg>"
+LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE(arg) ::=
+	"literal has no associated lexer rule: <arg>"
+CANNOT_ALIAS_TOKENS_IN_LEXER(arg) ::=
+	"literals are illegal in lexer tokens{} section: <arg>"
+ATTRIBUTE_REF_NOT_IN_RULE(arg,arg2) ::=
+	"reference to attribute outside of a rule: <arg><if(arg2)>.<arg2><endif>"
+UNKNOWN_ATTRIBUTE_IN_SCOPE(arg,arg2) ::=
+	"unknown attribute for <arg>: <arg2>"
+UNKNOWN_RULE_ATTRIBUTE(arg,arg2) ::=
+	"unknown attribute for rule <arg>: <arg2>"
+UNKNOWN_SIMPLE_ATTRIBUTE(arg,args2) ::=
+	"attribute is not a token, parameter, or return value: <arg>"
+ISOLATED_RULE_SCOPE(arg) ::=
+	"missing attribute access on rule scope: <arg>"
+INVALID_RULE_PARAMETER_REF(arg,arg2) ::=
+	"cannot access rule <arg>'s parameter: <arg2>"
+INVALID_RULE_SCOPE_ATTRIBUTE_REF(arg,arg2) ::=
+	"cannot access rule <arg>'s dynamically-scoped attribute: <arg2>"
+SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE(arg) ::=
+	"symbol <arg> conflicts with global dynamic scope with same name"
+WRITE_TO_READONLY_ATTR(arg,arg2,arg3) ::=
+	"cannot write to read only attribute: $<arg><if(arg2)>.<arg2><endif>"
+LABEL_CONFLICTS_WITH_RULE(arg) ::=
+	"label <arg> conflicts with rule with same name"
+LABEL_CONFLICTS_WITH_TOKEN(arg) ::=
+	"label <arg> conflicts with token with same name"
+LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE(arg,arg2) ::=
+	"label <arg> conflicts with rule <arg2>'s dynamically-scoped attribute with same name"
+LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL(arg,arg2) ::=
+	"label <arg> conflicts with rule <arg2>'s return value or parameter with same name"
+ATTRIBUTE_CONFLICTS_WITH_RULE(arg,arg2) ::=
+	"rule <arg2>'s dynamically-scoped attribute <arg> conflicts with the rule name"
+ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL(arg,arg2) ::=
+	"rule <arg2>'s dynamically-scoped attribute <arg> conflicts with<arg2>'s return value or parameter with same name"
+LABEL_TYPE_CONFLICT(arg,arg2) ::=
+	"label <arg> type mismatch with previous definition: <arg2>"
+ARG_RETVAL_CONFLICT(arg,arg2) ::=
+	"rule <arg2>'s argument <arg> conflicts a return value with same name"
+NONUNIQUE_REF(arg) ::=
+	"<arg> is a non-unique reference"
+FORWARD_ELEMENT_REF(arg) ::=
+	"illegal forward reference: <arg>"
+MISSING_RULE_ARGS(arg) ::=
+	"missing parameter(s) on rule reference: <arg>"
+RULE_HAS_NO_ARGS(arg) ::=
+	"rule <arg> has no defined parameters"
+ARGS_ON_TOKEN_REF(arg) ::=
+	"token reference <arg> may not have parameters"
+ILLEGAL_OPTION(arg) ::=
+	"illegal option <arg>"
+LIST_LABEL_INVALID_UNLESS_RETVAL_STRUCT(arg) ::=
+	"rule '+=' list labels are not allowed w/o output option: <arg>"
+UNDEFINED_TOKEN_REF_IN_REWRITE(arg) ::=
+  "reference to undefined token in rewrite rule: <arg>"
+REWRITE_ELEMENT_NOT_PRESENT_ON_LHS(arg) ::=
+  "reference to rewrite element <arg> without reference on left of ->"
+UNDEFINED_LABEL_REF_IN_REWRITE(arg) ::=
+  "reference to undefined label in rewrite rule: $<arg>"
+NO_GRAMMAR_START_RULE (arg) ::=
+  "grammar <arg>: no start rule (no rule can obviously be followed by EOF)"
+EMPTY_COMPLEMENT(arg) ::= <<
+<if(arg)>
+set complement ~<arg> is empty
+<else>
+set complement is empty
+<endif>
+>>
+UNKNOWN_DYNAMIC_SCOPE(arg) ::=
+  "unknown dynamic scope: <arg>"
+UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE(arg,arg2) ::=
+  "unknown dynamically-scoped attribute for scope <arg>: <arg2>"
+RULE_REF_AMBIG_WITH_RULE_IN_ALT(arg) ::=
+  "reference $<arg> is ambiguous; rule <arg> is enclosing rule and referenced in the production (assuming enclosing rule)"
+ISOLATED_RULE_ATTRIBUTE(arg) ::=
+  "reference to locally-defined rule scope attribute without rule name: <arg>"
+INVALID_ACTION_SCOPE(arg,arg2) ::=
+  "unknown or invalid action scope for <arg2> grammar: <arg>"
+ACTION_REDEFINITION(arg) ::=
+  "redefinition of <arg> action"
+DOUBLE_QUOTES_ILLEGAL(arg) ::=
+  "string literals must use single quotes (such as \'begin\'): <arg>"
+INVALID_TEMPLATE_ACTION(arg) ::=
+  "invalid StringTemplate % shorthand syntax: '<arg>'"
+MISSING_ATTRIBUTE_NAME() ::=
+  "missing attribute name on $ reference"
+ARG_INIT_VALUES_ILLEGAL(arg) ::=
+  "rule parameters may not have init values: <arg>"
+REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION(arg) ::=
+  "<if(arg)>rule <arg> uses <endif>rewrite syntax or operator with no output option; setting output=AST"
+AST_OP_WITH_NON_AST_OUTPUT_OPTION(arg) ::=
+  "AST operator with non-AST output option: <arg>"
+NO_RULES(arg) ::= "grammar file <arg> has no rules"
+MISSING_AST_TYPE_IN_TREE_GRAMMAR(arg) ::=
+  "tree grammar <arg> has no ASTLabelType option"
+REWRITE_FOR_MULTI_ELEMENT_ALT(arg) ::=
+  "with rewrite=true, alt <arg> not simple node or obvious tree element; text attribute for rule not guaranteed to be correct"
+RULE_INVALID_SET(arg) ::=
+  "Cannot complement rule <arg>; not a simple set or element"
+HETERO_ILLEGAL_IN_REWRITE_ALT(arg) ::=
+  "alts with rewrites can't use heterogeneous types left of ->"
+NO_SUCH_GRAMMAR_SCOPE(arg,arg2) ::=
+  "reference to undefined grammar in rule reference: <arg>.<arg2>"
+NO_SUCH_RULE_IN_SCOPE(arg,arg2) ::=
+  "rule <arg2> is not defined in grammar <arg>"
+TOKEN_ALIAS_CONFLICT(arg,arg2) ::=
+  "cannot alias <arg>; string already assigned to <arg2>"
+TOKEN_ALIAS_REASSIGNMENT(arg,arg2) ::=
+  "cannot alias <arg>; token name already assigned to <arg2>"
+TOKEN_VOCAB_IN_DELEGATE(arg,arg2) ::=
+  "tokenVocab option ignored in imported grammar <arg>"
+INVALID_IMPORT(arg,arg2) ::=
+  "<arg.grammarTypeString> grammar <arg.name> cannot import <arg2.grammarTypeString> grammar <arg2.name>"
+IMPORTED_TOKENS_RULE_EMPTY(arg,arg2) ::=
+  "no lexer rules contributed to <arg> from imported grammar <arg2>"
+IMPORT_NAME_CLASH(arg,arg2) ::=
+  "combined grammar <arg.name> and imported <arg2.grammarTypeString> grammar <arg2.name> both generate <arg2.recognizerName>; import ignored"
+AST_OP_IN_ALT_WITH_REWRITE(arg,arg2) ::=
+  "rule <arg> alt <arg2> uses rewrite syntax and also an AST operator"
+WILDCARD_AS_ROOT(arg) ::= "Wildcard invalid as root; wildcard can itself be a tree"
+CONFLICTING_OPTION_IN_TREE_FILTER(arg,arg2) ::= "option <arg>=<arg2> conflicts with tree grammar filter mode"
+ILLEGAL_OPTION_VALUE(arg, arg2) ::= "value '<arg2>' invalid for option <arg>"
+ALL_OPS_NEED_SAME_ASSOC(arg) ::= "all operators of alt <alt> of left-recursive rule must have same associativity"
+RANGE_OP_ILLEGAL(arg) ::= "the .. range operator isn't allowed in parser rules"
+
+// GRAMMAR WARNINGS
+
+GRAMMAR_NONDETERMINISM(input,conflictingAlts,paths,disabled,hasPredicateBlockedByAction) ::=
+<<
+<if(paths)>
+Decision can match input such as "<input>" using multiple alternatives:
+<paths:{ it |  alt <it.alt> via NFA path <it.states; separator=","><\n>}>
+<else>
+Decision can match input such as "<input>" using multiple alternatives: <conflictingAlts; separator=", ">
+<endif>
+<if(disabled)><\n>As a result, alternative(s) <disabled; separator=","> were disabled for that input<endif><if(hasPredicateBlockedByAction)><\n>Semantic predicates were present but were hidden by actions.<endif>
+>>
+
+DANGLING_STATE(danglingAlts,input) ::= <<
+the decision cannot distinguish between alternative(s) <danglingAlts; separator=","> for input such as "<input>"
+>>
+
+UNREACHABLE_ALTS(alts) ::= <<
+The following alternatives can never be matched: <alts; separator=","><\n>
+>>
+
+INSUFFICIENT_PREDICATES(upon,altToLocations,hasPredicateBlockedByAction) ::= <<
+Input such as "<upon>" is insufficiently covered with predicates at locations: <altToLocations.keys:{alt|alt <alt>: <altToLocations.(alt):{loc| line <loc.line>:<loc.column> at <loc.text>}; separator=", ">}; separator=", "><if(hasPredicateBlockedByAction)><\n>Semantic predicates were present but were hidden by actions.<endif>
+>>
+
+DUPLICATE_SET_ENTRY(arg) ::=
+	"duplicate token type <arg> when collapsing subrule into set"
+
+ANALYSIS_ABORTED(enclosingRule) ::= <<
+ANTLR could not analyze this decision in rule <enclosingRule>; often this is because of recursive rule references visible from the left edge of alternatives.  ANTLR will re-analyze the decision with a fixed lookahead of k=1.  Consider using "options {k=1;}" for that decision and possibly adding a syntactic predicate.
+>>
+
+RECURSION_OVERLOW(alt,input,targetRules,callSiteStates) ::= <<
+Alternative <alt>: after matching input such as <input> decision cannot predict what comes next due to recursion overflow <targetRules,callSiteStates:{t,c|to <t> from <c:{s|<s.enclosingRule.name>};separator=", ">}; separator=" and ">
+>>
+
+LEFT_RECURSION(targetRules,alt,callSiteStates) ::= <<
+Alternative <alt> discovers infinite left-recursion <targetRules,callSiteStates:{t,c|to <t> from <c:{s|<s.enclosingRule>};separator=", ">}; separator=" and ">
+>>
+
+UNREACHABLE_TOKENS(tokens) ::= <<
+The following token definitions can never be matched because prior tokens match the same input: <tokens; separator=",">
+>>
+
+TOKEN_NONDETERMINISM(input,conflictingTokens,paths,disabled,hasPredicateBlockedByAction) ::=
+<<
+<if(paths)>
+Decision can match input such as "<input>" using multiple alternatives:
+<paths:{ it | alt <it.alt> via NFA path <it.states; separator=","><\n>}>
+<else>
+Multiple token rules can match input such as "<input>": <conflictingTokens; separator=", "><\n>
+<endif>
+<if(disabled)><\n>As a result, token(s) <disabled; separator=","> were disabled for that input<endif><if(hasPredicateBlockedByAction)><\n>Semantic predicates were present but were hidden by actions.<endif>
+>>
+
+LEFT_RECURSION_CYCLES(listOfCycles) ::= <<
+The following sets of rules are mutually left-recursive <listOfCycles:{c| [<c:{r|<r.name>}; separator=", ">]}; separator=" and ">
+>>
+
+NONREGULAR_DECISION(ruleName,alts) ::= <<
+[fatal] rule <ruleName> has non-LL(*) decision due to recursive rule invocations reachable from alts <alts; separator=",">.  Resolve by left-factoring or using syntactic predicates or using backtrack=true option.
+>>
+
+/* l10n for message levels */
+warning() ::= "warning"
+error() ::= "error"
diff --git a/build/prep/7z.dll b/build/prep/7z.dll
new file mode 100644
index 0000000..8e8be61
Binary files /dev/null and b/build/prep/7z.dll differ
diff --git a/build/prep/7z.exe b/build/prep/7z.exe
new file mode 100644
index 0000000..aec56e4
Binary files /dev/null and b/build/prep/7z.exe differ
diff --git a/build/prep/Antlr3.Runtime.Debug.nuspec b/build/prep/Antlr3.Runtime.Debug.nuspec
new file mode 100644
index 0000000..48ada48
--- /dev/null
+++ b/build/prep/Antlr3.Runtime.Debug.nuspec
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="utf-8"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
+  <metadata>
+    <id>Antlr3.Runtime.Debug</id>
+    <version>0.0.0</version>
+    <authors>Sam Harwell, Terence Parr</authors>
+    <owners>Sam Harwell</owners>
+    <description>The runtime library for parsers generated by the C# target of ANTLR 3. This package supports projects targeting .NET 2.0 or newer, and built using Visual Studio 2008 or newer.</description>
+    <language>en-us</language>
+    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
+    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
+    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
+    <copyright>Copyright Â© Sam Harwell 2013</copyright>
+    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$version$</releaseNotes>
+    <requireLicenseAcceptance>true</requireLicenseAcceptance>
+    <tags>antlr antlr3 parsing</tags>
+    <title>ANTLR 3 Runtime</title>
+    <summary>The runtime library for parsers generated by the C# target of ANTLR 3.</summary>
+    <dependencies>
+      <dependency id="Antlr3.Runtime" version="$version$" />
+    </dependencies>
+  </metadata>
+  <files>
+    <!-- Runtime Libraries -->
+
+    <file src="Tool\Antlr3.Runtime.Debug.dll" target="lib\net20"/>
+    <file src="Tool\Antlr3.Runtime.Debug.pdb" target="lib\net20"/>
+    <file src="Tool\Antlr3.Runtime.Debug.xml" target="lib\net20"/>
+
+    <!-- Source Code -->
+
+    <file exclude="..\..\Runtime\Antlr3.Runtime.Debug\obj\**\*.cs" src="..\..\Runtime\Antlr3.Runtime.Debug\**\*.cs" target="src"/>
+  </files>
+</package>
diff --git a/build/prep/Antlr3.Runtime.nuspec b/build/prep/Antlr3.Runtime.nuspec
new file mode 100644
index 0000000..4ebbba2
--- /dev/null
+++ b/build/prep/Antlr3.Runtime.nuspec
@@ -0,0 +1,31 @@
+<?xml version="1.0" encoding="utf-8"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
+  <metadata>
+    <id>Antlr3.Runtime</id>
+    <version>0.0.0</version>
+    <authors>Sam Harwell, Terence Parr</authors>
+    <owners>Sam Harwell</owners>
+    <description>The runtime library for parsers generated by the C# target of ANTLR 3. This package supports projects targeting .NET 2.0 or newer, and built using Visual Studio 2008 or newer.</description>
+    <language>en-us</language>
+    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
+    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
+    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
+    <copyright>Copyright Â© Sam Harwell 2013</copyright>
+    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$version$</releaseNotes>
+    <requireLicenseAcceptance>true</requireLicenseAcceptance>
+    <tags>antlr antlr3 parsing</tags>
+    <title>ANTLR 3 Runtime</title>
+    <summary>The runtime library for parsers generated by the C# target of ANTLR 3.</summary>
+  </metadata>
+  <files>
+    <!-- Runtime Libraries -->
+
+    <file src="Runtime\Antlr3.Runtime.dll" target="lib\net20"/>
+    <file src="Runtime\Antlr3.Runtime.pdb" target="lib\net20"/>
+    <file src="Runtime\Antlr3.Runtime.xml" target="lib\net20"/>
+
+    <!-- Source Code -->
+
+    <file exclude="..\..\Runtime\Antlr3.Runtime\obj\**\*.cs" src="..\..\Runtime\Antlr3.Runtime\**\*.cs" target="src"/>
+  </files>
+</package>
diff --git a/build/prep/Antlr3.nuspec b/build/prep/Antlr3.nuspec
new file mode 100644
index 0000000..195d813
--- /dev/null
+++ b/build/prep/Antlr3.nuspec
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
+  <metadata minClientVersion="2.5">
+    <id>Antlr3</id>
+    <version>0.0.0</version>
+    <authors>Sam Harwell, Terence Parr</authors>
+    <owners>Sam Harwell</owners>
+    <description>The C# target of the ANTLR 3 parser generator. This package supports projects targeting .NET 2.0 or newer, and built using Visual Studio 2008 or newer.</description>
+    <language>en-us</language>
+    <projectUrl>https://github.com/sharwell/antlr4cs</projectUrl>
+    <licenseUrl>https://raw.github.com/sharwell/antlr4cs/master/LICENSE.txt</licenseUrl>
+    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
+    <copyright>Copyright Â© Sam Harwell 2013</copyright>
+    <releaseNotes>https://github.com/sharwell/antlr4cs/releases/v$version$</releaseNotes>
+    <requireLicenseAcceptance>true</requireLicenseAcceptance>
+    <tags>antlr antlr3 parsing</tags>
+    <title>ANTLR 3</title>
+    <summary>The C# target of the ANTLR 3 parser generator.</summary>
+    <dependencies>
+      <dependency id="Antlr3.Runtime" version="$version$" />
+      <dependency id="Antlr3.Runtime.Debug" version="$version$" />
+      <dependency id="StringTemplate3" version="$version$" />
+    </dependencies>
+  </metadata>
+  <files>
+    <!-- Tools -->
+
+    <file src="Bootstrap\**\*.*" target="tools"/>
+
+    <!-- Build Configuration -->
+
+    <file src="Tool\Antlr3.props" target="build"/>
+    <file src="Tool\Antlr3.targets" target="build"/>
+    <file src="Tool\AntlrBuildTask.dll" target="build"/>
+  </files>
+</package>
diff --git a/build/prep/LICENSE.txt b/build/prep/LICENSE.txt
new file mode 100644
index 0000000..f63a069
--- /dev/null
+++ b/build/prep/LICENSE.txt
@@ -0,0 +1,27 @@
+[The "BSD license"]
+Copyright (c) 2011 Terence Parr
+C# Port (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+ 1. Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+    derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/build/prep/NuGet.exe b/build/prep/NuGet.exe
new file mode 100644
index 0000000..be85ec2
Binary files /dev/null and b/build/prep/NuGet.exe differ
diff --git a/build/prep/StringTemplate3.nuspec b/build/prep/StringTemplate3.nuspec
new file mode 100644
index 0000000..488c5e3
--- /dev/null
+++ b/build/prep/StringTemplate3.nuspec
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
+  <metadata>
+    <id>StringTemplate3</id>
+    <version>0.0.0</version>
+    <authors>Sam Harwell, Terence Parr</authors>
+    <owners>Sam Harwell</owners>
+    <description>The C# port of StringTemplate 3.</description>
+    <language>en-us</language>
+    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
+    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
+    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
+    <copyright>Copyright Â© Sam Harwell 2013</copyright>
+    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$ANTLRVersion$</releaseNotes>
+    <requireLicenseAcceptance>true</requireLicenseAcceptance>
+    <tags>stringtemplate st3 stringtemplate3 template</tags>
+    <title>StringTemplate 3</title>
+    <summary>The C# port of StringTemplate 3.</summary>
+    <dependencies>
+      <dependency id="Antlr3.Runtime" version="$ANTLRVersion$" />
+    </dependencies>
+  </metadata>
+  <files>
+    <!-- Runtime Libraries -->
+
+    <file src="ST3\Antlr3.StringTemplate.dll" target="lib\net35-client"/>
+    <file src="ST3\Antlr3.StringTemplate.pdb" target="lib\net35-client"/>
+    <file src="ST3\Antlr3.StringTemplate.xml" target="lib\net35-client"/>
+
+    <!-- Source Code -->
+
+    <file exclude="..\..\Antlr3.StringTemplate\obj\**\*.cs" src="..\..\Antlr3.StringTemplate\**\*.cs" target="src"/>
+    <file src="..\..\Antlr3.StringTemplate\obj\$Configuration$\**\*.cs" target="src\obj\$Configuration$"/>
+    <file src="..\..\Antlr3.StringTemplate\obj\$Configuration$\**\*.tokens" target="src\obj\$Configuration$"/>
+  </files>
+</package>
diff --git a/build/prep/StringTemplate4.Visualizer.nuspec b/build/prep/StringTemplate4.Visualizer.nuspec
new file mode 100644
index 0000000..68984d6
--- /dev/null
+++ b/build/prep/StringTemplate4.Visualizer.nuspec
@@ -0,0 +1,38 @@
+<?xml version="1.0" encoding="utf-8"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
+  <metadata>
+    <id>StringTemplate4.Visualizer</id>
+    <version>0.0.0</version>
+    <authors>Sam Harwell, Terence Parr</authors>
+    <owners>Sam Harwell</owners>
+    <description>Provides the visualizer runtime for StringTemplate 4.</description>
+    <language>en-us</language>
+    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
+    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
+    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
+    <copyright>Copyright Â© Sam Harwell 2013</copyright>
+    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$ANTLRVersion$</releaseNotes>
+    <requireLicenseAcceptance>true</requireLicenseAcceptance>
+    <tags>stringtemplate st4 stringtemplate4 stviz template</tags>
+    <title>StringTemplate 4 Visualizer</title>
+    <summary>Provides the visualizer runtime for StringTemplate 4.</summary>
+    <dependencies>
+      <dependency id="Antlr3.Runtime" version="$ANTLRVersion$" />
+      <dependency id="StringTemplate4" version="$version$" />
+    </dependencies>
+  </metadata>
+  <files>
+    <!-- Runtime Libraries -->
+
+    <file src="ST4\Antlr4.StringTemplate.Visualizer.dll" target="lib\net35-client"/>
+    <file src="ST4\Antlr4.StringTemplate.Visualizer.pdb" target="lib\net35-client"/>
+    <file src="ST4\Antlr4.StringTemplate.Visualizer.xml" target="lib\net35-client"/>
+
+    <!-- Source Code -->
+
+    <file exclude="..\..\Antlr4.StringTemplate.Visualizer\obj\**\*.cs" src="..\..\Antlr4.StringTemplate.Visualizer\**\*.cs" target="src"/>
+    <file src="..\..\Antlr4.StringTemplate.Visualizer\**\*.xaml" target="src"/>
+    <file src="..\..\Antlr4.StringTemplate.Visualizer\obj\$Configuration$\**\*.cs" target="src\obj\$Configuration$"/>
+    <file src="..\..\Antlr4.StringTemplate.Visualizer\obj\$Configuration$\**\*.tokens" target="src\obj\$Configuration$"/>
+  </files>
+</package>
diff --git a/build/prep/StringTemplate4.nuspec b/build/prep/StringTemplate4.nuspec
new file mode 100644
index 0000000..b2924b4
--- /dev/null
+++ b/build/prep/StringTemplate4.nuspec
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="utf-8"?>
+<package xmlns="http://schemas.microsoft.com/packaging/2010/07/nuspec.xsd">
+  <metadata>
+    <id>StringTemplate4</id>
+    <version>0.0.0</version>
+    <authors>Sam Harwell, Terence Parr</authors>
+    <owners>Sam Harwell</owners>
+    <description>The C# port of StringTemplate 4.</description>
+    <language>en-us</language>
+    <projectUrl>https://github.com/sharwell/antlrcs</projectUrl>
+    <licenseUrl>https://raw.github.com/sharwell/antlrcs/master/bin/prep/LICENSE.txt</licenseUrl>
+    <iconUrl>https://raw.github.com/antlr/website-antlr4/master/images/icons/antlr.png</iconUrl>
+    <copyright>Copyright Â© Sam Harwell 2013</copyright>
+    <releaseNotes>https://github.com/sharwell/antlrcs/releases/v$ANTLRVersion$</releaseNotes>
+    <requireLicenseAcceptance>true</requireLicenseAcceptance>
+    <tags>stringtemplate st4 stringtemplate4 template</tags>
+    <title>StringTemplate 4</title>
+    <summary>The C# port of StringTemplate 4.</summary>
+    <dependencies>
+      <dependency id="Antlr3.Runtime" version="$ANTLRVersion$" />
+    </dependencies>
+  </metadata>
+  <files>
+    <!-- Runtime Libraries -->
+
+    <file src="ST4\Antlr4.StringTemplate.dll" target="lib\net35-client"/>
+    <file src="ST4\Antlr4.StringTemplate.pdb" target="lib\net35-client"/>
+    <file src="ST4\Antlr4.StringTemplate.xml" target="lib\net35-client"/>
+
+    <!-- Source Code -->
+
+    <file exclude="..\..\Antlr4.StringTemplate\obj\**\*.cs" src="..\..\Antlr4.StringTemplate\**\*.cs" target="src"/>
+    <file src="..\..\Antlr4.StringTemplate\obj\$Configuration$\**\*.cs" target="src\obj\$Configuration$"/>
+    <file src="..\..\Antlr4.StringTemplate\obj\$Configuration$\**\*.tokens" target="src\obj\$Configuration$"/>
+  </files>
+</package>
diff --git a/build/prep/prepare.ps1 b/build/prep/prepare.ps1
new file mode 100644
index 0000000..8146cc1
--- /dev/null
+++ b/build/prep/prepare.ps1
@@ -0,0 +1,220 @@
+# build the solution
+$SolutionPath = "..\..\Antlr3.sln"
+
+# make sure the script was run from the expected path
+if (!(Test-Path $SolutionPath)) {
+  echo "The script was run from an invalid working directory."
+  exit 1
+}
+
+$BuildConfig = "Release"
+$DebugBuild = false
+
+# clean up from any previous builds
+$CleanItems = "Runtime", "Tool", "Bootstrap", "ST3", "ST4"
+$CleanItems | ForEach-Object {
+  if (Test-Path $_) {
+    Remove-Item -Force -Recurse $_
+  }
+}
+
+# build the project
+$msbuild = "C:\Windows\Microsoft.NET\Framework64\v4.0.30319\msbuild.exe"
+#if (!(Test-Path $msbuild)) {
+#    [void][System.Reflection.Assembly]::Load('Microsoft.Build.Utilities.v3.5, Version=3.5.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
+#    $msbuild = [Microsoft.Build.Utilities.ToolLocationHelper]::GetPathToDotNetFrameworkFile("msbuild.exe", "VersionLatest")
+#}
+
+&$msbuild /nologo /m /nr:false /t:rebuild /p:Configuration=$BuildConfig $SolutionPath
+if ($LASTEXITCODE -ne 0) {
+  echo "Build Failed, Aborting!"
+  exit $p.ExitCode
+}
+
+# back up the bootstrap folder
+$ArchivePath = ".\Backup\Bootstrap-" + [System.IO.Path]::GetFileNameWithoutExtension([System.IO.Path]::GetRandomFileName()) + ".7z"
+.\7z.exe a -r $ArchivePath "..\Bootstrap\*"
+
+# copy the new bootstrap files
+if ($DebugBuild) {
+  $BootstrapBinaries = "Antlr3.exe", "Antlr3.exe.config", "Antlr3.Runtime.dll", "Antlr3.Runtime.Debug.dll", "Antlr4.StringTemplate.dll", "Antlr4.StringTemplate.Visualizer.dll", "Antlr3.targets", "Antlr3.props", "AntlrBuildTask.dll"
+}
+else {
+  $BootstrapBinaries = "Antlr3.exe", "Antlr3.exe.config", "Antlr3.Runtime.dll", "Antlr3.Runtime.Debug.dll", "Antlr4.StringTemplate.dll", "Antlr3.targets", "Antlr3.props", "AntlrBuildTask.dll"
+}
+
+$BootstrapBinaries | ForEach-Object {
+    copy -force "..\..\bin\$BuildConfig\$_" "..\Bootstrap"
+    if ($LASTEXITCODE -ne 0) {
+      echo "Bootstrap update failed, Aborting!"
+      exit $p.ExitCode
+    }
+}
+
+if ($LASTEXITCODE -ne 0) {
+  echo "Bootstrap update failed, Aborting!"
+  exit $p.ExitCode
+}
+
+if (-not (Test-Path "..\Bootstrap\Codegen\Templates\CSharp2")) {
+  mkdir "..\Bootstrap\Codegen\Templates\CSharp2"
+}
+
+copy -force "..\..\bin\$BuildConfig\Codegen\Templates\LeftRecursiveRules.stg" "..\Bootstrap\Codegen\Templates"
+if ($LASTEXITCODE -ne 0) {
+  echo "Bootstrap update failed, Aborting!"
+  exit $p.ExitCode
+}
+
+copy -force "..\..\bin\$BuildConfig\Codegen\Templates\CSharp2\*" "..\Bootstrap\Codegen\Templates\CSharp2"
+if ($LASTEXITCODE -ne 0) {
+  echo "Bootstrap update failed, Aborting!"
+  exit $p.ExitCode
+}
+
+copy -force "..\..\bin\$BuildConfig\Codegen\Templates\CSharp3\*" "..\Bootstrap\Codegen\Templates\CSharp3"
+if ($LASTEXITCODE -ne 0) {
+  echo "Bootstrap update failed, Aborting!"
+  exit $p.ExitCode
+}
+
+copy -force "..\..\bin\$BuildConfig\Targets\Antlr3.Targets.CSharp2.dll" "..\Bootstrap\Targets"
+if ($LASTEXITCODE -ne 0) {
+  echo "Bootstrap update failed, Aborting!"
+  exit $p.ExitCode
+}
+
+copy -force "..\..\bin\$BuildConfig\Targets\Antlr3.Targets.CSharp3.dll" "..\Bootstrap\Targets"
+if ($LASTEXITCODE -ne 0) {
+  echo "Bootstrap update failed, Aborting!"
+  exit $p.ExitCode
+}
+
+copy -r -force "..\..\bin\$BuildConfig\Tool\*" "..\Bootstrap\Tool"
+if ($LASTEXITCODE -ne 0) {
+  echo "Bootstrap update failed, Aborting!"
+  exit $p.ExitCode
+}
+
+Remove-Item -force "..\Bootstrap\Tool\Templates\messages\formats\gnu.stg"
+
+# build the project again with the new bootstrap files
+&$msbuild /nologo /m /nr:false /t:rebuild /p:Configuration=$BuildConfig $SolutionPath
+if ($LASTEXITCODE -ne 0) {
+  echo "Build Failed, Aborting!"
+  exit $p.ExitCode
+}
+
+# copy files from the build
+mkdir Runtime
+mkdir Tool
+mkdir Bootstrap
+mkdir ST3
+mkdir ST4
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.dll" ".\Runtime"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.pdb" ".\Runtime"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.xml" ".\Runtime"
+copy "LICENSE.txt" ".\Runtime"
+
+copy "..\..\bin\$BuildConfig\Antlr3.exe" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.exe.config" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.dll" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.Debug.dll" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.dll" ".\Tool"
+if ($DebugBuild) {
+  copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.Visualizer.dll" ".\Tool"
+}
+copy "..\..\bin\$BuildConfig\Antlr3.props" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.targets" ".\Tool"
+copy "..\..\bin\$BuildConfig\AntlrBuildTask.dll" ".\Tool"
+copy "LICENSE.txt" ".\Tool"
+
+copy ".\Tool\*" ".\Bootstrap"
+
+# copy ST4 binaries and all symbol files to the full Tool folder
+copy "..\..\bin\$BuildConfig\Antlr3.pdb" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.pdb" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.Debug.pdb" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.pdb" ".\Tool"
+if ($DebugBuild) {
+  copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.Visualizer.pdb" ".\Tool"
+}
+copy "..\..\bin\$BuildConfig\AntlrBuildTask.pdb" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.xml" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.xml" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.Debug.xml" ".\Tool"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.xml" ".\Tool"
+if ($DebugBuild) {
+  copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.Visualizer.xml" ".\Tool"
+}
+copy "..\..\bin\$BuildConfig\AntlrBuildTask.xml" ".\Tool"
+
+mkdir "Tool\Codegen"
+mkdir "Tool\Targets"
+mkdir "Tool\Tool"
+copy -r "..\..\bin\$BuildConfig\Codegen\*" ".\Tool\Codegen"
+copy -r "..\..\bin\$BuildConfig\Targets\*.dll" ".\Tool\Targets"
+copy -r "..\..\bin\$BuildConfig\Targets\*.pdb" ".\Tool\Targets"
+copy -r "..\..\bin\$BuildConfig\Targets\*.xml" ".\Tool\Targets"
+copy -r "..\..\bin\$BuildConfig\Tool\*" ".\Tool\Tool"
+
+mkdir "Bootstrap\Codegen\Templates\CSharp2"
+mkdir "Bootstrap\Codegen\Templates\CSharp3"
+mkdir "Bootstrap\Tool"
+mkdir "Bootstrap\Targets"
+copy "..\..\bin\$BuildConfig\Codegen\Templates\LeftRecursiveRules.stg" ".\Bootstrap\Codegen\Templates"
+copy "..\..\bin\$BuildConfig\Codegen\Templates\CSharp2\*" ".\Bootstrap\Codegen\Templates\CSharp2"
+copy "..\..\bin\$BuildConfig\Codegen\Templates\CSharp3\*" ".\Bootstrap\Codegen\Templates\CSharp3"
+copy "..\..\bin\$BuildConfig\Targets\Antlr3.Targets.CSharp2.dll" ".\Bootstrap\Targets"
+copy "..\..\bin\$BuildConfig\Targets\Antlr3.Targets.CSharp3.dll" ".\Bootstrap\Targets"
+copy -r "..\..\bin\$BuildConfig\Tool\*" ".\Bootstrap\Tool"
+Remove-Item ".\Bootstrap\Tool\Templates\messages\formats\gnu.stg"
+
+# ST3 dist
+copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.StringTemplate.dll" ".\ST3"
+copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.Runtime.dll" ".\ST3"
+copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.StringTemplate.pdb" ".\ST3"
+copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.Runtime.pdb" ".\ST3"
+copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.StringTemplate.xml" ".\ST3"
+copy "..\..\Antlr3.StringTemplate\bin\$BuildConfig\Antlr3.Runtime.xml" ".\ST3"
+copy "LICENSE.txt" ".\ST3"
+
+# ST4 dist
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.dll" ".\ST4"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.dll" ".\ST4"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.Visualizer.dll" ".\ST4"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.pdb" ".\ST4"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.pdb" ".\ST4"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.Visualizer.pdb" ".\ST4"
+copy "..\..\bin\$BuildConfig\Antlr3.Runtime.xml" ".\ST4"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.xml" ".\ST4"
+copy "..\..\bin\$BuildConfig\Antlr4.StringTemplate.Visualizer.xml" ".\ST4"
+copy "LICENSE.txt" ".\ST4"
+
+# compress the distributable packages
+$AntlrVersion = "3.5.0.3-alpha001"
+$STVersion = "4.0.7.2-alpha001"
+
+$ArchivePath = ".\dist\antlr-dotnet-csharpbootstrap-" + $AntlrVersion + ".7z"
+.\7z.exe a -r -mx9 $ArchivePath ".\Bootstrap\*"
+$ArchivePath = ".\dist\antlr-dotnet-csharpruntime-" + $AntlrVersion + ".7z"
+.\7z.exe a -r -mx9 $ArchivePath ".\Runtime\*"
+$ArchivePath = ".\dist\antlr-dotnet-tool-" + $AntlrVersion + ".7z"
+.\7z.exe a -r -mx9 $ArchivePath ".\Tool\*"
+$ArchivePath = ".\dist\antlr-dotnet-st3-" + $AntlrVersion + ".7z"
+.\7z.exe a -r -mx9 $ArchivePath ".\ST3\*"
+$ArchivePath = ".\dist\antlr-dotnet-st4-" + $STVersion + ".7z"
+.\7z.exe a -r -mx9 $ArchivePath ".\ST4\*"
+
+# Build the NuGet packages
+
+if (-not (Test-Path nuget)) {
+  mkdir "nuget"
+}
+
+.\NuGet.exe pack .\Antlr3.Runtime.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $AntlrVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
+.\NuGet.exe pack .\Antlr3.Runtime.Debug.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $AntlrVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
+.\NuGet.exe pack .\Antlr3.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $AntlrVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
+.\NuGet.exe pack .\StringTemplate3.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $AntlrVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
+.\NuGet.exe pack .\StringTemplate4.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $STVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols
+.\NuGet.exe pack .\StringTemplate4.Visualizer.nuspec -OutputDirectory nuget -Prop Configuration=Release -Version $STVersion -Prop ANTLRVersion=$AntlrVersion -Prop STVersion=$STVersion -Symbols

