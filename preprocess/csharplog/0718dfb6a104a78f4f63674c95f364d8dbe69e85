commit 0718dfb6a104a78f4f63674c95f364d8dbe69e85
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Wed Jan 30 10:40:49 2013 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Wed Jan 30 13:19:19 2013 -0600

Merge/port many updates from antlr/stringtemplate4

diff --git a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
index 0131d43..fa81ea7 100644
--- a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
+++ b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
@@ -37,6 +37,7 @@
</ItemGroup>
<ItemGroup>
<Compile Include="Compiler\TemplateCompiler.TemplateLexerNoNewlines.cs" />
+    <Compile Include="TemplateRawGroupDirectory.cs" />
<Compile Include="Debug\IndentEvent.cs" />
<Compile Include="Extensions\ExceptionExtensions.cs" />
<Compile Include="IAttributeRenderer.cs" />
@@ -56,7 +57,7 @@
<None Include="..\..\..\..\keys\antlr\Key.snk">
<Link>Key.snk</Link>
</None>
-    <None Include="DateRenderer.cs" />
+    <Compile Include="DateRenderer.cs" />
<Compile Include="Compiler\Instruction.cs" />
<Compile Include="ITypeProxyFactory.cs" />
<Compile Include="Misc\TypeRegistry`1.cs" />
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3 b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
index a0b1398..e8f56e3 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
@@ -202,13 +202,13 @@ ifstat[CommonTree indent]
;

conditional
-	:	^('||' conditional conditional)		{emit(Bytecode.INSTR_OR);}
-	|	^('&&' conditional conditional)		{emit(Bytecode.INSTR_AND);}
-	|	^('!' conditional)					{emit(Bytecode.INSTR_NOT);}
+	:	^(OR conditional conditional)		{emit($OR, Bytecode.INSTR_OR);}
+	|	^(AND conditional conditional)		{emit($AND, Bytecode.INSTR_AND);}
+	|	^(BANG conditional)					{emit($BANG, Bytecode.INSTR_NOT);}
|	expr // not all expr are valid, but reuse code gen (parser restricts syntax)
;

-exprOptions : {emit(Bytecode.INSTR_OPTIONS);} ^(OPTIONS option*) ;
+exprOptions : {emit($start, Bytecode.INSTR_OPTIONS);} ^(OPTIONS option*) ;

option : ^('=' ID expr) {setOption($ID);} ;

diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
index 8dd2bc3..703cbec 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
@@ -106,11 +106,6 @@ namespace Antlr4.StringTemplate.Compiler
CompilationState.Emit2(opAST, opcode, s, arg2);
}

-        public void emit(Bytecode opcode)
-        {
-            CompilationState.Emit(opcode);
-        }
-
public void emit(CommonTree opAST, Bytecode opcode)
{
CompilationState.Emit(opAST, opcode);
diff --git a/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs b/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
index c62a91b..1e9b2f1 100644
--- a/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
+++ b/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
@@ -42,6 +42,8 @@ namespace Antlr4.StringTemplate.Compiler
using ArgumentException = System.ArgumentException;
using ArgumentNullException = System.ArgumentNullException;
using Console = System.Console;
+    using Math = System.Math;
+    using NotSupportedException = System.NotSupportedException;
using StringWriter = System.IO.StringWriter;

/** The result of compiling an Template.  Contains all the bytecode instructions,
@@ -321,19 +323,19 @@ namespace Antlr4.StringTemplate.Compiler
{
if (IsAnonSubtemplate)
{
-                    Interval start = sourceMap[0];
-                    Interval stop = null;
-                    for (int i = sourceMap.Length - 1; i >= 0; i--)
+                    int start = int.MaxValue;
+                    int stop = int.MinValue;
+                    foreach (Interval interval in sourceMap)
{
-                        Interval interval = sourceMap[i];
-                        if (interval != null)
-                        {
-                            stop = interval;
-                            break;
-                        }
+                        if (interval == null)
+                            continue;
+
+                        start = Math.Min(start, interval.Start);
+                        stop = Math.Max(stop, interval.End);
}

-                    return Interval.FromBounds(start.Start, stop.End);
+                    if (start <= stop + 1)
+                        return new Interval(start, stop);
}

return new Interval(0, Template.Length);
@@ -379,23 +381,32 @@ namespace Antlr4.StringTemplate.Compiler
{
if (fa.DefaultValueToken != null)
{
-                    if (fa.DefaultValueToken.Type == GroupParser.ANONYMOUS_TEMPLATE)
+                    switch (fa.DefaultValueToken.Type)
{
+                    case GroupParser.ANONYMOUS_TEMPLATE:
string argSTname = fa.Name + "_default_value";
TemplateCompiler c2 = new TemplateCompiler(group);
string defArgTemplate = Utility.Strip(fa.DefaultValueToken.Text, 1);
fa.CompiledDefaultValue = c2.Compile(group.FileName, argSTname, null, defArgTemplate, fa.DefaultValueToken);
fa.CompiledDefaultValue.Name = argSTname;
fa.CompiledDefaultValue.DefineImplicitlyDefinedTemplates(group);
-                    }
-                    else if (fa.DefaultValueToken.Type == GroupParser.STRING)
-                    {
+                        break;
+
+                    case GroupParser.STRING:
fa.DefaultValue = Utility.Strip(fa.DefaultValueToken.Text, 1);
-                    }
-                    else
-                    {
-                        // true or false
+                        break;
+
+                    case GroupParser.LBRACK:
+                        fa.DefaultValue = new object[0];
+                        break;
+
+                    case GroupParser.TRUE:
+                    case GroupParser.FALSE:
fa.DefaultValue = fa.DefaultValueToken.Type == GroupParser.TRUE;
+                        break;
+
+                    default:
+                        throw new NotSupportedException("Unexpected default value token type.");
}
}
}
diff --git a/Antlr4.StringTemplate/Compiler/Group.g3 b/Antlr4.StringTemplate/Compiler/Group.g3
index b07afbc..93ba535 100644
--- a/Antlr4.StringTemplate/Compiler/Group.g3
+++ b/Antlr4.StringTemplate/Compiler/Group.g3
@@ -40,6 +40,8 @@ tokens {
COMMA=',';
TRUE='true';
FALSE='false';
+	LBRACK='[';
+	RBRACK=']';
}

@lexer::namespace{Antlr4.StringTemplate.Compiler}
@@ -127,7 +129,11 @@ templateDef[string prefix]
template = Utility.Strip(template, n);
string templateName = $name.text;
if (prefix.Length > 0) templateName = prefix + $name.text;
-			_group.DefineTemplateOrRegion(templateName, $enclosing.text, templateToken,
+			string enclosingTemplateName = $enclosing.text;
+			if (enclosingTemplateName != null && enclosingTemplateName.Length > 0 && prefix.Length > 0)
+				enclosingTemplateName = prefix + enclosingTemplateName;
+
+			_group.DefineTemplateOrRegion(templateName, enclosingTemplateName, templateToken,
template, $name, $formalArgs.args);
}
}
@@ -145,6 +151,7 @@ bool hasOptionalParameter;
formalArg[List<FormalArgument> args]
:	ID
(	'=' a=(STRING|ANONYMOUS_TEMPLATE|'true'|'false') {$formalArgs::hasOptionalParameter = true;}
+		|	'=' a='[' ']' {$formalArgs::hasOptionalParameter = true;}
|	{if ($formalArgs::hasOptionalParameter) _group.ErrorManager.GroupSyntaxError(ErrorType.REQUIRED_PARAMETER_AFTER_OPTIONAL, SourceName, input.LT(1));}
)
{$args.Add(new FormalArgument($ID.text, $a));}
@@ -203,6 +210,7 @@ keyValue returns [object value]
|	a=STRING				{$value = Utility.ReplaceEscapes(Utility.Strip($a.text, 1));}
|	TRUE					{$value = true;}
|	FALSE					{$value = false;}
+	|	'[' ']'					{$value = new object[0];}
|	{input.LT(1).Text.Equals("key")}?=> ID
{$value = TemplateGroup.DictionaryKey;}
;
@@ -230,18 +238,19 @@ STRING
;

BIGSTRING
-	:	'<<'
-		(	options {greedy=false;}
-		:	'\\' '>'  // \> escape
-		|	'\\' ~'>'
-		|	~'\\'
-		)*
-        '>>'
-        {Text = Text.Replace("\\>",">");}
+	:	'<<' .* '>>'
+		// >\> is the escape to avoid end of string
+		{
+		Text = Text.Replace(">\\>",">>");
+		}
;

BIGSTRING_NO_NL // same as BIGSTRING but means ignore newlines later
:	'<%' .* '%>'
+		// %\> is the escape to avoid end of string
+		{
+		Text = Text.Replace("\%\\>","\%>");
+		}
;

ANONYMOUS_TEMPLATE
diff --git a/Antlr4.StringTemplate/DateRenderer.cs b/Antlr4.StringTemplate/DateRenderer.cs
index 1dd8b4e..f9ada61 100644
--- a/Antlr4.StringTemplate/DateRenderer.cs
+++ b/Antlr4.StringTemplate/DateRenderer.cs
@@ -32,52 +32,53 @@

namespace Antlr4.StringTemplate
{
+    using System;
using System.Collections.Generic;
using CultureInfo = System.Globalization.CultureInfo;

-/** A renderer for java.util.Date and Calendar objects. It understands a
- *  variety of format names as shown in formatToInt field.  By default
- *  it assumes "short" format.  A prefix of date: or time: shows only
- *  those components of the time object.
- */
-public class DateRenderer : AttributeRenderer {
-#if false
-    public static readonly IDictionary<string,int> formatToInt =
-        new Dictionary<string,int>() {
-            {
-                put("short", DateFormat.SHORT);
-                put("medium", DateFormat.MEDIUM);
-                put("long", DateFormat.LONG);
-                put("full", DateFormat.FULL);
+    /** A renderer for java.util.Date and Calendar objects. It understands a
+     *  variety of format names as shown in formatToInt field.  By default
+     *  it assumes "short" format.  A prefix of date: or time: shows only
+     *  those components of the time object.
+     */
+    public class DateRenderer : IAttributeRenderer
+    {
+        public static readonly IDictionary<string, string> formatToInt =
+            new Dictionary<string, string>() {
+                {"short", "g"},
+                {"medium", "g"},
+                {"long", "f"},
+                {"full", "F"},
+
+                {"date:short", "d"},
+                {"date:medium", "d"},
+                {"date:long", "D"},
+                {"date:full", "D"},
+
+                {"time:short", "t"},
+                {"time:medium", "t"},
+                {"time:long", "T"},
+                {"time:full", "T"},
+            };

-                put("date:short", DateFormat.SHORT);
-                put("date:medium", DateFormat.MEDIUM);
-                put("date:long", DateFormat.LONG);
-                put("date:full", DateFormat.FULL);
+        public virtual string ToString(object o, string formatString, CultureInfo locale)
+        {
+            if (formatString == null)
+                formatString = "short";

-                put("time:short", DateFormat.SHORT);
-                put("time:medium", DateFormat.MEDIUM);
-                put("time:long", DateFormat.LONG);
-                put("time:full", DateFormat.FULL);
-            }
-        };
-#endif
+            DateTimeOffset d;
+            if (o is DateTime)
+                d = (DateTime)o;
+            else if (o is DateTimeOffset)
+                d = (DateTimeOffset)o;
+            else
+                throw new ArgumentException();

-    public virtual string toString(object o, string formatString, CultureInfo locale) {
-        Date d;
-        if ( formatString==null ) formatString = "short";
-        if ( o is Calendar ) d = ((Calendar)o).getTime();
-        else d = (Date)o;
-        Integer styleI = formatToInt.get(formatString);
-        DateFormat f;
-        if ( styleI==null ) f = new SimpleDateFormat(formatString);
-        else {
-            int style = styleI.intValue();
-            if ( formatString.startsWith("date:") ) f = DateFormat.getDateInstance(style);
-            else if ( formatString.startsWith("time:") ) f = DateFormat.getTimeInstance(style);
-            else f = DateFormat.getDateTimeInstance(style, style);
+            string dateFormat;
+            if (!formatToInt.TryGetValue(formatString, out dateFormat))
+                return d.ToString(formatString, locale);
+
+            return d.ToString(dateFormat, locale);
}
-        return f.format(d);
}
}
-}
diff --git a/Antlr4.StringTemplate/Interpreter.cs b/Antlr4.StringTemplate/Interpreter.cs
index 85f308c..a6f07c5 100644
--- a/Antlr4.StringTemplate/Interpreter.cs
+++ b/Antlr4.StringTemplate/Interpreter.cs
@@ -159,6 +159,9 @@ namespace Antlr4.StringTemplate
if (frame.StackDepth > 200)
throw new TemplateException("Template stack overflow.", null);

+                if (trace)
+                    Console.Out.WriteLine("Execute({0})", frame.Template.Name);
+
SetDefaultArguments(frame);
return ExecuteImpl(@out, frame);
}
@@ -647,6 +650,7 @@ namespace Antlr4.StringTemplate
// if no default value
if (arg.DefaultValueToken == null)
{
+                            _errorManager.RuntimeError(frame, ErrorType.NO_SUCH_ATTRIBUTE_PASS_THROUGH, arg.Name);
attrs[arg.Name] = null;
}
}
@@ -656,6 +660,12 @@ namespace Antlr4.StringTemplate

internal virtual void StoreArguments(TemplateFrame frame, IDictionary<string, object> attrs, Template st)
{
+            if (attrs != null && attrs.Count > 0 &&
+                 !st.impl.HasFormalArgs && st.impl.FormalArguments == null)
+            {
+                st.Add(Template.ImplicitArgumentName, null); // pretend we have "it" arg
+            }
+
int nformalArgs = 0;
if (st.impl.FormalArguments != null)
nformalArgs = st.impl.FormalArguments.Count;
@@ -688,6 +698,11 @@ namespace Antlr4.StringTemplate

internal virtual void StoreArguments(TemplateFrame frame, int nargs, Template st)
{
+            if (nargs > 0 && !st.impl.HasFormalArgs && st.impl.FormalArguments == null)
+            {
+                st.Add(Template.ImplicitArgumentName, null); // pretend we have "it" arg
+            }
+
int nformalArgs = 0;
if (st.impl.FormalArguments != null)
nformalArgs = st.impl.FormalArguments.Count;
@@ -1071,6 +1086,16 @@ namespace Antlr4.StringTemplate

protected virtual void SetFirstArgument(TemplateFrame frame, Template st, object attr)
{
+            if (!st.impl.HasFormalArgs)
+            {
+                if (st.impl.FormalArguments == null)
+                {
+                    st.Add(Template.ImplicitArgumentName, attr);
+                    return;
+                }
+                // else fall thru to set locals[0]
+            }
+
if (st.impl.FormalArguments == null)
{
_errorManager.RuntimeError(frame, ErrorType.ARGUMENT_COUNT_MISMATCH, 1, st.impl.Name, 0);
@@ -1332,7 +1357,7 @@ namespace Antlr4.StringTemplate

IEnumerable enumerable = o as IEnumerable;
if (enumerable != null)
-                return enumerable.Cast<object>().GetEnumerator();
+                return enumerable.GetEnumerator();

//// This code is implied in the last line
//Iterator iterator = o as Iterator;
@@ -1395,7 +1420,7 @@ namespace Antlr4.StringTemplate
if (o == null)
{
_errorManager.RuntimeError(frame, ErrorType.NO_SUCH_PROPERTY,
-                                          "null attribute");
+                                          "null." + property);
return null;
}

@@ -1502,7 +1527,7 @@ namespace Antlr4.StringTemplate
StringBuilder buf = new StringBuilder();
dis.DisassembleInstruction(buf, ip);
string name = self.impl.Name + ":";
-            if (self.impl.Name == Template.UnknownName)
+            if (object.ReferenceEquals(self.impl.Name, Template.UnknownName))
name = string.Empty;

tr.Append(string.Format("{0,-40}", name + buf));
diff --git a/Antlr4.StringTemplate/Misc/ErrorManager.cs b/Antlr4.StringTemplate/Misc/ErrorManager.cs
index a61051c..82df017 100644
--- a/Antlr4.StringTemplate/Misc/ErrorManager.cs
+++ b/Antlr4.StringTemplate/Misc/ErrorManager.cs
@@ -83,9 +83,14 @@ namespace Antlr4.StringTemplate.Misc

public virtual void CompiletimeError(ErrorType error, IToken templateToken, IToken t)
{
-            string srcName = t.InputStream.SourceName;
-            if (srcName != null)
-                srcName = Path.GetFileName(srcName);
+            ICharStream input = t.InputStream;
+            string srcName = null;
+            if (input != null)
+            {
+                srcName = input.SourceName;
+                if (srcName != null)
+                    srcName = Path.GetFileName(srcName);
+            }

Listener.CompiletimeError(new TemplateCompiletimeMessage(error, srcName, templateToken, t, null, t.Text));
}
diff --git a/Antlr4.StringTemplate/Misc/ErrorType.cs b/Antlr4.StringTemplate/Misc/ErrorType.cs
index 4c2be31..e18673a 100644
--- a/Antlr4.StringTemplate/Misc/ErrorType.cs
+++ b/Antlr4.StringTemplate/Misc/ErrorType.cs
@@ -42,6 +42,7 @@ namespace Antlr4.StringTemplate.Misc
public static readonly ErrorType NO_SUCH_TEMPLATE = new ErrorType("no such template: {0}");
public static readonly ErrorType NO_IMPORTED_TEMPLATE = new ErrorType("no such template: super.{0}");
public static readonly ErrorType NO_SUCH_ATTRIBUTE = new ErrorType("attribute {0} isn't defined");
+        public static readonly ErrorType NO_SUCH_ATTRIBUTE_PASS_THROUGH = new ErrorType("could not pass through undefined attribute {0}");
public static readonly ErrorType REF_TO_IMPLICIT_ATTRIBUTE_OUT_OF_SCOPE = new ErrorType("implicitly-defined attribute {0} not visible");
public static readonly ErrorType MISSING_FORMAL_ARGUMENTS = new ErrorType("missing argument definitions");
public static readonly ErrorType NO_SUCH_PROPERTY = new ErrorType("no such property or can't access: {0}");
diff --git a/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs
index 0d78976..03a1363 100644
--- a/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs
@@ -42,31 +42,55 @@ namespace Antlr4.StringTemplate.Misc
*/
public class TemplateCompiletimeMessage : TemplateMessage
{
-        private readonly IToken templateToken; // overall token pulled from group file
-        private readonly IToken token;         // token inside template
-        private readonly string srcName;
+        private readonly IToken _templateToken; // overall token pulled from group file
+        private readonly IToken _token;         // token inside template
+        private readonly string _sourceName;

-        public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t)
-            : this(error, srcName, templateToken, t, null)
+        public TemplateCompiletimeMessage(ErrorType error, string sourceName, IToken templateToken, IToken token)
+            : this(error, sourceName, templateToken, token, null)
{
}

-        public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause)
-            : this(error, srcName, templateToken, t, cause, null)
+        public TemplateCompiletimeMessage(ErrorType error, string sourceName, IToken templateToken, IToken token, Exception cause)
+            : this(error, sourceName, templateToken, token, cause, null)
{
}

-        public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg)
-            : this(error, srcName, templateToken, t, cause, arg, null)
+        public TemplateCompiletimeMessage(ErrorType error, string sourceName, IToken templateToken, IToken token, Exception cause, object arg)
+            : this(error, sourceName, templateToken, token, cause, arg, null)
{
}

-        public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg, object arg2)
+        public TemplateCompiletimeMessage(ErrorType error, string sourceName, IToken templateToken, IToken token, Exception cause, object arg, object arg2)
: base(error, null, cause, arg, arg2)
{
-            this.templateToken = templateToken;
-            this.token = t;
-            this.srcName = srcName;
+            this._templateToken = templateToken;
+            this._token = token;
+            this._sourceName = sourceName;
+        }
+
+        public IToken TemplateToken
+        {
+            get
+            {
+                return _templateToken;
+            }
+        }
+
+        public IToken Token
+        {
+            get
+            {
+                return _token;
+            }
+        }
+
+        public string SourceName
+        {
+            get
+            {
+                return _sourceName;
+            }
}

public override string ToString()
@@ -74,25 +98,25 @@ namespace Antlr4.StringTemplate.Misc
RecognitionException re = (RecognitionException)Cause;
int line = 0;
int charPos = -1;
-            if (token != null)
+            if (_token != null)
{
-                line = token.Line;
-                charPos = token.CharPositionInLine;
-                if (templateToken != null)
+                line = _token.Line;
+                charPos = _token.CharPositionInLine;
+                // check the input streams - if different then token is embedded in templateToken and we need to adjust the offset
+                if (_templateToken != null && !_templateToken.InputStream.Equals(Token.InputStream))
{
int templateDelimiterSize = 1;
-                    if (templateToken.Type == GroupParser.BIGSTRING)
-                    {
+                    if (_templateToken.Type == GroupParser.BIGSTRING || _templateToken.Type == GroupParser.BIGSTRING_NO_NL)
templateDelimiterSize = 2;
-                    }
-                    line += templateToken.Line - 1;
-                    charPos += templateToken.CharPositionInLine + templateDelimiterSize;
+
+                    line += _templateToken.Line - 1;
+                    charPos += _templateToken.CharPositionInLine + templateDelimiterSize;
}
}

string filepos = string.Format("{0}:{1}", line, charPos);
-            if (srcName != null)
-                return string.Format("{0} {1}: {2}", srcName, filepos, string.Format(Error.Message, Arg, Arg2));
+            if (_sourceName != null)
+                return string.Format("{0} {1}: {2}", _sourceName, filepos, string.Format(Error.Message, Arg, Arg2));

return string.Format("{0}: {1}", filepos, string.Format(Error.Message, Arg, Arg2));
}
diff --git a/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs
index b2e5f80..530bcc1 100644
--- a/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs
@@ -41,29 +41,45 @@ namespace Antlr4.StringTemplate.Misc
/// <summary>
/// token inside group file
/// </summary>
-        private readonly IToken token;
-        private readonly string srcName;
+        private readonly IToken _token;
+        private readonly string _sourceName;

-        public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t)
-            : this(error, srcName, t, null, null, null)
+        public TemplateGroupCompiletimeMessage(ErrorType error, string sourceName, IToken token)
+            : this(error, sourceName, token, null, null, null)
{
}

-        public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause)
-            : this(error, srcName, t, cause, null, null)
+        public TemplateGroupCompiletimeMessage(ErrorType error, string sourceName, IToken token, Exception cause)
+            : this(error, sourceName, token, cause, null, null)
{
}

-        public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg)
-            : this(error, srcName, t, cause, arg, null)
+        public TemplateGroupCompiletimeMessage(ErrorType error, string sourceName, IToken token, Exception cause, object arg)
+            : this(error, sourceName, token, cause, arg, null)
{
}

-        public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg, object arg2)
+        public TemplateGroupCompiletimeMessage(ErrorType error, string sourceName, IToken token, Exception cause, object arg, object arg2)
: base(error, null, cause, arg, arg2)
{
-            this.token = t;
-            this.srcName = srcName;
+            this._token = token;
+            this._sourceName = sourceName;
+        }
+
+        public IToken Token
+        {
+            get
+            {
+                return _token;
+            }
+        }
+
+        public string SourceName
+        {
+            get
+            {
+                return _sourceName;
+            }
}

public override string ToString()
@@ -71,10 +87,10 @@ namespace Antlr4.StringTemplate.Misc
RecognitionException re = (RecognitionException)Cause;
int line = 0;
int charPos = -1;
-            if (token != null)
+            if (_token != null)
{
-                line = token.Line;
-                charPos = token.CharPositionInLine;
+                line = _token.Line;
+                charPos = _token.CharPositionInLine;
}
else if (re != null)
{
@@ -83,9 +99,9 @@ namespace Antlr4.StringTemplate.Misc
}

string filepos = line + ":" + charPos;
-            if (srcName != null)
+            if (_sourceName != null)
{
-                return srcName + " " + filepos + ": " + string.Format(Error.Message, Arg, Arg2);
+                return _sourceName + " " + filepos + ": " + string.Format(Error.Message, Arg, Arg2);
}

return filepos + ": " + string.Format(Error.Message, Arg, Arg2);
diff --git a/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs b/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs
index 13719fa..1440c7b 100644
--- a/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs
@@ -40,16 +40,40 @@ namespace Antlr4.StringTemplate.Misc
/** */
public class TemplateLexerMessage : TemplateMessage
{
-        string msg;
-        IToken templateToken; // overall token pulled from group file
-        string srcName;
+        private readonly string _message;
+        private readonly IToken _templateToken; // overall token pulled from group file
+        private readonly string _sourceName;

-        public TemplateLexerMessage(string srcName, string msg, IToken templateToken, Exception cause)
+        public TemplateLexerMessage(string sourceName, string message, IToken templateToken, Exception cause)
: base(ErrorType.LEXER_ERROR, null, cause, null)
{
-            this.msg = msg;
-            this.templateToken = templateToken;
-            this.srcName = srcName;
+            this._message = message;
+            this._templateToken = templateToken;
+            this._sourceName = sourceName;
+        }
+
+        public string Message
+        {
+            get
+            {
+                return _message;
+            }
+        }
+
+        public IToken TemplateToken
+        {
+            get
+            {
+                return _templateToken;
+            }
+        }
+
+        public string SourceName
+        {
+            get
+            {
+                return _sourceName;
+            }
}

public override string ToString()
@@ -57,24 +81,24 @@ namespace Antlr4.StringTemplate.Misc
RecognitionException re = (RecognitionException)Cause;
int line = re.Line;
int charPos = re.CharPositionInLine;
-            if (templateToken != null)
+            if (_templateToken != null)
{
int templateDelimiterSize = 1;
-                if (templateToken.Type == GroupParser.BIGSTRING)
+                if (_templateToken.Type == GroupParser.BIGSTRING)
{
templateDelimiterSize = 2;
}
-                line += templateToken.Line - 1;
-                charPos += templateToken.CharPositionInLine + templateDelimiterSize;
+                line += _templateToken.Line - 1;
+                charPos += _templateToken.CharPositionInLine + templateDelimiterSize;
}

string filepos = line + ":" + charPos;
-            if (srcName != null)
+            if (_sourceName != null)
{
-                return srcName + " " + filepos + ": " + string.Format(Error.Message, msg);
+                return _sourceName + " " + filepos + ": " + string.Format(Error.Message, _message);
}

-            return filepos + ": " + string.Format(Error.Message, msg);
+            return filepos + ": " + string.Format(Error.Message, _message);
}
}
}
diff --git a/Antlr4.StringTemplate/Misc/TemplateMessage.cs b/Antlr4.StringTemplate/Misc/TemplateMessage.cs
index 147867d..cba82ba 100644
--- a/Antlr4.StringTemplate/Misc/TemplateMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateMessage.cs
@@ -152,6 +152,7 @@ namespace Antlr4.StringTemplate.Misc
{
sw.WriteLine();
sw.Write("Caused by: ");
+                sw.WriteLine(cause.Message);
sw.Write(cause.StackTrace);
}
return sw.ToString();
diff --git a/Antlr4.StringTemplate/StringRenderer.cs b/Antlr4.StringTemplate/StringRenderer.cs
index f9b3c9d..e358022 100644
--- a/Antlr4.StringTemplate/StringRenderer.cs
+++ b/Antlr4.StringTemplate/StringRenderer.cs
@@ -33,6 +33,7 @@
namespace Antlr4.StringTemplate
{
using CultureInfo = System.Globalization.CultureInfo;
+    using Encoding = System.Text.Encoding;
using HttpUtility = Antlr4.StringTemplate.Misc.HttpUtility;
using SecurityElement = System.Security.SecurityElement;

@@ -58,12 +59,12 @@ namespace Antlr4.StringTemplate
return s.Length > 0 ? char.ToUpper(s[0], culture) + s.Substring(1) : s;

if (formatString.Equals("url-encode"))
-                return HttpUtility.UrlEncode(s);
+                return HttpUtility.UrlEncode(s, Encoding.UTF8);

if (formatString.Equals("xml-encode"))
return SecurityElement.Escape(s);

-            return string.Format(formatString, s);
+            return string.Format(culture, formatString, s);
}
}
}
diff --git a/Antlr4.StringTemplate/Template.cs b/Antlr4.StringTemplate/Template.cs
index fde2939..bcea153 100644
--- a/Antlr4.StringTemplate/Template.cs
+++ b/Antlr4.StringTemplate/Template.cs
@@ -82,6 +82,11 @@ namespace Antlr4.StringTemplate
public static readonly string UnknownName = "anonymous";
public static readonly object EmptyAttribute = new object();

+        /** When there are no formal args for template t and you map t across
+         *  some values, t implicitly gets arg "it".  E.g., "<b>$it$</b>"
+         */
+        public static readonly string ImplicitArgumentName = "it";
+
/** The implementation for this template among all instances of same tmpelate . */
public CompiledTemplate impl;

@@ -241,12 +246,9 @@ namespace Antlr4.StringTemplate
public virtual Template Add(string name, object value)
{
if (name == null)
-                return this; // allow null value but not name
-
+                throw new ArgumentNullException("name");
if (name.IndexOf('.') >= 0)
-            {
throw new ArgumentException("cannot have '.' in attribute names");
-            }

if (Group.TrackCreationEvents)
{
@@ -457,12 +459,6 @@ namespace Antlr4.StringTemplate
multi = new AttributeList(listAttr.Count);
multi.AddRange(listAttr.Cast<object>());
}
-            else if (curvalue.GetType().IsArray)
-            { // copy array to list
-                object[] a = (object[])curvalue;
-                multi = new AttributeList(a.Length);
-                multi.AddRange(a); // asList doesn't copy as far as I can tell
-            }
else
{
// curvalue nonlist and we want to Add an attribute
@@ -626,8 +622,6 @@ namespace Antlr4.StringTemplate
public static string Format(int lineWidth, string template, params object[] attributes)
{
template = Regex.Replace(template, "[0-9]+", "arg$0");
-            Console.WriteLine(template);
-
Template st = new Template(template);
int i = 1;
foreach (object a in attributes)
diff --git a/Antlr4.StringTemplate/TemplateGroup.cs b/Antlr4.StringTemplate/TemplateGroup.cs
index 3490b07..477c627 100644
--- a/Antlr4.StringTemplate/TemplateGroup.cs
+++ b/Antlr4.StringTemplate/TemplateGroup.cs
@@ -77,6 +77,9 @@ namespace Antlr4.StringTemplate
*/
public class TemplateGroup
{
+        public static readonly string GroupFileExtension = ".stg";
+        public static readonly string TemplateFileExtension = ".st";
+
/** When we use key as a value in a dictionary, this is how we signify. */
public static readonly string DictionaryKey = "key";
public static readonly string DefaultKey = "default";
@@ -837,8 +840,8 @@ namespace Antlr4.StringTemplate
fileName = Utility.Strip(fileName, 1);

//Console.WriteLine("import {0}", fileName);
-            bool isGroupFile = fileName.EndsWith(".stg");
-            bool isTemplateFile = fileName.EndsWith(".st");
+            bool isGroupFile = fileName.EndsWith(GroupFileExtension);
+            bool isTemplateFile = fileName.EndsWith(TemplateFileExtension);
bool isGroupDir = !(isGroupFile || isTemplateFile);

TemplateGroup g = null;
@@ -931,7 +934,12 @@ namespace Antlr4.StringTemplate
/** Load a group file with full path fileName; it's relative to root by prefix. */
public virtual void LoadGroupFile(string prefix, string fileName)
{
-            //System.out.println("load group file prefix="+prefix+", fileName="+fileName);
+            if (Verbose)
+            {
+                Console.Out.WriteLine("{0}.LoadGroupFile(prefix={1}, fileName={2})",
+                    GetType().FullName, prefix, fileName);
+            }
+
GroupParser parser = null;
try
{
@@ -963,10 +971,10 @@ namespace Antlr4.StringTemplate
catch (Exception e)
{
e.PreserveStackTrace();
-                if (!e.IsCritical())
-                    ErrorManager.IOError(null, ErrorType.CANT_LOAD_GROUP_FILE, e, fileName);
+                if (e.IsCritical())
+                    throw;

-                throw;
+                ErrorManager.IOError(null, ErrorType.CANT_LOAD_GROUP_FILE, e, fileName);
}
}

@@ -1709,7 +1717,7 @@ namespace Antlr4.StringTemplate
*  The prefix is path from group root to unqualifiedFileName like /subdir
*  if file is in /subdir/a.st
*/
-        public CompiledTemplate LoadTemplateFile(string prefix, string unqualifiedFileName, ICharStream templateStream)
+        public virtual CompiledTemplate LoadTemplateFile(string prefix, string unqualifiedFileName, ICharStream templateStream)
{
GroupLexer lexer = new GroupLexer(templateStream);
CommonTokenStream tokens = new CommonTokenStream(lexer);
@@ -1927,5 +1935,19 @@ namespace Antlr4.StringTemplate
ErrorManager = new ErrorManager(value);
}
}
+
+
+        public virtual HashSet<string> GetTemplateNames()
+        {
+            Load();
+            HashSet<string> result = new HashSet<string>();
+            foreach (KeyValuePair<string, CompiledTemplate> e in templates)
+            {
+                if (e.Value != NotFoundTemplate)
+                    result.Add(e.Key);
+            }
+
+            return result;
+        }
}
}
diff --git a/Antlr4.StringTemplate/TemplateGroupDirectory.cs b/Antlr4.StringTemplate/TemplateGroupDirectory.cs
index e4bcc22..99987a5 100644
--- a/Antlr4.StringTemplate/TemplateGroupDirectory.cs
+++ b/Antlr4.StringTemplate/TemplateGroupDirectory.cs
@@ -45,6 +45,7 @@ namespace Antlr4.StringTemplate
using File = System.IO.File;
using IOException = System.IO.IOException;
using NotImplementedException = System.NotImplementedException;
+    using NotSupportedException = System.NotSupportedException;
using Path = System.IO.Path;
using StreamReader = System.IO.StreamReader;
using Uri = System.Uri;
@@ -124,10 +125,19 @@ namespace Antlr4.StringTemplate
if (encoding == null)
throw new ArgumentNullException("encoding");

+            this.groupDirName = Path.GetFileName(root.AbsolutePath);
this.root = root;
this.Encoding = encoding;
}

+        public override void ImportTemplates(IToken fileNameToken)
+        {
+            string msg =
+                "import illegal in group files embedded in TemplateGroupDirectory; " +
+                "import " + fileNameToken.Text + " in TemplateGroupDirectory " + this.Name;
+            throw new NotSupportedException(msg);
+        }
+
/** <summary>
* Load a template from dir or group file.  Group file is given
* precedence over dir with same name. <paramref name="name"/> is
@@ -144,7 +154,7 @@ namespace Antlr4.StringTemplate

//    	if (parent.isEmpty()) {
//    		// no need to check for a group file as name has no parent
-            //            return loadTemplateFile("/", name+".st"); // load t.st file
+            //            return loadTemplateFile("/", name+TemplateFileExtension); // load t.st file
//    	}

if (!Path.IsPathRooted(parent))
@@ -154,18 +164,18 @@ namespace Antlr4.StringTemplate
try
{
// see if parent of template name is a group file
-                groupFileURL = new Uri(TemplateName.GetTemplatePath(root.LocalPath, parent) + ".stg");
+                groupFileURL = new Uri(TemplateName.GetTemplatePath(root.LocalPath, parent) + GroupFileExtension);
}
catch (UriFormatException e)
{
-                ErrorManager.InternalError(null, "bad URL: " + TemplateName.GetTemplatePath(root.LocalPath, parent) + ".stg", e);
+                ErrorManager.InternalError(null, "bad URL: " + TemplateName.GetTemplatePath(root.LocalPath, parent) + GroupFileExtension, e);
return null;
}

if (!File.Exists(groupFileURL.LocalPath))
{
string unqualifiedName = Path.GetFileName(name);
-                return LoadTemplateFile(prefix, unqualifiedName + ".st"); // load t.st file
+                return LoadTemplateFile(prefix, unqualifiedName + TemplateFileExtension); // load t.st file
}
#if false
InputStream @is = null;
@@ -176,7 +186,7 @@ namespace Antlr4.StringTemplate
catch (FileNotFoundException fnfe)
{
// must not be in a group file
-                return loadTemplateFile(parent, name + ".st"); // load t.st file
+                return loadTemplateFile(parent, name + TemplateFileExtension); // load t.st file
}
catch (IOException ioe)
{
diff --git a/Antlr4.StringTemplate/TemplateGroupFile.cs b/Antlr4.StringTemplate/TemplateGroupFile.cs
index fe42299..083bcec 100644
--- a/Antlr4.StringTemplate/TemplateGroupFile.cs
+++ b/Antlr4.StringTemplate/TemplateGroupFile.cs
@@ -73,7 +73,7 @@ namespace Antlr4.StringTemplate

try
{
-                if (!fileName.EndsWith(".stg"))
+                if (!fileName.EndsWith(GroupFileExtension))
throw new ArgumentException("Group file names must end in .stg: " + fileName);

if (!File.Exists(fileName))
diff --git a/Antlr4.StringTemplate/TemplateRawGroupDirectory.cs b/Antlr4.StringTemplate/TemplateRawGroupDirectory.cs
new file mode 100644
index 0000000..92f045e
--- /dev/null
+++ b/Antlr4.StringTemplate/TemplateRawGroupDirectory.cs
@@ -0,0 +1,100 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2012 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2012 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate
+{
+    using Antlr.Runtime;
+    using Antlr4.StringTemplate.Compiler;
+    using Antlr4.StringTemplate.Misc;
+
+    using ArgumentException = System.ArgumentException;
+    using ArgumentNullException = System.ArgumentNullException;
+    using Console = System.Console;
+    using Directory = System.IO.Directory;
+    using Encoding = System.Text.Encoding;
+    using Exception = System.Exception;
+    using File = System.IO.File;
+    using IOException = System.IO.IOException;
+    using NotImplementedException = System.NotImplementedException;
+    using NotSupportedException = System.NotSupportedException;
+    using Path = System.IO.Path;
+    using StreamReader = System.IO.StreamReader;
+    using Uri = System.Uri;
+    using UriFormatException = System.UriFormatException;
+
+    // TODO: caching?
+
+    /** A dir of templates w/o headers like ST v3 had.  Still allows group files
+     *  in dir though like TemplateGroupDirectory parent.
+     */
+    public class TemplateRawGroupDirectory : TemplateGroupDirectory
+    {
+        public TemplateRawGroupDirectory(string dirName)
+            : base(dirName)
+        {
+        }
+
+        public TemplateRawGroupDirectory(string dirName, char delimiterStartChar, char delimiterStopChar)
+            : base(dirName, delimiterStartChar, delimiterStopChar)
+        {
+        }
+
+        public TemplateRawGroupDirectory(string dirName, Encoding encoding)
+            : base(dirName, encoding)
+        {
+        }
+
+        public TemplateRawGroupDirectory(string dirName, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+            : base(dirName, encoding, delimiterStartChar, delimiterStopChar)
+        {
+        }
+
+        public TemplateRawGroupDirectory(Uri root, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+            : base(root, encoding, delimiterStartChar, delimiterStopChar)
+        {
+        }
+
+        public override CompiledTemplate LoadTemplateFile(string prefix, string unqualifiedFileName,
+                                           ICharStream templateStream)
+        {
+            string template = templateStream.Substring(0, templateStream.Count);
+            string templateName = Path.GetFileNameWithoutExtension(unqualifiedFileName);
+            string fullyQualifiedTemplateName = prefix + templateName;
+            CompiledTemplate impl = new TemplateCompiler(this).Compile(fullyQualifiedTemplateName, template);
+            CommonToken nameT = new CommonToken(TemplateLexer.SEMI); // Seems like a hack, best I could come up with.
+            nameT.InputStream = templateStream;
+            RawDefineTemplate(fullyQualifiedTemplateName, impl, nameT);
+            impl.DefineImplicitlyDefinedTemplates(this);
+            return impl;
+        }
+    }
+}
diff --git a/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj b/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj
index 345ef04..a859a46 100644
--- a/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj
+++ b/Antlr4.Test.StringTemplate/Antlr4.Test.StringTemplate.csproj
@@ -51,6 +51,7 @@
<Compile Include="TestCategories.cs" />
<Compile Include="TestNoNewlineTemplates.cs" />
<Compile Include="TestTemplateNames.cs" />
+    <Compile Include="TestTemplateRawGroupDirectory.cs" />
<Compile Include="TestVisualizer.cs" />
</ItemGroup>
<ItemGroup>
diff --git a/Antlr4.Test.StringTemplate/BaseTest.cs b/Antlr4.Test.StringTemplate/BaseTest.cs
index 3527c0c..b16f1f1 100644
--- a/Antlr4.Test.StringTemplate/BaseTest.cs
+++ b/Antlr4.Test.StringTemplate/BaseTest.cs
@@ -32,17 +32,19 @@

namespace Antlr4.Test.StringTemplate
{
+    using Antlr.Runtime;
using Antlr4.StringTemplate;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
using Antlr4.StringTemplate.Compiler;
-    using Path = System.IO.Path;
-    using File = System.IO.File;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ArgumentException = System.ArgumentException;
+    using CultureInfo = System.Globalization.CultureInfo;
+    using DateTime = System.DateTime;
using Directory = System.IO.Directory;
using Environment = System.Environment;
-    using Antlr.Runtime;
-    using DateTime = System.DateTime;
+    using File = System.IO.File;
+    using Path = System.IO.Path;
using StringBuilder = System.Text.StringBuilder;
-    using ArgumentException = System.ArgumentException;
+    using Thread = System.Threading.Thread;

[TestClass]
public abstract class BaseTest
@@ -64,6 +66,7 @@ namespace Antlr4.Test.StringTemplate

protected virtual void setUpImpl()
{
+            Thread.CurrentThread.CurrentCulture = CultureInfo.GetCultureInfo("en-us");
TemplateGroup.DefaultGroup = new TemplateGroup();
TemplateCompiler.subtemplateCount = 0;

diff --git a/Antlr4.Test.StringTemplate/TestCoreBasics.cs b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
index b755aff..04bde44 100644
--- a/Antlr4.Test.StringTemplate/TestCoreBasics.cs
+++ b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
@@ -125,7 +125,7 @@ namespace Antlr4.Test.StringTemplate
string result = st.Render();
Assert.AreEqual(expected, result);

-            Assert.IsTrue(names.Count == 2); // my names list is still just 2
+            Assert.AreEqual(2, names.Count); // my names list is still just 2
}

[TestMethod][TestCategory(TestCategories.ST4)]
@@ -640,6 +640,42 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expected, result);
}

+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRepeatedMapWithNullValue()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("a", "[<x>]", new string[] { "x" });
+            group.DefineTemplate("b", "(<x>)", new string[] { "x" });
+            group.DefineTemplate("test", "hi <name:a():b()>!", new string[] { "name" });
+            Template st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", null);
+            st.Add("name", "Sumana");
+            string expected =
+                "hi ([Ter])([Sumana])!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRepeatedMapWithNullValueAndNullOption()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("a", "[<x>]", new string[] { "x" });
+            group.DefineTemplate("b", "(<x>)", new string[] { "x" });
+            group.DefineTemplate("test", "hi <name:a():b(); null={x}>!", new string[] { "name" });
+            Template st = group.GetInstanceOf("test");
+            st.Add("name", "Ter");
+            st.Add("name", null);
+            st.Add("name", "Sumana");
+            string expected =
+                "hi ([Ter])x([Sumana])!";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
[TestMethod][TestCategory(TestCategories.ST4)]
public void TestRoundRobinMap()
{
@@ -992,6 +1028,79 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expected, result);
}

+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSeparatorInList2()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("test", "<names:{n | case <n>}; separator=\", \">", new string[] { "names" });
+            Template st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", new List<string>(new string[] { "Tom", "Sriram" }));
+            string expected =
+                "case Ter, case Tom, case Sriram";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSeparatorInArray()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("test", "<names:{n | case <n>}; separator=\", \">", new string[] { "names" });
+            Template st = group.GetInstanceOf("test");
+            st.Add("names", new string[] { "Ter", "Tom" });
+            string expected =
+                "case Ter, case Tom";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSeparatorInArray2()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("test", "<names:{n | case <n>}; separator=\", \">", new string[] { "names" });
+            Template st = group.GetInstanceOf("test");
+            st.Add("names", "Ter");
+            st.Add("names", new string[] { "Tom", "Sriram" });
+            string expected =
+                "case Ter, case Tom, case Sriram";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSeparatorInPrimitiveArray()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("test", "<names:{n | case <n>}; separator=\", \">", new string[] { "names" });
+            Template st = group.GetInstanceOf("test");
+            st.Add("names", new int[] { 0, 1 });
+            string expected =
+                "case 0, case 1";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSeparatorInPrimitiveArray2()
+        {
+            TemplateGroup group = new TemplateGroup();
+            group.DefineTemplate("test", "<names:{n | case <n>}; separator=\", \">", new string[] { "names" });
+            Template st = group.GetInstanceOf("test");
+            st.Add("names", 0);
+            st.Add("names", new int[] { 1, 2 });
+            string expected =
+                "case 0, case 1, case 2";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
/** (...) forces early eval to string.
* We need an STWriter so I must pick one.  toString(...) is used to
* ensure b is property name in &lt;a.b&gt;.  It's used to eval default args
diff --git a/Antlr4.Test.StringTemplate/TestDictionaries.cs b/Antlr4.Test.StringTemplate/TestDictionaries.cs
index 47a4530..b2e82da 100644
--- a/Antlr4.Test.StringTemplate/TestDictionaries.cs
+++ b/Antlr4.Test.StringTemplate/TestDictionaries.cs
@@ -469,5 +469,157 @@ namespace Antlr4.Test.StringTemplate
string result = st.Render();
Assert.AreEqual(expected, result);
}
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestStringsInDictionary()
+        {
+            string templates =
+                "auxMap ::= [\n" +
+                "   \"E\": \"electric <field>\",\n" +
+                "   \"I\": \"in <field> between\",\n" +
+                "   \"F\": \"<field> force\",\n" +
+                "   default: \"<field>\"\n" +
+                "]\n" +
+                "\n" +
+                "makeTmpl(type, field) ::= <<\n" +
+                "<auxMap.(type)>\n" +
+                ">>\n" +
+                "\n" +
+                "top() ::= <<\n" +
+                "  <makeTmpl(\"E\", \"foo\")>\n" +
+                "  <makeTmpl(\"F\", \"foo\")>\n" +
+                "  <makeTmpl(\"I\", \"foo\")>\n" +
+                ">>\n";
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("top");
+            Assert.IsNotNull(st);
+            string expecting =
+                "  electric <field>" + newline +
+                "  <field> force" + newline +
+                "  in <field> between";
+            Assert.AreEqual(expecting, st.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestTemplatesInDictionary()
+        {
+            string templates =
+                "auxMap ::= [\n" +
+                "   \"E\": {electric <field>},\n" +
+                "   \"I\": {in <field> between},\n" +
+                "   \"F\": {<field> force},\n" +
+                "   default: {<field>}\n" +
+                "]\n" +
+                "\n" +
+                "makeTmpl(type, field) ::= <<\n" +
+                "<auxMap.(type)>\n" +
+                ">>\n" +
+                "\n" +
+                "top() ::= <<\n" +
+                "  <makeTmpl(\"E\", \"foo\")>\n" +
+                "  <makeTmpl(\"F\", \"foo\")>\n" +
+                "  <makeTmpl(\"I\", \"foo\")>\n" +
+                ">>\n";
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("top");
+            Assert.IsNotNull(st);
+            string expecting =
+                "  electric foo" + newline +
+                "  foo force" + newline +
+                "  in foo between";
+            Assert.AreEqual(expecting, st.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestDictionaryBehaviorTrue()
+        {
+            string templates =
+                "d ::= [\n" +
+                "	\"x\" : true,\n" +
+                "	default : false,\n" +
+                "]\n" +
+                "\n" +
+                "t() ::= <<\n" +
+                "<d.(\"x\")><if(d.(\"x\"))>+<else>-<endif>\n" +
+                ">>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            string expected = "true+";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestDictionaryBehaviorFalse()
+        {
+            string templates =
+                "d ::= [\n" +
+                "	\"x\" : false,\n" +
+                "	default : false,\n" +
+                "]\n" +
+                "\n" +
+                "t() ::= <<\n" +
+                "<d.(\"x\")><if(d.(\"x\"))>+<else>-<endif>\n" +
+                ">>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            string expected = "false-";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestDictionaryBehaviorEmptyTemplate()
+        {
+            string templates =
+                "d ::= [\n" +
+                "	\"x\" : {},\n" +
+                "	default : false,\n" +
+                "]\n" +
+                "\n" +
+                "t() ::= <<\n" +
+                "<d.(\"x\")><if(d.(\"x\"))>+<else>-<endif>\n" +
+                ">>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            string expected = "+";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestDictionaryBehaviorEmptyList()
+        {
+            string templates =
+                "d ::= [\n" +
+                "	\"x\" : [],\n" +
+                "	default : false,\n" +
+                "]\n" +
+                "\n" +
+                "t() ::= <<\n" +
+                "<d.(\"x\")><if(d.(\"x\"))>+<else>-<endif>\n" +
+                ">>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            string expected = "-";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
}
}
diff --git a/Antlr4.Test.StringTemplate/TestFunctions.cs b/Antlr4.Test.StringTemplate/TestFunctions.cs
index e223a51..908f986 100644
--- a/Antlr4.Test.StringTemplate/TestFunctions.cs
+++ b/Antlr4.Test.StringTemplate/TestFunctions.cs
@@ -25,7 +25,7 @@
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
* NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, TemplateRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
* THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
@@ -40,7 +40,8 @@ namespace Antlr4.Test.StringTemplate
[TestClass]
public class TestFunctions : BaseTest
{
-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestFirst()
{
string template = "<first(names)>";
@@ -52,7 +53,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expected, result);
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestLength()
{
string template = "<length(names)>";
@@ -64,7 +66,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expected, result);
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestLengthWithNullValues()
{
string template = "<length(names)>";
@@ -76,7 +79,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expected, result);
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestFirstOp()
{
Template e = new Template(
@@ -89,7 +93,44 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestFirstOpList()
+        {
+            Template e = new Template(
+                    "<first(names)>"
+                );
+            e.Add("names", new List<string>(new string[] { "Ter", "Tom", "Sriram" }));
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestFirstOpArray()
+        {
+            Template e = new Template(
+                    "<first(names)>"
+                );
+            e.Add("names", new string[] { "Ter", "Tom", "Sriram" });
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestFirstOpPrimitiveArray()
+        {
+            Template e = new Template(
+                    "<first(names)>"
+                );
+            e.Add("names", new int[] { 0, 1, 2 });
+            string expecting = "0";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestTruncOp()
{
Template e = new Template(
@@ -102,7 +143,44 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestTruncOpList()
+        {
+            Template e = new Template(
+                    "<trunc(names); separator=\", \">"
+                );
+            e.Add("names", new List<string>(new string[] { "Ter", "Tom", "Sriram" }));
+            string expecting = "Ter, Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestTruncOpArray()
+        {
+            Template e = new Template(
+                    "<trunc(names); separator=\", \">"
+                );
+            e.Add("names", new string[] { "Ter", "Tom", "Sriram" });
+            string expecting = "Ter, Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestTruncOpPrimitiveArray()
+        {
+            Template e = new Template(
+                    "<trunc(names); separator=\", \">"
+                );
+            e.Add("names", new int[] { 0, 1, 2 });
+            string expecting = "0, 1";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRestOp()
{
Template e = new Template(
@@ -115,7 +193,44 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRestOpList()
+        {
+            Template e = new Template(
+                    "<rest(names); separator=\", \">"
+                );
+            e.Add("names", new List<string>(new string[] { "Ter", "Tom", "Sriram" }));
+            string expecting = "Tom, Sriram";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRestOpArray()
+        {
+            Template e = new Template(
+                    "<rest(names); separator=\", \">"
+                );
+            e.Add("names", new string[] { "Ter", "Tom", "Sriram" });
+            string expecting = "Tom, Sriram";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRestOpPrimitiveArray()
+        {
+            Template e = new Template(
+                    "<rest(names); separator=\", \">"
+                );
+            e.Add("names", new int[] { 0, 1, 2 });
+            string expecting = "1, 2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRestOpEmptyList()
{
Template e = new Template(
@@ -126,7 +241,32 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRestOpEmptyArray()
+        {
+            Template e = new Template(
+                    "<rest(names); separator=\", \">"
+                );
+            e.Add("names", new string[0]);
+            string expecting = "";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRestOpEmptyPrimitiveArray()
+        {
+            Template e = new Template(
+                    "<rest(names); separator=\", \">"
+                );
+            e.Add("names", new int[0]);
+            string expecting = "";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestReUseOfRestResult()
{
string templates =
@@ -144,7 +284,24 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestReUseOfRestPrimitiveArrayResult()
+        {
+            string templates =
+                "a(names) ::= \"<b(rest(names))>\"" + newline +
+                "b(x) ::= \"<x>, <x>\"" + newline
+                ;
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
+            Template e = group.GetInstanceOf("a");
+            e.Add("names", new int[] { 0, 1 });
+            string expecting = "1, 1";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestLastOp()
{
Template e = new Template(
@@ -157,7 +314,44 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLastOpList()
+        {
+            Template e = new Template(
+                    "<last(names)>"
+                );
+            e.Add("names", new List<string>(new string[] { "Ter", "Tom", "Sriram" }));
+            string expecting = "Sriram";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLastOpArray()
+        {
+            Template e = new Template(
+                    "<last(names)>"
+                );
+            e.Add("names", new string[] { "Ter", "Tom", "Sriram" });
+            string expecting = "Sriram";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLastOpPrimitiveArray()
+        {
+            Template e = new Template(
+                    "<last(names)>"
+                );
+            e.Add("names", new int[] { 0, 1, 2 });
+            string expecting = "2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestStripOp()
{
Template e = new Template(
@@ -173,7 +367,32 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestStripOpList()
+        {
+            Template e = new Template(
+                    "<strip(names); null=\"n/a\">"
+                );
+            e.Add("names", new List<string>(new string[] { null, "Tom", null, null, "Sriram", null }));
+            string expecting = "TomSriram";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestStripOpArray()
+        {
+            Template e = new Template(
+                    "<strip(names); null=\"n/a\">"
+                );
+            e.Add("names", new string[] { null, "Tom", null, null, "Sriram", null });
+            string expecting = "TomSriram";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestLengthStrip()
{
Template e = new Template(
@@ -189,7 +408,32 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLengthStripList()
+        {
+            Template e = new Template(
+                    "<length(strip(names))>"
+                );
+            e.Add("names", new List<string>(new string[] { null, "Tom", null, null, "Sriram", null }));
+            string expecting = "2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLengthStripArray()
+        {
+            Template e = new Template(
+                    "<length(strip(names))>"
+                );
+            e.Add("names", new string[] { null, "Tom", null, null, "Sriram", null });
+            string expecting = "2";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestCombinedOp()
{
// replace first of yours with first of mine
@@ -205,7 +449,53 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCombinedOpList()
+        {
+            // replace first of yours with first of mine
+            Template e = new Template(
+                    "<[first(mine),rest(yours)]; separator=\", \">"
+                );
+            e.Add("mine", new List<string>(new string[] { "1", "2", "3" }));
+            e.Add("yours", "a");
+            e.Add("yours", "b");
+            string expecting = "1, b";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCombinedOpArray()
+        {
+            // replace first of yours with first of mine
+            Template e = new Template(
+                    "<[first(mine),rest(yours)]; separator=\", \">"
+                );
+            e.Add("mine", new string[] { "1", "2", "3" });
+            e.Add("yours", "a");
+            e.Add("yours", "b");
+            string expecting = "1, b";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCombinedOpPrimitiveArray()
+        {
+            // replace first of yours with first of mine
+            Template e = new Template(
+                    "<[first(mine),rest(yours)]; separator=\", \">"
+                );
+            e.Add("mine", new int[] { 1, 2, 3 });
+            e.Add("yours", "a");
+            e.Add("yours", "b");
+            string expecting = "1, b";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestCatListAndSingleAttribute()
{
// replace first of yours with first of mine
@@ -220,7 +510,50 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCatListAndSingleAttribute2()
+        {
+            // replace first of yours with first of mine
+            Template e = new Template(
+                    "<[mine,yours]; separator=\", \">"
+                );
+            e.Add("mine", new List<string>(new string[] { "1", "2", "3" }));
+            e.Add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCatArrayAndSingleAttribute()
+        {
+            // replace first of yours with first of mine
+            Template e = new Template(
+                    "<[mine,yours]; separator=\", \">"
+                );
+            e.Add("mine", new string[] { "1", "2", "3" });
+            e.Add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCatPrimitiveArrayAndSingleAttribute()
+        {
+            // replace first of yours with first of mine
+            Template e = new Template(
+                    "<[mine,yours]; separator=\", \">"
+                );
+            e.Add("mine", new int[] { 1, 2, 3 });
+            e.Add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestReUseOfCat()
{
string templates =
@@ -241,7 +574,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestCatListAndEmptyAttributes()
{
// + is overloaded to be cat strings and cat lists so the
@@ -259,7 +593,59 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCatListAndEmptyAttributes2()
+        {
+            // + is overloaded to be cat strings and cat lists so the
+            // two operands (from left to right) determine which way it
+            // goes.  In this case, x+mine is a list so everything from their
+            // to the right becomes list cat.
+            Template e = new Template(
+                    "<[x,mine,y,yours,z]; separator=\", \">"
+                );
+            e.Add("mine", new List<string>(new string[] { "1", "2", "3" }));
+            e.Add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCatArrayAndEmptyAttributes2()
+        {
+            // + is overloaded to be cat strings and cat lists so the
+            // two operands (from left to right) determine which way it
+            // goes.  In this case, x+mine is a list so everything from their
+            // to the right becomes list cat.
+            Template e = new Template(
+                    "<[x,mine,y,yours,z]; separator=\", \">"
+                );
+            e.Add("mine", new string[] { "1", "2", "3" });
+            e.Add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestCatPrimitiveArrayAndEmptyAttributes()
+        {
+            // + is overloaded to be cat strings and cat lists so the
+            // two operands (from left to right) determine which way it
+            // goes.  In this case, x+mine is a list so everything from their
+            // to the right becomes list cat.
+            Template e = new Template(
+                    "<[x,mine,y,yours,z]; separator=\", \">"
+                );
+            e.Add("mine", new int[] { 1, 2, 3 });
+            e.Add("yours", "a");
+            string expecting = "1, 2, 3, a";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestNestedOp()
{
Template e = new Template(
@@ -272,7 +658,44 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestNestedOpList()
+        {
+            Template e = new Template(
+                    "<first(rest(names))>" // gets 2nd element
+                );
+            e.Add("names", new List<string>(new string[] { "Ter", "Tom", "Sriram" }));
+            string expecting = "Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestNestedOpArray()
+        {
+            Template e = new Template(
+                    "<first(rest(names))>" // gets 2nd element
+                );
+            e.Add("names", new string[] { "Ter", "Tom", "Sriram" });
+            string expecting = "Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestNestedOpPrimitiveArray()
+        {
+            Template e = new Template(
+                    "<first(rest(names))>" // gets 2nd element
+                );
+            e.Add("names", new int[] { 0, 1, 2 });
+            string expecting = "1";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestFirstWithOneAttributeOp()
{
Template e = new Template(
@@ -283,7 +706,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestLastWithOneAttributeOp()
{
Template e = new Template(
@@ -294,7 +718,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestLastWithLengthOneListAttributeOp()
{
Template e = new Template(
@@ -305,7 +730,32 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLastWithLengthOneArrayAttributeOp()
+        {
+            Template e = new Template(
+                    "<last(names)>"
+                );
+            e.Add("names", new string[] { "Ter" });
+            string expecting = "Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLastWithLengthOnePrimitiveArrayAttributeOp()
+        {
+            Template e = new Template(
+                    "<last(names)>"
+                );
+            e.Add("names", new int[] { 0 });
+            string expecting = "0";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRestWithOneAttributeOp()
{
Template e = new Template(
@@ -316,7 +766,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRestWithLengthOneListAttributeOp()
{
Template e = new Template(
@@ -327,7 +778,32 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRestWithLengthOneArrayAttributeOp()
+        {
+            Template e = new Template(
+                    "<rest(names)>"
+                );
+            e.Add("names", new string[] { "Ter" });
+            string expecting = "";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRestWithLengthOnePrimitiveArrayAttributeOp()
+        {
+            Template e = new Template(
+                    "<rest(names)>"
+                );
+            e.Add("names", new int[] { 0 });
+            string expecting = "";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRepeatedRestOp()
{
Template e = new Template(
@@ -339,7 +815,44 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRepeatedRestOpList()
+        {
+            Template e = new Template(
+                    "<rest(names)>, <rest(names)>" // gets 2nd element
+                );
+            e.Add("names", new List<string>(new string[] { "Ter", "Tom" }));
+            string expecting = "Tom, Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRepeatedRestOpArray()
+        {
+            Template e = new Template(
+                    "<rest(names)>, <rest(names)>" // gets 2nd element
+                );
+            e.Add("names", new string[] { "Ter", "Tom" });
+            string expecting = "Tom, Tom";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestRepeatedRestOpPrimitiveArray()
+        {
+            Template e = new Template(
+                    "<rest(names)>, <rest(names)>" // gets 2nd element
+                );
+            e.Add("names", new int[] { 0, 1 });
+            string expecting = "1, 1";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestIncomingLists()
{
Template e = new Template(
@@ -351,7 +864,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestFirstWithCatAttribute()
{
Template e = new Template(
@@ -365,7 +879,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestFirstWithListOfMaps()
{
Template e = new Template(
@@ -386,7 +901,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestFirstWithListOfMaps2()
{
Template e = new Template(
@@ -406,7 +922,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestTrim()
{
Template e = new Template(
@@ -417,7 +934,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestStrlen()
{
Template e = new Template(
@@ -428,7 +946,8 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, e.Render());
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestReverse()
{
Template e = new Template(
@@ -440,5 +959,41 @@ namespace Antlr4.Test.StringTemplate
string expecting = "Sriram, Tom, Ter";
Assert.AreEqual(expecting, e.Render());
}
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestReverseList()
+        {
+            Template e = new Template(
+                    "<reverse(names); separator=\", \">"
+                );
+            e.Add("names", new List<string>(new string[] { "Ter", "Tom", "Sriram" }));
+            string expecting = "Sriram, Tom, Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestReverseArray()
+        {
+            Template e = new Template(
+                    "<reverse(names); separator=\", \">"
+                );
+            e.Add("names", new string[] { "Ter", "Tom", "Sriram" });
+            string expecting = "Sriram, Tom, Ter";
+            Assert.AreEqual(expecting, e.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestReversePrimitiveArray()
+        {
+            Template e = new Template(
+                    "<reverse(names); separator=\", \">"
+                );
+            e.Add("names", new int[] { 0, 1, 2 });
+            string expecting = "2, 1, 0";
+            Assert.AreEqual(expecting, e.Render());
+        }
}
}
diff --git a/Antlr4.Test.StringTemplate/TestGroupSyntax.cs b/Antlr4.Test.StringTemplate/TestGroupSyntax.cs
index 5e38a75..4ba18d2 100644
--- a/Antlr4.Test.StringTemplate/TestGroupSyntax.cs
+++ b/Antlr4.Test.StringTemplate/TestGroupSyntax.cs
@@ -196,6 +196,74 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expected, result);
}

+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestDefaultValueBehaviorTrue()
+        {
+            string templates =
+                "t(a=true) ::= <<\n" +
+                "<a><if(a)>+<else>-<endif>\n" +
+                ">>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            string expected = "true+";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestDefaultValueBehaviorFalse()
+        {
+            string templates =
+                "t(a=false) ::= <<\n" +
+                "<a><if(a)>+<else>-<endif>\n" +
+                ">>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            string expected = "false-";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestDefaultValueBehaviorEmptyTemplate()
+        {
+            string templates =
+                "t(a={}) ::= <<\n" +
+                "<a><if(a)>+<else>-<endif>\n" +
+                ">>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            string expected = "+";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestDefaultValueBehaviorEmptyList()
+        {
+            string templates =
+                "t(a=[]) ::= <<\n" +
+                "<a><if(a)>+<else>-<endif>\n" +
+                ">>\n";
+
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            string expected = "-";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
[TestMethod][TestCategory(TestCategories.ST4)]
public void TestNestedTemplateInGroupFile()
{
diff --git a/Antlr4.Test.StringTemplate/TestGroups.cs b/Antlr4.Test.StringTemplate/TestGroups.cs
index 05656ef..69d6aea 100644
--- a/Antlr4.Test.StringTemplate/TestGroups.cs
+++ b/Antlr4.Test.StringTemplate/TestGroups.cs
@@ -32,10 +32,12 @@

namespace Antlr4.Test.StringTemplate
{
-    using System.Runtime.CompilerServices;
using Antlr4.StringTemplate;
using Antlr4.StringTemplate.Misc;
using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using System.Collections.Generic;
+    using System.Linq;
+    using System.Runtime.CompilerServices;
using Path = System.IO.Path;

[TestClass]
@@ -699,6 +701,29 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual("group2", stb.impl.NativeGroup.Name);
}

+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestGetTemplateNames()
+        {
+            string templates =
+                "t() ::= \"foo\"\n" +
+                "main() ::= \"<t()>\"";
+            writeFile(tmpdir, "t.stg", templates);
+
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            // try to get an undefined template.
+            // This will add an entry to the "templates" field in STGroup, however
+            // this should not be returned.
+            group.LookupTemplate("t2");
+
+            HashSet<string> names = group.GetTemplateNames();
+
+            // Should only contain "t" and "main" (not "t2")
+            Assert.AreEqual(2, names.Count);
+            CollectionAssert.Contains(names.ToList(), "/t");
+            CollectionAssert.Contains(names.ToList(), "/main");
+        }
+
[TestMethod][TestCategory(TestCategories.ST4)]
public void TestUnloadWithImports()
{
@@ -716,5 +741,39 @@ namespace Antlr4.Test.StringTemplate
st = group.GetInstanceOf("main");
Assert.AreEqual("v2-g2;f2", st.Render());
}
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLineBreakInGroup()
+        {
+            string templates =
+                "t() ::= <<" + newline +
+                "Foo <\\\\>" + newline +
+                "  \t  bar" + newline +
+                ">>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            Assert.IsNotNull(st);
+            string expecting = "Foo bar";     // expect \n in output
+            Assert.AreEqual(expecting, st.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLineBreakInGroup2()
+        {
+            string templates =
+                "t() ::= <<" + newline +
+                "Foo <\\\\>       " + newline +
+                "  \t  bar" + newline +
+                ">>" + newline;
+            writeFile(tmpdir, "t.stg", templates);
+            TemplateGroup group = new TemplateGroupFile(tmpdir + Path.DirectorySeparatorChar + "t.stg");
+            Template st = group.GetInstanceOf("t");
+            Assert.IsNotNull(st);
+            string expecting = "Foo bar";     // expect \n in output
+            Assert.AreEqual(expecting, st.Render());
+        }
}
}
diff --git a/Antlr4.Test.StringTemplate/TestImports.cs b/Antlr4.Test.StringTemplate/TestImports.cs
index 617fb87..4b3ec6d 100644
--- a/Antlr4.Test.StringTemplate/TestImports.cs
+++ b/Antlr4.Test.StringTemplate/TestImports.cs
@@ -35,6 +35,7 @@ namespace Antlr4.Test.StringTemplate
using System.Runtime.CompilerServices;
using Antlr4.StringTemplate;
using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using ErrorBuffer = Antlr4.StringTemplate.Misc.ErrorBuffer;
using Path = System.IO.Path;

[TestClass]
@@ -78,6 +79,7 @@ namespace Antlr4.Test.StringTemplate
subdir
a.st
b.st
+                    c.st
*/
string dir = tmpdir;
string gstr =
@@ -85,16 +87,21 @@ namespace Antlr4.Test.StringTemplate
"a() ::= <<dir1 a>>\n";
writeFile(dir, "g.stg", gstr);

-            string a = "a() ::= <<dir2 a>>\n";
-            string b = "b() ::= <<dir2 b>>\n";
+            string a = "a() ::= <<subdir a>>\n";
+            string b = "b() ::= <<subdir b>>\n";
+            string c = "c() ::= <<subdir b>>\n";
writeFile(dir, Path.Combine("subdir", "a.st"), a);
writeFile(dir, Path.Combine("subdir", "b.st"), b);
+            writeFile(dir, Path.Combine("subdir", "c.st"), c);

TemplateGroup group = new TemplateGroupFile(Path.Combine(dir, "g.stg"));
Template st = group.GetInstanceOf("b"); // visible only if import worked
-            string expected = "dir2 b";
+            string expected = "subdir b";
string result = st.Render();
Assert.AreEqual(expected, result);
+            st = group.GetInstanceOf("c");
+            result = st.Render();
+            Assert.AreEqual(expected, result);
}

[TestMethod][TestCategory(TestCategories.ST4)]
@@ -411,5 +418,78 @@ namespace Antlr4.Test.StringTemplate
expected = "dir1 b";
Assert.AreEqual(expected, result);
}
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestUnloadImportedTemplatedSpecifiedInGroupFile()
+        {
+            writeFile(tmpdir, "t.stg",
+                    "import \"g1.stg\"\n\nmain() ::= <<\nv1-<f()>\n>>");
+            writeFile(tmpdir, "g1.stg", "f() ::= \"g1\"");
+            writeFile(tmpdir, "g2.stg", "f() ::= \"g2\"\nf2() ::= \"f2\"\n");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            Template st = group.GetInstanceOf("main");
+            Assert.AreEqual("v1-g1", st.Render());
+
+            // Change the imports of group t.
+            writeFile(tmpdir, "t.stg",
+                    "import \"g2.stg\"\n\nmain() ::= <<\nv2-<f()>;<f2()>\n>>");
+            group.Unload(); // will also unload already imported groups
+            st = group.GetInstanceOf("main");
+            Assert.AreEqual("v2-g2;f2", st.Render());
+        }
+
+        /** Cannot import from a group file unless it's the root.
+         */
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestGroupFileInDirImportsAnotherGroupFile()
+        {
+            // /randomdir/group.stg with a() imports /randomdir/imported.stg with b()
+            // can't have groupdir then groupfile inside that imports
+            string dir = tmpdir;
+            string groupFile =
+                "import \"imported.stg\"\n" +
+                "a() ::= \"a: <b()>\"\n";
+            writeFile(dir, "group.stg", groupFile);
+            string importedFile =
+                "b() ::= \"b\"\n";
+            writeFile(dir, "imported.stg", importedFile);
+            ITemplateErrorListener errors = new ErrorBuffer();
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            group.Listener = errors;
+            group.GetInstanceOf("/group/a");
+            string result = errors.ToString();
+            string substring =
+                "import illegal in group files embedded in TemplateGroupDirectory; import \"imported.stg\" in TemplateGroupDirectory";
+            StringAssert.Contains(result, substring);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestGroupFileInDirImportsAGroupDir()
+        {
+            /*
+            dir
+                g.stg has a() that imports subdir with relative path
+                subdir
+                    b.st
+                    c.st
+             */
+            string dir = tmpdir;
+            string gstr =
+                "import \"subdir\"\n" + // finds subdir in dir
+                "a() ::= \"a: <b()>\"\n";
+            writeFile(dir, "g.stg", gstr);
+
+            writeFile(dir, "subdir/b.st", "b() ::= \"b: <c()>\"\n");
+            writeFile(dir, "subdir/c.st", "c() ::= <<subdir c>>\n");
+
+            TemplateGroup group = new TemplateGroupFile(dir + "/g.stg");
+            Template st = group.GetInstanceOf("a");
+            string expected = "a: b: subdir c";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
}
}
diff --git a/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs b/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs
index ff70b3f..7b9aafa 100644
--- a/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs
+++ b/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs
@@ -35,6 +35,7 @@ namespace Antlr4.Test.StringTemplate
using Antlr4.StringTemplate;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;
+    using ErrorBuffer = Antlr4.StringTemplate.Misc.ErrorBuffer;

[TestClass]
public class TestIndirectionAndEarlyEval : BaseTest
@@ -78,6 +79,25 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expected, result);
}

+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestIndirectCallWithPassThru()
+        {
+            // pass-through for dynamic template invocation is not supported by the
+            // bytecode representation
+            writeFile(tmpdir, "t.stg",
+                "t1(x) ::= \"<x>\"\n" +
+                "main(x=\"hello\",t=\"t1\") ::= <<\n" +
+                "<(t)(...)>\n" +
+                ">>");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
+            ErrorBuffer errors = new ErrorBuffer();
+            group.Listener = errors;
+            Template st = group.GetInstanceOf("main");
+            Assert.AreEqual("t.stg 2:34: mismatched input '...' expecting RPAREN" + newline, errors.ToString());
+            Assert.IsNull(st);
+        }
+
[TestMethod][TestCategory(TestCategories.ST4)]
public void TestIndirectTemplateIncludeViaTemplate()
{
diff --git a/Antlr4.Test.StringTemplate/TestLineWrap.cs b/Antlr4.Test.StringTemplate/TestLineWrap.cs
index d3af6a2..b458953 100644
--- a/Antlr4.Test.StringTemplate/TestLineWrap.cs
+++ b/Antlr4.Test.StringTemplate/TestLineWrap.cs
@@ -157,7 +157,7 @@ namespace Antlr4.Test.StringTemplate
public void TestLineWrapEdgeCase()
{
string templates =
-                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\">\\>>" + newline;
writeFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

@@ -174,7 +174,7 @@ namespace Antlr4.Test.StringTemplate
public void TestLineWrapLastCharIsNewline()
{
string templates =
-                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\">\\>>" + newline;
writeFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

@@ -191,7 +191,7 @@ namespace Antlr4.Test.StringTemplate
public void TestLineWrapCharAfterWrapIsNewline()
{
string templates =
-                    "duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
+                    "duh(chars) ::= <<<chars; wrap=\"\\n\">\\>>" + newline;
writeFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

@@ -284,7 +284,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIndentBeyondLineWidth()
{
string templates =
-                    "duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
+                    "duh(chars) ::= <<    <chars; wrap=\"\\n\">\\>>" + newline;
writeFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

@@ -304,7 +304,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIndentedExpr()
{
string templates =
-                    "duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
+                    "duh(chars) ::= <<    <chars; wrap=\"\\n\">\\>>" + newline;
writeFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

@@ -324,7 +324,7 @@ namespace Antlr4.Test.StringTemplate
{
string templates =
"top(d) ::= <<  <d>!>>" + newline +
-                    "duh(chars) ::= <<  <chars; wrap=\"\\n\"\\>>>" + newline;
+                    "duh(chars) ::= <<  <chars; wrap=\"\\n\">\\>>" + newline;
writeFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

@@ -345,7 +345,7 @@ namespace Antlr4.Test.StringTemplate
{
string templates =
"top(d) ::= <<  <d>!>>" + newline +
-                    "duh(chars) ::= <<x: <chars; anchor, wrap=\"\\n\"\\>>>" + newline;
+                    "duh(chars) ::= <<x: <chars; anchor, wrap=\"\\n\">\\>>" + newline;
writeFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

@@ -402,7 +402,7 @@ namespace Antlr4.Test.StringTemplate
{
string templates =
"top(arrays) ::= <<Arrays: <arrays>done>>" + newline +
-                    "array(values) ::= <<int[] a = { <values; anchor, wrap=\"\\n\", separator=\",\"> };<\\n\\>>>" + newline;
+                    "array(values) ::= <<int[] a = { <values; anchor, wrap=\"\\n\", separator=\",\"> };<\\n>\\>>" + newline;
writeFile(tmpdir, "t.stg", templates);
TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

diff --git a/Antlr4.Test.StringTemplate/TestLists.cs b/Antlr4.Test.StringTemplate/TestLists.cs
index 3d6fa44..11bf89c 100644
--- a/Antlr4.Test.StringTemplate/TestLists.cs
+++ b/Antlr4.Test.StringTemplate/TestLists.cs
@@ -169,7 +169,7 @@ namespace Antlr4.Test.StringTemplate
);
e.Add("phones", "1");
e.Add("phones", "2");
-            string expecting = "foo, foo";  // only one since template application gives nothing
+            string expecting = "foo, foo";
Assert.AreEqual(expecting, e.Render());
}

@@ -217,5 +217,18 @@ namespace Antlr4.Test.StringTemplate
string result = e.Render();
Assert.AreEqual(expecting, result);
}
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestListWithTwoEmptyListsCollapsesToEmptyList()
+        {
+            Template e = new Template(
+                "<[[],[]]:{x | <x>!}; separator=\", \">"
+            );
+            e.Add("names", "Ter");
+            e.Add("names", "Tom");
+            string expecting = "";
+            Assert.AreEqual(expecting, e.Render());
+        }
}
}
diff --git a/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs b/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs
index 04fb616..30b3fcf 100644
--- a/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs
+++ b/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs
@@ -35,11 +35,240 @@ namespace Antlr4.Test.StringTemplate
using Antlr4.StringTemplate;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using System.Collections.Generic;
+    using System.Linq;
+    using NotImplementedException = System.NotImplementedException;
using StringWriter = System.IO.StringWriter;

[TestClass]
public class TestNullAndEmptyValues : BaseTest
{
+        private class T
+        {
+            public string template;
+            public object x;
+            public string expecting;
+
+            public string result;
+
+            public T(string template, object x, string expecting)
+            {
+                this.template = template;
+                this.x = x;
+                this.expecting = expecting;
+            }
+
+            public T(T t)
+            {
+                this.template = t.template;
+                this.x = t.x;
+                this.expecting = t.expecting;
+            }
+
+            public override string ToString()
+            {
+                string s = x.ToString();
+                if (x.GetType().IsArray)
+                {
+                    throw new NotImplementedException();
+                    //s = Arrays.toString((object[])x);
+                }
+                return "('" + template + "', " + s + ", '" + expecting + "', '" + result + "')";
+            }
+        }
+
+        private static readonly object UNDEF = "<undefined>";
+        private static readonly IList<object> LIST0 = new List<object>();
+
+        private static readonly T[] singleValuedTests = new T[] {
+        new T("<x>", UNDEF, ""),
+        new T("<x>", null, ""),
+        new T("<x>", "", ""),
+        new T("<x>", LIST0, ""),
+
+        new T("<x:t()>", UNDEF, ""),
+        new T("<x:t()>", null, ""),
+        new T("<x:t()>", "", ""),
+        new T("<x:t()>", LIST0, ""),
+
+        new T("<x; null={y}>", UNDEF, "y"),
+        new T("<x; null={y}>", null, "y"),
+        new T("<x; null={y}>", "", ""),
+        new T("<x; null={y}>", LIST0, ""),
+
+        new T("<x:t(); null={y}>", UNDEF, "y"),
+        new T("<x:t(); null={y}>", null, "y"),
+        new T("<x:t(); null={y}>", "", ""),
+        new T("<x:t(); null={y}>", LIST0, ""),
+
+        new T("<if(x)>y<endif>", UNDEF, ""),
+        new T("<if(x)>y<endif>", null, ""),
+        new T("<if(x)>y<endif>", "", "y"),
+        new T("<if(x)>y<endif>", LIST0, ""),
+
+        new T("<if(x)>y<else>z<endif>", UNDEF, "z"),
+        new T("<if(x)>y<else>z<endif>", null, "z"),
+        new T("<if(x)>y<else>z<endif>", "", "y"),
+        new T("<if(x)>y<else>z<endif>", LIST0, "z"),
+    };
+
+        private static readonly string[] LISTa = { "a" };
+        private static readonly string[] LISTab = { "a", "b" };
+        private static readonly string[] LISTnull = { null };
+        private static readonly string[] LISTa_null = { "a", null };
+        private static readonly string[] LISTnull_b = { null, "b" };
+        private static readonly string[] LISTa_null_b = { "a", null, "b" };
+
+        private static readonly T[] multiValuedTests = new T[] {
+        new T("<x>", LIST0,        ""),
+        new T("<x>", LISTa,        "a"),
+        new T("<x>", LISTab,       "ab"),
+        new T("<x>", LISTnull,     ""),
+        new T("<x>", LISTnull_b,   "b"),
+        new T("<x>", LISTa_null,   "a"),
+        new T("<x>", LISTa_null_b, "ab"),
+
+        new T("<x; null={y}>", LIST0,        ""),
+        new T("<x; null={y}>", LISTa,        "a"),
+        new T("<x; null={y}>", LISTab,       "ab"),
+        new T("<x; null={y}>", LISTnull,     "y"),
+        new T("<x; null={y}>", LISTnull_b,   "yb"),
+        new T("<x; null={y}>", LISTa_null,   "ay"),
+        new T("<x; null={y}>", LISTa_null_b, "ayb"),
+
+        new T("<x; separator={,}>", LIST0,        ""),
+        new T("<x; separator={,}>", LISTa,        "a"),
+        new T("<x; separator={,}>", LISTab,       "a,b"),
+        new T("<x; separator={,}>", LISTnull,     ""),
+        new T("<x; separator={,}>", LISTnull_b,   "b"),
+        new T("<x; separator={,}>", LISTa_null,   "a"),
+        new T("<x; separator={,}>", LISTa_null_b, "a,b"),
+
+        new T("<x; null={y}, separator={,}>", LIST0,        ""),
+        new T("<x; null={y}, separator={,}>", LISTa,        "a"),
+        new T("<x; null={y}, separator={,}>", LISTab,       "a,b"),
+        new T("<x; null={y}, separator={,}>", LISTnull,     "y"),
+        new T("<x; null={y}, separator={,}>", LISTnull_b,   "y,b"),
+        new T("<x; null={y}, separator={,}>", LISTa_null,   "a,y"),
+        new T("<x; null={y}, separator={,}>", LISTa_null_b, "a,y,b"),
+
+        new T("<if(x)>y<endif>", LIST0,        ""),
+        new T("<if(x)>y<endif>", LISTa,        "y"),
+        new T("<if(x)>y<endif>", LISTab,       "y"),
+        new T("<if(x)>y<endif>", LISTnull,     "y"),
+        new T("<if(x)>y<endif>", LISTnull_b,   "y"),
+        new T("<if(x)>y<endif>", LISTa_null,   "y"),
+        new T("<if(x)>y<endif>", LISTa_null_b, "y"),
+
+        new T("<x:{it | <it>}>", LIST0,        ""),
+        new T("<x:{it | <it>}>", LISTa,        "a"),
+        new T("<x:{it | <it>}>", LISTab,       "ab"),
+        new T("<x:{it | <it>}>", LISTnull,     ""),
+        new T("<x:{it | <it>}>", LISTnull_b,   "b"),
+        new T("<x:{it | <it>}>", LISTa_null,   "a"),
+        new T("<x:{it | <it>}>", LISTa_null_b, "ab"),
+
+        new T("<x:{it | <it>}; null={y}>", LIST0,        ""),
+        new T("<x:{it | <it>}; null={y}>", LISTa,        "a"),
+        new T("<x:{it | <it>}; null={y}>", LISTab,       "ab"),
+        new T("<x:{it | <it>}; null={y}>", LISTnull,     "y"),
+        new T("<x:{it | <it>}; null={y}>", LISTnull_b,   "yb"),
+        new T("<x:{it | <it>}; null={y}>", LISTa_null,   "ay"),
+        new T("<x:{it | <it>}; null={y}>", LISTa_null_b, "ayb"),
+
+        new T("<x:{it | <i>.<it>}>", LIST0,        ""),
+        new T("<x:{it | <i>.<it>}>", LISTa,        "1.a"),
+        new T("<x:{it | <i>.<it>}>", LISTab,       "1.a2.b"),
+        new T("<x:{it | <i>.<it>}>", LISTnull,     ""),
+        new T("<x:{it | <i>.<it>}>", LISTnull_b,   "1.b"),
+        new T("<x:{it | <i>.<it>}>", LISTa_null,   "1.a"),
+        new T("<x:{it | <i>.<it>}>", LISTa_null_b, "1.a2.b"),
+
+        new T("<x:{it | <i>.<it>}; null={y}>", LIST0,        ""),
+        new T("<x:{it | <i>.<it>}; null={y}>", LISTa,        "1.a"),
+        new T("<x:{it | <i>.<it>}; null={y}>", LISTab,       "1.a2.b"),
+        new T("<x:{it | <i>.<it>}; null={y}>", LISTnull,     "y"),
+        new T("<x:{it | <i>.<it>}; null={y}>", LISTnull_b,   "y1.b"),
+        new T("<x:{it | <i>.<it>}; null={y}>", LISTa_null,   "1.ay"),
+        new T("<x:{it | <i>.<it>}; null={y}>", LISTa_null_b, "1.ay2.b"),
+
+        new T("<x:{it | x<if(!it)>y<endif>}; null={z}>", LIST0,        ""),
+        new T("<x:{it | x<if(!it)>y<endif>}; null={z}>", LISTa,        "x"),
+        new T("<x:{it | x<if(!it)>y<endif>}; null={z}>", LISTab,       "xx"),
+        new T("<x:{it | x<if(!it)>y<endif>}; null={z}>", LISTnull,     "z"),
+        new T("<x:{it | x<if(!it)>y<endif>}; null={z}>", LISTnull_b,   "zx"),
+        new T("<x:{it | x<if(!it)>y<endif>}; null={z}>", LISTa_null,   "xz"),
+        new T("<x:{it | x<if(!it)>y<endif>}; null={z}>", LISTa_null_b, "xzx"),
+
+        new T("<x:t():u(); null={y}>", LIST0,        ""),
+        new T("<x:t():u(); null={y}>", LISTa,        "a"),
+        new T("<x:t():u(); null={y}>", LISTab,       "ab"),
+        new T("<x:t():u(); null={y}>", LISTnull,     "y"),
+        new T("<x:t():u(); null={y}>", LISTnull_b,   "yb"),
+        new T("<x:t():u(); null={y}>", LISTa_null,   "ay"),
+        new T("<x:t():u(); null={y}>", LISTa_null_b, "ayb")
+    };
+
+        private static readonly T[] listTests = new T[] {
+        new T("<[]>", UNDEF, ""),
+        new T("<[]; null={x}>", UNDEF, ""),
+        new T("<[]:{it | x}>", UNDEF, ""),
+        new T("<[[],[]]:{it| x}>", UNDEF, ""),
+        new T("<[]:t()>", UNDEF, ""),
+    };
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSingleValued()
+        {
+            IList<T> failed = TestMatrix(singleValuedTests);
+            IList<T> expecting = new List<T>();
+            CollectionAssert.AreEqual(expecting.ToList(), failed.ToList());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestMultiValued()
+        {
+            IList<T> failed = TestMatrix(multiValuedTests);
+            IList<T> expecting = new List<T>();
+            CollectionAssert.AreEqual(expecting.ToList(), failed.ToList());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestLists()
+        {
+            IList<T> failed = TestMatrix(listTests);
+            IList<T> expecting = new List<T>();
+            CollectionAssert.AreEqual(expecting.ToList(), failed.ToList());
+        }
+
+        private IList<T> TestMatrix(T[] tests)
+        {
+            IList<T> failed = new List<T>();
+            foreach (T t in tests)
+            {
+                T test = new T(t); // dup since we might mod with result
+                TemplateGroup group = new TemplateGroup();
+                //System.out.println("running "+test);
+                group.DefineTemplate("t", "<x>", new string[] { "x" });
+                group.DefineTemplate("u", "<x>", new string[] { "x" });
+                group.DefineTemplate("test", test.template, new string[] { "x" });
+                Template st = group.GetInstanceOf("test");
+                if (test.x != UNDEF)
+                {
+                    st.Add("x", test.x);
+                }
+                string result = st.Render();
+                if (!result.Equals(test.expecting))
+                {
+                    test.result = result;
+                    failed.Add(test);
+                }
+            }
+            return failed;
+        }
+
[TestMethod][TestCategory(TestCategories.ST4)]
public void TestSeparatorWithNullFirstValue()
{
@@ -245,6 +474,25 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expecting, result);
}

+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSeparatorEmittedForEmptyIteratorValu3333e()
+        {
+            string dir = tmpdir;
+            string groupFile =
+                "filter ::= [\"b\":, default: key]\n" +
+                "t() ::= <%<[\"a\", \"b\", \"c\", \"b\"]:{it | <filter.(it)>}; separator=\",\">%>\n";
+            writeFile(dir, "group.stg", groupFile);
+            TemplateGroupFile group = new TemplateGroupFile(dir + "/group.stg");
+
+            Template st = group.GetInstanceOf("t");
+            StringWriter sw = new StringWriter();
+            st.Write(new AutoIndentWriter(sw));
+            string result = sw.ToString();
+            string expecting = "a,,c,";
+            Assert.AreEqual(expecting, result);
+        }
+
[TestMethod][TestCategory(TestCategories.ST4)]
public void TestSeparatorEmittedForEmptyIteratorValue2()
{
diff --git a/Antlr4.Test.StringTemplate/TestRegions.cs b/Antlr4.Test.StringTemplate/TestRegions.cs
index 9fe01b7..732ad74 100644
--- a/Antlr4.Test.StringTemplate/TestRegions.cs
+++ b/Antlr4.Test.StringTemplate/TestRegions.cs
@@ -188,6 +188,26 @@ namespace Antlr4.Test.StringTemplate
Assert.AreEqual(expected, result);
}

+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestAnonymousTemplateInRegionInSubdir()
+        {
+            //fails since it makes region name /region__/g/a/_r
+            string dir = tmpdir;
+            string g = "a() ::= <<[<@r()>]>>\n" +
+                       "@a.r() ::= <<\n" +
+                       "<[\"foo\"]:{x|<x>}>\n" +
+                       ">>\n";
+            writeFile(dir, "g.stg", g);
+
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            group.Verbose = true;
+            Template st = group.GetInstanceOf("g/a");
+            string expected = "[foo]";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
[TestMethod][TestCategory(TestCategories.ST4)]
public void TestCantDefineEmbeddedRegionAgain()
{
@@ -392,7 +412,7 @@ namespace Antlr4.Test.StringTemplate
string dir = tmpdir;
string g =
"a() ::= <<\n" +
-                    "X<@r()>Y" +
+                    "X<@r()>Y\n" +
">>\n" +
"@a.q() ::= \"foo\"" + newline;
ITemplateErrorListener errors = new ErrorBuffer();
@@ -402,7 +422,7 @@ namespace Antlr4.Test.StringTemplate
Template st = group.GetInstanceOf("a");
st.Render();
string result = errors.ToString();
-            string expecting = "g.stg 3:3: template a doesn't have a region called q" + newline;
+            string expecting = "g.stg 4:3: template /a doesn't have a region called q" + newline;
Assert.AreEqual(expecting, result);
}

diff --git a/Antlr4.Test.StringTemplate/TestRenderers.cs b/Antlr4.Test.StringTemplate/TestRenderers.cs
index 3a10d17..536727d 100644
--- a/Antlr4.Test.StringTemplate/TestRenderers.cs
+++ b/Antlr4.Test.StringTemplate/TestRenderers.cs
@@ -36,104 +36,117 @@ namespace Antlr4.Test.StringTemplate
using Antlr4.StringTemplate;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using CultureInfo = System.Globalization.CultureInfo;
+    using DateTime = System.DateTime;
+    using DateTimeOffset = System.DateTimeOffset;
using Path = System.IO.Path;

[TestClass]
public class TestRenderers : BaseTest
{
-#if false // date renderer
[TestMethod][TestCategory(TestCategories.ST4)]
public void TestRendererForGroup()
{
string templates =
"dateThing(created) ::= \"datetime: <created>\"\n";
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
-            ST st = group.getInstanceOf("dateThing");
-            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
-            string expecting = "datetime: 7/5/05 12:00 AM";
-            string result = st.render();
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.RegisterRenderer(typeof(DateTime), new DateRenderer());
+            group.RegisterRenderer(typeof(DateTimeOffset), new DateRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 07, 05));
+            string expecting = "datetime: 7/5/2005 12:00 AM";
+            string result = st.Render();
Assert.AreEqual(expecting, result);
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRendererWithFormat()
{
string templates =
"dateThing(created) ::= << date: <created; format=\"yyyy.MM.dd\"> >>\n";
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
-            ST st = group.getInstanceOf("dateThing");
-            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.RegisterRenderer(typeof(DateTime), new DateRenderer());
+            group.RegisterRenderer(typeof(DateTimeOffset), new DateRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 07, 05));
string expecting = " date: 2005.07.05 ";
-            string result = st.render();
+            string result = st.Render();
Assert.AreEqual(expecting, result);
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRendererWithPredefinedFormat()
{
string templates =
"dateThing(created) ::= << datetime: <created; format=\"short\"> >>\n";
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
-            ST st = group.getInstanceOf("dateThing");
-            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
-            string expecting = " datetime: 7/5/05 12:00 AM ";
-            string result = st.render();
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.RegisterRenderer(typeof(DateTime), new DateRenderer());
+            group.RegisterRenderer(typeof(DateTimeOffset), new DateRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 07, 05));
+            string expecting = " datetime: 7/5/2005 12:00 AM ";
+            string result = st.Render();
Assert.AreEqual(expecting, result);
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRendererWithPredefinedFormat2()
{
string templates =
"dateThing(created) ::= << datetime: <created; format=\"full\"> >>\n";
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
-            ST st = group.getInstanceOf("dateThing");
-            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
-            string expecting = " datetime: Tuesday, July 5, 2005 12:00:00 AM PDT ";
-            string result = st.render();
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.RegisterRenderer(typeof(DateTime), new DateRenderer());
+            group.RegisterRenderer(typeof(DateTimeOffset), new DateRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 07, 05));
+            string expecting = " datetime: Tuesday, July 05, 2005 12:00:00 AM ";
+            string result = st.Render();
Assert.AreEqual(expecting, result);
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [Ignore] // medium is not supported on .NET
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRendererWithPredefinedFormat3()
{
string templates =
"dateThing(created) ::= << date: <created; format=\"date:medium\"> >>\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
-            ST st = group.getInstanceOf("dateThing");
-            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.RegisterRenderer(typeof(DateTime), new DateRenderer());
+            group.RegisterRenderer(typeof(DateTimeOffset), new DateRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 07, 05));
string expecting = " date: Jul 5, 2005 ";
-            string result = st.render();
+            string result = st.Render();
Assert.AreEqual(expecting, result);
}

-        [TestMethod][TestCategory(TestCategories.ST4)]
+        [Ignore] // medium is not supported on .NET
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
public void TestRendererWithPredefinedFormat4()
{
string templates =
"dateThing(created) ::= << time: <created; format=\"time:medium\"> >>\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            group.registerRenderer(typeof(GregorianCalendar), new DateRenderer());
-            ST st = group.getInstanceOf("dateThing");
-            st.add("created", new GregorianCalendar(2005, 07 - 1, 05));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            group.RegisterRenderer(typeof(DateTime), new DateRenderer());
+            group.RegisterRenderer(typeof(DateTimeOffset), new DateRenderer());
+            Template st = group.GetInstanceOf("dateThing");
+            st.Add("created", new DateTime(2005, 07, 05));
string expecting = " time: 12:00:00 AM ";
-            string result = st.render();
+            string result = st.Render();
Assert.AreEqual(expecting, result);
}
-#endif

[TestMethod][TestCategory(TestCategories.ST4)]
public void TestStringRendererWithPrintfFormat()
diff --git a/Antlr4.Test.StringTemplate/TestTemplateRawGroupDirectory.cs b/Antlr4.Test.StringTemplate/TestTemplateRawGroupDirectory.cs
new file mode 100644
index 0000000..db69c67
--- /dev/null
+++ b/Antlr4.Test.StringTemplate/TestTemplateRawGroupDirectory.cs
@@ -0,0 +1,151 @@
+﻿/*
+ * [The "BSD license"]
+ * Copyright (c) 2012 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2012 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.Test.StringTemplate
+{
+    using Antlr4.StringTemplate;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using System.Collections.Generic;
+
+    [TestClass]
+    public class TestTemplateRawGroupDirectory : BaseTest
+    {
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSimpleGroup()
+        {
+            string dir = tmpdir;
+            writeFile(dir, "a.st", "foo");
+            TemplateGroup group = new TemplateRawGroupDirectory(dir, '$', '$');
+            Template st = group.GetInstanceOf("a");
+            string expected = "foo";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSimpleGroup2()
+        {
+            string dir = tmpdir;
+            writeFile(dir, "a.st", "foo");
+            writeFile(dir, "b.st", "$name$");
+            TemplateGroup group = new TemplateRawGroupDirectory(dir, '$', '$');
+            Template st = group.GetInstanceOf("a");
+            string expected = "foo";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+
+            Template b = group.GetInstanceOf("b");
+            b.Add("name", "Bob");
+            Assert.AreEqual("Bob", b.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSimpleGroupAngleBrackets()
+        {
+            string dir = tmpdir;
+            writeFile(dir, "a.st", "foo");
+            writeFile(dir, "b.st", "<name>");
+            TemplateGroup group = new TemplateRawGroupDirectory(dir);
+            Template st = group.GetInstanceOf("a");
+            string expected = "foo";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+
+            Template b = group.GetInstanceOf("b");
+            b.Add("name", "Bob");
+            Assert.AreEqual("Bob", b.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestAnonymousTemplateInRawTemplate()
+        {
+            string dir = tmpdir;
+            writeFile(dir, "template.st", "$values:{foo|[$foo$]}$");
+            TemplateGroup group = new TemplateRawGroupDirectory(dir, '$', '$');
+            Template template = group.GetInstanceOf("template");
+            List<string> values = new List<string>();
+            values.Add("one");
+            values.Add("two");
+            values.Add("three");
+            template.Add("values", values);
+            Assert.AreEqual("[one][two][three]", template.Render());
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestMap()
+        {
+            string dir = tmpdir;
+            writeFile(dir, "a.st", "$names:bold()$");
+            writeFile(dir, "bold.st", "<b>$it$</b>");
+            TemplateGroup group = new TemplateRawGroupDirectory(dir, '$', '$');
+            Template st = group.GetInstanceOf("a");
+            List<string> names = new List<string>();
+            names.Add("parrt");
+            names.Add("tombu");
+            st.Add("names", names);
+            //string asmResult = st.impl.GetInstructions();
+            //Console.Out.WriteLine(asmResult);
+
+            //st.Visualize();
+            string expected = "<b>parrt</b><b>tombu</b>";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        [TestCategory(TestCategories.ST4)]
+        public void TestSuper()
+        {
+            string dir1 = tmpdir + "dir1011";
+            string a = "dir1 a";
+            string b = "dir1 b";
+            writeFile(dir1, "a.st", a);
+            writeFile(dir1, "b.st", b);
+            string dir2 = tmpdir + "dir0220";
+            a = "[<super.a()>]";
+            writeFile(dir2, "a.st", a);
+
+            TemplateGroup group1 = new TemplateRawGroupDirectory(dir1);
+            TemplateGroup group2 = new TemplateRawGroupDirectory(dir2);
+            group2.ImportTemplates(group1);
+            Template st = group2.GetInstanceOf("a");
+            string expected = "[dir1 a]";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+    }
+}
diff --git a/Reference/stringtemplate4 b/Reference/stringtemplate4
index feeb77e..5c64dc6 160000
--- a/Reference/stringtemplate4
+++ b/Reference/stringtemplate4
@@ -1 +1 @@
-Subproject commit feeb77e3cecd8c42ff080cd8815cb895fa263dd6
+Subproject commit 5c64dc6fe7062399fd341bac41bcb8d4b6dbb93b

