commit a29f980070f9e59c7b88ca7a674541309088fe14
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Mon Jan 24 10:00:14 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Mon Jan 24 10:00:14 2011 -0800

(C# 3) C# naming conventions

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 7517]

diff --git a/Antlr4.StringTemplate.Visualizer/Extensions/ListExtensions.cs b/Antlr4.StringTemplate.Visualizer/Extensions/ListExtensions.cs
index d635c40..bf0a443 100644
--- a/Antlr4.StringTemplate.Visualizer/Extensions/ListExtensions.cs
+++ b/Antlr4.StringTemplate.Visualizer/Extensions/ListExtensions.cs
@@ -40,10 +40,10 @@ namespace Antlr4.StringTemplate.Visualizer.Extensions
{
public static string ToListString(this IList list)
{
-            STGroup group = new STGroup('$', '$');
+            TemplateGroup group = new TemplateGroup('$', '$');
group.defineTemplate("listTemplate", "list", "[$list:{x|$x$}; separator=\", \"$]");
group.registerRenderer(typeof(IList), new CollectionRenderer());
-            ST st = group.getInstanceOf("listTemplate");
+            Template st = group.getInstanceOf("listTemplate");
st.add("list", list);
return st.render();
}
diff --git a/Antlr4.StringTemplate.Visualizer/TemplateVisualizer.cs b/Antlr4.StringTemplate.Visualizer/TemplateVisualizer.cs
index a497f88..be6fac7 100644
--- a/Antlr4.StringTemplate.Visualizer/TemplateVisualizer.cs
+++ b/Antlr4.StringTemplate.Visualizer/TemplateVisualizer.cs
@@ -45,9 +45,9 @@ namespace Antlr4.StringTemplate.Visualizer
private readonly string _output;
private readonly Interpreter _interpreter;
private readonly List<string> _trace;
-        private readonly ReadOnlyCollection<STMessage> _errors;
+        private readonly ReadOnlyCollection<TemplateMessage> _errors;

-        public TemplateVisualizer(ErrorManager errorManager, DebugST root, string output, Interpreter interpreter, List<string> trace, ReadOnlyCollection<STMessage> errors)
+        public TemplateVisualizer(ErrorManager errorManager, DebugST root, string output, Interpreter interpreter, List<string> trace, ReadOnlyCollection<TemplateMessage> errors)
{
if (errorManager == null)
throw new ArgumentNullException("errorManager");
@@ -108,7 +108,7 @@ namespace Antlr4.StringTemplate.Visualizer
}
}

-        public ReadOnlyCollection<STMessage> Errors
+        public ReadOnlyCollection<TemplateMessage> Errors
{
get
{
diff --git a/Antlr4.StringTemplate.Visualizer/TemplateVisualizerFrame.xaml.cs b/Antlr4.StringTemplate.Visualizer/TemplateVisualizerFrame.xaml.cs
index d13e560..5f1bb1c 100644
--- a/Antlr4.StringTemplate.Visualizer/TemplateVisualizerFrame.xaml.cs
+++ b/Antlr4.StringTemplate.Visualizer/TemplateVisualizerFrame.xaml.cs
@@ -92,8 +92,8 @@ namespace Antlr4.StringTemplate.Visualizer
private void HandleErrorsListBoxSelectionChanged(object sender, SelectionChangedEventArgs e)
{
int minIndex = ErrorsListBox.SelectedIndex;
-            STMessage message = ErrorsListBox.SelectedItem as STMessage;
-            STRuntimeMessage runtimeMessage = message as STRuntimeMessage;
+            TemplateMessage message = ErrorsListBox.SelectedItem as TemplateMessage;
+            TemplateRuntimeMessage runtimeMessage = message as TemplateRuntimeMessage;
if (runtimeMessage != null)
{
Interval interval = runtimeMessage.SourceInterval;
@@ -182,7 +182,7 @@ namespace Antlr4.StringTemplate.Visualizer
}
}

-        private static void SetSelectionPath(TemplateCallHierarchyViewModel treeView, ICollection<ST> selectionPath)
+        private static void SetSelectionPath(TemplateCallHierarchyViewModel treeView, ICollection<Template> selectionPath)
{
if (treeView == null || selectionPath == null || selectionPath.Count == 0 || treeView.Template != selectionPath.First())
return;
@@ -248,7 +248,7 @@ namespace Antlr4.StringTemplate.Visualizer
}
}

-        private int GetIndexOfChild(DebugST parent, ST child)
+        private int GetIndexOfChild(DebugST parent, Template child)
{
if (parent == null)
throw new ArgumentNullException("parent");
@@ -263,7 +263,7 @@ namespace Antlr4.StringTemplate.Visualizer

private void UpdateStack()
{
-            List<ST> stack = currentTemplate.getEnclosingInstanceStack(true);
+            List<Template> stack = currentTemplate.getEnclosingInstanceStack(true);
ViewModel.Title = string.Format("STViz - [{0}]", string.Join(" ", stack.Select(i => i.ToString()).ToArray()));
}

diff --git a/Antlr4.StringTemplate.Visualizer/TemplateVisualizerViewModel.cs b/Antlr4.StringTemplate.Visualizer/TemplateVisualizerViewModel.cs
index f55a2fc..b31766b 100644
--- a/Antlr4.StringTemplate.Visualizer/TemplateVisualizerViewModel.cs
+++ b/Antlr4.StringTemplate.Visualizer/TemplateVisualizerViewModel.cs
@@ -88,7 +88,7 @@ namespace Antlr4.StringTemplate.Visualizer
}
}

-        public ReadOnlyCollection<STMessage> Errors
+        public ReadOnlyCollection<TemplateMessage> Errors
{
get
{
diff --git a/Antlr4.StringTemplate/AutoIndentWriter.cs b/Antlr4.StringTemplate/AutoIndentWriter.cs
index 508a076..274d68b 100644
--- a/Antlr4.StringTemplate/AutoIndentWriter.cs
+++ b/Antlr4.StringTemplate/AutoIndentWriter.cs
@@ -52,7 +52,7 @@ namespace Antlr4.StringTemplate
*
*  \n is the proper way to say newline for options and templates.
*  Templates can mix \r\n and \n them but use \n for sure in options like
-     *  wrap="\n". ST will generate the right thing. Override the default (locale)
+     *  wrap="\n". Template will generate the right thing. Override the default (locale)
*  newline by passing in a string to the constructor.
*/
public class AutoIndentWriter : ITemplateWriter
diff --git a/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs b/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs
index 92b873a..b03fdf0 100644
--- a/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs
+++ b/Antlr4.StringTemplate/Compiler/BytecodeDisassembler.cs
@@ -40,9 +40,9 @@ namespace Antlr4.StringTemplate.Compiler

public class BytecodeDisassembler
{
-        private readonly CompiledST code;
+        private readonly CompiledTemplate code;

-        public BytecodeDisassembler(CompiledST code)
+        public BytecodeDisassembler(CompiledTemplate code)
{
this.code = code;
}
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3 b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
index 745ae68..029743f 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
@@ -47,7 +47,7 @@ using Antlr4.StringTemplate.Misc;
templateAndEOF : template[null,null] EOF; // hush warning; ignore

public
-template[string name, List<FormalArgument> args] returns [CompiledST impl]
+template[string name, List<FormalArgument> args] returns [CompiledTemplate impl]
scope {
CompilationState state; // automatically get a new state pointer per invocation
}
@@ -56,14 +56,14 @@ scope {
$impl = $template::state.impl;
if ($template.Count == 1) outermostImpl = $impl;
$impl.defineFormalArgs($args); // make sure args are defined prior to compilation
-	if ( name!=null && name.StartsWith(Compiler.SubtemplatePrefix) ) {
+	if ( name!=null && name.StartsWith(TemplateCompiler.SubtemplatePrefix) ) {
$impl.addArg(new FormalArgument("i"));
$impl.addArg(new FormalArgument("i0"));
}
$impl.template = _template; // always forget the entire template; char indexes are relative to it
}
:	chunk
-		{ // finish off the CompiledST result
+		{ // finish off the CompiledTemplate result
if ( $template::state.stringtable!=null ) $impl.strings = $template::state.stringtable.ToArray();
$impl.codeSize = $template::state.ip;
}
@@ -100,12 +100,12 @@ exprElement

region returns [string name]
:	^(	REGION ID
-			{$name = STGroup.getMangledRegionName(outermostTemplateName, $ID.text);}
+			{$name = TemplateGroup.getMangledRegionName(outermostTemplateName, $ID.text);}
template[$name,null]
{
-			CompiledST sub = $template.impl;
+			CompiledTemplate sub = $template.impl;
sub.isRegion = true;
-	        sub.regionDefType = ST.RegionType.Embedded;
+	        sub.regionDefType = Template.RegionType.Embedded;
sub.dump();
outermostImpl.addImplicitlyDefinedTemplate(sub);
}
@@ -114,7 +114,7 @@ region returns [string name]

subtemplate returns [string name, int nargs]
@init {
-    $name = Compiler.getNewSubtemplateName();
+    $name = TemplateCompiler.getNewSubtemplateName();
List<FormalArgument> args = new List<FormalArgument>();
}
:	^(	SUBTEMPLATE
@@ -122,9 +122,9 @@ subtemplate returns [string name, int nargs]
{$nargs = args.Count;}
template[$name,args]
{
-			CompiledST sub = $template.impl;
+			CompiledTemplate sub = $template.impl;
sub.isAnonSubtemplate = true;
-			if ( STGroup.debug ) {
+			if ( TemplateGroup.debug ) {
sub.ast = $SUBTEMPLATE;
sub.ast.SetUnknownTokenBoundaries();
sub.tokens = input.TokenStream;
@@ -260,14 +260,14 @@ includeExpr
else emit2($INCLUDE_SUPER, Bytecode.INSTR_SUPER_NEW, $ID.text, $args.n);
}
|	^(INCLUDE_REGION ID)		{
-									CompiledST impl =
-										Compiler.defineBlankRegion(outermostImpl, $ID.text);
+									CompiledTemplate impl =
+										TemplateCompiler.defineBlankRegion(outermostImpl, $ID.text);
impl.dump();
emit2($INCLUDE_REGION,Bytecode.INSTR_NEW,impl.name,0);
}
|	^(INCLUDE_SUPER_REGION ID)	{
-									CompiledST impl =
-										Compiler.defineBlankRegion(outermostImpl, $ID.text);
+									CompiledTemplate impl =
+										TemplateCompiler.defineBlankRegion(outermostImpl, $ID.text);
impl.dump();
emit2($INCLUDE_SUPER_REGION,Bytecode.INSTR_SUPER_NEW,impl.name,0);
}
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
index d51eb04..f4ce1fc 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
@@ -45,7 +45,7 @@ namespace Antlr4.StringTemplate.Compiler
/// <summary>Overall template text</summary>
private readonly string _template;
private readonly ErrorManager errMgr;
-        private CompiledST outermostImpl;
+        private CompiledTemplate outermostImpl;

public CodeGenerator(ITreeNodeStream input, ErrorManager errMgr, string name, string template, IToken templateToken)
: this(input, new RecognizerSharedState())
diff --git a/Antlr4.StringTemplate/Compiler/CompilationState.cs b/Antlr4.StringTemplate/Compiler/CompilationState.cs
index c869d95..d1cb933 100644
--- a/Antlr4.StringTemplate/Compiler/CompilationState.cs
+++ b/Antlr4.StringTemplate/Compiler/CompilationState.cs
@@ -38,14 +38,14 @@ namespace Antlr4.StringTemplate.Compiler
using Antlr4.StringTemplate.Misc;

/** temp data used during construction and functions that fill it / use it.
-     *  Result is impl CompiledST object.
+     *  Result is impl CompiledTemplate object.
*/
public class CompilationState
{
/** The compiled code implementation to fill in. */
-        internal CompiledST impl = new CompiledST();
+        internal CompiledTemplate impl = new CompiledTemplate();

-        /** Track unique strings; copy into CompiledST's String[] after compilation */
+        /** Track unique strings; copy into CompiledTemplate's String[] after compilation */
internal StringTable stringtable = new StringTable();

/** Track instruction location within code.instrs array; this is
@@ -94,14 +94,14 @@ namespace Antlr4.StringTemplate.Compiler

public virtual void setOption(CommonTree id)
{
-            Interpreter.Option O = Compiler.supportedOptions[id.Text];
+            Interpreter.Option O = TemplateCompiler.supportedOptions[id.Text];
emit1(id, Bytecode.INSTR_STORE_OPTION, (int)O);
}

public virtual void func(IToken templateToken, CommonTree id)
{
Bytecode funcBytecode;
-            if (!Compiler.funcs.TryGetValue(id.Text, out funcBytecode))
+            if (!TemplateCompiler.funcs.TryGetValue(id.Text, out funcBytecode))
{
errMgr.compileTimeError(ErrorType.NO_SUCH_FUNCTION, templateToken, id.token);
emit(id, Bytecode.INSTR_POP);
diff --git a/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs b/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
index 571543a..e05cd8d 100644
--- a/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
+++ b/Antlr4.StringTemplate/Compiler/CompiledTemplate.cs
@@ -41,12 +41,12 @@ namespace Antlr4.StringTemplate.Compiler
using Console = System.Console;
using ArgumentNullException = System.ArgumentNullException;

-    /** The result of compiling an ST.  Contains all the bytecode instructions,
+    /** The result of compiling an Template.  Contains all the bytecode instructions,
*  string table, bytecode address to source code map, and other bookkeeping
-     *  info.  It's the implementation of an ST you might say.  All instances
+     *  info.  It's the implementation of an Template you might say.  All instances
*  of the same template share a single implementation (impl field).
*/
-    public class CompiledST
+    public class CompiledTemplate
{
public string name;

@@ -68,13 +68,13 @@ namespace Antlr4.StringTemplate.Compiler
public bool hasFormalArgs;

/** A list of all regions and subtemplates */
-        public List<CompiledST> implicitlyDefinedTemplates;
+        public List<CompiledTemplate> implicitlyDefinedTemplates;

-        /** The group that physically defines this ST definition.  We use it to initiate
-         *  interpretation via ST.ToString().  From there, it becomes field 'group'
+        /** The group that physically defines this Template definition.  We use it to initiate
+         *  interpretation via Template.ToString().  From there, it becomes field 'group'
*  in interpreter and is fixed until rendering completes.
*/
-        public STGroup nativeGroup = STGroup.defaultGroup;
+        public TemplateGroup nativeGroup = TemplateGroup.defaultGroup;

/** Does this template come from a &lt;@region&gt;...&lt;@end&gt; embedded in
*  another template?
@@ -89,7 +89,7 @@ namespace Antlr4.StringTemplate.Compiler
*  own.  We need to prevent more than one manual def though.  Between
*  this var and isEmbeddedRegion we can determine these cases.
*/
-        public ST.RegionType regionDefType;
+        public Template.RegionType regionDefType;

public bool isAnonSubtemplate; // {...}

@@ -98,10 +98,10 @@ namespace Antlr4.StringTemplate.Compiler
public int codeSize;
public Interval[] sourceMap; // maps IP to range in template pattern

-        public CompiledST()
+        public CompiledTemplate()
{
-            instrs = new byte[Compiler.InitialCodeSize];
-            sourceMap = new Interval[Compiler.InitialCodeSize];
+            instrs = new byte[TemplateCompiler.InitialCodeSize];
+            sourceMap = new Interval[TemplateCompiler.InitialCodeSize];
template = "";
}

@@ -162,15 +162,15 @@ namespace Antlr4.StringTemplate.Compiler
return formalArguments.FirstOrDefault(i => i.Name == name);
}

-        public virtual void addImplicitlyDefinedTemplate(CompiledST sub)
+        public virtual void addImplicitlyDefinedTemplate(CompiledTemplate sub)
{
if (implicitlyDefinedTemplates == null)
-                implicitlyDefinedTemplates = new List<CompiledST>();
+                implicitlyDefinedTemplates = new List<CompiledTemplate>();

implicitlyDefinedTemplates.Add(sub);
}

-        public virtual void defineArgDefaultValueTemplates(STGroup group)
+        public virtual void defineArgDefaultValueTemplates(TemplateGroup group)
{
if (formalArguments == null)
return;
@@ -180,7 +180,7 @@ namespace Antlr4.StringTemplate.Compiler
if (fa.DefaultValueToken != null)
{
string argSTname = fa.Name + "_default_value";
-                    Compiler c2 = new Compiler(group.errMgr, group.delimiterStartChar, group.delimiterStopChar);
+                    TemplateCompiler c2 = new TemplateCompiler(group.errMgr, group.delimiterStartChar, group.delimiterStopChar);
string defArgTemplate = Utility.strip(fa.DefaultValueToken.Text, 1);
fa.CompiledDefaultValue = c2.compile(nativeGroup.getFileName(), argSTname, null, defArgTemplate, fa.DefaultValueToken);
fa.CompiledDefaultValue.name = argSTname;
@@ -202,7 +202,7 @@ namespace Antlr4.StringTemplate.Compiler
}
}

-        /** Used by ST.add() to add args one by one w/o turning on full formal args definition signal */
+        /** Used by Template.add() to add args one by one w/o turning on full formal args definition signal */
public virtual void addArg(FormalArgument a)
{
if (formalArguments == null)
@@ -212,11 +212,11 @@ namespace Antlr4.StringTemplate.Compiler
formalArguments.Add(a);
}

-        public virtual void defineImplicitlyDefinedTemplates(STGroup group)
+        public virtual void defineImplicitlyDefinedTemplates(TemplateGroup group)
{
if (implicitlyDefinedTemplates != null)
{
-                foreach (CompiledST sub in implicitlyDefinedTemplates)
+                foreach (CompiledTemplate sub in implicitlyDefinedTemplates)
{
group.rawDefineTemplate(sub.name, sub, null);
sub.defineImplicitlyDefinedTemplates(group);
diff --git a/Antlr4.StringTemplate/Compiler/FormalArgument.cs b/Antlr4.StringTemplate/Compiler/FormalArgument.cs
index bc2e897..b68e247 100644
--- a/Antlr4.StringTemplate/Compiler/FormalArgument.cs
+++ b/Antlr4.StringTemplate/Compiler/FormalArgument.cs
@@ -40,7 +40,7 @@ namespace Antlr4.StringTemplate.Compiler
*
*  Each template has a set of these formal arguments or uses
*  a placeholder object: UNKNOWN (indicating that no arguments
-     *  were specified such as when we create a template with "new ST(...)").
+     *  were specified such as when we create a template with "new Template(...)").
*
*  Note: originally, I tracked cardinality as well as the name of an
*  attribute.  I'm leaving the code here as I suspect something may come
@@ -69,7 +69,7 @@ namespace Antlr4.StringTemplate.Compiler
*/

/** When template arguments are not available, when the user
-         *  uses "new ST(...)", then the list of formal arguments
+         *  uses "new Template(...)", then the list of formal arguments
*  must be distinguished from the case where a template can specify
*  args and there just aren't any such as the t() template above.
*/
@@ -82,7 +82,7 @@ namespace Antlr4.StringTemplate.Compiler

/** If they specified name="value", store the template here */
private readonly IToken defaultValueToken;
-        private CompiledST compiledDefaultValue;
+        private CompiledTemplate compiledDefaultValue;

public FormalArgument(string name)
{
@@ -124,7 +124,7 @@ namespace Antlr4.StringTemplate.Compiler
}
}

-        public CompiledST CompiledDefaultValue
+        public CompiledTemplate CompiledDefaultValue
{
get
{
diff --git a/Antlr4.StringTemplate/Compiler/Group.g3 b/Antlr4.StringTemplate/Compiler/Group.g3
index f37c360..68104da 100644
--- a/Antlr4.StringTemplate/Compiler/Group.g3
+++ b/Antlr4.StringTemplate/Compiler/Group.g3
@@ -51,7 +51,7 @@ using StringBuilder = System.Text.StringBuilder;
}

public
-group[STGroup group, string prefix]
+group[TemplateGroup group, string prefix]
@init {
GroupLexer lexer = (GroupLexer)input.TokenSource;
this._group = lexer.group = $group;
@@ -174,7 +174,7 @@ dictPairs[IDictionary<string,object> mapping]
}

defaultValuePair[IDictionary<string,object> mapping]
-	:	'default' ':' keyValue {mapping[STGroup.DefaultKey] = $keyValue.value;}
+	:	'default' ':' keyValue {mapping[TemplateGroup.DefaultKey] = $keyValue.value;}
;

keyValuePair[IDictionary<string,object> mapping]
@@ -186,7 +186,7 @@ keyValue returns [object value]
|	ANONYMOUS_TEMPLATE	{$value = _group.createSingleton($ANONYMOUS_TEMPLATE);}
|	STRING				{$value = Utility.replaceEscapes(Utility.strip($STRING.text, 1));}
|	{input.LT(1).Text.Equals("key")}?=> ID
-							{$value = STGroup.DictionaryKey;}
+							{$value = TemplateGroup.DictionaryKey;}
;
catch[RecognitionException re] {
error("missing value for key at '"+input.LT(1).Text+"'");
@@ -225,10 +225,10 @@ ANONYMOUS_TEMPLATE
:	'{'
{
IToken templateToken = new CommonToken(input, ANONYMOUS_TEMPLATE, 0, CharIndex, CharIndex);
-		STLexer lexer = new STLexer(group.errMgr, input, templateToken, group.delimiterStartChar, group.delimiterStopChar);
+		TemplateLexer lexer = new TemplateLexer(group.errMgr, input, templateToken, group.delimiterStartChar, group.delimiterStopChar);
lexer.subtemplateDepth = 1;
IToken t = lexer.NextToken();
-		while ( lexer.subtemplateDepth>=1 || t.Type!=STLexer.RCURLY )
+		while ( lexer.subtemplateDepth>=1 || t.Type!=TemplateLexer.RCURLY )
t = lexer.NextToken();
}
// don't match '}' here; our little {...} scanner loop matches it
diff --git a/Antlr4.StringTemplate/Compiler/Group.g3.lexer.cs b/Antlr4.StringTemplate/Compiler/Group.g3.lexer.cs
index 175378a..de0151d 100644
--- a/Antlr4.StringTemplate/Compiler/Group.g3.lexer.cs
+++ b/Antlr4.StringTemplate/Compiler/Group.g3.lexer.cs
@@ -38,7 +38,7 @@ namespace Antlr4.StringTemplate.Compiler

partial class GroupLexer
{
-        public STGroup group;
+        public TemplateGroup group;

public override void ReportError(RecognitionException e)
{
diff --git a/Antlr4.StringTemplate/Compiler/Group.g3.parser.cs b/Antlr4.StringTemplate/Compiler/Group.g3.parser.cs
index 0e76ac9..798502c 100644
--- a/Antlr4.StringTemplate/Compiler/Group.g3.parser.cs
+++ b/Antlr4.StringTemplate/Compiler/Group.g3.parser.cs
@@ -38,9 +38,9 @@ namespace Antlr4.StringTemplate.Compiler

partial class GroupParser
{
-        private STGroup _group;
+        private TemplateGroup _group;

-        public STGroup Group
+        public TemplateGroup Group
{
get
{
diff --git a/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs b/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs
index 162da18..8697c2d 100644
--- a/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs
+++ b/Antlr4.StringTemplate/Compiler/TemplateCompiler.cs
@@ -38,7 +38,7 @@ namespace Antlr4.StringTemplate.Compiler
using Antlr.Runtime.Tree;

/** A compiler for a single template. */
-    public class Compiler
+    public class TemplateCompiler
{
public static readonly string SubtemplatePrefix = "_sub";

@@ -81,7 +81,7 @@ namespace Antlr4.StringTemplate.Compiler
public static int subtemplateCount = 0;

/** The compiler needs to know how to delimit expressions.
-         *  The STGroup normally passes in this information, but we
+         *  The TemplateGroup normally passes in this information, but we
*  can set some defaults.
*/
public char delimiterStartChar = '<'; // Use <expr> by default
@@ -89,52 +89,52 @@ namespace Antlr4.StringTemplate.Compiler

public ErrorManager errMgr;

-        public Compiler()
-            : this(STGroup.DefaultErrorManager)
+        public TemplateCompiler()
+            : this(TemplateGroup.DefaultErrorManager)
{
}

-        public Compiler(ErrorManager errMgr)
+        public TemplateCompiler(ErrorManager errMgr)
: this(errMgr, '<', '>')
{
}

-        public Compiler(char delimiterStartChar, char delimiterStopChar)
-            : this(STGroup.DefaultErrorManager, delimiterStartChar, delimiterStopChar)
+        public TemplateCompiler(char delimiterStartChar, char delimiterStopChar)
+            : this(TemplateGroup.DefaultErrorManager, delimiterStartChar, delimiterStopChar)
{
}

/** To compile a template, we need to know what the
*  enclosing template is (if any) in case of regions.
*/
-        public Compiler(ErrorManager errMgr, char delimiterStartChar, char delimiterStopChar)
+        public TemplateCompiler(ErrorManager errMgr, char delimiterStartChar, char delimiterStopChar)
{
this.errMgr = errMgr;
this.delimiterStartChar = delimiterStartChar;
this.delimiterStopChar = delimiterStopChar;
}

-        public virtual CompiledST compile(string template)
+        public virtual CompiledTemplate compile(string template)
{
-            CompiledST code = compile(null, null, null, template, null);
+            CompiledTemplate code = compile(null, null, null, template, null);
code.hasFormalArgs = false;
return code;
}

/** Compile full template with unknown formal args. */
-        public virtual CompiledST compile(string name, string template)
+        public virtual CompiledTemplate compile(string name, string template)
{
-            CompiledST code = compile(null, name, null, template, null);
+            CompiledTemplate code = compile(null, name, null, template, null);
code.hasFormalArgs = false;
return code;
}

/** Compile full template with respect to a list of formal args. */
-        public virtual CompiledST compile(string srcName, string name, List<FormalArgument> args, string template, IToken templateToken)
+        public virtual CompiledTemplate compile(string srcName, string name, List<FormalArgument> args, string template, IToken templateToken)
{
ANTLRStringStream @is = new ANTLRStringStream(template);
@is.name = srcName != null ? srcName : name;
-            STLexer lexer = new STLexer(errMgr, @is, templateToken, delimiterStartChar, delimiterStopChar);
+            TemplateLexer lexer = new TemplateLexer(errMgr, @is, templateToken, delimiterStartChar, delimiterStopChar);
CommonTokenStream tokens = new CommonTokenStream(lexer);
TemplateParser p = new TemplateParser(tokens, errMgr, templateToken);
TemplateParser.templateAndEOF_return r = null;
@@ -150,7 +150,7 @@ namespace Antlr4.StringTemplate.Compiler

if (p.NumberOfSyntaxErrors > 0 || r.Tree == null)
{
-                CompiledST impl = new CompiledST();
+                CompiledTemplate impl = new CompiledTemplate();
impl.defineFormalArgs(args);
return impl;
}
@@ -160,12 +160,12 @@ namespace Antlr4.StringTemplate.Compiler
nodes.TokenStream = tokens;
CodeGenerator gen = new CodeGenerator(nodes, errMgr, name, template, templateToken);

-            CompiledST impl2 = null;
+            CompiledTemplate impl2 = null;
try
{
impl2 = gen.template(name, args);
// only save tree/token stream when debugging
-                if (STGroup.debug)
+                if (TemplateGroup.debug)
{
impl2.ast = (CommonTree)r.Tree;
impl2.ast.SetUnknownTokenBoundaries();
@@ -180,13 +180,13 @@ namespace Antlr4.StringTemplate.Compiler
return impl2;
}

-        public static CompiledST defineBlankRegion(CompiledST outermostImpl, string name)
+        public static CompiledTemplate defineBlankRegion(CompiledTemplate outermostImpl, string name)
{
string outermostTemplateName = outermostImpl.name;
-            string mangled = STGroup.getMangledRegionName(outermostTemplateName, name);
-            CompiledST blank = new CompiledST();
+            string mangled = TemplateGroup.getMangledRegionName(outermostTemplateName, name);
+            CompiledTemplate blank = new CompiledTemplate();
blank.isRegion = true;
-            blank.regionDefType = ST.RegionType.Implicit;
+            blank.regionDefType = Template.RegionType.Implicit;
blank.name = mangled;
outermostImpl.addImplicitlyDefinedTemplate(blank);
return blank;
@@ -200,7 +200,7 @@ namespace Antlr4.StringTemplate.Compiler

protected virtual void reportMessageAndThrowSTException(ITokenStream tokens, IToken templateToken, Parser parser, RecognitionException re)
{
-            if (re.Token.Type == STLexer.EOF_TYPE)
+            if (re.Token.Type == TemplateLexer.EOF_TYPE)
{
string msg = "premature EOF";
errMgr.compileTimeError(ErrorType.SYNTAX_ERROR, templateToken, re.Token, msg);
@@ -216,7 +216,7 @@ namespace Antlr4.StringTemplate.Compiler
string msg = "this doesn't look like a template: \"" + tokens + "\"";
errMgr.compileTimeError(ErrorType.SYNTAX_ERROR, templateToken, re.Token, msg);
}
-            else if (tokens.LA(1) == STLexer.LDELIM)
+            else if (tokens.LA(1) == TemplateLexer.LDELIM)
{
// couldn't parse expr
string msg = "doesn't look like an expression";
@@ -228,7 +228,7 @@ namespace Antlr4.StringTemplate.Compiler
errMgr.compileTimeError(ErrorType.SYNTAX_ERROR, templateToken, re.Token, msg);
}

-            throw new STException();
+            throw new TemplateException();
}
}
}
diff --git a/Antlr4.StringTemplate/Compiler/TemplateException.cs b/Antlr4.StringTemplate/Compiler/TemplateException.cs
index 195285f..fcda35b 100644
--- a/Antlr4.StringTemplate/Compiler/TemplateException.cs
+++ b/Antlr4.StringTemplate/Compiler/TemplateException.cs
@@ -34,13 +34,13 @@ namespace Antlr4.StringTemplate.Compiler
{
using Exception = System.Exception;

-    public class STException : Exception
+    public class TemplateException : Exception
{
-        public STException()
+        public TemplateException()
{
}

-        public STException(string message, Exception innerException)
+        public TemplateException(string message, Exception innerException)
: base(message, innerException)
{
}
diff --git a/Antlr4.StringTemplate/Compiler/TemplateLexer.cs b/Antlr4.StringTemplate/Compiler/TemplateLexer.cs
index e7bc4e1..0948887 100644
--- a/Antlr4.StringTemplate/Compiler/TemplateLexer.cs
+++ b/Antlr4.StringTemplate/Compiler/TemplateLexer.cs
@@ -49,9 +49,9 @@ namespace Antlr4.StringTemplate.Compiler
*  template as a simple stream of elements.
*
*  This class defines the token types and communicates these values to STParser.g
-     *  via STLexer.tokens file (which must remain consistent).
+     *  via TemplateLexer.tokens file (which must remain consistent).
*/
-    public class STLexer : ITokenSource
+    public class TemplateLexer : ITokenSource
{
public const char EOF = char.MaxValue;            // EOF char
public const int EOF_TYPE = CharStreamConstants.EndOfFile;  // EOF token type
@@ -90,7 +90,7 @@ namespace Antlr4.StringTemplate.Compiler

public static readonly IToken SKIP = new STToken(-1, "<skip>");

-        // must follow STLexer.tokens file that STParser.g loads
+        // must follow TemplateLexer.tokens file that STParser.g loads
public const int RBRACK = 17;
public const int LBRACK = 16;
public const int ELSE = 5;
@@ -127,7 +127,7 @@ namespace Antlr4.StringTemplate.Compiler
char delimiterStopChar = '>';

/** This keep track of the mode of the lexer. Are we inside or outside
-         *  an ST expression?
+         *  an Template expression?
*/
bool scanningInsideExpr = false;

@@ -157,16 +157,16 @@ namespace Antlr4.StringTemplate.Compiler
*/
private readonly Queue<IToken> tokens = new Queue<IToken>();

-        public STLexer(ICharStream input) : this(STGroup.DefaultErrorManager, input, null, '<', '>')
+        public TemplateLexer(ICharStream input) : this(TemplateGroup.DefaultErrorManager, input, null, '<', '>')
{
}

-        public STLexer(ErrorManager errMgr, ICharStream input, IToken templateToken)
+        public TemplateLexer(ErrorManager errMgr, ICharStream input, IToken templateToken)
: this(errMgr, input, templateToken, '<', '>')
{
}

-        public STLexer(ErrorManager errMgr,
+        public TemplateLexer(ErrorManager errMgr,
ICharStream input,
IToken templateToken,
char delimiterStartChar,
@@ -402,7 +402,7 @@ namespace Antlr4.StringTemplate.Compiler
re.CharPositionInLine = startCharPositionInLine;
if (c == EOF)
{
-                        throw new STException("EOF inside ST expression at " + re.Line + ":" + re.CharPositionInLine, re);
+                        throw new TemplateException("EOF inside Template expression at " + re.Line + ":" + re.CharPositionInLine, re);
}

errMgr.lexerError(input.SourceName, "invalid character '" + c + "'", templateToken, re);
@@ -650,7 +650,7 @@ namespace Antlr4.StringTemplate.Compiler
RecognitionException re = new MismatchedTokenException((int)'"', input);
re.Line = input.Line;
re.CharPositionInLine = input.CharPositionInLine;
-                    throw new STException("EOF inside string/template at " + startLine + ":" + startCharPositionInLine, re);
+                    throw new TemplateException("EOF inside string/template at " + startLine + ":" + startCharPositionInLine, re);
}
}

diff --git a/Antlr4.StringTemplate/Compiler/TemplateParser.g3 b/Antlr4.StringTemplate/Compiler/TemplateParser.g3
index babb4c7..fbd5e19 100644
--- a/Antlr4.StringTemplate/Compiler/TemplateParser.g3
+++ b/Antlr4.StringTemplate/Compiler/TemplateParser.g3
@@ -119,9 +119,9 @@ option
@init {
string id = input.LT(1).Text;
string defVal;
-	Compiler.defaultOptionValues.TryGetValue(id, out defVal);
+	TemplateCompiler.defaultOptionValues.TryGetValue(id, out defVal);
Interpreter.Option supportedOption;
-	bool validOption = Compiler.supportedOptions.TryGetValue(id, out supportedOption);
+	bool validOption = TemplateCompiler.supportedOptions.TryGetValue(id, out supportedOption);
}
:	ID
{
@@ -185,7 +185,7 @@ memberExpr

includeExpr
options {k=2;} // prevent full LL(*), which fails, falling back on k=1; need k=2
-	:	{Compiler.funcs.ContainsKey(input.LT(1).Text)}? // predefined function
+	:	{TemplateCompiler.funcs.ContainsKey(input.LT(1).Text)}? // predefined function
ID '(' expr? ')'						-> ^(EXEC_FUNC ID expr?)
|	'super' '.' ID '(' args ')'				-> ^(INCLUDE_SUPER ID args?)
|	ID '(' args ')'							-> ^(INCLUDE ID args?)
diff --git a/Antlr4.StringTemplate/Compiler/TestNewStuff.cs b/Antlr4.StringTemplate/Compiler/TestNewStuff.cs
index 3571799..7f1c2d3 100644
--- a/Antlr4.StringTemplate/Compiler/TestNewStuff.cs
+++ b/Antlr4.StringTemplate/Compiler/TestNewStuff.cs
@@ -40,7 +40,7 @@ namespace Antlr4.StringTemplate.Compiler
{
public static void main(string[] args)
{
-            Compiler c = new Compiler();
+            TemplateCompiler c = new TemplateCompiler();

string template = File.ReadAllText(args[0]);
List<FormalArgument> a = new List<FormalArgument>();
diff --git a/Antlr4.StringTemplate/Debug/ConstructionEvent.cs b/Antlr4.StringTemplate/Debug/ConstructionEvent.cs
index 551b200..e3ec9c4 100644
--- a/Antlr4.StringTemplate/Debug/ConstructionEvent.cs
+++ b/Antlr4.StringTemplate/Debug/ConstructionEvent.cs
@@ -34,7 +34,7 @@ namespace Antlr4.StringTemplate.Debug
{
using System.Diagnostics;

-    /** An event that happens when building ST trees, adding attributes etc... */
+    /** An event that happens when building Template trees, adding attributes etc... */
public class ConstructionEvent
{
private readonly StackTrace stack;
diff --git a/Antlr4.StringTemplate/Debug/DebugTemplate.cs b/Antlr4.StringTemplate/Debug/DebugTemplate.cs
index d863ad0..7bce9ad 100644
--- a/Antlr4.StringTemplate/Debug/DebugTemplate.cs
+++ b/Antlr4.StringTemplate/Debug/DebugTemplate.cs
@@ -37,10 +37,10 @@ namespace Antlr4.StringTemplate.Debug
using CultureInfo = System.Globalization.CultureInfo;
using StringWriter = System.IO.StringWriter;

-    /** To avoid polluting ST instances with debug info when not debugging.
-     *  Setting debug mode in STGroup makes it create these instead of STs.
+    /** To avoid polluting Template instances with debug info when not debugging.
+     *  Setting debug mode in TemplateGroup makes it create these instead of STs.
*/
-    public class DebugST : ST
+    public class DebugST : Template
{
public class State
{
@@ -51,7 +51,7 @@ namespace Antlr4.StringTemplate.Debug
/** Record who made us? ConstructionEvent creates Exception to grab stack */
public ConstructionEvent newSTEvent = new ConstructionEvent();

-        /** Track construction-time add attribute "events"; used for ST user-level debugging */
+        /** Track construction-time add attribute "events"; used for Template user-level debugging */
public MultiMap<string, AddAttributeEvent> addAttrEvents = new MultiMap<string, AddAttributeEvent>();

//public Interpreter interp; // set when we start interpreter in inspect()
@@ -60,13 +60,13 @@ namespace Antlr4.StringTemplate.Debug
{
}

-        public DebugST(ST proto) : base(proto)
+        public DebugST(Template proto) : base(proto)
{
}

public override void add(string name, object value)
{
-            if (STGroup.debug)
+            if (TemplateGroup.debug)
addAttrEvents.map(name, new AddAttributeEvent(name, value));

base.add(name, value);
diff --git a/Antlr4.StringTemplate/IModelAdaptor.cs b/Antlr4.StringTemplate/IModelAdaptor.cs
index aaff737..7fae256 100644
--- a/Antlr4.StringTemplate/IModelAdaptor.cs
+++ b/Antlr4.StringTemplate/IModelAdaptor.cs
@@ -51,8 +51,8 @@ namespace Antlr4.StringTemplate
*
*  property is normally a String but doesn't have to be. E.g.,
*  if o is Map, property could be any key type.  If we need to convert
-         *  to string, then it's done by ST and passed in here.
+         *  to string, then it's done by Template and passed in here.
*/
-        object GetProperty(ST self, object obj, object property, string propertyName);
+        object GetProperty(Template self, object obj, object property, string propertyName);
}
}
diff --git a/Antlr4.StringTemplate/ITemplateErrorListener.cs b/Antlr4.StringTemplate/ITemplateErrorListener.cs
index c879764..4994e41 100644
--- a/Antlr4.StringTemplate/ITemplateErrorListener.cs
+++ b/Antlr4.StringTemplate/ITemplateErrorListener.cs
@@ -37,9 +37,9 @@ namespace Antlr4.StringTemplate
/** How to handle messages */
public interface ITemplateErrorListener
{
-        void compileTimeError(STMessage msg);
-        void runTimeError(STMessage msg);
-        void IOError(STMessage msg);
-        void internalError(STMessage msg);
+        void compileTimeError(TemplateMessage msg);
+        void runTimeError(TemplateMessage msg);
+        void IOError(TemplateMessage msg);
+        void internalError(TemplateMessage msg);
}
}
diff --git a/Antlr4.StringTemplate/ITemplateWriter.cs b/Antlr4.StringTemplate/ITemplateWriter.cs
index 5d62bb2..01764e1 100644
--- a/Antlr4.StringTemplate/ITemplateWriter.cs
+++ b/Antlr4.StringTemplate/ITemplateWriter.cs
@@ -62,12 +62,12 @@ namespace Antlr4.StringTemplate
*/
int write(string str, string wrap);

-        /** Because we evaluate ST instance by invoking exec() again, we
+        /** Because we evaluate Template instance by invoking exec() again, we
*  can't pass options in.  So the WRITE instruction of an applied
*  template (such as when we wrap in between template applications
*  like &lt;data:{v|[&lt;v&gt;]}; wrap&gt;) we need to write the wrap string
*  before calling exec().  We expose just like for the separator.
-         *  See Interpreter.writeObject where it checks for ST instance.
+         *  See Interpreter.writeObject where it checks for Template instance.
*  If POJO, writePOJO passes wrap to ITemplateWriter's
*
*     write(String str, String wrap)
diff --git a/Antlr4.StringTemplate/Interpreter.cs b/Antlr4.StringTemplate/Interpreter.cs
index 412d2e2..0696c20 100644
--- a/Antlr4.StringTemplate/Interpreter.cs
+++ b/Antlr4.StringTemplate/Interpreter.cs
@@ -53,9 +53,9 @@ namespace Antlr4.StringTemplate
using StringWriter = System.IO.StringWriter;

/** This class knows how to execute template bytecodes relative to a
-     *  particular STGroup. To execute the byte codes, we need an output stream
-     *  and a reference to an ST an instance. That instance's impl field points at
-     *  a CompiledST, which contains all of the byte codes and other information
+     *  particular TemplateGroup. To execute the byte codes, we need an output stream
+     *  and a reference to an Template an instance. That instance's impl field points at
+     *  a CompiledTemplate, which contains all of the byte codes and other information
*  relevant to execution.
*
*  This interpreter is a stack-based bytecode interpreter.  All operands
@@ -66,7 +66,7 @@ namespace Antlr4.StringTemplate
*  These are used by STViz to pair up output chunks with the template
*  expressions that generate them.
*
-     *  We create a new interpreter for each ST.render(), DebugST.inspect, or
+     *  We create a new interpreter for each Template.render(), DebugST.inspect, or
*  DebugST.getEvents() invocation.
*/
public class Interpreter
@@ -87,10 +87,10 @@ namespace Antlr4.StringTemplate
/** Dump bytecode instructions as we execute them? */
public static bool trace = false;

-        /** Exec st with respect to this group. Once set in ST.ToString(),
-         *  it should be fixed. ST has group also.
+        /** Exec st with respect to this group. Once set in Template.ToString(),
+         *  it should be fixed. Template has group also.
*/
-        private readonly STGroup group;
+        private readonly TemplateGroup group;

/** For renderers, we have to pass in the culture */
private readonly CultureInfo culture;
@@ -110,38 +110,38 @@ namespace Antlr4.StringTemplate
// TODO: track the pieces not a string and track what it contributes to output
private List<string> executeTrace;

-        private IDictionary<ST, List<InterpEvent>> debugInfo;
+        private IDictionary<Template, List<InterpEvent>> debugInfo;

-        public Interpreter(STGroup group)
+        public Interpreter(TemplateGroup group)
: this(group, CultureInfo.CurrentCulture, group.errMgr)
{
}

-        public Interpreter(STGroup group, CultureInfo culture)
+        public Interpreter(TemplateGroup group, CultureInfo culture)
: this(group, culture, group.errMgr)
{
}

-        public Interpreter(STGroup group, ErrorManager errMgr)
+        public Interpreter(TemplateGroup group, ErrorManager errMgr)
: this(group, CultureInfo.CurrentCulture, errMgr)
{
}

-        public Interpreter(STGroup group, CultureInfo culture, ErrorManager errMgr)
+        public Interpreter(TemplateGroup group, CultureInfo culture, ErrorManager errMgr)
{
this.group = group;
this.culture = culture;
this.errMgr = errMgr;
-            if (STGroup.debug)
+            if (TemplateGroup.debug)
{
events = new List<InterpEvent>();
executeTrace = new List<string>();
-                debugInfo = new Dictionary<ST, List<InterpEvent>>();
+                debugInfo = new Dictionary<Template, List<InterpEvent>>();
}
}

/** Execute template self and return how many characters it wrote to out */
-        public virtual int Execute(ITemplateWriter @out, ST self)
+        public virtual int Execute(ITemplateWriter @out, Template self)
{
int save_ip = current_ip;
try
@@ -154,7 +154,7 @@ namespace Antlr4.StringTemplate
}
}

-        protected virtual int ExecuteImpl(ITemplateWriter @out, ST self)
+        protected virtual int ExecuteImpl(ITemplateWriter @out, Template self)
{
int start = @out.index(); // track char we're about to write
Bytecode prevOpcode = Bytecode.Invalid;
@@ -164,13 +164,13 @@ namespace Antlr4.StringTemplate
int addr;
string name;
object o, left, right;
-            ST st;
+            Template st;
object[] options;
byte[] code = self.impl.instrs;        // which code block are we executing
int ip = 0;
while (ip < self.impl.codeSize)
{
-                if (trace || STGroup.debug)
+                if (trace || TemplateGroup.debug)
Trace(self, ip);

Bytecode opcode = (Bytecode)code[ip];
@@ -192,7 +192,7 @@ namespace Antlr4.StringTemplate
{
o = self.getAttribute(name);
}
-                    catch (STNoSuchPropertyException)
+                    catch (TemplateNoSuchPropertyException)
{
errMgr.runTimeError(self, current_ip, ErrorType.NO_SUCH_ATTRIBUTE, name);
o = null;
@@ -204,7 +204,7 @@ namespace Antlr4.StringTemplate
int valueIndex = getShort(code, ip);
ip += Instruction.OperandSizeInBytes;
o = self.locals[valueIndex];
-                    if (o == ST.EmptyAttribute)
+                    if (o == Template.EmptyAttribute)
o = null;
operands[++sp] = o;
break;
@@ -312,7 +312,7 @@ namespace Antlr4.StringTemplate
break;

case Bytecode.INSTR_MAP:
-                    st = (ST)operands[sp--]; // get prototype off stack
+                    st = (Template)operands[sp--]; // get prototype off stack
o = operands[sp--];		 // get object to map prototype across
map(self, o, st);
break;
@@ -320,9 +320,9 @@ namespace Antlr4.StringTemplate
case Bytecode.INSTR_ROT_MAP:
int nmaps = getShort(code, ip);
ip += Instruction.OperandSizeInBytes;
-                    List<ST> templates = new List<ST>();
+                    List<Template> templates = new List<Template>();
for (int i = nmaps - 1; i >= 0; i--)
-                        templates.Add((ST)operands[sp - i]);
+                        templates.Add((Template)operands[sp - i]);
sp -= nmaps;
o = operands[sp--];
if (o != null)
@@ -330,7 +330,7 @@ namespace Antlr4.StringTemplate
break;

case Bytecode.INSTR_ZIP_MAP:
-                    st = (ST)operands[sp--];
+                    st = (Template)operands[sp--];
nmaps = getShort(code, ip);
ip += Instruction.OperandSizeInBytes;
List<object> exprs = new List<object>();
@@ -355,7 +355,7 @@ namespace Antlr4.StringTemplate
break;

case Bytecode.INSTR_OPTIONS:
-                    operands[++sp] = new object[Compiler.Compiler.NUM_OPTIONS];
+                    operands[++sp] = new object[Compiler.TemplateCompiler.NUM_OPTIONS];
break;

case Bytecode.INSTR_ARGS:
@@ -492,7 +492,7 @@ namespace Antlr4.StringTemplate
}
prevOpcode = opcode;
}
-            if (STGroup.debug)
+            if (TemplateGroup.debug)
{
int stop = @out.index() - 1;
EvalTemplateEvent e = new EvalTemplateEvent((DebugST)self, start, stop);
@@ -509,16 +509,16 @@ namespace Antlr4.StringTemplate

// TODO: refactor to remove dup'd code

-        internal virtual void super_new(ST self, string name, int nargs)
+        internal virtual void super_new(Template self, string name, int nargs)
{
-            ST st = null;
-            CompiledST imported = self.impl.nativeGroup.lookupImportedTemplate(name);
+            Template st = null;
+            CompiledTemplate imported = self.impl.nativeGroup.lookupImportedTemplate(name);
if (imported == null)
{
errMgr.runTimeError(self, current_ip, ErrorType.NO_IMPORTED_TEMPLATE,
name);
st = self.groupThatCreatedThisInstance.createStringTemplate();
-                st.impl = new CompiledST();
+                st.impl = new CompiledTemplate();
sp -= nargs;
operands[++sp] = st;
return;
@@ -535,15 +535,15 @@ namespace Antlr4.StringTemplate
operands[++sp] = st;
}

-        internal virtual void super_new(ST self, string name, IDictionary<string, object> attrs)
+        internal virtual void super_new(Template self, string name, IDictionary<string, object> attrs)
{
-            ST st = null;
-            CompiledST imported = self.impl.nativeGroup.lookupImportedTemplate(name);
+            Template st = null;
+            CompiledTemplate imported = self.impl.nativeGroup.lookupImportedTemplate(name);
if (imported == null)
{
errMgr.runTimeError(self, current_ip, ErrorType.NO_IMPORTED_TEMPLATE, name);
st = self.groupThatCreatedThisInstance.createStringTemplate();
-                st.impl = new CompiledST();
+                st.impl = new CompiledTemplate();
operands[++sp] = st;
return;
}
@@ -558,7 +558,7 @@ namespace Antlr4.StringTemplate
operands[++sp] = st;
}

-        internal virtual void storeArgs(ST self, IDictionary<string, object> attrs, ST st)
+        internal virtual void storeArgs(Template self, IDictionary<string, object> attrs, Template st)
{
int nformalArgs = 0;
if (st.impl.formalArguments != null)
@@ -591,7 +591,7 @@ namespace Antlr4.StringTemplate
}
}

-        internal virtual void storeArgs(ST self, int nargs, ST st)
+        internal virtual void storeArgs(Template self, int nargs, Template st)
{
int nformalArgs = 0;
if (st.impl.formalArguments != null)
@@ -626,11 +626,11 @@ namespace Antlr4.StringTemplate
/** Write out an expression result that doesn't use expression options.
*  E.g., <name>
*/
-        protected virtual int writeObjectNoOptions(ITemplateWriter @out, ST self, object o)
+        protected virtual int writeObjectNoOptions(ITemplateWriter @out, Template self, object o)
{
int start = @out.index(); // track char we're about to write
int n = writeObject(@out, self, o, null);
-            if (STGroup.debug)
+            if (TemplateGroup.debug)
{
Interval templateLocation = self.impl.sourceMap[current_ip];
int exprStart = -1;
@@ -651,7 +651,7 @@ namespace Antlr4.StringTemplate
/** Write out an expression result that uses expression options.
*  E.g., <names; separator=", ">
*/
-        protected virtual int writeObjectWithOptions(ITemplateWriter @out, ST self, object o,
+        protected virtual int writeObjectWithOptions(ITemplateWriter @out, Template self, object o,
object[] options)
{
int start = @out.index(); // track char we're about to write
@@ -660,7 +660,7 @@ namespace Antlr4.StringTemplate
if (options != null)
{
optionStrings = new string[options.Length];
-                for (int i = 0; i < Compiler.Compiler.NUM_OPTIONS; i++)
+                for (int i = 0; i < Compiler.TemplateCompiler.NUM_OPTIONS; i++)
{
optionStrings[i] = toString(self, options[i]);
}
@@ -676,7 +676,7 @@ namespace Antlr4.StringTemplate
{
@out.popAnchorPoint();
}
-            if (STGroup.debug)
+            if (TemplateGroup.debug)
{
Interval templateLocation = self.impl.sourceMap[current_ip];
int exprStart = templateLocation.A, exprStop = templateLocation.B;
@@ -692,7 +692,7 @@ namespace Antlr4.StringTemplate
/** Generic method to emit text for an object. It differentiates
*  between templates, iterable objects, and plain old Java objects (POJOs)
*/
-        protected virtual int writeObject(ITemplateWriter @out, ST self, object o, string[] options)
+        protected virtual int writeObject(ITemplateWriter @out, Template self, object o, string[] options)
{
int n = 0;
if (o == null)
@@ -704,10 +704,10 @@ namespace Antlr4.StringTemplate
else
return 0;
}
-            if (o is ST)
+            if (o is Template)
{
-                ((ST)o).enclosingInstance = self;
-                setDefaultArguments((ST)o);
+                ((Template)o).enclosingInstance = self;
+                setDefaultArguments((Template)o);
if (options != null && options[(int)Option.Wrap] != null)
{
// if we have a wrap string, then inform writer it
@@ -721,7 +721,7 @@ namespace Antlr4.StringTemplate
errMgr.IOError(self, ErrorType.WRITE_IO_ERROR, ioe);
}
}
-                n = Execute(@out, (ST)o);
+                n = Execute(@out, (Template)o);
}
else
{
@@ -741,7 +741,7 @@ namespace Antlr4.StringTemplate
return n;
}

-        protected virtual int writeIterator(ITemplateWriter @out, ST self, object o, string[] options)
+        protected virtual int writeIterator(ITemplateWriter @out, Template self, object o, string[] options)
{
if (o == null)
return 0;
@@ -792,13 +792,13 @@ namespace Antlr4.StringTemplate
return n;
}

-        protected virtual void map(ST self, object attr, ST st)
+        protected virtual void map(Template self, object attr, Template st)
{
-            rot_map(self, attr, new List<ST>() { st });
+            rot_map(self, attr, new List<Template>() { st });
}

// <names:a> or <names:a,b>
-        protected virtual void rot_map(ST self, object attr, List<ST> prototypes)
+        protected virtual void rot_map(Template self, object attr, List<Template> prototypes)
{
if (attr == null)
{
@@ -808,7 +808,7 @@ namespace Antlr4.StringTemplate
attr = convertAnythingIteratableToIterator(attr);
if (attr is Iterator)
{
-                List<ST> mapped = new List<ST>();
+                List<Template> mapped = new List<Template>();
Iterator iter = (Iterator)attr;
int i0 = 0;
int i = 1;
@@ -824,8 +824,8 @@ namespace Antlr4.StringTemplate

int templateIndex = ti % prototypes.Count; // rotate through
ti++;
-                    ST proto = prototypes[templateIndex];
-                    ST st = group.createStringTemplate(proto);
+                    Template proto = prototypes[templateIndex];
+                    Template st = group.createStringTemplate(proto);
setFirstArgument(self, st, iterValue);
if (st.impl.isAnonSubtemplate)
{
@@ -840,8 +840,8 @@ namespace Antlr4.StringTemplate
}
else
{ // if only single value, just apply first template to sole value
-                ST proto = prototypes[0];
-                ST st = group.createStringTemplate(proto);
+                Template proto = prototypes[0];
+                Template st = group.createStringTemplate(proto);
if (st != null)
{
setFirstArgument(self, st, attr);
@@ -861,7 +861,7 @@ namespace Antlr4.StringTemplate

// <names,phones:{n,p | ...}> or <a,b:t()>
// todo: i, i0 not set unless mentioned? map:{k,v | ..}?
-        protected virtual ST.AttributeList zip_map(ST self, List<object> exprs, ST prototype)
+        protected virtual Template.AttributeList zip_map(Template self, List<object> exprs, Template prototype)
{
if (exprs == null || prototype == null || exprs.Count == 0)
{
@@ -877,7 +877,7 @@ namespace Antlr4.StringTemplate

// ensure arguments line up
int numExprs = exprs.Count;
-            CompiledST code = prototype.impl;
+            CompiledTemplate code = prototype.impl;
List<FormalArgument> formalArguments = code.formalArguments;
if (!code.hasFormalArgs || formalArguments == null)
{
@@ -903,13 +903,13 @@ namespace Antlr4.StringTemplate

// keep walking while at least one attribute has values

-            ST.AttributeList results = new ST.AttributeList();
+            Template.AttributeList results = new Template.AttributeList();
int i2 = 0; // iteration number from 0
while (true)
{
-                // get a value for each attribute in list; put into ST instance
+                // get a value for each attribute in list; put into Template instance
int numEmpty = 0;
-                ST embedded = group.createStringTemplate(prototype);
+                Template embedded = group.createStringTemplate(prototype);
embedded.rawSetAttribute("i0", i2);
embedded.rawSetAttribute("i", i2 + 1);
for (int a = 0; a < numExprs; a++)
@@ -936,7 +936,7 @@ namespace Antlr4.StringTemplate
return results;
}

-        protected virtual void setFirstArgument(ST self, ST st, object attr)
+        protected virtual void setFirstArgument(Template self, Template st, object attr)
{
if (st.impl.formalArguments == null)
{
@@ -1152,15 +1152,15 @@ namespace Antlr4.StringTemplate
return 1;
}

-        protected virtual string toString(ST self, object value)
+        protected virtual string toString(Template self, object value)
{
if (value != null)
{
if (value.GetType() == typeof(string))
return (string)value;
-                // if ST, make sure it evaluates with enclosing template as self
-                if (value is ST)
-                    ((ST)value).enclosingInstance = self;
+                // if Template, make sure it evaluates with enclosing template as self
+                if (value is Template)
+                    ((Template)value).enclosingInstance = self;
// if not string already, must evaluate it
StringWriter sw = new StringWriter();
/*
@@ -1211,7 +1211,7 @@ namespace Antlr4.StringTemplate
if (iter != null)
return iter;

-            ST.AttributeList singleton = new ST.AttributeList(1);
+            Template.AttributeList singleton = new Template.AttributeList(1);
singleton.Add(o);
return singleton.iterator();
}
@@ -1248,7 +1248,7 @@ namespace Antlr4.StringTemplate
return true;
}

-        protected virtual object getObjectProperty(ST self, object o, object property)
+        protected virtual object getObjectProperty(Template self, object o, object property)
{
if (o == null)
{
@@ -1262,7 +1262,7 @@ namespace Antlr4.StringTemplate
IModelAdaptor adap = self.groupThatCreatedThisInstance.getModelAdaptor(o.GetType());
return adap.GetProperty(self, o, property, toString(self, property));
}
-            catch (STNoSuchPropertyException e)
+            catch (TemplateNoSuchPropertyException e)
{
errMgr.runTimeError(self, current_ip, ErrorType.NO_SUCH_PROPERTY,
e, o.GetType().Name + "." + property);
@@ -1276,16 +1276,16 @@ namespace Antlr4.StringTemplate
*
*  The evaluation context is the template enclosing invokedST.
*/
-        public virtual void setDefaultArguments(ST invokedST)
+        public virtual void setDefaultArguments(Template invokedST)
{
if (invokedST.impl.formalArguments == null)
return;
foreach (FormalArgument arg in invokedST.impl.formalArguments)
{
// if no value for attribute and default arg, inject default arg into self
-                if (invokedST.locals[arg.Index] == ST.EmptyAttribute && arg.CompiledDefaultValue != null)
+                if (invokedST.locals[arg.Index] == Template.EmptyAttribute && arg.CompiledDefaultValue != null)
{
-                    ST defaultArgST = group.createStringTemplate();
+                    Template defaultArgST = group.createStringTemplate();
defaultArgST.enclosingInstance = invokedST.enclosingInstance;
defaultArgST.groupThatCreatedThisInstance = group;
defaultArgST.impl = arg.CompiledDefaultValue;
@@ -1307,14 +1307,14 @@ namespace Antlr4.StringTemplate
}
}

-        protected virtual void Trace(ST self, int ip)
+        protected virtual void Trace(Template self, int ip)
{
StringBuilder tr = new StringBuilder();
BytecodeDisassembler dis = new BytecodeDisassembler(self.impl);
StringBuilder buf = new StringBuilder();
dis.disassembleInstruction(buf, ip);
string name = self.impl.name + ":";
-            if (self.impl.name == ST.UnknownName)
+            if (self.impl.name == Template.UnknownName)
name = "";

tr.Append(string.Format("{0,-40}", name + buf));
@@ -1330,7 +1330,7 @@ namespace Antlr4.StringTemplate
tr.Append(", sp=" + sp + ", nw=" + nwline);
string s = tr.ToString();

-            if (STGroup.debug)
+            if (TemplateGroup.debug)
executeTrace.Add(s);

if (trace)
@@ -1339,12 +1339,12 @@ namespace Antlr4.StringTemplate

protected virtual void printForTrace(StringBuilder tr, object o)
{
-            if (o is ST)
+            if (o is Template)
{
-                if (((ST)o).impl == null)
+                if (((Template)o).impl == null)
tr.Append("bad-template()");
else
-                    tr.Append(" " + ((ST)o).impl.name + "()");
+                    tr.Append(" " + ((Template)o).impl.name + "()");
return;
}
o = convertAnythingIteratableToIterator(o);
@@ -1370,7 +1370,7 @@ namespace Antlr4.StringTemplate
return events;
}

-        public virtual List<InterpEvent> getEvents(ST st)
+        public virtual List<InterpEvent> getEvents(Template st)
{
List<InterpEvent> events;
if (!debugInfo.TryGetValue(st, out events) || events == null)
diff --git a/Antlr4.StringTemplate/Misc/ErrorBuffer.cs b/Antlr4.StringTemplate/Misc/ErrorBuffer.cs
index 777a372..5f91458 100644
--- a/Antlr4.StringTemplate/Misc/ErrorBuffer.cs
+++ b/Antlr4.StringTemplate/Misc/ErrorBuffer.cs
@@ -39,9 +39,9 @@ namespace Antlr4.StringTemplate.Misc
/** Used during tests to track all errors */
public class ErrorBuffer : ITemplateErrorListener
{
-        private readonly List<STMessage> errors = new List<STMessage>();
+        private readonly List<TemplateMessage> errors = new List<TemplateMessage>();

-        public ReadOnlyCollection<STMessage> Errors
+        public ReadOnlyCollection<TemplateMessage> Errors
{
get
{
@@ -49,7 +49,7 @@ namespace Antlr4.StringTemplate.Misc
}
}

-        protected List<STMessage> ErrorList
+        protected List<TemplateMessage> ErrorList
{
get
{
@@ -57,24 +57,24 @@ namespace Antlr4.StringTemplate.Misc
}
}

-        public virtual void compileTimeError(STMessage msg)
+        public virtual void compileTimeError(TemplateMessage msg)
{
errors.Add(msg);
}

-        public virtual void runTimeError(STMessage msg)
+        public virtual void runTimeError(TemplateMessage msg)
{
// ignore these
if (msg.Error != ErrorType.NO_SUCH_PROPERTY)
errors.Add(msg);
}

-        public virtual void IOError(STMessage msg)
+        public virtual void IOError(TemplateMessage msg)
{
errors.Add(msg);
}

-        public virtual void internalError(STMessage msg)
+        public virtual void internalError(TemplateMessage msg)
{
errors.Add(msg);
}
@@ -82,7 +82,7 @@ namespace Antlr4.StringTemplate.Misc
public override string ToString()
{
StringBuilder buf = new StringBuilder();
-            foreach (STMessage m in errors)
+            foreach (TemplateMessage m in errors)
buf.AppendLine(m.ToString());

return buf.ToString();
diff --git a/Antlr4.StringTemplate/Misc/ErrorManager.cs b/Antlr4.StringTemplate/Misc/ErrorManager.cs
index 4765982..ffab970 100644
--- a/Antlr4.StringTemplate/Misc/ErrorManager.cs
+++ b/Antlr4.StringTemplate/Misc/ErrorManager.cs
@@ -46,12 +46,12 @@ namespace Antlr4.StringTemplate.Misc

private class DefaultErrorListener : ITemplateErrorListener
{
-            public virtual void compileTimeError(STMessage msg)
+            public virtual void compileTimeError(TemplateMessage msg)
{
Console.Error.WriteLine(msg);
}

-            public virtual void runTimeError(STMessage msg)
+            public virtual void runTimeError(TemplateMessage msg)
{
if (msg.Error != ErrorType.NO_SUCH_PROPERTY)
{ // ignore these
@@ -59,12 +59,12 @@ namespace Antlr4.StringTemplate.Misc
}
}

-            public virtual void IOError(STMessage msg)
+            public virtual void IOError(TemplateMessage msg)
{
Console.Error.WriteLine(msg);
}

-            public virtual void internalError(STMessage msg)
+            public virtual void internalError(TemplateMessage msg)
{
Console.Error.WriteLine(msg);
// throw new Error("internal error", msg.cause);
@@ -92,7 +92,7 @@ namespace Antlr4.StringTemplate.Misc
*
*  t() ::= <<foo>>
*
-         *  Here, the template starts at charPos 10, but the STLexer
+         *  Here, the template starts at charPos 10, but the TemplateLexer
*  thinks that the charPos is 0.  If we want to get correct
*  error info, we push the template token onto the context
*  stack and then all errors are relative to that.  Should
@@ -126,19 +126,19 @@ namespace Antlr4.StringTemplate.Misc
if (srcName != null)
srcName = Path.GetFileName(srcName);

-            listener.compileTimeError(new STCompiletimeMessage(error, srcName, templateToken, t, null, t.Text));
+            listener.compileTimeError(new TemplateCompiletimeMessage(error, srcName, templateToken, t, null, t.Text));
}

public virtual void lexerError(string srcName, string msg, IToken templateToken, RecognitionException e)
{
-            listener.compileTimeError(new STLexerMessage(srcName, msg, templateToken, e));
+            listener.compileTimeError(new TemplateLexerMessage(srcName, msg, templateToken, e));
}

public virtual void compileTimeError(ErrorType error, IToken templateToken, IToken t, object arg)
{
string srcName = t.InputStream.SourceName;
srcName = Path.GetFileName(srcName);
-            listener.compileTimeError(new STCompiletimeMessage(error, srcName, templateToken, t, null, arg));
+            listener.compileTimeError(new TemplateCompiletimeMessage(error, srcName, templateToken, t, null, arg));
}

public virtual void compileTimeError(ErrorType error, IToken templateToken, IToken t, object arg, object arg2)
@@ -147,58 +147,58 @@ namespace Antlr4.StringTemplate.Misc
if (srcName != null)
srcName = Path.GetFileName(srcName);

-            listener.compileTimeError(new STCompiletimeMessage(error, srcName, templateToken, t, null, arg, arg2));
+            listener.compileTimeError(new TemplateCompiletimeMessage(error, srcName, templateToken, t, null, arg, arg2));
}

public virtual void groupSyntaxError(ErrorType error, string srcName, RecognitionException e, string msg)
{
IToken t = e.Token;
-            listener.compileTimeError(new STGroupCompiletimeMessage(error, srcName, e.Token, e, msg));
+            listener.compileTimeError(new TemplateGroupCompiletimeMessage(error, srcName, e.Token, e, msg));
}

public virtual void groupLexerError(ErrorType error, string srcName, RecognitionException e, string msg)
{
-            listener.compileTimeError(new STGroupCompiletimeMessage(error, srcName, e.Token, e, msg));
+            listener.compileTimeError(new TemplateGroupCompiletimeMessage(error, srcName, e.Token, e, msg));
}

-        public virtual void runTimeError(ST self, int ip, ErrorType error)
+        public virtual void runTimeError(Template self, int ip, ErrorType error)
{
-            listener.runTimeError(new STRuntimeMessage(error, ip, self));
+            listener.runTimeError(new TemplateRuntimeMessage(error, ip, self));
}

-        public virtual void runTimeError(ST self, int ip, ErrorType error, object arg)
+        public virtual void runTimeError(Template self, int ip, ErrorType error, object arg)
{
-            listener.runTimeError(new STRuntimeMessage(error, ip, self, arg));
+            listener.runTimeError(new TemplateRuntimeMessage(error, ip, self, arg));
}

-        public virtual void runTimeError(ST self, int ip, ErrorType error, Exception e, object arg)
+        public virtual void runTimeError(Template self, int ip, ErrorType error, Exception e, object arg)
{
-            listener.runTimeError(new STRuntimeMessage(error, ip, self, e, arg));
+            listener.runTimeError(new TemplateRuntimeMessage(error, ip, self, e, arg));
}

-        public virtual void runTimeError(ST self, int ip, ErrorType error, object arg, object arg2)
+        public virtual void runTimeError(Template self, int ip, ErrorType error, object arg, object arg2)
{
-            listener.runTimeError(new STRuntimeMessage(error, ip, self, null, arg, arg2));
+            listener.runTimeError(new TemplateRuntimeMessage(error, ip, self, null, arg, arg2));
}

-        public virtual void runTimeError(ST self, int ip, ErrorType error, object arg, object arg2, object arg3)
+        public virtual void runTimeError(Template self, int ip, ErrorType error, object arg, object arg2, object arg3)
{
-            listener.runTimeError(new STRuntimeMessage(error, ip, self, null, arg, arg2, arg3));
+            listener.runTimeError(new TemplateRuntimeMessage(error, ip, self, null, arg, arg2, arg3));
}

-        public virtual void IOError(ST self, ErrorType error, Exception e)
+        public virtual void IOError(Template self, ErrorType error, Exception e)
{
-            listener.IOError(new STMessage(error, self, e));
+            listener.IOError(new TemplateMessage(error, self, e));
}

-        public virtual void IOError(ST self, ErrorType error, Exception e, object arg)
+        public virtual void IOError(Template self, ErrorType error, Exception e, object arg)
{
-            listener.IOError(new STMessage(error, self, e, arg));
+            listener.IOError(new TemplateMessage(error, self, e, arg));
}

-        public virtual void internalError(ST self, string msg, Exception e)
+        public virtual void internalError(Template self, string msg, Exception e)
{
-            listener.internalError(new STMessage(ErrorType.INTERNAL_ERROR, self, e, msg));
+            listener.internalError(new TemplateMessage(ErrorType.INTERNAL_ERROR, self, e, msg));
}
}
}
diff --git a/Antlr4.StringTemplate/Misc/MapModelAdaptor.cs b/Antlr4.StringTemplate/Misc/MapModelAdaptor.cs
index c3289d1..3dc268d 100644
--- a/Antlr4.StringTemplate/Misc/MapModelAdaptor.cs
+++ b/Antlr4.StringTemplate/Misc/MapModelAdaptor.cs
@@ -36,13 +36,13 @@ namespace Antlr4.StringTemplate.Misc

public class MapModelAdaptor : IModelAdaptor
{
-        public virtual object GetProperty(ST self, object o, object property, string propertyName)
+        public virtual object GetProperty(Template self, object o, object property, string propertyName)
{
object value;
IDictionary map = (IDictionary)o;

if (property == null)
-                value = map[STGroup.DefaultKey];
+                value = map[TemplateGroup.DefaultKey];
else if (property.Equals("keys"))
value = map.Keys;
else if (property.Equals("values"))
@@ -52,10 +52,10 @@ namespace Antlr4.StringTemplate.Misc
else if (map.Contains(propertyName))
value = map[propertyName]; // if can't find the key, try ToString version
else
-                value = map[STGroup.DefaultKey]; // not found, use default
+                value = map[TemplateGroup.DefaultKey]; // not found, use default

string valueString = value as string;
-            if (valueString == STGroup.DictionaryKey)
+            if (valueString == TemplateGroup.DictionaryKey)
{
value = property;
}
diff --git a/Antlr4.StringTemplate/Misc/ObjectModelAdaptor.cs b/Antlr4.StringTemplate/Misc/ObjectModelAdaptor.cs
index b3d5bc6..3ab0105 100644
--- a/Antlr4.StringTemplate/Misc/ObjectModelAdaptor.cs
+++ b/Antlr4.StringTemplate/Misc/ObjectModelAdaptor.cs
@@ -46,14 +46,14 @@ namespace Antlr4.StringTemplate.Misc
private static readonly Dictionary<Type, Dictionary<string, System.Func<object, object>>> _memberAccessors =
new Dictionary<Type, Dictionary<string, System.Func<object, object>>>();

-        public virtual object GetProperty(ST self, object o, object property, string propertyName)
+        public virtual object GetProperty(Template self, object o, object property, string propertyName)
{
if (o == null)
throw new ArgumentNullException("o");

Type c = o.GetType();
if (property == null)
-                throw new STNoSuchPropertyException(string.Format("{0}.{1}", c.FullName, propertyName ?? "null"));
+                throw new TemplateNoSuchPropertyException(string.Format("{0}.{1}", c.FullName, propertyName ?? "null"));

object value = null;
var accessor = FindMember(c, propertyName);
@@ -63,7 +63,7 @@ namespace Antlr4.StringTemplate.Misc
}
else
{
-                throw new STNoSuchPropertyException(string.Format("{0}.{1}", c.FullName, propertyName));
+                throw new TemplateNoSuchPropertyException(string.Format("{0}.{1}", c.FullName, propertyName));
}

return value;
diff --git a/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs
index 5a434e8..0d78976 100644
--- a/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateCompileTimeMessage.cs
@@ -38,30 +38,30 @@ namespace Antlr4.StringTemplate.Misc
using RecognitionException = Antlr.Runtime.RecognitionException;

/** Used for semantic errors that occur at compile time not during
-     *  interpretation. For ST parsing ONLY not group parsing.
+     *  interpretation. For Template parsing ONLY not group parsing.
*/
-    public class STCompiletimeMessage : STMessage
+    public class TemplateCompiletimeMessage : TemplateMessage
{
private readonly IToken templateToken; // overall token pulled from group file
private readonly IToken token;         // token inside template
private readonly string srcName;

-        public STCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t)
+        public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t)
: this(error, srcName, templateToken, t, null)
{
}

-        public STCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause)
+        public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause)
: this(error, srcName, templateToken, t, cause, null)
{
}

-        public STCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg)
+        public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg)
: this(error, srcName, templateToken, t, cause, arg, null)
{
}

-        public STCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg, object arg2)
+        public TemplateCompiletimeMessage(ErrorType error, string srcName, IToken templateToken, IToken t, Exception cause, object arg, object arg2)
: base(error, null, cause, arg, arg2)
{
this.templateToken = templateToken;
diff --git a/Antlr4.StringTemplate/Misc/TemplateDump.cs b/Antlr4.StringTemplate/Misc/TemplateDump.cs
index a183e81..2f357d6 100644
--- a/Antlr4.StringTemplate/Misc/TemplateDump.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateDump.cs
@@ -42,22 +42,22 @@ namespace Antlr4.StringTemplate.Misc
/** This class dumps out a hierarchy of templates in text form, indented
*  to show the nested relationship.  Usage:
*
-     *     ST st = ...;
-     *     STDump d = new STDump(st);
+     *     Template st = ...;
+     *     TemplateDump d = new TemplateDump(st);
*     System.out.println(d.ToString());
*/
-    public class STDump
+    public class TemplateDump
{
-        private readonly ST self;
+        private readonly Template self;

-        public STDump(ST self)
+        public TemplateDump(Template self)
{
this.self = self;
}

-        public static string toString(ST self)
+        public static string toString(Template self)
{
-            STDump d = new STDump(self);
+            TemplateDump d = new TemplateDump(self);
return d.ToString();
}

@@ -100,9 +100,9 @@ namespace Antlr4.StringTemplate.Misc
{
StringBuilder buf = new StringBuilder();
value = Interpreter.convertAnythingIteratableToIterator(value);
-            if (value is ST)
+            if (value is Template)
{
-                STDump d = new STDump((ST)value);
+                TemplateDump d = new TemplateDump((Template)value);
buf.Append(d.toString(n));
}
else if (value is Iterator)
diff --git a/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs
index 06fc13c..542a535 100644
--- a/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateGroupCompiletimeMessage.cs
@@ -36,7 +36,7 @@ namespace Antlr4.StringTemplate.Misc
using IToken = Antlr.Runtime.IToken;
using RecognitionException = Antlr.Runtime.RecognitionException;

-    public class STGroupCompiletimeMessage : STMessage
+    public class TemplateGroupCompiletimeMessage : TemplateMessage
{
/// <summary>
/// token inside group file
@@ -44,17 +44,17 @@ namespace Antlr4.StringTemplate.Misc
private readonly IToken token;
private readonly string srcName;

-        public STGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause)
+        public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause)
: this(error, srcName, t, cause, null)
{
}

-        public STGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg)
+        public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg)
: this(error, srcName, t, cause, arg, null)
{
}

-        public STGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg, object arg2)
+        public TemplateGroupCompiletimeMessage(ErrorType error, string srcName, IToken t, Exception cause, object arg, object arg2)
: base(error, null, cause, arg, arg2)
{
this.token = t;
diff --git a/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs b/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs
index f6f7f79..13719fa 100644
--- a/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateLexerMessage.cs
@@ -38,13 +38,13 @@ namespace Antlr4.StringTemplate.Misc
using RecognitionException = Antlr.Runtime.RecognitionException;

/** */
-    public class STLexerMessage : STMessage
+    public class TemplateLexerMessage : TemplateMessage
{
string msg;
IToken templateToken; // overall token pulled from group file
string srcName;

-        public STLexerMessage(string srcName, string msg, IToken templateToken, Exception cause)
+        public TemplateLexerMessage(string srcName, string msg, IToken templateToken, Exception cause)
: base(ErrorType.LEXER_ERROR, null, cause, null)
{
this.msg = msg;
diff --git a/Antlr4.StringTemplate/Misc/TemplateMessage.cs b/Antlr4.StringTemplate/Misc/TemplateMessage.cs
index 07eff3a..63d5c62 100644
--- a/Antlr4.StringTemplate/Misc/TemplateMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateMessage.cs
@@ -36,66 +36,66 @@ namespace Antlr4.StringTemplate.Misc
using IToken = Antlr.Runtime.IToken;
using StringWriter = System.IO.StringWriter;

-    /** Upon error, ST creates an STMessage or subclass instance and notifies
+    /** Upon error, Template creates an TemplateMessage or subclass instance and notifies
*  the listener.  This root class is used for IO and internal errors.
*
-     *  @see STRuntimeMessage
-     *  @see STCompiletimeMessage
+     *  @see TemplateRuntimeMessage
+     *  @see TemplateCompiletimeMessage
*/
-    public class STMessage
+    public class TemplateMessage
{
/** if in debug mode, has created instance, add attr events and eval
*  template events.
*/
-        private readonly ST self;
+        private readonly Template self;
private readonly ErrorType error;
private readonly object arg;
private readonly object arg2;
private readonly object arg3;
private readonly Exception cause;

-        public STMessage(ErrorType error)
+        public TemplateMessage(ErrorType error)
{
this.error = error;
}

-        public STMessage(ErrorType error, ST self)
+        public TemplateMessage(ErrorType error, Template self)
: this(error)
{
this.self = self;
}

-        public STMessage(ErrorType error, ST self, Exception cause)
+        public TemplateMessage(ErrorType error, Template self, Exception cause)
: this(error, self)
{
this.cause = cause;
}

-        public STMessage(ErrorType error, ST self, Exception cause, object arg)
+        public TemplateMessage(ErrorType error, Template self, Exception cause, object arg)
: this(error, self, cause)
{
this.arg = arg;
}

-        public STMessage(ErrorType error, ST self, Exception cause, IToken where, object arg)
+        public TemplateMessage(ErrorType error, Template self, Exception cause, IToken where, object arg)
: this(error, self, cause, where)
{
this.arg = arg;
}

-        public STMessage(ErrorType error, ST self, Exception cause, object arg, object arg2)
+        public TemplateMessage(ErrorType error, Template self, Exception cause, object arg, object arg2)
: this(error, self, cause, arg)
{
this.arg2 = arg2;
}

-        public STMessage(ErrorType error, ST self, Exception cause, object arg, object arg2, object arg3)
+        public TemplateMessage(ErrorType error, Template self, Exception cause, object arg, object arg2, object arg3)
: this(error, self, cause, arg, arg2)
{
this.arg3 = arg3;
}

-        public ST Self
+        public Template Self
{
get
{
diff --git a/Antlr4.StringTemplate/Misc/TemplateModelAdaptor.cs b/Antlr4.StringTemplate/Misc/TemplateModelAdaptor.cs
index dc91538..352b354 100644
--- a/Antlr4.StringTemplate/Misc/TemplateModelAdaptor.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateModelAdaptor.cs
@@ -32,11 +32,11 @@

namespace Antlr4.StringTemplate.Misc
{
-    public class STModelAdaptor : IModelAdaptor
+    public class TemplateModelAdaptor : IModelAdaptor
{
-        public virtual object GetProperty(ST self, object o, object property, string propertyName)
+        public virtual object GetProperty(Template self, object o, object property, string propertyName)
{
-            ST st = (ST)o;
+            Template st = (Template)o;
return st.getAttribute(propertyName);
}
}
diff --git a/Antlr4.StringTemplate/Misc/TemplateNoSuchPropertyException.cs b/Antlr4.StringTemplate/Misc/TemplateNoSuchPropertyException.cs
index 26ebfb5..f26b4a2 100644
--- a/Antlr4.StringTemplate/Misc/TemplateNoSuchPropertyException.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateNoSuchPropertyException.cs
@@ -35,20 +35,20 @@ namespace Antlr4.StringTemplate.Misc
using Antlr4.StringTemplate.Compiler;
using Exception = System.Exception;

-    public class STNoSuchPropertyException : STException
+    public class TemplateNoSuchPropertyException : TemplateException
{
private readonly string propertyName;

-        public STNoSuchPropertyException()
+        public TemplateNoSuchPropertyException()
{
}

-        public STNoSuchPropertyException(string propertyName)
+        public TemplateNoSuchPropertyException(string propertyName)
{
this.propertyName = propertyName;
}

-        public STNoSuchPropertyException(Exception e, string propertyName)
+        public TemplateNoSuchPropertyException(Exception e, string propertyName)
: base(null, e)
{
this.propertyName = propertyName;
diff --git a/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs b/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs
index 7f6b360..3ff5f82 100644
--- a/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs
+++ b/Antlr4.StringTemplate/Misc/TemplateRuntimeMessage.cs
@@ -35,39 +35,39 @@ namespace Antlr4.StringTemplate.Misc
using Exception = System.Exception;
using StringBuilder = System.Text.StringBuilder;

-    /** Used to track errors that occur in the ST interpreter. */
-    public class STRuntimeMessage : STMessage
+    /** Used to track errors that occur in the Template interpreter. */
+    public class TemplateRuntimeMessage : TemplateMessage
{
/** Where error occurred in bytecode memory */
private readonly int ip = -1;

-        public STRuntimeMessage(ErrorType error, int ip)
+        public TemplateRuntimeMessage(ErrorType error, int ip)
: this(error, ip, null)
{
}

-        public STRuntimeMessage(ErrorType error, int ip, ST self)
+        public TemplateRuntimeMessage(ErrorType error, int ip, Template self)
: this(error, ip, self, null)
{
}

-        public STRuntimeMessage(ErrorType error, int ip, ST self, object arg)
+        public TemplateRuntimeMessage(ErrorType error, int ip, Template self, object arg)
: this(error, ip, self, null, arg, null)
{
}

-        public STRuntimeMessage(ErrorType error, int ip, ST self, Exception e, object arg)
+        public TemplateRuntimeMessage(ErrorType error, int ip, Template self, Exception e, object arg)
: this(error, ip, self, e, arg, null)
{
}

-        public STRuntimeMessage(ErrorType error, int ip, ST self, Exception e, object arg, object arg2)
+        public TemplateRuntimeMessage(ErrorType error, int ip, Template self, Exception e, object arg, object arg2)
: base(error, self, e, arg, arg2)
{
this.ip = ip;
}

-        public STRuntimeMessage(ErrorType error, int ip, ST self, Exception e, object arg, object arg2, object arg3)
+        public TemplateRuntimeMessage(ErrorType error, int ip, Template self, Exception e, object arg, object arg2, object arg3)
: base(error, self, e, arg, arg2, arg3)
{
this.ip = ip;
diff --git a/Antlr4.StringTemplate/Template.cs b/Antlr4.StringTemplate/Template.cs
index 58cff7e..5875c91 100644
--- a/Antlr4.StringTemplate/Template.cs
+++ b/Antlr4.StringTemplate/Template.cs
@@ -53,10 +53,10 @@ namespace Antlr4.StringTemplate
*  in a deeply nested template for an HTML page body, we could still reference
*  the title attribute defined in the outermost page template.
*
-     *  To use templates, you create one (usually via STGroup) and then inject
+     *  To use templates, you create one (usually via TemplateGroup) and then inject
*  attributes using add(). To render its attacks, use render().
*/
-    public class ST
+    public class Template
{
/** <@r()>, <@r>...<@end>, and @t.r() ::= "..." defined manually by coder */
public enum RegionType
@@ -70,7 +70,7 @@ namespace Antlr4.StringTemplate
public static readonly object EmptyAttribute = new object();

/** The implementation for this template among all instances of same tmpelate . */
-        public CompiledST impl;
+        public CompiledTemplate impl;

/** Safe to simultaneously write via add, which is synchronized.  Reading
*  during exec is, however, NOT synchronized.  So, not thread safe to
@@ -83,7 +83,7 @@ namespace Antlr4.StringTemplate
*  IF-subtemplates are considered embedded as well. We look up
*  dynamically scoped attributes with this ptr.
*/
-        public ST enclosingInstance; // who's your daddy?
+        public Template enclosingInstance; // who's your daddy?

/** Created as instance of which group? We need this to init interpreter
*  via render.  So, we create st and then it needs to know which
@@ -101,10 +101,10 @@ namespace Antlr4.StringTemplate
*   v
*   g2 = {t()}
*/
-        public STGroup groupThatCreatedThisInstance;
+        public TemplateGroup groupThatCreatedThisInstance;

/** Just an alias for ArrayList, but this way I can track whether a
-         *  list is something ST created or it's an incoming list.
+         *  list is something Template created or it's an incoming list.
*/
public sealed class AttributeList : List<object>
{
@@ -119,28 +119,28 @@ namespace Antlr4.StringTemplate
}

/** Used by group creation routine, not by users */
-        public ST()
+        public Template()
{
}

/** Used to make templates inline in code for simple things like SQL or log records.
*  No formal args are set and there is no enclosing instance.
*/
-        public ST(string template)
-            : this(STGroup.defaultGroup, template)
+        public Template(string template)
+            : this(TemplateGroup.defaultGroup, template)
{
}

-        /** Create ST using non-default delimiters; each one of these will live
+        /** Create Template using non-default delimiters; each one of these will live
*  in it's own group since you're overriding a default; don't want to
-         *  alter STGroup.defaultGroup.
+         *  alter TemplateGroup.defaultGroup.
*/
-        public ST(string template, char delimiterStartChar, char delimiterStopChar)
-            : this(new STGroup(delimiterStartChar, delimiterStopChar), template)
+        public Template(string template, char delimiterStartChar, char delimiterStopChar)
+            : this(new TemplateGroup(delimiterStartChar, delimiterStopChar), template)
{
}

-        public ST(STGroup group, string template)
+        public Template(TemplateGroup group, string template)
{
groupThatCreatedThisInstance = group;
impl = groupThatCreatedThisInstance.compile(group.getFileName(), null,
@@ -151,7 +151,7 @@ namespace Antlr4.StringTemplate
}

/** Clone a prototype template for application in MAP operations; copy all fields */
-        public ST(ST proto)
+        public Template(Template proto)
{
this.impl = proto.impl;
if (proto.locals != null)
@@ -188,7 +188,7 @@ namespace Antlr4.StringTemplate
}
else
{
-                // define and make room in locals (a hack to make new ST("simple template") work.)
+                // define and make room in locals (a hack to make new Template("simple template") work.)
arg = impl.TryGetFormalArgument(name);
if (arg == null)
{
@@ -204,8 +204,8 @@ namespace Antlr4.StringTemplate
}
}

-            if (value is ST)
-                ((ST)value).enclosingInstance = this;
+            if (value is Template)
+                ((Template)value).enclosingInstance = this;

object curvalue = locals[arg.Index];
if (curvalue == EmptyAttribute)
@@ -256,7 +256,7 @@ namespace Antlr4.StringTemplate
}

/** Set this.locals attr value when you only know the name, not the index.
-         *  This is ultimately invoked by calling ST.add() from outside so toss
+         *  This is ultimately invoked by calling Template.add() from outside so toss
*  an exception to notify them.
*/
protected internal virtual void rawSetAttribute(string name, object value)
@@ -271,20 +271,20 @@ namespace Antlr4.StringTemplate
locals[arg.Index] = value;
}

-        /** Find an attr via dynamic scoping up enclosing ST chain.
+        /** Find an attr via dynamic scoping up enclosing Template chain.
*  If not found, look for a map.  So attributes sent in to a template
*  override dictionary names.
*/
public virtual object getAttribute(string name)
{
-            ST p = this;
+            Template p = this;
while (p != null)
{
FormalArgument localArg = p.impl.TryGetFormalArgument(name);
if (localArg != null)
{
object o = p.locals[localArg.Index];
-                    if (o == ST.EmptyAttribute)
+                    if (o == Template.EmptyAttribute)
o = null;
return o;
}
@@ -297,7 +297,7 @@ namespace Antlr4.StringTemplate
return impl.nativeGroup.rawGetDictionary(name);
}

-            throw new STNoSuchPropertyException(name);
+            throw new TemplateNoSuchPropertyException(name);
}

public virtual IDictionary<string, object> getAttributes()
@@ -309,7 +309,7 @@ namespace Antlr4.StringTemplate
foreach (FormalArgument a in impl.formalArguments)
{
object o = locals[a.Index];
-                if (o == ST.EmptyAttribute)
+                if (o == Template.EmptyAttribute)
o = null;

attributes[a.Name] = o;
@@ -328,13 +328,13 @@ namespace Antlr4.StringTemplate
}
else if (curvalue.GetType() == typeof(AttributeList))
{
-                // already a list made by ST
+                // already a list made by Template
multi = (AttributeList)curvalue;
}
else if (curvalue is IList)
{
-                // existing attribute is non-ST List
-                // must copy to an ST-managed list before adding new attribute
+                // existing attribute is non-Template List
+                // must copy to an Template-managed list before adding new attribute
// (can't alter incoming attributes)
IList listAttr = (IList)curvalue;
multi = new AttributeList(listAttr.Count);
@@ -362,10 +362,10 @@ namespace Antlr4.StringTemplate
*/
public virtual string getEnclosingInstanceStackString()
{
-            List<ST> templates = getEnclosingInstanceStack(true);
+            List<Template> templates = getEnclosingInstanceStack(true);
StringBuilder buf = new StringBuilder();
int i = 0;
-            foreach (ST st in templates)
+            foreach (Template st in templates)
{
if (i > 0)
buf.Append(" ");
@@ -376,10 +376,10 @@ namespace Antlr4.StringTemplate
return buf.ToString();
}

-        public virtual List<ST> getEnclosingInstanceStack(bool topdown)
+        public virtual List<Template> getEnclosingInstanceStack(bool topdown)
{
-            List<ST> stack = new List<ST>();
-            ST p = this;
+            List<Template> stack = new List<Template>();
+            Template p = this;
while (p != null)
{
if (topdown)
@@ -462,9 +462,9 @@ namespace Antlr4.StringTemplate
return impl.name + "()";
}

-        // ST.format("name, phone | <name>:<phone>", n, p);
-        // ST.format("<%1>:<%2>", n, p);
-        // ST.format("<name>:<phone>", "name", x, "phone", y);
+        // Template.format("name, phone | <name>:<phone>", n, p);
+        // Template.format("<%1>:<%2>", n, p);
+        // Template.format("<name>:<phone>", "name", x, "phone", y);
public static string format(string template, params object[] attributes)
{
return format(AutoIndentWriter.NoWrap, template, attributes);
@@ -475,7 +475,7 @@ namespace Antlr4.StringTemplate
template = Regex.Replace(template, "[0-9]+", @"arg\0");
Console.WriteLine(template);

-            ST st = new ST(template);
+            Template st = new Template(template);
int i = 1;
foreach (object a in attributes)
{
diff --git a/Antlr4.StringTemplate/TemplateGroup.cs b/Antlr4.StringTemplate/TemplateGroup.cs
index 338f61c..f9f4649 100644
--- a/Antlr4.StringTemplate/TemplateGroup.cs
+++ b/Antlr4.StringTemplate/TemplateGroup.cs
@@ -52,10 +52,10 @@ namespace Antlr4.StringTemplate
/** A directory or directory tree of .st template files and/or group files.
*  Individual template files contain formal template definitions. In a sense,
*  it's like a single group file broken into multiple files, one for each template.
-     *  ST v3 had just the pure template inside, not the template name and header.
+     *  Template v3 had just the pure template inside, not the template name and header.
*  Name inside must match filename (minus suffix).
*/
-    public class STGroup
+    public class TemplateGroup
{
/** When we use key as a value in a dictionary, this is how we signify. */
public static readonly string DictionaryKey = "key";
@@ -67,13 +67,13 @@ namespace Antlr4.StringTemplate
/** Every group can import templates/dictionaries from other groups.
*  The list must be synchronized (see importTemplates).
*/
-        protected List<STGroup> imports;
+        protected List<TemplateGroup> imports;

public char delimiterStartChar = '<'; // Use <expr> by default
public char delimiterStopChar = '>';

/** Maps template name to StringTemplate object. synchronized. */
-        protected IDictionary<string, CompiledST> templates = new Dictionary<string, CompiledST>();
+        protected IDictionary<string, CompiledTemplate> templates = new Dictionary<string, CompiledTemplate>();

/** Maps dict names to HashMap objects.  This is the list of dictionaries
*  defined by the user like typeInitMap ::= ["int":"0"]
@@ -105,23 +105,23 @@ namespace Antlr4.StringTemplate
*  a particular kind of object (subclass or implementation). Applies
*  for any template evaluated relative to this group.
*
-         *  ST initializes with model adaptors that know how to pull
+         *  Template initializes with model adaptors that know how to pull
*  properties out of Objects, Maps, and STs.
*/
protected TypeRegistry<IModelAdaptor> adaptors =
new TypeRegistry<IModelAdaptor>()
{
{typeof(object), new ObjectModelAdaptor()},
-                {typeof(ST), new STModelAdaptor()},
+                {typeof(Template), new TemplateModelAdaptor()},
{typeof(IDictionary), new MapModelAdaptor()},
};

-        public static STGroup defaultGroup = new STGroup();
+        public static TemplateGroup defaultGroup = new TemplateGroup();

/** Used to indicate that the template doesn't exist.
*  Prevents duplicate group file loads and unnecessary file checks.
*/
-        protected static readonly CompiledST NotFoundTemplate = new CompiledST();
+        protected static readonly CompiledTemplate NotFoundTemplate = new CompiledTemplate();

public static readonly ErrorManager DefaultErrorManager = new ErrorManager();

@@ -130,13 +130,13 @@ namespace Antlr4.StringTemplate
/** The errMgr for entire group; all compilations and executions.
*  This gets copied to parsers, walkers, and interpreters.
*/
-        public ErrorManager errMgr = STGroup.DefaultErrorManager;
+        public ErrorManager errMgr = TemplateGroup.DefaultErrorManager;

-        public STGroup()
+        public TemplateGroup()
{
}

-        public STGroup(char delimiterStartChar, char delimiterStopChar)
+        public TemplateGroup(char delimiterStartChar, char delimiterStopChar)
{
this.delimiterStartChar = delimiterStartChar;
this.delimiterStopChar = delimiterStopChar;
@@ -145,36 +145,36 @@ namespace Antlr4.StringTemplate
/** The primary means of getting an instance of a template from this
*  group. Names must be absolute, fully-qualified names like a/b
*/
-        public virtual ST getInstanceOf(string name)
+        public virtual Template getInstanceOf(string name)
{
if (name == null)
return null;
//System.out.println("getInstanceOf("+name+")");
-            CompiledST c = lookupTemplate(name);
+            CompiledTemplate c = lookupTemplate(name);
if (c != null)
{
-                ST instanceST = createStringTemplate();
+                Template instanceST = createStringTemplate();
instanceST.groupThatCreatedThisInstance = this;
instanceST.impl = c;
if (instanceST.impl.formalArguments != null)
{
instanceST.locals = new object[instanceST.impl.formalArguments.Count];
for (int i = 0; i < instanceST.locals.Length; i++)
-                        instanceST.locals[i] = ST.EmptyAttribute;
+                        instanceST.locals[i] = Template.EmptyAttribute;
}
return instanceST;
}
return null;
}

-        protected internal virtual ST getEmbeddedInstanceOf(ST enclosingInstance, int ip, string name)
+        protected internal virtual Template getEmbeddedInstanceOf(Template enclosingInstance, int ip, string name)
{
-            ST st = getInstanceOf(name);
+            Template st = getInstanceOf(name);
if (st == null)
{
errMgr.runTimeError(enclosingInstance, ip, ErrorType.NO_SUCH_TEMPLATE, name);
st = createStringTemplate();
-                st.impl = new CompiledST();
+                st.impl = new CompiledTemplate();
return st;
}
st.enclosingInstance = enclosingInstance;
@@ -182,7 +182,7 @@ namespace Antlr4.StringTemplate
}

/** Create singleton template for use with dictionary values */
-        public virtual ST createSingleton(IToken templateToken)
+        public virtual Template createSingleton(IToken templateToken)
{
string template;
if (templateToken.Type == GroupParser.BIGSTRING)
@@ -193,11 +193,11 @@ namespace Antlr4.StringTemplate
{
template = Utility.strip(templateToken.Text, 1);
}
-            ST st = createStringTemplate();
+            Template st = createStringTemplate();
st.groupThatCreatedThisInstance = this;
st.impl = compile(getFileName(), null, null, template, templateToken);
st.impl.hasFormalArgs = false;
-            st.impl.name = ST.UnknownName;
+            st.impl.name = Template.UnknownName;
st.impl.defineImplicitlyDefinedTemplates(this);
return st;
}
@@ -211,9 +211,9 @@ namespace Antlr4.StringTemplate
}

/** Look up a fully-qualified name */
-        public virtual CompiledST lookupTemplate(string name)
+        public virtual CompiledTemplate lookupTemplate(string name)
{
-            CompiledST code;
+            CompiledTemplate code;
templates.TryGetValue(name, out code);
if (code == NotFoundTemplate)
return null;
@@ -245,7 +245,7 @@ namespace Antlr4.StringTemplate
/** Load st from disk if dir or load whole group file if .stg file (then
*  return just one template). name is fully-qualified.
*/
-        protected virtual CompiledST load(string name)
+        protected virtual CompiledTemplate load(string name)
{
return null;
}
@@ -255,23 +255,23 @@ namespace Antlr4.StringTemplate
{
}

-        protected internal virtual CompiledST lookupImportedTemplate(string name)
+        protected internal virtual CompiledTemplate lookupImportedTemplate(string name)
{
//System.out.println("look for "+name+" in "+imports);
if (imports == null)
return null;
-            foreach (STGroup g in imports)
+            foreach (TemplateGroup g in imports)
{
-                CompiledST code = g.lookupTemplate(name);
+                CompiledTemplate code = g.lookupTemplate(name);
if (code != null)
return code;
}
return null;
}

-        public virtual CompiledST rawGetTemplate(string name)
+        public virtual CompiledTemplate rawGetTemplate(string name)
{
-            CompiledST template;
+            CompiledTemplate template;
templates.TryGetValue(name, out template);
return template;
}
@@ -289,14 +289,14 @@ namespace Antlr4.StringTemplate
}

// for testing
-        public virtual CompiledST defineTemplate(string templateName, string template)
+        public virtual CompiledTemplate defineTemplate(string templateName, string template)
{
try
{
-                CompiledST impl = defineTemplate(templateName, new CommonToken(GroupParser.ID, templateName), null, template, null);
+                CompiledTemplate impl = defineTemplate(templateName, new CommonToken(GroupParser.ID, templateName), null, template, null);
return impl;
}
-            catch (STException)
+            catch (TemplateException)
{
Console.Error.WriteLine("eh?");
}
@@ -305,7 +305,7 @@ namespace Antlr4.StringTemplate
}

// for testing
-        public virtual CompiledST defineTemplate(string name, string argsS, string template)
+        public virtual CompiledTemplate defineTemplate(string name, string argsS, string template)
{
string[] args = argsS.Split(',');
List<FormalArgument> a = new List<FormalArgument>();
@@ -315,7 +315,7 @@ namespace Antlr4.StringTemplate
return defineTemplate(name, new CommonToken(GroupParser.ID, name), a, template, null);
}

-        public virtual CompiledST defineTemplate(string templateName,
+        public virtual CompiledTemplate defineTemplate(string templateName,
IToken nameT,
List<FormalArgument> args,
string template,
@@ -329,7 +329,7 @@ namespace Antlr4.StringTemplate
template = Utility.trimOneStartingNewline(template);
template = Utility.trimOneTrailingNewline(template);
// compile, passing in templateName as enclosing name for any embedded regions
-            CompiledST code = compile(getFileName(), templateName, args, template, templateToken);
+            CompiledTemplate code = compile(getFileName(), templateName, args, template, templateToken);
code.name = templateName;
rawDefineTemplate(templateName, code, nameT);
code.defineArgDefaultValueTemplates(this);
@@ -339,11 +339,11 @@ namespace Antlr4.StringTemplate
}

/** Make name and alias for target.  Replace any previous def of name */
-        public virtual CompiledST defineTemplateAlias(IToken aliasT, IToken targetT)
+        public virtual CompiledTemplate defineTemplateAlias(IToken aliasT, IToken targetT)
{
string alias = aliasT.Text;
string target = targetT.Text;
-            CompiledST targetCode;
+            CompiledTemplate targetCode;
templates.TryGetValue(target, out targetCode);
if (targetCode == null)
{
@@ -355,23 +355,23 @@ namespace Antlr4.StringTemplate
return targetCode;
}

-        public virtual CompiledST defineRegion(string enclosingTemplateName,
+        public virtual CompiledTemplate defineRegion(string enclosingTemplateName,
IToken regionT,
string template)
{
string name = regionT.Text;
-            CompiledST code = compile(getFileName(), enclosingTemplateName, null, template, regionT);
+            CompiledTemplate code = compile(getFileName(), enclosingTemplateName, null, template, regionT);
string mangled = getMangledRegionName(enclosingTemplateName, name);

if (lookupTemplate(mangled) == null)
{
errMgr.compileTimeError(ErrorType.NO_SUCH_REGION, null, regionT, enclosingTemplateName, name);
-                return new CompiledST();
+                return new CompiledTemplate();
}

code.name = mangled;
code.isRegion = true;
-            code.regionDefType = ST.RegionType.Explicit;
+            code.regionDefType = Template.RegionType.Explicit;

rawDefineTemplate(mangled, code, regionT);
return code;
@@ -399,16 +399,16 @@ namespace Antlr4.StringTemplate
defineTemplate(templateName, nameToken, args, template, templateToken);
}
}
-            catch (STException)
+            catch (TemplateException)
{
// after getting syntax error in a template, we emit msg
// and throw exception to blast all the way out here.
}
}

-        public virtual void rawDefineTemplate(string name, CompiledST code, IToken defT)
+        public virtual void rawDefineTemplate(string name, CompiledTemplate code, IToken defT)
{
-            CompiledST prev;
+            CompiledTemplate prev;
templates.TryGetValue(name, out prev);
if (prev != null)
{
@@ -417,12 +417,12 @@ namespace Antlr4.StringTemplate
errMgr.compileTimeError(ErrorType.TEMPLATE_REDEFINITION, null, defT);
return;
}
-                if (prev.isRegion && prev.regionDefType == ST.RegionType.Embedded)
+                if (prev.isRegion && prev.regionDefType == Template.RegionType.Embedded)
{
errMgr.compileTimeError(ErrorType.EMBEDDED_REGION_REDEFINITION, null, defT, getUnMangledTemplateName(name));
return;
}
-                else if (prev.isRegion && prev.regionDefType == ST.RegionType.Explicit)
+                else if (prev.isRegion && prev.regionDefType == Template.RegionType.Explicit)
{
errMgr.compileTimeError(ErrorType.REGION_REDEFINITION, null, defT, getUnMangledTemplateName(name));
return;
@@ -438,15 +438,15 @@ namespace Antlr4.StringTemplate
}

/** Compile a template */
-        public virtual CompiledST compile(string srcName,
+        public virtual CompiledTemplate compile(string srcName,
string name,
List<FormalArgument> args,
string template,
IToken templateToken) // for error location
{
-            //System.out.println("STGroup.compile: "+enclosingTemplateName);
-            Compiler.Compiler c = new Compiler.Compiler(errMgr, delimiterStartChar, delimiterStopChar);
-            CompiledST code = c.compile(srcName, name, args, template, templateToken);
+            //System.out.println("TemplateGroup.compile: "+enclosingTemplateName);
+            Compiler.TemplateCompiler c = new Compiler.TemplateCompiler(errMgr, delimiterStartChar, delimiterStopChar);
+            CompiledTemplate code = c.compile(srcName, name, args, template, templateToken);
code.nativeGroup = this;
code.template = template;
return code;
@@ -475,13 +475,13 @@ namespace Antlr4.StringTemplate
}

/** Make this group import templates/dictionaries from g. */
-        public virtual void importTemplates(STGroup g)
+        public virtual void importTemplates(TemplateGroup g)
{
if (g == null)
return;

if (imports == null)
-                imports = new List<STGroup>();
+                imports = new List<TemplateGroup>();

imports.Add(g);
}
@@ -504,14 +504,14 @@ namespace Antlr4.StringTemplate
if (fileName == null || fileName.Equals("<missing STRING>"))
return;
fileName = Utility.strip(fileName, 1);
-            STGroup g = null;
+            TemplateGroup g = null;
if (fileName.EndsWith(".stg"))
{
-                g = new STGroupFile(fileName, delimiterStartChar, delimiterStopChar);
+                g = new TemplateGroupFile(fileName, delimiterStartChar, delimiterStopChar);
}
else
{
-                g = new STGroupDir(fileName, delimiterStartChar, delimiterStopChar);
+                g = new TemplateGroupDirectory(fileName, delimiterStartChar, delimiterStopChar);
}
importTemplates(g);
}
@@ -537,9 +537,9 @@ namespace Antlr4.StringTemplate
}
}

-        /** Add an adaptor for a kind of object so ST knows how to pull properties
-         *  from them. Add adaptors in increasing order of specificity.  ST adds Object,
-         *  Map, and ST model adaptors for you first. Adaptors you add have
+        /** Add an adaptor for a kind of object so Template knows how to pull properties
+         *  from them. Add adaptors in increasing order of specificity.  Template adds Object,
+         *  Map, and Template model adaptors for you first. Adaptors you add have
*  priority over default adaptors.
*
*  If an adaptor for type T already exists, it is replaced by the adaptor arg.
@@ -580,21 +580,21 @@ namespace Antlr4.StringTemplate
}

/** StringTemplate object factory; each group can have its own. */
-        public virtual ST createStringTemplate()
+        public virtual Template createStringTemplate()
{
// TODO: try making a mem pool?
if (debug)
return new DebugST();

-            return new ST();
+            return new Template();
}

-        public virtual ST createStringTemplate(ST proto)
+        public virtual Template createStringTemplate(Template proto)
{
if (debug)
return new DebugST(proto);

-            return new ST(proto);
+            return new Template(proto);
}

public virtual string getName()
@@ -621,7 +621,7 @@ namespace Antlr4.StringTemplate
foreach (string n in templates.Keys)
{
string name = n;
-                CompiledST c = templates[name];
+                CompiledTemplate c = templates[name];
if (c.isAnonSubtemplate || c == NotFoundTemplate)
continue;

diff --git a/Antlr4.StringTemplate/TemplateGroupDirectory.cs b/Antlr4.StringTemplate/TemplateGroupDirectory.cs
index 0dc684d..f249998 100644
--- a/Antlr4.StringTemplate/TemplateGroupDirectory.cs
+++ b/Antlr4.StringTemplate/TemplateGroupDirectory.cs
@@ -53,17 +53,17 @@ namespace Antlr4.StringTemplate
*  We load files on-demand. If we fail to find a file, we look for it via
*  the CLASSPATH as a resource.  I track everything with URLs not file names.
*/
-    public class STGroupDir : STGroup
+    public class TemplateGroupDirectory : TemplateGroup
{
public readonly string groupDirName;
public readonly Uri root;

-        public STGroupDir(string dirName)
+        public TemplateGroupDirectory(string dirName)
: this(dirName, '<', '>')
{
}

-        public STGroupDir(string dirName, char delimiterStartChar, char delimiterStopChar)
+        public TemplateGroupDirectory(string dirName, char delimiterStartChar, char delimiterStopChar)
: base(delimiterStartChar, delimiterStopChar)
{
this.groupDirName = dirName;
@@ -98,18 +98,18 @@ namespace Antlr4.StringTemplate
}
}

-        public STGroupDir(string dirName, Encoding encoding)
+        public TemplateGroupDirectory(string dirName, Encoding encoding)
: this(dirName, encoding, '<', '>')
{
}

-        public STGroupDir(string dirName, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+        public TemplateGroupDirectory(string dirName, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
: this(dirName, delimiterStartChar, delimiterStopChar)
{
this.encoding = encoding;
}

-        public STGroupDir(Uri root, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+        public TemplateGroupDirectory(Uri root, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
: base(delimiterStartChar, delimiterStopChar)
{
this.root = root;
@@ -119,7 +119,7 @@ namespace Antlr4.StringTemplate
/** Load a template from dir or group file.  Group file is given
*  precedence over dir with same name.
*/
-        protected override CompiledST load(string name)
+        protected override CompiledTemplate load(string name)
{
string parent = Utility.getPrefix(name);

@@ -170,13 +170,13 @@ namespace Antlr4.StringTemplate

loadGroupFile(parent, Path.Combine(root.LocalPath, parent) + ".stg");

-            CompiledST template;
+            CompiledTemplate template;
templates.TryGetValue(name, out template);
return template;
}

/** Load full path name .st file relative to root by prefix */
-        public virtual CompiledST loadTemplateFile(string prefix, string fileName)
+        public virtual CompiledTemplate loadTemplateFile(string prefix, string fileName)
{
if (Path.IsPathRooted(fileName))
throw new ArgumentException();
@@ -220,7 +220,7 @@ namespace Antlr4.StringTemplate
errMgr.groupSyntaxError(ErrorType.SYNTAX_ERROR, Path.GetFileName(f.LocalPath), re, re.Message);
}

-            CompiledST template;
+            CompiledTemplate template;
templates.TryGetValue(templateName, out template);
return template;
}
diff --git a/Antlr4.StringTemplate/TemplateGroupFile.cs b/Antlr4.StringTemplate/TemplateGroupFile.cs
index 93bca68..404aad7 100644
--- a/Antlr4.StringTemplate/TemplateGroupFile.cs
+++ b/Antlr4.StringTemplate/TemplateGroupFile.cs
@@ -46,7 +46,7 @@ namespace Antlr4.StringTemplate
*  ".stg").  If we fail to find a group file, look for it via the
*  CLASSPATH as a resource.
*/
-    public class STGroupFile : STGroup
+    public class TemplateGroupFile : TemplateGroup
{
public readonly string fileName;
public readonly Uri url;
@@ -54,12 +54,12 @@ namespace Antlr4.StringTemplate
protected bool alreadyLoaded = false;

/** Load a file relative to current dir or from root or via CLASSPATH. */
-        public STGroupFile(string fileName)
+        public TemplateGroupFile(string fileName)
: this(fileName, '<', '>')
{
}

-        public STGroupFile(string fileName, char delimiterStartChar, char delimiterStopChar)
+        public TemplateGroupFile(string fileName, char delimiterStartChar, char delimiterStopChar)
: base(delimiterStartChar, delimiterStopChar)
{
if (!fileName.EndsWith(".stg"))
@@ -100,18 +100,18 @@ namespace Antlr4.StringTemplate
this.fileName = fileName;
}

-        public STGroupFile(string fullyQualifiedFileName, Encoding encoding)
+        public TemplateGroupFile(string fullyQualifiedFileName, Encoding encoding)
: this(fullyQualifiedFileName, encoding, '<', '>')
{
}

-        public STGroupFile(string fullyQualifiedFileName, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+        public TemplateGroupFile(string fullyQualifiedFileName, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
: this(fullyQualifiedFileName, delimiterStartChar, delimiterStopChar)
{
this.encoding = encoding;
}

-        public STGroupFile(Uri url, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
+        public TemplateGroupFile(Uri url, Encoding encoding, char delimiterStartChar, char delimiterStopChar)
: base(delimiterStartChar, delimiterStopChar)
{
this.url = url;
@@ -132,12 +132,12 @@ namespace Antlr4.StringTemplate
alreadyLoaded = false;
}

-        protected override CompiledST load(string name)
+        protected override CompiledTemplate load(string name)
{
if (!alreadyLoaded)
load();

-            CompiledST template;
+            CompiledTemplate template;
templates.TryGetValue(name, out template);
return template;
}
diff --git a/Antlr4.Test.StringTemplate/BaseTest.cs b/Antlr4.Test.StringTemplate/BaseTest.cs
index a029e21..498ef44 100644
--- a/Antlr4.Test.StringTemplate/BaseTest.cs
+++ b/Antlr4.Test.StringTemplate/BaseTest.cs
@@ -64,9 +64,9 @@ namespace Antlr4.Test.StringTemplate

protected virtual void setUpImpl()
{
-            STGroup.defaultGroup = new STGroup();
-            Compiler.subtemplateCount = 0;
-            STGroup.debug = false;
+            TemplateGroup.defaultGroup = new TemplateGroup();
+            TemplateCompiler.subtemplateCount = 0;
+            TemplateGroup.debug = false;

// new output dir for each test
tmpdir = Path.GetFullPath(Path.Combine(Path.GetTempPath(), "st4-" + currentTimeMillis()));
@@ -112,8 +112,8 @@ namespace Antlr4.Test.StringTemplate

public void checkTokens(string template, string expected, char delimiterStartChar, char delimiterStopChar)
{
-            STLexer lexer =
-                new STLexer(STGroup.DefaultErrorManager,
+            TemplateLexer lexer =
+                new TemplateLexer(TemplateGroup.DefaultErrorManager,
new ANTLRStringStream(template),
null,
delimiterStartChar,
diff --git a/Antlr4.Test.StringTemplate/ErrorBufferAllErrors.cs b/Antlr4.Test.StringTemplate/ErrorBufferAllErrors.cs
index bf2c033..60072a5 100644
--- a/Antlr4.Test.StringTemplate/ErrorBufferAllErrors.cs
+++ b/Antlr4.Test.StringTemplate/ErrorBufferAllErrors.cs
@@ -38,7 +38,7 @@ namespace Antlr4.Test.StringTemplate

public class ErrorBufferAllErrors : ErrorBuffer
{
-        public override void runTimeError(STMessage msg)
+        public override void runTimeError(TemplateMessage msg)
{
ErrorList.Add(msg);
}
diff --git a/Antlr4.Test.StringTemplate/Extensions/ListExtensions.cs b/Antlr4.Test.StringTemplate/Extensions/ListExtensions.cs
index 0b29ddb..7a220eb 100644
--- a/Antlr4.Test.StringTemplate/Extensions/ListExtensions.cs
+++ b/Antlr4.Test.StringTemplate/Extensions/ListExtensions.cs
@@ -44,10 +44,10 @@ namespace Antlr4.Test.StringTemplate.Extensions
{
public static string ToListString(this IList list)
{
-            STGroup group = new STGroup('$', '$');
+            TemplateGroup group = new TemplateGroup('$', '$');
group.defineTemplate("listTemplate", "list", "[$list:{x|$x$}; separator=\", \"$]");
group.registerRenderer(typeof(IList), new CollectionRenderer());
-            ST st = group.getInstanceOf("listTemplate");
+            Template st = group.getInstanceOf("listTemplate");
st.add("list", list);
return st.render();
}
diff --git a/Antlr4.Test.StringTemplate/TestCompiler.cs b/Antlr4.Test.StringTemplate/TestCompiler.cs
index de0d7d9..c5e68ec 100644
--- a/Antlr4.Test.StringTemplate/TestCompiler.cs
+++ b/Antlr4.Test.StringTemplate/TestCompiler.cs
@@ -43,7 +43,7 @@ namespace Antlr4.Test.StringTemplate
{
protected override void setUpImpl()
{
-            Compiler.subtemplateCount = 0;
+            TemplateCompiler.subtemplateCount = 0;
base.setUpImpl();
}

@@ -51,7 +51,7 @@ namespace Antlr4.Test.StringTemplate
public void TestAttr()
{
string template = "hi <name>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -68,7 +68,7 @@ namespace Antlr4.Test.StringTemplate
public void TestInclude()
{
string template = "hi <foo()>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, write, new 1 0, write";
string asmResult = code.Instrs();
@@ -82,7 +82,7 @@ namespace Antlr4.Test.StringTemplate
public void TestSuperInclude()
{
string template = "<super.foo()>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"super_new 0 0, write";
code.dump();
@@ -97,7 +97,7 @@ namespace Antlr4.Test.StringTemplate
public void TestSuperIncludeWithArgs()
{
string template = "<super.foo(a,{b})>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, new 1 0, super_new 2 2, write";
string asmResult = code.Instrs();
@@ -111,7 +111,7 @@ namespace Antlr4.Test.StringTemplate
public void TestSuperIncludeWithNamedArgs()
{
string template = "<super.foo(x=a,y={b})>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"args, load_attr 0, store_arg 1, new 2 0, store_arg 3, super_new_box_args 4, write";
string asmResult = code.Instrs();
@@ -125,7 +125,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIncludeWithArgs()
{
string template = "hi <foo(a,b)>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, write, load_attr 1, load_attr 2, new 3 2, write";
string asmResult = code.Instrs();
@@ -139,7 +139,7 @@ namespace Antlr4.Test.StringTemplate
public void TestAnonIncludeArgs()
{
string template = "<({ a, b | <a><b>})>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"new 0 0, tostr, write";
string asmResult = code.Instrs();
@@ -154,7 +154,7 @@ namespace Antlr4.Test.StringTemplate
{
ITemplateErrorListener errors = new ErrorBuffer();
string template = "<a:{foo}>";
-            CompiledST code = new Compiler(new ErrorManager(errors)).compile(template);
+            CompiledTemplate code = new TemplateCompiler(new ErrorManager(errors)).compile(template);
string expected = "1:3: anonymous template has 0 arg(s) but mapped across 1 value(s)" + newline;
Assert.AreEqual(expected, errors.ToString());
}
@@ -164,7 +164,7 @@ namespace Antlr4.Test.StringTemplate
{
ITemplateErrorListener errors = new ErrorBuffer();
string template = "<a,b:{x|foo}>";
-            CompiledST code = new Compiler(new ErrorManager(errors)).compile(template);
+            CompiledTemplate code = new TemplateCompiler(new ErrorManager(errors)).compile(template);
string expected = "1:5: anonymous template has 1 arg(s) but mapped across 2 value(s)" + newline;
Assert.AreEqual(expected, errors.ToString());
}
@@ -174,7 +174,7 @@ namespace Antlr4.Test.StringTemplate
{
ITemplateErrorListener errors = new ErrorBuffer();
string template = "<a:{x|foo},{bar}>";
-            CompiledST code = new Compiler(new ErrorManager(errors)).compile(template);
+            CompiledTemplate code = new TemplateCompiler(new ErrorManager(errors)).compile(template);
string expected = "1:11: anonymous template has 0 arg(s) but mapped across 1 value(s)" + newline;
Assert.AreEqual(expected, errors.ToString());
}
@@ -183,7 +183,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIndirectIncludeWitArgs()
{
string template = "hi <(foo)(a,b)>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, write, load_attr 1, tostr, load_attr 2, load_attr 3, new_ind 2, write";
string asmResult = code.Instrs();
@@ -197,7 +197,7 @@ namespace Antlr4.Test.StringTemplate
public void TestProp()
{
string template = "hi <a.b>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, write, load_attr 1, load_prop 2, write";
string asmResult = code.Instrs();
@@ -211,7 +211,7 @@ namespace Antlr4.Test.StringTemplate
public void TestProp2()
{
string template = "<u.id>: <u.name>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, load_prop 1, write, load_str 2, write, " +
"load_attr 0, load_prop 3, write";
@@ -226,7 +226,7 @@ namespace Antlr4.Test.StringTemplate
public void TestMap()
{
string template = "<name:bold()>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, null, new 1 1, map, write";
string asmResult = code.Instrs();
@@ -240,7 +240,7 @@ namespace Antlr4.Test.StringTemplate
public void TestMapAsOption()
{
string template = "<a; wrap=name:bold()>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, options, load_attr 1, null, new 2 1, map, " +
"store_option 4, write_opt";
@@ -255,7 +255,7 @@ namespace Antlr4.Test.StringTemplate
public void TestMapArg()
{
string template = "<name:bold(x)>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, null, load_attr 1, new 2 2, map, write";
string asmResult = code.Instrs();
@@ -269,7 +269,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIndirectMapArg()
{
string template = "<name:(t)(x)>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, load_attr 1, tostr, null, load_attr 2, new_ind 2, map, write";
string asmResult = code.Instrs();
@@ -283,7 +283,7 @@ namespace Antlr4.Test.StringTemplate
public void TestRepeatedMap()
{
string template = "<name:bold():italics()>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, null, new 1 1, map, null, new 2 1, map, write";
string asmResult = code.Instrs();
@@ -297,7 +297,7 @@ namespace Antlr4.Test.StringTemplate
public void TestRepeatedMapArg()
{
string template = "<name:bold(x):italics(x,y)>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, null, load_attr 1, new 2 2, map, " +
"null, load_attr 1, load_attr 3, new 4 3, map, write";
@@ -312,7 +312,7 @@ namespace Antlr4.Test.StringTemplate
public void TestRotMap()
{
string template = "<name:bold(),italics()>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, null, new 1 1, null, new 2 1, rot_map 2, write";
string asmResult = code.Instrs();
@@ -326,7 +326,7 @@ namespace Antlr4.Test.StringTemplate
public void TestRotMapArg()
{
string template = "<name:bold(x),italics()>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, null, load_attr 1, new 2 2, null, new 3 1, rot_map 2, write";
string asmResult = code.Instrs();
@@ -340,7 +340,7 @@ namespace Antlr4.Test.StringTemplate
public void TestZipMap()
{
string template = "<names,phones:bold()>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, load_attr 1, null, null, new 2 2, zip_map 2, write";
string asmResult = code.Instrs();
@@ -354,7 +354,7 @@ namespace Antlr4.Test.StringTemplate
public void TestZipMapArg()
{
string template = "<names,phones:bold(x)>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, load_attr 1, null, null, load_attr 2, new 3 3, zip_map 2, write";
string asmResult = code.Instrs();
@@ -368,7 +368,7 @@ namespace Antlr4.Test.StringTemplate
public void TestAnonMap()
{
string template = "<name:{n | <n>}>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, null, new 1 1, map, write";
string asmResult = code.Instrs();
@@ -382,7 +382,7 @@ namespace Antlr4.Test.StringTemplate
public void TestAnonZipMap()
{
string template = "<a,b:{x,y | <x><y>}>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_attr 0, load_attr 1, null, null, new 2 2, zip_map 2, write";
string asmResult = code.Instrs();
@@ -396,7 +396,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIf()
{
string template = "go: <if(name)>hi, foo<endif>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, write, load_attr 1, brf 14, load_str 2, write";
string asmResult = code.Instrs();
@@ -410,7 +410,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIfElse()
{
string template = "go: <if(name)>hi, foo<else>bye<endif>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -432,7 +432,7 @@ namespace Antlr4.Test.StringTemplate
public void TestElseIf()
{
string template = "go: <if(name)>hi, foo<elseif(user)>a user<endif>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -456,7 +456,7 @@ namespace Antlr4.Test.StringTemplate
public void TestElseIfElse()
{
string template = "go: <if(name)>hi, foo<elseif(user)>a user<else>bye<endif>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -483,7 +483,7 @@ namespace Antlr4.Test.StringTemplate
public void TestOption()
{
string template = "hi <name; separator=\"x\">";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, write, load_attr 1, options, load_str 2, store_option 3, write_opt";
string asmResult = code.Instrs();
@@ -497,7 +497,7 @@ namespace Antlr4.Test.StringTemplate
public void TestOptionAsTemplate()
{
string template = "hi <name; separator={, }>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, write, load_attr 1, options, new 2 0, store_option 3, write_opt";
string asmResult = code.Instrs();
@@ -511,7 +511,7 @@ namespace Antlr4.Test.StringTemplate
public void TestOptions()
{
string template = "hi <name; anchor, wrap=foo(), separator=\", \">";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected =
"load_str 0, " +
"write, " +
@@ -536,7 +536,7 @@ namespace Antlr4.Test.StringTemplate
public void TestEmptyList()
{
string template = "<[]>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected = "list, write";
string asmResult = code.Instrs();
Assert.AreEqual(asmExpected, asmResult);
@@ -549,7 +549,7 @@ namespace Antlr4.Test.StringTemplate
public void TestList()
{
string template = "<[a,b]>";
-            CompiledST code = new Compiler().compile(template);
+            CompiledTemplate code = new TemplateCompiler().compile(template);
string asmExpected = "list, load_attr 0, add, load_attr 1, add, write";
string asmResult = code.Instrs();
Assert.AreEqual(asmExpected, asmResult);
@@ -563,7 +563,7 @@ namespace Antlr4.Test.StringTemplate
{
string template = "<@r>foo<@end>";
// compile as if in root dir and in template 'a'
-            CompiledST code = new Compiler('<', '>').compile("a", template);
+            CompiledTemplate code = new TemplateCompiler('<', '>').compile("a", template);
string asmExpected =
"new 0 0, write";
string asmResult = code.Instrs();
@@ -578,7 +578,7 @@ namespace Antlr4.Test.StringTemplate
{
string template = "x:<@r()>";
// compile as if in root dir and in template 'a'
-            CompiledST code = new Compiler('<', '>').compile("a", template);
+            CompiledTemplate code = new TemplateCompiler('<', '>').compile("a", template);
string asmExpected =
"load_str 0, write, new 1 0, write";
string asmResult = code.Instrs();
diff --git a/Antlr4.Test.StringTemplate/TestCoreBasics.cs b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
index 5a7d3b8..a38d78f 100644
--- a/Antlr4.Test.StringTemplate/TestCoreBasics.cs
+++ b/Antlr4.Test.StringTemplate/TestCoreBasics.cs
@@ -46,7 +46,7 @@ namespace Antlr4.Test.StringTemplate
public void TestNullAttr()
{
string template = "hi <name>!";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected =
"hi !";
string result = st.render();
@@ -57,7 +57,7 @@ namespace Antlr4.Test.StringTemplate
public void TestAttr()
{
string template = "hi <name>!";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "hi Ter!";
string result = st.render();
@@ -71,9 +71,9 @@ namespace Antlr4.Test.StringTemplate
"t() ::= <<hi <name>!>>\n";
ErrorBuffer errors = new ErrorBuffer();
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
string result = null;
try
{
@@ -91,7 +91,7 @@ namespace Antlr4.Test.StringTemplate
public void TestMultiAttr()
{
string template = "hi <name>!";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
st.add("name", "Tom");
string expected =
@@ -104,12 +104,12 @@ namespace Antlr4.Test.StringTemplate
public void TestAttrIsList()
{
string template = "hi <name>!";
-            ST st = new ST(template);
+            Template st = new Template(template);
List<string> names = new List<string>() { "Ter", "Tom" };
st.add("name", names);
st.add("name", "Sumana"); // shouldn't alter my version of names list!
string expected =
-                "hi TerTomSumana!";  // ST sees 3 names
+                "hi TerTomSumana!";  // Template sees 3 names
string result = st.render();
Assert.AreEqual(expected, result);

@@ -120,12 +120,12 @@ namespace Antlr4.Test.StringTemplate
public void TestAttrIsArray()
{
string template = "hi <name>!";
-            ST st = new ST(template);
+            Template st = new Template(template);
string[] names = new string[] { "Ter", "Tom" };
st.add("name", names);
st.add("name", "Sumana"); // shouldn't alter my version of names list!
string expected =
-                "hi TerTomSumana!";  // ST sees 3 names
+                "hi TerTomSumana!";  // Template sees 3 names
string result = st.render();
Assert.AreEqual(expected, result);
}
@@ -134,7 +134,7 @@ namespace Antlr4.Test.StringTemplate
public void TestProp()
{
string template = "<u.id>: <u.name>"; // checks field and method getter
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("u", new User(1, "parrt"));
string expected = "1: parrt";
string result = st.render();
@@ -145,7 +145,7 @@ namespace Antlr4.Test.StringTemplate
public void TestPropWithNoAttr()
{
string template = "<foo.a>: <ick>"; // checks field and method getter
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("foo", new Dictionary<string, string>() { { "a", "b" } });
string expected = "b: ";
string result = st.render();
@@ -156,8 +156,8 @@ namespace Antlr4.Test.StringTemplate
public void TestSTProp()
{
string template = "<t.x>"; // get x attr of template t
-            ST st = new ST(template);
-            ST t = new ST("<x>");
+            Template st = new Template(template);
+            Template t = new Template("<x>");
t.add("x", "Ter");
st.add("t", t);
string expected = "Ter";
@@ -169,7 +169,7 @@ namespace Antlr4.Test.StringTemplate
public void TestBooleanISProp()
{
string template = "<t.isManager>"; // call isManager
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("t", new User(32, "Ter"));
string expected = true.ToString();
string result = st.render();
@@ -180,7 +180,7 @@ namespace Antlr4.Test.StringTemplate
public void TestBooleanHASProp()
{
string template = "<t.hasParkingSpot>"; // call hasParkingSpot
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("t", new User(32, "Ter"));
string expected = true.ToString();
string result = st.render();
@@ -191,7 +191,7 @@ namespace Antlr4.Test.StringTemplate
public void TestNullAttrProp()
{
string template = "<u.id>: <u.name>";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected = ": ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -202,15 +202,15 @@ namespace Antlr4.Test.StringTemplate
{
ErrorBufferAllErrors errors = new ErrorBufferAllErrors();
string template = "<u.qqq>";
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.setListener(errors);
-            ST st = new ST(group, template);
+            Template st = new Template(group, template);
st.add("u", new User(1, "parrt"));
string expected = "";
string result = st.render();
Assert.AreEqual(expected, result);
-            STRuntimeMessage msg = (STRuntimeMessage)errors.Errors[0];
-            STNoSuchPropertyException e = (STNoSuchPropertyException)msg.Cause;
+            TemplateRuntimeMessage msg = (TemplateRuntimeMessage)errors.Errors[0];
+            TemplateNoSuchPropertyException e = (TemplateNoSuchPropertyException)msg.Cause;
Assert.AreEqual("Antlr4.Test.StringTemplate.BaseTest+User.qqq", e.PropertyName);
}

@@ -218,17 +218,17 @@ namespace Antlr4.Test.StringTemplate
public void TestNullIndirectProp()
{
ErrorBufferAllErrors errors = new ErrorBufferAllErrors();
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.setListener(errors);
string template = "<u.(qqq)>";
-            ST st = new ST(group, template);
+            Template st = new Template(group, template);
st.add("u", new User(1, "parrt"));
st.add("qqq", null);
string expected = "";
string result = st.render();
Assert.AreEqual(expected, result);
-            STRuntimeMessage msg = (STRuntimeMessage)errors.Errors[0];
-            STNoSuchPropertyException e = (STNoSuchPropertyException)msg.Cause;
+            TemplateRuntimeMessage msg = (TemplateRuntimeMessage)errors.Errors[0];
+            TemplateNoSuchPropertyException e = (TemplateNoSuchPropertyException)msg.Cause;
Assert.AreEqual("Antlr4.Test.StringTemplate.BaseTest+User.null", e.PropertyName);
}

@@ -236,17 +236,17 @@ namespace Antlr4.Test.StringTemplate
public void TestPropConvertsToString()
{
ErrorBufferAllErrors errors = new ErrorBufferAllErrors();
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.setListener(errors);
string template = "<u.(name)>";
-            ST st = new ST(group, template);
+            Template st = new Template(group, template);
st.add("u", new User(1, "parrt"));
st.add("name", 100);
string expected = "";
string result = st.render();
Assert.AreEqual(expected, result);
-            STRuntimeMessage msg = (STRuntimeMessage)errors.Errors[0];
-            STNoSuchPropertyException e = (STNoSuchPropertyException)msg.Cause;
+            TemplateRuntimeMessage msg = (TemplateRuntimeMessage)errors.Errors[0];
+            TemplateNoSuchPropertyException e = (TemplateNoSuchPropertyException)msg.Cause;
Assert.AreEqual("Antlr4.Test.StringTemplate.BaseTest+User.100", e.PropertyName);
}

@@ -254,7 +254,7 @@ namespace Antlr4.Test.StringTemplate
public void TestInclude()
{
string template = "load <box()>;";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.impl.nativeGroup.defineTemplate("box", "kewl\ndaddy");
string expected =
"load kewl" + newline +
@@ -267,7 +267,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIncludeWithArg()
{
string template = "load <box(\"arg\")>;";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.impl.nativeGroup.defineTemplate("box", "x", "kewl <x> daddy");
st.impl.dump();
st.add("name", "Ter");
@@ -280,7 +280,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIncludeWithArg2()
{
string template = "load <box(\"arg\", foo())>;";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.impl.nativeGroup.defineTemplate("box", "x,y", "kewl <x> <y> daddy");
st.impl.nativeGroup.defineTemplate("foo", "blech");
st.add("name", "Ter");
@@ -293,7 +293,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIncludeWithNestedArgs()
{
string template = "load <box(foo(\"arg\"))>;";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.impl.nativeGroup.defineTemplate("box", "y", "kewl <y> daddy");
st.impl.nativeGroup.defineTemplate("foo", "x", "blech <x>");
st.add("name", "Ter");
@@ -305,10 +305,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestDefineTemplate()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("inc", "x", "<x>+1");
group.defineTemplate("test", "name", "hi <name>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", "Sumana");
@@ -321,10 +321,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMap()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("inc", "x", "[<x>]");
group.defineTemplate("test", "name", "hi <name:inc()>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", "Sumana");
@@ -337,10 +337,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIndirectMap()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("inc", "x", "[<x>]");
group.defineTemplate("test", "t,name", "<name:(t)()>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("t", "inc");
st.add("name", "Ter");
st.add("name", "Tom");
@@ -359,8 +359,8 @@ namespace Antlr4.Test.StringTemplate
"test(name) ::= \"<name:(d.foo)()>\"\n" +
"bold(x) ::= <<*<x>*>>\n";
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ST st = group.getInstanceOf("test");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", "Sumana");
@@ -372,9 +372,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelMap()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names,phones", "hi <names,phones:{n,p | <n>:<p>;}>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -390,9 +390,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelMapWith3Versus2Elements()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names,phones", "hi <names,phones:{n,p | <n>:<p>;}>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -407,11 +407,11 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelMapThenMap()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("bold", "x", "[<x>]");
group.defineTemplate("test", "names,phones",
"hi <names,phones:{n,p | <n>:<p>;}:bold()>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -426,11 +426,11 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMapThenParallelMap()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("bold", "x", "[<x>]");
group.defineTemplate("test", "names,phones",
"hi <[names:bold()],phones:{n,p | <n>:<p>;}>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -445,10 +445,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMapIndexes()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("inc", "x,i", "<i>:<x>");
group.defineTemplate("test", "name", "<name:{n|<inc(n,i)>}; separator=\", \">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", null); // don't count this one
@@ -462,9 +462,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMapIndexes2()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name:{n | <i>:<n>}; separator=\", \">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", null); // don't count this one. still can't apply subtemplate to null value
@@ -478,10 +478,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMapSingleValue()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("a", "x", "[<x>]");
group.defineTemplate("test", "name", "hi <name:a()>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
string expected = "hi [Ter]!";
string result = st.render();
@@ -491,10 +491,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMapNullValue()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("a", "x", "[<x>]");
group.defineTemplate("test", "name", "hi <name:a()>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
string expected = "hi !";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -503,9 +503,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMapNullValueInList()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name; separator=\", \">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", null); // don't print this one
@@ -519,11 +519,11 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestRepeatedMap()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("a", "x", "[<x>]");
group.defineTemplate("b", "x", "(<x>)");
group.defineTemplate("test", "name", "hi <name:a():b()>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", "Sumana");
@@ -536,11 +536,11 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestRoundRobinMap()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("a", "x", "[<x>]");
group.defineTemplate("b", "x", "(<x>)");
group.defineTemplate("test", "name", "hi <name:a(),b()>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", "Sumana");
@@ -554,7 +554,7 @@ namespace Antlr4.Test.StringTemplate
public void TestTrueCond()
{
string template = "<if(name)>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "works";
string result = st.render();
@@ -565,7 +565,7 @@ namespace Antlr4.Test.StringTemplate
public void TestEmptyIFTemplate()
{
string template = "<if(x)>fail<elseif(name)><endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "";
string result = st.render();
@@ -576,7 +576,7 @@ namespace Antlr4.Test.StringTemplate
public void TestCondParens()
{
string template = "<if(!(x||y)&&!z)>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected = "works";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -586,7 +586,7 @@ namespace Antlr4.Test.StringTemplate
public void TestFalseCond()
{
string template = "<if(name)>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected = "";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -596,7 +596,7 @@ namespace Antlr4.Test.StringTemplate
public void TestFalseCond2()
{
string template = "<if(name)>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", null);
string expected = "";
string result = st.render();
@@ -615,8 +615,8 @@ namespace Antlr4.Test.StringTemplate
"bar\n" +
">>\n";
writeFile(dir, "group.stg", groupFile);
-            STGroupFile group = new STGroupFile(dir + "/group.stg");
-            ST st = group.getInstanceOf("a");
+            TemplateGroupFile group = new TemplateGroupFile(dir + "/group.stg");
+            Template st = group.getInstanceOf("a");
st.impl.dump();
string expected = "foo" + newline +
"bar";
@@ -629,7 +629,7 @@ namespace Antlr4.Test.StringTemplate
{
string template =
"<if(x)>fail1<elseif(y)>fail2<elseif(z)>works<else>fail3<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("z", "blort");
string expected = "works";
string result = st.render();
@@ -641,7 +641,7 @@ namespace Antlr4.Test.StringTemplate
{
string template =
"<if(x)><elseif(y)><elseif(z)>works<else><endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("z", "blort");
string expected = "works";
string result = st.render();
@@ -652,7 +652,7 @@ namespace Antlr4.Test.StringTemplate
public void TestNotTrueCond()
{
string template = "<if(!name)>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "";
string result = st.render();
@@ -663,7 +663,7 @@ namespace Antlr4.Test.StringTemplate
public void TestNotFalseCond()
{
string template = "<if(!name)>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected = "works";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -673,7 +673,7 @@ namespace Antlr4.Test.StringTemplate
public void TestTrueCondWithElse()
{
string template = "<if(name)>works<else>fail<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "works";
string result = st.render();
@@ -684,7 +684,7 @@ namespace Antlr4.Test.StringTemplate
public void TestFalseCondWithElse()
{
string template = "<if(name)>fail<else>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected = "works";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -694,7 +694,7 @@ namespace Antlr4.Test.StringTemplate
public void TestElseIf()
{
string template = "<if(name)>fail<elseif(id)>works<else>fail<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("id", "2DF3DF");
string expected = "works";
string result = st.render();
@@ -705,7 +705,7 @@ namespace Antlr4.Test.StringTemplate
public void TestElseIfNoElseAllFalse()
{
string template = "<if(name)>fail<elseif(id)>fail<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected = "";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -715,7 +715,7 @@ namespace Antlr4.Test.StringTemplate
public void TestElseIfAllExprFalse()
{
string template = "<if(name)>fail<elseif(id)>fail<else>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected = "works";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -725,7 +725,7 @@ namespace Antlr4.Test.StringTemplate
public void TestOr()
{
string template = "<if(name||notThere)>works<else>fail<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "works";
string result = st.render();
@@ -736,7 +736,7 @@ namespace Antlr4.Test.StringTemplate
public void TestMapConditionAndEscapeInside()
{
string template = "<if(m.name)>works \\\\<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
IDictionary<string, string> m = new Dictionary<string, string>();
m["name"] = "Ter";
st.add("m", m);
@@ -749,7 +749,7 @@ namespace Antlr4.Test.StringTemplate
public void TestAnd()
{
string template = "<if(name&&notThere)>fail<else>works<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "works";
string result = st.render();
@@ -760,7 +760,7 @@ namespace Antlr4.Test.StringTemplate
public void TestAndNot()
{
string template = "<if(name&&!notThere)>works<else>fail<endif>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "works";
string result = st.render();
@@ -770,7 +770,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestCharLiterals()
{
-            ST st = new ST(
+            Template st = new Template(
"Foo <\\n><\\n><\\t> bar\n"
);
StringWriter sw = new StringWriter();
@@ -779,7 +779,7 @@ namespace Antlr4.Test.StringTemplate
string expecting = "Foo \n\n\t bar\n";     // expect \n in output
Assert.AreEqual(expecting, result);

-            st = new ST(
+            st = new Template(
"Foo <\\n><\\t> bar" + newline);
sw = new StringWriter();
st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
@@ -787,7 +787,7 @@ namespace Antlr4.Test.StringTemplate
result = sw.ToString();
Assert.AreEqual(expecting, result);

-            st = new ST(
+            st = new Template(
"Foo<\\ >bar<\\n>");
sw = new StringWriter();
st.write(new AutoIndentWriter(sw, "\n")); // force \n as newline
@@ -799,20 +799,20 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestUnicodeLiterals()
{
-            ST st = new ST(
+            Template st = new Template(
"Foo <\\uFEA5><\\n><\\u00C2> bar\n"
);
string expecting = "Foo \ufea5" + newline + "\u00C2 bar" + newline;
string result = st.render();
Assert.AreEqual(expecting, result);

-            st = new ST(
+            st = new Template(
"Foo <\\uFEA5><\\n><\\u00C2> bar" + newline);
expecting = "Foo \ufea5" + newline + "\u00C2 bar" + newline;
result = st.render();
Assert.AreEqual(expecting, result);

-            st = new ST(
+            st = new Template(
"Foo<\\ >bar<\\n>");
expecting = "Foo bar" + newline;
result = st.render();
@@ -823,7 +823,7 @@ namespace Antlr4.Test.StringTemplate
public void TestSubtemplateExpr()
{
string template = "<{name\n}>";
-            ST st = new ST(template);
+            Template st = new Template(template);
string expected =
"name" + newline;
string result = st.render();
@@ -833,9 +833,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparator()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{n | case <n>}; separator=\", \">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
string expected =
@@ -847,9 +847,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparatorInList()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{n | case <n>}; separator=\", \">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", new List<string>() { "Ter", "Tom" });
string expected =
"case Ter, case Tom";
@@ -861,7 +861,7 @@ namespace Antlr4.Test.StringTemplate
public void Playing()
{
string template = "<a:t(x,y),u()>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.impl.dump();
}
}
diff --git a/Antlr4.Test.StringTemplate/TestDebugEvents.cs b/Antlr4.Test.StringTemplate/TestDebugEvents.cs
index 9bf4276..a89cfe0 100644
--- a/Antlr4.Test.StringTemplate/TestDebugEvents.cs
+++ b/Antlr4.Test.StringTemplate/TestDebugEvents.cs
@@ -49,8 +49,8 @@ namespace Antlr4.Test.StringTemplate
"t() ::= <<foo>>" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            STGroup.debug = true;
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup.debug = true;
DebugST st = (DebugST)group.getInstanceOf("t");
List<InterpEvent> events = st.getEvents();
string expected =
@@ -67,8 +67,8 @@ namespace Antlr4.Test.StringTemplate
"t(x) ::= << <x> >>" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            STGroup.debug = true;
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup.debug = true;
DebugST st = (DebugST)group.getInstanceOf("t");
List<InterpEvent> events = st.getEvents();
string expected =
@@ -87,8 +87,8 @@ namespace Antlr4.Test.StringTemplate
"u() ::= << <x> >>\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            STGroup.debug = true;
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup.debug = true;
DebugST st = (DebugST)group.getInstanceOf("t");
List<InterpEvent> events = st.getEvents();
string expected =
diff --git a/Antlr4.Test.StringTemplate/TestDictionaries.cs b/Antlr4.Test.StringTemplate/TestDictionaries.cs
index 072a46d..e60273c 100644
--- a/Antlr4.Test.StringTemplate/TestDictionaries.cs
+++ b/Antlr4.Test.StringTemplate/TestDictionaries.cs
@@ -49,8 +49,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("type", "int");
st.add("name", "x");
string expecting = "int x = 0;";
@@ -66,8 +66,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.impl.dump();
st.add("w", "L");
st.add("type", "int");
@@ -86,10 +86,10 @@ namespace Antlr4.Test.StringTemplate
"var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("w", "L");
-            st.add("type", new ST("int"));
+            st.add("type", new Template("int"));
st.add("name", "x");
string expecting = "int x = 0L;";
string result = st.render();
@@ -104,8 +104,8 @@ namespace Antlr4.Test.StringTemplate
"foo(m,k) ::= \"<m.(k)>\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("foo");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("foo");
IDictionary<HashableUser, string> m = new Dictionary<HashableUser, string>();
m[new HashableUser(99, "parrt")] = "first";
m[new HashableUser(172036, "tombu")] = "second";
@@ -125,8 +125,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("w", "L");
st.add("type", "double"); // double not in typeInit map
st.add("name", "x");
@@ -143,8 +143,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,w,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("w", "L");
st.add("type", null); // double not in typeInit map
st.add("name", "x");
@@ -161,8 +161,8 @@ namespace Antlr4.Test.StringTemplate
"var(typeInit,type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("type", "int");
st.add("name", "x");
string expecting = "int x = ;";
@@ -178,8 +178,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("type", "float");
st.add("name", "x");
string expecting = "float x = ;";
@@ -195,8 +195,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("type", "UserRecord");
st.add("name", "x");
string expecting = "UserRecord x = null;";
@@ -212,8 +212,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
// missing or set to null: st.add("type", null);
st.add("name", "x");
string expecting = " x = null;";
@@ -230,7 +230,7 @@ namespace Antlr4.Test.StringTemplate
;
writeFile(tmpdir, "test.stg", templates);
ErrorBuffer errors = new ErrorBuffer();
-            STGroupFile group = new STGroupFile(tmpdir + "/" + "test.stg");
+            TemplateGroupFile group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
group.setListener(errors);
group.load();
string expected = "[test.stg 1:33: missing value for key at ']']";
@@ -246,8 +246,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("type", "UserRecord");
st.add("name", "x");
string expecting = "UserRecord x = UserRecord;";
@@ -266,8 +266,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("var");
st.add("type", "default");
st.add("name", "x");
string expecting = "default x = foo;";
@@ -286,8 +286,8 @@ namespace Antlr4.Test.StringTemplate
"t() ::= << <map.(\"1\")> >>" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("t");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("t");
string expecting = " default ";
string result = st.render();
Assert.AreEqual(expecting, result);
@@ -302,8 +302,8 @@ namespace Antlr4.Test.StringTemplate
"var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST st = group.getInstanceOf("intermediate");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template st = group.getInstanceOf("intermediate");
st.add("type", "int");
st.add("name", "x");
string expecting = "int x = 0;";
@@ -320,9 +320,9 @@ namespace Antlr4.Test.StringTemplate
"var(type,name) ::= \"<type> <name> = <typeInit.(type)>;\"" + newline
;
writeFile(tmpdir, "test.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "test.stg");
-            ST interm = group.getInstanceOf("intermediate");
-            ST var = group.getInstanceOf("var");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "test.stg");
+            Template interm = group.getInstanceOf("intermediate");
+            Template var = group.getInstanceOf("var");
var.add("type", "int");
var.add("name", "x");
interm.add("stuff", var);
diff --git a/Antlr4.Test.StringTemplate/TestDollarDelimiters.cs b/Antlr4.Test.StringTemplate/TestDollarDelimiters.cs
index 25bcacf..77a8dbb 100644
--- a/Antlr4.Test.StringTemplate/TestDollarDelimiters.cs
+++ b/Antlr4.Test.StringTemplate/TestDollarDelimiters.cs
@@ -42,7 +42,7 @@ namespace Antlr4.Test.StringTemplate
public void TestAttr()
{
string template = "hi $name$!";
-            ST st = new ST(template, '$', '$');
+            Template st = new Template(template, '$', '$');
st.add("name", "Ter");
string expected = "hi Ter!";
string result = st.render();
@@ -52,9 +52,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelMap()
{
-            STGroup group = new STGroup('$', '$');
+            TemplateGroup group = new TemplateGroup('$', '$');
group.defineTemplate("test", "names,phones", "hi $names,phones:{n,p | $n$:$p$;}$");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -75,8 +75,8 @@ namespace Antlr4.Test.StringTemplate
string b = "b() ::= <<bar>>\n";
writeFile(dir, "a.st", a);
writeFile(dir, "b.st", b);
-            STGroup group = new STGroupDir(dir, '$', '$');
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupDirectory(dir, '$', '$');
+            Template st = group.getInstanceOf("a");
string expected = " bar ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -92,8 +92,8 @@ namespace Antlr4.Test.StringTemplate
"stat(name,value=\"99\") ::= \"x=$value$; // $name$\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg", '$', '$');
-            ST b = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg", '$', '$');
+            Template b = group.getInstanceOf("method");
b.add("name", "foo");
string expecting = "x=99; // foo";
string result = b.render();
diff --git a/Antlr4.Test.StringTemplate/TestFunctions.cs b/Antlr4.Test.StringTemplate/TestFunctions.cs
index 26124d7..7e0ecb5 100644
--- a/Antlr4.Test.StringTemplate/TestFunctions.cs
+++ b/Antlr4.Test.StringTemplate/TestFunctions.cs
@@ -43,7 +43,7 @@ namespace Antlr4.Test.StringTemplate
public void TestFirst()
{
string template = "<first(names)>";
-            ST st = new ST(template);
+            Template st = new Template(template);
List<string> names = new List<string>() { "Ter", "Tom" };
st.add("names", names);
string expected = "Ter";
@@ -55,7 +55,7 @@ namespace Antlr4.Test.StringTemplate
public void TestLength()
{
string template = "<length(names)>";
-            ST st = new ST(template);
+            Template st = new Template(template);
List<string> names = new List<string>() { "Ter", "Tom" };
st.add("names", names);
string expected = "2";
@@ -67,7 +67,7 @@ namespace Antlr4.Test.StringTemplate
public void TestLengthWithNullValues()
{
string template = "<length(names)>";
-            ST st = new ST(template);
+            Template st = new Template(template);
List<string> names = new List<string>() { "Ter", null, "Tom", null };
st.add("names", names);
string expected = "4";
@@ -78,7 +78,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestFirstOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<first(names)>"
);
e.add("names", "Ter");
@@ -91,7 +91,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTruncOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<trunc(names); separator=\", \">"
);
e.add("names", "Ter");
@@ -104,7 +104,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestRestOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<rest(names); separator=\", \">"
);
e.add("names", "Ter");
@@ -117,7 +117,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestRestOpEmptyList()
{
-            ST e = new ST(
+            Template e = new Template(
"<rest(names); separator=\", \">"
);
e.add("names", new List<string>());
@@ -133,8 +133,8 @@ namespace Antlr4.Test.StringTemplate
"b(x) ::= \"<x>, <x>\"" + newline
;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ST e = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
+            Template e = group.getInstanceOf("a");
List<string> names = new List<string>();
names.Add("Ter");
names.Add("Tom");
@@ -146,7 +146,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLastOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<last(names)>"
);
e.add("names", "Ter");
@@ -159,7 +159,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestStripOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<strip(names); null=\"n/a\">"
);
e.add("names", null);
@@ -175,7 +175,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLengthStrip()
{
-            ST e = new ST(
+            Template e = new Template(
"<length(strip(names))>"
);
e.add("names", null);
@@ -192,7 +192,7 @@ namespace Antlr4.Test.StringTemplate
public void TestCombinedOp()
{
// replace first of yours with first of mine
-            ST e = new ST(
+            Template e = new Template(
"<[first(mine),rest(yours)]; separator=\", \">"
);
e.add("mine", "1");
@@ -208,7 +208,7 @@ namespace Antlr4.Test.StringTemplate
public void TestCatListAndSingleAttribute()
{
// replace first of yours with first of mine
-            ST e = new ST(
+            Template e = new Template(
"<[mine,yours]; separator=\", \">"
);
e.add("mine", "1");
@@ -227,8 +227,8 @@ namespace Antlr4.Test.StringTemplate
"b(x) ::= \"<x>, <x>\"" + newline
;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ST e = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
+            Template e = group.getInstanceOf("a");
List<string> mine = new List<string>();
mine.Add("Ter");
mine.Add("Tom");
@@ -247,7 +247,7 @@ namespace Antlr4.Test.StringTemplate
// two operands (from left to right) determine which way it
// goes.  In this case, x+mine is a list so everything from their
// to the right becomes list cat.
-            ST e = new ST(
+            Template e = new Template(
"<[x,mine,y,yours,z]; separator=\", \">"
);
e.add("mine", "1");
@@ -261,7 +261,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNestedOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<first(rest(names))>" // gets 2nd element
);
e.add("names", "Ter");
@@ -274,7 +274,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestFirstWithOneAttributeOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<first(names)>"
);
e.add("names", "Ter");
@@ -285,7 +285,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLastWithOneAttributeOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<last(names)>"
);
e.add("names", "Ter");
@@ -296,7 +296,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLastWithLengthOneListAttributeOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<last(names)>"
);
e.add("names", new List<string>() { "Ter" });
@@ -307,7 +307,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestRestWithOneAttributeOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<rest(names)>"
);
e.add("names", "Ter");
@@ -318,7 +318,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestRestWithLengthOneListAttributeOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<rest(names)>"
);
e.add("names", new List<string>() { "Ter" });
@@ -329,7 +329,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestRepeatedRestOp()
{
-            ST e = new ST(
+            Template e = new Template(
"<rest(names)>, <rest(names)>" // gets 2nd element
);
e.add("names", "Ter");
@@ -341,7 +341,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIncomingLists()
{
-            ST e = new ST(
+            Template e = new Template(
"<rest(names)>, <rest(names)>" // gets 2nd element
);
e.add("names", "Ter");
@@ -353,7 +353,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestFirstWithCatAttribute()
{
-            ST e = new ST(
+            Template e = new Template(
"<first([names,phones])>"
);
e.add("names", "Ter");
@@ -367,7 +367,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestFirstWithListOfMaps()
{
-            ST e = new ST(
+            Template e = new Template(
"<first(maps).Ter>"
);
IDictionary<string, string> m1 = new Dictionary<string, string>();
@@ -388,7 +388,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestFirstWithListOfMaps2()
{
-            ST e = new ST(
+            Template e = new Template(
"<first(maps):{ m | <m>!}>"
);
IDictionary<string, string> m1 = new Dictionary<string, string>();
@@ -408,7 +408,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTrim()
{
-            ST e = new ST(
+            Template e = new Template(
"<trim(name)>"
);
e.add("name", " Ter  \n");
@@ -419,7 +419,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestStrlen()
{
-            ST e = new ST(
+            Template e = new Template(
"<strlen(name)>"
);
e.add("name", "012345");
@@ -430,7 +430,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestReverse()
{
-            ST e = new ST(
+            Template e = new Template(
"<reverse(names); separator=\", \">"
);
e.add("names", "Ter");
diff --git a/Antlr4.Test.StringTemplate/TestGroupSyntax.cs b/Antlr4.Test.StringTemplate/TestGroupSyntax.cs
index 4ce72e5..3c9f6a2 100644
--- a/Antlr4.Test.StringTemplate/TestGroupSyntax.cs
+++ b/Antlr4.Test.StringTemplate/TestGroupSyntax.cs
@@ -46,7 +46,7 @@ namespace Antlr4.Test.StringTemplate
"t() ::= <<foo>>" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
string expected =
"t() ::= <<" + Environment.NewLine +
"foo" + Environment.NewLine +
@@ -64,7 +64,7 @@ namespace Antlr4.Test.StringTemplate
"wow() ::= <<last>>" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
string expected =
"ta(x) ::= <<" + Environment.NewLine +
"[<x>]" + Environment.NewLine +
@@ -86,7 +86,7 @@ namespace Antlr4.Test.StringTemplate
"t(a,b) ::= \"[<a>]\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
string expected =
"t(a,b) ::= <<" + Environment.NewLine +
"[<a>]" + Environment.NewLine +
@@ -102,7 +102,7 @@ namespace Antlr4.Test.StringTemplate
"t(a={def1},b=\"def2\") ::= \"[<a>]\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
string expected =
"t(a={def1},b=\"def2\") ::= <<" + Environment.NewLine +
"[<a>]" + Environment.NewLine +
@@ -118,7 +118,7 @@ namespace Antlr4.Test.StringTemplate
"t(a={x | 2*<x>}) ::= \"[<a>]\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
string expected =
"t(a={x | 2*<x>}) ::= <<" + Environment.NewLine +
"[<a>]" + Environment.NewLine +
@@ -134,7 +134,7 @@ namespace Antlr4.Test.StringTemplate
"t(a) ::= \"<a:{x | <x:{y | <y>}>}>\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
string expected =
"t(a) ::= <<" + Environment.NewLine +
"<a:{x | <x:{y | <y>}>}>" + Environment.NewLine +
@@ -150,7 +150,7 @@ namespace Antlr4.Test.StringTemplate
"t(a={x | <x:{y|<y>}>}) ::= \"ick\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.load();
string expected =
"t(a={x | <x:{y|<y>}>}) ::= <<" + Environment.NewLine +
@@ -167,7 +167,7 @@ namespace Antlr4.Test.StringTemplate
"t(a={x | \\< <x:{y|<y>\\}}>}) ::= \"[<a>]\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
string expected =
"t(a={x | \\< <x:{y|<y>\\}}>}) ::= <<" + Environment.NewLine +
"[<a>]" + Environment.NewLine +
diff --git a/Antlr4.Test.StringTemplate/TestGroupSyntaxErrors.cs b/Antlr4.Test.StringTemplate/TestGroupSyntaxErrors.cs
index f95caee..5d46cdd 100644
--- a/Antlr4.Test.StringTemplate/TestGroupSyntaxErrors.cs
+++ b/Antlr4.Test.StringTemplate/TestGroupSyntaxErrors.cs
@@ -49,7 +49,7 @@ namespace Antlr4.Test.StringTemplate
writeFile(tmpdir, "t.stg", templates);

ITemplateErrorListener errors = new ErrorBuffer();
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 2:0: mismatched input 'foo' expecting STRING" + newline +
@@ -67,7 +67,7 @@ namespace Antlr4.Test.StringTemplate
writeFile(tmpdir, "t.stg", templates);

ITemplateErrorListener errors = new ErrorBuffer();
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:7: mismatched input 'Super' expecting STRING" + newline;
@@ -82,9 +82,9 @@ namespace Antlr4.Test.StringTemplate
"foo() ::= \n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 2:0: missing template at '<EOF>'" + newline;
@@ -99,9 +99,9 @@ namespace Antlr4.Test.StringTemplate
"foo( ::= << >>\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:5: no viable alternative at input '::='" + newline;
@@ -116,9 +116,9 @@ namespace Antlr4.Test.StringTemplate
"foo() ::= \"\nfoo\"\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:11: \\n in string" + newline;
@@ -134,9 +134,9 @@ namespace Antlr4.Test.StringTemplate
"bar() ::= <<bar>>\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:0: garbled template definition starting at 'foo'" + newline;
@@ -151,9 +151,9 @@ namespace Antlr4.Test.StringTemplate
"foo(a,) ::= << >>\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:6: mismatched input ')' expecting ID" + newline;
@@ -168,9 +168,9 @@ namespace Antlr4.Test.StringTemplate
"foo(a,,) ::= << >>\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected =
@@ -187,9 +187,9 @@ namespace Antlr4.Test.StringTemplate
"foo(a b) ::= << >>\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected =
@@ -206,9 +206,9 @@ namespace Antlr4.Test.StringTemplate
"foo(a) ::= \"<a b>\"\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "[t.stg 1:15: 'b' came as a complete surprise to me]";
@@ -223,9 +223,9 @@ namespace Antlr4.Test.StringTemplate
"d ::= []\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "[t.stg 1:7: missing dictionary entry at ']']";
@@ -240,9 +240,9 @@ namespace Antlr4.Test.StringTemplate
"d ::= [\"k\":]\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "[t.stg 1:11: missing value for key at ']']";
@@ -257,9 +257,9 @@ namespace Antlr4.Test.StringTemplate
"d ::= [\"k\":{dfkj}}]\n"; // extra }
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "[t.stg 1:17: invalid character '}']";
@@ -274,9 +274,9 @@ namespace Antlr4.Test.StringTemplate
"f() ::= \""; // extra }
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ErrorBuffer errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "[t.stg 1:9: unterminated string, t.stg 1:9: missing template at '<EOF>']";
diff --git a/Antlr4.Test.StringTemplate/TestGroups.cs b/Antlr4.Test.StringTemplate/TestGroups.cs
index 52646b2..412c04d 100644
--- a/Antlr4.Test.StringTemplate/TestGroups.cs
+++ b/Antlr4.Test.StringTemplate/TestGroups.cs
@@ -50,8 +50,8 @@ namespace Antlr4.Test.StringTemplate
"foo" + newline +
">>" + newline;
writeFile(dir, "a.st", a);
-            STGroup group = new STGroupDir(dir);
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st = group.getInstanceOf("a");
string expected = "foo";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -69,9 +69,9 @@ namespace Antlr4.Test.StringTemplate
string b =
"b() ::= \"bar\"" + newline;
writeFile(dir, "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st1 = group.getInstanceOf("a");
-            ST st2 = group.getInstanceOf("b");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st1 = group.getInstanceOf("a");
+            Template st2 = group.getInstanceOf("b");
string expected = "foobar";
string result = st1.render() + st2.render();
Assert.AreEqual(expected, result);
@@ -90,9 +90,9 @@ namespace Antlr4.Test.StringTemplate
string b =
"b() ::= \"bar\"" + newline;
writeFile(Path.Combine(dir, "subdir"), "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st1 = group.getInstanceOf("a");
-            ST st2 = group.getInstanceOf("subdir/b");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st1 = group.getInstanceOf("a");
+            Template st2 = group.getInstanceOf("subdir/b");
string expected = "foobar";
string result = st1.render() + st2.render();
Assert.AreEqual(expected, result);
@@ -113,8 +113,8 @@ namespace Antlr4.Test.StringTemplate
string b =
"b() ::= <<bar>>\n";
writeFile(dir + "/subdir", "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st = group.getInstanceOf("a");
string expected = " bar ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -134,10 +134,10 @@ namespace Antlr4.Test.StringTemplate
"b() ::= \"bar\"\n" +
"c() ::= \"duh\"\n";
writeFile(dir, "group.stg", groupFile);
-            STGroup group = new STGroupDir(dir);
-            ST st1 = group.getInstanceOf("a");
-            ST st2 = group.getInstanceOf("group/b");
-            ST st3 = group.getInstanceOf("group/c");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st1 = group.getInstanceOf("a");
+            Template st2 = group.getInstanceOf("group/b");
+            Template st3 = group.getInstanceOf("group/c");
string expected = "foobarduh";
string result = st1.render() + st2.render() + st3.render();
Assert.AreEqual(expected, result);
@@ -156,9 +156,9 @@ namespace Antlr4.Test.StringTemplate
string b =
"b() ::= \"bar\"" + newline;
writeFile(dir + "/sub1/sub2", "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st1 = group.getInstanceOf("a");
-            ST st2 = group.getInstanceOf("sub1/sub2/b");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st1 = group.getInstanceOf("a");
+            Template st2 = group.getInstanceOf("sub1/sub2/b");
string expected = "foobar";
string result = st1.render() + st2.render();
Assert.AreEqual(expected, result);
@@ -178,10 +178,10 @@ namespace Antlr4.Test.StringTemplate
"b() ::= \"bar\"\n" +
"c() ::= \"duh\"\n";
writeFile(dir, "subdir/group.stg", groupFile);
-            STGroup group = new STGroupDir(dir);
-            ST st1 = group.getInstanceOf("a");
-            ST st2 = group.getInstanceOf("subdir/group/b");
-            ST st3 = group.getInstanceOf("subdir/group/c");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st1 = group.getInstanceOf("a");
+            Template st2 = group.getInstanceOf("subdir/group/b");
+            Template st3 = group.getInstanceOf("subdir/group/c");
string expected = "foobarduh";
string result = st1.render() + st2.render() + st3.render();
Assert.AreEqual(expected, result);
@@ -195,8 +195,8 @@ namespace Antlr4.Test.StringTemplate
string b = "b() ::= <<bar>>\n";
writeFile(dir, "a.st", a);
writeFile(dir, "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st = group.getInstanceOf("a");
string expected = " bar ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -211,8 +211,8 @@ namespace Antlr4.Test.StringTemplate
string b = "b() ::= <<bar>>\n";
writeFile(dir + "/subdir", "a.st", a);
writeFile(dir + "/subdir", "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st = group.getInstanceOf("subdir/a");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st = group.getInstanceOf("subdir/a");
st.impl.dump();
string expected = " bar ";
string result = st.render();
@@ -228,7 +228,7 @@ namespace Antlr4.Test.StringTemplate
"b() ::= \"duh\"\n";
writeFile(dir, "group.stg", groupFile);
ITemplateErrorListener errors = new ErrorBuffer();
-            STGroupFile group = new STGroupFile(Path.Combine(dir, "group.stg"));
+            TemplateGroupFile group = new TemplateGroupFile(Path.Combine(dir, "group.stg"));
group.setListener(errors);
group.load();
string expected = "group.stg 2:0: redefinition of template b" + newline;
@@ -244,8 +244,8 @@ namespace Antlr4.Test.StringTemplate
"a() ::= \"bar\"\n" +
"b ::= a\n";
writeFile(dir, "group.stg", groupFile);
-            STGroupFile group = new STGroupFile(Path.Combine(dir, "group.stg"));
-            ST st = group.getInstanceOf("b");
+            TemplateGroupFile group = new TemplateGroupFile(Path.Combine(dir, "group.stg"));
+            Template st = group.getInstanceOf("b");
string expected = "bar";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -259,8 +259,8 @@ namespace Antlr4.Test.StringTemplate
"a(x,y) ::= \"<x><y>\"\n" +
"b ::= a\n";
writeFile(dir, "group.stg", groupFile);
-            STGroupFile group = new STGroupFile(Path.Combine(dir, "group.stg"));
-            ST st = group.getInstanceOf("b");
+            TemplateGroupFile group = new TemplateGroupFile(Path.Combine(dir, "group.stg"));
+            Template st = group.getInstanceOf("b");
st.add("x", 1);
st.add("y", 2);
string expected = "12";
@@ -276,8 +276,8 @@ namespace Antlr4.Test.StringTemplate
string b = "b(x=\"foo\") ::= \"<x>\"\n";
writeFile(dir, "a.st", a);
writeFile(dir, "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st = group.getInstanceOf("a");
string expected = " foo ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -293,8 +293,8 @@ namespace Antlr4.Test.StringTemplate
"stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template b = group.getInstanceOf("method");
b.add("name", "foo");
string expecting = "x=99; // foo";
string result = b.render();
@@ -308,8 +308,8 @@ namespace Antlr4.Test.StringTemplate
"stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.getInstanceOf("stat");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template b = group.getInstanceOf("stat");
b.add("name", "foo");
string expecting = "x=99; // foo";
string result = b.render();
@@ -323,8 +323,8 @@ namespace Antlr4.Test.StringTemplate
"stat(name,value={99}) ::= \"x=<value>; // <name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.getInstanceOf("stat");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template b = group.getInstanceOf("stat");
b.add("name", "foo");
string expecting = "x=99; // foo";
string result = b.render();
@@ -353,8 +353,8 @@ namespace Antlr4.Test.StringTemplate
"stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST m = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template m = group.getInstanceOf("method");
m.add("fields", new Field());
string expecting = "x=parrt; // parrt";
string result = m.render();
@@ -371,8 +371,8 @@ namespace Antlr4.Test.StringTemplate
"stat(value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST m = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template m = group.getInstanceOf("method");
m.add("fields", new Field());
string expecting = "x=parrt; // parrt";
string result = m.render();
@@ -390,8 +390,8 @@ namespace Antlr4.Test.StringTemplate
"stat(f,value={<f.name>}) ::= \"x=<value>; // <f.name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST m = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template m = group.getInstanceOf("method");
m.add("fields", new Field());
string expecting = "x=parrt; // parrt";
string result = m.render();
@@ -408,8 +408,8 @@ namespace Antlr4.Test.StringTemplate
"stat(name,value={<name>}) ::= \"x=<value>; // <name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template b = group.getInstanceOf("method");
b.add("name", "foo");
b.add("size", "2");
string expecting = "x=foo; // foo";
@@ -428,8 +428,8 @@ namespace Antlr4.Test.StringTemplate
"stat(name,value={ [<name>] }) ::= \"x=<value>; // <name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template b = group.getInstanceOf("method");
b.add("name", "foo");
b.add("size", "2");
string expecting = "x=[foo] ; // foo"; // won't see ' ' after '=' since it's an indent not simple string
@@ -448,8 +448,8 @@ namespace Antlr4.Test.StringTemplate
"stat(name,value=\"99\") ::= \"x=<value>; // <name>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST b = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template b = group.getInstanceOf("method");
b.add("name", "foo");
string expecting = "x=34; // foo";
string result = b.render();
@@ -473,8 +473,8 @@ namespace Antlr4.Test.StringTemplate
"B(y={<(x)>}) ::= \"<y> <x> <x> <y>\"" + newline
;
writeFile(tmpdir, "group.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/group.stg");
-            ST a = group.getInstanceOf("A");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/group.stg");
+            Template a = group.getInstanceOf("A");
a.add("x", new Counter());
string expecting = "0 1 2 0"; // trace must be false to get these numbers
string result = a.render();
@@ -490,8 +490,8 @@ namespace Antlr4.Test.StringTemplate
"f(x,y) ::= \"<x><y>\"\n" +
"g() ::= \"<f(x={a},y={b})>\"";
writeFile(dir, "group.stg", groupFile);
-            STGroupFile group = new STGroupFile(Path.Combine(dir, "group.stg"));
-            ST st = group.getInstanceOf("g");
+            TemplateGroupFile group = new TemplateGroupFile(Path.Combine(dir, "group.stg"));
+            Template st = group.getInstanceOf("g");
string expected = "ab";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -505,8 +505,8 @@ namespace Antlr4.Test.StringTemplate
"f(x,y) ::= \"<x><y>\"\n" +
"g() ::= \"<f(y={b},x={a})>\"";
writeFile(dir, "group.stg", groupFile);
-            STGroupFile group = new STGroupFile(Path.Combine(dir, "group.stg"));
-            ST st = group.getInstanceOf("g");
+            TemplateGroupFile group = new TemplateGroupFile(Path.Combine(dir, "group.stg"));
+            Template st = group.getInstanceOf("g");
string expected = "ab";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -522,10 +522,10 @@ namespace Antlr4.Test.StringTemplate
//012345678901234567

writeFile(dir, "group.stg", groupFile);
-            STGroupFile group = new STGroupFile(Path.Combine(dir, "group.stg"));
+            TemplateGroupFile group = new TemplateGroupFile(Path.Combine(dir, "group.stg"));
ErrorBuffer errors = new ErrorBuffer();
group.setListener(errors);
-            ST st = group.getInstanceOf("g");
+            Template st = group.getInstanceOf("g");
st.render();
string expected = "context [g] 1:1 attribute z isn't defined" + newline;
string result = errors.ToString();
@@ -542,7 +542,7 @@ namespace Antlr4.Test.StringTemplate
//012345678901234567

writeFile(dir, "group.stg", groupFile);
-            STGroupFile group = new STGroupFile(Path.Combine(dir, "group.stg"));
+            TemplateGroupFile group = new TemplateGroupFile(Path.Combine(dir, "group.stg"));
ErrorBuffer errors = new ErrorBuffer();
group.setListener(errors);
group.load();
@@ -560,7 +560,7 @@ namespace Antlr4.Test.StringTemplate
"g(name) ::= \"<(name)(x={a},y={b})>\"";
//0123456789012345678901234567890
writeFile(dir, "group.stg", groupFile);
-            STGroupFile group = new STGroupFile(Path.Combine(dir, "group.stg"));
+            TemplateGroupFile group = new TemplateGroupFile(Path.Combine(dir, "group.stg"));
ErrorBuffer errors = new ErrorBuffer();
group.setListener(errors);
group.load();
@@ -580,8 +580,8 @@ namespace Antlr4.Test.StringTemplate
"b() ::= \"group file b\"\n";
writeFile(dir, "group.stg", groupFile);

-            STGroup group1 = new STGroupDir(dir);
-            ST st = group1.getInstanceOf("group/a"); // can't see
+            TemplateGroup group1 = new TemplateGroupDirectory(dir);
+            Template st = group1.getInstanceOf("group/a"); // can't see
Assert.AreEqual(null, st);
}

@@ -596,8 +596,8 @@ namespace Antlr4.Test.StringTemplate
"foo" + newline +
">>" + newline;
writeFile(dir, "a.st", a);
-            STGroup group = new STGroupDir(dir);
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st = group.getInstanceOf("a");
string expected = "foo";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -612,8 +612,8 @@ namespace Antlr4.Test.StringTemplate
string b = "b() ::= <<bar>>\n";
writeFile(dir + "/subdir", "a.st", a);
writeFile(dir + "/subdir", "b.st", b);
-            STGroup group = new STGroupDir(dir);
-            ST st = group.getInstanceOf("subdir/a");
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st = group.getInstanceOf("subdir/a");
string expected = " bar ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -631,9 +631,9 @@ namespace Antlr4.Test.StringTemplate
"b() ::= \"bar\"\n" +
"c() ::= \"<a()>\"\n";
writeFile(dir, "group.stg", groupFile);
-            STGroup group = new STGroupDir(dir);
-            ST st1 = group.getInstanceOf("a");
-            ST st2 = group.getInstanceOf("group/c"); // invokes /a
+            TemplateGroup group = new TemplateGroupDirectory(dir);
+            Template st1 = group.getInstanceOf("a");
+            Template st2 = group.getInstanceOf("group/c"); // invokes /a
string expected = " bar  bar ";
string result = st1.render() + st2.render();
Assert.AreEqual(expected, result);
@@ -649,9 +649,9 @@ namespace Antlr4.Test.StringTemplate
"b() ::= <<bar>>\n";
writeFile(dir, "a.st", a);
writeFile(dir, "b.st", b);
-            STGroup group = new STGroupDir(dir);
+            TemplateGroup group = new TemplateGroupDirectory(dir);
group.load(); // force load
-            ST st = group.getInstanceOf("a");
+            Template st = group.getInstanceOf("a");
int originalHashCode = RuntimeHelpers.GetHashCode(st);
group.unload(); // blast cache
st = group.getInstanceOf("a");
@@ -674,9 +674,9 @@ namespace Antlr4.Test.StringTemplate
"a(x) ::= <<foo>>\n" +
"b() ::= <<bar>>\n";
writeFile(dir, "a.stg", a);
-            STGroup group = new STGroupFile(dir + "/a.stg");
+            TemplateGroup group = new TemplateGroupFile(dir + "/a.stg");
group.load(); // force load
-            ST st = group.getInstanceOf("a");
+            Template st = group.getInstanceOf("a");
int originalHashCode = RuntimeHelpers.GetHashCode(st);
group.unload(); // blast cache
st = group.getInstanceOf("a");
diff --git a/Antlr4.Test.StringTemplate/TestImports.cs b/Antlr4.Test.StringTemplate/TestImports.cs
index 77f3608..ba1b0ba 100644
--- a/Antlr4.Test.StringTemplate/TestImports.cs
+++ b/Antlr4.Test.StringTemplate/TestImports.cs
@@ -52,10 +52,10 @@ namespace Antlr4.Test.StringTemplate
a = "a() ::= << <b()> >>\n";
writeFile(dir2, "a.st", a);

-            STGroup group1 = new STGroupDir(dir1);
-            STGroup group2 = new STGroupDir(dir2);
+            TemplateGroup group1 = new TemplateGroupDirectory(dir1);
+            TemplateGroup group2 = new TemplateGroupDirectory(dir2);
group2.importTemplates(group1);
-            ST st = group2.getInstanceOf("b");
+            Template st = group2.getInstanceOf("b");
string expected = "dir1 b";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -82,8 +82,8 @@ namespace Antlr4.Test.StringTemplate
writeFile(dir2, "a.st", a);
writeFile(dir2, "b.st", b);

-            STGroup group = new STGroupFile(dir1 + "/a.stg");
-            ST st = group.getInstanceOf("b"); // visible only if import worked
+            TemplateGroup group = new TemplateGroupFile(dir1 + "/a.stg");
+            Template st = group.getInstanceOf("b"); // visible only if import worked
string expected = "dir2 b";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -103,8 +103,8 @@ namespace Antlr4.Test.StringTemplate
"c() ::= \"g2 c\"\n";
writeFile(dir, "group2.stg", groupFile);

-            STGroup group1 = new STGroupFile(dir + "/group1.stg");
-            ST st = group1.getInstanceOf("c"); // should see c()
+            TemplateGroup group1 = new TemplateGroupFile(dir + "/group1.stg");
+            Template st = group1.getInstanceOf("c"); // should see c()
string expected = "g2 c";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -122,10 +122,10 @@ namespace Antlr4.Test.StringTemplate
"c() ::= \"group file c\"\n";
writeFile(dir, "y/group.stg", groupFile);

-            STGroup group1 = new STGroupDir(dir + "/x");
-            STGroup group2 = new STGroupFile(dir + "/y/group.stg");
+            TemplateGroup group1 = new TemplateGroupDirectory(dir + "/x");
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/y/group.stg");
group1.importTemplates(group2);
-            ST st = group1.getInstanceOf("a");
+            Template st = group1.getInstanceOf("a");
st.impl.dump();
string expected = " group file b ";
string result = st.render();
@@ -146,10 +146,10 @@ namespace Antlr4.Test.StringTemplate
"c() ::= \"g2 c\"\n";
writeFile(dir, "y/group.stg", groupFile);

-            STGroup group1 = new STGroupFile(dir + "/x/group.stg");
-            STGroup group2 = new STGroupFile(dir + "/y/group.stg");
+            TemplateGroup group1 = new TemplateGroupFile(dir + "/x/group.stg");
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/y/group.stg");
group1.importTemplates(group2);
-            ST st = group1.getInstanceOf("b");
+            Template st = group1.getInstanceOf("b");
string expected = "g2 c";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -165,10 +165,10 @@ namespace Antlr4.Test.StringTemplate
writeFile(dir, "x/subdir/a.st", a);
writeFile(dir, "y/subdir/b.st", b);

-            STGroup group1 = new STGroupDir(dir + "/x");
-            STGroup group2 = new STGroupDir(dir + "/y");
+            TemplateGroup group1 = new TemplateGroupDirectory(dir + "/x");
+            TemplateGroup group2 = new TemplateGroupDirectory(dir + "/y");
group1.importTemplates(group2);
-            ST st = group1.getInstanceOf("subdir/a");
+            Template st = group1.getInstanceOf("subdir/a");
string expected = " x's subdir/b ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -187,10 +187,10 @@ namespace Antlr4.Test.StringTemplate
"b() ::= \"group file: b\"\n";
writeFile(dir, "y/subdir.stg", groupFile);

-            STGroup group1 = new STGroupDir(dir + "/x");
-            STGroup group2 = new STGroupDir(dir + "/y");
+            TemplateGroup group1 = new TemplateGroupDirectory(dir + "/x");
+            TemplateGroup group2 = new TemplateGroupDirectory(dir + "/y");
group1.importTemplates(group2);
-            ST st = group1.getInstanceOf("subdir/a");
+            Template st = group1.getInstanceOf("subdir/a");
string expected = " group file: b ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -208,12 +208,12 @@ namespace Antlr4.Test.StringTemplate
writeFile(dir2, "a.st", a);
writeFile(dir2, "b.st", b);

-            STGroup group1 = new STGroupDir(dir1);
-            STGroup group2 = new STGroupDir(dir2);
+            TemplateGroup group1 = new TemplateGroupDirectory(dir1);
+            TemplateGroup group2 = new TemplateGroupDirectory(dir2);
group1.importTemplates(group2);

// normal lookup; a created from dir2 calls dir2.b
-            ST st = group2.getInstanceOf("a");
+            Template st = group2.getInstanceOf("a");
string expected = " dir2 b ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -237,10 +237,10 @@ namespace Antlr4.Test.StringTemplate
a = "a() ::= << [<super.a()>] >>\n";
writeFile(dir2, "a.st", a);

-            STGroup group1 = new STGroupDir(dir1);
-            STGroup group2 = new STGroupDir(dir2);
+            TemplateGroup group1 = new TemplateGroupDirectory(dir1);
+            TemplateGroup group2 = new TemplateGroupDirectory(dir2);
group2.importTemplates(group1);
-            ST st = group2.getInstanceOf("a");
+            Template st = group2.getInstanceOf("a");
string expected = " [dir1 a] ";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -258,12 +258,12 @@ namespace Antlr4.Test.StringTemplate
a = "a() ::= << <b()> >>\n";
writeFile(dir2, "a.st", a);

-            STGroup group1 = new STGroupDir(dir1);
-            STGroup group2 = new STGroupDir(dir2);
+            TemplateGroup group1 = new TemplateGroupDirectory(dir1);
+            TemplateGroup group2 = new TemplateGroupDirectory(dir2);
group2.importTemplates(group1);

-            ST st = group2.getInstanceOf("a");
-            ST st2 = group2.getInstanceOf("b");
+            Template st = group2.getInstanceOf("a");
+            Template st2 = group2.getInstanceOf("b");
int originalHashCode = RuntimeHelpers.GetHashCode(st);
int originalHashCode2 = RuntimeHelpers.GetHashCode(st2);
group1.unload(); // blast cache
diff --git a/Antlr4.Test.StringTemplate/TestIndentation.cs b/Antlr4.Test.StringTemplate/TestIndentation.cs
index 43f2751..c30c0d7 100644
--- a/Antlr4.Test.StringTemplate/TestIndentation.cs
+++ b/Antlr4.Test.StringTemplate/TestIndentation.cs
@@ -48,8 +48,8 @@ namespace Antlr4.Test.StringTemplate
">>" + newline;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST t = group.getInstanceOf("list");
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            Template t = group.getInstanceOf("list");
t.impl.dump();
t.add("a", "Terence");
t.add("b", "Jim");
@@ -67,8 +67,8 @@ namespace Antlr4.Test.StringTemplate
">>" + newline;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST t = group.getInstanceOf("list");
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            Template t = group.getInstanceOf("list");
t.add("names", "Terence");
t.add("names", "Jim");
t.add("names", "Sriram");
@@ -87,8 +87,8 @@ namespace Antlr4.Test.StringTemplate
"  <names; separator=\"\n\">" + newline +
">>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST t = group.getInstanceOf("list");
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            Template t = group.getInstanceOf("list");
t.add("names", "Terence\nis\na\nmaniac");
t.add("names", "Jim");
t.add("names", "Sriram\nis\ncool");
@@ -112,8 +112,8 @@ namespace Antlr4.Test.StringTemplate
"  <names>" + newline +
">>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST t = group.getInstanceOf("list");
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            Template t = group.getInstanceOf("list");
t.add("names", "Terence\n\nis a maniac");
string expecting =
"  Terence" + newline +
@@ -132,8 +132,8 @@ namespace Antlr4.Test.StringTemplate
"after" + newline +
">>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST t = group.getInstanceOf("list");
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            Template t = group.getInstanceOf("list");
t.add("names", "Terence");
t.add("names", "Jim");
t.add("names", "Sriram");
@@ -163,18 +163,18 @@ namespace Antlr4.Test.StringTemplate
"assign(lhs,expr) ::= <<<lhs>=<expr>;>>" + newline
;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            ST t = group.getInstanceOf("method");
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            Template t = group.getInstanceOf("method");
t.add("name", "foo");
-            ST s1 = group.getInstanceOf("assign");
+            Template s1 = group.getInstanceOf("assign");
s1.add("lhs", "x");
s1.add("expr", "0");
-            ST s2 = group.getInstanceOf("ifstat");
+            Template s2 = group.getInstanceOf("ifstat");
s2.add("expr", "x>0");
-            ST s2a = group.getInstanceOf("assign");
+            Template s2a = group.getInstanceOf("assign");
s2a.add("lhs", "y");
s2a.add("expr", "x+y");
-            ST s2b = group.getInstanceOf("assign");
+            Template s2b = group.getInstanceOf("assign");
s2b.add("lhs", "z");
s2b.add("expr", "4");
s2.add("stats", s2a);
@@ -195,7 +195,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIndentedIFWithValueExpr()
{
-            ST t = new ST(
+            Template t = new Template(
"begin" + newline +
"    <if(x)>foo<endif>" + newline +
"end" + newline);
@@ -211,7 +211,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIFWithIndentOnMultipleLines()
{
-            ST t = new ST(
+            Template t = new Template(
"begin" + newline +
"   <if(x)>" + newline +
"   foo" + newline +
@@ -230,7 +230,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIFWithIndentAndExprOnMultipleLines()
{
-            ST t = new ST(
+            Template t = new Template(
"begin" + newline +
"   <if(x)>" + newline +
"   <x>" + newline +
@@ -250,7 +250,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIFWithIndentAndExprWithIndentOnMultipleLines()
{
-            ST t = new ST(
+            Template t = new Template(
"begin" + newline +
"   <if(x)>" + newline +
"     <x>" + newline +
@@ -270,7 +270,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNestedIFWithIndentOnMultipleLines()
{
-            ST t = new ST(
+            Template t = new Template(
"begin" + newline +
"   <if(x)>" + newline +
"      <if(y)>" + newline +
@@ -295,7 +295,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIFInSubtemplate()
{
-            ST t = new ST(
+            Template t = new Template(
"<names:{n |" + newline +
"   <if(x)>" + newline +
"   <x>" + newline +
diff --git a/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs b/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs
index 3863a58..d3706e9 100644
--- a/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs
+++ b/Antlr4.Test.StringTemplate/TestIndirectionAndEarlyEval.cs
@@ -43,7 +43,7 @@ namespace Antlr4.Test.StringTemplate
public void TestEarlyEval()
{
string template = "<(name)>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("name", "Ter");
string expected = "Ter";
string result = st.render();
@@ -53,11 +53,11 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIndirectTemplateInclude()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("foo", "bar");
string template = "<(name)()>";
group.defineTemplate("test", "name", template);
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "foo");
string expected = "bar";
string result = st.render();
@@ -67,11 +67,11 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIndirectTemplateIncludeWithArgs()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("foo", "x,y", "<x><y>");
string template = "<(name)({1},{2})>";
group.defineTemplate("test", "name", template);
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "foo");
string expected = "12";
string result = st.render();
@@ -81,12 +81,12 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIndirectTemplateIncludeViaTemplate()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("foo", "bar");
group.defineTemplate("tname", "foo");
string template = "<(tname())()>";
group.defineTemplate("test", "name", template);
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
string expected = "bar";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -96,7 +96,7 @@ namespace Antlr4.Test.StringTemplate
public void TestIndirectProp()
{
string template = "<u.(propname)>: <u.name>";
-            ST st = new ST(template);
+            Template st = new Template(template);
st.add("u", new TestCoreBasics.User(1, "parrt"));
st.add("propname", "id");
string expected = "1: parrt";
@@ -107,10 +107,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIndirectMap()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("a", "x", "[<x>]");
group.defineTemplate("test", "names,templateName", "hi <names:(templateName)()>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -125,7 +125,7 @@ namespace Antlr4.Test.StringTemplate
public void TestNonStringDictLookup()
{
string template = "<m.(intkey)>";
-            ST st = new ST(template);
+            Template st = new Template(template);
IDictionary<int, string> m = new Dictionary<int, string>();
m[36] = "foo";
st.add("m", m);
diff --git a/Antlr4.Test.StringTemplate/TestInterptimeErrors.cs b/Antlr4.Test.StringTemplate/TestInterptimeErrors.cs
index 449705d..b402d83 100644
--- a/Antlr4.Test.StringTemplate/TestInterptimeErrors.cs
+++ b/Antlr4.Test.StringTemplate/TestInterptimeErrors.cs
@@ -71,9 +71,9 @@ namespace Antlr4.Test.StringTemplate
"t() ::= \"<foo()>\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.render();
string expected = "context [t] 1:0 no such template: foo" + newline;
string result = errors.ToString();
@@ -89,15 +89,15 @@ namespace Antlr4.Test.StringTemplate
"t() ::= \"<super.t()>\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
string templates2 =
"u() ::= \"blech\"" + Environment.NewLine;

writeFile(tmpdir, "t2.stg", templates2);
-            STGroup group2 = new STGroupFile(tmpdir + "/" + "t2.stg");
+            TemplateGroup group2 = new TemplateGroupFile(tmpdir + "/" + "t2.stg");
group.importTemplates(group2);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.render();
string expected = "context [t] 1:1 no such template: super.t" + newline;
string result = errors.ToString();
@@ -113,9 +113,9 @@ namespace Antlr4.Test.StringTemplate
"t(u) ::= \"<u.x>\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.add("u", new User(32, "parrt"));
st.render();
string expected = "";
@@ -132,9 +132,9 @@ namespace Antlr4.Test.StringTemplate
"t(u) ::= \"<u.name>\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.add("u", new UserHiddenName("parrt"));
st.render();
string expected = "";
@@ -151,9 +151,9 @@ namespace Antlr4.Test.StringTemplate
"t(u) ::= \"<u.name>\"" + Environment.NewLine;

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.add("u", new UserHiddenNameField("parrt"));
st.render();
string expected = "";
@@ -171,9 +171,9 @@ namespace Antlr4.Test.StringTemplate
"u(x,y) ::= \"<x>\"\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.render();
string expected = "context [t] 1:1 passed 1 arg(s) to template u with 2 declared arg(s)" + newline;
string result = errors.ToString();
@@ -190,9 +190,9 @@ namespace Antlr4.Test.StringTemplate
"u(x,y) ::= \"<x>\"\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
string expected = "9";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -212,10 +212,10 @@ namespace Antlr4.Test.StringTemplate
"u() ::= \"<x>\"\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            STGroup.debug = true;
-            ST st = group.getInstanceOf("t");
+            TemplateGroup.debug = true;
+            Template st = group.getInstanceOf("t");
st.render();
string expected = "context [t u] 1:1 attribute x isn't defined" + newline;
string result = errors.ToString();
@@ -226,9 +226,9 @@ namespace Antlr4.Test.StringTemplate
public void TestParallelAttributeIterationWithMissingArgs()
{
ErrorBuffer errors = new ErrorBuffer();
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.setListener(errors);
-            ST e = new ST(group,
+            Template e = new Template(group,
"<names,phones,salaries:{n,p | <n>@<p>}; separator=\", \">"
);
e.add("names", "Ter");
@@ -250,9 +250,9 @@ namespace Antlr4.Test.StringTemplate
public void TestStringTypeMismatch()
{
ErrorBuffer errors = new ErrorBuffer();
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.setListener(errors);
-            ST e = new ST(group, "<trim(s)>");
+            Template e = new Template(group, "<trim(s)>");
e.add("s", 34);
e.render(); // generate the error
string errorExpecting = "context [anonymous] 1:1 function trim expects a string not System.Int32" + newline;
@@ -263,9 +263,9 @@ namespace Antlr4.Test.StringTemplate
public void TestStringTypeMismatch2()
{
ErrorBuffer errors = new ErrorBuffer();
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.setListener(errors);
-            ST e = new ST(group, "<strlen(s)>");
+            Template e = new Template(group, "<strlen(s)>");
e.add("s", 34);
e.render(); // generate the error
string errorExpecting = "context [anonymous] 1:1 function strlen expects a string not System.Int32" + newline;
diff --git a/Antlr4.Test.StringTemplate/TestLineWrap.cs b/Antlr4.Test.StringTemplate/TestLineWrap.cs
index 9255e2e..cdb710d 100644
--- a/Antlr4.Test.StringTemplate/TestLineWrap.cs
+++ b/Antlr4.Test.StringTemplate/TestLineWrap.cs
@@ -48,9 +48,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"array(values) ::= <<int[] a = { <values; wrap=\"\\n\", separator=\",\"> };>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("array");
+            Template a = group.getInstanceOf("array");
a.add("values",
new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
@@ -75,9 +75,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"array(values) ::= <<int[] a = { <values; anchor, wrap, separator=\",\"> };>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("array");
+            Template a = group.getInstanceOf("array");
a.add("values",
new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
@@ -97,14 +97,14 @@ namespace Antlr4.Test.StringTemplate
string templates =
"array(values) ::= <<{ <values; anchor, separator=\", \"> }>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST x = new ST("<\\n>{ <stuff; anchor, separator=\",\\n\"> }<\\n>");
+            Template x = new Template("<\\n>{ <stuff; anchor, separator=\",\\n\"> }<\\n>");
x.groupThatCreatedThisInstance = group;
x.add("stuff", "1");
x.add("stuff", "2");
x.add("stuff", "3");
-            ST a = group.getInstanceOf("array");
+            Template a = group.getInstanceOf("array");
a.add("values", new List<object>() { "a", x, "b" });
string expecting =
"{ a, " + Environment.NewLine +
@@ -121,9 +121,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"func(args) ::= <<       FUNCTION line( <args; wrap=\"\\n      c\", separator=\",\"> )>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("func");
+            Template a = group.getInstanceOf("func");
a.add("args",
new string[] { "a", "b", "c", "d", "e", "f" });
string expecting =
@@ -138,9 +138,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"array(values) ::= <<int[] a = { <{1,9,2,<values; wrap, separator=\",\">}; anchor> };>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("array");
+            Template a = group.getInstanceOf("array");
a.add("values",
new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
4,9,20,2,1,4,63,9,20,2,1,4,6});
@@ -159,9 +159,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("duh");
+            Template a = group.getInstanceOf("duh");
a.add("chars", new string[] { "a", "b", "c", "d", "e" });
// lineWidth==3 implies that we can have 3 characters at most
string expecting =
@@ -176,9 +176,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("duh");
+            Template a = group.getInstanceOf("duh");
a.add("chars", new string[] { "a", "b", "\n", "d", "e" });
// don't do \n if it's last element anyway
string expecting =
@@ -193,9 +193,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"duh(chars) ::= <<<chars; wrap=\"\\n\"\\>>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("duh");
+            Template a = group.getInstanceOf("duh");
a.add("chars", new string[] { "a", "b", "c", "\n", "d", "e" });
// Once we wrap, we must dump chars as we see them.  A newline right
// after a wrap is just an "unfortunate" event.  People will expect
@@ -213,9 +213,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"duh(data) ::= <<!<data; wrap>!>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("duh");
+            Template a = group.getInstanceOf("duh");
a.add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
string expecting =
"!123" + Environment.NewLine +
@@ -230,9 +230,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"duh(data) ::= <<!<data:{v|[<v>]}; wrap>!>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("duh");
+            Template a = group.getInstanceOf("duh");
a.add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
string expecting =
"![1][2][3]" + Environment.NewLine + // width=9 is the 3 char; don't break til after ]
@@ -247,9 +247,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"duh(data) ::= <<!<data:{v|[<v>]}; anchor, wrap>!>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("duh");
+            Template a = group.getInstanceOf("duh");
a.add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
string expecting =
"![1][2][3]" + Environment.NewLine +
@@ -265,10 +265,10 @@ namespace Antlr4.Test.StringTemplate
"top(s) ::= <<  <s>.>>" +
"str(data) ::= <<!<data:{v|[<v>]}; wrap=\"!+\\n!\">!>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST t = group.getInstanceOf("top");
-            ST s = group.getInstanceOf("str");
+            Template t = group.getInstanceOf("top");
+            Template s = group.getInstanceOf("str");
s.add("data", new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9 });
t.add("s", s);
string expecting =
@@ -286,9 +286,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("duh");
+            Template a = group.getInstanceOf("duh");
a.add("chars", new string[] { "a", "b", "c", "d", "e" });
//
string expecting =
@@ -306,9 +306,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"duh(chars) ::= <<    <chars; wrap=\"\\n\"\\>>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("duh");
+            Template a = group.getInstanceOf("duh");
a.add("chars", new string[] { "a", "b", "c", "d", "e" });
//
string expecting =
@@ -326,10 +326,10 @@ namespace Antlr4.Test.StringTemplate
"top(d) ::= <<  <d>!>>" + newline +
"duh(chars) ::= <<  <chars; wrap=\"\\n\"\\>>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST top = group.getInstanceOf("top");
-            ST duh = group.getInstanceOf("duh");
+            Template top = group.getInstanceOf("top");
+            Template duh = group.getInstanceOf("duh");
duh.add("chars", new string[] { "a", "b", "c", "d", "e" });
top.add("d", duh);
string expecting =
@@ -347,10 +347,10 @@ namespace Antlr4.Test.StringTemplate
"top(d) ::= <<  <d>!>>" + newline +
"duh(chars) ::= <<x: <chars; anchor, wrap=\"\\n\"\\>>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST top = group.getInstanceOf("top");
-            ST duh = group.getInstanceOf("duh");
+            Template top = group.getInstanceOf("top");
+            Template duh = group.getInstanceOf("duh");
duh.add("chars", new string[] { "a", "b", "c", "d", "e" });
top.add("d", duh);
//
@@ -367,9 +367,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"m(args,body) ::= <<[TestMethod] public voidfoo(<args; wrap=\"\\n\",separator=\", \">) throws Ick { <body> }>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST a = group.getInstanceOf("m");
+            Template a = group.getInstanceOf("m");
a.add("args",
new string[] { "a", "b", "c" });
a.add("body", "i=3;");
@@ -386,9 +386,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"m(args,body) ::= <<{ <body; anchor, wrap=\"\\n\"> }>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST m = group.getInstanceOf("m");
+            Template m = group.getInstanceOf("m");
m.add("body", "i=3;");
// make it wrap because of ") throws Ick { " literal
string expecting =
@@ -404,10 +404,10 @@ namespace Antlr4.Test.StringTemplate
"top(arrays) ::= <<Arrays: <arrays>done>>" + newline +
"array(values) ::= <<int[] a = { <values; anchor, wrap=\"\\n\", separator=\",\"> };<\\n\\>>>" + newline;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));

-            ST top = group.getInstanceOf("top");
-            ST a = group.getInstanceOf("array");
+            Template top = group.getInstanceOf("top");
+            Template a = group.getInstanceOf("array");
a.add("values",
new int[] {3,9,20,2,1,4,6,32,5,6,77,888,2,1,6,32,5,6,77,
4,9,20,2,1,4,63,9,20,2,1,4,6,32,5,6,77,6,32,5,6,77,
diff --git a/Antlr4.Test.StringTemplate/TestLists.cs b/Antlr4.Test.StringTemplate/TestLists.cs
index 357429e..d4787ca 100644
--- a/Antlr4.Test.StringTemplate/TestLists.cs
+++ b/Antlr4.Test.StringTemplate/TestLists.cs
@@ -41,7 +41,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestJustCat()
{
-            ST e = new ST(
+            Template e = new Template(
"<[names,phones]>"
);
e.add("names", "Ter");
@@ -55,7 +55,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestListLiteralWithEmptyElements()
{
-            ST e = new ST(
+            Template e = new Template(
"<[\"Ter\",,\"Jesse\"]:{n | <i>:<n>}; separator=\", \", null={foo}>"
);
string expecting = "1:Ter, foo, 2:Jesse";
@@ -65,7 +65,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestListLiteralWithEmptyFirstElement()
{
-            ST e = new ST(
+            Template e = new Template(
"<[,\"Ter\",\"Jesse\"]:{n | <i>:<n>}; separator=\", \", null={foo}>"
);
string expecting = "foo, 1:Ter, 2:Jesse";
@@ -75,7 +75,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLength()
{
-            ST e = new ST(
+            Template e = new Template(
"<length([names,phones])>"
);
e.add("names", "Ter");
@@ -89,7 +89,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestCat2Attributes()
{
-            ST e = new ST(
+            Template e = new Template(
"<[names,phones]; separator=\", \">"
);
e.add("names", "Ter");
@@ -103,7 +103,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestCat2AttributesWithApply()
{
-            ST e = new ST(
+            Template e = new Template(
"<[names,phones]:{a|<a>.}>"
);
e.add("names", "Ter");
@@ -117,7 +117,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestCat3Attributes()
{
-            ST e = new ST(
+            Template e = new Template(
"<[names,phones,salaries]; separator=\", \">"
);
e.add("names", "Ter");
@@ -133,7 +133,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestCatWithTemplateApplicationAsElement()
{
-            ST e = new ST(
+            Template e = new Template(
"<[names:{n|<n>!},phones]; separator=\", \">"
);
e.add("names", "Ter");
@@ -147,7 +147,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestCatWithIFAsElement()
{
-            ST e = new ST(
+            Template e = new Template(
"<[{<if(names)>doh<endif>},phones]; separator=\", \">"
);
e.add("names", "Ter");
@@ -163,7 +163,7 @@ namespace Antlr4.Test.StringTemplate
{
// [a, b] must behave like <a><b>; if a==b==null, blank output
// unless null argument.
-            ST e = new ST(
+            Template e = new Template(
"<[no,go]; null=\"foo\", separator=\", \">"
);
e.add("phones", "1");
@@ -175,7 +175,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestCatWithNullTemplateApplicationAsElement()
{
-            ST e = new ST(
+            Template e = new Template(
"<[names:{n|<n>!},\"foo\"]:{a|x}; separator=\", \">"
);
e.add("phones", "1");
@@ -187,7 +187,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestCatWithNestedTemplateApplicationAsElement()
{
-            ST e = new ST(
+            Template e = new Template(
"<[names, [\"foo\",\"bar\"]:{x | <x>!},phones]; separator=\", \">"
);
e.add("names", "Ter");
@@ -206,8 +206,8 @@ namespace Antlr4.Test.StringTemplate
"foo(items) ::= \"<items:{a | *<a>*}>\"" + newline
;
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
-            ST e = group.getInstanceOf("test");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
+            Template e = group.getInstanceOf("test");
e.add("names", "Ter");
e.add("names", "Tom");
e.add("phones", "1");
diff --git a/Antlr4.Test.StringTemplate/TestModelAdaptors.cs b/Antlr4.Test.StringTemplate/TestModelAdaptors.cs
index af380ce..0b5bc83 100644
--- a/Antlr4.Test.StringTemplate/TestModelAdaptors.cs
+++ b/Antlr4.Test.StringTemplate/TestModelAdaptors.cs
@@ -41,25 +41,25 @@ namespace Antlr4.Test.StringTemplate
{
private class UserAdaptor : IModelAdaptor
{
-            public object GetProperty(ST self, object o, object property, string propertyName)
+            public object GetProperty(Template self, object o, object property, string propertyName)
{
if (propertyName.Equals("id"))
return ((User)o).id;
if (propertyName.Equals("name"))
return ((User)o).Name;
-                throw new STNoSuchPropertyException(null, "User." + propertyName);
+                throw new TemplateNoSuchPropertyException(null, "User." + propertyName);
}
}

private class UserAdaptorConst : IModelAdaptor
{
-            public object GetProperty(ST self, object o, object property, string propertyName)
+            public object GetProperty(Template self, object o, object property, string propertyName)
{
if (propertyName.Equals("id"))
return "const id value";
if (propertyName.Equals("name"))
return "const name value";
-                throw new STNoSuchPropertyException(null, "User." + propertyName);
+                throw new TemplateNoSuchPropertyException(null, "User." + propertyName);
}
}

@@ -90,9 +90,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"foo(x) ::= \"<x.id>: <x.name>\"\n";
writeFile(tmpdir, "foo.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/foo.stg");
group.registerModelAdaptor(typeof(User), new UserAdaptor());
-            ST st = group.getInstanceOf("foo");
+            Template st = group.getInstanceOf("foo");
st.add("x", new User(100, "parrt"));
string expecting = "100: parrt";
string result = st.render();
@@ -106,17 +106,17 @@ namespace Antlr4.Test.StringTemplate
string templates =
"foo(x) ::= \"<x.qqq>\"\n";
writeFile(tmpdir, "foo.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/foo.stg");
group.setListener(errors);
group.registerModelAdaptor(typeof(User), new UserAdaptor());
-            ST st = group.getInstanceOf("foo");
+            Template st = group.getInstanceOf("foo");
st.add("x", new User(100, "parrt"));
string expecting = "";
string result = st.render();
Assert.AreEqual(expecting, result);

-            STRuntimeMessage msg = (STRuntimeMessage)errors.Errors[0];
-            STNoSuchPropertyException e = (STNoSuchPropertyException)msg.Cause;
+            TemplateRuntimeMessage msg = (TemplateRuntimeMessage)errors.Errors[0];
+            TemplateNoSuchPropertyException e = (TemplateNoSuchPropertyException)msg.Cause;
Assert.AreEqual("User.qqq", e.PropertyName);
}

@@ -126,9 +126,9 @@ namespace Antlr4.Test.StringTemplate
string templates =
"foo(x) ::= \"<x.id>: <x.name>\"\n";
writeFile(tmpdir, "foo.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/foo.stg");
group.registerModelAdaptor(typeof(User), new UserAdaptor());
-            ST st = group.getInstanceOf("foo");
+            Template st = group.getInstanceOf("foo");
st.add("x", new SuperUser(100, "parrt")); // create subclass of User
string expecting = "100: super parrt";
string result = st.render();
@@ -141,14 +141,14 @@ namespace Antlr4.Test.StringTemplate
string templates =
"foo(x) ::= \"<x.id>: <x.name>\"\n";
writeFile(tmpdir, "foo.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/foo.stg");
group.registerModelAdaptor(typeof(User), new UserAdaptor());
group.getModelAdaptor(typeof(User)); // get User, SuperUser into cache
group.getModelAdaptor(typeof(SuperUser));

group.registerModelAdaptor(typeof(User), new UserAdaptorConst());
// cache should be reset so we see new adaptor
-            ST st = group.getInstanceOf("foo");
+            Template st = group.getInstanceOf("foo");
st.add("x", new User(100, "parrt"));
string expecting = "const id value: const name value"; // sees UserAdaptorConst
string result = st.render();
@@ -161,10 +161,10 @@ namespace Antlr4.Test.StringTemplate
string templates =
"foo(x) ::= \"<x.id>: <x.name>\"\n";
writeFile(tmpdir, "foo.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/foo.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/foo.stg");
group.registerModelAdaptor(typeof(User), new UserAdaptor());
group.registerModelAdaptor(typeof(SuperUser), new UserAdaptorConst()); // most specific
-            ST st = group.getInstanceOf("foo");
+            Template st = group.getInstanceOf("foo");
st.add("x", new User(100, "parrt"));
string expecting = "100: parrt";
string result = st.render();
diff --git a/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs b/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs
index 14d2ee6..0ec8068 100644
--- a/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs
+++ b/Antlr4.Test.StringTemplate/TestNullAndEmptyValues.cs
@@ -42,9 +42,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparatorWithNullFirstValue()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", null); // null is added to list, but ignored in iteration
st.add("name", "Tom");
st.add("name", "Sumana");
@@ -56,10 +56,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTemplateAppliedToNullIsEmpty()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name:t()>");
group.defineTemplate("t", "x", "<x>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", null); // null is added to list, but ignored in iteration
string expected = "";
string result = st.render();
@@ -69,10 +69,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTemplateAppliedToMissingValueIsEmpty()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name:t()>");
group.defineTemplate("t", "x", "<x>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
string expected = "";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -81,9 +81,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparatorWithNull2ndValue()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", null);
st.add("name", "Sumana");
@@ -95,9 +95,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparatorWithNullLastValue()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", null);
@@ -109,9 +109,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparatorWithTwoNullValuesInRow()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", null);
@@ -125,9 +125,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTwoNullValues()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "hi <name; null=\"x\">!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", null);
st.add("name", null);
string expected = "hi xx!";
@@ -138,9 +138,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNullListItemNotCountedForIteratorIndex()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name:{n | <i>:<n>}>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", null);
st.add("name", null);
@@ -153,12 +153,12 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSizeZeroButNonNullListGetsNoOutput()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "users",
"begin\n" +
"<users>\n" +
"end\n");
-            ST t = group.getInstanceOf("test");
+            Template t = group.getInstanceOf("test");
t.add("users", null);
string expecting = "begin" + newline + "end";
string result = t.render();
@@ -168,12 +168,12 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNullListGetsNoOutput()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "users",
"begin\n" +
"<users:{u | name: <u>}; separator=\", \">\n" +
"end\n");
-            ST t = group.getInstanceOf("test");
+            Template t = group.getInstanceOf("test");
string expecting = "begin" + newline + "end";
string result = t.render();
Assert.AreEqual(expecting, result);
@@ -182,12 +182,12 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestEmptyListGetsNoOutput()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "users",
"begin\n" +
"<users:{u | name: <u>}; separator=\", \">\n" +
"end\n");
-            ST t = group.getInstanceOf("test");
+            Template t = group.getInstanceOf("test");
t.add("users", new List<string>());
string expecting = "begin" + newline + "end";
string result = t.render();
@@ -197,9 +197,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMissingDictionaryValue()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "m", "<m.foo>");
-            ST t = group.getInstanceOf("test");
+            Template t = group.getInstanceOf("test");
t.add("m", new Dictionary<string, string>());
string expecting = "";
string result = t.render();
@@ -209,9 +209,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMissingDictionaryValue2()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "m", "<if(m.foo)>[<m.foo>]<endif>");
-            ST t = group.getInstanceOf("test");
+            Template t = group.getInstanceOf("test");
t.add("m", new Dictionary<string, string>());
string expecting = "";
string result = t.render();
@@ -221,9 +221,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMissingDictionaryValue3()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "m", "<if(m.foo)>[<m.foo>]<endif>");
-            ST t = group.getInstanceOf("test");
+            Template t = group.getInstanceOf("test");
t.add("m", new Dictionary<string, string>() { { "foo", null } });
string expecting = "";
string result = t.render();
diff --git a/Antlr4.Test.StringTemplate/TestOptions.cs b/Antlr4.Test.StringTemplate/TestOptions.cs
index df3857c..90bc5ea 100644
--- a/Antlr4.Test.StringTemplate/TestOptions.cs
+++ b/Antlr4.Test.StringTemplate/TestOptions.cs
@@ -43,9 +43,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparator()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "hi <name; separator=\", \">!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", "Tom");
st.add("name", "Sumana");
@@ -57,9 +57,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestAttrSeparator()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name,sep", "hi <name; separator=sep>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("sep", ", ");
st.add("name", "Ter");
st.add("name", "Tom");
@@ -72,10 +72,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIncludeSeparator()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("foo", "|");
group.defineTemplate("test", "name,sep", "hi <name; separator=foo()>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("sep", ", ");
st.add("name", "Ter");
st.add("name", "Tom");
@@ -88,9 +88,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSubtemplateSeparator()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name,sep", "hi <name; separator={<sep> _}>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("sep", ",");
st.add("name", "Ter");
st.add("name", "Tom");
@@ -103,9 +103,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparatorWithNullFirstValueAndNullOption()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "hi <name; null=\"n/a\", separator=\", \">!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", null);
st.add("name", "Tom");
st.add("name", "Sumana");
@@ -117,9 +117,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSeparatorWithNull2ndValueAndNullOption()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "hi <name; null=\"n/a\", separator=\", \">!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.impl.dump();
st.add("name", "Ter");
st.add("name", null);
@@ -132,9 +132,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNullValueAndNullOption()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name; null=\"n/a\">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", null);
string expected = "n/a";
string result = st.render();
@@ -144,9 +144,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestListApplyWithNullValueAndNullOption()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name:{n | <n>}; null=\"n/a\">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", null);
st.add("name", "Sumana");
@@ -158,12 +158,12 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestDoubleListApplyWithNullValueAndNullOption()
{
-            // first apply sends [ST, null, ST] to second apply, which puts [] around
+            // first apply sends [Template, null, Template] to second apply, which puts [] around
// the value.  This verifies that null not blank comes out of first apply
// since we don't get [null].
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name:{n | <n>}:{n | [<n>]}; null=\"n/a\">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
st.add("name", null);
st.add("name", "Sumana");
@@ -175,9 +175,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMissingValueAndNullOption()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "name", "<name; null=\"n/a\">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
string expected = "n/a";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -186,10 +186,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestOptionDoesntApplyToNestedTemplate()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("foo", "<zippo>");
group.defineTemplate("test", "zippo", "<foo(); null=\"n/a\">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("zippo", null);
string expected = "";
string result = st.render();
@@ -200,10 +200,10 @@ namespace Antlr4.Test.StringTemplate
public void TestIllegalOption()
{
ErrorBuffer errors = new ErrorBuffer();
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.setListener(errors);
group.defineTemplate("test", "name", "<name; bad=\"ugly\">");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("name", "Ter");
string expected = "Ter";
string result = st.render();
diff --git a/Antlr4.Test.StringTemplate/TestRegions.cs b/Antlr4.Test.StringTemplate/TestRegions.cs
index 78c8f49..600fdb5 100644
--- a/Antlr4.Test.StringTemplate/TestRegions.cs
+++ b/Antlr4.Test.StringTemplate/TestRegions.cs
@@ -48,8 +48,8 @@ namespace Antlr4.Test.StringTemplate
"[<@r>bar<@end>]\n" +
">>\n";
writeFile(dir, "group.stg", groupFile);
-            STGroup group = new STGroupFile(dir + "/group.stg");
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupFile(dir + "/group.stg");
+            Template st = group.getInstanceOf("a");
string expected = "[bar]";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -64,8 +64,8 @@ namespace Antlr4.Test.StringTemplate
"[<@r()>]\n" +
">>\n";
writeFile(dir, "group.stg", groupFile);
-            STGroup group = new STGroupFile(dir + "/group.stg");
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupFile(dir + "/group.stg");
+            Template st = group.getInstanceOf("a");
string expected = "[]";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -80,10 +80,10 @@ namespace Antlr4.Test.StringTemplate
string g2 = "@a.r() ::= <<foo>>\n";
writeFile(dir, "g2.stg", g2);

-            STGroup group1 = new STGroupFile(dir + "/g1.stg");
-            STGroup group2 = new STGroupFile(dir + "/g2.stg");
+            TemplateGroup group1 = new TemplateGroupFile(dir + "/g1.stg");
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/g2.stg");
group2.importTemplates(group1); // define r in g2
-            ST st = group2.getInstanceOf("a");
+            Template st = group2.getInstanceOf("a");
string expected = "[foo]";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -98,10 +98,10 @@ namespace Antlr4.Test.StringTemplate
string g2 = "@a.r() ::= <<(<@super.r()>)>>\n";
writeFile(dir, "g2.stg", g2);

-            STGroup group1 = new STGroupFile(dir + "/g1.stg");
-            STGroup group2 = new STGroupFile(dir + "/g2.stg");
+            TemplateGroup group1 = new TemplateGroupFile(dir + "/g1.stg");
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/g2.stg");
group2.importTemplates(group1); // define r in g2
-            ST st = group2.getInstanceOf("a");
+            Template st = group2.getInstanceOf("a");
string expected = "[(foo)]";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -116,10 +116,10 @@ namespace Antlr4.Test.StringTemplate
string g2 = "@a.r() ::= <<foo>>>\n";
writeFile(dir, "g2.stg", g2);

-            STGroup group1 = new STGroupFile(dir + "/g1.stg");
-            STGroup group2 = new STGroupFile(dir + "/g2.stg");
+            TemplateGroup group1 = new TemplateGroupFile(dir + "/g1.stg");
+            TemplateGroup group2 = new TemplateGroupFile(dir + "/g2.stg");
group1.importTemplates(group2); // opposite of previous; g1 imports g2
-            ST st = group1.getInstanceOf("a");
+            Template st = group1.getInstanceOf("a");
string expected = "[]"; // @a.r implicitly defined in g1; can't see g2's
string result = st.render();
Assert.AreEqual(expected, result);
@@ -133,8 +133,8 @@ namespace Antlr4.Test.StringTemplate
"@a.r() ::= <<foo>>\n";
writeFile(dir, "g.stg", g);

-            STGroup group = new STGroupFile(dir + "/g.stg");
-            ST st = group.getInstanceOf("a");
+            TemplateGroup group = new TemplateGroupFile(dir + "/g.stg");
+            Template st = group.getInstanceOf("a");
string expected = "[foo]";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -148,7 +148,7 @@ namespace Antlr4.Test.StringTemplate
"@a.r() ::= <<bar>>\n"; // error; dup
writeFile(dir, "g.stg", g);

-            STGroupFile group = new STGroupFile(dir + "/g.stg");
+            TemplateGroupFile group = new TemplateGroupFile(dir + "/g.stg");
ErrorBuffer errors = new ErrorBuffer();
group.setListener(errors);
group.load();
@@ -167,15 +167,15 @@ namespace Antlr4.Test.StringTemplate
"a() ::= \"X<@r()>Y\"" +
"@a.r() ::= \"foo\"" + newline;
writeFile(dir, "g.stg", g);
-            STGroupFile group = new STGroupFile(dir + "/g.stg");
+            TemplateGroupFile group = new TemplateGroupFile(dir + "/g.stg");

string sub =
"@a.r() ::= \"A<@super.r()>B\"" + newline;
writeFile(dir, "sub.stg", sub);
-            STGroupFile subGroup = new STGroupFile(dir + "/sub.stg");
+            TemplateGroupFile subGroup = new TemplateGroupFile(dir + "/sub.stg");
subGroup.importTemplates(group);

-            ST st = subGroup.getInstanceOf("a");
+            Template st = subGroup.getInstanceOf("a");
string result = st.render();
string expecting = "XAfooBY";
Assert.AreEqual(expecting, result);
@@ -202,21 +202,21 @@ namespace Antlr4.Test.StringTemplate
"a() ::= \"X<@r()>Y\"" +
"@a.r() ::= \"foo\"" + newline;
writeFile(dir, "g.stg", g);
-            STGroupFile group = new STGroupFile(dir + "/g.stg");
+            TemplateGroupFile group = new TemplateGroupFile(dir + "/g.stg");

string sub =
"@a.r() ::= \"<@super.r()>2\"" + newline;
writeFile(dir, "sub.stg", sub);
-            STGroupFile subGroup = new STGroupFile(dir + "/sub.stg");
+            TemplateGroupFile subGroup = new TemplateGroupFile(dir + "/sub.stg");
subGroup.importTemplates(group);

string subsub =
"@a.r() ::= \"<@super.r()>3\"" + newline;
writeFile(dir, "subsub.stg", subsub);
-            STGroupFile subSubGroup = new STGroupFile(dir + "/subsub.stg");
+            TemplateGroupFile subSubGroup = new TemplateGroupFile(dir + "/subsub.stg");
subSubGroup.importTemplates(subGroup);

-            ST st = subSubGroup.getInstanceOf("a");
+            Template st = subSubGroup.getInstanceOf("a");

string result = st.render();
string expecting = "Xfoo23Y";
@@ -230,15 +230,15 @@ namespace Antlr4.Test.StringTemplate
string g =
"a() ::= \"X<@r>foo<@end>Y\"" + newline;
writeFile(dir, "g.stg", g);
-            STGroupFile group = new STGroupFile(dir + "/g.stg");
+            TemplateGroupFile group = new TemplateGroupFile(dir + "/g.stg");

string sub =
"@a.r() ::= \"A<@super.r()>\"" + newline;
writeFile(dir, "sub.stg", sub);
-            STGroupFile subGroup = new STGroupFile(dir + "/sub.stg");
+            TemplateGroupFile subGroup = new TemplateGroupFile(dir + "/sub.stg");
subGroup.importTemplates(group);

-            ST st = subGroup.getInstanceOf("a");
+            Template st = subGroup.getInstanceOf("a");
string result = st.render();
string expecting = "XAfooY";
Assert.AreEqual(expecting, result);
@@ -255,9 +255,9 @@ namespace Antlr4.Test.StringTemplate
"@a.q() ::= \"foo\"" + newline;
ITemplateErrorListener errors = new ErrorBuffer();
writeFile(dir, "g.stg", g);
-            STGroupFile group = new STGroupFile(dir + "/g.stg");
+            TemplateGroupFile group = new TemplateGroupFile(dir + "/g.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("a");
+            Template st = group.getInstanceOf("a");
st.render();
string result = errors.ToString();
string expecting = "g.stg 3:3: template a doesn't have a region called q" + newline;
@@ -272,17 +272,17 @@ namespace Antlr4.Test.StringTemplate
"a() ::= \"X<@r()>Y\"" +
"@a.r() ::= \"foo\"" + newline;
writeFile(dir, "g.stg", g);
-            STGroupFile group = new STGroupFile(dir + "/g.stg");
+            TemplateGroupFile group = new TemplateGroupFile(dir + "/g.stg");

string sub =
"@a.r() ::= \"A<@super.q()>B\"" + newline; // allow this; trap at runtime
ITemplateErrorListener errors = new ErrorBuffer();
group.setListener(errors);
writeFile(dir, "sub.stg", sub);
-            STGroupFile subGroup = new STGroupFile(dir + "/sub.stg");
+            TemplateGroupFile subGroup = new TemplateGroupFile(dir + "/sub.stg");
subGroup.importTemplates(group);

-            ST st = subGroup.getInstanceOf("a");
+            Template st = subGroup.getInstanceOf("a");
string result = st.render();
string expecting = "XABY";
Assert.AreEqual(expecting, result);
diff --git a/Antlr4.Test.StringTemplate/TestRenderers.cs b/Antlr4.Test.StringTemplate/TestRenderers.cs
index e10b90c..d0ddf46 100644
--- a/Antlr4.Test.StringTemplate/TestRenderers.cs
+++ b/Antlr4.Test.StringTemplate/TestRenderers.cs
@@ -141,9 +141,9 @@ namespace Antlr4.Test.StringTemplate
"foo(x) ::= << <x; format=\"{0,6}\"> >>\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
group.registerRenderer(typeof(string), new StringRenderer());
-            ST st = group.getInstanceOf("foo");
+            Template st = group.getInstanceOf("foo");
st.add("x", "hi");
string expecting = "     hi ";
string result = st.render();
@@ -155,9 +155,9 @@ namespace Antlr4.Test.StringTemplate
{
string template =
"The names: <names; format=\"upper\">";
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.registerRenderer(typeof(string), new StringRenderer());
-            ST st = new ST(template);
+            Template st = new Template(template);
st.groupThatCreatedThisInstance = group;
st.add("names", "ter");
st.add("names", "tom");
@@ -172,9 +172,9 @@ namespace Antlr4.Test.StringTemplate
{
string template =
"The names: <names; separator=\" and \", format=\"upper\">";
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.registerRenderer(typeof(string), new StringRenderer());
-            ST st = new ST(template);
+            Template st = new Template(template);
st.groupThatCreatedThisInstance = group;
st.add("names", "ter");
st.add("names", "tom");
@@ -189,9 +189,9 @@ namespace Antlr4.Test.StringTemplate
{
string template =
"The names: <names; separator=\" and \", null=\"n/a\", format=\"upper\">";
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.registerRenderer(typeof(string), new StringRenderer());
-            ST st = new ST(template);
+            Template st = new Template(template);
st.groupThatCreatedThisInstance = group;
List<string> names = new List<string>();
names.Add("ter");
@@ -210,10 +210,10 @@ namespace Antlr4.Test.StringTemplate
string templates = "foo(x,y) ::= << <x; format=\"{0}\"> <y; format=\"{0:0.000}\"> >>\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
group.registerRenderer(typeof(int), new NumberRenderer());
group.registerRenderer(typeof(double), new NumberRenderer());
-            ST st = group.getInstanceOf("foo");
+            Template st = group.getInstanceOf("foo");
st.add("x", -2100);
st.add("y", 3.14159);
string expecting = " -2100 3.142 ";
@@ -227,10 +227,10 @@ namespace Antlr4.Test.StringTemplate
string templates =
"numberThing(x,y,z) ::= \"numbers: <x>, <y>; <z>\"\n";
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
group.registerRenderer(typeof(int), new NumberRenderer());
group.registerRenderer(typeof(double), new NumberRenderer());
-            ST st = group.getInstanceOf("numberThing");
+            Template st = group.getInstanceOf("numberThing");
st.add("x", -2100);
st.add("y", 3.14159);
st.add("z", "hi");
@@ -246,10 +246,10 @@ namespace Antlr4.Test.StringTemplate
string templates = "foo(x,y) ::= << <x; format=\"{0:#,#}\"> <y; format=\"{0:0.000}\"> >>\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/t.stg");
group.registerRenderer(typeof(int), new NumberRenderer());
group.registerRenderer(typeof(double), new NumberRenderer());
-            ST st = group.getInstanceOf("foo");
+            Template st = group.getInstanceOf("foo");
st.add("x", -2100);
st.add("y", 3.14159);
// Polish uses '?' (ASCII 160) for ',' and ',' for '.'
diff --git a/Antlr4.Test.StringTemplate/TestScopes.cs b/Antlr4.Test.StringTemplate/TestScopes.cs
index a56c7d0..4619a62 100644
--- a/Antlr4.Test.StringTemplate/TestScopes.cs
+++ b/Antlr4.Test.StringTemplate/TestScopes.cs
@@ -47,9 +47,9 @@ namespace Antlr4.Test.StringTemplate
"u() ::= \"<x><y>\"";
ErrorBuffer errors = new ErrorBuffer();
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.add("x", "x");
st.add("y", "y");
string result = st.render();
@@ -69,9 +69,9 @@ namespace Antlr4.Test.StringTemplate
"u(z) ::= \"\"";
ErrorBuffer errors = new ErrorBuffer();
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
string result = st.render();

string expectedError = "context [t] 1:1 passed 0 arg(s) to template u with 1 declared arg(s)" + newline;
@@ -85,9 +85,9 @@ namespace Antlr4.Test.StringTemplate
"t() ::= \"<x>\"\n";
ErrorBuffer errors = new ErrorBuffer();
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
string result = st.render();

string expectedError = "context [t] 1:1 attribute x isn't defined" + newline;
@@ -102,9 +102,9 @@ namespace Antlr4.Test.StringTemplate
"u(y) ::= \"<x><y>\"";
ErrorBuffer errors = new ErrorBuffer();
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.add("x", "x");
st.add("y", "y");
string result = st.render();
@@ -125,9 +125,9 @@ namespace Antlr4.Test.StringTemplate
"u(x) ::= \"<i>:<x>\"";
ErrorBuffer errors = new ErrorBuffer();
writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
-            ST st = group.getInstanceOf("t");
+            Template st = group.getInstanceOf("t");
st.add("names", "Ter");
string result = st.render();
group.getInstanceOf("u").impl.dump();
diff --git a/Antlr4.Test.StringTemplate/TestSubtemplates.cs b/Antlr4.Test.StringTemplate/TestSubtemplates.cs
index 017d677..8191591 100644
--- a/Antlr4.Test.StringTemplate/TestSubtemplates.cs
+++ b/Antlr4.Test.StringTemplate/TestSubtemplates.cs
@@ -43,9 +43,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSimpleIteration()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{n|<n>}>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -57,9 +57,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestMapIterationIsByKeys()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "emails", "<emails:{n|<n>}>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
IDictionary<string, string> emails = new Dictionary<string, string>();
emails["parrt"] = "Ter";
emails["tombu"] = "Tom";
@@ -73,9 +73,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSimpleIterationWithArg()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{n | <n>}>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -87,9 +87,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNestedIterationWithArg()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "users", "<users:{u | <u.id:{id | <id>=}><u.name>}>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("users", new TestCoreBasics.User(1, "parrt"));
st.add("users", new TestCoreBasics.User(2, "tombu"));
st.add("users", new TestCoreBasics.User(3, "sri"));
@@ -101,7 +101,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelAttributeIteration()
{
-            ST e = new ST(
+            Template e = new Template(
"<names,phones,salaries:{n,p,s | <n>@<p>: <s>\n}>"
);
e.add("names", "Ter");
@@ -117,7 +117,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelAttributeIterationWithNullValue()
{
-            ST e = new ST(
+            Template e = new Template(
"<names,phones,salaries:{n,p,s | <n>@<p>: <s>\n}>"
);
e.add("names", "Ter");
@@ -136,7 +136,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelAttributeIterationHasI()
{
-            ST e = new ST(
+            Template e = new Template(
"<names,phones,salaries:{n,p,s | <i0>. <n>@<p>: <s>\n}>"
);
e.add("names", "Ter");
@@ -154,7 +154,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelAttributeIterationWithDifferentSizes()
{
-            ST e = new ST(
+            Template e = new Template(
"<names,phones,salaries:{n,p,s | <n>@<p>: <s>}; separator=\", \">"
);
e.add("names", "Ter");
@@ -170,7 +170,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestParallelAttributeIterationWithSingletons()
{
-            ST e = new ST(
+            Template e = new Template(
"<names,phones,salaries:{n,p,s | <n>@<p>: <s>}; separator=\", \">"
);
e.add("names", "Ter");
@@ -189,8 +189,8 @@ namespace Antlr4.Test.StringTemplate
"value(x) ::= \"<if(!x)>n/a<else><x><endif>\"" + newline;
writeFile(tmpdir, "g.stg", templates);

-            STGroup group = new STGroupFile(tmpdir + "/g.stg");
-            ST p = group.getInstanceOf("page");
+            TemplateGroup group = new TemplateGroupFile(tmpdir + "/g.stg");
+            Template p = group.getInstanceOf("page");
p.add("names", "Ter");
p.add("names", "Tom");
p.add("names", "Sriram");
@@ -205,16 +205,16 @@ namespace Antlr4.Test.StringTemplate
public void TestEvalSTIteratingSubtemplateInSTFromAnotherGroup()
{
ErrorBuffer errors = new ErrorBuffer();
-            STGroup innerGroup = new STGroup();
+            TemplateGroup innerGroup = new TemplateGroup();
innerGroup.setListener(errors);
innerGroup.defineTemplate("test", "m", "<m:samegroup()>");
innerGroup.defineTemplate("samegroup", "x", "hi ");
-            ST st = innerGroup.getInstanceOf("test");
+            Template st = innerGroup.getInstanceOf("test");
st.add("m", new int[] { 1, 2, 3 });

-            STGroup outerGroup = new STGroup();
+            TemplateGroup outerGroup = new TemplateGroup();
outerGroup.defineTemplate("errorMessage", "x", "<x>");
-            ST outerST = outerGroup.getInstanceOf("errorMessage");
+            Template outerST = outerGroup.getInstanceOf("errorMessage");
outerST.add("x", st);

string expected = "hi hi hi ";
@@ -229,16 +229,16 @@ namespace Antlr4.Test.StringTemplate
public void TestEvalSTIteratingSubtemplateInSTFromAnotherGroupSingleValue()
{
ErrorBuffer errors = new ErrorBuffer();
-            STGroup innerGroup = new STGroup();
+            TemplateGroup innerGroup = new TemplateGroup();
innerGroup.setListener(errors);
innerGroup.defineTemplate("test", "m", "<m:samegroup()>");
innerGroup.defineTemplate("samegroup", "x", "hi ");
-            ST st = innerGroup.getInstanceOf("test");
+            Template st = innerGroup.getInstanceOf("test");
st.add("m", 10);

-            STGroup outerGroup = new STGroup();
+            TemplateGroup outerGroup = new TemplateGroup();
outerGroup.defineTemplate("errorMessage", "x", "<x>");
-            ST outerST = outerGroup.getInstanceOf("errorMessage");
+            Template outerST = outerGroup.getInstanceOf("errorMessage");
outerST.add("x", st);

string expected = "hi ";
@@ -253,16 +253,16 @@ namespace Antlr4.Test.StringTemplate
public void TestEvalSTFromAnotherGroup()
{
ErrorBuffer errors = new ErrorBuffer();
-            STGroup innerGroup = new STGroup();
+            TemplateGroup innerGroup = new TemplateGroup();
innerGroup.setListener(errors);
innerGroup.defineTemplate("bob", "inner");
-            ST st = innerGroup.getInstanceOf("bob");
+            Template st = innerGroup.getInstanceOf("bob");

-            STGroup outerGroup = new STGroup();
+            TemplateGroup outerGroup = new TemplateGroup();
outerGroup.setListener(errors);
outerGroup.defineTemplate("errorMessage", "x", "<x>");
outerGroup.defineTemplate("bob", "outer"); // should not be visible to test() in innerGroup
-            ST outerST = outerGroup.getInstanceOf("errorMessage");
+            Template outerST = outerGroup.getInstanceOf("errorMessage");
outerST.add("x", st);

string expected = "inner";
diff --git a/Antlr4.Test.StringTemplate/TestSyntaxErrors.cs b/Antlr4.Test.StringTemplate/TestSyntaxErrors.cs
index 5485bc1..ce2c849 100644
--- a/Antlr4.Test.StringTemplate/TestSyntaxErrors.cs
+++ b/Antlr4.Test.StringTemplate/TestSyntaxErrors.cs
@@ -40,14 +40,14 @@ namespace Antlr4.Test.StringTemplate
public void TestEmptyExpr()
{
string template = " <> ";
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
ErrorBuffer errors = new ErrorBuffer();
group.setListener(errors);
try
{
group.defineTemplate("test", template);
}
-            catch (STException)
+            catch (TemplateException)
{
}
string result = errors.ToString();
@@ -59,14 +59,14 @@ namespace Antlr4.Test.StringTemplate
public void TestEmptyExpr2()
{
string template = "hi <> ";
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
ErrorBuffer errors = new ErrorBuffer();
group.setListener(errors);
try
{
group.defineTemplate("test", template);
}
-            catch (STException)
+            catch (TemplateException)
{
}
string result = errors.ToString();
@@ -78,14 +78,14 @@ namespace Antlr4.Test.StringTemplate
public void TestWeirdChar()
{
string template = "   <*>";
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
ErrorBuffer errors = new ErrorBuffer();
group.setListener(errors);
try
{
group.defineTemplate("test", template);
}
-            catch (STException)
+            catch (TemplateException)
{
}
string result = errors.ToString();
@@ -102,7 +102,7 @@ namespace Antlr4.Test.StringTemplate
writeFile(tmpdir, "t.stg", templates);

ITemplateErrorListener errors = new ErrorBuffer();
-            STGroupFile group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroupFile group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:15: doesn't look like an expression" + newline;
@@ -119,7 +119,7 @@ namespace Antlr4.Test.StringTemplate
writeFile(tmpdir, "t.stg", templates);

ErrorBuffer errors = new ErrorBuffer();
-            STGroupFile group = new STGroupFile(tmpdir + "/" + "t.stg");
+            TemplateGroupFile group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "[t.stg 1:15: \\n in string, t.stg 1:14: doesn't look like an expression]";
@@ -134,9 +134,9 @@ namespace Antlr4.Test.StringTemplate
"foo() ::= \"hi <name:{[<aaa.bb!>]}> mom\"\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:29: '!' came as a complete surprise to me" + newline;
@@ -151,9 +151,9 @@ namespace Antlr4.Test.StringTemplate
"foo() ::= \"hi <name:{x|[<aaa.bb>]}\"\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:34: premature EOF" + newline;
@@ -168,9 +168,9 @@ namespace Antlr4.Test.StringTemplate
"foo() ::= \"hi <foo(>\"\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:19: '>' came as a complete surprise to me" + newline;
@@ -185,9 +185,9 @@ namespace Antlr4.Test.StringTemplate
"foo() ::= \"<a,b:t(),u()>\"\n";
writeFile(tmpdir, "t.stg", templates);

-            STGroupFile group = null;
+            TemplateGroupFile group = null;
ITemplateErrorListener errors = new ErrorBuffer();
-            group = new STGroupFile(tmpdir + "/" + "t.stg");
+            group = new TemplateGroupFile(tmpdir + "/" + "t.stg");
group.setListener(errors);
group.load(); // force load
string expected = "t.stg 1:19: mismatched input ',' expecting RDELIM" + newline;
diff --git a/Antlr4.Test.StringTemplate/TestVisualizer.cs b/Antlr4.Test.StringTemplate/TestVisualizer.cs
index c60219b..70bbb46 100644
--- a/Antlr4.Test.StringTemplate/TestVisualizer.cs
+++ b/Antlr4.Test.StringTemplate/TestVisualizer.cs
@@ -63,23 +63,23 @@ namespace Antlr4.Test.StringTemplate
"paren(x) ::= \"(<x>)\"\n";

writeFile(tmpdir, "t.stg", templates);
-            STGroup group = new STGroupFile(Path.Combine(tmpdir, "t.stg"));
-            STGroup.debug = true;
+            TemplateGroup group = new TemplateGroupFile(Path.Combine(tmpdir, "t.stg"));
+            TemplateGroup.debug = true;
DebugST st = (DebugST)group.getInstanceOf("method");
st.impl.dump();
st.add("type", "float");
st.add("name", "foo");
st.add("locals", 3);
st.add("args", new String[] { "x", "y", "z" });
-            ST s1 = group.getInstanceOf("assign");
-            ST paren = group.getInstanceOf("paren");
+            Template s1 = group.getInstanceOf("assign");
+            Template paren = group.getInstanceOf("paren");
paren.add("x", "x");
s1.add("a", paren);
s1.add("b", "y");
-            ST s2 = group.getInstanceOf("assign");
+            Template s2 = group.getInstanceOf("assign");
s2.add("a", "y");
s2.add("b", "z");
-            ST s3 = group.getInstanceOf("return");
+            Template s3 = group.getInstanceOf("return");
s3.add("x", "3.14159");
st.add("stats", s1);
st.add("stats", s2);
diff --git a/Antlr4.Test.StringTemplate/TestWhitespace.cs b/Antlr4.Test.StringTemplate/TestWhitespace.cs
index 5fc3aec..0fe8d58 100644
--- a/Antlr4.Test.StringTemplate/TestWhitespace.cs
+++ b/Antlr4.Test.StringTemplate/TestWhitespace.cs
@@ -43,9 +43,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTrimmedSubtemplates()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{n | <n>}>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -57,10 +57,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTrimmedSubtemplatesNoArgs()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "[<foo({ foo })>]");
group.defineTemplate("foo", "x", "<x>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
string expected = "[ foo ]";
string result = st.render();
Assert.AreEqual(expected, result);
@@ -69,9 +69,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTrimmedSubtemplatesArgs()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{x|  foo }>");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -83,9 +83,9 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTrimJustOneWSInSubtemplates()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{n |  <n> }>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -97,10 +97,10 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestTrimNewlineInSubtemplates()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{n |\n" +
"<n>}>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -112,11 +112,11 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLeaveNewlineOnEndInSubtemplates()
{
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "<names:{n |\n" +
"<n>\n" +
"}>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -129,11 +129,11 @@ namespace Antlr4.Test.StringTemplate
public void TestTabBeforeEndInSubtemplates()
{
// fails since it counts indent from outer too
-            STGroup group = new STGroup();
+            TemplateGroup group = new TemplateGroup();
group.defineTemplate("test", "names", "  <names:{n |\n" +
"    <n>\n" +
"  }>!");
-            ST st = group.getInstanceOf("test");
+            Template st = group.getInstanceOf("test");
st.add("names", "Ter");
st.add("names", "Tom");
st.add("names", "Sumana");
@@ -150,7 +150,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestEmptyExprAsFirstLineGetsNoOutput()
{
-            ST t = new ST(
+            Template t = new Template(
"<users>\n" +
"end\n");
string expecting = "end" + newline;
@@ -161,7 +161,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestEmptyLineWithIndent()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"    \n" +
"end\n");
@@ -173,7 +173,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestEmptyLine()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"\n" +
"end\n");
@@ -185,7 +185,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSizeZeroOnLineByItselfGetsNoOutput()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"<name>\n" +
"<users>\n" +
@@ -199,7 +199,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSizeZeroOnLineWithIndentGetsNoOutput()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"  <name>\n" +
"	<users>\n" +
@@ -213,7 +213,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestSizeZeroOnLineWithMultipleExpr()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"  <name>\n" +
"	<users><users>\n" +
@@ -226,7 +226,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIFExpr()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"<if(x)><endif>\n" +
"end\n");
@@ -238,7 +238,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIndentedIFExpr()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"    <if(x)><endif>\n" +
"end\n");
@@ -250,7 +250,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIFElseExpr()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"<if(users)><else><endif>\n" +
"end\n");
@@ -262,7 +262,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestIFOnMultipleLines()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"<if(users)>\n" +
"foo\n" +
@@ -278,7 +278,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNestedIFOnMultipleLines()
{
-            ST t = new ST(
+            Template t = new Template(
"begin\n" +
"<if(x)>\n" +
"<if(y)>\n" +
@@ -297,7 +297,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLineBreak()
{
-            ST st = new ST(
+            Template st = new Template(
"Foo <\\\\>" + newline +
"  \t  bar" + newline
);
@@ -311,7 +311,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLineBreak2()
{
-            ST st = new ST(
+            Template st = new Template(
"Foo <\\\\>       " + newline +
"  \t  bar" + newline
);
@@ -325,7 +325,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestLineBreakNoWhiteSpace()
{
-            ST st = new ST(
+            Template st = new Template(
"Foo <\\\\>" + newline +
"bar\n"
);
@@ -339,7 +339,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNewlineNormalizationInTemplateString()
{
-            ST st = new ST(
+            Template st = new Template(
"Foo\r\n" +
"Bar\n"
);
@@ -353,7 +353,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNewlineNormalizationInTemplateStringPC()
{
-            ST st = new ST(
+            Template st = new Template(
"Foo\r\n" +
"Bar\n"
);
@@ -367,7 +367,7 @@ namespace Antlr4.Test.StringTemplate
[TestMethod]
public void TestNewlineNormalizationInAttribute()
{
-            ST st = new ST(
+            Template st = new Template(
"Foo\r\n" +
"<name>\n"
);

