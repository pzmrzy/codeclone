commit 8fc6a13b3e78c73b0f37a0ea8f403641c7917da5
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun Apr 3 08:31:30 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun Apr 3 08:31:30 2011 -0800

(C# 3) Merge CL7906

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 8030]

diff --git a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
index d5aa45c..6f06c84 100644
--- a/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
+++ b/Antlr4.StringTemplate/Antlr4.StringTemplate.csproj
@@ -44,6 +44,7 @@
<Reference Include="System.Xml" />
</ItemGroup>
<ItemGroup>
+    <Compile Include="Debug\IndentEvent.cs" />
<Compile Include="Extensions\ExceptionExtensions.cs" />
<Compile Include="IAttributeRenderer.cs" />
<Compile Include="AutoIndentWriter.cs" />
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3 b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
index 23bc0ee..f8da1c8 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3
@@ -74,9 +74,9 @@ chunk
;

element
-	:	^(INDENT compoundElement[$INDENT.text])
+	:	^(INDENT compoundElement[$INDENT])
|	compoundElement[null]
-	|	^(INDENT {Indent($INDENT.text);} singleElement {Dedent();})
+	|	^(INDENT {Indent($INDENT);} singleElement {Dedent();})
|	singleElement
;

@@ -90,7 +90,7 @@ singleElement
|	NEWLINE {emit(Bytecode.INSTR_NEWLINE);}
;

-compoundElement[string indent]
+compoundElement[CommonTree indent]
:	ifstat[$indent]
|	region[$indent]
;
@@ -101,9 +101,9 @@ exprElement
{emit($EXPR, op);}
;

-region[string indent] returns [string name]
-@init {if (!string.IsNullOrEmpty($indent)) Indent($indent);}
-@after {if (!string.IsNullOrEmpty($indent)) Dedent();}
+region[CommonTree indent] returns [string name]
+@init {if ($indent != null) Indent($indent);}
+@after {if ($indent != null) Dedent();}
:	^(	REGION ID
{$name = TemplateGroup.GetMangledRegionName(outermostTemplateName, $ID.text);}
template[$name,null]
@@ -142,7 +142,7 @@ subtemplate returns [string name, int nargs]
)
;

-ifstat[string indent]
+ifstat[CommonTree indent]
@init {
///** Tracks address of branch operand (in code block).  It's how
//	*  we backpatch forward references when generating code for IFs.
@@ -152,10 +152,10 @@ ifstat[string indent]
//	*  We need to update them once we see the endif.
//	*/
List<int> endRefs = new List<int>();
-	if (!string.IsNullOrEmpty($indent)) Indent($indent);
+	if ($indent != null) Indent($indent);
}
@after {
-	if (!string.IsNullOrEmpty($indent)) Dedent();
+	if ($indent != null) Dedent();
}
:	^(	i='if' conditional
{
diff --git a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
index a8b4c97..8dd2bc3 100644
--- a/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
+++ b/Antlr4.StringTemplate/Compiler/CodeGenerator.g3.cs
@@ -116,9 +116,9 @@ namespace Antlr4.StringTemplate.Compiler
CompilationState.Emit(opAST, opcode);
}

-        private void Indent(string text)
+        private void Indent(CommonTree indent)
{
-            CompilationState.Indent(text);
+            CompilationState.Indent(indent);
}

private void Dedent()
diff --git a/Antlr4.StringTemplate/Compiler/CompilationState.cs b/Antlr4.StringTemplate/Compiler/CompilationState.cs
index ade7b8c..e37b83b 100644
--- a/Antlr4.StringTemplate/Compiler/CompilationState.cs
+++ b/Antlr4.StringTemplate/Compiler/CompilationState.cs
@@ -32,10 +32,10 @@

namespace Antlr4.StringTemplate.Compiler
{
-    using Array = System.Array;
using Antlr.Runtime;
using Antlr.Runtime.Tree;
using Antlr4.StringTemplate.Misc;
+    using Array = System.Array;

/** temp data used during construction and functions that fill it / use it.
*  Result is impl CompiledTemplate object.
@@ -205,9 +205,9 @@ namespace Antlr4.StringTemplate.Compiler
}
}

-        public virtual void Indent(string indent)
+        public virtual void Indent(CommonTree indent)
{
-            Emit1(null, Bytecode.INSTR_INDENT, indent);
+            Emit1(indent, Bytecode.INSTR_INDENT, indent.Text);
}

/** Write value at index into a byte array highest to lowest byte,
diff --git a/Antlr4.StringTemplate/Compiler/TemplateLexer.cs b/Antlr4.StringTemplate/Compiler/TemplateLexer.cs
index 63d774c..f308db2 100644
--- a/Antlr4.StringTemplate/Compiler/TemplateLexer.cs
+++ b/Antlr4.StringTemplate/Compiler/TemplateLexer.cs
@@ -35,10 +35,8 @@ namespace Antlr4.StringTemplate.Compiler
using System.Collections.Generic;
using Antlr.Runtime;
using Antlr4.StringTemplate.Misc;
-    using Exception = System.Exception;
using NumberStyles = System.Globalization.NumberStyles;
using StringBuilder = System.Text.StringBuilder;
-    using StringComparison = System.StringComparison;

/** This class represents the tokenizer for templates. It operates in two modes:
*  inside and outside of expressions. It behaves like an ANTLR TokenSource,
@@ -494,8 +492,13 @@ namespace Antlr4.StringTemplate.Compiler

private IToken ESCAPE()
{
+            startCharIndex = input.Index;
+            startCharPositionInLine = input.CharPositionInLine;
consume(); // kill \\
-            IToken t = null;
+            if (c == 'u')
+                return UNICODE();
+
+            string text = null;
switch (c)
{
case '\\':
@@ -503,28 +506,27 @@ namespace Antlr4.StringTemplate.Compiler
return SKIP;

case 'n':
-                t = newToken(TEXT, "\n", input.CharPositionInLine - 2);
+                text = "\n";
break;

case 't':
-                t = newToken(TEXT, "\t", input.CharPositionInLine - 2);
+                text = "\t";
break;

case ' ':
-                t = newToken(TEXT, " ", input.CharPositionInLine - 2);
-                break;
-
-            case 'u':
-                t = UNICODE();
+                text = " ";
break;

default:
-                t = SKIP;
NoViableAltException e = new NoViableAltException(string.Empty, 0, 0, input);
errMgr.LexerError(input.SourceName, string.Format("invalid escaped char: '{0}'", GetCharString(c)), templateToken, e);
-                break;
+                consume();
+                match(delimiterStopChar);
+                return SKIP;
}
+
consume();
+            IToken t = newToken(TEXT, text, input.CharPositionInLine - 2);
match(delimiterStopChar);
return t;
}
@@ -564,9 +566,12 @@ namespace Antlr4.StringTemplate.Compiler
}

chars[3] = c;
-            // ESCAPE kills final char and >
+            // ESCAPE kills >
char uc = (char)int.Parse(new string(chars), NumberStyles.HexNumber);
-            return newToken(TEXT, uc.ToString(), input.CharPositionInLine - 6);
+            IToken t = newToken(TEXT, uc.ToString(), input.CharPositionInLine - 6);
+            consume();
+            match(delimiterStopChar);
+            return t;
}

private IToken mTEXT()
diff --git a/Antlr4.StringTemplate/Debug/DebugTemplate.cs b/Antlr4.StringTemplate/Debug/DebugTemplate.cs
index b52377b..d40cb9e 100644
--- a/Antlr4.StringTemplate/Debug/DebugTemplate.cs
+++ b/Antlr4.StringTemplate/Debug/DebugTemplate.cs
@@ -101,6 +101,11 @@ namespace Antlr4.StringTemplate.Debug
return GetEvents(CultureInfo.CurrentCulture, lineWidth);
}

+        public virtual List<InterpEvent> GetEvents(ITemplateWriter writer)
+        {
+            return GetEvents(CultureInfo.CurrentCulture, writer);
+        }
+
public virtual List<InterpEvent> GetEvents(CultureInfo locale)
{
return GetEvents(locale, AutoIndentWriter.NoWrap);
@@ -111,8 +116,13 @@ namespace Antlr4.StringTemplate.Debug
StringWriter @out = new StringWriter();
ITemplateWriter wr = new AutoIndentWriter(@out);
wr.LineWidth = lineWidth;
-            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, locale);
-            interp.Execute(wr, this); // Render and track events
+            return GetEvents(locale, wr);
+        }
+
+        public virtual List<InterpEvent> GetEvents(CultureInfo culture, ITemplateWriter writer)
+        {
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, culture);
+            interp.Execute(writer, this); // Render and track events
return interp.GetEvents();
}
}
diff --git a/Antlr4.StringTemplate/Debug/EvalExprEvent.cs b/Antlr4.StringTemplate/Debug/EvalExprEvent.cs
index 37a8181..a4d56ca 100644
--- a/Antlr4.StringTemplate/Debug/EvalExprEvent.cs
+++ b/Antlr4.StringTemplate/Debug/EvalExprEvent.cs
@@ -38,7 +38,7 @@ namespace Antlr4.StringTemplate.Debug
{
// template pattern location
private readonly Interval _sourceInterval;
-        private readonly string expr;
+        private readonly string expr = string.Empty;

public EvalExprEvent(DebugTemplate template, Interval outputInterval, Interval sourceInterval)
: base(template, outputInterval)
@@ -66,7 +66,7 @@ namespace Antlr4.StringTemplate.Debug

public override string ToString()
{
-            return string.Format("{0}{{self={1}, output={2}, expr={3}}}", GetType().Name, Template, OutputInterval, Expr);
+            return string.Format("{0}{{self={1}, expr='{2}', source={3}, output={4}}}", GetType().Name, Template, Expr, SourceInterval, OutputInterval);
}
}
}
diff --git a/Antlr4.StringTemplate/Debug/IndentEvent.cs b/Antlr4.StringTemplate/Debug/IndentEvent.cs
new file mode 100644
index 0000000..52cd9eb
--- /dev/null
+++ b/Antlr4.StringTemplate/Debug/IndentEvent.cs
@@ -0,0 +1,44 @@
+ï»¿/*
+ * [The "BSD license"]
+ *  Copyright (c) 2011 Terence Parr
+ *  All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2011 Sam Harwell, Tunnel Vision Laboratories, LLC
+ * All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr4.StringTemplate.Debug
+{
+    using Antlr4.StringTemplate.Misc;
+
+    public class IndentEvent : EvalExprEvent
+    {
+        public IndentEvent(DebugTemplate template, Interval outputInterval, Interval sourceInterval)
+            : base(template, outputInterval, sourceInterval)
+        {
+        }
+    }
+}
diff --git a/Antlr4.StringTemplate/Interpreter.cs b/Antlr4.StringTemplate/Interpreter.cs
index 5634537..b8f33a5 100644
--- a/Antlr4.StringTemplate/Interpreter.cs
+++ b/Antlr4.StringTemplate/Interpreter.cs
@@ -450,7 +450,7 @@ namespace Antlr4.StringTemplate
case Bytecode.INSTR_INDENT:
strIndex = GetShort(code, ip);
ip += Instruction.OperandSizeInBytes;
-                    @out.PushIndentation(self.impl.strings[strIndex]);
+                    Indent(@out, self, strIndex);
break;

case Bytecode.INSTR_DEDENT:
@@ -526,7 +526,7 @@ namespace Antlr4.StringTemplate
if (group.Debug)
{
EvalTemplateEvent e = new EvalTemplateEvent((DebugTemplate)self, Interval.FromBounds(start, @out.Index));
-                //System.out.println("eval template "+self+": "+e);
+                //Console.WriteLine(e);
events.Add(e);
if (self.EnclosingInstance != null)
{
@@ -653,6 +653,20 @@ namespace Antlr4.StringTemplate
}
}

+        protected void Indent(ITemplateWriter @out, Template self, int strIndex)
+        {
+            string indent = self.impl.strings[strIndex];
+            if (group.Debug)
+            {
+                int start = @out.Index; // track char we're about to write
+                EvalExprEvent e = new IndentEvent((DebugTemplate)self, new Interval(start, indent.Length), GetExpressionInterval(self));
+                //Console.WriteLine(e);
+                events.Add(e);
+            }
+
+            @out.PushIndentation(indent);
+        }
+
/** Write out an expression result that doesn't use expression options.
*  E.g., &lt;name&gt;
*/
@@ -821,6 +835,11 @@ namespace Antlr4.StringTemplate
return n;
}

+        protected virtual Interval GetExpressionInterval(Template self)
+        {
+            return self.impl.sourceMap[current_ip];
+        }
+
protected virtual void Map(Template self, object attr, Template st)
{
RotateMap(self, attr, new List<Template>() { st });
diff --git a/Antlr4.StringTemplate/Template.cs b/Antlr4.StringTemplate/Template.cs
index c46a2c1..e6d40ad 100644
--- a/Antlr4.StringTemplate/Template.cs
+++ b/Antlr4.StringTemplate/Template.cs
@@ -439,9 +439,9 @@ namespace Antlr4.StringTemplate
return interp.Execute(@out, this);
}

-        public virtual int Write(ITemplateWriter @out, CultureInfo locale)
+        public virtual int Write(ITemplateWriter @out, CultureInfo culture)
{
-            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, locale, impl.NativeGroup.ErrorManager);
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, culture, impl.NativeGroup.ErrorManager);
interp.SetDefaultArguments(this);
return interp.Execute(@out, this);
}
@@ -453,9 +453,9 @@ namespace Antlr4.StringTemplate
return interp.Execute(@out, this);
}

-        public virtual int Write(ITemplateWriter @out, CultureInfo locale, ITemplateErrorListener listener)
+        public virtual int Write(ITemplateWriter @out, CultureInfo culture, ITemplateErrorListener listener)
{
-            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, locale, new ErrorManager(listener));
+            Interpreter interp = new Interpreter(groupThatCreatedThisInstance, culture, new ErrorManager(listener));
interp.SetDefaultArguments(this);
return interp.Execute(@out, this);
}
@@ -490,17 +490,17 @@ namespace Antlr4.StringTemplate
return Render(CultureInfo.CurrentCulture, lineWidth);
}

-        public virtual string Render(CultureInfo locale)
+        public virtual string Render(CultureInfo culture)
{
-            return Render(locale, AutoIndentWriter.NoWrap);
+            return Render(culture, AutoIndentWriter.NoWrap);
}

-        public virtual string Render(CultureInfo locale, int lineWidth)
+        public virtual string Render(CultureInfo culture, int lineWidth)
{
StringWriter @out = new StringWriter();
ITemplateWriter wr = new AutoIndentWriter(@out);
wr.LineWidth = lineWidth;
-            Write(wr, locale);
+            Write(wr, culture);
return @out.ToString();
}

diff --git a/Antlr4.Test.StringTemplate/TestDebugEvents.cs b/Antlr4.Test.StringTemplate/TestDebugEvents.cs
index 8a69a18..e4a1e09 100644
--- a/Antlr4.Test.StringTemplate/TestDebugEvents.cs
+++ b/Antlr4.Test.StringTemplate/TestDebugEvents.cs
@@ -32,13 +32,14 @@

namespace Antlr4.Test.StringTemplate
{
+    using System.Collections.Generic;
using Antlr4.StringTemplate;
-    using Microsoft.VisualStudio.TestTools.UnitTesting;
-    using Environment = System.Environment;
using Antlr4.StringTemplate.Debug;
using Antlr4.Test.StringTemplate.Extensions;
-    using System.Collections.Generic;
+    using Microsoft.VisualStudio.TestTools.UnitTesting;
+    using Environment = System.Environment;
using Path = System.IO.Path;
+    using StringWriter = System.IO.StringWriter;

[TestClass]
public class TestDebugEvents : BaseTest
@@ -103,5 +104,25 @@ namespace Antlr4.Test.StringTemplate
string result = events.ToListString();
Assert.AreEqual(expected, result);
}
+
+        [TestMethod]
+        public void TestEvalExprEventForSpecialCharacter()
+        {
+            string templates = "t() ::= <<[<\\n>]>>\n";
+            //                            012 345
+            TemplateGroupString g = new TemplateGroupString(templates);
+            g.Debug = true;
+            DebugTemplate st = (DebugTemplate)g.GetInstanceOf("t");
+            st.impl.Dump();
+            StringWriter writer = new StringWriter();
+            List<InterpEvent> events = st.GetEvents(new AutoIndentWriter(writer, "\n"));
+            string expected =
+                "[EvalExprEvent{self=t(), expr='[', source=[0..1), output=[0..1)}, " +
+                "EvalExprEvent{self=t(), expr='\\n', source=[2..4), output=[1..2)}, " +
+                "EvalExprEvent{self=t(), expr=']', source=[5..6), output=[2..3)}, " +
+                "EvalTemplateEvent{self=t(), output=[0..3)}]";
+            string result = events.ToListString();
+            Assert.AreEqual(expected, result);
+        }
}
}
diff --git a/Antlr4.Test.StringTemplate/TestWhitespace.cs b/Antlr4.Test.StringTemplate/TestWhitespace.cs
index 30e2d15..373b56e 100644
--- a/Antlr4.Test.StringTemplate/TestWhitespace.cs
+++ b/Antlr4.Test.StringTemplate/TestWhitespace.cs
@@ -55,6 +55,32 @@ namespace Antlr4.Test.StringTemplate
}

[TestMethod]
+        public void TestTrimmedNewlinesBeforeAfterInTemplate()
+        {
+            string templates =
+                "a(x) ::= <<" + newline +
+                "foo" + newline +
+                ">>" + newline;
+            TemplateGroupString group = new TemplateGroupString(templates);
+            Template st = group.GetInstanceOf("a");
+            string expected = "foo";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
+        public void TestDontTrimJustSpaceBeforeAfterInTemplate()
+        {
+            string templates =
+                "a(x) ::= << foo >>\n";
+            TemplateGroupString group = new TemplateGroupString(templates);
+            Template st = group.GetInstanceOf("a");
+            string expected = " foo ";
+            string result = st.Render();
+            Assert.AreEqual(expected, result);
+        }
+
+        [TestMethod]
public void TestTrimmedSubtemplatesNoArgs()
{
TemplateGroup group = new TemplateGroup();

