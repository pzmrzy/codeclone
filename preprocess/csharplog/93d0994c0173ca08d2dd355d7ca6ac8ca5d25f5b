commit 93d0994c0173ca08d2dd355d7ca6ac8ca5d25f5b
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Mon Dec 14 12:52:34 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Mon Dec 14 12:52:34 2009 -0800

C# Port:
* Merge 6409

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6519]

diff --git a/Antlr3.Test/ST4/ErrorBuffer.cs b/Antlr3.Test/ST4/ErrorBuffer.cs
index 5c108ca..92329f3 100644
--- a/Antlr3.Test/ST4/ErrorBuffer.cs
+++ b/Antlr3.Test/ST4/ErrorBuffer.cs
@@ -1,60 +1,41 @@
﻿namespace AntlrUnitTests.ST4
{
+    using System.Collections.Generic;
using StringTemplate;
-    using Exception = System.Exception;
using StringBuilder = System.Text.StringBuilder;
-    using StringWriter = System.IO.StringWriter;

public class ErrorBuffer : ITemplateErrorListener
{
-        StringBuilder errorOutput = new StringBuilder(500);
-        int n = 0;
+        private List<TemplateMessage> errors = new List<TemplateMessage>();

-        public void Error(string msg)
+        public void CompileTimeError(TemplateMessage msg)
{
-            Error(msg, null);
+            errors.Add(msg);
}

-        public void Error(string msg, Exception e)
+        public void RuntimeError(TemplateMessage msg)
{
-            n++;
-            if (n > 1)
-            {
-                errorOutput.Append('\n');
-            }
-            if (e != null)
-            {
-                StringWriter duh = new StringWriter();
-                duh.WriteLine(e.StackTrace);
-                errorOutput.Append(msg + ": " + duh.ToString());
-            }
-            else
-            {
-                errorOutput.Append(msg);
-            }
+            errors.Add(msg);
}

-        public void Warning(string msg)
+        public void IOError(TemplateMessage msg)
{
-            n++;
-            errorOutput.Append(msg);
+            errors.Add(msg);
}

-        public override bool Equals(object o)
+        public void InternalError(TemplateMessage msg)
{
-            string me = ToString();
-            string them = o.ToString();
-            return me.Equals(them);
-        }
-
-        public override int GetHashCode()
-        {
-            return ToString().GetHashCode();
+            errors.Add(msg);
}

public override string ToString()
{
-            return errorOutput.ToString();
+            StringBuilder buf = new StringBuilder();
+            foreach (TemplateMessage m in errors)
+            {
+                buf.Append(m.ToString());
+            }
+            return buf.ToString();
}
}
}
diff --git a/Antlr3.Test/ST4/TestRegions.cs b/Antlr3.Test/ST4/TestRegions.cs
index 5962840..9da0a50 100644
--- a/Antlr3.Test/ST4/TestRegions.cs
+++ b/Antlr3.Test/ST4/TestRegions.cs
@@ -151,7 +151,7 @@ namespace AntlrUnitTests.ST4
ErrorBuffer errors = new ErrorBuffer();
ErrorManager.ErrorListener = errors;
group.Load();
-            string expected = "redefinition of /region__a__r";
+            string expected = "redefinition of template /region__a__r" + newline;
string result = errors.ToString();
Assert.AreEqual(expected, result);
}
diff --git a/StringTemplate4/Compiler/Group.g3 b/StringTemplate4/Compiler/Group.g3
index 6b025a3..b830fe7 100644
--- a/StringTemplate4/Compiler/Group.g3
+++ b/StringTemplate4/Compiler/Group.g3
@@ -101,9 +101,7 @@ templateDef[string prefix]
RecognitionException re = (RecognitionException)e.InnerException;
int charPosition =
re.charPositionInLine+templateToken.CharPositionInLine+n;
-	        ErrorManager.Error(templateToken.Line+":"+
-                    	  		 charPosition+
-	                             ": "+e.Message, null);
+	        ErrorManager.CompileTimeError(ErrorType.SyntaxError, e.Message, templateToken.Line + ":" + charPosition);
}
}
|   alias=ID '::=' target=ID
@@ -135,10 +133,10 @@ dictDef
:	ID '::=' dict
{
if ( this._group.dictionaries.ContainsKey($ID.text) ) {
-            ErrorManager.Error("redefinition of map: "+$ID.text);
+            ErrorManager.CompileTimeError(ErrorType.MapRedefinition, "redefinition of map: "+$ID.text);
}
else if ( this._group.templates.ContainsKey($ID.text) ) {
-            ErrorManager.Error("redefinition of template as map: "+$ID.text);
+            ErrorManager.CompileTimeError(ErrorType.TemplateRedefinitionAsMap, "redefinition of template as map: "+$ID.text);
}
else {
this._group.DefineDictionary($ID.text, $dict.mapping);
diff --git a/StringTemplate4/Compiler/TemplateLexer.cs b/StringTemplate4/Compiler/TemplateLexer.cs
index fb45518..181b909 100644
--- a/StringTemplate4/Compiler/TemplateLexer.cs
+++ b/StringTemplate4/Compiler/TemplateLexer.cs
@@ -408,7 +408,7 @@ namespace StringTemplate.Compiler
t = UNICODE();
break;
default:
-                ErrorManager.Error("bad \\ char");
+                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
break;
}
Consume();
@@ -421,19 +421,19 @@ namespace StringTemplate.Compiler
Consume();
char[] chars = new char[4];
if (!IsUnicodeLetter(c))
-                ErrorManager.Error("bad unicode char: " + c);
+                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
chars[0] = c;
Consume();
if (!IsUnicodeLetter(c))
-                ErrorManager.Error("bad unicode char: " + c);
+                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
chars[1] = c;
Consume();
if (!IsUnicodeLetter(c))
-                ErrorManager.Error("bad unicode char: " + c);
+                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
chars[2] = c;
Consume();
if (!IsUnicodeLetter(c))
-                ErrorManager.Error("bad unicode char: " + c);
+                ErrorManager.CompileTimeError(ErrorType.LexerError, c);
chars[3] = c;
// ESCAPE kills final char and >
char uc = (char)int.Parse(new string(chars), NumberStyles.HexNumber);
diff --git a/StringTemplate4/Compiler/TemplateParserHelper.cs b/StringTemplate4/Compiler/TemplateParserHelper.cs
index 550c66f..8e84264 100644
--- a/StringTemplate4/Compiler/TemplateParserHelper.cs
+++ b/StringTemplate4/Compiler/TemplateParserHelper.cs
@@ -92,7 +92,7 @@ namespace StringTemplate.Compiler
int i;
if (!TemplateCompiler.supportedOptions.TryGetValue(id.Text, out i))
{
-                ErrorManager.Error("no such option: " + id.Text);
+                ErrorManager.CompileTimeError(ErrorType.NoSuchOption, id);
return;
}

@@ -104,7 +104,7 @@ namespace StringTemplate.Compiler
string v;
if (!TemplateCompiler.defaultOptionValues.TryGetValue(id.Text, out v))
{
-                ErrorManager.Error("no def value for " + id.Text);
+                ErrorManager.CompileTimeError(ErrorType.NoDefaultValue, id);
return;
}

@@ -116,7 +116,7 @@ namespace StringTemplate.Compiler
short funcBytecode;
if (!TemplateCompiler.funcs.TryGetValue(id.Text, out funcBytecode))
{
-                ErrorManager.Error("no such fun: " + id);
+                ErrorManager.CompileTimeError(ErrorType.NoSuchFunction, id);
gen.Emit(Bytecode.INSTR_NOOP);
return;
}
diff --git a/StringTemplate4/ErrorManager.cs b/StringTemplate4/ErrorManager.cs
index e4d3033..c0256e4 100644
--- a/StringTemplate4/ErrorManager.cs
+++ b/StringTemplate4/ErrorManager.cs
@@ -34,7 +34,9 @@ namespace StringTemplate
{
using Console = System.Console;
using Exception = System.Exception;
+    using IOException = System.IO.IOException;
using ThreadStatic = System.ThreadStaticAttribute;
+    using StringTemplate.Compiler;

public static class ErrorManager
{
@@ -55,23 +57,82 @@ namespace StringTemplate
}
}

-        public static void Error(string s)
+        public static void CompileTimeError(ErrorType error, object arg)
{
-            ErrorListener.Error(s, null);
+            listener.CompileTimeError(new TemplateMessage(error, null, null, arg));
}

-        public static void Error(string s, Exception e)
+        public static void CompileTimeError(ErrorType error, object arg1, object arg2)
{
-            ErrorListener.Error(s, e);
+            listener.CompileTimeError(new TemplateMessage(error, null, null, arg1, arg2));
}

-        public static void Warning(string s)
+        public static void RuntimeError(Template template, ErrorType error)
{
-            ErrorListener.Warning(s);
+            listener.RuntimeError(new TemplateMessage(error, template));
+        }
+
+        public static void RuntimeError(Template template, ErrorType error, object arg)
+        {
+            listener.RuntimeError(new TemplateMessage(error, template, null, arg));
+        }
+
+        public static void RuntimeError(Template template, ErrorType error, Exception source, object arg)
+        {
+            listener.RuntimeError(new TemplateMessage(error, template, source, arg));
+        }
+
+        public static void RuntimeError(Template template, ErrorType error, object arg1, object arg2)
+        {
+            listener.RuntimeError(new TemplateMessage(error, template, null, arg1, arg2));
+        }
+
+        public static void IOError(Template template, ErrorType error, Exception source)
+        {
+            listener.IOError(new TemplateMessage(error, template, source));
+        }
+
+        public static void IOError(Template template, ErrorType error, Exception source, object arg)
+        {
+            listener.IOError(new TemplateMessage(error, template, source, arg));
+        }
+
+        public static void InternalError(Template template, ErrorType error, Exception source)
+        {
+            listener.InternalError(new TemplateMessage(error, template, source));
+        }
+
+        public static void InternalError(Template template, ErrorType error, Exception source, object arg)
+        {
+            listener.InternalError(new TemplateMessage(error, template, source, arg));
+        }
+
+        public static void InternalError(Template template, ErrorType error, Exception source, object arg1, object arg2)
+        {
+            listener.InternalError(new TemplateMessage(error, template, source, arg1, arg2));
}

private class DefaultErrorListenerImpl : ITemplateErrorListener
{
+            public void CompileTimeError(TemplateMessage message)
+            {
+            }
+
+            public void RuntimeError(TemplateMessage message)
+            {
+            }
+
+            public void IOError(TemplateMessage message)
+            {
+                throw new IOException(message.Message, message.Source);
+            }
+
+            public void InternalError(TemplateMessage message)
+            {
+                throw new TemplateException(message.Message, message.Source);
+            }
+
+            // TODO: put in [root ... template] stack
public void Error(string message, Exception e)
{
Console.Error.WriteLine(message);
diff --git a/StringTemplate4/ErrorTolerance.cs b/StringTemplate4/ErrorTolerance.cs
deleted file mode 100644
index 845c590..0000000
--- a/StringTemplate4/ErrorTolerance.cs
+++ /dev/null
@@ -1,65 +0,0 @@
-﻿/*
- * [The "BSD licence"]
- * Copyright (c) 2005-2008 Terence Parr
- * All rights reserved.
- *
- * Conversion to C#:
- * Copyright (c) 2008-2009 Sam Harwell
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. The name of the author may not be used to endorse or promote products
- *    derived from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-namespace StringTemplate
-{
-    using ThreadStatic = System.ThreadStaticAttribute;
-
-    public class ErrorTolerance
-    {
-        // bit set values telling ST what to care about
-        public static readonly int DETECT_UNKNOWN_ATTRIBUTE = 1;
-        public static readonly int DETECT_UNKNOWN_PROPERTY = 2;
-        public static readonly int DETECT_UNKNOWN_TEMPLATE = 4;
-        public static readonly int DETECT_MALFORMED_TEMPLATE_NAME = 8;
-
-        public static readonly int DEFAULT_TOLERANCE = DETECT_UNKNOWN_TEMPLATE | DETECT_MALFORMED_TEMPLATE_NAME;
-
-        [ThreadStatic]
-        public static int detect = DEFAULT_TOLERANCE;
-
-        public bool Detects(int x)
-        {
-            return (detect & x) != 0;
-        }
-
-        public void Detect(int x)
-        {
-            detect |= x;
-        }
-
-        public void Ignore(int x)
-        {
-            detect &= ~x;
-        }
-    }
-}
diff --git a/StringTemplate4/ErrorType.cs b/StringTemplate4/ErrorType.cs
new file mode 100644
index 0000000..ec265e9
--- /dev/null
+++ b/StringTemplate4/ErrorType.cs
@@ -0,0 +1,79 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    public sealed class ErrorType
+    {
+        // RUNTIME SEMANTIC ERRORS
+        public static readonly ErrorType NoSuchTemplate = new ErrorType("no such template: {0}");
+        public static readonly ErrorType NoImportedTemplate = new ErrorType("no such template: super.{0}");
+        public static readonly ErrorType CantAccessPropertyMethod = new ErrorType("can't access property {0} via method");
+        public static readonly ErrorType CantAccessPropertyField = new ErrorType("can't access property {0} as field");
+        public static readonly ErrorType NoSuchProperty = new ErrorType("{0} doesn't have a {1} property");
+        public static readonly ErrorType ExpectingSingleArgument = new ErrorType("expecting single arg in template {0}, not {1} args");
+        public static readonly ErrorType MissingFormalArguments = new ErrorType("missing argument definitions");
+        public static readonly ErrorType ArgumentCountMismatch = new ErrorType("template {0}'s actual and formal argument count does not match");
+        public static readonly ErrorType ExpectingString = new ErrorType("function {0} expects a string not {1}");
+
+        // COMPILE-TIME SYNTAX/SEMANTIC ERRORS
+        public static readonly ErrorType SyntaxError = new ErrorType("{0}");
+        public static readonly ErrorType TemplateRedefinition = new ErrorType("redefinition of template {0}");
+        public static readonly ErrorType EmbeddedRegionRedefinition = new ErrorType("region {0} is embedded and thus already implicitly defined");
+        public static readonly ErrorType RegionRedefinition = new ErrorType("redefinition of region {0}");
+        public static readonly ErrorType MapRedefinition = new ErrorType("redefinition of dictionary {0}");
+        public static readonly ErrorType TemplateRedefinitionAsMap = new ErrorType("redefinition of template {0} as a map");
+        public static readonly ErrorType LexerError = new ErrorType("lexer there are add character {0}");
+        public static readonly ErrorType NoDefaultValue = new ErrorType("missing dictionary default value");
+        public static readonly ErrorType NoSuchFunction = new ErrorType("no such function: {0}");
+        public static readonly ErrorType NoSuchOption = new ErrorType("no such option: {0}");
+
+        // IO ERRORS
+        public static readonly ErrorType WriteIoError = new ErrorType("error writing output");
+        public static readonly ErrorType CantLoadGroupFile = new ErrorType("can't load group file {0}");
+        public static readonly ErrorType CantLoadTemplateFile = new ErrorType("can't load template file {0}");
+        public static readonly ErrorType InvalidBytecode = new ErrorType("invalid bytecode {0} at IP {1}");
+
+        public static readonly ErrorType GuiError = new ErrorType("GUI error");
+
+        private ErrorType(string messageFormat)
+        {
+            this.MessageFormat = messageFormat;
+        }
+
+        public string MessageFormat
+        {
+            get;
+            private set;
+        }
+    }
+}
diff --git a/StringTemplate4/ITemplateErrorListener.cs b/StringTemplate4/ITemplateErrorListener.cs
index 5ea675c..f9e1f50 100644
--- a/StringTemplate4/ITemplateErrorListener.cs
+++ b/StringTemplate4/ITemplateErrorListener.cs
@@ -36,8 +36,9 @@ namespace StringTemplate

public interface ITemplateErrorListener
{
-        void Error(string message, Exception e);
-        void Error(string message);
-        void Warning(string message);
+        void CompileTimeError(TemplateMessage message);
+        void RuntimeError(TemplateMessage message);
+        void IOError(TemplateMessage message);
+        void InternalError(TemplateMessage message);
}
}
diff --git a/StringTemplate4/Interpreter.cs b/StringTemplate4/Interpreter.cs
index c10b312..5dfcce5 100644
--- a/StringTemplate4/Interpreter.cs
+++ b/StringTemplate4/Interpreter.cs
@@ -41,6 +41,7 @@ namespace StringTemplate
using Console = System.Console;
using CultureInfo = System.Globalization.CultureInfo;
using Environment = System.Environment;
+    using Exception = System.Exception;
using FieldInfo = System.Reflection.FieldInfo;
using ICollection = System.Collections.ICollection;
using IDictionary = System.Collections.IDictionary;
@@ -174,7 +175,7 @@ namespace StringTemplate
st = group.GetEmbeddedInstanceOf(self, name);
if (st == null)
{
-                        ErrorManager.Error("no such template " + name);
+                        ErrorManager.RuntimeError(self, ErrorType.NoSuchTemplate, name);
st = Template.Blank;
}
operands[++sp] = st;
@@ -184,7 +185,7 @@ namespace StringTemplate
st = group.GetEmbeddedInstanceOf(self, name);
if (st == null)
{
-                        ErrorManager.Error("no such template " + name);
+                        ErrorManager.RuntimeError(self, ErrorType.NoSuchTemplate, name);
st = Template.Blank;
}
operands[++sp] = st;
@@ -196,7 +197,7 @@ namespace StringTemplate
CompiledTemplate imported = group.LookupImportedTemplate(name);
if (imported == null)
{
-                        ErrorManager.Error("no imported template for " + name);
+                        ErrorManager.RuntimeError(self, ErrorType.NoImportedTemplate, name);
operands[++sp] = Template.Blank;
break;
}
@@ -225,7 +226,7 @@ namespace StringTemplate
}
if (nargs != 1)
{
-                        ErrorManager.Error("arg mismatch; expecting 1, found " + nargs);
+                        ErrorManager.RuntimeError(self, ErrorType.ExpectingSingleArgument, st, nargs);
}
else
{
@@ -337,7 +338,7 @@ namespace StringTemplate
}
else
{
-                        ErrorManager.Error("trim(non string): " + o);
+                        ErrorManager.RuntimeError(self, ErrorType.ExpectingString, "trim", o);
operands[++sp] = o;
}
break;
@@ -352,7 +353,7 @@ namespace StringTemplate
}
else
{
-                        ErrorManager.Error("strlen(non string): " + o);
+                        ErrorManager.RuntimeError(self, ErrorType.ExpectingString, "strlen", o);
operands[++sp] = 0;
}
break;
@@ -391,13 +392,13 @@ namespace StringTemplate
}
nw = -1; // indicate nothing written but no WRITE yet
}
-                    catch (IOException)
+                    catch (IOException ioe)
{
-                        ErrorManager.Error("[internal]: can't write newline");
+                        ErrorManager.IOError(self, ErrorType.WriteIoError, ioe);
}
break;
default:
-                    ErrorManager.Error("[internal]: Invalid bytecode: " + opcode + " @ ip=" + (ip - 1));
+                    ErrorManager.InternalError(self, ErrorType.InvalidBytecode, null, opcode, ip - 1);
self.code.Dump();
break;
}
@@ -487,9 +488,9 @@ namespace StringTemplate
{
@out.WriteWrap(options[OPTION_WRAP]);
}
-                    catch (IOException)
+                    catch (IOException ioe)
{
-                        ErrorManager.Error("Can't write wrap string");
+                        ErrorManager.IOError(self, ErrorType.WriteIoError, ioe);
}
}
n = Exec(@out, (Template)o);
@@ -504,9 +505,9 @@ namespace StringTemplate
else
n = WritePlainObject(@out, o, options);
}
-                catch (IOException)
+                catch (IOException ioe)
{
-                    ErrorManager.Error("can't write " + o);
+                    ErrorManager.IOError(self, ErrorType.WriteIoError, ioe, o);
}
}

@@ -638,17 +639,14 @@ namespace StringTemplate
var formalArguments = code.formalArguments;
if (formalArguments == null || formalArguments.Count == 0)
{
-                ErrorManager.Error("missing formal arguments in anonymous" +
-                           " template in context " + self.GetEnclosingInstanceStackString(), null);
+                ErrorManager.RuntimeError(self, ErrorType.MissingFormalArguments);
return null;
}

object[] formalArgumentNames = formalArguments.Keys.ToArray();
if (formalArgumentNames.Length != numAttributes)
{
-                ErrorManager.Error("number of arguments " + formalArguments.Keys +
-                           " mismatch between attribute list and anonymous" +
-                           " template in context " + self.GetEnclosingInstanceStackString(), null);
+                ErrorManager.RuntimeError(self, ErrorType.ArgumentCountMismatch, template);
// truncate arg list to match smaller size
int shorterSize = Math.Min(formalArgumentNames.Length, numAttributes);
numAttributes = shorterSize;
@@ -1050,10 +1048,9 @@ namespace StringTemplate
{
value = InvokeMethod(m, o, value);
}
-                catch
+                catch (Exception e)
{
-                    ErrorManager.Error("Can't get property " + propertyName + " using method get/is" + methodSuffix +
-                        " from " + c.Name + " instance");
+                    ErrorManager.RuntimeError(self, ErrorType.CantAccessPropertyMethod, e, m);
}
}
else
@@ -1067,16 +1064,14 @@ namespace StringTemplate
{
value = AccessField(f, o, value);
}
-                    catch
+                    catch (Exception e)
{
-                        ErrorManager.Error("Can't access property " + propertyName + " using method get/is" + methodSuffix +
-                            " or direct field access from " + c.Name + " instance");
+                        ErrorManager.RuntimeError(self, ErrorType.CantAccessPropertyField, e, m);
}
}
catch
{
-                    ErrorManager.Error("Class " + c.Name + " has no such attribute: " + propertyName +
-                        " in template context " + "PUT CALLSTACK HERE");
+                    ErrorManager.RuntimeError(self, ErrorType.NoSuchProperty, c, propertyName);
}
}

diff --git a/StringTemplate4/StringTemplate4.csproj b/StringTemplate4/StringTemplate4.csproj
index 9022c29..9cacc6a 100644
--- a/StringTemplate4/StringTemplate4.csproj
+++ b/StringTemplate4/StringTemplate4.csproj
@@ -65,13 +65,13 @@
<Compile Include="Debug\EvalTemplateEvent.cs" />
<Compile Include="Debug\InterpEvent.cs" />
<Compile Include="ErrorManager.cs" />
-    <Compile Include="ErrorTolerance.cs" />
<Compile Include="Compiler\GroupLexerHelper.cs">
<DependentUpon>Group.g3</DependentUpon>
</Compile>
<Compile Include="Compiler\GroupParserHelper.cs">
<DependentUpon>Group.g3</DependentUpon>
</Compile>
+    <Compile Include="ErrorType.cs" />
<Compile Include="IAttributeRenderer.cs" />
<Compile Include="Interpreter.cs" />
<Compile Include="ITemplateErrorListener.cs" />
@@ -88,6 +88,7 @@
<Compile Include="Compiler\TemplateParserHelper.cs">
<DependentUpon>TemplateParser.g3</DependentUpon>
</Compile>
+    <Compile Include="TemplateMessage.cs" />
</ItemGroup>
<ItemGroup>
<None Include="..\Antlr3\Key.snk">
diff --git a/StringTemplate4/TemplateGroup.cs b/StringTemplate4/TemplateGroup.cs
index 77c262d..6315e4b 100644
--- a/StringTemplate4/TemplateGroup.cs
+++ b/StringTemplate4/TemplateGroup.cs
@@ -147,7 +147,7 @@ namespace StringTemplate
Template st = GetInstanceOf(name);
if (st == null)
{
-                ErrorManager.Error("no such template: " + name);
+                ErrorManager.RuntimeError(enclosingInstance, ErrorType.NoSuchTemplate, name);
return Template.Blank;
}
st.enclosingInstance = enclosingInstance;
@@ -294,17 +294,17 @@ namespace StringTemplate
{
if (!prev.isRegion)
{
-                    ErrorManager.Error("redefinition of " + name);
+                    ErrorManager.CompileTimeError(ErrorType.TemplateRedefinition, name);
return;
}
if (prev.isRegion && prev.regionDefType == Template.RegionType.Embedded)
{
-                    ErrorManager.Error("can't redefine embedded region " + name);
+                    ErrorManager.CompileTimeError(ErrorType.EmbeddedRegionRedefinition, GetUnmangledTemplateName(name));
return;
}
else if (prev.isRegion && prev.regionDefType == Template.RegionType.Explicit)
{
-                    ErrorManager.Error("can't redefine region in same group: " + name);
+                    ErrorManager.CompileTimeError(ErrorType.RegionRedefinition, GetUnmangledTemplateName(name));
return;
}
}
@@ -327,12 +327,14 @@ namespace StringTemplate
return "region__" + enclosingTemplateName + "__" + name;
}

-        /** Return "t" from "region__t__foo" */
+        /// <summary>
+        /// Return "t.foo" from "region__t__foo"
+        /// </summary>
public static string GetUnmangledTemplateName(string mangledName)
{
-            int start = "region__".Length;
-            int end = mangledName.LastIndexOf("__");
-            return mangledName.Substring(start, end - start);
+            string t = mangledName.Substring("region__".Length, mangledName.LastIndexOf("__") - "region__".Length + 1);
+            string r = mangledName.Substring(mangledName.LastIndexOf("__") + 2, mangledName.Length - mangledName.LastIndexOf("__") + 2 + 1);
+            return t + '.' + r;
}

/** Define a map for this group; not thread safe...do not keep adding
@@ -376,7 +378,7 @@ namespace StringTemplate
}
catch (Exception e)
{
-                ErrorManager.Error("can't load group file: " + absoluteFileName, e);
+                ErrorManager.IOError(null, ErrorType.CantLoadGroupFile, e, absoluteFileName);
}
}

diff --git a/StringTemplate4/TemplateGroupDirectory.cs b/StringTemplate4/TemplateGroupDirectory.cs
index 096b026..05223c3 100644
--- a/StringTemplate4/TemplateGroupDirectory.cs
+++ b/StringTemplate4/TemplateGroupDirectory.cs
@@ -125,7 +125,7 @@ namespace StringTemplate
}
catch (Exception e)
{
-                ErrorManager.Error("can't load template file: " + absoluteFileName);
+                ErrorManager.IOError(null, ErrorType.CantLoadTemplateFile, e, absoluteFileName);
Console.Error.WriteLine(e.StackTrace);
}
return null;
diff --git a/StringTemplate4/TemplateMessage.cs b/StringTemplate4/TemplateMessage.cs
new file mode 100644
index 0000000..09097b5
--- /dev/null
+++ b/StringTemplate4/TemplateMessage.cs
@@ -0,0 +1,113 @@
+﻿/*
+ * [The "BSD licence"]
+ * Copyright (c) 2005-2008 Terence Parr
+ * All rights reserved.
+ *
+ * Conversion to C#:
+ * Copyright (c) 2008-2009 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace StringTemplate
+{
+    using Exception = System.Exception;
+    using StringBuilder = System.Text.StringBuilder;
+
+    public class TemplateMessage
+    {
+        /** if in debug mode, has create instance, add attr events and eval
+         *  template events.
+         */
+        private ErrorType error;
+        private object arg1;
+        private object arg2;
+
+        public TemplateMessage(ErrorType error)
+            : this(error, null, null, null, null)
+        {
+        }
+
+        public TemplateMessage(ErrorType error, Template template)
+            : this(error, template, null, null, null)
+        {
+        }
+
+        public TemplateMessage(ErrorType error, Template template, Exception source)
+            : this(error, template, source, null, null)
+        {
+        }
+
+        public TemplateMessage(ErrorType error, Template template, Exception source, object arg)
+            : this(error, template, source, arg, null)
+        {
+        }
+
+        public TemplateMessage(ErrorType error, Template template, Exception source, object arg1, object arg2)
+        {
+            this.error = error;
+            this.Template = template;
+            this.Source = source;
+            this.arg1 = arg1;
+            this.arg2 = arg2;
+        }
+
+        public Template Template
+        {
+            get;
+            private set;
+        }
+
+        public string Message
+        {
+            get
+            {
+                return string.Format(error.MessageFormat, arg1, arg2);
+            }
+        }
+
+        public Exception Source
+        {
+            get;
+            private set;
+        }
+
+        public override string ToString()
+        {
+            StringBuilder builder = new StringBuilder();
+
+            if (Template != null)
+                builder.Append(Template.GetEnclosingInstanceStackString() + " ");
+
+            builder.AppendLine(Message);
+
+            if (Source != null)
+            {
+                builder.AppendLine(Source.StackTrace);
+            }
+
+            return builder.ToString();
+        }
+    }
+}

