commit 530edac225a58bded7f786e2be505880880347df
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Fri May 8 06:32:30 2009 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Fri May 8 06:32:30 2009 -0800

C# Port:
* Rename _{Method} to {Method}Core
* Other .NET naming, visibility updates
* Fix unit tests

[git-p4: depot-paths = "//depot/code/antlrcs/main/": change = 6105]

diff --git a/Antlr3.StringTemplate/Language/ASTExpr.cs b/Antlr3.StringTemplate/Language/ASTExpr.cs
index 4013156..7ecd6e9 100644
--- a/Antlr3.StringTemplate/Language/ASTExpr.cs
+++ b/Antlr3.StringTemplate/Language/ASTExpr.cs
@@ -404,10 +404,10 @@ namespace Antlr3.ST.Language
int numEmpty = 0;
for ( int a = 0; a < numAttributes; a++ )
{
-                    Iterator it = (Iterator)attributes[a];
+                    Iterator it = attributes[a] as Iterator;
if ( it != null && it.hasNext() )
{
-                        string argName = (string)formalArgumentNames[a];
+                        string argName = formalArgumentNames[a];
object iteratedValue = it.next();
argumentContext[argName] = iteratedValue;
}
@@ -448,11 +448,11 @@ namespace Antlr3.ST.Language
attributeValue = ConvertArrayToList( attributeValue );
attributeValue = ConvertAnythingIteratableToIterator( attributeValue );

-            if ( attributeValue is Iterator )
+            Iterator iter = attributeValue as Iterator;
+            if ( iter != null )
{
// results can be treated list an attribute, indicate ST created list
IList resultVector = new StringTemplate.STAttributeList();
-                Iterator iter = (Iterator)attributeValue;
int i = 0;
while ( iter.hasNext() )
{
@@ -466,7 +466,7 @@ namespace Antlr3.ST.Language
ithValue = _nullValue;
}
int templateIndex = i % templatesToApply.Count; // rotate through
-                    embedded = (StringTemplate)templatesToApply[templateIndex];
+                    embedded = templatesToApply[templateIndex];
// template to apply is an actual StringTemplate (created in
// eval.g), but that is used as the examplar.  We must create
// a new instance of the embedded template to apply each time
@@ -511,7 +511,7 @@ namespace Antlr3.ST.Language
embedded.getName()+
" to "+attributeValue);
*/
-                embedded = (StringTemplate)templatesToApply[0];
+                embedded = templatesToApply[0];
argumentContext = new Dictionary<string, object>();
var formalArgs = embedded.FormalArguments;
StringTemplateAST args = embedded.ArgumentsAST;
@@ -576,7 +576,8 @@ namespace Antlr3.ST.Language

if ( propertyName == null )
{
-                if ( o is IDictionary && ( (IDictionary)o ).Contains( DefaultMapValueName ) )
+                IDictionary dictionary = o as IDictionary;
+                if ( dictionary != null && dictionary.Contains( DefaultMapValueName ) )
propertyName = DefaultMapValueName;
else
return null;
@@ -602,73 +603,76 @@ namespace Antlr3.ST.Language
return value;
}

-        [MethodImpl( MethodImplOptions.Synchronized )]
static Func<object, object> FindMember( Type type, string name )
{
if ( type == null || name == null )
throw new ArgumentNullException();

-            Dictionary<string, Func<object, object>> members;
-            Func<object, object> accessor = null;
-
-            if ( _memberAccessors.TryGetValue( type, out members ) )
-            {
-                if ( members.TryGetValue( name, out accessor ) )
-                    return accessor;
-            }
-            else
+            lock ( _memberAccessors )
{
-                members = new Dictionary<string, Func<object, object>>();
-                _memberAccessors[type] = members;
-            }
+                Dictionary<string, Func<object, object>> members;
+                Func<object, object> accessor = null;

-            // must look up using reflection
-            string methodSuffix = char.ToUpperInvariant( name[0] ) + name.Substring( 1 );
+                if ( _memberAccessors.TryGetValue( type, out members ) )
+                {
+                    if ( members.TryGetValue( name, out accessor ) )
+                        return accessor;
+                }
+                else
+                {
+                    members = new Dictionary<string, Func<object, object>>();
+                    _memberAccessors[type] = members;
+                }

-            // BEGIN ADDED FOR C#
-            MethodInfo method = null;
-            if ( method == null )
-            {
-                System.Reflection.PropertyInfo p = type.GetProperty( methodSuffix );
-                if ( p != null )
-                    method = p.GetGetMethod();
-            }
-            if ( method == null )
-            {
-                method = GetMethod( type, "Get" + methodSuffix );
-            }
-            if ( method == null )
-            {
-                method = GetMethod( type, "Is" + methodSuffix );
-            }
-            // END ADDED
-            if ( method == null )
-            {
-                method = GetMethod( type, "get" + methodSuffix );
-            }
-            if ( method == null )
-            {
-                method = GetMethod( type, "is" + methodSuffix );
-            }
+                // must look up using reflection
+                string methodSuffix = char.ToUpperInvariant( name[0] ) + name.Substring( 1 );

-            if ( method != null )
-            {
-                accessor = BuildAccessor( method );
-            }
-            else
-            {
-                // try for a visible field
-                FieldInfo field = type.GetField( name );
-                // also check .NET naming convention for fields
-                if ( field == null )
-                    field = type.GetField( "_" + name );
-
-                if ( field != null )
-                    accessor = BuildAccessor( field );
-            }
+                // BEGIN ADDED FOR C#
+                MethodInfo method = null;
+                if ( method == null )
+                {
+                    System.Reflection.PropertyInfo p = type.GetProperty( methodSuffix );
+                    if ( p != null )
+                        method = p.GetGetMethod();
+                }
+                if ( method == null )
+                {
+                    method = GetMethod( type, "Get" + methodSuffix );
+                }
+                if ( method == null )
+                {
+                    method = GetMethod( type, "Is" + methodSuffix );
+                }
+                // END ADDED
+                if ( method == null )
+                {
+                    method = GetMethod( type, "get" + methodSuffix );
+                }
+                if ( method == null )
+                {
+                    method = GetMethod( type, "is" + methodSuffix );
+                }

-            members[name] = accessor;
-            return accessor;
+                if ( method != null )
+                {
+                    accessor = BuildAccessor( method );
+                }
+                else
+                {
+                    // try for a visible field
+                    FieldInfo field = type.GetField( name );
+                    // also check .NET naming convention for fields
+                    if ( field == null )
+                        field = type.GetField( "_" + name );
+
+                    if ( field != null )
+                        accessor = BuildAccessor( field );
+                }
+
+                members[name] = accessor;
+
+                return accessor;
+            }
}

static Func<object, object> BuildAccessor( MethodInfo method )
@@ -730,12 +734,11 @@ namespace Antlr3.ST.Language
value = ( (StringTemplate.Aggregate)o ).Get( (string)propertyName2 );
return value;
}
-
-            // Special case: if it's a template, pull property from
-            // it's attribute table.
-            // TODO: TJP just asked himself why we can't do inherited attr here?
else if ( c == typeof( StringTemplate ) )
{
+                // Special case: if it's a template, pull property from
+                // it's attribute table.
+                // TODO: TJP just asked himself why we can't do inherited attr here?
var attributes = ( (StringTemplate)o ).Attributes;
if ( attributes != null )
{
@@ -747,9 +750,9 @@ namespace Antlr3.ST.Language

// Special case: if it's a Map then pull using
// key not the property method.
-            if ( o is IDictionary )
+            IDictionary map = o as IDictionary;
+            if ( map != null )
{
-                IDictionary map = (IDictionary)o;
if ( property.Equals( "keys" ) )
{
value = map.Keys;
@@ -837,27 +840,33 @@ namespace Antlr3.ST.Language
{
return false;
}
-            if ( a is Boolean )
+            if ( a is bool )
{
return (bool)a;
}
-            if ( a is ICollection )
-            {
-                return ( (ICollection)a ).Count > 0;
-            }
-            if ( a is IDictionary )
-            {
-                return ( (IDictionary)a ).Count > 0;
-            }
-            if ( a is IEnumerable && !( a is string ) )
-            {
-                return ( (IEnumerable)a ).GetEnumerator().MoveNext();
-            }
-            if ( a is Iterator )
-            {
-                return ( (Iterator)a ).hasNext();
-            }
-            return true; // any other non-null object, return true--it's present
+
+            string str = a as string;
+            if ( str != null )
+                return true;
+
+            ICollection collection = a as ICollection;
+            if ( collection != null )
+                return collection.Count > 0;
+
+            IDictionary dictionary = a as IDictionary;
+            if ( dictionary != null )
+                return dictionary.Count > 0;
+
+            IEnumerable enumerable = a as IEnumerable;
+            if ( enumerable != null )
+                return enumerable.GetEnumerator().MoveNext();
+
+            Iterator iterator = a as Iterator;
+            if ( iterator != null )
+                return iterator.hasNext();
+
+            // any other non-null object, return true--it's present
+            return true;
}

/** <summary>
@@ -868,7 +877,8 @@ namespace Antlr3.ST.Language
public virtual object Add( object a, object b )
{
if ( a == null )
-            { // a null value means don't do cat, just return other value
+            {
+                // a null value means don't do cat, just return other value
return b;
}
else if ( b == null )
@@ -943,9 +953,9 @@ namespace Antlr3.ST.Language
int n = 0;
try
{
-                if ( o is StringTemplate )
+                StringTemplate stToWrite = o as StringTemplate;
+                if ( stToWrite != null )
{
-                    StringTemplate stToWrite = (StringTemplate)o;
// failsafe: perhaps enclosing instance not set
// Or, it could be set to another context!  This occurs
// when you store a template instance as an attribute of more
@@ -1078,7 +1088,9 @@ namespace Antlr3.ST.Language
{
return null;
}
-            if ( expr is StringTemplateAST )
+
+            StringTemplateAST exprAST = expr as StringTemplateAST;
+            if ( exprAST != null )
{
#if COMPILE_EXPRESSIONS
System.Func<StringTemplate, IStringTemplateWriter, int> value;
@@ -1086,14 +1098,11 @@ namespace Antlr3.ST.Language
if ( !_evaluators.TryGetValue( expr, out value ) )
#endif
{
-                    StringTemplateAST exprAST = (StringTemplateAST)expr;
value = GetEvaluator( this, exprAST );
#if CACHE_FUNCTORS
_evaluators[expr] = value;
#endif
}
-#else
-                StringTemplateAST exprAST = (StringTemplateAST)expr;
#endif
// must evaluate, writing to a string so we can hang on to it
StringWriter buf = new StringWriter();
@@ -1191,65 +1200,50 @@ namespace Antlr3.ST.Language
*/
public static object ConvertArrayToList( object value )
{
-            if ( value == null )
-            {
-                return null;
-            }
-            if ( value.GetType().IsArray )
-            {
-                if ( value.GetType().GetElementType().IsPrimitive )
-                {
-                    return (IList)value;
-                }
-                return (IList)(object[])value;
-            }
+            // .NET arrays implement IList
return value;
}

protected internal static object ConvertAnythingIteratableToIterator( object o )
{
-            Iterator iter = null;
-            if ( o is IDictionary )
-            {
-                iter = ( (IDictionary)o ).Values.iterator();
-            }
-            else if ( o is System.Collections.IEnumerable && !(o is string) )
-            {
-                iter = ( (System.Collections.IEnumerable)o ).Cast<object>().iterator();
-            }
-            else if ( o is Iterator )
-            {
-                iter = (Iterator)o;
-            }
-            if ( iter == null )
-            {
-                return o;
-            }
-            return iter;
+            if ( o == null )
+                return null;
+
+            string str = o as string;
+            if ( str != null )
+                return str;
+
+            IDictionary dictionary = o as IDictionary;
+            if ( dictionary != null )
+                return dictionary.Values.iterator();
+
+            ICollection collection = o as ICollection;
+            if ( collection != null )
+                return collection.iterator();
+
+            IEnumerable enumerable = o as IEnumerable;
+            if ( enumerable != null )
+                return enumerable.Cast<object>().iterator();
+
+            //// This code is implied in the last line
+            //Iterator iterator = o as Iterator;
+            //if ( iterator != null )
+            //    return iterator;
+
+            return o;
}

protected static Iterator ConvertAnythingToIterator( object o )
{
-            Iterator iter = null;
-            if ( o is ICollection )
-            {
-                iter = ( (ICollection)o ).iterator();
-            }
-            else if ( o is IDictionary )
-            {
-                iter = ( (IDictionary)o ).Values.iterator();
-            }
-            else if ( o is Iterator )
-            {
-                iter = (Iterator)o;
-            }
-            if ( iter == null )
-            {
-                IList singleton = new StringTemplate.STAttributeList( 1 );
-                singleton.Add( o );
-                return singleton.iterator();
-            }
-            return iter;
+            o = ConvertAnythingIteratableToIterator( o );
+
+            Iterator iter = o as Iterator;
+            if ( iter != null )
+                return iter;
+
+            var singleton = new StringTemplate.STAttributeList( 1 );
+            singleton.Add( o );
+            return singleton.iterator();
}

/** <summary>
@@ -1265,9 +1259,9 @@ namespace Antlr3.ST.Language
}
object f = attribute;
attribute = ConvertAnythingIteratableToIterator( attribute );
-            if ( attribute is Iterator )
+            Iterator it = attribute as Iterator;
+            if ( it != null )
{
-                Iterator it = (Iterator)attribute;
if ( it.hasNext() )
{
f = it.next();
@@ -1290,10 +1284,10 @@ namespace Antlr3.ST.Language
}
object theRest = attribute;
attribute = ConvertAnythingIteratableToIterator( attribute );
-            if ( attribute is Iterator )
+            Iterator it = attribute as Iterator;
+            if ( it != null )
{
IList a = new List<object>();
-                Iterator it = (Iterator)attribute;
if ( !it.hasNext() )
{
return null; // if not even one value return null
@@ -1301,7 +1295,7 @@ namespace Antlr3.ST.Language
it.next(); // ignore first value
while ( it.hasNext() )
{
-                    object o = (object)it.next();
+                    object o = it.next();
if ( o != null )
a.Add( o );
}
@@ -1330,9 +1324,9 @@ namespace Antlr3.ST.Language
}
object last = attribute;
attribute = ConvertAnythingIteratableToIterator( attribute );
-            if ( attribute is Iterator )
+            Iterator it = attribute as Iterator;
+            if ( it != null )
{
-                Iterator it = (Iterator)attribute;
while ( it.hasNext() )
{
last = it.next();
@@ -1350,13 +1344,13 @@ namespace Antlr3.ST.Language
return null;
}
attribute = ConvertAnythingIteratableToIterator( attribute );
-            if ( attribute is Iterator )
+            Iterator it = attribute as Iterator;
+            if ( it != null )
{
-                IList a = new List<object>();
-                Iterator it = (Iterator)attribute;
+                var a = new List<object>();
while ( it.hasNext() )
{
-                    object o = (object)it.next();
+                    object o = it.next();
if ( o != null )
a.Add( o );
}
@@ -1373,10 +1367,10 @@ namespace Antlr3.ST.Language
return null;
}
attribute = ConvertAnythingIteratableToIterator( attribute );
-            if ( attribute is Iterator )
+            Iterator it = attribute as Iterator;
+            if ( it != null )
{
-                IList a = new List<object>();
-                Iterator it = (Iterator)attribute;
+                var a = new List<object>();
while ( it.hasNext() )
{
object o = (object)it.next();
@@ -1398,54 +1392,37 @@ namespace Antlr3.ST.Language
public virtual object Length( object attribute )
{
if ( attribute == null )
-            {
return 0;
-            }
-            int i = 1;		// we have at least one of something. Iterator and arrays might be empty.
-            if ( attribute is IDictionary )
-            {
-                i = ( (IDictionary)attribute ).Count;
-            }
-            else if ( attribute is ICollection )
-            {
-                i = ( (ICollection)attribute ).Count;
-            }
-            else if ( attribute is object[] )
-            {
-                object[] list = (object[])attribute;
-                i = list.Length;
-            }
-            else if ( attribute is int[] )
-            {
-                int[] list = (int[])attribute;
-                i = list.Length;
-            }
-            else if ( attribute is long[] )
-            {
-                long[] list = (long[])attribute;
-                i = list.Length;
-            }
-            else if ( attribute is float[] )
-            {
-                float[] list = (float[])attribute;
-                i = list.Length;
-            }
-            else if ( attribute is double[] )
-            {
-                double[] list = (double[])attribute;
-                i = list.Length;
-            }
-            else if ( attribute is Iterator )
+
+            string str = attribute as string;
+            if ( str != null )
+                return 1;
+
+            ICollection collection = attribute as ICollection;
+            if ( collection != null )
+                return collection.Count;
+
+            IDictionary dictionary = attribute as IDictionary;
+            if ( dictionary != null )
+                return dictionary.Count;
+
+            IEnumerable enumerable = attribute as IEnumerable;
+            if ( enumerable != null )
+                return enumerable.Cast<object>().Count();
+
+            Iterator iterator = attribute as Iterator;
+            if ( iterator != null )
{
-                Iterator it = (Iterator)attribute;
-                i = 0;
-                while ( it.hasNext() )
+                int i = 0;
+                while ( iterator.hasNext() )
{
-                    it.next();
+                    iterator.next();
i++;
}
+                return i;
}
-            return i;
+
+            return 1;
}

public object GetOption( string name )
@@ -1456,7 +1433,7 @@ namespace Antlr3.ST.Language
if ( _options.TryGetValue( name, out value ) )
{
string s = value as string;
-                    if ( s != null && s == EmptyOption )
+                    if ( s == EmptyOption )
{
StringTemplateAST st;
if ( _defaultOptionValues.TryGetValue( name, out st ) )
diff --git a/Antlr3.Test/BaseTest.cs b/Antlr3.Test/BaseTest.cs
index 0da5592..63733b8 100644
--- a/Antlr3.Test/BaseTest.cs
+++ b/Antlr3.Test/BaseTest.cs
@@ -39,7 +39,9 @@ namespace AntlrUnitTests
using Microsoft.VisualStudio.TestTools.UnitTesting;

using AntlrTool = Antlr3.AntlrTool;
+    using BindingFlags = System.Reflection.BindingFlags;
using ErrorManager = Antlr3.Tool.ErrorManager;
+    using FieldInfo = System.Reflection.FieldInfo;
using GrammarSemanticsMessage = Antlr3.Tool.GrammarSemanticsMessage;
using IANTLRErrorListener = Antlr3.Tool.IANTLRErrorListener;
using IList = System.Collections.IList;
@@ -133,8 +135,8 @@ namespace AntlrUnitTests

private void VerifyImportedTokens( Type source, Type target )
{
-            System.Reflection.FieldInfo namesField = source.GetField( "tokenNames" );
-            System.Reflection.FieldInfo targetNamesField = target.GetField( "tokenNames" );
+            FieldInfo namesField = source.GetField( "tokenNames", BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public );
+            FieldInfo targetNamesField = target.GetField( "tokenNames", BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public );
Assert.IsNotNull( namesField, string.Format( "No tokenNames field was found in grammar {0}.", source.Name ) );

string[] sourceNames = namesField.GetValue( null ) as string[];
@@ -166,8 +168,8 @@ namespace AntlrUnitTests
}
}

-                System.Reflection.FieldInfo sourceToken = source.GetField( tokenName );
-                System.Reflection.FieldInfo targetToken = target.GetField( tokenName );
+                FieldInfo sourceToken = source.GetField( tokenName );
+                FieldInfo targetToken = target.GetField( tokenName );
if ( source != null && target != null )
{
int sourceValue = (int)sourceToken.GetValue( null );
diff --git a/Antlr3.Test/TestTrees.cs b/Antlr3.Test/TestTrees.cs
index 584e06e..d5cde17 100644
--- a/Antlr3.Test/TestTrees.cs
+++ b/Antlr3.Test/TestTrees.cs
@@ -51,29 +51,29 @@ namespace AntlrUnitTests
public int x;
public V( IToken t )
{
-                this.token = t;
+                this.Token = t;
}
public V( int ttype, int x )
{
this.x = x;
-                token = new CommonToken( ttype );
+                Token = new CommonToken( ttype );
}
public V( int ttype, IToken t, int x )
{
-                token = t;
+                Token = t;
this.x = x;
}
public override string ToString()
{
-                return ( token != null ? token.Text : "" ) + "<V>";
+                return ( Token != null ? Token.Text : "" ) + "<V>";
}
}

[TestMethod]
public void TestSingleNode() /*throws Exception*/ {
CommonTree t = new CommonTree( new CommonToken( 101 ) );
-            assertNull( t.parent );
-            assertEquals( -1, t.childIndex );
+            assertNull( t.Parent );
+            assertEquals( -1, t.ChildIndex );
}

[TestMethod]
@@ -83,10 +83,10 @@ namespace AntlrUnitTests
CommonTree u = new V( new CommonToken( 102, "102" ) );
adaptor.AddChild( root_0, t );
adaptor.AddChild( root_0, u );
-            assertNull( root_0.parent );
-            assertEquals( -1, root_0.childIndex );
-            assertEquals( 0, t.childIndex );
-            assertEquals( 1, u.childIndex );
+            assertNull( root_0.Parent );
+            assertEquals( -1, root_0.ChildIndex );
+            assertEquals( 0, t.ChildIndex );
+            assertEquals( 1, u.ChildIndex );
}

[TestMethod]
@@ -97,8 +97,8 @@ namespace AntlrUnitTests
r0.GetChild( 0 ).AddChild( new CommonTree( new CommonToken( 103 ) ) );
r0.AddChild( new CommonTree( new CommonToken( 104 ) ) );

-            assertNull( r0.parent );
-            assertEquals( -1, r0.childIndex );
+            assertNull( r0.Parent );
+            assertEquals( -1, r0.ChildIndex );
}

[TestMethod]
@@ -110,14 +110,14 @@ namespace AntlrUnitTests
r0.AddChild( c1 = new CommonTree( new CommonToken( 102 ) ) );
r0.AddChild( c2 = new CommonTree( new CommonToken( 103 ) ) );

-            assertNull( r0.parent );
-            assertEquals( -1, r0.childIndex );
-            assertEquals( r0, c0.parent );
-            assertEquals( 0, c0.childIndex );
-            assertEquals( r0, c1.parent );
-            assertEquals( 1, c1.childIndex );
-            assertEquals( r0, c2.parent );
-            assertEquals( 2, c2.childIndex );
+            assertNull( r0.Parent );
+            assertEquals( -1, r0.ChildIndex );
+            assertEquals( r0, c0.Parent );
+            assertEquals( 0, c0.ChildIndex );
+            assertEquals( r0, c1.Parent );
+            assertEquals( 1, c1.ChildIndex );
+            assertEquals( r0, c2.Parent );
+            assertEquals( 2, c2.ChildIndex );
}

[TestMethod]
@@ -135,15 +135,15 @@ namespace AntlrUnitTests

root.AddChild( r0 );

-            assertNull( root.parent );
-            assertEquals( -1, root.childIndex );
+            assertNull( root.Parent );
+            assertEquals( -1, root.ChildIndex );
// check children of root all point at root
-            assertEquals( root, c0.parent );
-            assertEquals( 0, c0.childIndex );
-            assertEquals( root, c0.parent );
-            assertEquals( 1, c1.childIndex );
-            assertEquals( root, c0.parent );
-            assertEquals( 2, c2.childIndex );
+            assertEquals( root, c0.Parent );
+            assertEquals( 0, c0.ChildIndex );
+            assertEquals( root, c0.Parent );
+            assertEquals( 1, c1.ChildIndex );
+            assertEquals( root, c0.Parent );
+            assertEquals( 2, c2.ChildIndex );
}

[TestMethod]
@@ -162,15 +162,15 @@ namespace AntlrUnitTests

root.AddChild( r0 );

-            assertNull( root.parent );
-            assertEquals( -1, root.childIndex );
+            assertNull( root.Parent );
+            assertEquals( -1, root.ChildIndex );
// check children of root all point at root
-            assertEquals( root, c0.parent );
-            assertEquals( 1, c0.childIndex );
-            assertEquals( root, c0.parent );
-            assertEquals( 2, c1.childIndex );
-            assertEquals( root, c0.parent );
-            assertEquals( 3, c2.childIndex );
+            assertEquals( root, c0.Parent );
+            assertEquals( 1, c0.ChildIndex );
+            assertEquals( root, c0.Parent );
+            assertEquals( 2, c1.ChildIndex );
+            assertEquals( root, c0.Parent );
+            assertEquals( 3, c2.ChildIndex );
}

[TestMethod]
@@ -188,8 +188,8 @@ namespace AntlrUnitTests

CommonTree dup = (CommonTree)( new CommonTreeAdaptor() ).DupTree( r0 );

-            assertNull( dup.parent );
-            assertEquals( -1, dup.childIndex );
+            assertNull( dup.Parent );
+            assertEquals( -1, dup.ChildIndex );
dup.SanityCheckParentAndChildIndexes();
}

diff --git a/Antlr3/Analysis/DFAState.cs b/Antlr3/Analysis/DFAState.cs
index b5f2499..20b039f 100644
--- a/Antlr3/Analysis/DFAState.cs
+++ b/Antlr3/Analysis/DFAState.cs
@@ -195,6 +195,13 @@ namespace Antlr3.Analysis
return GetAltSet();
}
}
+        public bool AtLeastOneConfigurationHasAPredicate
+        {
+            get
+            {
+                return _atLeastOneConfigurationHasAPredicate;
+            }
+        }
public ICollection<int> DisabledAlternatives
{
get
diff --git a/Antlr3/Analysis/NFAtoDFAConverter.cs b/Antlr3/Analysis/NFAtoDFAConverter.cs
index 99ea84d..74d31c0 100644
--- a/Antlr3/Analysis/NFAtoDFAConverter.cs
+++ b/Antlr3/Analysis/NFAtoDFAConverter.cs
@@ -1721,7 +1721,7 @@ namespace Antlr3.Analysis
// incoming label, unless it's EOF, w/o a predicate.
if ( s.incidentEdgeLabel != null && s.incidentEdgeLabel.label != Label.EOF )
{
-                            if ( s.associatedASTNode == null || s.associatedASTNode.token == null )
+                            if ( s.associatedASTNode == null || s.associatedASTNode.Token == null )
{
ErrorManager.InternalError( "no AST/token for nonepsilon target w/o predicate" );
}
@@ -1733,7 +1733,7 @@ namespace Antlr3.Analysis
locations = new HashSet<IToken>();
altToLocationsReachableWithoutPredicate[altI] = locations;
}
-                                locations.Add( s.associatedASTNode.token );
+                                locations.Add( s.associatedASTNode.Token );
}
}
}
diff --git a/Antlr3/Codegen/CodeGenerator.cs b/Antlr3/Codegen/CodeGenerator.cs
index f5b648d..2a2096a 100644
--- a/Antlr3/Codegen/CodeGenerator.cs
+++ b/Antlr3/Codegen/CodeGenerator.cs
@@ -1092,7 +1092,7 @@ namespace Antlr3.Codegen
}
ActionTranslator translator = new ActionTranslator( this, ruleName, actionTree );
IList chunks = translator.TranslateToChunks();
-            chunks = target.PostProcessAction( chunks, actionTree.token );
+            chunks = target.PostProcessAction( chunks, actionTree.Token );
return chunks;
}

@@ -1104,7 +1104,7 @@ namespace Antlr3.Codegen
public virtual List<StringTemplate> TranslateArgAction( string ruleName,
GrammarAST actionTree )
{
-            string actionText = actionTree.token.Text;
+            string actionText = actionTree.Token.Text;
List<string> args = GetListOfArgumentsFromAction( actionText, ',' );
List<StringTemplate> translatedArgs = new List<StringTemplate>();
foreach ( string arg in args )
diff --git a/Antlr3/Grammars/ANTLRParser.cs b/Antlr3/Grammars/ANTLRParser.cs
index f4e100a..0026f3a 100644
--- a/Antlr3/Grammars/ANTLRParser.cs
+++ b/Antlr3/Grammars/ANTLRParser.cs
@@ -1,4 +1,4 @@
-// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-04-24 11:17:04
+// $ANTLR 3.1.2 Grammars\\ANTLR.g3 2009-05-07 18:09:39

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
@@ -78,7 +78,7 @@ namespace Antlr3.Grammars
*/
public partial class ANTLRParser : Parser
{
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ACTION", "ACTION_CHAR_LITERAL", "ACTION_ESC", "ACTION_STRING_LITERAL", "ALT", "AMPERSAND", "ARG", "ARG_ACTION", "ARGLIST", "ASSIGN", "BACKTRACK_SEMPRED", "BANG", "BLOCK", "CATCH", "CHAR_LITERAL", "CHAR_RANGE", "CLOSE_ELEMENT_OPTION", "CLOSURE", "COLON", "COMBINED_GRAMMAR", "COMMA", "COMMENT", "DIGIT", "DOC_COMMENT", "DOLLAR", "DOT", "DOUBLE_ANGLE_STRING_LITERAL", "DOUBLE_QUOTE_STRING_LITERAL", "EOA", "EOB", "EOR", "EPSILON", "ESC", "ETC", "FINALLY", "FORCED_ACTION", "FRAGMENT", "GATED_SEMPRED", "GRAMMAR", "ID", "IMPLIES", "IMPORT", "INITACTION", "INT", "LABEL", "LEXER", "LEXER_GRAMMAR", "LPAREN", "ML_COMMENT", "NESTED_ACTION", "NESTED_ARG_ACTION", "NOT", "OPEN_ELEMENT_OPTION", "OPTIONAL", "OPTIONS", "OR", "PARSER", "PARSER_GRAMMAR", "PLUS", "PLUS_ASSIGN", "POSITIVE_CLOSURE", "PRIVATE", "PROTECTED", "PUBLIC", "QUESTION", "RANGE", "RCURLY", "RET", "RETURNS", "REWRITE", "ROOT", "RPAREN", "RULE", "RULE_REF", "SCOPE", "SEMI", "SEMPRED", "SL_COMMENT", "SRC", "STAR", "STRAY_BRACKET", "STRING_LITERAL", "SYN_SEMPRED", "SYNPRED", "TEMPLATE", "THROWS", "TOKEN_REF", "TOKENS", "TREE", "TREE_BEGIN", "TREE_GRAMMAR", "WILDCARD", "WS", "WS_LOOP", "WS_OPT", "XDIGIT"
};
public const int EOF=-1;
@@ -217,7 +217,7 @@ public partial class ANTLRParser : Parser
#region Rules
public class grammar__return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -352,7 +352,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec3.Tree);
if ( state.backtracking == 0 )
{
-					opts = (optionsSpec3!=null?optionsSpec3.opts:default(IDictionary<string, object>)); Grammar.SetOptions(opts, (optionsSpec3!=null?((IToken)optionsSpec3.start):null));
+					opts = (optionsSpec3!=null?optionsSpec3.opts:default(IDictionary<string, object>)); Grammar.SetOptions(opts, (optionsSpec3!=null?((IToken)optionsSpec3.Start):null));
}

}
@@ -546,7 +546,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-					Cleanup( ((GrammarAST)retval.tree) );
+					Cleanup( ((GrammarAST)retval.Tree) );

}
}
@@ -566,7 +566,7 @@ public partial class ANTLRParser : Parser

public class grammarType_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -820,7 +820,7 @@ public partial class ANTLRParser : Parser

public class actions_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -912,7 +912,7 @@ public partial class ANTLRParser : Parser

public class action_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -1038,7 +1038,7 @@ public partial class ANTLRParser : Parser

public class actionScopeName_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -1200,7 +1200,7 @@ public partial class ANTLRParser : Parser
public class optionsSpec_return : ParserRuleReturnScope
{
public IDictionary<string, object> opts=new Dictionary<string, object>();
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -1305,7 +1305,7 @@ public partial class ANTLRParser : Parser

public class option_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -1382,7 +1382,7 @@ public partial class ANTLRParser : Parser
public class optionValue_return : ParserRuleReturnScope
{
public object value=null;
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -1586,7 +1586,7 @@ public partial class ANTLRParser : Parser

public class delegateGrammars_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -1692,7 +1692,7 @@ public partial class ANTLRParser : Parser

public class delegateGrammar_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -1791,7 +1791,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) adaptor.AddChild(root_0, g.Tree);
if ( state.backtracking == 0 )
{
-					Grammar.ImportGrammar((g!=null?((GrammarAST)g.tree):null), (lab!=null?input.ToString(lab.start,lab.stop):null));
+					Grammar.ImportGrammar((g!=null?((GrammarAST)g.Tree):null), (lab!=null?input.ToString(lab.start,lab.stop):null));
}

}
@@ -1809,7 +1809,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) adaptor.AddChild(root_0, g2.Tree);
if ( state.backtracking == 0 )
{
-					Grammar.ImportGrammar((g2!=null?((GrammarAST)g2.tree):null),null);
+					Grammar.ImportGrammar((g2!=null?((GrammarAST)g2.Tree):null),null);
}

}
@@ -1840,7 +1840,7 @@ public partial class ANTLRParser : Parser

public class tokensSpec_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -1942,7 +1942,7 @@ public partial class ANTLRParser : Parser

public class tokenSpec_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -2043,7 +2043,7 @@ public partial class ANTLRParser : Parser

public class attrScopes_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -2129,7 +2129,7 @@ public partial class ANTLRParser : Parser

public class attrScope_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -2225,7 +2225,7 @@ public partial class ANTLRParser : Parser

public class rules_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -2317,7 +2317,7 @@ public partial class ANTLRParser : Parser

public class rule_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -2828,7 +2828,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-						((GrammarAST)((GrammarAST)retval.tree).GetChild(0)).BlockOptions = (optionsSpec45!=null?optionsSpec45.opts:default(IDictionary<string, object>));
+						((GrammarAST)((GrammarAST)retval.Tree).GetChild(0)).BlockOptions = (optionsSpec45!=null?optionsSpec45.opts:default(IDictionary<string, object>));

}

@@ -2858,7 +2858,7 @@ public partial class ANTLRParser : Parser

public class ruleActions_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -2950,7 +2950,7 @@ public partial class ANTLRParser : Parser

public class ruleAction_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -3020,7 +3020,7 @@ public partial class ANTLRParser : Parser

public class throwsSpec_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -3123,7 +3123,7 @@ public partial class ANTLRParser : Parser

public class ruleScopeSpec_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -3274,7 +3274,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:376:6: ^( SCOPE[$start,\"scope\"] ( ruleActions )? ( ACTION )? ( idList )* )
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SCOPE, ((IToken)retval.start), "scope"), root_1);
+				root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SCOPE, ((IToken)retval.Start), "scope"), root_1);

// Grammars\\ANTLR.g3:376:30: ( ruleActions )?
if ( stream_ruleActions.HasNext )
@@ -3333,7 +3333,7 @@ public partial class ANTLRParser : Parser

public class block_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -3416,7 +3416,7 @@ public partial class ANTLRParser : Parser

if ( state.backtracking == 0 )
{
-				currentBlockAST = (GrammarAST)((GrammarAST)retval.tree).GetChild(0);
+				currentBlockAST = (GrammarAST)((GrammarAST)retval.Tree).GetChild(0);
}
// Grammars\\ANTLR.g3:390:3: ( ( optionsSpec )? ( ruleActions )? COLON | ACTION COLON )?
int alt36=3;
@@ -3461,7 +3461,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_optionsSpec.Add(optionsSpec64.Tree);
if ( state.backtracking == 0 )
{
-						((GrammarAST)((GrammarAST)retval.tree).GetChild(0)).SetOptions(Grammar,(optionsSpec64!=null?optionsSpec64.opts:default(IDictionary<string, object>)));
+						((GrammarAST)((GrammarAST)retval.Tree).GetChild(0)).SetOptions(Grammar,(optionsSpec64!=null?optionsSpec64.opts:default(IDictionary<string, object>)));
}

}
@@ -3530,9 +3530,9 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-							stream_alternative.Add( (r!=null?((GrammarAST)r.tree):null) );
+							stream_alternative.Add( (r!=null?((GrammarAST)r.Tree):null) );
if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
-								PrefixWithSynPred((a!=null?((GrammarAST)a.tree):null));
+								PrefixWithSynPred((a!=null?((GrammarAST)a.Tree):null));

}
// Grammars\\ANTLR.g3:406:3: ( OR a= alternative r= rewrite )*
@@ -3570,9 +3570,9 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-										stream_alternative.Add( (r!=null?((GrammarAST)r.tree):null) );
+										stream_alternative.Add( (r!=null?((GrammarAST)r.Tree):null) );
if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
-											PrefixWithSynPred((a!=null?((GrammarAST)a.tree):null));
+											PrefixWithSynPred((a!=null?((GrammarAST)a.Tree):null));

}

@@ -3682,7 +3682,7 @@ public partial class ANTLRParser : Parser

public class altList_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -3735,7 +3735,7 @@ public partial class ANTLRParser : Parser
root_0 = (GrammarAST)adaptor.Nil();
// 425:6: -> BLOCK[$start,\"BLOCK\"]
{
-				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, ((IToken)retval.start), "BLOCK"));
+				adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(BLOCK, ((IToken)retval.Start), "BLOCK"));

}

@@ -3748,7 +3748,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-							blkRoot = (GrammarAST)((GrammarAST)retval.tree).GetChild(0);
+							blkRoot = (GrammarAST)((GrammarAST)retval.Tree).GetChild(0);
blkRoot.BlockOptions = opts;
currentBlockAST = blkRoot;

@@ -3770,7 +3770,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_rewrite.Add(r1.Tree);
if ( state.backtracking == 0 )
{
-				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a1!=null?((GrammarAST)a1.tree):null));
+				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a1!=null?((GrammarAST)a1.Tree):null));
}


@@ -3842,7 +3842,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 ) stream_rewrite.Add(r2.Tree);
if ( state.backtracking == 0 )
{
-						if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a2!=null?((GrammarAST)a2.tree):null));
+						if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) PrefixWithSynPred((a2!=null?((GrammarAST)a2.Tree):null));
}


@@ -3952,7 +3952,7 @@ public partial class ANTLRParser : Parser

public class alternative_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -4056,7 +4056,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:445:6: ^( ALT[$start,\"ALT\"] ( element )+ EOA[\"<end-of-alt>\"] )
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, ((IToken)retval.start), "ALT"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, ((IToken)retval.Start), "ALT"), root_1);

if ( !(stream_element.HasNext) )
{
@@ -4105,9 +4105,9 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:447:6: ^( ALT[$start,\"ALT\"] EPSILON[$start,\"epsilon\"] EOA[\"<end-of-alt>\"] )
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, ((IToken)retval.start), "ALT"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(ALT, ((IToken)retval.Start), "ALT"), root_1);

-					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, ((IToken)retval.start), "epsilon"));
+					adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EPSILON, ((IToken)retval.Start), "epsilon"));
adaptor.AddChild(root_1, (GrammarAST)adaptor.Create(EOA, "<end-of-alt>"));

adaptor.AddChild(root_0, root_1);
@@ -4147,7 +4147,7 @@ public partial class ANTLRParser : Parser

public class exceptionGroup_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -4303,7 +4303,7 @@ public partial class ANTLRParser : Parser

public class exceptionHandler_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -4373,7 +4373,7 @@ public partial class ANTLRParser : Parser

public class finallyClause_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -4436,7 +4436,7 @@ public partial class ANTLRParser : Parser

public class element_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -4492,7 +4492,7 @@ public partial class ANTLRParser : Parser

public class elementNoOptionSpec_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -4671,7 +4671,7 @@ public partial class ANTLRParser : Parser
if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-						root_0 = (sub!=null?((GrammarAST)sub.tree):null);
+						root_0 = (sub!=null?((GrammarAST)sub.Tree):null);
}

}
@@ -4705,13 +4705,13 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:477:6: sub2= ebnfSuffix[$a.tree,false]
{
PushFollow(Follow._ebnfSuffix_in_elementNoOptionSpec1805);
-					sub2=ebnfSuffix((a!=null?((GrammarAST)a.tree):null), false);
+					sub2=ebnfSuffix((a!=null?((GrammarAST)a.Tree):null), false);

state._fsp--;
if (state.failed) return retval;
if ( state.backtracking == 0 )
{
-						root_0=(sub2!=null?((GrammarAST)sub2.tree):null);
+						root_0=(sub2!=null?((GrammarAST)sub2.Tree):null);
}

}
@@ -4839,7 +4839,7 @@ public partial class ANTLRParser : Parser

public class atom_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -5164,7 +5164,7 @@ public partial class ANTLRParser : Parser

public class ruleref_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -5289,7 +5289,7 @@ public partial class ANTLRParser : Parser

public class notSet_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -5395,7 +5395,7 @@ public partial class ANTLRParser : Parser

public class treeRoot_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -5658,7 +5658,7 @@ public partial class ANTLRParser : Parser

public class tree__return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -5767,7 +5767,7 @@ public partial class ANTLRParser : Parser

public class ebnf_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -5902,7 +5902,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:533:7: ^( OPTIONAL[$start,\"?\"] block )
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, ((IToken)retval.start), "?"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, ((IToken)retval.Start), "?"), root_1);

adaptor.AddChild(root_1, stream_block.NextTree());

@@ -5943,7 +5943,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:535:7: ^( CLOSURE[$start,\"*\"] block )
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, ((IToken)retval.start), "*"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, ((IToken)retval.Start), "*"), root_1);

adaptor.AddChild(root_1, stream_block.NextTree());

@@ -5984,7 +5984,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:537:7: ^( POSITIVE_CLOSURE[$start,\"+\"] block )
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, ((IToken)retval.start), "+"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, ((IToken)retval.Start), "+"), root_1);

adaptor.AddChild(root_1, stream_block.NextTree());

@@ -6026,7 +6026,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:540:82: ^( SYNPRED[$start,\"=>\"] block )
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SYNPRED, ((IToken)retval.start), "=>"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(SYNPRED, ((IToken)retval.Start), "=>"), root_1);

adaptor.AddChild(root_1, stream_block.NextTree());

@@ -6036,7 +6036,7 @@ public partial class ANTLRParser : Parser
}
else // 542:4: ->
{
-					adaptor.AddChild(root_0, CreateSynSemPredFromBlock((block119!=null?((GrammarAST)block119.tree):null), SYN_SEMPRED));
+					adaptor.AddChild(root_0, CreateSynSemPredFromBlock((block119!=null?((GrammarAST)block119.Tree):null), SYN_SEMPRED));

}

@@ -6189,7 +6189,7 @@ public partial class ANTLRParser : Parser

public class range_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -6288,7 +6288,7 @@ public partial class ANTLRParser : Parser

public class terminal_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -6709,7 +6709,7 @@ public partial class ANTLRParser : Parser

public class elementOptions_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -6907,7 +6907,7 @@ public partial class ANTLRParser : Parser

public class defaultNodeOption_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -7022,7 +7022,7 @@ public partial class ANTLRParser : Parser

public class elementOption_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -7111,7 +7111,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-						object v = ((b!=null?((GrammarAST)b.tree):null)!=null)?(b!=null?input.ToString(b.start,b.stop):null):(s!=null?s.Text:null);
+						object v = ((b!=null?((GrammarAST)b.Tree):null)!=null)?(b!=null?input.ToString(b.start,b.stop):null):(s!=null?s.Text:null);
terminalAST.SetTerminalOption(Grammar,(a!=null?input.ToString(a.start,a.stop):null),v);

}
@@ -7142,7 +7142,7 @@ public partial class ANTLRParser : Parser

public class ebnfSuffix_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -7209,7 +7209,7 @@ public partial class ANTLRParser : Parser

if ( state.backtracking == 0 )
{
-				 blkRoot = (GrammarAST)((GrammarAST)retval.tree).GetChild(0); currentBlockAST = blkRoot;
+				 blkRoot = (GrammarAST)((GrammarAST)retval.Tree).GetChild(0); currentBlockAST = blkRoot;
}
// Grammars\\ANTLR.g3:613:3: ( -> ^( ALT[\"ALT\"] EOA[\"<end-of-alt>\"] ) )
// Grammars\\ANTLR.g3:614:4:
@@ -7254,7 +7254,7 @@ public partial class ANTLRParser : Parser
if ( state.backtracking == 0 )
{

-							alt = (GrammarAST)((GrammarAST)retval.tree).GetChild(0);
+							alt = (GrammarAST)((GrammarAST)retval.Tree).GetChild(0);
if ( !inRewrite )
PrefixWithSynPred(alt);

@@ -7465,7 +7465,7 @@ public partial class ANTLRParser : Parser

public class notTerminal_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -7530,7 +7530,7 @@ public partial class ANTLRParser : Parser

public class idList_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -7626,7 +7626,7 @@ public partial class ANTLRParser : Parser

public class id_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -7762,7 +7762,7 @@ public partial class ANTLRParser : Parser

public class rewrite_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -7938,7 +7938,7 @@ public partial class ANTLRParser : Parser

public class rewrite_with_sempred_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -8008,7 +8008,7 @@ public partial class ANTLRParser : Parser

public class rewrite_block_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -8107,7 +8107,7 @@ public partial class ANTLRParser : Parser

public class rewrite_alternative_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -8346,7 +8346,7 @@ public partial class ANTLRParser : Parser

public class rewrite_element_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -8458,7 +8458,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:685:5: subrule= ebnfSuffix[$t.tree,true]
{
PushFollow(Follow._ebnfSuffix_in_rewrite_element2913);
-					subrule=ebnfSuffix((t!=null?((GrammarAST)t.tree):null), true);
+					subrule=ebnfSuffix((t!=null?((GrammarAST)t.Tree):null), true);

state._fsp--;
if (state.failed) return retval;
@@ -8565,7 +8565,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:692:5: subrule= ebnfSuffix[$tr.tree,true]
{
PushFollow(Follow._ebnfSuffix_in_rewrite_element2961);
-					subrule=ebnfSuffix((tr!=null?((GrammarAST)tr.tree):null), true);
+					subrule=ebnfSuffix((tr!=null?((GrammarAST)tr.Tree):null), true);

state._fsp--;
if (state.failed) return retval;
@@ -8630,7 +8630,7 @@ public partial class ANTLRParser : Parser

public class rewrite_atom_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -8770,7 +8770,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:705:4: elementOptions[(GrammarAST)$tree.GetChild(0)]
{
PushFollow(Follow._elementOptions_in_rewrite_atom3012);
-					elementOptions171=elementOptions((GrammarAST)((GrammarAST)retval.tree).GetChild(0));
+					elementOptions171=elementOptions((GrammarAST)((GrammarAST)retval.Tree).GetChild(0));

state._fsp--;
if (state.failed) return retval;
@@ -8908,7 +8908,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:711:4: elementOptions[(GrammarAST)$tree.GetChild(0)]
{
PushFollow(Follow._elementOptions_in_rewrite_atom3066);
-					elementOptions173=elementOptions((GrammarAST)((GrammarAST)retval.tree).GetChild(0));
+					elementOptions173=elementOptions((GrammarAST)((GrammarAST)retval.Tree).GetChild(0));

state._fsp--;
if (state.failed) return retval;
@@ -8973,7 +8973,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:715:4: eo= elementOptions[(GrammarAST)$tree.GetChild(0)]
{
PushFollow(Follow._elementOptions_in_rewrite_atom3097);
-					eo=elementOptions((GrammarAST)((GrammarAST)retval.tree).GetChild(0));
+					eo=elementOptions((GrammarAST)((GrammarAST)retval.Tree).GetChild(0));

state._fsp--;
if (state.failed) return retval;
@@ -9016,7 +9016,7 @@ public partial class ANTLRParser : Parser
root_0 = (GrammarAST)adaptor.Nil();
// 717:3: -> LABEL[$i.start,$i.text]
{
-					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(LABEL, (i!=null?((IToken)i.start):null), (i!=null?input.ToString(i.start,i.stop):null)));
+					adaptor.AddChild(root_0, (GrammarAST)adaptor.Create(LABEL, (i!=null?((IToken)i.Start):null), (i!=null?input.ToString(i.start,i.stop):null)));

}

@@ -9065,7 +9065,7 @@ public partial class ANTLRParser : Parser

public class rewrite_ebnf_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -9158,7 +9158,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:724:7: ^( OPTIONAL[$b.start,\"?\"] $b)
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, (b!=null?((IToken)b.start):null), "?"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(OPTIONAL, (b!=null?((IToken)b.Start):null), "?"), root_1);

adaptor.AddChild(root_1, stream_b.NextTree());

@@ -9200,7 +9200,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:726:7: ^( CLOSURE[$b.start,\"*\"] $b)
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, (b!=null?((IToken)b.start):null), "*"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(CLOSURE, (b!=null?((IToken)b.Start):null), "*"), root_1);

adaptor.AddChild(root_1, stream_b.NextTree());

@@ -9242,7 +9242,7 @@ public partial class ANTLRParser : Parser
// Grammars\\ANTLR.g3:728:7: ^( POSITIVE_CLOSURE[$b.start,\"+\"] $b)
{
GrammarAST root_1 = (GrammarAST)adaptor.Nil();
-					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, (b!=null?((IToken)b.start):null), "+"), root_1);
+					root_1 = (GrammarAST)adaptor.BecomeRoot((GrammarAST)adaptor.Create(POSITIVE_CLOSURE, (b!=null?((IToken)b.Start):null), "+"), root_1);

adaptor.AddChild(root_1, stream_b.NextTree());

@@ -9287,7 +9287,7 @@ public partial class ANTLRParser : Parser

public class rewrite_tree_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -9390,7 +9390,7 @@ public partial class ANTLRParser : Parser

public class rewrite_template_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -9571,7 +9571,7 @@ public partial class ANTLRParser : Parser

if ( state.backtracking == 0 )
{
-					 adaptor.AddChild( ((GrammarAST)retval.tree).GetChild(0), adaptor.Create(st) );
+					 adaptor.AddChild( ((GrammarAST)retval.Tree).GetChild(0), adaptor.Create(st) );
}

}
@@ -9643,7 +9643,7 @@ public partial class ANTLRParser : Parser

public class rewrite_template_head_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -9750,7 +9750,7 @@ public partial class ANTLRParser : Parser

public class rewrite_indirect_template_head_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -9865,7 +9865,7 @@ public partial class ANTLRParser : Parser

public class rewrite_template_args_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -10057,7 +10057,7 @@ public partial class ANTLRParser : Parser

public class rewrite_template_arg_return : ParserRuleReturnScope
{
-		public GrammarAST tree;
+		internal GrammarAST tree;
public override object Tree { get { return tree; } }
}

@@ -10770,7 +10770,7 @@ public partial class ANTLRParser : Parser
#endregion DFA

#region Follow sets
-	public static class Follow
+	static class Follow
{
public static readonly BitSet _ACTION_in_grammar_308 = new BitSet(new ulong[]{0x1002040008000000UL,0x10000000UL});
public static readonly BitSet _DOC_COMMENT_in_grammar_319 = new BitSet(new ulong[]{0x1002040008000000UL,0x10000000UL});
diff --git a/Antlr3/Grammars/ActionTranslatorHelper.cs b/Antlr3/Grammars/ActionTranslatorHelper.cs
index c713d8c..3836143 100644
--- a/Antlr3/Grammars/ActionTranslatorHelper.cs
+++ b/Antlr3/Grammars/ActionTranslatorHelper.cs
@@ -61,12 +61,12 @@ namespace Antlr3.Grammars
public ActionTranslator( CodeGenerator generator,
string ruleName,
GrammarAST actionAST )
-            : this( new ANTLRStringStream( actionAST.token.Text ) )
+            : this( new ANTLRStringStream( actionAST.Token.Text ) )
{
this.generator = generator;
this.grammar = generator.grammar;
this.enclosingRule = grammar.GetLocallyDefinedRule( ruleName );
-            this.actionToken = actionAST.token;
+            this.actionToken = actionAST.Token;
this.outerAltNum = actionAST.outerAltNum;
}

diff --git a/Antlr3/Tool/Grammar.cs b/Antlr3/Tool/Grammar.cs
index 0514116..c3af4db 100644
--- a/Antlr3/Tool/Grammar.cs
+++ b/Antlr3/Tool/Grammar.cs
@@ -2774,7 +2774,7 @@ namespace Antlr3.Tool
{
ErrorManager.GrammarError( ErrorManager.MSG_INVALID_IMPORT,
this,
-                                              grammarNameAST.token,
+                                              grammarNameAST.Token,
this,
delegateGrammar );
return;
@@ -2785,7 +2785,7 @@ namespace Antlr3.Tool
{
ErrorManager.GrammarError( ErrorManager.MSG_IMPORT_NAME_CLASH,
this,
-                                              grammarNameAST.token,
+                                              grammarNameAST.Token,
this,
delegateGrammar );
return;
@@ -2846,7 +2846,7 @@ namespace Antlr3.Tool
{
ErrorManager.GrammarWarning( ErrorManager.MSG_TOKEN_VOCAB_IN_DELEGATE,
this,
-                                            tokenVocabOptionAST.token,
+                                            tokenVocabOptionAST.Token,
name );
return composite.maxTokenType;
}
diff --git a/Antlr3/Tool/GrammarSanity.cs b/Antlr3/Tool/GrammarSanity.cs
index d10fbd7..da4b484 100644
--- a/Antlr3/Tool/GrammarSanity.cs
+++ b/Antlr3/Tool/GrammarSanity.cs
@@ -302,7 +302,7 @@ namespace Antlr3.Tool
{
ErrorManager.GrammarWarning( ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
grammar,
-                                                next.token,
+                                                next.Token,
outerAltNum );
}
return;
@@ -328,7 +328,7 @@ namespace Antlr3.Tool
}
ErrorManager.GrammarWarning( ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
grammar,
-                                        elementAST.token,
+                                        elementAST.Token,
outerAltNum );
}

diff --git a/Antlr3/Tool/NameSpaceChecker.cs b/Antlr3/Tool/NameSpaceChecker.cs
index 1c78c6a..0ab369e 100644
--- a/Antlr3/Tool/NameSpaceChecker.cs
+++ b/Antlr3/Tool/NameSpaceChecker.cs
@@ -145,7 +145,7 @@ namespace Antlr3.Tool
// for each rule ref, ask if there is a rule definition
foreach ( GrammarAST refAST in grammar.ruleRefs )
{
-                IToken tok = refAST.token;
+                IToken tok = refAST.Token;
string ruleName = tok.Text;
Rule localRule = grammar.GetLocallyDefinedRule( ruleName );
Rule rule = grammar.GetRule( ruleName );
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
index f537eb9..a3678f1 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
@@ -72,7 +72,7 @@ public ITreeAdaptor TreeAdaptor
>>

@returnScope.ruleReturnMembers() ::= <<
-public <ASTLabelType> tree;
+internal <ASTLabelType> tree;
public override object Tree { get { return tree; } }
>>

diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index c0f5014..04092a4 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -225,7 +225,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
public partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
{
<if(grammar.grammarIsRoot)>
-	public static readonly string[] tokenNames = new string[] {
+	internal static readonly string[] tokenNames = new string[] {
"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
};<\n>
<endif>
@@ -293,7 +293,7 @@ public <grammar.recognizerName>( <inputStreamType> input, RecognizerSharedState

<if(bitsets)>
#region Follow sets
-	public static class Follow
+	static class Follow
{
<bitsets:bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>},
words64=it.bits)>
@@ -1409,14 +1409,14 @@ tokenLabelPropertyRef_index(scope,attr) ::= "(<scope>!=null?<scope>.TokenIndex:0
tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?Integer.valueOf(<scope>.Text):0)"

-ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.start):null)"
-ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.stop):null)"
-ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.tree):null)"
+ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):null)"
+ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):null)"
+ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):null)"
ruleLabelPropertyRef_text(scope,attr) ::= <<
<if(TREE_PARSER)>
(<scope>!=null?(input.TokenStream.ToString(
-  input.TreeAdaptor.GetTokenStartIndex(<scope>.start),
-  input.TreeAdaptor.GetTokenStopIndex(<scope>.start))):null)
+  input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
+  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):null)
<else>
(<scope>!=null?input.ToString(<scope>.start,<scope>.stop):null)
<endif>
@@ -1449,16 +1449,16 @@ lexerRuleLabelPropertyRef_int(scope,attr) ::=
"(<scope>!=null?Integer.valueOf(<scope>.Text):0)"

// Somebody may ref $template or $tree or $stop within a rule:
-rulePropertyRef_start(scope,attr) ::= "((<labelType>)retval.start)"
-rulePropertyRef_stop(scope,attr) ::= "((<labelType>)retval.stop)"
-rulePropertyRef_tree(scope,attr) ::= "((<ASTLabelType>)retval.tree)"
+rulePropertyRef_start(scope,attr) ::= "((<labelType>)retval.Start)"
+rulePropertyRef_stop(scope,attr) ::= "((<labelType>)retval.Stop)"
+rulePropertyRef_tree(scope,attr) ::= "((<ASTLabelType>)retval.Tree)"
rulePropertyRef_text(scope,attr) ::= <<
<if(TREE_PARSER)>
input.TokenStream.ToString(
-  input.TreeAdaptor.GetTokenStartIndex(retval.start),
-  input.TreeAdaptor.GetTokenStopIndex(retval.start))
+  input.TreeAdaptor.GetTokenStartIndex(retval.Start),
+  input.TreeAdaptor.GetTokenStopIndex(retval.Start))
<else>
-input.ToString(retval.start,input.LT(-1))
+input.ToString(retval.Start,input.LT(-1))
<endif>
>>
rulePropertyRef_st(scope,attr) ::= "retval.st"

