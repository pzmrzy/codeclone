commit 4427f2206c2fa81b9db4193f3d9dc0474c3db400
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Thu Jan 31 14:57:51 2013 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Thu Jan 31 14:57:51 2013 -0600

Updated bootstrap binaries

diff --git a/bin/Bootstrap/Antlr3.Runtime.Debug.dll b/bin/Bootstrap/Antlr3.Runtime.Debug.dll
index 2937899..fc8f7ba 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.Debug.dll and b/bin/Bootstrap/Antlr3.Runtime.Debug.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll b/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll
index 7ff67dc..92991b6 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll and b/bin/Bootstrap/Antlr3.Runtime.JavaExtensions.dll differ
diff --git a/bin/Bootstrap/Antlr3.Runtime.dll b/bin/Bootstrap/Antlr3.Runtime.dll
index 34bd478..c6affed 100644
Binary files a/bin/Bootstrap/Antlr3.Runtime.dll and b/bin/Bootstrap/Antlr3.Runtime.dll differ
diff --git a/bin/Bootstrap/Antlr3.exe b/bin/Bootstrap/Antlr3.exe
index 89e1f73..86950a9 100755
Binary files a/bin/Bootstrap/Antlr3.exe and b/bin/Bootstrap/Antlr3.exe differ
diff --git a/bin/Bootstrap/Antlr3.targets b/bin/Bootstrap/Antlr3.targets
index 3a440da..fb07c0d 100644
--- a/bin/Bootstrap/Antlr3.targets
+++ b/bin/Bootstrap/Antlr3.targets
@@ -28,12 +28,12 @@
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
<PropertyGroup>
<BuildSystem>MSBuild</BuildSystem>
-    <TaskVersion>3.3.0.7239</TaskVersion>
+    <TaskVersion>3.5.0.0</TaskVersion>
<TaskKeyToken>eb42632606e9261f</TaskKeyToken>
<AntlrBuildTaskAssemblyName Condition="'$(AntlrBuildTaskAssemblyName)'==''">AntlrBuildTask, Version=$(TaskVersion), Culture=neutral, PublicKeyToken=$(TaskKeyToken)</AntlrBuildTaskAssemblyName>
</PropertyGroup>

-  <!--<PropertyGroup>
+  <PropertyGroup>
<LoadTimeSensitiveTargets>
$(LoadTimeSensitiveTargets);
AntlrCompile;
@@ -42,13 +42,7 @@
$(LoadTimeSensitiveProperties);
AntlrCompileDependsOn;
</LoadTimeSensitiveProperties>
-
-
-    <PrepareResourcesDependsOn>
-      AntlrCompile;
-      $(PrepareResourcesDependsOn)
-    </PrepareResourcesDependsOn>
-  </PropertyGroup>-->
+  </PropertyGroup>

<PropertyGroup>
<AntlrBuildTaskLocation Condition="'$(AntlrBuildTaskPath)'==''">$(MSBuildBinPath)</AntlrBuildTaskLocation>
@@ -84,6 +78,14 @@
<AvailableItemName Include="AntlrAbstractGrammar" />
</ItemGroup>

+  <ItemDefinitionGroup>
+    <Antlr3>
+      <TargetLanguage/>
+      <DebugGrammar>false</DebugGrammar>
+      <ProfileGrammar>false</ProfileGrammar>
+    </Antlr3>
+  </ItemDefinitionGroup>
+
<Target Name="AntlrCompileReadGeneratedFileList">
<ReadLinesFromFile File="$(IntermediateOutputPath)$(AntlrGenCodeFileNames)">
<Output TaskParameter="Lines" ItemName="AntlrOutputCodeFilesList"/>
@@ -124,14 +126,16 @@
AntlrToolPath="$(AntlrToolLocation)"
BuildTaskPath="$(AntlrBuildTaskLocation)"
OutputPath="$(IntermediateOutputPath)"
-      Language="$(Language)"
+      TargetLanguage="%(Antlr3.TargetLanguage)"
SourceCodeFiles="@(Antlr3)"
ContinueOnError="$(_IntellisenseOnlyCompile)"
TokensFiles="@(AntlrTokens)"
-      AbstractGrammarFiles="@(AntlrAbstractGrammar)">
+      AbstractGrammarFiles="@(AntlrAbstractGrammar)"
+      LanguageSourceExtensions="$(DefaultLanguageSourceExtension)"
+      DebugGrammar="%(Antlr3.DebugGrammar)"
+      ProfileGrammar="%(Antlr3.ProfileGrammar)">

<Output ItemName="AntlrGeneratedCodeFiles" TaskParameter="GeneratedCodeFiles" />
-      <Output ItemName="Compile" TaskParameter="GeneratedCodeFiles" />
</AntlrClassGenerationTask>

<WriteLinesToFile
@@ -142,21 +146,22 @@
</Target>

<Target Name="AntlrCompileAddFilesGenerated"
-          DependsOnTargets="AntlrCompile"
+          AfterTargets="AntlrCompile"
Condition="'@(Antlr3)' != ''">

<ItemGroup>
-      <Compile Condition="'@(AntlrGeneratedCodeFiles)' == ''" Include="@(AntlrOutputCodeFilesList)" />
+      <AntlrGeneratedCodeFiles Condition="'@(AntlrGeneratedCodeFiles)' == ''" Include="@(AntlrOutputCodeFilesList)" />
</ItemGroup>

<ItemGroup>
-      <_AntlrCodeGenFileWrites Condition="'@(AntlrGeneratedCodeFiles)' != ''" Include="@(AntlrGeneratedCodeFiles)" />
-      <_AntlrCodeGenFileWrites Condition="'@(AntlrGeneratedCodeFiles)' == ''" Include="@(AntlrOutputCodeFilesList)" />
+      <FileWrites Include="@(AntlrGeneratedCodeFiles);
+                           $(IntermediateOutputPath)$(AntlrGenCodeFileNames);" />
</ItemGroup>

<ItemGroup>
-      <FileWrites Include="@(_AntlrCodeGenFileWrites);
-                           $(IntermediateOutputPath)$(AntlrGenCodeFileNames);" />
+      <Compile Include="@(AntlrGeneratedCodeFiles)" />
+      <!-- The WinFX "GenerateTemporaryTargetAssembly" target requires generated code files be added here. -->
+      <_GeneratedCodeFiles Include="@(AntlrGeneratedCodeFiles)" />
</ItemGroup>

</Target>
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll
index ba49dbc..4b88787 100644
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll and b/bin/Bootstrap/Antlr4.StringTemplate.Visualizer.dll differ
diff --git a/bin/Bootstrap/Antlr4.StringTemplate.dll b/bin/Bootstrap/Antlr4.StringTemplate.dll
index e24622e..ad596e1 100644
Binary files a/bin/Bootstrap/Antlr4.StringTemplate.dll and b/bin/Bootstrap/Antlr4.StringTemplate.dll differ
diff --git a/bin/Bootstrap/AntlrBuildTask.dll b/bin/Bootstrap/AntlrBuildTask.dll
index 7be3707..07966e5 100644
Binary files a/bin/Bootstrap/AntlrBuildTask.dll and b/bin/Bootstrap/AntlrBuildTask.dll differ
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
index a898b69..a94ed7c 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/AST.stg
@@ -117,7 +117,7 @@ root_0 = (<ASTLabelType>)adaptor.Nil();
// T r a c k i n g  R u l e  E l e m e n t s

/** ID and track it for use in a rewrite rule */
-tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefTrack(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)> <! Track implies no auto AST construction!>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
>>
@@ -125,19 +125,19 @@ tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
*  to the tracking list stream_ID for use in the rewrite.
*/
-tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefTrack(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** ^(ID ...) track for rewrite */
-tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
>>

/** Match ^(label+=TOKEN ...) track for rewrite */
-tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefRuleRootTrack(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -321,7 +321,7 @@ DebugLocation(<e.line>, <e.pos>);<\n>
%>

/** Gen ID or ID[args] */
-rewriteTokenRef(token,elementIndex,terminalOptions,args) ::= <<
+rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
>>

@@ -344,15 +344,15 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(),
rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot

/** Gen ^(ID ...) or ^(ID[args] ...) */
-rewriteTokenRefRoot(token,elementIndex,terminalOptions,args) ::= <<
+rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
>>

-rewriteImaginaryTokenRef(args,token,terminalOptions,elementIndex) ::= <<
+rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
>>

-rewriteImaginaryTokenRefRoot(args,token,terminalOptions,elementIndex) ::= <<
+rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
>>

@@ -408,7 +408,7 @@ rewriteWildcardLabelRef(label) ::= <<
adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
>>

-createImaginaryNode(tokenType,terminalOptions,args) ::= <%
+createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
<! new MethodNode(IDLabel, args) !>
new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
@@ -417,7 +417,7 @@ new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
<endif>
%>

-createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
+createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
<else>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
index 0d2a441..e7b2904 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTDbg.stg
@@ -33,24 +33,24 @@
*/

parserMembers() ::= <<
-protected DebugTreeAdaptor adaptor;
+	protected DebugTreeAdaptor adaptor;

-public ITreeAdaptor TreeAdaptor
-{
-	get
-	{
-		return adaptor;
-	}
-	set
+	public ITreeAdaptor TreeAdaptor
{
+		get
+		{
+			return adaptor;
+		}
+		set
+		{
<if(grammar.grammarIsRoot)>
-		this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
+			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
<else>
-		this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+			this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
<endif><\n>
-		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
-	}
-}<\n>
+			<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+		}
+	}<\n>
>>

parserCtorBody() ::= <<
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
index 6413dfe..1585287 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTParser.stg
@@ -49,7 +49,7 @@ retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1
// TOKEN AST STUFF

/** ID and output=AST */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
<super.tokenRef(...)>
<if(backtracking)>if (state.backtracking == 0) {<endif>
<label>_tree = <createNodeFromToken(...)>;
@@ -61,7 +61,7 @@ adaptor.AddChild(root_0, <label>_tree);
tokenRefBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"

/** ID^ and output=AST */
-tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
<super.tokenRef(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = <createNodeFromToken(...)>;
@@ -70,19 +70,19 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
>>

/** ids+=ID! and output=AST */
-tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** label+=TOKEN when output=AST but not rewrite alt */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRef(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** Match label+=TOKEN^ when output=AST but not rewrite alt */
-tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefRuleRoot(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -100,20 +100,20 @@ tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
// rather than just added on code.  Investigate that refactoring when
// I have more time.

-matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+matchSet(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= <<
<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);}, ...)>
>>

-matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+matchRuleBlockSet(s,label,elementIndex,postmatchCode,treeLevel="0",terminalOptions={}) ::= <<
<matchSet(...)>
>>

-matchSetBang(s,label,elementIndex,terminalOptions,postmatchCode) ::= "<super.matchSet(...)>"
+matchSetBang(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= "<super.matchSet(...)>"

// note there is no matchSetTrack because -> rewrites force sets to be
// plain old blocks of alts: (A|B|...|C)

-matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+matchSetRuleRoot(s,label,elementIndex,debug,terminalOptions={}) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);
<endif>
@@ -157,7 +157,7 @@ ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<

// WILDCARD AST

-wildcard(token,label,elementIndex,terminalOptions) ::= <<
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
<super.wildcard(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
@@ -165,9 +165,9 @@ adaptor.AddChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
>>

-wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"
+wildcardBang(label,elementIndex) ::= "<super.wildcard(token=[],...)>"

-wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+wildcardRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
<super.wildcard(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
@@ -175,7 +175,7 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
>>

-createNodeFromToken(label,terminalOptions) ::= <%
+createNodeFromToken(label,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<else>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
index fc6df64..316282f 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/ASTTreeParser.stg
@@ -53,7 +53,7 @@ ruleDeclarations() ::= <<
/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
-noRewrite(rewriteBlockLevel, treeLevel) ::= <<
+noRewrite(rewriteBlockLevel=false, treeLevel=false) ::= <<
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(rewriteMode)>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
index c5e1fd8..8f15ef2 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/CSharp2.stg
@@ -344,7 +344,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
appear to be defined in this recognizer. !>
#region Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", "><endif>); \}}; separator="\n">
#endregion Delegated rules
<endif>

@@ -377,14 +377,14 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,

@genericParser.members() ::= <<
#if ANTLR_DEBUG
-	private static readonly bool[] decisionCanBacktrack =
-		new bool[]
-		{
-			false, // invalid decision
-			<grammar.decisions:{d | <d.dfa.hasSynPred>}; wrap="\n", separator=", ">
-		};
+private static readonly bool[] decisionCanBacktrack =
+	new bool[]
+	{
+		false, // invalid decision
+		<grammar.decisions:{d | <d.dfa.hasSynPred>}; wrap="\n", separator=", ">
+	};
#else
-	private static readonly bool[] decisionCanBacktrack = new bool[0];
+private static readonly bool[] decisionCanBacktrack = new bool[0];
#endif
<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
@@ -455,7 +455,7 @@ protected virtual void EnterRule_<ruleName>_fragment() {}
protected virtual void LeaveRule_<ruleName>_fragment() {}

// $ANTLR start <ruleName>
-public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
+<ruleModifier(grammar,ruleDescriptor)> void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
{
<ruleLabelDefs()>
EnterRule_<ruleName>_fragment();
@@ -631,7 +631,7 @@ ruleDeclarations() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>();
retval.Start = (<labelType>)input.LT(1);
-<else>
+<elseif(ruleDescriptor.returnScope)>
<ruleDescriptor.returnScope.attributes:{ a |
<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
}>
@@ -679,7 +679,7 @@ lexerRuleLabelDefs() ::= <<
ruleDescriptor.ruleListLabels]
:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
>
-<ruleDescriptor.charListLabels:{it|List\<int\> list_<it.label.text> = null;}; separator="\n"
+<ruleDescriptor.charListLabels:{it|List\<int> list_<it.label.text> = null;}; separator="\n"
>
>>

@@ -948,12 +948,12 @@ DebugLocation(<it.line>, <it.pos>);<\n>
%>

/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
>>

/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRef(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -980,7 +980,7 @@ MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,terminalOptions,elementIndex,postmatchCode="") ::= <<
+matchSet(s,label,elementIndex,postmatchCode="",terminalOptions={}) ::= <<
<if(label)>
<matchSetLabel()>
<endif>
@@ -1049,14 +1049,14 @@ Match(<string>); <checkRuleBacktrackFailure()><\n>
<endif>
%>

-wildcard(token,label,elementIndex,terminalOptions) ::= <<
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
MatchAny(input); <checkRuleBacktrackFailure()>
>>

-wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+wildcardAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<wildcard(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -1176,6 +1176,7 @@ if (!(<evalPredicate(...)>))
dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
+<if((!isTrue.(last(edges).labelExpr)) && (!last(edges).predicates))>
else
{
<if(eotPredictsAlt)>
@@ -1188,6 +1189,7 @@ else
throw nvae;
<endif>
}
+<endif>
>>

/** Same as a normal DFA state except that we don't examine lookahead
@@ -1450,7 +1452,7 @@ s = <targetStateNumber>;<\n>

andPredicates(left,right) ::= "(<left>&&<right>)"

-orPredicates(operands) ::= "(<first(operands)><rest(operands):{o | ||<o>}>)"
+orPredicates(operands) ::= "(<operands; separator=\"||\">)"

notPredicate(pred) ::= "!(<evalPredicate(...)>)"

@@ -1481,6 +1483,7 @@ setTest(ranges) ::= <<
// A T T R I B U T E S

attributeScope(scope) ::= <<
+<if(scope)>
<if(scope.attributes)>
protected sealed partial class <scope.name>_scope
{
@@ -1502,7 +1505,8 @@ protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
<else>
protected virtual void <scope.name>_scopeAfter( <scope.name>_scope scope ) {}
<endif>
-protected readonly ListStack\<<scope.name>_scope\> <scope.name>_stack = new ListStack\<<scope.name>_scope\>();
+protected readonly ListStack\<<scope.name>_scope> <scope.name>_stack = new ListStack\<<scope.name>_scope>();
+<endif>
<endif>
>>

@@ -1532,9 +1536,7 @@ returnType(ruleDescriptor) ::= <%
*  values.
*/
ruleLabelType(referencedRule) ::= <%
-<if(referencedRule.returnScope.attributes&&referencedRule.hasMultipleReturnValues)>
-	<referencedRule.grammar.recognizerName>.<referencedRule:returnStructName()>
-<elseif(referencedRule.hasMultipleReturnValues)>
+<if(referencedRule.hasMultipleReturnValues)>
<ruleReturnBaseType()>
<elseif(referencedRule.hasSingleReturnValue)>
<referencedRule.singleValueReturnType>
@@ -1625,7 +1627,7 @@ isolatedDynamicScopeRef(scope) ::= "<scope>_stack"
/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
-(<scope>!=null?<scope>.<attr.name; format="id">:<initValue(attr.type)>)
+(<scope>!=null?((<returnType(referencedRule)>)<scope>).<attr.name; format="id">:<initValue(attr.type)>)
<else>
<scope>
<endif>
@@ -1656,7 +1658,7 @@ listLabelRef(label) ::= "list_<label>"

// not sure the next are the right approach

-tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:null)"
+tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:default(string))"
tokenLabelPropertyRef_type(scope,attr) ::= "(<scope>!=null?<scope>.Type:0)"
tokenLabelPropertyRef_line(scope,attr) ::= "(<scope>!=null?<scope>.Line:0)"
tokenLabelPropertyRef_pos(scope,attr) ::= "(<scope>!=null?<scope>.CharPositionInLine:0)"
@@ -1672,9 +1674,9 @@ ruleLabelPropertyRef_text(scope,attr) ::= <%
<if(TREE_PARSER)>
(<scope>!=null?(input.TokenStream.ToString(
input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
-  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):null)
+  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):default(string))
<else>
-(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):null)
+(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):default(string))
<endif>
%>

@@ -1699,7 +1701,7 @@ lexerRuleLabelPropertyRef_index(scope,attr) ::=
"(<scope>!=null?<scope>.TokenIndex:0)"

lexerRuleLabelPropertyRef_text(scope,attr) ::=
-    "(<scope>!=null?<scope>.Text:null)"
+    "(<scope>!=null?<scope>.Text:default(string))"

lexerRuleLabelPropertyRef_int(scope,attr) ::=
"(<scope>!=null?int.Parse(<scope>.Text):0)"
@@ -1763,3 +1765,8 @@ codeFileExtension() ::= ".cs"

true_value() ::= "true"
false_value() ::= "false"
+
+isTrue ::= [
+	"true" : true,
+	default : false
+]
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
index 16f6de2..b537ff1 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp2/Dbg.stg
@@ -49,21 +49,21 @@ public static readonly string[] ruleNames =
};<\n>
<endif>
<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
-	int ruleLevel = 0;
-	public virtual int RuleLevel { get { return ruleLevel; } }
-	public virtual void IncRuleLevel() { ruleLevel++; }
-	public virtual void DecRuleLevel() { ruleLevel--; }
+int ruleLevel = 0;
+public virtual int RuleLevel { get { return ruleLevel; } }
+public virtual void IncRuleLevel() { ruleLevel++; }
+public virtual void DecRuleLevel() { ruleLevel--; }
<if(profile)>
-	<ctorForProfilingRootGrammar()>
+<ctorForProfilingRootGrammar()>
<else>
-	<ctorForRootGrammar()>
+<ctorForRootGrammar()>
<endif>
<ctorForPredefinedListener()>
<else><! imported grammar !>
-	public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
-	public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
-	public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
-	<ctorForDelegateGrammar()>
+public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
+public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
+public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
+<ctorForDelegateGrammar()>
<endif>
<if(profile)>
public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
index 5eba4ed..d1d765a 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/AST.stg
@@ -115,7 +115,7 @@ root_0 = (<ASTLabelType>)adaptor.Nil();
// T r a c k i n g  R u l e  E l e m e n t s

/** ID and track it for use in a rewrite rule */
-tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefTrack(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)> <! Track implies no auto AST construction!>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
>>
@@ -123,19 +123,19 @@ tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
*  to the tracking list stream_ID for use in the rewrite.
*/
-tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefTrack(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** ^(ID ...) track for rewrite */
-tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
>>

/** Match ^(label+=TOKEN ...) track for rewrite */
-tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefRuleRootTrack(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -210,12 +210,12 @@ if (<prevRuleRootRef()>.Tree != null)

rewriteCodeLabels() ::= <<
<referencedTokenLabels
-    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
-    separator="\n"
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
+	separator="\n"
>
<referencedTokenListLabels
-    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
-    separator="\n"
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
+	separator="\n"
>
<referencedWildcardLabels
:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
@@ -226,12 +226,12 @@ rewriteCodeLabels() ::= <<
separator="\n"
>
<referencedRuleLabels
-    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
-    separator="\n"
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
+	separator="\n"
>
<referencedRuleListLabels
-    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
-    separator="\n"
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
+	separator="\n"
>
>>

@@ -319,7 +319,7 @@ DebugLocation(<e.line>, <e.pos>);<\n>
%>

/** Gen ID or ID[args] */
-rewriteTokenRef(token,elementIndex,terminalOptions,args) ::= <<
+rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
>>

@@ -342,15 +342,15 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(),
rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot

/** Gen ^(ID ...) or ^(ID[args] ...) */
-rewriteTokenRefRoot(token,elementIndex,terminalOptions,args) ::= <<
+rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
>>

-rewriteImaginaryTokenRef(args,token,terminalOptions,elementIndex) ::= <<
+rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
>>

-rewriteImaginaryTokenRefRoot(args,token,terminalOptions,elementIndex) ::= <<
+rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
>>

@@ -406,7 +406,7 @@ rewriteWildcardLabelRef(label) ::= <<
adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
>>

-createImaginaryNode(tokenType,terminalOptions,args) ::= <%
+createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
<! new MethodNode(IDLabel, args) !>
new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
@@ -415,7 +415,7 @@ new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
<endif>
%>

-createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
+createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
<else>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
index 35d1629..b4b245a 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTDbg.stg
@@ -35,26 +35,26 @@
*/

parserMembers() ::= <<
-// Implement this function in your helper file to use a custom tree adaptor
-partial void InitializeTreeAdaptor();
-protected DebugTreeAdaptor adaptor;
+	// Implement this function in your helper file to use a custom tree adaptor
+	partial void InitializeTreeAdaptor();
+	protected DebugTreeAdaptor adaptor;

-public ITreeAdaptor TreeAdaptor
-{
-	get
-	{
-		return adaptor;
-	}
-	set
+	public ITreeAdaptor TreeAdaptor
{
+		get
+		{
+			return adaptor;
+		}
+		set
+		{
<if(grammar.grammarIsRoot)>
-		this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
+			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
<else>
-		this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+			this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
<endif><\n>
-		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
-	}
-}<\n>
+			<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+		}
+	}<\n>
>>

parserCtorBody() ::= <<
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
index 8b507c7..b97d44b 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTParser.stg
@@ -50,7 +50,7 @@ retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1
// TOKEN AST STUFF

/** ID and output=AST */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <%
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <%
<super.tokenRef(...)>
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)><\n>if (state.backtracking == 0) {<endif>
@@ -61,10 +61,10 @@ tokenRef(token,label,elementIndex,terminalOptions) ::= <%
%>

/** ID! and output=AST (same as plain tokenRef) */
-tokenRefBang(token,label,elementIndex,terminalOptions) ::= "<super.tokenRef(...)>"
+tokenRefBang(token,label,elementIndex,terminalOptions={}) ::= "<super.tokenRef(...)>"

/** ID^ and output=AST */
-tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <%
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <%
<super.tokenRef(...)>
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)><\n>if (<actions.(actionScope).synpredgate>) {<endif>
@@ -75,19 +75,19 @@ tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <%
%>

/** ids+=ID! and output=AST */
-tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** label+=TOKEN when output=AST but not rewrite alt */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRef(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** Match label+=TOKEN^ when output=AST but not rewrite alt */
-tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefRuleRoot(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -105,20 +105,20 @@ tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
// rather than just added on code.  Investigate that refactoring when
// I have more time.

-matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+matchSet(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= <<
<super.matchSet(postmatchCode={<if(!ruleDescriptor.isSynPred)><if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);<endif>}, ...)>
>>

-matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+matchRuleBlockSet(s,label,elementIndex,postmatchCode,treeLevel="0",terminalOptions={}) ::= <<
<matchSet(...)>
>>

-matchSetBang(s,label,elementIndex,terminalOptions,postmatchCode) ::= "<super.matchSet(...)>"
+matchSetBang(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= "<super.matchSet(...)>"

// note there is no matchSetTrack because -> rewrites force sets to be
// plain old blocks of alts: (A|B|...|C)

-matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+matchSetRuleRoot(s,label,elementIndex,debug,terminalOptions={}) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);
<endif>
@@ -164,7 +164,7 @@ ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<

// WILDCARD AST

-wildcard(token,label,elementIndex,terminalOptions) ::= <<
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
<super.wildcard(...)>
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
@@ -174,9 +174,9 @@ adaptor.AddChild(root_0, <label>_tree);
<endif>
>>

-wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"
+wildcardBang(label,elementIndex) ::= "<super.wildcard(token=[],...)>"

-wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+wildcardRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
<super.wildcard(...)>
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
@@ -186,7 +186,7 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
<endif>
>>

-createNodeFromToken(label,terminalOptions) ::= <%
+createNodeFromToken(label,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<else>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
index 676ba00..c5529b2 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/ASTTreeParser.stg
@@ -54,13 +54,13 @@ ruleDeclarations() ::= <<
/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
-noRewrite(rewriteBlockLevel, treeLevel) ::= <<
+noRewrite(rewriteBlockLevel=false, treeLevel=false) ::= <<
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(rewriteMode)>
retval.Tree = (<ASTLabelType>)_first_0;
if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
-    retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
+	retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
<endif>
<if(backtracking)>}<endif>
<endif>
@@ -91,9 +91,9 @@ if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.
<actionsAfterRoot:element()>
<if(nullableChildList)>
if (input.LA(1) == TokenTypes.Down) {
-    Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-    <children:element()>
-    Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+	<children:element()>
+	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
}
<else>
Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
index bf7ca36..c9229e1 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/CSharp3.stg
@@ -98,7 +98,7 @@ lexerInputStreamType() ::= <<
>>

lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
-      superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>},
+	  superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>},
rewriteElementType={}, ASTLabelType={}) ::= <<
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
[System.CLSCompliant(false)]
@@ -108,13 +108,13 @@ lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="Com
<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<actions.lexer.members>

-    // delegates
-    <grammar.delegates:
-         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    // delegators
-    <grammar.delegators:
-         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    <last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+	// delegates
+	<grammar.delegates:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	// delegators
+	<grammar.delegators:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>

<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
{
@@ -193,7 +193,7 @@ lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="Com
<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif>);}; separator="\n">
}

-	<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
+	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
#endregion

}
@@ -336,7 +336,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
appear to be defined in this recognizer. !>
#region Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)<!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", "><endif>); \}}; separator="\n">
#endregion Delegated rules
<endif>

@@ -436,7 +436,7 @@ partial void EnterRule_<ruleName>_fragment();
partial void LeaveRule_<ruleName>_fragment();

// $ANTLR start <ruleName>
-public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
{
<ruleLabelDefs(...)>
EnterRule_<ruleName>_fragment();
@@ -566,7 +566,7 @@ partial void LeaveRule_<ruleName>();
{
ReportError(re);
Recover(input,re);
-	<@setErrorReturnValue()>
+		<@setErrorReturnValue()>
}
<endif>
<endif>
@@ -609,7 +609,7 @@ ruleDeclarations() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>(<if(ruleDescriptor.returnScope.attributes)>this<endif>);
retval.Start = (<labelType>)input.LT(1);
-<else>
+<elseif(ruleDescriptor.returnScope)>
<ruleDescriptor.returnScope.attributes:{ a |
<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
}>
@@ -631,13 +631,13 @@ ruleScopeCleanUp() ::= <<

ruleLabelDefs(ruleDescriptor, labelType, ASTLabelType, rewriteElementType) ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+	:{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
>
<ruleDescriptor.tokenListLabels
-    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+	:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
>
<[ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
+	:{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
>
<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
<ruleDescriptor.ruleListLabels:ruleLabelDef(); separator="\n">
@@ -647,7 +647,7 @@ lexerRuleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,
ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleLabels]
-    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+	:{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
>
<[ruleDescriptor.charListLabels,
ruleDescriptor.charLabels]
@@ -655,9 +655,9 @@ lexerRuleLabelDefs() ::= <<
>
<[ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleListLabels]
-    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+	:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
>
-<ruleDescriptor.charListLabels:{it|List\<int\> list_<it.label.text> = null;}; separator="\n"
+<ruleDescriptor.charListLabels:{it|List\<int> list_<it.label.text> = null;}; separator="\n"
>
>>

@@ -924,12 +924,12 @@ DebugLocation(<it.line>, <it.pos>);<\n>
%>

/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
>>

/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRef(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -960,7 +960,7 @@ MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,terminalOptions,elementIndex,postmatchCode="") ::= <<
+matchSet(s,label,elementIndex,postmatchCode="",terminalOptions={}) ::= <<
<if(label)>
<matchSetLabel()>
<endif>
@@ -1029,14 +1029,14 @@ Match(<string>); <checkRuleBacktrackFailure()><\n>
<endif>
%>

-wildcard(token,label,elementIndex,terminalOptions) ::= <<
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
MatchAny(input); <checkRuleBacktrackFailure()>
>>

-wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+wildcardAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<wildcard(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -1429,7 +1429,7 @@ s = <targetStateNumber>;<\n>

andPredicates(left,right) ::= "(<left>&&<right>)"

-orPredicates(operands) ::= "(<first(operands)><rest(operands):{o | ||<o>}>)"
+orPredicates(operands) ::= "(<operands; separator=\"||\">)"

notPredicate(pred) ::= "!(<evalPredicate(...)>)"

@@ -1460,6 +1460,7 @@ setTest(ranges) ::= <<
// A T T R I B U T E S

attributeScope(scope) ::= <<
+<if(scope)>
<if(scope.attributes)>
protected sealed partial class <scope.name>_scope
{
@@ -1484,7 +1485,8 @@ protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
<else>
partial void <scope.name>_scopeAfter( <scope.name>_scope scope );
<endif>
-protected readonly ListStack\<<scope.name>_scope\> <scope.name>_stack = new ListStack\<<scope.name>_scope\>();
+protected readonly ListStack\<<scope.name>_scope> <scope.name>_stack = new ListStack\<<scope.name>_scope>();
+<endif>
<endif>
>>

@@ -1514,9 +1516,7 @@ returnType(ruleDescriptor) ::= <%
*  values.
*/
ruleLabelType(referencedRule) ::= <%
-<if(referencedRule.returnScope.attributes&&referencedRule.hasMultipleReturnValues)>
-	<referencedRule.grammar.recognizerName>.<referencedRule:returnStructName()>
-<elseif(referencedRule.hasMultipleReturnValues)>
+<if(referencedRule.hasMultipleReturnValues)>
<ruleReturnBaseType()>
<elseif(referencedRule.hasSingleReturnValue)>
<referencedRule.singleValueReturnType>
@@ -1609,7 +1609,7 @@ isolatedDynamicScopeRef(scope) ::= "<scope>_stack"
/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
-(<scope>!=null?<scope>.<attr.name; format="id">:<initValue(attr.type)>)
+(<scope>!=null?((<returnType(referencedRule)>)<scope>).<attr.name; format="id">:<initValue(attr.type)>)
<else>
<scope>
<endif>
@@ -1640,7 +1640,7 @@ listLabelRef(label) ::= "list_<label>"

// not sure the next are the right approach

-tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:null)"
+tokenLabelPropertyRef_text(scope,attr) ::= "(<scope>!=null?<scope>.Text:default(string))"
tokenLabelPropertyRef_type(scope,attr) ::= "(<scope>!=null?<scope>.Type:0)"
tokenLabelPropertyRef_line(scope,attr) ::= "(<scope>!=null?<scope>.Line:0)"
tokenLabelPropertyRef_pos(scope,attr) ::= "(<scope>!=null?<scope>.CharPositionInLine:0)"
@@ -1656,9 +1656,9 @@ ruleLabelPropertyRef_text(scope,attr) ::= <%
<if(TREE_PARSER)>
(<scope>!=null?(input.TokenStream.ToString(
input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
-  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):null)
+  input.TreeAdaptor.GetTokenStopIndex(<scope>.Start))):default(string))
<else>
-(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):null)
+(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):default(string))
<endif>
%>

@@ -1683,7 +1683,7 @@ lexerRuleLabelPropertyRef_index(scope,attr) ::=
"(<scope>!=null?<scope>.TokenIndex:0)"

lexerRuleLabelPropertyRef_text(scope,attr) ::=
-    "(<scope>!=null?<scope>.Text:null)"
+    "(<scope>!=null?<scope>.Text:default(string))"

lexerRuleLabelPropertyRef_int(scope,attr) ::=
"(<scope>!=null?int.Parse(<scope>.Text):0)"
diff --git a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
index c16a848..c250e44 100644
--- a/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
+++ b/bin/Bootstrap/Codegen/Templates/CSharp3/Dbg.stg
@@ -48,21 +48,21 @@ public static readonly string[] ruleNames =
};<\n>
<endif>
<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
-	int ruleLevel = 0;
-	public virtual int RuleLevel { get { return ruleLevel; } }
-	public virtual void IncRuleLevel() { ruleLevel++; }
-	public virtual void DecRuleLevel() { ruleLevel--; }
+int ruleLevel = 0;
+public virtual int RuleLevel { get { return ruleLevel; } }
+public virtual void IncRuleLevel() { ruleLevel++; }
+public virtual void DecRuleLevel() { ruleLevel--; }
<if(profile)>
-	<ctorForProfilingRootGrammar()>
+<ctorForProfilingRootGrammar()>
<else>
-	<ctorForRootGrammar()>
+<ctorForRootGrammar()>
<endif>
<ctorForPredefinedListener()>
<else><! imported grammar !>
-	public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
-	public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
-	public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
-	<ctorForDelegateGrammar()>
+public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
+public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
+public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
+<ctorForDelegateGrammar()>
<endif>
<if(profile)>
public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll
index 4091db6..b0bb1e0 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp2.dll differ
diff --git a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll
index d661e00..2098c2d 100644
Binary files a/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll and b/bin/Bootstrap/Targets/Antlr3.Targets.CSharp3.dll differ
diff --git a/bin/Bootstrap/Tool/Templates/dot/dot.stg b/bin/Bootstrap/Tool/Templates/dot/dot.stg
index 96981dc..efcac2c 100644
--- a/bin/Bootstrap/Tool/Templates/dot/dot.stg
+++ b/bin/Bootstrap/Tool/Templates/dot/dot.stg
@@ -48,7 +48,7 @@ rankdir=LR;
}
>>

-decision_rank(states) ::= <<
+decision-rank(states) ::= <<
{rank=same; rankdir=TB; <states; separator="; ">}
>>

@@ -56,11 +56,11 @@ edge(src,target,label,arrowhead) ::= <<
<src> -> <target> [fontsize=11, fontname="Courier", arrowsize=.7, label = "<label>"<if(arrowhead)>, arrowhead = <arrowhead><endif>];
>>

-action_edge(src,target,label,arrowhead) ::= <<
+action-edge(src,target,label,arrowhead) ::= <<
<src> -> <target> [fontsize=11, fontname="Courier", arrowsize=.7, label = "<label>"<if(arrowhead)>, arrowhead = <arrowhead><endif>];
>>

-epsilon_edge(src,target,label,arrowhead) ::= <<
+epsilon-edge(src,target,label,arrowhead) ::= <<
<src> -> <target> [fontname="Times-Italic", label = "e"];
>>

diff --git a/bin/Bootstrap/Tool/Templates/messages/languages/en.stg b/bin/Bootstrap/Tool/Templates/messages/languages/en.stg
index ea27ddc..b5e42d5 100644
--- a/bin/Bootstrap/Tool/Templates/messages/languages/en.stg
+++ b/bin/Bootstrap/Tool/Templates/messages/languages/en.stg
@@ -83,6 +83,8 @@ CODE_GEN_TEMPLATES_INCOMPLETE(arg) ::=
"at least one code generation template missing for language <arg>"
CANNOT_CREATE_TARGET_GENERATOR(arg,exception,stackTrace) ::=
"cannot create target <arg> code generator: <exception>"
+STRING_TEMPLATE_ERROR(arg,exception,stackTrace) ::=
+	"template error: <arg>"
CANNOT_COMPUTE_SAMPLE_INPUT_SEQ() ::=
"cannot generate a sample input sequence from lookahead DFA"

@@ -228,6 +230,7 @@ WILDCARD_AS_ROOT(arg) ::= "Wildcard invalid as root; wildcard can itself be a tr
CONFLICTING_OPTION_IN_TREE_FILTER(arg,arg2) ::= "option <arg>=<arg2> conflicts with tree grammar filter mode"
ILLEGAL_OPTION_VALUE(arg, arg2) ::= "value '<arg2>' invalid for option <arg>"
ALL_OPS_NEED_SAME_ASSOC(arg) ::= "all operators of alt <alt> of left-recursive rule must have same associativity"
+RANGE_OP_ILLEGAL(arg) ::= "the .. range operator isn't allowed in parser rules"

// GRAMMAR WARNINGS


