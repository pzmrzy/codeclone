commit 4bb86c4e8a84b2392725276ce9b22f64dfe67499
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Wed Mar 7 08:50:23 2012 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Wed Mar 7 08:50:23 2012 -0600

Emit hard tabs instead of spaces - 24.4% reduction in generated code size (almost 300KB *savings* on ANTLR 4 parsers)

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
index 22095ac..dbbef3a 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
@@ -42,11 +42,11 @@ import org.antlr.runtime.tree.*;<\n>
parserMembers() ::= <<
protected TreeAdaptor adaptor = new CommonTreeAdaptor();<\n>
public void setTreeAdaptor(TreeAdaptor adaptor) {
-    this.adaptor = adaptor;
-    <grammar.directDelegates:{g|<g:delegateName()>.setTreeAdaptor(this.adaptor);}>
+	this.adaptor = adaptor;
+	<grammar.directDelegates:{g|<g:delegateName()>.setTreeAdaptor(this.adaptor);}>
}
public TreeAdaptor getTreeAdaptor() {
-    return adaptor;
+	return adaptor;
}
>>

@@ -69,14 +69,14 @@ ruleLabelDefs() ::= <<
<ruleDescriptor.tokenListLabels:{it | <ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
<if(ruleDescriptor.supportsLabelOptimization)>
<ruleDescriptor.allTokenRefsInRewrites
-    :{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
+	:{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
<ruleDescriptor.allRuleRefsInRewrites
-    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
+	:{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
<else>
<ruleDescriptor.allTokenRefsInAltsWithRewrites
-    :{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
+	:{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
<ruleDescriptor.allRuleRefsInAltsWithRewrites
-    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
+	:{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
<endif>
<endif>
>>
@@ -181,9 +181,9 @@ root_0 = (<ASTLabelType>)adaptor.nil();
<if(rewriteMode)>
<prevRuleRootRef()>.tree = (<ASTLabelType>)adaptor.rulePostProcessing(root_0);
input.replaceChildren(adaptor.getParent(retval.start),
-                      adaptor.getChildIndex(retval.start),
-                      adaptor.getChildIndex(_last),
-                      retval.tree);
+					  adaptor.getChildIndex(retval.start),
+					  adaptor.getChildIndex(_last),
+					  retval.tree);
<endif>
<endif>
<! if parser or tree-parser && rewrite!=true, we need to set result !>
@@ -201,28 +201,28 @@ input.replaceChildren(adaptor.getParent(retval.start),

rewriteCodeLabels() ::= <<
<referencedTokenLabels
-    :{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
-    separator="\n"
+	:{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
+	separator="\n"
>
<referencedTokenListLabels
-    :{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
-    separator="\n"
+	:{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
+	separator="\n"
>
<referencedWildcardLabels
-    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
-    separator="\n"
+	:{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
+	separator="\n"
>
<referencedWildcardListLabels
-    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
-    separator="\n"
+	:{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
+	separator="\n"
>
<referencedRuleLabels
-    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.getTree():null);};
-    separator="\n"
+	:{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.getTree():null);};
+	separator="\n"
>
<referencedRuleListLabels
-    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
-    separator="\n"
+	:{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
+	separator="\n"
>
>>

@@ -237,7 +237,7 @@ rewriteOptionalBlock(
<<
// <fileName>:<description>
if ( <referencedElementsDeep:{el | stream_<el>.hasNext()}; separator="||"> ) {
-    <alt>
+	<alt>
}
<referencedElementsDeep:{el | stream_<el>.reset();<\n>}>
>>
@@ -250,7 +250,7 @@ rewriteClosureBlock(
<<
// <fileName>:<description>
while ( <referencedElements:{el | stream_<el>.hasNext()}; separator="||"> ) {
-    <alt>
+	<alt>
}
<referencedElements:{el | stream_<el>.reset();<\n>}>
>>
@@ -262,10 +262,10 @@ rewritePositiveClosureBlock(
description) ::=
<<
if ( !(<referencedElements:{el | stream_<el>.hasNext()}; separator="||">) ) {
-    throw new RewriteEarlyExitException();
+	throw new RewriteEarlyExitException();
}
while ( <referencedElements:{el | stream_<el>.hasNext()}; separator="||"> ) {
-    <alt>
+	<alt>
}
<referencedElements:{el | stream_<el>.reset();<\n>}>
>>
@@ -274,11 +274,11 @@ rewriteAlt(a) ::= <<
// <a.description>
<if(a.pred)>
if (<a.pred>) {
-    <a.alt>
+	<a.alt>
}<\n>
<else>
{
-    <a.alt>
+	<a.alt>
}<\n>
<endif>
>>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTDbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTDbg.stg
index 886e198..502a2fe 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTDbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTDbg.stg
@@ -34,14 +34,14 @@ parserMembers() ::= <<
protected DebugTreeAdaptor adaptor;
public void setTreeAdaptor(TreeAdaptor adaptor) {
<if(grammar.grammarIsRoot)>
-    this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
+	this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
<else>
-    this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+	this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
<endif><\n>
-    <grammar.directDelegates:{g|<g:delegateName()>.setTreeAdaptor(this.adaptor);}>
+	<grammar.directDelegates:{g|<g:delegateName()>.setTreeAdaptor(this.adaptor);}>
}
public TreeAdaptor getTreeAdaptor() {
-    return adaptor;
+	return adaptor;
}<\n>
>>

@@ -51,14 +51,14 @@ parserCtorBody() ::= <<

createListenerAndHandshake() ::= <<
DebugEventSocketProxy proxy =
-    new DebugEventSocketProxy(this,port,<if(TREE_PARSER)>input.getTreeAdaptor()<else>adaptor<endif>);
+	new DebugEventSocketProxy(this,port,<if(TREE_PARSER)>input.getTreeAdaptor()<else>adaptor<endif>);
setDebugListener(proxy);
set<inputStreamType>(new Debug<inputStreamType>(input,proxy));
try {
-    proxy.handshake();
+	proxy.handshake();
}
catch (IOException ioe) {
-    reportError(ioe);
+	reportError(ioe);
}
>>

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
index c8db8d5..a0d22e6 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
@@ -56,7 +56,7 @@ noRewrite(rewriteBlockLevel, treeLevel) ::= <<
<if(rewriteMode)>
retval.tree = (<ASTLabelType>)_first_0;
if ( adaptor.getParent(retval.tree)!=null && adaptor.isNil( adaptor.getParent(retval.tree) ) )
-    retval.tree = (<ASTLabelType>)adaptor.getParent(retval.tree);
+	retval.tree = (<ASTLabelType>)adaptor.getParent(retval.tree);
<endif>
<if(backtracking)>}<endif>
<endif>
@@ -66,7 +66,7 @@ if ( adaptor.getParent(retval.tree)!=null && adaptor.isNil( adaptor.getParent(re
*  add tree construction actions.
*/
tree(root, actionsAfterRoot, children, nullableChildList,
-     enclosingTreeLevel, treeLevel) ::= <<
+	 enclosingTreeLevel, treeLevel) ::= <<
<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
{
@@ -87,9 +87,9 @@ if ( _first_<enclosingTreeLevel>==null ) _first_<enclosingTreeLevel> = <root.el.
<actionsAfterRoot:element()>
<if(nullableChildList)>
if ( input.LA(1)==Token.DOWN ) {
-    match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
-    <children:element()>
-    match(input, Token.UP, null); <checkRuleBacktrackFailure()>
+	match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
+	<children:element()>
+	match(input, Token.UP, null); <checkRuleBacktrackFailure()>
}
<else>
match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
index b512b2b..7bffc8d 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
@@ -37,47 +37,47 @@ import java.io.IOException;
@genericParser.members() ::= <<
<if(grammar.grammarIsRoot)>
public static final String[] ruleNames = new String[] {
-    "invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n    ", separator=", ">
+	"invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n    ", separator=", ">
};<\n>
<endif>
public static final boolean[] decisionCanBacktrack = new boolean[] {
-    false, // invalid decision
-    <grammar.decisions:{d | <d.dfa.hasSynPred; null="false">}; wrap="\n    ", separator=", ">
+	false, // invalid decision
+	<grammar.decisions:{d | <d.dfa.hasSynPred; null="false">}; wrap="\n    ", separator=", ">
};<\n>
<if(grammar.grammarIsRoot)> <! grammar imports other grammar(s) !>
-    public int ruleLevel = 0;
-    public int getRuleLevel() { return ruleLevel; }
-    public void incRuleLevel() { ruleLevel++; }
-    public void decRuleLevel() { ruleLevel--; }
+	public int ruleLevel = 0;
+	public int getRuleLevel() { return ruleLevel; }
+	public void incRuleLevel() { ruleLevel++; }
+	public void decRuleLevel() { ruleLevel--; }
<if(profile)>
-    <ctorForProfilingRootGrammar()>
+	<ctorForProfilingRootGrammar()>
<else>
-    <ctorForRootGrammar()>
+	<ctorForRootGrammar()>
<endif>
<ctorForPredefinedListener()>
<else> <! imported grammar !>
-    public int getRuleLevel() { return <grammar.delegators:{g| <g:delegateName()>}>.getRuleLevel(); }
-    public void incRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.incRuleLevel(); }
-    public void decRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.decRuleLevel(); }
-    <ctorForDelegateGrammar()>
+	public int getRuleLevel() { return <grammar.delegators:{g| <g:delegateName()>}>.getRuleLevel(); }
+	public void incRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.incRuleLevel(); }
+	public void decRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.decRuleLevel(); }
+	<ctorForDelegateGrammar()>
<endif>
<if(profile)>
public boolean alreadyParsedRule(IntStream input, int ruleIndex) {
int stopIndex = getRuleMemoization(ruleIndex, input.index());
-    ((Profiler)dbg).examineRuleMemoization(input, ruleIndex, stopIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-    return super.alreadyParsedRule(input, ruleIndex);
+	((Profiler)dbg).examineRuleMemoization(input, ruleIndex, stopIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	return super.alreadyParsedRule(input, ruleIndex);
}<\n>
public void memoize(IntStream input,
-                    int ruleIndex,
-                    int ruleStartIndex)
+					int ruleIndex,
+					int ruleStartIndex)
{
-    ((Profiler)dbg).memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
-    super.memoize(input, ruleIndex, ruleStartIndex);
+	((Profiler)dbg).memoize(input, ruleIndex, ruleStartIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
+	super.memoize(input, ruleIndex, ruleStartIndex);
}<\n>
<endif>
protected boolean evalPredicate(boolean result, String predicate) {
-    dbg.semanticPredicate(result, predicate);
-    return result;
+	dbg.semanticPredicate(result, predicate);
+	return result;
}<\n>
>>

@@ -85,30 +85,30 @@ ctorForRootGrammar() ::= <<
<! bug: can't use <@super.members()> cut-n-paste instead !>
<! Same except we add port number and profile stuff if root grammar !>
public <name>(<inputStreamType> input) {
-    this(input, DebugEventSocketProxy.DEFAULT_DEBUGGER_PORT, new RecognizerSharedState());
+	this(input, DebugEventSocketProxy.DEFAULT_DEBUGGER_PORT, new RecognizerSharedState());
}
public <name>(<inputStreamType> input, int port, RecognizerSharedState state) {
-    super(input, state);
-    <parserCtorBody()>
-    <createListenerAndHandshake()>
-    <grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
-    <@finally()>
+	super(input, state);
+	<parserCtorBody()>
+	<createListenerAndHandshake()>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	<@finally()>
}<\n>
>>

ctorForProfilingRootGrammar() ::= <<
<! bug: can't use <@super.members()> cut-n-paste instead !>
public <name>(<inputStreamType> input) {
-    this(input, new Profiler(null), new RecognizerSharedState());
+	this(input, new Profiler(null), new RecognizerSharedState());
}
public <name>(<inputStreamType> input, DebugEventListener dbg, RecognizerSharedState state) {
-    super(input, dbg, state);
-    Profiler p = (Profiler)dbg;
-    p.setParser(this);
-    <parserCtorBody()>
-    <grammar.directDelegates:
-     {g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
-    <@finally()>
+	super(input, dbg, state);
+	Profiler p = (Profiler)dbg;
+	p.setParser(this);
+	<parserCtorBody()>
+	<grammar.directDelegates:
+		{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	<@finally()>
}
<\n>
>>
@@ -116,40 +116,40 @@ public <name>(<inputStreamType> input, DebugEventListener dbg, RecognizerSharedS
/** Basically we don't want to set any dbg listeners are root will have it. */
ctorForDelegateGrammar() ::= <<
public <name>(<inputStreamType> input, DebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
-    super(input, dbg, state);
-    <parserCtorBody()>
-    <grammar.directDelegates:
-     {g|<g:delegateName()> = new <g.recognizerName>(input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	super(input, dbg, state);
+	<parserCtorBody()>
+	<grammar.directDelegates:
+		{g|<g:delegateName()> = new <g.recognizerName>(input, this, this.state<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
}<\n>
>>

ctorForPredefinedListener() ::= <<
public <name>(<inputStreamType> input, DebugEventListener dbg) {
-    <@superClassRef>super(input, dbg, new RecognizerSharedState());<@end>
+	<@superClassRef>super(input, dbg, new RecognizerSharedState());<@end>
<if(profile)>
-    Profiler p = (Profiler)dbg;
-    p.setParser(this);
+	Profiler p = (Profiler)dbg;
+	p.setParser(this);
<endif>
-    <parserCtorBody()>
-    <grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
-    <@finally()>
+	<parserCtorBody()>
+	<grammar.directDelegates:{g|<g:delegateName()> = new <g.recognizerName>(input, dbg, this.state, this<grammar.delegators:{g|, <g:delegateName()>}>);}; separator="\n">
+	<@finally()>
}<\n>
>>

createListenerAndHandshake() ::= <<
<if(TREE_PARSER)>
DebugEventSocketProxy proxy =
-    new DebugEventSocketProxy(this, port, input.getTreeAdaptor());<\n>
+	new DebugEventSocketProxy(this, port, input.getTreeAdaptor());<\n>
<else>
DebugEventSocketProxy proxy =
-    new DebugEventSocketProxy(this, port, null);<\n>
+	new DebugEventSocketProxy(this, port, null);<\n>
<endif>
setDebugListener(proxy);
try {
-    proxy.handshake();
+	proxy.handshake();
}
catch (IOException ioe) {
-    reportError(ioe);
+	reportError(ioe);
}
>>

@@ -166,9 +166,9 @@ dbg.location(<ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine
dbg.location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
}
finally {
-    dbg.exitRule(getGrammarFileName(), "<ruleName>");
-    decRuleLevel();
-    if ( getRuleLevel()==0 ) {dbg.terminate();}
+	dbg.exitRule(getGrammarFileName(), "<ruleName>");
+	decRuleLevel();
+	if ( getRuleLevel()==0 ) {dbg.terminate();}
}<\n>
>>

@@ -179,16 +179,16 @@ finally {
// Common debug event triggers used by region overrides below

enterSubRule() ::=
-    "try { dbg.enterSubRule(<decisionNumber>);<\n>"
+	"try { dbg.enterSubRule(<decisionNumber>);<\n>"

exitSubRule() ::=
-    "} finally {dbg.exitSubRule(<decisionNumber>);}<\n>"
+	"} finally {dbg.exitSubRule(<decisionNumber>);}<\n>"

enterDecision() ::=
-    "try { dbg.enterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);<\n>"
+	"try { dbg.enterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>]);<\n>"

exitDecision() ::=
-    "} finally {dbg.exitDecision(<decisionNumber>);}<\n>"
+	"} finally {dbg.exitDecision(<decisionNumber>);}<\n>"

enterAlt(n) ::= "dbg.enterAlt(<n>);<\n>"

@@ -217,7 +217,7 @@ enterAlt(n) ::= "dbg.enterAlt(<n>);<\n>"
@positiveClosureBlock.postdecision() ::= "<exitDecision()>"

@positiveClosureBlock.earlyExitException() ::=
-    "dbg.recognitionException(eee);<\n>"
+	"dbg.recognitionException(eee);<\n>"

@closureBlock.preloop() ::= "<enterSubRule()>"

@@ -230,10 +230,10 @@ enterAlt(n) ::= "dbg.enterAlt(<n>);<\n>"
@altSwitchCase.prealt() ::= "<enterAlt(altNum)>" // altNum is arg of altSwitchCase

@element.prematch() ::=
-    "dbg.location(<e.line>,<e.pos>);" // e is arg of element
+	"dbg.location(<e.line>,<e.pos>);" // e is arg of element

@matchSet.mismatchedSetException() ::=
-    "dbg.recognitionException(mse);"
+	"dbg.recognitionException(mse);"

@dfaState.noViableAltException() ::= "dbg.recognitionException(nvae);"

@@ -241,18 +241,18 @@ enterAlt(n) ::= "dbg.enterAlt(<n>);<\n>"

dfaDecision(decisionNumber,description) ::= <<
try {
-    isCyclicDecision = true;
-    <super.dfaDecision(...)>
+	isCyclicDecision = true;
+	<super.dfaDecision(...)>
}
catch (NoViableAltException nvae) {
-    dbg.recognitionException(nvae);
-    throw nvae;
+	dbg.recognitionException(nvae);
+	throw nvae;
}
>>

@cyclicDFA.errorMethod() ::= <<
public void error(NoViableAltException nvae) {
-    dbg.recognitionException(nvae);
+	dbg.recognitionException(nvae);
}
>>

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
index 165a6a0..c121c36 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
@@ -84,49 +84,49 @@ import java.util.HashMap;
lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
superClass="Lexer") ::= <<
public class <grammar.recognizerName> extends <@superClassName><superClass><@end> {
-    <tokens:{it | public static final int <it.name>=<it.type>;}; separator="\n">
-    <scopes:{it |<if(it.isDynamicGlobalScope)><globalAttributeScope(it)><endif>}>
-    <actions.lexer.members>
-
-    // delegates
-    <grammar.delegates:
-         {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    // delegators
-    <grammar.delegators:
-         {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    <last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
-    public <superClass>[] getDelegates() {
-        return new <superClass>[] {<grammar.delegates: {g|<g:delegateName()>}; separator = ", ">};
-    }
-
-    public <grammar.recognizerName>() {} <! needed by subclasses !>
-    public <grammar.recognizerName>(CharStream input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
-        this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>);
-    }
-    public <grammar.recognizerName>(CharStream input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
-        super(input,state);
+	<tokens:{it | public static final int <it.name>=<it.type>;}; separator="\n">
+	<scopes:{it |<if(it.isDynamicGlobalScope)><globalAttributeScope(it)><endif>}>
+	<actions.lexer.members>
+
+	// delegates
+	<grammar.delegates:
+		{g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	// delegators
+	<grammar.delegators:
+		{g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
+	public <superClass>[] getDelegates() {
+		return new <superClass>[] {<grammar.delegates: {g|<g:delegateName()>}; separator = ", ">};
+	}
+
+	public <grammar.recognizerName>() {} <! needed by subclasses !>
+	public <grammar.recognizerName>(CharStream input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
+		this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>);
+	}
+	public <grammar.recognizerName>(CharStream input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
+		super(input,state);
<if(memoize)>
<if(grammar.grammarIsRoot)>
-        state.ruleMemo = new HashMap[<numRules>+1];<\n> <! index from 1..n !>
+		state.ruleMemo = new HashMap[<numRules>+1];<\n> <! index from 1..n !>
<endif>
<endif>
-        <grammar.directDelegates:
-         {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-        <grammar.delegators:
-         {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
-        <last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-    }
-    public String getGrammarFileName() { return "<fileName>"; }
+		<grammar.directDelegates:
+			{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+		<grammar.delegators:
+			{g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+	}
+	public String getGrammarFileName() { return "<fileName>"; }

<if(filterMode)>
-    <filteringNextToken()>
+	<filteringNextToken()>
<endif>
-    <rules; separator="\n\n">
+	<rules; separator="\n\n">

-    <synpreds:{p | <lexerSynpred(p)>}>
+	<synpreds:{p | <lexerSynpred(p)>}>

-    <cyclicDFAs:{dfa | protected DFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this);}; separator="\n">
-    <cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
+	<cyclicDFAs:{dfa | protected DFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this);}; separator="\n">
+	<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>

}
>>
@@ -139,44 +139,44 @@ public class <grammar.recognizerName> extends <@superClassName><superClass><@end
*/
filteringNextToken() ::= <<
public Token nextToken() {
-    while (true) {
-        if ( input.LA(1)==CharStream.EOF ) {
-            Token eof = new CommonToken(input,Token.EOF,
-                                        Token.DEFAULT_CHANNEL,
-                                        input.index(),input.index());
-            eof.setLine(getLine());
-            eof.setCharPositionInLine(getCharPositionInLine());
-            return eof;
-        }
-        state.token = null;
+	while (true) {
+		if ( input.LA(1)==CharStream.EOF ) {
+			Token eof = new CommonToken(input,Token.EOF,
+										Token.DEFAULT_CHANNEL,
+										input.index(),input.index());
+			eof.setLine(getLine());
+			eof.setCharPositionInLine(getCharPositionInLine());
+			return eof;
+		}
+		state.token = null;
state.channel = Token.DEFAULT_CHANNEL;
-        state.tokenStartCharIndex = input.index();
-        state.tokenStartCharPositionInLine = input.getCharPositionInLine();
-        state.tokenStartLine = input.getLine();
+		state.tokenStartCharIndex = input.index();
+		state.tokenStartCharPositionInLine = input.getCharPositionInLine();
+		state.tokenStartLine = input.getLine();
state.text = null;
-        try {
-            int m = input.mark();
-            state.backtracking=1; <! means we won't throw slow exception !>
-            state.failed=false;
-            mTokens();
-            state.backtracking=0;
-            <! mTokens backtracks with synpred at backtracking==2
-               and we set the synpredgate to allow actions at level 1. !>
-            if ( state.failed ) {
-                input.rewind(m);
-                input.consume(); <! advance one char and try again !>
-            }
-            else {
-                emit();
-                return state.token;
-            }
-        }
-        catch (RecognitionException re) {
-            // shouldn't happen in backtracking mode, but...
-            reportError(re);
-            recover(re);
-        }
-    }
+		try {
+			int m = input.mark();
+			state.backtracking=1; <! means we won't throw slow exception !>
+			state.failed=false;
+			mTokens();
+			state.backtracking=0;
+			<! mTokens backtracks with synpred at backtracking==2
+				and we set the synpredgate to allow actions at level 1. !>
+			if ( state.failed ) {
+				input.rewind(m);
+				input.consume(); <! advance one char and try again !>
+			}
+			else {
+				emit();
+				return state.token;
+			}
+		}
+		catch (RecognitionException re) {
+			// shouldn't happen in backtracking mode, but...
+			reportError(re);
+			recover(re);
+		}
+	}
}

public void memoize(IntStream input,
@@ -203,60 +203,60 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
filterMode, ASTLabelType="Object") ::= <<
public class <grammar.recognizerName> extends <@superClassName><superClass><@end> {
<if(grammar.grammarIsRoot)>
-    public static final String[] tokenNames = new String[] {
-        "\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
-    };<\n>
+	public static final String[] tokenNames = new String[] {
+		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
+	};<\n>
<endif>
-    <tokens:{it |public static final int <it.name>=<it.type>;}; separator="\n">
-
-    // delegates
-    <grammar.delegates: {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    public <superClass>[] getDelegates() {
-        return new <superClass>[] {<grammar.delegates: {g|<g:delegateName()>}; separator = ", ">};
-    }
-
-    // delegators
-    <grammar.delegators:
-         {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    <last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
-
-    <scopes:{it |<if(it.isDynamicGlobalScope)><globalAttributeScope(it)><endif>}>
-
-    <@members>
-    <! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
-    public <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
-        this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>);
-    }
-    public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
-        super(input, state);
-        <parserCtorBody()>
-        <grammar.directDelegates:
-         {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-        <grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
-        <last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-    }
-    <@end>
-
-    public String[] getTokenNames() { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; }
-    public String getGrammarFileName() { return "<fileName>"; }
-
-    <members>
-
-    <rules; separator="\n\n">
+	<tokens:{it |public static final int <it.name>=<it.type>;}; separator="\n">
+
+	// delegates
+	<grammar.delegates: {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	public <superClass>[] getDelegates() {
+		return new <superClass>[] {<grammar.delegates: {g|<g:delegateName()>}; separator = ", ">};
+	}
+
+	// delegators
+	<grammar.delegators:
+		{g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
+
+	<scopes:{it |<if(it.isDynamicGlobalScope)><globalAttributeScope(it)><endif>}>
+
+	<@members>
+	<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
+	public <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
+		this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>);
+	}
+	public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>) {
+		super(input, state);
+		<parserCtorBody()>
+		<grammar.directDelegates:
+			{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+		<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
+		<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+	}
+	<@end>
+
+	public String[] getTokenNames() { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; }
+	public String getGrammarFileName() { return "<fileName>"; }
+
+	<members>
+
+	<rules; separator="\n\n">

<! generate rule/method definitions for imported rules so they
appear to be defined in this recognizer. !>
-    // Delegated rules
+	// Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-    public <returnType(ruleDescriptor)> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec; separator=", "> { <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">
+	public <returnType(ruleDescriptor)> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec; separator=", "> { <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">

-    <synpreds:{p | <synpred(p)>}>
+	<synpreds:{p | <synpred(p)>}>

-    <cyclicDFAs:{dfa | protected DFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this);}; separator="\n">
-    <cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
+	<cyclicDFAs:{dfa | protected DFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this);}; separator="\n">
+	<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>

-    <bitsets:{it | <bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
-                          words64=it.bits)>}>
+	<bitsets:{it | <bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
+							words64=it.bits)>}>
}
>>

@@ -267,7 +267,7 @@ this.state.ruleMemo = new HashMap[<length(grammar.allImportedRules)>+1];<\n> <!
<endif>
<endif>
<grammar.delegators:
- {g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
+	{g|this.<g:delegateName()> = <g:delegateName()>;}; separator="\n">
>>

parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
@@ -304,17 +304,17 @@ synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
// $ANTLR start <ruleName>
public final void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec:{x|<x>}; separator=", "> {
-    <ruleLabelDefs()>
+	<ruleLabelDefs()>
<if(trace)>
-    traceIn("<ruleName>_fragment", <ruleDescriptor.index>);
-    try {
-        <block>
-    }
-    finally {
-        traceOut("<ruleName>_fragment", <ruleDescriptor.index>);
-    }
+	traceIn("<ruleName>_fragment", <ruleDescriptor.index>);
+	try {
+		<block>
+	}
+	finally {
+		traceOut("<ruleName>_fragment", <ruleDescriptor.index>);
+	}
<else>
-    <block>
+	<block>
<endif>
}
// $ANTLR end <ruleName>
@@ -322,20 +322,20 @@ public final void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterSc

synpred(name) ::= <<
public final boolean <name>() {
-    state.backtracking++;
-    <@start()>
-    int start = input.mark();
-    try {
-        <name>_fragment(); // can never throw exception
-    } catch (RecognitionException re) {
-        System.err.println("impossible: "+re);
-    }
-    boolean success = !state.failed;
-    input.rewind(start);
-    <@stop()>
-    state.backtracking--;
-    state.failed=false;
-    return success;
+	state.backtracking++;
+	<@start()>
+	int start = input.mark();
+	try {
+		<name>_fragment(); // can never throw exception
+	} catch (RecognitionException re) {
+		System.err.println("impossible: "+re);
+	}
+	boolean success = !state.failed;
+	input.rewind(start);
+	<@stop()>
+	state.backtracking--;
+	state.failed=false;
+	return success;
}<\n>
>>

@@ -369,49 +369,49 @@ rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memo
// $ANTLR start "<ruleName>"
// <fileName>:<description>
public final <returnType(ruleDescriptor)> <ruleName>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec:{x|<x>}; separator=", "> {
-    <if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
-    <ruleScopeSetUp()>
-    <ruleDeclarations()>
-    <ruleLabelDefs()>
-    <ruleDescriptor.actions.init>
-    <@preamble()>
-    try {
-        <ruleMemoization(name=ruleName)>
-        <block>
-        <ruleCleanUp()>
-        <(ruleDescriptor.actions.after):execAction()>
-    }
+	<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
+	<ruleScopeSetUp()>
+	<ruleDeclarations()>
+	<ruleLabelDefs()>
+	<ruleDescriptor.actions.init>
+	<@preamble()>
+	try {
+		<ruleMemoization(name=ruleName)>
+		<block>
+		<ruleCleanUp()>
+		<(ruleDescriptor.actions.after):execAction()>
+	}
<if(exceptions)>
-    <exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
+	<exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
<else>
<if(!emptyRule)>
<if(actions.(actionScope).rulecatch)>
-    <actions.(actionScope).rulecatch>
+	<actions.(actionScope).rulecatch>
<else>
-    catch (RecognitionException re) {
-        reportError(re);
-        recover(input,re);
+	catch (RecognitionException re) {
+		reportError(re);
+		recover(input,re);
<@setErrorReturnValue()>
-    }<\n>
+	}<\n>
<endif>
<endif>
<endif>
-    finally {
-    	// do for sure before leaving
-        <if(trace)>traceOut("<ruleName>", <ruleDescriptor.index>);<endif>
-        <memoize()>
-        <ruleScopeCleanUp()>
-        <finally>
-    }
-    <@postamble()>
-    return <ruleReturnValue()>;
+	finally {
+		// do for sure before leaving
+		<if(trace)>traceOut("<ruleName>", <ruleDescriptor.index>);<endif>
+		<memoize()>
+		<ruleScopeCleanUp()>
+		<finally>
+	}
+	<@postamble()>
+	return <ruleReturnValue()>;
}
// $ANTLR end "<ruleName>"
>>

catch(decl,action) ::= <<
catch (<e.decl>) {
-    <e.action>
+	<e.action>
}
>>

@@ -443,10 +443,10 @@ ruleScopeCleanUp() ::= <<
ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,
ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{it |<labelType> <it.label.text>=null;}; separator="\n"
+	:{it |<labelType> <it.label.text>=null;}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{it |List\<Object> list_<it.label.text>=null;}; separator="\n"
+	:{it |List\<Object> list_<it.label.text>=null;}; separator="\n"
>
<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
<ruleDescriptor.ruleListLabels:{ll|RuleReturnScope <ll.label.text> = null;}; separator="\n">
@@ -456,12 +456,12 @@ lexerRuleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,
ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleLabels]
-    :{it |<labelType> <it.label.text>=null;}; separator="\n"
+	:{it |<labelType> <it.label.text>=null;}; separator="\n"
>
<ruleDescriptor.charLabels:{it |int <it.label.text>;}; separator="\n">
<[ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleListLabels]
-    :{it |List\<Object> list_<it.label.text>=null;}; separator="\n"
+	:{it |List\<Object> list_<it.label.text>=null;}; separator="\n"
>
>>

@@ -499,34 +499,34 @@ if ( state.backtracking>0 ) { memoize(input, <ruleDescriptor.index>, <ruleDescri
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
// $ANTLR start "<ruleName>"
public final void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>) throws RecognitionException {
-    <if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
-    <ruleScopeSetUp()>
-    <ruleDeclarations()>
-    try {
+	<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
+	<ruleScopeSetUp()>
+	<ruleDeclarations()>
+	try {
<if(nakedBlock)>
-        <ruleMemoization(name=ruleName)>
-        <lexerRuleLabelDefs()>
-        <ruleDescriptor.actions.init>
-        <block><\n>
+		<ruleMemoization(name=ruleName)>
+		<lexerRuleLabelDefs()>
+		<ruleDescriptor.actions.init>
+		<block><\n>
<else>
-        int _type = <ruleName>;
-        int _channel = DEFAULT_TOKEN_CHANNEL;
-        <ruleMemoization(name=ruleName)>
-        <lexerRuleLabelDefs()>
-        <ruleDescriptor.actions.init>
-        <block>
-        <ruleCleanUp()>
-        state.type = _type;
-        state.channel = _channel;
-        <(ruleDescriptor.actions.after):execAction()>
+		int _type = <ruleName>;
+		int _channel = DEFAULT_TOKEN_CHANNEL;
+		<ruleMemoization(name=ruleName)>
+		<lexerRuleLabelDefs()>
+		<ruleDescriptor.actions.init>
+		<block>
+		<ruleCleanUp()>
+		state.type = _type;
+		state.channel = _channel;
+		<(ruleDescriptor.actions.after):execAction()>
<endif>
-    }
-    finally {
-    	// do for sure before leaving
-        <if(trace)>traceOut("<ruleName>", <ruleDescriptor.index>);<endif>
-        <ruleScopeCleanUp()>
-        <memoize()>
-    }
+	}
+	finally {
+		// do for sure before leaving
+		<if(trace)>traceOut("<ruleName>", <ruleDescriptor.index>);<endif>
+		<ruleScopeCleanUp()>
+		<memoize()>
+	}
}
// $ANTLR end "<ruleName>"
>>
@@ -536,7 +536,7 @@ public final void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>)
*/
tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
public void mTokens() throws RecognitionException {
-    <block><\n>
+	<block><\n>
}
>>

@@ -552,7 +552,7 @@ int alt<decisionNumber>=<maxAlt>;
<@postdecision()>
<@prebranch()>
switch (alt<decisionNumber>) {
-    <alts:{a | <altSwitchCase(i,a)>}>
+	<alts:{a | <altSwitchCase(i,a)>}>
}
<@postbranch()>
>>
@@ -566,7 +566,7 @@ int alt<decisionNumber>=<maxAlt>;
<decision>
<@postdecision()>
switch (alt<decisionNumber>) {
-    <alts:{a | <altSwitchCase(i,a)>}>
+	<alts:{a | <altSwitchCase(i,a)>}>
}
>>

@@ -595,21 +595,21 @@ int cnt<decisionNumber>=0;
<@preloop()>
loop<decisionNumber>:
do {
-    int alt<decisionNumber>=<maxAlt>;
-    <@predecision()>
-    <decision>
-    <@postdecision()>
-    switch (alt<decisionNumber>) {
+	int alt<decisionNumber>=<maxAlt>;
+	<@predecision()>
+	<decision>
+	<@postdecision()>
+	switch (alt<decisionNumber>) {
<alts:{a | <altSwitchCase(i,a)>}>
default :
-	    if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
-	    <ruleBacktrackFailure()>
-            EarlyExitException eee =
-                new EarlyExitException(<decisionNumber>, input);
-            <@earlyExitException()>
-            throw eee;
-    }
-    cnt<decisionNumber>++;
+		if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
+		<ruleBacktrackFailure()>
+			EarlyExitException eee =
+				new EarlyExitException(<decisionNumber>, input);
+			<@earlyExitException()>
+			throw eee;
+	}
+	cnt<decisionNumber>++;
} while (true);
<@postloop()>
>>
@@ -623,15 +623,15 @@ closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,m
<@preloop()>
loop<decisionNumber>:
do {
-    int alt<decisionNumber>=<maxAlt>;
-    <@predecision()>
-    <decision>
-    <@postdecision()>
-    switch (alt<decisionNumber>) {
+	int alt<decisionNumber>=<maxAlt>;
+	<@predecision()>
+	<decision>
+	<@postdecision()>
+	switch (alt<decisionNumber>) {
<alts:{a | <altSwitchCase(i,a)>}>
default :
-	    break loop<decisionNumber>;
-    }
+		break loop<decisionNumber>;
+	}
} while (true);
<@postloop()>
>>
@@ -651,9 +651,9 @@ optionalBlockSingleAlt ::= block
*/
altSwitchCase(altNum,alt) ::= <<
case <altNum> :
-    <@prealt()>
-    <alt>
-    break;<\n>
+	<@prealt()>
+	<alt>
+	break;<\n>
>>

/** An alternative is just a list of elements; at outermost level */
@@ -722,25 +722,25 @@ matchSet(s,label,elementIndex,terminalOptions,postmatchCode="") ::= <<
<endif>
<endif>
if ( <s> ) {
-    input.consume();
-    <postmatchCode>
+	input.consume();
+	<postmatchCode>
<if(!LEXER)>
-    state.errorRecovery=false;
+	state.errorRecovery=false;
<endif>
-    <if(backtracking)>state.failed=false;<endif>
+	<if(backtracking)>state.failed=false;<endif>
}
else {
-    <ruleBacktrackFailure()>
-    MismatchedSetException mse = new MismatchedSetException(null,input);
-    <@mismatchedSetException()>
+	<ruleBacktrackFailure()>
+	MismatchedSetException mse = new MismatchedSetException(null,input);
+	<@mismatchedSetException()>
<if(LEXER)>
-    recover(mse);
-    throw mse;
+	recover(mse);
+	throw mse;
<else>
-    throw mse;
-    <! use following code to make it recover inline; remove throw mse;
-    recoverFromMismatchedSet(input,mse,FOLLOW_set_in_<ruleName><elementIndex>);
-    !>
+	throw mse;
+	<! use following code to make it recover inline; remove throw mse;
+	recoverFromMismatchedSet(input,mse,FOLLOW_set_in_<ruleName><elementIndex>);
+	!>
<endif>
}<\n>
>>
@@ -866,9 +866,9 @@ tree(root, actionsAfterRoot, children, nullableChildList,
<actionsAfterRoot:element()>
<if(nullableChildList)>
if ( input.LA(1)==Token.DOWN ) {
-    match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
-    <children:element()>
-    match(input, Token.UP, null); <checkRuleBacktrackFailure()>
+	match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
+	<children:element()>
+	match(input, Token.UP, null); <checkRuleBacktrackFailure()>
}
<else>
match(input, Token.DOWN, null); <checkRuleBacktrackFailure()>
@@ -882,8 +882,8 @@ match(input, Token.UP, null); <checkRuleBacktrackFailure()>
*/
validateSemanticPredicate(pred,description) ::= <<
if ( !(<evalPredicate(pred,description)>) ) {
-    <ruleBacktrackFailure()>
-    throw new FailedPredicateException(input, "<ruleName>", "<description>");
+	<ruleBacktrackFailure()>
+	throw new FailedPredicateException(input, "<ruleName>", "<description>");
}
>>

@@ -894,9 +894,9 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
else {
<if(eotPredictsAlt)>
-    alt<decisionNumber>=<eotPredictsAlt>;
+	alt<decisionNumber>=<eotPredictsAlt>;
<else>
-    <ruleBacktrackFailure()>
+	<ruleBacktrackFailure()>
<(nvaExceptionWrapperMap.(k))({NoViableAltException nvae =
new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
<@noViableAltException()>
@@ -960,7 +960,7 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
alt<decisionNumber>=<eotPredictsAlt>; <! if no edges, don't gen ELSE !>
<else>
else {
-    alt<decisionNumber>=<eotPredictsAlt>;
+	alt<decisionNumber>=<eotPredictsAlt>;
}<\n>
<endif>
<endif>
@@ -975,7 +975,7 @@ dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>;"
*/
dfaEdge(labelExpr, targetState, predicates) ::= <<
if ( (<labelExpr>) <if(predicates)>&& (<predicates>)<endif>) {
-    <targetState>
+	<targetState>
}
>>

@@ -989,9 +989,9 @@ switch ( input.LA(<k>) ) {
<edges; separator="\n">
default:
<if(eotPredictsAlt)>
-    alt<decisionNumber>=<eotPredictsAlt>;
+	alt<decisionNumber>=<eotPredictsAlt>;
<else>
-    <ruleBacktrackFailure()>
+	<ruleBacktrackFailure()>
<(nvaExceptionWrapperMap.(k))({NoViableAltException nvae =
new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
<@noViableAltException()>
@@ -1002,7 +1002,7 @@ throw nvae;})>

dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
switch ( input.LA(<k>) ) {
-    <edges; separator="\n">
+	<edges; separator="\n">
}<\n>
>>

@@ -1011,18 +1011,18 @@ switch ( input.LA(<k>) ) {
<edges; separator="\n"><\n>
<if(eotPredictsAlt)>
default:
-    alt<decisionNumber>=<eotPredictsAlt>;
-    break;<\n>
+	alt<decisionNumber>=<eotPredictsAlt>;
+	break;<\n>
<endif>
}<\n>
>>

dfaEdgeSwitch(labels, targetState) ::= <<
<labels:{it |case <it>:}; separator="\n">
-    {
-    <targetState>
-    }
-    break;
+	{
+	<targetState>
+	}
+	break;
>>

// C y c l i c  D F A
@@ -1045,19 +1045,19 @@ alt<decisionNumber> = dfa<decisionNumber>.predict(input);
*/
cyclicDFA(dfa) ::= <<
static final String DFA<dfa.decisionNumber>_eotS =
-    "<dfa.javaCompressedEOT; wrap="\"+\n    \"">";
+	"<dfa.javaCompressedEOT; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_eofS =
-    "<dfa.javaCompressedEOF; wrap="\"+\n    \"">";
+	"<dfa.javaCompressedEOF; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_minS =
-    "<dfa.javaCompressedMin; wrap="\"+\n    \"">";
+	"<dfa.javaCompressedMin; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_maxS =
-    "<dfa.javaCompressedMax; wrap="\"+\n    \"">";
+	"<dfa.javaCompressedMax; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_acceptS =
-    "<dfa.javaCompressedAccept; wrap="\"+\n    \"">";
+	"<dfa.javaCompressedAccept; wrap="\"+\n\t\"">";
static final String DFA<dfa.decisionNumber>_specialS =
-    "<dfa.javaCompressedSpecial; wrap="\"+\n    \"">}>";
+	"<dfa.javaCompressedSpecial; wrap="\"+\n\t\"">}>";
static final String[] DFA<dfa.decisionNumber>_transitionS = {
-        <dfa.javaCompressedTransition:{s|"<s; wrap="\"+\n\"">"}; separator=",\n">
+		<dfa.javaCompressedTransition:{s|"<s; wrap="\"+\n\"">"}; separator=",\n">
};

static final short[] DFA<dfa.decisionNumber>_eot = DFA.unpackEncodedString(DFA<dfa.decisionNumber>_eotS);
@@ -1069,55 +1069,55 @@ static final short[] DFA<dfa.decisionNumber>_special = DFA.unpackEncodedString(D
static final short[][] DFA<dfa.decisionNumber>_transition;

static {
-    int numStates = DFA<dfa.decisionNumber>_transitionS.length;
-    DFA<dfa.decisionNumber>_transition = new short[numStates][];
-    for (int i=0; i\<numStates; i++) {
-        DFA<dfa.decisionNumber>_transition[i] = DFA.unpackEncodedString(DFA<dfa.decisionNumber>_transitionS[i]);
-    }
+	int numStates = DFA<dfa.decisionNumber>_transitionS.length;
+	DFA<dfa.decisionNumber>_transition = new short[numStates][];
+	for (int i=0; i\<numStates; i++) {
+		DFA<dfa.decisionNumber>_transition[i] = DFA.unpackEncodedString(DFA<dfa.decisionNumber>_transitionS[i]);
+	}
}

class DFA<dfa.decisionNumber> extends DFA {

-    public DFA<dfa.decisionNumber>(BaseRecognizer recognizer) {
-        this.recognizer = recognizer;
-        this.decisionNumber = <dfa.decisionNumber>;
-        this.eot = DFA<dfa.decisionNumber>_eot;
-        this.eof = DFA<dfa.decisionNumber>_eof;
-        this.min = DFA<dfa.decisionNumber>_min;
-        this.max = DFA<dfa.decisionNumber>_max;
-        this.accept = DFA<dfa.decisionNumber>_accept;
-        this.special = DFA<dfa.decisionNumber>_special;
-        this.transition = DFA<dfa.decisionNumber>_transition;
-    }
-    public String getDescription() {
-        return "<dfa.description>";
-    }
-    <@errorMethod()>
+	public DFA<dfa.decisionNumber>(BaseRecognizer recognizer) {
+		this.recognizer = recognizer;
+		this.decisionNumber = <dfa.decisionNumber>;
+		this.eot = DFA<dfa.decisionNumber>_eot;
+		this.eof = DFA<dfa.decisionNumber>_eof;
+		this.min = DFA<dfa.decisionNumber>_min;
+		this.max = DFA<dfa.decisionNumber>_max;
+		this.accept = DFA<dfa.decisionNumber>_accept;
+		this.special = DFA<dfa.decisionNumber>_special;
+		this.transition = DFA<dfa.decisionNumber>_transition;
+	}
+	public String getDescription() {
+		return "<dfa.description>";
+	}
+	<@errorMethod()>
<if(dfa.specialStateSTs)>
-    public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
-        <if(LEXER)>
-        IntStream input = _input;
-        <endif>
-        <if(PARSER)>
-        TokenStream input = (TokenStream)_input;
-        <endif>
-        <if(TREE_PARSER)>
-        TreeNodeStream input = (TreeNodeStream)_input;
-        <endif>
-    	int _s = s;
-        switch ( s ) {
-        <dfa.specialStateSTs:{state |
-        case <i0> : <! compressed special state numbers 0..n-1 !>
-            <state>}; separator="\n">
-        }
+	public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
+		<if(LEXER)>
+		IntStream input = _input;
+		<endif>
+		<if(PARSER)>
+		TokenStream input = (TokenStream)_input;
+		<endif>
+		<if(TREE_PARSER)>
+		TreeNodeStream input = (TreeNodeStream)_input;
+		<endif>
+		int _s = s;
+		switch ( s ) {
+		<dfa.specialStateSTs:{state |
+		case <i0> : <! compressed special state numbers 0..n-1 !>
+			<state>}; separator="\n">
+		}
<if(backtracking)>
-        if (state.backtracking>0) {state.failed=true; return -1;}<\n>
+		if (state.backtracking>0) {state.failed=true; return -1;}<\n>
<endif>
-        NoViableAltException nvae =
-            new NoViableAltException(getDescription(), <dfa.decisionNumber>, _s, input);
-        error(nvae);
-        throw nvae;
-    }<\n>
+		NoViableAltException nvae =
+			new NoViableAltException(getDescription(), <dfa.decisionNumber>, _s, input);
+		error(nvae);
+		throw nvae;
+	}<\n>
<endif>
}<\n>
>>
@@ -1189,7 +1189,7 @@ setTest(ranges) ::= <<
globalAttributeScope(scope) ::= <<
<if(scope.attributes)>
protected static class <scope.name>_scope {
-    <scope.attributes:{it |<it.decl>;}; separator="\n">
+	<scope.attributes:{it |<it.decl>;}; separator="\n">
}
protected Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.name>_scope\>();<\n>
<endif>
@@ -1198,7 +1198,7 @@ protected Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.nam
ruleAttributeScope(scope) ::= <<
<if(scope.attributes)>
protected static class <scope.name>_scope {
-    <scope.attributes:{it |<it.decl>;}; separator="\n">
+	<scope.attributes:{it |<it.decl>;}; separator="\n">
}
protected Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.name>_scope\>();<\n>
<endif>
@@ -1253,8 +1253,8 @@ ruleLabelDef(label) ::= <%
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
public static class <ruleDescriptor:returnStructName()> extends <returnScopeBaseType()> {
-    <scope.attributes:{it |public <it.decl>;}; separator="\n">
-    <@ruleReturnMembers()>
+	<scope.attributes:{it |public <it.decl>;}; separator="\n">
+	<@ruleReturnMembers()>
};
<endif>
>>
@@ -1362,19 +1362,19 @@ ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?((StringTemplate)<scope>
lexerRuleLabel(label) ::= "<label>"

lexerRuleLabelPropertyRef_type(scope,attr) ::=
-    "(<scope>!=null?<scope>.getType():0)"
+	"(<scope>!=null?<scope>.getType():0)"
lexerRuleLabelPropertyRef_line(scope,attr) ::=
-    "(<scope>!=null?<scope>.getLine():0)"
+	"(<scope>!=null?<scope>.getLine():0)"
lexerRuleLabelPropertyRef_pos(scope,attr) ::=
-    "(<scope>!=null?<scope>.getCharPositionInLine():-1)"
+	"(<scope>!=null?<scope>.getCharPositionInLine():-1)"
lexerRuleLabelPropertyRef_channel(scope,attr) ::=
-    "(<scope>!=null?<scope>.getChannel():0)"
+	"(<scope>!=null?<scope>.getChannel():0)"
lexerRuleLabelPropertyRef_index(scope,attr) ::=
-    "(<scope>!=null?<scope>.getTokenIndex():0)"
+	"(<scope>!=null?<scope>.getTokenIndex():0)"
lexerRuleLabelPropertyRef_text(scope,attr) ::=
-    "(<scope>!=null?<scope>.getText():null)"
+	"(<scope>!=null?<scope>.getText():null)"
lexerRuleLabelPropertyRef_int(scope,attr) ::=
-    "(<scope>!=null?Integer.valueOf(<scope>.getText()):0)"
+	"(<scope>!=null?Integer.valueOf(<scope>.getText()):0)"

// Somebody may ref $template or $tree or $stop within a rule:
rulePropertyRef_start(scope,attr) ::= "((<labelType>)retval.start)"
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ST.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ST.stg
index a898e4d..d8a0162 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ST.stg
@@ -58,14 +58,14 @@ public StringTemplateGroup getTemplateLib() {
*  "new STAttrMap().put(...).put(...)"
*/
public static class STAttrMap extends HashMap {
-  public STAttrMap put(String attrName, Object value) {
-    super.put(attrName, value);
-    return this;
-  }
-  public STAttrMap put(String attrName, int value) {
-    super.put(attrName, new Integer(value));
-    return this;
-  }
+	public STAttrMap put(String attrName, Object value) {
+		super.put(attrName, value);
+		return this;
+	}
+	public STAttrMap put(String attrName, int value) {
+		super.put(attrName, new Integer(value));
+		return this;
+	}
}
>>

@@ -107,11 +107,11 @@ rewriteTemplateAlt(alt) ::= <<
// <alt.description>
<if(alt.pred)>
if (<alt.pred>) {
-    retval.st = <alt.alt>;
+	retval.st = <alt.alt>;
}<\n>
<else>
{
-    retval.st = <alt.alt>;
+	retval.st = <alt.alt>;
}<\n>
<endif>
>>

