commit 6850982a98d159c69c622735ab8856b9bfa4eecc
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Tue Jan 29 23:10:44 2013 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Tue Jan 29 23:11:47 2013 -0600

CSharp2 and CSharp3: runtime and template updates to synchronize with changes in Java version

diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime.Debug/ParseTreeBuilder.cs b/runtime/CSharp3/Sources/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
index deeaf3b..cb5f678 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime.Debug/ParseTreeBuilder.cs
@@ -58,7 +58,8 @@ namespace Antlr.Runtime.Debug
{
get
{
-                return callStack.Peek();
+                ParseTree[] stack = callStack.ToArray();
+                return stack[stack.Length - 1];
}
}

diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime.Debug/Properties/AssemblyInfo.cs b/runtime/CSharp3/Sources/Antlr3.Runtime.Debug/Properties/AssemblyInfo.cs
index 5cc7429..dd6db55 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime.Debug/Properties/AssemblyInfo.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime.Debug/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime.JavaExtensions/Properties/AssemblyInfo.cs b/runtime/CSharp3/Sources/Antlr3.Runtime.JavaExtensions/Properties/AssemblyInfo.cs
index d936148..596e4af 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime.JavaExtensions/Properties/AssemblyInfo.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime.JavaExtensions/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime.Test/Properties/AssemblyInfo.cs b/runtime/CSharp3/Sources/Antlr3.Runtime.Test/Properties/AssemblyInfo.cs
index 478f623..d4f63a4 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime.Test/Properties/AssemblyInfo.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime.Test/Properties/AssemblyInfo.cs
@@ -66,5 +66,5 @@ using System.Runtime.InteropServices;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/Antlr3.Runtime.csproj b/runtime/CSharp3/Sources/Antlr3.Runtime/Antlr3.Runtime.csproj
index 4afc0d0..2188cc0 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime/Antlr3.Runtime.csproj
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/Antlr3.Runtime.csproj
@@ -99,6 +99,7 @@
<Compile Include="Tree\CommonTreeAdaptor.cs" />
<Compile Include="Tree\CommonTreeNodeStream.cs" />
<Compile Include="Tree\DotTreeGenerator.cs" />
+    <Compile Include="Tree\IPositionTrackingStream.cs" />
<Compile Include="Tree\ITree.cs" />
<Compile Include="Tree\ITreeAdaptor.cs" />
<Compile Include="Tree\ITreeNodeStream.cs" />
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/Lexer.cs b/runtime/CSharp3/Sources/Antlr3.Runtime/Lexer.cs
index cf478c6..daf530d 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime/Lexer.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/Lexer.cs
@@ -137,10 +137,7 @@ namespace Antlr.Runtime
state.text = null;
if ( input.LA( 1 ) == CharStreamConstants.EndOfFile )
{
-                    IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
-                    eof.Line = Line;
-                    eof.CharPositionInLine = CharPositionInLine;
-                    return eof;
+                    return GetEndOfFileToken();
}
try
{
@@ -173,6 +170,17 @@ namespace Antlr.Runtime
}
}

+        /** Returns the EOF token (default), if you need
+         *  to return a custom token instead override this method.
+         */
+        public virtual IToken GetEndOfFileToken()
+        {
+            IToken eof = new CommonToken((ICharStream)input, CharStreamConstants.EndOfFile, TokenChannels.Default, input.Index, input.Index);
+            eof.Line = Line;
+            eof.CharPositionInLine = CharPositionInLine;
+            return eof;
+        }
+
/** <summary>
*  Instruct the lexer to skip creating a token for current lexer rule
*  and look for another token.  nextToken() knows to keep looking when
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/Misc/FastQueue.cs b/runtime/CSharp3/Sources/Antlr3.Runtime/Misc/FastQueue.cs
index 2dc5bfc..af975d7 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime/Misc/FastQueue.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/Misc/FastQueue.cs
@@ -71,9 +71,9 @@ namespace Antlr.Runtime.Misc
}

/** <summary>
-         *  Return element i elements ahead of current element.  i==0 gets
-         *  current element.  This is not an absolute index into the data list
-         *  since p defines the start of the real list.
+         * Return element {@code i} elements ahead of current element. {@code i==0}
+         * gets current element. This is not an absolute index into {@link #data}
+         * since {@code p} defines the start of the real list.
*  </summary>
*/
public virtual T this[int i]
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/Misc/LookaheadStream.cs b/runtime/CSharp3/Sources/Antlr3.Runtime/Misc/LookaheadStream.cs
index 24dc0cb..38c26a8 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime/Misc/LookaheadStream.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/Misc/LookaheadStream.cs
@@ -33,13 +33,16 @@
namespace Antlr.Runtime.Misc
{
using ArgumentException = System.ArgumentException;
+    using Debug = System.Diagnostics.Debug;
using InvalidOperationException = System.InvalidOperationException;
+    using NotSupportedException = System.NotSupportedException;
+    using ArgumentOutOfRangeException = System.ArgumentOutOfRangeException;

/** <summary>
-     *  A lookahead queue that knows how to mark/release locations
-     *  in the buffer for backtracking purposes. Any markers force the FastQueue
-     *  superclass to keep all tokens until no more markers; then can reset
-     *  to avoid growing a huge buffer.
+     * A lookahead queue that knows how to mark/release locations in the buffer for
+     * backtracking purposes. Any markers force the {@link FastQueue} superclass to
+     * keep all elements until no more markers; then can reset to avoid growing a
+     * huge buffer.
*  </summary>
*/
public abstract class LookaheadStream<T>
@@ -47,10 +50,13 @@ namespace Antlr.Runtime.Misc
where T : class
{
/** Absolute token index. It's the index of the symbol about to be
-         *  read via LT(1). Goes from 0 to numtokens.
+         *  read via {@code LT(1)}. Goes from 0 to numtokens.
*/
private int _currentElementIndex = 0;

+        /**
+         * This is the {@code LT(-1)} element for the first element in {@link #data}.
+         */
private T _previousElement;

/** Track object returned by nextElement upon end of stream;
@@ -94,14 +100,17 @@ namespace Antlr.Runtime.Misc

/** <summary>
*  Implement nextElement to supply a stream of elements to this
-         *  lookahead buffer.  Return eof upon end of the stream we're pulling from.
+         *  lookahead buffer.  Return EOF upon end of the stream we're pulling from.
*  </summary>
*/
public abstract T NextElement();

public abstract bool IsEndOfFile(T o);

-        /** <summary>Get and remove first element in queue; override FastQueue.remove()</summary> */
+        /** <summary>
+         * Get and remove first element in queue; override
+         * {@link FastQueue#remove()}; it's the same, just checks for backtracking.
+         * </summary> */
public override T Dequeue()
{
T o = this[0];
@@ -109,6 +118,7 @@ namespace Antlr.Runtime.Misc
// have we hit end of buffer and not backtracking?
if ( _p == _data.Count && _markDepth == 0 )
{
+                _previousElement = o;
// if so, it's an opportunity to start filling at index 0 again
Clear(); // size goes to 0, but retains memory
}
@@ -119,7 +129,7 @@ namespace Antlr.Runtime.Misc
public virtual void Consume()
{
SyncAhead(1);
-            _previousElement = Dequeue();
+            Dequeue();
_currentElementIndex++;
}

@@ -201,34 +211,61 @@ namespace Antlr.Runtime.Misc

public virtual void Rewind( int marker )
{
-            Seek( marker );
-            Release( marker );
+            _markDepth--;
+            int delta = _p - marker;
+            _currentElementIndex -= delta;
+            _p = marker;
}

public virtual void Rewind()
{
-            Rewind( _lastMarker );
+            // rewind but do not release marker
+            int delta = _p - _lastMarker;
+            _currentElementIndex -= delta;
+            _p = _lastMarker;
}

/** <summary>
-         *  Seek to a 0-indexed position within data buffer.  Can't handle
-         *  case where you seek beyond end of existing buffer.  Normally used
-         *  to seek backwards in the buffer. Does not force loading of nodes.
-         *  Doesn't see to absolute position in input stream since this stream
-         *  is unbuffered. Seeks only into our moving window of elements.
+         * Seek to a 0-indexed absolute token index. Normally used to seek backwards
+         * in the buffer. Does not force loading of nodes.
*  </summary>
+         *  <remarks>
+         * To preserve backward compatibility, this method allows seeking past the
+         * end of the currently buffered data. In this case, the input pointer will
+         * be moved but the data will only actually be loaded upon the next call to
+         * {@link #consume} or {@link #LT} for {@code k>0}.
+         *  </remarks>
*/
public virtual void Seek( int index )
{
-            _p = index;
+            if (index < 0)
+                throw new ArgumentOutOfRangeException("index");
+
+            int delta = _currentElementIndex - index;
+            if (_p - delta < 0)
+                throw new NotSupportedException("can't seek before the beginning of this stream's buffer");
+
+            _p -= delta;
+            _currentElementIndex = index;
}

protected virtual T LB(int k)
{
-            if (k == 1)
+            Debug.Assert(k > 0);
+
+            int index = _p - k;
+            if (index == -1)
return _previousElement;

-            throw new ArgumentException("can't look backwards more than one token in this stream");
+            // if k>0 then we know index < data.size(). avoid the double-check for
+            // performance.
+            if (index >= 0 /*&& index < data.size()*/)
+                return _data[index];
+
+            if (index < -1)
+                throw new NotSupportedException("can't look more than one token before the beginning of this stream's buffer");
+
+            throw new NotSupportedException("can't look past the end of this stream's buffer using LB(int)");
}
}
}
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/Properties/AssemblyInfo.cs b/runtime/CSharp3/Sources/Antlr3.Runtime/Properties/AssemblyInfo.cs
index a20bacc..24f7daf 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime/Properties/AssemblyInfo.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/Properties/AssemblyInfo.cs
@@ -68,5 +68,5 @@ using System.Security;
*      the Major or Minor version is incremented.
*   3. Revision is the Perforce changelist number associated with the release.
*/
-[assembly: AssemblyVersion("3.4.1.9004")]
-[assembly: AssemblyFileVersion("3.4.1.9004")]
+[assembly: AssemblyVersion("3.5.0.0")]
+[assembly: AssemblyFileVersion("3.5.0.0")]
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/RecognitionException.cs b/runtime/CSharp3/Sources/Antlr3.Runtime/RecognitionException.cs
index 861769f..007560d 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime/RecognitionException.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/RecognitionException.cs
@@ -34,9 +34,9 @@ namespace Antlr.Runtime
{
using Antlr.Runtime.Tree;

-    using ArgumentException = System.ArgumentException;
using ArgumentNullException = System.ArgumentNullException;
using Exception = System.Exception;
+    using NotSupportedException = System.NotSupportedException;
using SerializationInfo = System.Runtime.Serialization.SerializationInfo;
using StreamingContext = System.Runtime.Serialization.StreamingContext;

@@ -369,6 +369,19 @@ namespace Antlr.Runtime
protected virtual void ExtractInformationFromTreeNodeStream(ITreeNodeStream input)
{
this._node = input.LT(1);
+
+            object positionNode = null;
+            IPositionTrackingStream positionTrackingStream = input as IPositionTrackingStream;
+            if (positionTrackingStream != null)
+            {
+                positionNode = positionTrackingStream.GetKnownPositionElement(false);
+                if (positionNode == null)
+                {
+                    positionNode = positionTrackingStream.GetKnownPositionElement(true);
+                    this._approximateLineInfo = positionNode != null;
+                }
+            }
+
ITokenStreamInformation streamInformation = input as ITokenStreamInformation;
if (streamInformation != null)
{
@@ -385,7 +398,7 @@ namespace Antlr.Runtime
else
{
ITreeAdaptor adaptor = input.TreeAdaptor;
-                IToken payload = adaptor.GetToken(_node);
+                IToken payload = adaptor.GetToken(positionNode ?? _node);
if (payload != null)
{
this._token = payload;
@@ -405,12 +418,13 @@ namespace Antlr.Runtime
this._approximateLineInfo = true;
break;
}
+
--i;
try
{
priorNode = input.LT(i);
}
-                            catch (ArgumentException)
+                            catch (NotSupportedException)
{
priorNode = null;
}
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/CommonTreeNodeStream.cs b/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/CommonTreeNodeStream.cs
index 4f8e069..1764d1e 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/CommonTreeNodeStream.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/CommonTreeNodeStream.cs
@@ -38,7 +38,7 @@ namespace Antlr.Runtime.Tree
using StringBuilder = System.Text.StringBuilder;

[System.Serializable]
-    public class CommonTreeNodeStream : LookaheadStream<object>, ITreeNodeStream
+    public class CommonTreeNodeStream : LookaheadStream<object>, ITreeNodeStream, IPositionTrackingStream
{
public const int DEFAULT_INITIAL_BUFFER_SIZE = 100;
public const int INITIAL_CALL_STACK_SIZE = 10;
@@ -65,6 +65,17 @@ namespace Antlr.Runtime.Tree
/** <summary>Tracks tree depth.  Level=0 means we're at root node level.</summary> */
private int _level = 0;

+        /**
+         * Tracks the last node before the start of {@link #data} which contains
+         * position information to provide information for error reporting. This is
+         * tracked in addition to {@link #prevElement} which may or may not contain
+         * position information.
+         *
+         * @see #hasPositionInformation
+         * @see RecognitionException#extractInformationFromTreeNodeStream
+         */
+        private object _previousLocationElement;
+
public CommonTreeNodeStream( object tree )
: this( new CommonTreeAdaptor(), tree )
{
@@ -144,6 +155,7 @@ namespace Antlr.Runtime.Tree
_it.Reset();
_hasNilRoot = false;
_level = 0;
+            _previousLocationElement = null;
if ( _calls != null )
_calls.Clear();
}
@@ -181,6 +193,15 @@ namespace Antlr.Runtime.Tree
return t;
}

+        public override object Dequeue()
+        {
+            object result = base.Dequeue();
+            if (_p == 0 && HasPositionInformation(PreviousElement))
+                _previousLocationElement = PreviousElement;
+
+            return result;
+        }
+
public override bool IsEndOfFile(object o)
{
return TreeAdaptor.GetType(o) == CharStreamConstants.EndOfFile;
@@ -213,6 +234,44 @@ namespace Antlr.Runtime.Tree
return ret;
}

+        /**
+         * Returns an element containing position information. If {@code allowApproximateLocation} is {@code false}, then
+         * this method will return the {@code LT(1)} element if it contains position information, and otherwise return {@code null}.
+         * If {@code allowApproximateLocation} is {@code true}, then this method will return the last known element containing position information.
+         *
+         * @see #hasPositionInformation
+         */
+        public object GetKnownPositionElement(bool allowApproximateLocation)
+        {
+            object node = _data[_p];
+            if (HasPositionInformation(node))
+                return node;
+
+            if (!allowApproximateLocation)
+                return null;
+
+            for (int index = _p - 1; index >= 0; index--)
+            {
+                node = _data[index];
+                if (HasPositionInformation(node))
+                    return node;
+            }
+
+            return _previousLocationElement;
+        }
+
+        public bool HasPositionInformation(object node)
+        {
+            IToken token = TreeAdaptor.GetToken(node);
+            if (token == null)
+                return false;
+
+            if (token.Line <= 0)
+                return false;
+
+            return true;
+        }
+
#region Tree rewrite interface

public virtual void ReplaceChildren( object parent, int startChildIndex, int stopChildIndex, object t )
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/IPositionTrackingStream.cs b/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/IPositionTrackingStream.cs
new file mode 100644
index 0000000..8bc8945
--- /dev/null
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/IPositionTrackingStream.cs
@@ -0,0 +1,59 @@
+﻿/*
+ [The "BSD license"]
+ Copyright (c) 2012 Terence Parr
+ Copyright (c) 2012 Sam Harwell
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+     notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+     notice, this list of conditions and the following disclaimer in the
+     documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+     derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+namespace Antlr.Runtime.Tree
+{
+    /**
+     *
+     * @author Sam Harwell
+     */
+    public interface IPositionTrackingStream
+    {
+        /**
+         * Returns an element containing concrete information about the current
+         * position in the stream.
+         *
+         * @param allowApproximateLocation if {@code false}, this method returns
+         * {@code null} if an element containing exact information about the current
+         * position is not available
+         */
+        object GetKnownPositionElement(bool allowApproximateLocation);
+
+        /**
+         * Determines if the specified {@code element} contains concrete position
+         * information.
+         *
+         * @param element the element to check
+         * @return {@code true} if {@code element} contains concrete position
+         * information, otherwise {@code false}
+         */
+        bool HasPositionInformation(object element);
+
+    }
+}
diff --git a/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/ITreeNodeStream.cs b/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/ITreeNodeStream.cs
index b133f39..8f3f30a 100644
--- a/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/ITreeNodeStream.cs
+++ b/runtime/CSharp3/Sources/Antlr3.Runtime/Tree/ITreeNodeStream.cs
@@ -47,18 +47,18 @@ namespace Antlr.Runtime.Tree
}

/** <summary>
-         *  Get tree node at current input pointer + i ahead where i=1 is next node.
-         *  i&lt;0 indicates nodes in the past.  So LT(-1) is previous node, but
-         *  implementations are not required to provide results for k &lt; -1.
-         *  LT(0) is undefined.  For i&gt;=n, return null.
-         *  Return null for LT(0) and any index that results in an absolute address
-         *  that is negative.
+         * Get tree node at current input pointer + {@code k} ahead where
+         * {@code k==1} is next node. {@code k<0} indicates nodes in the past. So
+         * {@code LT(-1)} is previous node, but implementations are not required to
+         * provide results for {@code k < -1}. {@code LT(0)} is undefined. For
+         * {@code k<=n}, return {@code null}. Return {@code null} for {@code LT(0)}
+         * and any index that results in an absolute address that is negative.
*  </summary>
*
*  <remarks>
-         *  This is analogus to the LT() method of the TokenStream, but this
-         *  returns a tree node instead of a token.  Makes code gen identical
-         *  for both parser and tree grammars. :)
+         * This is analogous to {@link TokenStream#LT}, but this returns a tree node
+         * instead of a {@link Token}. Makes code generation identical for both
+         * parser and tree grammars.
*  </remarks>
*/
object LT( int k );
@@ -74,10 +74,11 @@ namespace Antlr.Runtime.Tree
}

/** <summary>
-         *  If the tree associated with this stream was created from a TokenStream,
-         *  you can specify it here.  Used to do rule $text attribute in tree
-         *  parser.  Optional unless you use tree parser rule text attribute
-         *  or output=template and rewrite=true options.
+         * If the tree associated with this stream was created from a
+         * {@link TokenStream}, you can specify it here. Used to do rule
+         * {@code $text} attribute in tree parser. Optional unless you use tree
+         * parser rule {@code $text} attribute or {@code output=template} and
+         * {@code rewrite=true} options.
*  </summary>
*/
ITokenStream TokenStream
@@ -96,11 +97,11 @@ namespace Antlr.Runtime.Tree
}

/** <summary>
-         *  As we flatten the tree, we use UP, DOWN nodes to represent
-         *  the tree structure.  When debugging we need unique nodes
-         *  so we have to instantiate new ones.  When doing normal tree
-         *  parsing, it's slow and a waste of memory to create unique
-         *  navigation nodes.  Default should be false;
+         * As we flatten the tree, we use {@link Token#UP}, {@link Token#DOWN} nodes
+         * to represent the tree structure. When debugging we need unique nodes so
+         * we have to instantiate new ones. When doing normal tree parsing, it's
+         * slow and a waste of memory to create unique navigation nodes. Default
+         * should be {@code false}.
*  </summary>
*/
bool UniqueNavigationNodes
@@ -110,11 +111,11 @@ namespace Antlr.Runtime.Tree
}

/** <summary>
-         *  Return the text of all nodes from start to stop, inclusive.
-         *  If the stream does not buffer all the nodes then it can still
-         *  walk recursively from start until stop.  You can always return
-         *  null or "" too, but users should not access $ruleLabel.text in
-         *  an action of course in that case.
+         * Return the text of all nodes from {@code start} to {@code stop},
+         * inclusive. If the stream does not buffer all the nodes then it can still
+         * walk recursively from start until stop. You can always return
+         * {@code null} or {@code ""} too, but users should not access
+         * {@code $ruleLabel.text} in an action of course in that case.
*  </summary>
*/
string ToString( object start, object stop );
@@ -123,17 +124,18 @@ namespace Antlr.Runtime.Tree
#region REWRITING TREES (used by tree parser)

/** <summary>
-         *  Replace from start to stop child index of parent with t, which might
-         *  be a list.  Number of children may be different
-         *  after this call.  The stream is notified because it is walking the
-         *  tree and might need to know you are monkeying with the underlying
-         *  tree.  Also, it might be able to modify the node stream to avoid
-         *  restreaming for future phases.
+         * Replace children of {@code parent} from index {@code startChildIndex} to
+         * {@code stopChildIndex} with {@code t}, which might be a list. Number of
+         * children may be different after this call. The stream is notified because
+         * it is walking the tree and might need to know you are monkeying with the
+         * underlying tree. Also, it might be able to modify the node stream to
+         * avoid restreaming for future phases.
*  </summary>
*
*  <remarks>
-         *  If parent is null, don't do anything; must be at root of overall tree.
-         *  Can't replace whatever points to the parent externally.  Do nothing.
+         * If {@code parent} is {@code null}, don't do anything; must be at root of
+         * overall tree. Can't replace whatever points to the parent externally. Do
+         * nothing.
*  </remarks>
*/
void ReplaceChildren( object parent, int startChildIndex, int stopChildIndex, object t );
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/AST.stg
index a898b69..a94ed7c 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/AST.stg
@@ -117,7 +117,7 @@ root_0 = (<ASTLabelType>)adaptor.Nil();
// T r a c k i n g  R u l e  E l e m e n t s

/** ID and track it for use in a rewrite rule */
-tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefTrack(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)> <! Track implies no auto AST construction!>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
>>
@@ -125,19 +125,19 @@ tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
*  to the tracking list stream_ID for use in the rewrite.
*/
-tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefTrack(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** ^(ID ...) track for rewrite */
-tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
>>

/** Match ^(label+=TOKEN ...) track for rewrite */
-tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefRuleRootTrack(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -321,7 +321,7 @@ DebugLocation(<e.line>, <e.pos>);<\n>
%>

/** Gen ID or ID[args] */
-rewriteTokenRef(token,elementIndex,terminalOptions,args) ::= <<
+rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
>>

@@ -344,15 +344,15 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(),
rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot

/** Gen ^(ID ...) or ^(ID[args] ...) */
-rewriteTokenRefRoot(token,elementIndex,terminalOptions,args) ::= <<
+rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
>>

-rewriteImaginaryTokenRef(args,token,terminalOptions,elementIndex) ::= <<
+rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
>>

-rewriteImaginaryTokenRefRoot(args,token,terminalOptions,elementIndex) ::= <<
+rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
>>

@@ -408,7 +408,7 @@ rewriteWildcardLabelRef(label) ::= <<
adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
>>

-createImaginaryNode(tokenType,terminalOptions,args) ::= <%
+createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
<! new MethodNode(IDLabel, args) !>
new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
@@ -417,7 +417,7 @@ new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
<endif>
%>

-createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
+createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
<else>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTDbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTDbg.stg
index 0d2a441..e7b2904 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTDbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTDbg.stg
@@ -33,24 +33,24 @@
*/

parserMembers() ::= <<
-protected DebugTreeAdaptor adaptor;
+	protected DebugTreeAdaptor adaptor;

-public ITreeAdaptor TreeAdaptor
-{
-	get
-	{
-		return adaptor;
-	}
-	set
+	public ITreeAdaptor TreeAdaptor
{
+		get
+		{
+			return adaptor;
+		}
+		set
+		{
<if(grammar.grammarIsRoot)>
-		this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
+			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
<else>
-		this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+			this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
<endif><\n>
-		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
-	}
-}<\n>
+			<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+		}
+	}<\n>
>>

parserCtorBody() ::= <<
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTParser.stg
index 6413dfe..1585287 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTParser.stg
@@ -49,7 +49,7 @@ retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1
// TOKEN AST STUFF

/** ID and output=AST */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
<super.tokenRef(...)>
<if(backtracking)>if (state.backtracking == 0) {<endif>
<label>_tree = <createNodeFromToken(...)>;
@@ -61,7 +61,7 @@ adaptor.AddChild(root_0, <label>_tree);
tokenRefBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"

/** ID^ and output=AST */
-tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
<super.tokenRef(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = <createNodeFromToken(...)>;
@@ -70,19 +70,19 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
>>

/** ids+=ID! and output=AST */
-tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** label+=TOKEN when output=AST but not rewrite alt */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRef(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** Match label+=TOKEN^ when output=AST but not rewrite alt */
-tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefRuleRoot(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -100,20 +100,20 @@ tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
// rather than just added on code.  Investigate that refactoring when
// I have more time.

-matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+matchSet(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= <<
<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);}, ...)>
>>

-matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+matchRuleBlockSet(s,label,elementIndex,postmatchCode,treeLevel="0",terminalOptions={}) ::= <<
<matchSet(...)>
>>

-matchSetBang(s,label,elementIndex,terminalOptions,postmatchCode) ::= "<super.matchSet(...)>"
+matchSetBang(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= "<super.matchSet(...)>"

// note there is no matchSetTrack because -> rewrites force sets to be
// plain old blocks of alts: (A|B|...|C)

-matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+matchSetRuleRoot(s,label,elementIndex,debug,terminalOptions={}) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);
<endif>
@@ -157,7 +157,7 @@ ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<

// WILDCARD AST

-wildcard(token,label,elementIndex,terminalOptions) ::= <<
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
<super.wildcard(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
@@ -165,9 +165,9 @@ adaptor.AddChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
>>

-wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"
+wildcardBang(label,elementIndex) ::= "<super.wildcard(token=[],...)>"

-wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+wildcardRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
<super.wildcard(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
@@ -175,7 +175,7 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
>>

-createNodeFromToken(label,terminalOptions) ::= <%
+createNodeFromToken(label,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<else>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTTreeParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTTreeParser.stg
index fc6df64..316282f 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTTreeParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTTreeParser.stg
@@ -53,7 +53,7 @@ ruleDeclarations() ::= <<
/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
-noRewrite(rewriteBlockLevel, treeLevel) ::= <<
+noRewrite(rewriteBlockLevel=false, treeLevel=false) ::= <<
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(rewriteMode)>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
index a9b9107..8f15ef2 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
@@ -344,7 +344,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
appear to be defined in this recognizer. !>
#region Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", "><endif>); \}}; separator="\n">
#endregion Delegated rules
<endif>

@@ -377,14 +377,14 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,

@genericParser.members() ::= <<
#if ANTLR_DEBUG
-	private static readonly bool[] decisionCanBacktrack =
-		new bool[]
-		{
-			false, // invalid decision
-			<grammar.decisions:{d | <d.dfa.hasSynPred>}; wrap="\n", separator=", ">
-		};
+private static readonly bool[] decisionCanBacktrack =
+	new bool[]
+	{
+		false, // invalid decision
+		<grammar.decisions:{d | <d.dfa.hasSynPred>}; wrap="\n", separator=", ">
+	};
#else
-	private static readonly bool[] decisionCanBacktrack = new bool[0];
+private static readonly bool[] decisionCanBacktrack = new bool[0];
#endif
<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
@@ -631,7 +631,7 @@ ruleDeclarations() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>();
retval.Start = (<labelType>)input.LT(1);
-<else>
+<elseif(ruleDescriptor.returnScope)>
<ruleDescriptor.returnScope.attributes:{ a |
<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
}>
@@ -679,7 +679,7 @@ lexerRuleLabelDefs() ::= <<
ruleDescriptor.ruleListLabels]
:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
>
-<ruleDescriptor.charListLabels:{it|List\<int\> list_<it.label.text> = null;}; separator="\n"
+<ruleDescriptor.charListLabels:{it|List\<int> list_<it.label.text> = null;}; separator="\n"
>
>>

@@ -948,12 +948,12 @@ DebugLocation(<it.line>, <it.pos>);<\n>
%>

/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
>>

/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRef(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -980,7 +980,7 @@ MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,terminalOptions,elementIndex,postmatchCode="") ::= <<
+matchSet(s,label,elementIndex,postmatchCode="",terminalOptions={}) ::= <<
<if(label)>
<matchSetLabel()>
<endif>
@@ -1049,14 +1049,14 @@ Match(<string>); <checkRuleBacktrackFailure()><\n>
<endif>
%>

-wildcard(token,label,elementIndex,terminalOptions) ::= <<
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
MatchAny(input); <checkRuleBacktrackFailure()>
>>

-wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+wildcardAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<wildcard(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -1176,6 +1176,7 @@ if (!(<evalPredicate(...)>))
dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
+<if((!isTrue.(last(edges).labelExpr)) && (!last(edges).predicates))>
else
{
<if(eotPredictsAlt)>
@@ -1188,6 +1189,7 @@ else
throw nvae;
<endif>
}
+<endif>
>>

/** Same as a normal DFA state except that we don't examine lookahead
@@ -1481,6 +1483,7 @@ setTest(ranges) ::= <<
// A T T R I B U T E S

attributeScope(scope) ::= <<
+<if(scope)>
<if(scope.attributes)>
protected sealed partial class <scope.name>_scope
{
@@ -1502,7 +1505,8 @@ protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
<else>
protected virtual void <scope.name>_scopeAfter( <scope.name>_scope scope ) {}
<endif>
-protected readonly ListStack\<<scope.name>_scope\> <scope.name>_stack = new ListStack\<<scope.name>_scope\>();
+protected readonly ListStack\<<scope.name>_scope> <scope.name>_stack = new ListStack\<<scope.name>_scope>();
+<endif>
<endif>
>>

@@ -1761,3 +1765,8 @@ codeFileExtension() ::= ".cs"

true_value() ::= "true"
false_value() ::= "false"
+
+isTrue ::= [
+	"true" : true,
+	default : false
+]
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/Dbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/Dbg.stg
index 16f6de2..b537ff1 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/Dbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/Dbg.stg
@@ -49,21 +49,21 @@ public static readonly string[] ruleNames =
};<\n>
<endif>
<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
-	int ruleLevel = 0;
-	public virtual int RuleLevel { get { return ruleLevel; } }
-	public virtual void IncRuleLevel() { ruleLevel++; }
-	public virtual void DecRuleLevel() { ruleLevel--; }
+int ruleLevel = 0;
+public virtual int RuleLevel { get { return ruleLevel; } }
+public virtual void IncRuleLevel() { ruleLevel++; }
+public virtual void DecRuleLevel() { ruleLevel--; }
<if(profile)>
-	<ctorForProfilingRootGrammar()>
+<ctorForProfilingRootGrammar()>
<else>
-	<ctorForRootGrammar()>
+<ctorForRootGrammar()>
<endif>
<ctorForPredefinedListener()>
<else><! imported grammar !>
-	public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
-	public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
-	public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
-	<ctorForDelegateGrammar()>
+public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
+public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
+public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
+<ctorForDelegateGrammar()>
<endif>
<if(profile)>
public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/AST.stg
index 5eba4ed..d1d765a 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/AST.stg
@@ -115,7 +115,7 @@ root_0 = (<ASTLabelType>)adaptor.Nil();
// T r a c k i n g  R u l e  E l e m e n t s

/** ID and track it for use in a rewrite rule */
-tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefTrack(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)> <! Track implies no auto AST construction!>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
>>
@@ -123,19 +123,19 @@ tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
*  to the tracking list stream_ID for use in the rewrite.
*/
-tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefTrack(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** ^(ID ...) track for rewrite */
-tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
>>

/** Match ^(label+=TOKEN ...) track for rewrite */
-tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefRuleRootTrack(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -210,12 +210,12 @@ if (<prevRuleRootRef()>.Tree != null)

rewriteCodeLabels() ::= <<
<referencedTokenLabels
-    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
-    separator="\n"
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
+	separator="\n"
>
<referencedTokenListLabels
-    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
-    separator="\n"
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
+	separator="\n"
>
<referencedWildcardLabels
:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
@@ -226,12 +226,12 @@ rewriteCodeLabels() ::= <<
separator="\n"
>
<referencedRuleLabels
-    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
-    separator="\n"
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
+	separator="\n"
>
<referencedRuleListLabels
-    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
-    separator="\n"
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
+	separator="\n"
>
>>

@@ -319,7 +319,7 @@ DebugLocation(<e.line>, <e.pos>);<\n>
%>

/** Gen ID or ID[args] */
-rewriteTokenRef(token,elementIndex,terminalOptions,args) ::= <<
+rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
adaptor.AddChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
>>

@@ -342,15 +342,15 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(stream_<label>.NextNode(),
rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot

/** Gen ^(ID ...) or ^(ID[args] ...) */
-rewriteTokenRefRoot(token,elementIndex,terminalOptions,args) ::= <<
+rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
>>

-rewriteImaginaryTokenRef(args,token,terminalOptions,elementIndex) ::= <<
+rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
adaptor.AddChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
>>

-rewriteImaginaryTokenRefRoot(args,token,terminalOptions,elementIndex) ::= <<
+rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
>>

@@ -406,7 +406,7 @@ rewriteWildcardLabelRef(label) ::= <<
adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
>>

-createImaginaryNode(tokenType,terminalOptions,args) ::= <%
+createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
<! new MethodNode(IDLabel, args) !>
new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
@@ -415,7 +415,7 @@ new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
<endif>
%>

-createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
+createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
<else>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTDbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTDbg.stg
index 35d1629..b4b245a 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTDbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTDbg.stg
@@ -35,26 +35,26 @@
*/

parserMembers() ::= <<
-// Implement this function in your helper file to use a custom tree adaptor
-partial void InitializeTreeAdaptor();
-protected DebugTreeAdaptor adaptor;
+	// Implement this function in your helper file to use a custom tree adaptor
+	partial void InitializeTreeAdaptor();
+	protected DebugTreeAdaptor adaptor;

-public ITreeAdaptor TreeAdaptor
-{
-	get
-	{
-		return adaptor;
-	}
-	set
+	public ITreeAdaptor TreeAdaptor
{
+		get
+		{
+			return adaptor;
+		}
+		set
+		{
<if(grammar.grammarIsRoot)>
-		this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
+			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);
<else>
-		this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
+			this.adaptor = (DebugTreeAdaptor)adaptor; // delegator sends dbg adaptor
<endif><\n>
-		<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
-	}
-}<\n>
+			<grammar.directDelegates:{g|<g:delegateName()>.TreeAdaptor = this.adaptor;}>
+		}
+	}<\n>
>>

parserCtorBody() ::= <<
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTParser.stg
index 8b507c7..b97d44b 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTParser.stg
@@ -50,7 +50,7 @@ retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1
// TOKEN AST STUFF

/** ID and output=AST */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <%
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <%
<super.tokenRef(...)>
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)><\n>if (state.backtracking == 0) {<endif>
@@ -61,10 +61,10 @@ tokenRef(token,label,elementIndex,terminalOptions) ::= <%
%>

/** ID! and output=AST (same as plain tokenRef) */
-tokenRefBang(token,label,elementIndex,terminalOptions) ::= "<super.tokenRef(...)>"
+tokenRefBang(token,label,elementIndex,terminalOptions={}) ::= "<super.tokenRef(...)>"

/** ID^ and output=AST */
-tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <%
+tokenRefRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <%
<super.tokenRef(...)>
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)><\n>if (<actions.(actionScope).synpredgate>) {<endif>
@@ -75,19 +75,19 @@ tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <%
%>

/** ids+=ID! and output=AST */
-tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefBang(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** label+=TOKEN when output=AST but not rewrite alt */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRef(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** Match label+=TOKEN^ when output=AST but not rewrite alt */
-tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
+tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRefRuleRoot(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -105,20 +105,20 @@ tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
// rather than just added on code.  Investigate that refactoring when
// I have more time.

-matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+matchSet(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= <<
<super.matchSet(postmatchCode={<if(!ruleDescriptor.isSynPred)><if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);<endif>}, ...)>
>>

-matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+matchRuleBlockSet(s,label,elementIndex,postmatchCode,treeLevel="0",terminalOptions={}) ::= <<
<matchSet(...)>
>>

-matchSetBang(s,label,elementIndex,terminalOptions,postmatchCode) ::= "<super.matchSet(...)>"
+matchSetBang(s,label,elementIndex,postmatchCode,terminalOptions={}) ::= "<super.matchSet(...)>"

// note there is no matchSetTrack because -> rewrites force sets to be
// plain old blocks of alts: (A|B|...|C)

-matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+matchSetRuleRoot(s,label,elementIndex,debug,terminalOptions={}) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);
<endif>
@@ -164,7 +164,7 @@ ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<

// WILDCARD AST

-wildcard(token,label,elementIndex,terminalOptions) ::= <<
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
<super.wildcard(...)>
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
@@ -174,9 +174,9 @@ adaptor.AddChild(root_0, <label>_tree);
<endif>
>>

-wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"
+wildcardBang(label,elementIndex) ::= "<super.wildcard(token=[],...)>"

-wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+wildcardRuleRoot(token,label,elementIndex,terminalOptions={}) ::= <<
<super.wildcard(...)>
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
@@ -186,7 +186,7 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
<endif>
>>

-createNodeFromToken(label,terminalOptions) ::= <%
+createNodeFromToken(label,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<else>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTTreeParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTTreeParser.stg
index 676ba00..c5529b2 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTTreeParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/ASTTreeParser.stg
@@ -54,13 +54,13 @@ ruleDeclarations() ::= <<
/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
-noRewrite(rewriteBlockLevel, treeLevel) ::= <<
+noRewrite(rewriteBlockLevel=false, treeLevel=false) ::= <<
<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(rewriteMode)>
retval.Tree = (<ASTLabelType>)_first_0;
if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
-    retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
+	retval.Tree = (<ASTLabelType>)adaptor.GetParent(retval.Tree);
<endif>
<if(backtracking)>}<endif>
<endif>
@@ -91,9 +91,9 @@ if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.
<actionsAfterRoot:element()>
<if(nullableChildList)>
if (input.LA(1) == TokenTypes.Down) {
-    Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
-    <children:element()>
-    Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
+	Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
+	<children:element()>
+	Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
}
<else>
Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
index 2a3c918..c9229e1 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
@@ -98,7 +98,7 @@ lexerInputStreamType() ::= <<
>>

lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
-      superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>},
+	  superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>},
rewriteElementType={}, ASTLabelType={}) ::= <<
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
[System.CLSCompliant(false)]
@@ -108,13 +108,13 @@ lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="Com
<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<actions.lexer.members>

-    // delegates
-    <grammar.delegates:
-         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    // delegators
-    <grammar.delegators:
-         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    <last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+	// delegates
+	<grammar.delegates:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	// delegators
+	<grammar.delegators:
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>

<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
{
@@ -193,7 +193,7 @@ lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="Com
<cyclicDFAs:{dfa | dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this<if(dfa.specialStateSTs)>, SpecialStateTransition<dfa.decisionNumber><endif>);}; separator="\n">
}

-	<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
+	<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
#endregion

}
@@ -336,7 +336,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
appear to be defined in this recognizer. !>
#region Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)<!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<if(ruleDescriptor.parameterScope)><ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", "><endif>); \}}; separator="\n">
#endregion Delegated rules
<endif>

@@ -566,7 +566,7 @@ partial void LeaveRule_<ruleName>();
{
ReportError(re);
Recover(input,re);
-	<@setErrorReturnValue()>
+		<@setErrorReturnValue()>
}
<endif>
<endif>
@@ -609,7 +609,7 @@ ruleDeclarations() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>(<if(ruleDescriptor.returnScope.attributes)>this<endif>);
retval.Start = (<labelType>)input.LT(1);
-<else>
+<elseif(ruleDescriptor.returnScope)>
<ruleDescriptor.returnScope.attributes:{ a |
<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
}>
@@ -631,13 +631,13 @@ ruleScopeCleanUp() ::= <<

ruleLabelDefs(ruleDescriptor, labelType, ASTLabelType, rewriteElementType) ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+	:{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
>
<ruleDescriptor.tokenListLabels
-    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+	:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
>
<[ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
+	:{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
>
<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
<ruleDescriptor.ruleListLabels:ruleLabelDef(); separator="\n">
@@ -647,7 +647,7 @@ lexerRuleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,
ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleLabels]
-    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+	:{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
>
<[ruleDescriptor.charListLabels,
ruleDescriptor.charLabels]
@@ -655,9 +655,9 @@ lexerRuleLabelDefs() ::= <<
>
<[ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleListLabels]
-    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+	:{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
>
-<ruleDescriptor.charListLabels:{it|List\<int\> list_<it.label.text> = null;}; separator="\n"
+<ruleDescriptor.charListLabels:{it|List\<int> list_<it.label.text> = null;}; separator="\n"
>
>>

@@ -924,12 +924,12 @@ DebugLocation(<it.line>, <it.pos>);<\n>
%>

/** match a token optionally with a label in front */
-tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+tokenRef(token,label,elementIndex,terminalOptions={}) ::= <<
<if(label)><label>=(<labelType>)<endif>Match(input,<token>,Follow._<token>_in_<ruleName><elementIndex>); <checkRuleBacktrackFailure()>
>>

/** ids+=ID */
-tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+tokenRefAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<tokenRef(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -960,7 +960,7 @@ MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,terminalOptions,elementIndex,postmatchCode="") ::= <<
+matchSet(s,label,elementIndex,postmatchCode="",terminalOptions={}) ::= <<
<if(label)>
<matchSetLabel()>
<endif>
@@ -1029,14 +1029,14 @@ Match(<string>); <checkRuleBacktrackFailure()><\n>
<endif>
%>

-wildcard(token,label,elementIndex,terminalOptions) ::= <<
+wildcard(token,label,elementIndex,terminalOptions={}) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
MatchAny(input); <checkRuleBacktrackFailure()>
>>

-wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+wildcardAndListLabel(token,label,elementIndex,terminalOptions={}) ::= <<
<wildcard(...)>
<listLabelElem(elem=label,elemType=labelType,...)>
>>
@@ -1460,6 +1460,7 @@ setTest(ranges) ::= <<
// A T T R I B U T E S

attributeScope(scope) ::= <<
+<if(scope)>
<if(scope.attributes)>
protected sealed partial class <scope.name>_scope
{
@@ -1484,7 +1485,8 @@ protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
<else>
partial void <scope.name>_scopeAfter( <scope.name>_scope scope );
<endif>
-protected readonly ListStack\<<scope.name>_scope\> <scope.name>_stack = new ListStack\<<scope.name>_scope\>();
+protected readonly ListStack\<<scope.name>_scope> <scope.name>_stack = new ListStack\<<scope.name>_scope>();
+<endif>
<endif>
>>

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/Dbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/Dbg.stg
index c16a848..c250e44 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/Dbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/Dbg.stg
@@ -48,21 +48,21 @@ public static readonly string[] ruleNames =
};<\n>
<endif>
<if(grammar.grammarIsRoot)><! grammar imports other grammar(s) !>
-	int ruleLevel = 0;
-	public virtual int RuleLevel { get { return ruleLevel; } }
-	public virtual void IncRuleLevel() { ruleLevel++; }
-	public virtual void DecRuleLevel() { ruleLevel--; }
+int ruleLevel = 0;
+public virtual int RuleLevel { get { return ruleLevel; } }
+public virtual void IncRuleLevel() { ruleLevel++; }
+public virtual void DecRuleLevel() { ruleLevel--; }
<if(profile)>
-	<ctorForProfilingRootGrammar()>
+<ctorForProfilingRootGrammar()>
<else>
-	<ctorForRootGrammar()>
+<ctorForRootGrammar()>
<endif>
<ctorForPredefinedListener()>
<else><! imported grammar !>
-	public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
-	public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
-	public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
-	<ctorForDelegateGrammar()>
+public int RuleLevel { get { return <grammar.delegators:{g| <g:delegateName()>}>.RuleLevel; } }
+public void IncRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.IncRuleLevel(); }
+public void DecRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.DecRuleLevel(); }
+<ctorForDelegateGrammar()>
<endif>
<if(profile)>
public override bool AlreadyParsedRule( IIntStream input, int ruleIndex )

