commit 8a1bf95c4cd3f65f24ca0ec3b1ce133114a8ecad
Author:     Zannick <jokeserver@gmail.com>
AuthorDate: Mon Jun 25 00:28:03 2012 -0700
Commit:     Zannick <jokeserver@gmail.com>
CommitDate: Mon Jun 25 00:59:09 2012 -0700

Let token.typeName return the actual token name.

- Fix the circular parser dependency by giving each parser tokenNames.
- Give each recognizer a tokenNamesMap mapping token type to token name.
(I would have done just tokenNames, but the lexer apparently doesn't
receive anything for it.)
- Give the Token class a registerTokenNamesMap function so that all
tokens can look up a reference to the names map in order to give a
proper token type name when requested.

diff --git a/runtime/Python3/antlr3/tokens.py b/runtime/Python3/antlr3/tokens.py
index fcc2371..a2bd169 100644
--- a/runtime/Python3/antlr3/tokens.py
+++ b/runtime/Python3/antlr3/tokens.py
@@ -41,6 +41,18 @@ from .constants import DEFAULT_CHANNEL, EOF, INVALID_TOKEN_TYPE
class Token(object):
"""@brief Abstract token baseclass."""

+    TOKEN_NAMES_MAP = None
+
+    @classmethod
+    def registerTokenNamesMap(cls, tokenNamesMap):
+        """@brief Store a mapping from token type to token name.
+
+        This enables token.typeName to give something more meaningful
+        than, e.g., '6'.
+        """
+        cls.TOKEN_NAMES_MAP = tokenNamesMap
+        cls.TOKEN_NAMES_MAP[EOF] = "EOF"
+
def __init__(self, type=None, channel=DEFAULT_CHANNEL, text=None,
index=-1, line=0, charPositionInLine=-1, input=None):
# We use -1 for index and charPositionInLine as an invalid index
@@ -74,6 +86,12 @@ class Token(object):
def getType(self):
return self._type

+    @property
+    def typeName(self):
+        if self.TOKEN_NAMES_MAP:
+            return self.TOKEN_NAMES_MAP.get(self._type, "INVALID_TOKEN_TYPE")
+        else:
+            return str(self._type)

@property
def line(self):
@@ -208,11 +226,6 @@ class CommonToken(Token):
self._text = value


-    @property
-    def typeName(self):
-        return str(self.type)
-
-
def getInputStream(self):
return self.input

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Python3/Python3.stg b/tool/src/main/resources/org/antlr/codegen/templates/Python3/Python3.stg
index bb5f8fe..108e2c9 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Python3/Python3.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Python3/Python3.stg
@@ -62,6 +62,13 @@ HIDDEN = BaseRecognizer.HIDDEN
# token types
<tokens:{it | <it.name>=<it.type>}; separator="\n">

+# token names
+tokenNamesMap = {
+    0: "\<invalid>", 1: "\<EOR>", 2: "\<DOWN>", 3: "\<UP>",
+    <tokens:{it | <it.type>: "<it.name>"}; wrap, separator=", ">
+}
+Token.registerTokenNamesMap(tokenNamesMap)
+
<recognizer>

<if(actions.(actionScope).main)>
@@ -218,20 +225,13 @@ filteringActionGate() ::= "self._state.backtracking == 1"
genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
bitsets, inputStreamType, superClass, labelType, members,
rewriteElementType, filterMode, init, ASTLabelType="Object") ::= <<
-<if(grammar.grammarIsRoot)>
# token names
tokenNames = [
"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>",
<tokenNames; wrap, separator=", ">
-]<\n>
-<else>
-from <grammar.composite.rootGrammar.recognizerName> import tokenNames<\n>
-<endif>
-<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScopeClass(scope=it)><endif>}>
+]

-<! I just want to say this is an awful hack. The delegates' grammars need to
-   import tokenNames from us, and it works despite the circular dependency
-   because we define it before we import them. !>
+<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScopeClass(scope=it)><endif>}>

<if(grammar.directDelegates)>
if __name__ == "__main__":

