commit 8dbf57c2d5de01eb956443b2c10e8a2516bc9bff
Author:     parrt <parrt@antlr.org>
AuthorDate: Fri Nov 25 09:50:12 2011 -0800
Commit:     parrt <parrt@antlr.org>
CommitDate: Fri Nov 25 09:50:12 2011 -0800

stderr not test correctly in gunit examineExecResult

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 9450]

diff --git a/gunit/src/main/java/org/antlr/gunit/gUnitBaseTest.java b/gunit/src/main/java/org/antlr/gunit/gUnitBaseTest.java
index bf089c3..7656324 100644
--- a/gunit/src/main/java/org/antlr/gunit/gUnitBaseTest.java
+++ b/gunit/src/main/java/org/antlr/gunit/gUnitBaseTest.java
@@ -29,37 +29,30 @@ package org.antlr.gunit;

import junit.framework.TestCase;
import org.antlr.runtime.*;
-import org.antlr.runtime.tree.CommonTree;
-import org.antlr.runtime.tree.CommonTreeNodeStream;
-import org.antlr.runtime.tree.TreeAdaptor;
-import org.antlr.runtime.tree.TreeNodeStream;
+import org.antlr.runtime.tree.*;
import org.antlr.stringtemplate.StringTemplate;

-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.PrintStream;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
+import java.io.*;
+import java.lang.reflect.*;

-/** All gUnit-generated JUnit class should extend this class
+/** All gUnit-generated JUnit class should extend this class
*  which implements the essential methods for triggering
*  ANTLR parser/tree walker
*/
public abstract class gUnitBaseTest extends TestCase {
-
+
public String treeAdaptorPath;
public String packagePath;
public String lexerPath;
public String parserPath;
public String treeParserPath;
-
+
protected String stdout;
protected String stderr;
-
+
private PrintStream console = System.out;
private PrintStream consoleErr = System.err;
-
+
// Invoke target lexer.rule
public String execLexer(String testRuleName, int line, String testInput, boolean isFile) throws Exception {
CharStream input;
@@ -84,13 +77,13 @@ public abstract class gUnitBaseTest extends TestCase {
/** Use Reflection to create instances of lexer and parser */
lexer = Class.forName(lexerPath);
Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
-            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
-            Lexer lexObj = (Lexer)lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
+            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
+            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
+            Lexer lexObj = (Lexer)lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
input.setLine(line);

Method ruleName = lexer.getMethod("m"+testRuleName, new Class[0]);
-
+
/** Start of I/O Redirecting */
ByteArrayOutputStream out = new ByteArrayOutputStream();
ByteArrayOutputStream err = new ByteArrayOutputStream();
@@ -107,10 +100,10 @@ public abstract class gUnitBaseTest extends TestCase {
if ( currentIndex!=input.size() ) {
ps2.println("extra text found, '"+input.substring(currentIndex, input.size()-1)+"'");
}
-
+
this.stdout = null;
this.stderr = null;
-
+
if ( err.toString().length()>0 ) {
this.stderr = err.toString();
return this.stderr;
@@ -149,9 +142,9 @@ public abstract class gUnitBaseTest extends TestCase {
}
return this.stdout;
}
-
+
// Invoke target parser.rule
-
+
public Object execParser(String testRuleName, int line, String testInput, boolean isFile) throws Exception {
CharStream input;
/** Set up ANTLR input stream based on input source, file or String */
@@ -179,7 +172,7 @@ public abstract class gUnitBaseTest extends TestCase {
lexer = Class.forName(lexerPath);
Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
+            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
Lexer lexObj = (Lexer)lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
input.setLine(line);

@@ -187,9 +180,9 @@ public abstract class gUnitBaseTest extends TestCase {
parser = Class.forName(parserPath);
Class[] parArgTypes = new Class[]{TokenStream.class};				// assign type to parser's args
Constructor parConstructor = parser.getConstructor(parArgTypes);
-            Object[] parArgs = new Object[]{tokens};							// assign value to parser's args
+            Object[] parArgs = new Object[]{tokens};							// assign value to parser's args
Parser parObj = (Parser)parConstructor.newInstance(parArgs);				// makes new instance of parser
-
+
// set up customized tree adaptor if necessary
if ( treeAdaptorPath!=null ) {
parArgTypes = new Class[]{TreeAdaptor.class};
@@ -240,13 +233,13 @@ public abstract class gUnitBaseTest extends TestCase {

this.stdout = "";
this.stderr = "";
-
+
/** Invalid input */
if ( tokens.index()!=tokens.size()-1 ) {
//throw new InvalidInputException();
this.stderr += "Stopped parsing at token index "+tokens.index()+": ";
}
-
+
// retVal could be actual return object from rule, stderr or stdout
this.stdout += out.toString();
this.stderr += err.toString();
@@ -297,7 +290,7 @@ public abstract class gUnitBaseTest extends TestCase {
}
return this.stdout;
}
-
+
// Invoke target parser.rule
public Object execTreeParser(String testTreeRuleName, String testRuleName, String testInput, boolean isFile) throws Exception {
CharStream input;
@@ -323,20 +316,20 @@ public abstract class gUnitBaseTest extends TestCase {
/** Use Reflection to create instances of lexer and parser */
lexer = Class.forName(lexerPath);
Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
-            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
-            Object lexObj = lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
-
+            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
+            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
+            Object lexObj = lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
+
CommonTokenStream tokens = new CommonTokenStream((Lexer) lexObj);
-
+
parser = Class.forName(parserPath);
Class[] parArgTypes = new Class[]{TokenStream.class};				// assign type to parser's args
Constructor parConstructor = parser.getConstructor(parArgTypes);
-            Object[] parArgs = new Object[]{tokens};							// assign value to parser's args
-            Object parObj = parConstructor.newInstance(parArgs);				// makes new instance of parser
-
+            Object[] parArgs = new Object[]{tokens};							// assign value to parser's args
+            Object parObj = parConstructor.newInstance(parArgs);				// makes new instance of parser
+
// set up customized tree adaptor if necessary
-            TreeAdaptor customTreeAdaptor = null;
+            TreeAdaptor customTreeAdaptor = null;
if ( treeAdaptorPath!=null ) {
parArgTypes = new Class[]{TreeAdaptor.class};
Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", parArgTypes);
@@ -344,7 +337,7 @@ public abstract class gUnitBaseTest extends TestCase {
customTreeAdaptor = (TreeAdaptor) _treeAdaptor.newInstance();
_setTreeAdaptor.invoke(parObj, customTreeAdaptor);
}
-
+
Method ruleName = parser.getMethod(testRuleName);

/** Start of I/O Redirecting */
@@ -358,8 +351,8 @@ public abstract class gUnitBaseTest extends TestCase {

/** Invoke grammar rule, and get the return value */
Object ruleReturn = ruleName.invoke(parObj);
-
-            Class _return = Class.forName(parserPath+"$"+testRuleName+"_return");
+
+            Class _return = Class.forName(parserPath+"$"+testRuleName+"_return");
Method returnName = _return.getMethod("getTree");
CommonTree tree = (CommonTree) returnName.invoke(ruleReturn);

@@ -377,12 +370,12 @@ public abstract class gUnitBaseTest extends TestCase {
treeParser = Class.forName(treeParserPath);
Class[] treeParArgTypes = new Class[]{TreeNodeStream.class};		// assign type to tree parser's args
Constructor treeParConstructor = treeParser.getConstructor(treeParArgTypes);
-            Object[] treeParArgs = new Object[]{nodes};							// assign value to tree parser's args
-            Object treeParObj = treeParConstructor.newInstance(treeParArgs);	// makes new instance of tree parser
+            Object[] treeParArgs = new Object[]{nodes};							// assign value to tree parser's args
+            Object treeParObj = treeParConstructor.newInstance(treeParArgs);	// makes new instance of tree parser
// Invoke the tree rule, and store the return value if there is
Method treeRuleName = treeParser.getMethod(testTreeRuleName);
Object treeRuleReturn = treeRuleName.invoke(treeParObj);
-
+
String astString = null;
String stString = null;
/** If tree rule has return value, determine if it contains an AST or a ST */
@@ -412,12 +405,12 @@ public abstract class gUnitBaseTest extends TestCase {

this.stdout = null;
this.stderr = null;
-
+
/** Invalid input */
if ( tokens.index()!=tokens.size()-1 ) {
throw new InvalidInputException();
}
-
+
// retVal could be actual return object from rule, stderr or stdout
if ( err.toString().length()>0 ) {
this.stderr = err.toString();
@@ -462,11 +455,13 @@ public abstract class gUnitBaseTest extends TestCase {
}
return stdout;
}
-
+
// Modify the return value if the expected token type is OK or FAIL
-	public Object examineExecResult(int tokenType, Object retVal) {
+	public Object examineExecResult(int tokenType, Object retVal) {
+		System.out.println("expect "+(tokenType==gUnitParser.OK?"OK":"FAIL")+
+						   "stderr=="+stderr);
if ( tokenType==gUnitParser.OK ) {	// expected Token: OK
-			if ( this.stderr==null ) {
+			if ( this.stderr==null || this.stderr.length()==0 ) {
return "OK";
}
else {
@@ -474,7 +469,7 @@ public abstract class gUnitBaseTest extends TestCase {
}
}
else if ( tokenType==gUnitParser.FAIL ) {	// expected Token: FAIL
-			if ( this.stderr!=null ) {
+			if ( this.stderr!=null && this.stderr.length()>0 ) {
return "FAIL";
}
else {
@@ -483,7 +478,7 @@ public abstract class gUnitBaseTest extends TestCase {
}
else {	// return the same object for the other token types
return retVal;
-		}
+		}
}
-
+
}
diff --git a/tool/CHANGES.txt b/tool/CHANGES.txt
index 73162b6..5be534c 100644
--- a/tool/CHANGES.txt
+++ b/tool/CHANGES.txt
@@ -7,6 +7,10 @@ University of San Francisco

CHANGES

+November 25, 2011
+
+* stderr not test correctly in gunit examineExecResult
+
October 25, 2011

* (Sam) Rule.setOption didn't do memoize option right.

