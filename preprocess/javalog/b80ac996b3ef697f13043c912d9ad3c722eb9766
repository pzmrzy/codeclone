commit b80ac996b3ef697f13043c912d9ad3c722eb9766
Author:     parrt <parrt@antlr.org>
AuthorDate: Tue Mar 29 10:12:59 2011 -0800
Commit:     parrt <parrt@antlr.org>
CommitDate: Tue Mar 29 10:12:59 2011 -0800

rm v2 stuff

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 7954]

diff --git a/tool/src/main/antlr2/org/antlr/grammar/v2/antlr.g b/tool/src/main/antlr2/org/antlr/grammar/v2/antlr.g
deleted file mode 100644
index 8dfded7..0000000
--- a/tool/src/main/antlr2/org/antlr/grammar/v2/antlr.g
+++ /dev/null
@@ -1,1348 +0,0 @@
-header {
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-package org.antlr.grammar.v2;
-import java.util.*;
-import java.io.*;
-import org.antlr.analysis.*;
-import org.antlr.misc.*;
-import org.antlr.tool.*;
-
-import antlr.TokenBuffer;
-import antlr.TokenStreamException;
-import antlr.Token;
-import antlr.TokenStream;
-import antlr.RecognitionException;
-import antlr.NoViableAltException;
-import antlr.ParserSharedInputState;
-import antlr.collections.impl.BitSet;
-import antlr.collections.AST;
-import antlr.collections.ASTEnumeration;
-import antlr.ASTFactory;
-import antlr.ASTPair;
-import antlr.TokenWithIndex;
-import antlr.TokenStreamRewriteEngine;
-import antlr.collections.impl.ASTArray;
-}
-
-/** Read in an ANTLR grammar and build an AST.  Try not to do
- *  any actions, just build the tree.
- *
- *  The phases are:
- *
- *		antlr.g (this file)
- *		assign.types.g
- *		define.g
- *		buildnfa.g
- *		antlr.print.g (optional)
- *		codegen.g
- *
- *  Terence Parr
- *  University of San Francisco
- *  2005
- */
-class ANTLRParser extends Parser;
-options {
-    buildAST = true;
-	exportVocab=ANTLR;
-    ASTLabelType="GrammarAST";
-	k=3;
-}
-
-tokens {
-	OPTIONS="options";
-	TOKENS="tokens";
-	PARSER="parser";
-
-    LEXER;
-    RULE;
-    PREC_RULE;
-    RECURSIVE_RULE_REF; // flip recursive RULE_REF to RECURSIVE_RULE_REF in prec rules
-    BLOCK;
-    OPTIONAL;
-    CLOSURE;
-    POSITIVE_CLOSURE;
-    SYNPRED;
-    RANGE;
-    CHAR_RANGE;
-    EPSILON;
-    ALT;
-    EOR;
-    EOB;
-    EOA; // end of alt
-    ID;
-    ARG;
-    ARGLIST;
-    RET;
-    LEXER_GRAMMAR;
-    PARSER_GRAMMAR;
-    TREE_GRAMMAR;
-    COMBINED_GRAMMAR;
-    INITACTION;
-    FORCED_ACTION; // {{...}} always exec even during syn preds
-    LABEL; // $x used in rewrite rules
-    TEMPLATE;
-    SCOPE="scope";
-    IMPORT="import";
-    GATED_SEMPRED; // {p}? =>
-    SYN_SEMPRED; // (...) =>   it's a manually-specified synpred converted to sempred
-    BACKTRACK_SEMPRED; // auto backtracking mode syn pred converted to sempred
-    FRAGMENT="fragment";
-    DOT;
-    REWRITES;
-}
-
-{
-	protected Grammar grammar = null;
-	protected int gtype = 0;
-
-    public Grammar getGrammar() {
-        return grammar;
-    }
-
-    public void setGrammar(Grammar grammar) {
-        this.grammar = grammar;
-    }
-
-    public int getGtype() {
-        return gtype;
-    }
-
-    public void setGtype(int gtype) {
-        this.gtype = gtype;
-        }
-
-    protected String currentRuleName = null;
-	protected GrammarAST currentBlockAST = null;
-	protected boolean atTreeRoot; // are we matching a tree root in tree grammar?
-
-	protected GrammarAST setToBlockWithSet(GrammarAST b) {
-		GrammarAST alt = #(#[ALT,"ALT"],#b,#[EOA,"<end-of-alt>"]);
-		prefixWithSynPred(alt);
-		return #(#[BLOCK,"BLOCK"],
-		           alt,
-		           #[EOB,"<end-of-block>"]
-		        );
-	}
-
-	/** Create a copy of the alt and make it into a BLOCK; all actions,
-	 *  labels, tree operators, rewrites are removed.
-	 */
-	protected GrammarAST createBlockFromDupAlt(GrammarAST alt) {
-		GrammarAST nalt = GrammarAST.dupTreeNoActions(alt, null);
-		GrammarAST blk = #(#[BLOCK,"BLOCK"],
-						   nalt,
-						   #[EOB,"<end-of-block>"]
-						  );
-		return blk;
-	}
-
-	/** Rewrite alt to have a synpred as first element;
-	 *  (xxx)=>xxx
-	 *  but only if they didn't specify one manually.
-	 */
-	protected void prefixWithSynPred(GrammarAST alt) {
-		// if they want backtracking and it's not a lexer rule in combined grammar
-		String autoBacktrack = (String)grammar.getBlockOption(currentBlockAST, "backtrack");
-		if ( autoBacktrack==null ) {
-			autoBacktrack = (String)grammar.getOption("backtrack");
-		}
-		if ( autoBacktrack!=null&&autoBacktrack.equals("true") &&
-			 !(gtype==COMBINED_GRAMMAR &&
-			 Character.isUpperCase(currentRuleName.charAt(0))) &&
-			 alt.getFirstChild().getType()!=SYN_SEMPRED )
-		{
-			// duplicate alt and make a synpred block around that dup'd alt
-			GrammarAST synpredBlockAST = createBlockFromDupAlt(alt);
-
-			// Create a BACKTRACK_SEMPRED node as if user had typed this in
-			// Effectively we replace (xxx)=>xxx with {synpredxxx}? xxx
-			GrammarAST synpredAST = createSynSemPredFromBlock(synpredBlockAST,
-															  BACKTRACK_SEMPRED);
-
-			// insert BACKTRACK_SEMPRED as first element of alt
-			synpredAST.getLastSibling().setNextSibling(alt.getFirstChild());
-			alt.setFirstChild(synpredAST);
-		}
-	}
-
-	protected GrammarAST createSynSemPredFromBlock(GrammarAST synpredBlockAST,
-												   int synpredTokenType)
-	{
-		// add grammar fragment to a list so we can make fake rules for them
-		// later.
-		String predName = grammar.defineSyntacticPredicate(synpredBlockAST,currentRuleName);
-		// convert (alpha)=> into {synpredN}? where N is some pred count
-		// during code gen we convert to function call with templates
-		String synpredinvoke = predName;
-		GrammarAST p = #[synpredTokenType,synpredinvoke];
-		// track how many decisions have synpreds
-		grammar.blocksWithSynPreds.add(currentBlockAST);
-		return p;
-	}
-
-	public static GrammarAST createSimpleRuleAST(String name,
-												  GrammarAST block,
-												  boolean fragment)
-   {
-		ASTFactory astFactory =
-			new ASTFactory() {
-				{
-					setASTNodeClass(GrammarAST.class);
-					setASTNodeClass("org.antlr.tool.GrammarAST");
-				}
-			};
-   		GrammarAST modifier = null;
-   		if ( fragment ) {
-   			modifier = #[FRAGMENT,"fragment"];
-   		}
-   		GrammarAST EORAST = #[EOR,"<end-of-rule>"];
-   		GrammarAST EOBAST = block.getLastChild();
-		EORAST.setLine(EOBAST.getLine());
-		EORAST.setColumn(EOBAST.getColumn());
-		GrammarAST ruleAST =
-		   #([RULE,"rule"],
-                 [ID,name],modifier,[ARG,"ARG"],[RET,"RET"],
-				 [SCOPE,"scope"],block,EORAST);
-		ruleAST.setLine(block.getLine());
-		ruleAST.setColumn(block.getColumn());
-		return ruleAST;
-	}
-
-    public void reportError(RecognitionException ex) {
-		Token token = null;
-		try {
-			token = LT(1);
-		}
-		catch (TokenStreamException tse) {
-			ErrorManager.internalError("can't get token???", tse);
-		}
-		ErrorManager.syntaxError(
-			ErrorManager.MSG_SYNTAX_ERROR,
-			grammar,
-			token,
-			"antlr: "+ex.toString(),
-			ex);
-    }
-
-    public void cleanup(GrammarAST root) {
-		if ( gtype==LEXER_GRAMMAR ) {
-			String filter = (String)grammar.getOption("filter");
-			GrammarAST tokensRuleAST =
-			    grammar.addArtificialMatchTokensRule(
-			    	root,
-			    	grammar.lexerRuleNamesInCombined,
-                    grammar.getDelegateNames(),
-			    	filter!=null&&filter.equals("true"));
-		}
-    }
-}
-
-grammar![Grammar g]
-{
-	this.grammar = g;
-	GrammarAST opt=null;
-	Token optionsStartToken = null;
-	Map opts;
-	// set to factory that sets enclosing rule
-	astFactory = new ASTFactory() {
-		{
-			setASTNodeClass(GrammarAST.class);
-			setASTNodeClass("org.antlr.tool.GrammarAST");
-		}
-		public AST create(Token token) {
-			AST t = super.create(token);
-			((GrammarAST)t).enclosingRuleName = currentRuleName;
-			return t;
-		}
-		public AST create(int i) {
-			AST t = super.create(i);
-			((GrammarAST)t).enclosingRuleName = currentRuleName;
-			return t;
-		}
-	};
-}
-   :    //hdr:headerSpec
-        ( ACTION )?
-	    ( cmt:DOC_COMMENT  )?
-        gr:grammarType gid:id {grammar.setName(#gid.getText());} SEMI
-			( {optionsStartToken=LT(1);}
-			  opts=optionsSpec {grammar.setOptions(opts, optionsStartToken);}
-			  {opt=(GrammarAST)returnAST;}
-			)?
-            (ig:delegateGrammars)?
-		    (ts:tokensSpec!)?
-        	scopes:attrScopes
-		    (a:actions)?
-	        r:rules
-        EOF
-        {
-        #grammar = #(null, #(#gr, #gid, #cmt, opt, #ig, #ts, #scopes, #a, #r));
-        cleanup(#grammar);
-        }
-	;
-
-grammarType
-    :   (	"lexer"!  {gtype=LEXER_GRAMMAR; grammar.type = Grammar.LEXER;}       // pure lexer
-    	|   "parser"! {gtype=PARSER_GRAMMAR; grammar.type = Grammar.PARSER;}     // pure parser
-    	|   "tree"!   {gtype=TREE_GRAMMAR; grammar.type = Grammar.TREE_PARSER;}  // a tree parser
-    	|			  {gtype=COMBINED_GRAMMAR; grammar.type = Grammar.COMBINED;} // merged parser/lexer
-    	)
-    	gr:"grammar" {#gr.setType(gtype);}
-    ;
-
-actions
-	:	(action)+
-	;
-
-/** Match stuff like @parser::members {int i;} */
-action
-	:	AMPERSAND^ (actionScopeName COLON! COLON!)? id ACTION
-	;
-
-/** Sometimes the scope names will collide with keywords; allow them as
- *  ids for action scopes.
- */
-actionScopeName
-	:	id
-	|	l:"lexer"	{#l.setType(ID);}
-    |   p:"parser"	{#p.setType(ID);}
-	;
-
-optionsSpec returns [Map opts=new HashMap()]
-	:	OPTIONS^ (option[opts] SEMI!)+ RCURLY!
-	;
-
-option[Map opts]
-{
-    Object value=null;
-}
-    :   o:id ASSIGN^ value=optionValue
-    	{
-    	opts.put(#o.getText(), value);
-    	}
-    ;
-
-optionValue returns [Object value=null]
-    :   x:id			 {value = #x.getText();}
-    |   s:STRING_LITERAL {String vs = #s.getText();
-                          value=vs.substring(1,vs.length()-1);}
-    |   c:CHAR_LITERAL   {String vs = #c.getText();
-                          value=vs.substring(1,vs.length()-1);}
-    |   i:INT            {value = new Integer(#i.getText());}
-    |	ss:STAR			 {#ss.setType(STRING_LITERAL); value = "*";} // used for k=*
-//  |   cs:charSet       {value = #cs;} // return set AST in this case
-    ;
-
-delegateGrammars
-    :   "import"^ delegateGrammar (COMMA! delegateGrammar)* SEMI!
-    ;
-
-delegateGrammar
-    :   lab:id ASSIGN^ g:id {grammar.importGrammar(#g, #lab.getText());}
-    |   g2:id               {grammar.importGrammar(#g2,null);}
-    ;
-
-tokensSpec
-	:	TOKENS^
-			( tokenSpec	)+
-		RCURLY!
-	;
-
-tokenSpec
-	:	TOKEN_REF ( ASSIGN^ (STRING_LITERAL|CHAR_LITERAL) )? SEMI!
-	;
-
-attrScopes
-	:	(attrScope)*
-	;
-
-attrScope
-	:	"scope"^ id ACTION
-	;
-
-rules
-    :   (
-			options {
-				// limitation of appox LL(k) says ambig upon
-				// DOC_COMMENT TOKEN_REF, but that's an impossible sequence
-				warnWhenFollowAmbig=false;
-			}
-		:	//{g.type==PARSER}? (aliasLexerRule)=>aliasLexerRule |
-			rule
-		)+
-    ;
-
-rule!
-{
-GrammarAST modifier=null, blk=null, eob=null;
-int startLine = LT(1).getLine();
-GrammarAST opt = null;
-Map opts = null;
-TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:
-	(	d:DOC_COMMENT
-	)?
-	(	p1:"protected"	{modifier=#p1;}
-	|	p2:"public"		{modifier=#p2;}
-	|	p3:"private"    {modifier=#p3;}
-	|	p4:"fragment"	{modifier=#p4;}
-	)?
-	ruleName:id
-	{currentRuleName=#ruleName.getText();
-     if ( gtype==LEXER_GRAMMAR && #p4==null ) {
-         grammar.lexerRuleNamesInCombined.add(currentRuleName);
-	 }
-	}
-	( BANG )?
-	( aa:ARG_ACTION )?
-	( "returns" rt:ARG_ACTION  )?
-	( throwsSpec )?
-    ( opts=optionsSpec {opt=(GrammarAST)returnAST;} )?
-	scopes:ruleScopeSpec
-	(a:ruleActions)?
-	colon:COLON
-	{
-	eob = #[EOB,"<end-of-block>"];
-    }
-	b:ruleAltList[opts] {blk = #b;}
-	semi:SEMI
-	( ex:exceptionGroup )?
-    {
-    int stop = ((TokenWithIndex)LT(1)).getIndex()-1; // point at the semi or exception thingie
-	eob.setLine(semi.getLine());
-	eob.setColumn(semi.getColumn());
-    GrammarAST eor = #[EOR,"<end-of-rule>"];
-	eor.setLine(semi.getLine());
-	eor.setColumn(semi.getColumn());
-	GrammarAST root = #[RULE,"rule"];
-	root.setLine(startLine);
-	root.setBlockOptions(opts);
-    #rule = #(root,
-              #ruleName,modifier,#(#[ARG,"ARG"],#aa),#(#[RET,"RET"],#rt),
-              opt,#scopes,#a,blk,ex,eor);
-    #rule.setTreeEnclosingRuleNameDeeply(currentRuleName);
-	currentRuleName=null;
-    ##.setTokenBoundaries(start,LT(0));
-    }
-	;
-
-ruleActions
-	:	(ruleAction)+
-	;
-
-/** Match stuff like @init {int i;} */
-ruleAction
-	:	AMPERSAND^ id ACTION
-	;
-
-throwsSpec
-	:	"throws" id ( COMMA id )*
-
-	;
-
-ruleScopeSpec
-{
-int line = LT(1).getLine();
-int column = LT(1).getColumn();
-}
-	:!	( options {warnWhenFollowAmbig=false;} : "scope" a:ACTION )?
-		( "scope" ids:idList SEMI! )*
-		{
-		GrammarAST scopeRoot = (GrammarAST)#[SCOPE,"scope"];
-		scopeRoot.setLine(line);
-		scopeRoot.setColumn(column);
-		#ruleScopeSpec = #(scopeRoot, #a, #ids);
-		}
-	;
-
-ruleAltList[Map opts]
-{
-	GrammarAST blkRoot = #[BLOCK,"BLOCK"];
-	blkRoot.setBlockOptions(opts);
-	blkRoot.setLine(LT(0).getLine()); // set to : or (
-	blkRoot.setColumn(LT(0).getColumn());
-	GrammarAST save = currentBlockAST;
-	currentBlockAST = #blkRoot;
-	TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-    :   a1:alternative rewrite
-		{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred(#a1);}
-        (   ( OR! a2:alternative rewrite
-              {if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred(#a2);}
-            )+
-        |
-        )
-        {
-        #ruleAltList = #(blkRoot,#ruleAltList,#[EOB,"<end-of-block>"]);
-        currentBlockAST = save;
-        ##.setTokenBoundaries(start,LT(0));
-        }
-    ;
-
-/** Build #(BLOCK ( #(ALT ...) EOB )+ ) */
-block
-{
-GrammarAST save = currentBlockAST;
-Map opts=null;
-	TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-    :   lp:LPAREN^ {#lp.setType(BLOCK); #lp.setText("BLOCK");}
-		(
-			// 2nd alt and optional branch ambig due to
-			// linear approx LL(2) issue.  COLON ACTION
-			// matched correctly in 2nd alt.
-			options {
-				warnWhenFollowAmbig = false;
-			}
-		:
-            (opts=optionsSpec {#block.setOptions(grammar,opts);})?
-            ( ruleActions )?
-            COLON!
-		|	ACTION COLON!
-		)?
-
-		{currentBlockAST = #lp;}
-
-		a1:alternative rewrite
-		{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred(#a1);}
-		( OR! a2:alternative rewrite
-          {if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred(#a2);}
-        )*
-
-        rp:RPAREN!
-        {
-		currentBlockAST = save;
-        GrammarAST eob = #[EOB,"<end-of-block>"];
-        eob.setLine(rp.getLine());
-        eob.setColumn(rp.getColumn());
-        #block.addChild(eob);
-        ##.setTokenBoundaries(start,LT(0));
-        }
-    ;
-
-alternative
-{
-    // ALT and EOA have indexes tracking start/stop of entire alt
-    GrammarAST eoa = #[EOA, "<end-of-alt>"];
-    GrammarAST altRoot = #[ALT,"ALT"];
-    altRoot.token.setIndex(((TokenWithIndex)LT(1)).getIndex());
-    altRoot.setLine(LT(1).getLine());
-    altRoot.setColumn(LT(1).getColumn());
-    Token start=LT(1);
-}
-    :   (
-            ( el:element )+
-            {
-                if ( #alternative==null ) {
-                    #alternative = #(altRoot,#[EPSILON,"epsilon"],eoa);
-                }
-                else {
-                    // we have a real list of stuff
-                    #alternative = #(altRoot, #alternative, eoa);
-                }
-                eoa.token.setIndex(((TokenWithIndex)LT(0)).getIndex());
-            }
-        |   {
-            GrammarAST eps = #[EPSILON,"epsilon"];
-            eps.setLine(LT(0).getLine()); // get line/col of '|' or ':' (prev token)
-            eps.setColumn(LT(0).getColumn());
-            #alternative = #(altRoot,eps,eoa);
-            }
-        )
-        {##.setTokenBoundaries(start,LT(0));}
-    ;
-
-exceptionGroup
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-	:	(
-			( exceptionHandler )+ ( finallyClause )?
-		|	finallyClause
-		)
-        {##.setTokenBoundaries(start,LT(0));}
-    ;
-
-exceptionHandler
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-    :    "catch"^ ARG_ACTION ACTION
-        {##.setTokenBoundaries(start,LT(0));}
-    ;
-
-finallyClause
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-    :    "finally"^ ACTION
-        {##.setTokenBoundaries(start,LT(0));}
-    ;
-
-element
-	:	elementNoOptionSpec
-	;
-
-elementNoOptionSpec
-{
-    IntSet elements=null;
-    GrammarAST sub, sub2;
-	TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:	(	id (ASSIGN^|PLUS_ASSIGN^) (atom|block)
-			( sub=ebnfSuffix[(GrammarAST)currentAST.root,false]! {#elementNoOptionSpec=sub;} )?
-		|   atom
-			( sub2=ebnfSuffix[(GrammarAST)currentAST.root,false]! {#elementNoOptionSpec=sub2;} )?
-		|	ebnf
-		|   FORCED_ACTION
-		|   ACTION
-		|   p:SEMPRED ( IMPLIES! {#p.setType(GATED_SEMPRED);} )?
-			{
-			grammar.blocksWithSemPreds.add(currentBlockAST);
-			}
-		|   t3:tree
-		)
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-atom
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-    :   (
-			range (ROOT^|BANG^)?
-		|   (   options {
-				// TOKEN_REF WILDCARD could match terminal here then WILDCARD next
-				generateAmbigWarnings=false;
-			}
-			:   // grammar.rule but ensure no spaces. "A . B" is not a qualified ref
-				// We do here rather than lexer so we can build a tree
-				{LT(1).getColumn()+LT(1).getText().length()==LT(2).getColumn()&&
-				 LT(2).getColumn()+1==LT(3).getColumn()}?
-				id w:WILDCARD^ (terminal|ruleref) {#w.setType(DOT);}
-			|   terminal
-			|   ruleref
-			)
-		|	notSet (ROOT^|BANG^)?
-		)
-        {##.setTokenBoundaries(start,LT(0));}
-    ;
-
-ruleref
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-    :   rr:RULE_REF^ ( ARG_ACTION )? (ROOT^|BANG^)?
-        {##.setTokenBoundaries(start,LT(0));}
-    ;
-
-notSet
-{
-    int line = LT(1).getLine();
-    int col = LT(1).getColumn();
-    GrammarAST subrule=null;
-	TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:	n:NOT^
-		(	notTerminal
-        |   block
-		)
-        {#notSet.setLine(line); #notSet.setColumn(col);}
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-treeRoot
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-    :   {atTreeRoot=true;}
-        (   id (ASSIGN^|PLUS_ASSIGN^) (atom|block)
-	    |   atom
-	    |   block
-	    )
-        {atTreeRoot=false;}
-        {##.setTokenBoundaries(start,LT(0));}
-    ;
-
-tree:   TREE_BEGIN^ treeRoot ( element )+ RPAREN! ;
-
-/** matches ENBF blocks (and sets via block rule) */
-ebnf!
-{
-    int line = LT(1).getLine();
-    int col = LT(1).getColumn();
-	TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:	b:block
-		(	QUESTION    {#ebnf=#([OPTIONAL,"?"],#b);}
-		|	STAR	    {#ebnf=#([CLOSURE,"*"],#b);}
-		|	PLUS	    {#ebnf=#([POSITIVE_CLOSURE,"+"],#b);}
-		|   IMPLIES! // syntactic predicate
-			{
-			if ( gtype==COMBINED_GRAMMAR &&
-			     Character.isUpperCase(currentRuleName.charAt(0)) )
-		    {
-                // ignore for lexer rules in combined
-		    	#ebnf = #(#[SYNPRED,"=>"],#b);
-		    }
-		    else {
-		    	// create manually specified (...)=> predicate;
-                // convert to sempred
-		    	#ebnf = createSynSemPredFromBlock(#b, SYN_SEMPRED);
-			}
-			}
-		|   ROOT {#ebnf = #(#ROOT, #b);}
-		|   BANG {#ebnf = #(#BANG, #b);}
-        |   {#ebnf = #b;}
-		)
-		{#ebnf.setLine(line); #ebnf.setColumn(col);}
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-range!
-{
-GrammarAST subrule=null, root=null;
-TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:	c1:CHAR_LITERAL RANGE c2:CHAR_LITERAL
-		{
-		GrammarAST r = #[CHAR_RANGE,".."];
-		r.setLine(c1.getLine());
-		r.setColumn(c1.getColumn());
-		#range = #(r, #c1, #c2);
-		root = #range;
-		}
-//    	(subrule=ebnfSuffix[root,false] {#range=subrule;})?
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-terminal
-{
-GrammarAST ebnfRoot=null, subrule=null;
-TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-    :   (
-			cl:CHAR_LITERAL^ ( elementOptions[#cl]! )? (ROOT^|BANG^)?
-
-		|   tr:TOKEN_REF^
-				( elementOptions[#tr]! )?
-				( ARG_ACTION )? // Args are only valid for lexer rules
-				(ROOT^|BANG^)?
-
-		|   sl:STRING_LITERAL^ ( elementOptions[#sl]! )? (ROOT^|BANG^)?
-
-		|   wi:WILDCARD (ROOT^|BANG^)?
-			{
-			if ( atTreeRoot ) {
-				ErrorManager.syntaxError(
-					ErrorManager.MSG_WILDCARD_AS_ROOT,grammar,wi,null,null);
-			}
-			}
-        )
-        {
-        ##.setTokenBoundaries(start,LT(0));
-        }
-	;
-
-elementOptions[GrammarAST terminalAST]
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-	:	(
-			OPEN_ELEMENT_OPTION^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION!
-		|	OPEN_ELEMENT_OPTION^ elementOption[terminalAST] (SEMI! elementOption[terminalAST])* CLOSE_ELEMENT_OPTION!
-        )
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-defaultNodeOption[GrammarAST terminalAST]
-{
-StringBuffer buf = new StringBuffer();
-TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:	i:id {buf.append(#i.getText());} (WILDCARD i2:id {buf.append("."+#i2.getText());})*
-	    {terminalAST.setTerminalOption(grammar,Grammar.defaultTokenOption,buf.toString());}
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-elementOption[GrammarAST terminalAST]
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-	:	a:id ASSIGN^ (b:id|s:STRING_LITERAL)
-		{
-		Object v = (#b!=null)?#b.getText():#s.getText();
-		terminalAST.setTerminalOption(grammar,#a.getText(),v);
-        ##.setTokenBoundaries(start,LT(0));
-		}
-	;
-
-ebnfSuffix[GrammarAST elemAST, boolean inRewrite] returns [GrammarAST subrule=null]
-{
-	GrammarAST ebnfRoot=null;
-    TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:!	(	QUESTION {ebnfRoot = #[OPTIONAL,"?"];}
-   		|	STAR     {ebnfRoot = #[CLOSURE,"*"];}
-   		|	PLUS     {ebnfRoot = #[POSITIVE_CLOSURE,"+"];}
-   		)
-    	{
-		GrammarAST save = currentBlockAST;
-       	ebnfRoot.setLine(elemAST.getLine());
-       	ebnfRoot.setColumn(elemAST.getColumn());
-    	GrammarAST blkRoot = #[BLOCK,"BLOCK"];
-    	currentBlockAST = blkRoot;
-       	GrammarAST eob = #[EOB,"<end-of-block>"];
-		eob.setLine(elemAST.getLine());
-		eob.setColumn(elemAST.getColumn());
-		GrammarAST alt = #(#[ALT,"ALT"],elemAST,#[EOA,"<end-of-alt>"]);
-    	if ( !inRewrite ) {
-    		prefixWithSynPred(alt);
-    	}
-  		subrule =
-  		     #(ebnfRoot,
-  		       #(blkRoot,alt,eob)
-  		      );
-  		currentBlockAST = save;
-        subrule.setTokenBoundaries(start,LT(0));
-   		}
-    ;
-
-notTerminal
-	:   cl:CHAR_LITERAL
-	|	tr:TOKEN_REF
-	|	STRING_LITERAL
-	;
-
-idList
-	:	id (COMMA! id)*
-	;
-
-id	:	TOKEN_REF {#id.setType(ID);}
-	|	RULE_REF  {#id.setType(ID);}
-	;
-
-// R E W R I T E  S Y N T A X
-
-rewrite
-{
-    GrammarAST root = #[REWRITES, "REWRITES"];
-    TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:!
-		( options { warnWhenFollowAmbig=false;}
-		: rew:REWRITE pred:SEMPRED alt:rewrite_alternative
-	      {
-	      root.addChild( #(#rew, #pred, #alt) );
-	      #rew.setTokenBoundaries(#alt.token,LT(0));
-	      }
-	    )*
-		rew2:REWRITE alt2:rewrite_alternative
-        {
-        TokenWithIndex stop = (TokenWithIndex)LT(0);
-        //if ( stop.getType() == REWRITE ) stop =
-        root.addChild( #(#rew2, #alt2) );
-        root.token.setIndex(start.getIndex());
-        #rewrite = root;
-        ##.setTokenBoundaries(start,LT(0));
-        }
-	|
-	;
-
-rewrite_block
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-    :   lp:LPAREN^ {#lp.setType(BLOCK); #lp.setText("BLOCK");}
-		rewrite_alternative
-        RPAREN!
-        {
-        GrammarAST eob = #[EOB,"<end-of-block>"];
-        eob.setLine(lp.getLine());
-        eob.setColumn(lp.getColumn());
-        #rewrite_block.addChild(eob);
-        ##.setTokenBoundaries(start,LT(0));
-        }
-    ;
-
-rewrite_alternative
-{
-    GrammarAST eoa = #[EOA, "<end-of-alt>"];
-    GrammarAST altRoot = #[ALT,"ALT"];
-    altRoot.setLine(LT(1).getLine());
-    altRoot.setColumn(LT(1).getColumn());
-    TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-    :	(
-            {grammar.buildTemplate()}? rewrite_template
-
-        |	{grammar.buildAST()}? ( rewrite_element )+
-            {
-                if ( #rewrite_alternative==null ) {
-                    #rewrite_alternative = #(altRoot,#[EPSILON,"epsilon"],eoa);
-                }
-                else {
-                    #rewrite_alternative = #(altRoot, #rewrite_alternative,eoa);
-                }
-            }
-
-        |   {#rewrite_alternative = #(altRoot,#[EPSILON,"epsilon"],eoa);}
-
-        |	{grammar.buildAST()}? ETC
-   	    )
-   	    {##.setTokenBoundaries(start,LT(0));}
-    ;
-
-rewrite_element
-{
-GrammarAST subrule=null;
-TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:	(
-            t:rewrite_atom
-            ( subrule=ebnfSuffix[#t,true] {#rewrite_element=subrule;} )?
-        |   rewrite_ebnf
-        |   tr:rewrite_tree
-            ( subrule=ebnfSuffix[#tr,true] {#rewrite_element=subrule;} )?
-    	)
-    	{##.setTokenBoundaries(start,LT(0));}
-	;
-
-rewrite_atom
-{
-GrammarAST subrule=null;
-TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-    :   (
-            tr:TOKEN_REF^ (elementOptions[#tr]!)? (ARG_ACTION)? // for imaginary nodes
-        |   rr:RULE_REF
-        |   cl:CHAR_LITERAL^ (elementOptions[#cl]!)?
-        |   sl:STRING_LITERAL^ (elementOptions[#sl]!)?
-        |!  d:DOLLAR i:id // reference to a label in a rewrite rule
-            {
-            #rewrite_atom = #[LABEL,i_AST.getText()];
-            #rewrite_atom.setLine(#d.getLine());
-            #rewrite_atom.setColumn(#d.getColumn());
-            }
-        |	ACTION
-	    )
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-rewrite_ebnf!
-{
-    int line = LT(1).getLine();
-    int col = LT(1).getColumn();
-    TokenWithIndex start = (TokenWithIndex)LT(1);
-}
-	:	b:rewrite_block
-		(	QUESTION    {#rewrite_ebnf=#([OPTIONAL,"?"],#b);}
-		|	STAR	    {#rewrite_ebnf=#([CLOSURE,"*"],#b);}
-		|	PLUS	    {#rewrite_ebnf=#([POSITIVE_CLOSURE,"+"],#b);}
-		)
-		{#rewrite_ebnf.setLine(line); #rewrite_ebnf.setColumn(col);}
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-rewrite_tree
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-    :
-	TREE_BEGIN^
-        rewrite_atom ( rewrite_element )*
-    RPAREN!
-    {##.setTokenBoundaries(start,LT(0));}
-	;
-
-/** Build a tree for a template rewrite:
-      ^(TEMPLATE (ID|ACTION) ^(ARGLIST ^(ARG ID ACTION) ...) )
-    where ARGLIST is always there even if no args exist.
-    ID can be "template" keyword.  If first child is ACTION then it's
-    an indirect template ref
-
-    -> foo(a={...}, b={...})
-    -> ({string-e})(a={...}, b={...})  // e evaluates to template name
-    -> {%{$ID.text}} // create literal template from string (done in ActionTranslator)
-	-> {st-expr} // st-expr evaluates to ST
- */
-rewrite_template
-{Token st=null; TokenWithIndex start = (TokenWithIndex)LT(1);}
-	:   (
-            // -> template(a={...},...) "..."
-            {LT(1).getText().equals("template")}? // inline
-            rewrite_template_head {st=LT(1);}
-            ( DOUBLE_QUOTE_STRING_LITERAL! | DOUBLE_ANGLE_STRING_LITERAL! )
-            {#rewrite_template.addChild(#[st]);}
-
-        |	// -> foo(a={...}, ...)
-            rewrite_template_head
-
-        |	// -> ({expr})(a={...}, ...)
-            rewrite_indirect_template_head
-
-        |	// -> {...}
-            ACTION
-		)
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-/** -> foo(a={...}, ...) */
-rewrite_template_head
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-	:	id lp:LPAREN^ {#lp.setType(TEMPLATE); #lp.setText("TEMPLATE");}
-		rewrite_template_args
-		RPAREN!
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-/** -> ({expr})(a={...}, ...) */
-rewrite_indirect_template_head
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-	:	lp:LPAREN^ {#lp.setType(TEMPLATE); #lp.setText("TEMPLATE");}
-		ACTION
-		RPAREN!
-		LPAREN! rewrite_template_args RPAREN!
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-rewrite_template_args
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-	:	(
-	    rewrite_template_arg (COMMA! rewrite_template_arg)*
-		{#rewrite_template_args = #(#[ARGLIST,"ARGLIST"], rewrite_template_args);}
-	|	{#rewrite_template_args = #[ARGLIST,"ARGLIST"];}
-        )
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-rewrite_template_arg
-{TokenWithIndex start = (TokenWithIndex)LT(1);}
-	:   id a:ASSIGN^ {#a.setType(ARG); #a.setText("ARG");} ACTION
-        {##.setTokenBoundaries(start,LT(0));}
-	;
-
-class ANTLRLexer extends Lexer;
-options {
-	k=3;
-	exportVocab=ANTLR;
-	testLiterals=false;
-	interactive=true;
-	charVocabulary='\003'..'\377';
-}
-
-{
-    /** advance the current column number by one; don't do tabs.
-     *  we want char position in line to be sent to AntlrWorks.
-     */
-    public void tab() {
-		setColumn( getColumn()+1 );
-    }
-    public boolean hasASTOperator = false;
-}
-
-WS	:	(	' '
-		|	'\t'
-		|	('\r')? '\n' {newline();}
-		)
-	;
-
-COMMENT :
-	( SL_COMMENT | t:ML_COMMENT {$setType(t.getType());} )
-	;
-
-protected
-SL_COMMENT
- 	:	"//"
- 	 	(	(" $ANTLR")=> " $ANTLR " SRC ('\r')? '\n' // src directive
- 		|	( options {greedy=false;} : . )* ('\r')? '\n'
-		)
-		{ newline(); }
-	;
-
-protected
-ML_COMMENT :
-	"/*"
-	(	{ LA(2)!='/' }? '*' {$setType(DOC_COMMENT);}
-	|
-	)
-	(
-		options {
-			greedy=false;  // make it exit upon "*/"
-		}
-	:	'\r' '\n'	{newline();}
-	|	'\n'		{newline();}
-	|	~('\n'|'\r')
-	)*
-	"*/"
-	;
-
-OPEN_ELEMENT_OPTION
-	:	'<'
-	;
-
-CLOSE_ELEMENT_OPTION
-	:	'>'
-	;
-
-AMPERSAND : '@';
-
-COMMA : ',';
-
-QUESTION :	'?' ;
-
-TREE_BEGIN : "^(" ;
-
-LPAREN:	'(' ;
-
-RPAREN:	')' ;
-
-COLON :	':' ;
-
-STAR:	'*' ;
-
-PLUS:	'+' ;
-
-ASSIGN : '=' ;
-
-PLUS_ASSIGN : "+=" ;
-
-IMPLIES : "=>" ;
-
-REWRITE : "->" ;
-
-SEMI:	';' ;
-
-ROOT : '^' {hasASTOperator=true;} ;
-
-BANG : '!' {hasASTOperator=true;} ;
-
-OR	:	'|' ;
-
-WILDCARD : '.' ;
-
-ETC : "..." ;
-
-RANGE : ".." ;
-
-NOT :	'~' ;
-
-RCURLY:	'}'	;
-
-DOLLAR : '$' ;
-
-STRAY_BRACKET
-	:	']'
-		{
-		ErrorManager.syntaxError(
-			ErrorManager.MSG_SYNTAX_ERROR,
-			null,
-			_token,
-			"antlr: dangling ']'? make sure to escape with \\]",
-			null);
-		}
-	;
-
-CHAR_LITERAL
-	:	'\'' (ESC|'\n'{newline();}|~'\'')* '\''
-		{
-		StringBuffer s = Grammar.getUnescapedStringFromGrammarStringLiteral($getText);
-		if ( s.length()>1 ) {
-			$setType(STRING_LITERAL);
-		}
-		}
-	;
-
-DOUBLE_QUOTE_STRING_LITERAL
-	:	'"' ('\\'! '"'|'\\' ~'"'|'\n'{newline();}|~'"')* '"'
-	;
-
-DOUBLE_ANGLE_STRING_LITERAL
-	:	"<<" (options {greedy=false;}:'\n'{newline();}|.)* ">>"
-	;
-
-protected
-ESC	:	'\\'
-		(	'n'
-		|	'r'
-		|	't'
-		|	'b'
-		|	'f'
-		|	'"'
-		|	'\''
-		|	'\\'
-		|	'>'
-		|	'u' XDIGIT XDIGIT XDIGIT XDIGIT
-		|	. // unknown, leave as it is
-		)
-	;
-
-protected
-DIGIT
-	:	'0'..'9'
-	;
-
-protected
-XDIGIT :
-		'0' .. '9'
-	|	'a' .. 'f'
-	|	'A' .. 'F'
-	;
-
-INT	:	('0'..'9')+
-	;
-
-ARG_ACTION
-	:	'['! NESTED_ARG_ACTION ']'!
-	;
-
-protected
-NESTED_ARG_ACTION :
-	(	'\r' '\n'	{newline();}
-	|	'\n'		{newline();}
-	|	'\\'! ']'
-	|	'\\' ~']'
-	|	ACTION_STRING_LITERAL
-	|	ACTION_CHAR_LITERAL
-	|	~']'
-	)*
-	;
-
-ACTION
-{int actionLine=getLine(); int actionColumn = getColumn(); }
-	:	NESTED_ACTION
-		(	'?'! {_ttype = SEMPRED;} )?
-		{
-			Token t = makeToken(_ttype);
-			String action = $getText;
-            int n = 1; // num delimiter chars
-            if ( action.startsWith("{{") && action.endsWith("}}") ) {
-                t.setType(FORCED_ACTION);
-                n = 2;
-            }
-			action = action.substring(n,action.length()-n);
-			t.setText(action);
-			t.setLine(actionLine);			// set action line to start
-			t.setColumn(actionColumn);
-			$setToken(t);
-		}
-	;
-
-protected
-NESTED_ACTION :
-	'{'
-	(
-		options {
-			greedy = false; // exit upon '}'
-		}
-	:
-		(
-			'\r' '\n'	{newline();}
-		|	'\n'		{newline();}
-		)
-	|	NESTED_ACTION
-	|	ACTION_CHAR_LITERAL
-	|	COMMENT
-	|	ACTION_STRING_LITERAL
-	|	ACTION_ESC
-	|	.
-	)*
-	'}'
-   ;
-
-protected
-ACTION_CHAR_LITERAL
-	:	'\'' (ACTION_ESC|'\n'{newline();}|~'\'')* '\''
-	;
-
-protected
-ACTION_STRING_LITERAL
-	:	'"' (ACTION_ESC|'\n'{newline();}|~'"')* '"'
-	;
-
-protected
-ACTION_ESC
-	:	"\\'"
-	|	"\\\""
-	|	'\\' ~('\''|'"')
-	;
-
-TOKEN_REF
-options { testLiterals = true; }
-	:	'A'..'Z'
-		(	// scarf as many letters/numbers as you can
-			options {
-				warnWhenFollowAmbig=false;
-			}
-		:
-			'a'..'z'|'A'..'Z'|'_'|'0'..'9'
-		)*
-	;
-
-// we get a warning here when looking for options '{', but it works right
-RULE_REF
-{
-	int t=0;
-}
-	:	t=INTERNAL_RULE_REF {_ttype=t;}
-		(	{t==OPTIONS}? WS_LOOP ('{' {_ttype = OPTIONS;})?
-		|	{t==TOKENS}? WS_LOOP ('{' {_ttype = TOKENS;})?
-		|
-		)
-	;
-
-protected
-WS_LOOP
-	:	(	// grab as much WS as you can
-			options {
-				greedy=true;
-			}
-		:
-			WS
-		|	COMMENT
-		)*
-	;
-
-protected
-INTERNAL_RULE_REF returns [int t]
-{
-	t = RULE_REF;
-}
-	:	'a'..'z'
-		(	// scarf as many letters/numbers as you can
-			options {
-				warnWhenFollowAmbig=false;
-			}
-		:
-			'a'..'z'|'A'..'Z'|'_'|'0'..'9'
-		)*
-		{t = testLiteralsTable(t);}
-	;
-
-protected
-WS_OPT
-	:	(WS)?
-	;
-
-/** Reset the file and line information; useful when the grammar
- *  has been generated so that errors are shown relative to the
- *  original file like the old C preprocessor used to do.
- */
-protected
-SRC	:	"src" ' ' file:ACTION_STRING_LITERAL ' ' line:INT
-		{
-		newline();
-		setFilename(file.getText().substring(1,file.getText().length()-1));
-		setLine(Integer.parseInt(line.getText())-1);  // -1 because SL_COMMENT will increment the line no. KR
-		$setType(Token.SKIP); // don't let this go to the parser
-		}
-	;
-
diff --git a/tool/src/main/antlr2/org/antlr/grammar/v2/antlr.print.g b/tool/src/main/antlr2/org/antlr/grammar/v2/antlr.print.g
deleted file mode 100644
index 4b822b1..0000000
--- a/tool/src/main/antlr2/org/antlr/grammar/v2/antlr.print.g
+++ /dev/null
@@ -1,390 +0,0 @@
-header {
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-	package org.antlr.grammar.v2;
-	import java.util.*;
-    import org.antlr.tool.*;
-}
-
-/** Print out a grammar (no pretty printing).
- *
- *  Terence Parr
- *  University of San Francisco
- *  August 19, 2003
- */
-class ANTLRTreePrinter extends TreeParser;
-
-options {
-	importVocab = ANTLR;
-	ASTLabelType = "GrammarAST";
-    codeGenBitsetTestThreshold=999;
-}
-
-{
-
-	protected Grammar grammar;
-	protected boolean showActions;
-    protected StringBuffer buf = new StringBuffer(300);
-
-    public void out(String s) {
-        buf.append(s);
-    }
-
-    public void reportError(RecognitionException ex) {
-		Token token = null;
-		if ( ex instanceof MismatchedTokenException ) {
-			token = ((MismatchedTokenException)ex).token;
-		}
-		else if ( ex instanceof NoViableAltException ) {
-			token = ((NoViableAltException)ex).token;
-		}
-        ErrorManager.syntaxError(
-            ErrorManager.MSG_SYNTAX_ERROR,
-            grammar,
-            token,
-            "antlr.print: "+ex.toString(),
-            ex);
-    }
-
-	/** Normalize a grammar print out by removing all double spaces
-	 *  and trailing/beginning stuff.  FOr example, convert
-	 *
-	 *  ( A  |  B  |  C )*
-	 *
-	 *  to
-	 *
-	 *  ( A | B | C )*
-	 */
-	public static String normalize(String g) {
-	    StringTokenizer st = new StringTokenizer(g, " ", false);
-		StringBuffer buf = new StringBuffer();
-		while ( st.hasMoreTokens() ) {
-			String w = st.nextToken();
-			buf.append(w);
-			buf.append(" ");
-		}
-		return buf.toString().trim();
-	}
-}
-
-/** Call this to figure out how to print */
-toString[Grammar g, boolean showActions] returns [String s=null]
-{
-grammar = g;
-this.showActions = showActions;
-}
-    :   (   grammar
-        |   rule
-        |   alternative
-        |   element
-        |	single_rewrite
-        |	rewrite
-        |   EOR// {s="EOR";}
-        )
-        {return normalize(buf.toString());}
-    ;
-
-// --------------
-
-grammar
-    :   ( #( LEXER_GRAMMAR grammarSpec["lexer " ] )
-	    | #( PARSER_GRAMMAR grammarSpec["parser "] )
-	    | #( TREE_GRAMMAR grammarSpec["tree "] )
-	    | #( COMBINED_GRAMMAR grammarSpec[""] )
-	    )
-     ;
-
-attrScope
-	:	#( "scope" ID ACTION )
-	;
-
-grammarSpec[String gtype]
-	:	 id:ID {out(gtype+"grammar "+#id.getText());}
-        (cmt:DOC_COMMENT {out(#cmt.getText()+"\n");} )?
-        (optionsSpec)? {out(";\n");}
-        (delegateGrammars)?
-        (tokensSpec)?
-        (attrScope)*
-        (actions)?
-        rules
-    ;
-
-actions
-	:	( action )+
-	;
-
-action
-{
-String scope=null, name=null;
-String action=null;
-}
-	:	#(AMPERSAND id1:ID
-			( id2:ID a1:ACTION
-			  {scope=#id1.getText(); name=#a1.getText(); action=#a1.getText();}
-			| a2:ACTION
-			  {scope=null; name=#id1.getText(); action=#a2.getText();}
-			)
-		 )
-		 {
-		 if ( showActions ) {
-		 	out("@"+(scope!=null?scope+"::":"")+name+action);
-		 }
-		 }
-	;
-
-optionsSpec
-    :   #( OPTIONS {out(" options {");}
-    	   (option {out("; ");})+
-    	   {out("} ");}
-    	 )
-    ;
-
-option
-    :   #( ASSIGN id:ID {out(#id.getText()+"=");} optionValue )
-    ;
-
-optionValue
-	:	id:ID            {out(#id.getText());}
-	|   s:STRING_LITERAL {out(#s.getText());}
-	|	c:CHAR_LITERAL   {out(#c.getText());}
-	|	i:INT            {out(#i.getText());}
-//	|   charSet
-	;
-
-/*
-charSet
-	:   #( CHARSET charSetElement )
-	;
-
-charSetElement
-	:   c:CHAR_LITERAL {out(#c.getText());}
-	|   #( OR c1:CHAR_LITERAL c2:CHAR_LITERAL )
-	|   #( RANGE c3:CHAR_LITERAL c4:CHAR_LITERAL )
-	;
-*/
-
-delegateGrammars
-	:	#( "import" ( #(ASSIGN ID ID) | ID )+ )
-	;
-
-tokensSpec
-	:	#( TOKENS ( tokenSpec )+ )
-	;
-
-tokenSpec
-	:	TOKEN_REF
-	|	#( ASSIGN TOKEN_REF (STRING_LITERAL|CHAR_LITERAL) )
-	;
-
-rules
-    :   ( rule|precRule )+
-    ;
-
-rule
-    :   #( RULE id:ID
-           (modifier)?
-           {out(#id.getText());}
-           #(ARG (arg:ARG_ACTION {out("["+#arg.getText()+"]");} )? )
-           #(RET (ret:ARG_ACTION {out(" returns ["+#ret.getText()+"]");} )? )
-           (optionsSpec)?
-           (ruleScopeSpec)?
-		   (ruleAction)*
-           {out(" : ");}
-           b:block[false]
-           (exceptionGroup)?
-           EOR {out(";\n");}
-         )
-    ;
-
-precRule
-    :   #( PREC_RULE id:ID
-           (modifier)?
-           {out(#id.getText());}
-           #(ARG (arg:ARG_ACTION {out("["+#arg.getText()+"]");} )? )
-           #(RET (ret:ARG_ACTION {out(" returns ["+#ret.getText()+"]");} )? )
-           (optionsSpec)?
-           (ruleScopeSpec)?
-		   (ruleAction)*
-           {out(" : ");}
-           b:block[false]
-           (exceptionGroup)?
-           EOR {out(";\n");}
-         )
-    ;
-
-ruleAction
-	:	#(AMPERSAND id:ID a:ACTION )
-		{if ( showActions ) out("@"+#id.getText()+"{"+#a.getText()+"}");}
-	;
-
-modifier
-{out(#modifier.getText()); out(" ");}
-	:	"protected"
-	|	"public"
-	|	"private"
-	|	"fragment"
-	;
-
-ruleScopeSpec
- 	:	#( "scope" (ACTION)? ( ID )* )
- 	;
-
-block[boolean forceParens]
-{
-int numAlts = countAltsForBlock(#block);
-}
-    :   #(  BLOCK {if ( forceParens||numAlts>1 ) out(" (");}
-            (optionsSpec {out(" : ");} )?
-            alternative rewrite ( {out(" | ");} alternative rewrite )*
-            EOB   {if ( forceParens||numAlts>1 ) out(")");}
-         )
-    ;
-
-countAltsForBlock returns [int n=0]
-    :   #( BLOCK (OPTIONS)? (ALT (REWRITES)? {n++;})+ EOB )
-	;
-
-alternative
-    :   #( ALT (element)* EOA )
-    ;
-
-exceptionGroup
-	:	( exceptionHandler )+ (finallyClause)?
-	|	finallyClause
-    ;
-
-exceptionHandler
-    :    #("catch" ARG_ACTION ACTION)
-    ;
-
-finallyClause
-    :    #("finally" ACTION)
-    ;
-
-rewrite
-	:	#( REWRITES ( single_rewrite )+ )
-	|
-	;
-
-single_rewrite
-	:	#( REWRITE {out(" ->");} (SEMPRED {out(" {"+#SEMPRED.getText()+"}?");})?
-	       ( alternative | rewrite_template | ETC {out("...");} | ACTION {out(" {"+#ACTION.getText()+"}");})
-	     )
-	;
-
-rewrite_template
-	:	#( TEMPLATE
-		   (id:ID {out(" "+#id.getText());}|ind:ACTION {out(" ({"+#ind.getText()+"})");})
-	       #( ARGLIST
-              {out("(");}
- 	       	  ( #( ARG arg:ID {out(#arg.getText()+"=");}
-	               a:ACTION   {out(#a.getText());}
-	             )
-	          )*
-              {out(")");}
-	        )
-		   ( DOUBLE_QUOTE_STRING_LITERAL {out(" "+#DOUBLE_QUOTE_STRING_LITERAL.getText());}
-		   | DOUBLE_ANGLE_STRING_LITERAL {out(" "+#DOUBLE_ANGLE_STRING_LITERAL.getText());}
-		   )?
-	     )
-	;
-
-element
-    :   #(ROOT element) {out("^");}
-    |   #(BANG element) {out("!");}
-    |   atom
-    |   #(NOT {out("~");} element)
-    |   #(RANGE atom {out("..");} atom)
-    |   #(CHAR_RANGE atom {out("..");} atom)
-    |	#(ASSIGN id:ID {out(#id.getText()+"=");} element)
-    |	#(PLUS_ASSIGN id2:ID {out(#id2.getText()+"+=");} element)
-    |   ebnf
-    |   tree
-    |   #( SYNPRED block[true] ) {out("=>");}
-    |   a:ACTION  {if ( showActions ) {out("{"); out(a.getText()); out("}");}}
-    |   a2:FORCED_ACTION  {if ( showActions ) {out("{{"); out(a2.getText()); out("}}");}}
-    |   pred:SEMPRED
-    	{
-    	if ( showActions ) {out("{"); out(pred.getText()); out("}?");}
-    	else {out("{...}?");}
-    	}
-    |   spred:SYN_SEMPRED
-    	{
-    	  String name = spred.getText();
-    	  GrammarAST predAST=grammar.getSyntacticPredicate(name);
-    	  block(predAST, true);
-    	  out("=>");
-    	}
-    |   BACKTRACK_SEMPRED // don't print anything (auto backtrack stuff)
-    |   gpred:GATED_SEMPRED
-    	{
-    	if ( showActions ) {out("{"); out(gpred.getText()); out("}? =>");}
-    	else {out("{...}? =>");}
-    	}
-    |   EPSILON
-    ;
-
-ebnf:   block[true] {out(" ");}
-    |   #( OPTIONAL block[true] ) {out("? ");}
-    |   #( CLOSURE block[true] )  {out("* ");}
-    |   #( POSITIVE_CLOSURE block[true] ) {out("+ ");}
-    ;
-
-tree:   #(TREE_BEGIN {out(" ^(");} element (element)* {out(") ");} )
-    ;
-
-atom
-{out(" ");}
-    :   (	#( RULE_REF		{out(#atom.toString());}
-			   (rarg:ARG_ACTION	{out("["+#rarg.toString()+"]");})?
-			   (ast_suffix)?
-             )
-		|   #( TOKEN_REF		{out(#atom.toString());}
-
-			   (targ:ARG_ACTION	{out("["+#targ.toString()+"]");} )?
-			   (ast_suffix)?
-             )
-		|   #( CHAR_LITERAL	{out(#atom.toString());}
-			   (ast_suffix)?
-             )
-		|   #( STRING_LITERAL	{out(#atom.toString());}
-			   (ast_suffix)?
-             )
-		|   #( WILDCARD		{out(#atom.toString());}
-                (ast_suffix)?
-             )
-		)
-		{out(" ");}
-    |	LABEL {out(" $"+#LABEL.getText());} // used in -> rewrites
-    |   #(DOT ID {out(#ID.getText()+".");} atom) // scope override on rule
-    ;
-
-ast_suffix
-	:	ROOT {out("^");}
-	|	BANG  {out("!");}
-	;
diff --git a/tool/src/main/antlr2/org/antlr/grammar/v2/assign.types.g b/tool/src/main/antlr2/org/antlr/grammar/v2/assign.types.g
deleted file mode 100644
index 9a6880a..0000000
--- a/tool/src/main/antlr2/org/antlr/grammar/v2/assign.types.g
+++ /dev/null
@@ -1,336 +0,0 @@
-header {
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-	package org.antlr.grammar.v2;
-	import java.util.*;
-	import org.antlr.analysis.*;
-	import org.antlr.misc.*;
-	import java.io.*;
-    import org.antlr.tool.*;
-}
-
-/** [Warning: TJP says that this is probably out of date as of 11/19/2005,
- *   but since it's probably still useful, I'll leave in.  Don't have energy
- *   to update at the moment.]
- *
- *  Compute the token types for all literals and rules etc..  There are
- *  a few different cases to consider for grammar types and a few situations
- *  within.
- *
- *  CASE 1 : pure parser grammar
- *	a) Any reference to a token gets a token type.
- *  b) The tokens section may alias a token name to a string or char
- *
- *  CASE 2 : pure lexer grammar
- *  a) Import token vocabulary if available. Set token types for any new tokens
- *     to values above last imported token type
- *  b) token rule definitions get token types if not already defined
- *  c) literals do NOT get token types
- *
- *  CASE 3 : merged parser / lexer grammar
- *	a) Any char or string literal gets a token type in a parser rule
- *  b) Any reference to a token gets a token type if not referencing
- *     a fragment lexer rule
- *  c) The tokens section may alias a token name to a string or char
- *     which must add a rule to the lexer
- *  d) token rule definitions get token types if not already defined
- *  e) token rule definitions may also alias a token name to a literal.
- *     E.g., Rule 'FOR : "for";' will alias FOR to "for" in the sense that
- *     references to either in the parser grammar will yield the token type
- *
- *  What this pass does:
- *
- *  0. Collects basic info about the grammar like grammar name and type;
- *     Oh, I have go get the options in case they affect the token types.
- *     E.g., tokenVocab option.
- *     Imports any token vocab name/type pairs into a local hashtable.
- *  1. Finds a list of all literals and token names.
- *  2. Finds a list of all token name rule definitions;
- *     no token rules implies pure parser.
- *  3. Finds a list of all simple token rule defs of form "<NAME> : <literal>;"
- *     and aliases them.
- *  4. Walks token names table and assign types to any unassigned
- *  5. Walks aliases and assign types to referenced literals
- *  6. Walks literals, assigning types if untyped
- *  4. Informs the Grammar object of the type definitions such as:
- *     g.defineToken(<charliteral>, ttype);
- *     g.defineToken(<stringliteral>, ttype);
- *     g.defineToken(<tokenID>, ttype);
- *     where some of the ttype values will be the same for aliases tokens.
- */
-class AssignTokenTypesWalker extends TreeParser;
-
-options {
-	importVocab = ANTLR;
-	ASTLabelType = "GrammarAST";
-    codeGenBitsetTestThreshold=999;
-}
-
-{
-    public void reportError(RecognitionException ex) {
-		Token token = null;
-		if ( ex instanceof MismatchedTokenException ) {
-			token = ((MismatchedTokenException)ex).token;
-		}
-		else if ( ex instanceof NoViableAltException ) {
-			token = ((NoViableAltException)ex).token;
-		}
-        ErrorManager.syntaxError(
-            ErrorManager.MSG_SYNTAX_ERROR,
-            grammar,
-            token,
-            "assign.types: "+ex.toString(),
-            ex);
-    }
-
-
-protected Grammar grammar;
-protected String currentRuleName;
-
-protected static GrammarAST stringAlias;
-protected static GrammarAST charAlias;
-protected static GrammarAST stringAlias2;
-protected static GrammarAST charAlias2;
-
-protected void initASTPatterns() {
-	stringAlias =
-		#(#[BLOCK], #(#[ALT], #[STRING_LITERAL], #[EOA]), #[EOB]);
-	charAlias =
-		#(#[BLOCK], #(#[ALT], #[CHAR_LITERAL], #[EOA]), #[EOB]);
-	stringAlias2 =
-		#(#[BLOCK], #(#[ALT], #[STRING_LITERAL], #[ACTION], #[EOA]),#[EOB]);
-	charAlias2 =
-		#(#[BLOCK], #(#[ALT], #[CHAR_LITERAL], #[ACTION], #[EOA]), #[EOB]);
-}
-
-// Behavior moved to AssignTokenTypesBehavior
-protected void trackString(GrammarAST t) {;}
-protected void trackToken(GrammarAST t) {;}
-protected void trackTokenRule(GrammarAST t, GrammarAST modifier, GrammarAST block) {;}
-protected void alias(GrammarAST t, GrammarAST s) {;}
-public    void defineTokens(Grammar root) {;}
-protected void defineStringLiteralsFromDelegates() {;}
-protected void assignStringTypes(Grammar root) {;}
-protected void aliasTokenIDsAndLiterals(Grammar root) {;}
-protected void assignTokenIDTypes(Grammar root) {;}
-protected void defineTokenNamesAndLiteralsInGrammar(Grammar root) {;}
-protected void init(Grammar root) {;}
-}
-
-grammar[Grammar g]
-{
-	init(g);
-}
-    :   ( #( LEXER_GRAMMAR 	  grammarSpec )
-	    | #( PARSER_GRAMMAR   grammarSpec )
-	    | #( TREE_GRAMMAR     grammarSpec )
-	    | #( COMBINED_GRAMMAR grammarSpec )
-	    )
-    ;
-
-grammarSpec
-{Map opts=null;}
-	:	id:ID
-		(cmt:DOC_COMMENT)?
-		(optionsSpec)?
-        (delegateGrammars)?
-        (tokensSpec)?
-        (attrScope)*
-        (AMPERSAND)* // skip actions
-        rules
-	;
-
-attrScope
-	:	#( "scope" ID ACTION )
-	;
-
-optionsSpec returns [Map opts=new HashMap()]
-    :   #( OPTIONS (option[opts])+ )
-    ;
-
-option[Map opts]
-{
-    String key=null;
-    Object value=null;
-}
-    :   #( ASSIGN id:ID {key=#id.getText();} value=optionValue )
-        {
-        opts.put(key,value);
-        // check for grammar-level option to import vocabulary
-        if ( currentRuleName==null && key.equals("tokenVocab") ) {
-            grammar.importTokenVocabulary(#id,(String)value);
-        }
-        }
-    ;
-
-optionValue returns [Object value=null]
-    :   id:ID			 {value = #id.getText();}
-    |   s:STRING_LITERAL {value = #s.getText();}
-    |   c:CHAR_LITERAL   {value = #c.getText();}
-    |   i:INT            {value = new Integer(#i.getText());}
-//  |   cs:charSet       {value = #cs;} // return set AST in this case
-    ;
-
-charSet
-	:   #( CHARSET charSetElement )
-	;
-
-charSetElement
-	:   c:CHAR_LITERAL
-	|   #( OR c1:CHAR_LITERAL c2:CHAR_LITERAL )
-	|   #( RANGE c3:CHAR_LITERAL c4:CHAR_LITERAL )
-	;
-
-delegateGrammars
-	:	#( "import"
-            (   #(ASSIGN ID ID)
-            |   ID
-            )+
-        )
-	;
-
-tokensSpec
-	:	#( TOKENS ( tokenSpec )+ )
-	;
-
-tokenSpec
-	:	t:TOKEN_REF           {trackToken(t);}
-	|	#( ASSIGN
-		   t2:TOKEN_REF       {trackToken(t2);}
-		   ( s:STRING_LITERAL {trackString(s); alias(t2,s);}
-		   | c:CHAR_LITERAL   {trackString(c); alias(t2,c);}
-		   )
-		 )
-	;
-
-rules
-    :   ( rule )+
-    ;
-
-rule:   #( RULE ruleBody)
-    |   #( PREC_RULE ruleBody)
-    ;
-
-ruleBody
-    :   id:ID {currentRuleName=#id.getText();}
-        (m:modifier)?
-        (ARG (ARG_ACTION)?)
-        (RET (ARG_ACTION)?)
-        (optionsSpec)?
-        (ruleScopeSpec)?
-        (AMPERSAND)*
-        b:block
-        (exceptionGroup)?
-        EOR
-        {trackTokenRule(#id,#m,#b);}
-    ;
-
-modifier
-	:	"protected"
-	|	"public"
-	|	"private"
-	|	"fragment"
-	;
-
-ruleScopeSpec
- 	:	#( "scope" (ACTION)? ( ID )* )
- 	;
-
-block
-    :   #(  BLOCK
-            (optionsSpec)?
-            ( alternative rewrite )+
-            EOB
-         )
-    ;
-
-alternative
-    :   #( ALT (element)+ EOA )
-    ;
-
-exceptionGroup
-	:	( exceptionHandler )+ (finallyClause)?
-	|	finallyClause
-    ;
-
-exceptionHandler
-    :    #("catch" ARG_ACTION ACTION)
-    ;
-
-finallyClause
-    :    #("finally" ACTION)
-    ;
-
-rewrite
-	:	#( REWRITES ( #( REWRITE (SEMPRED)? (ALT|TEMPLATE|ACTION|ETC) ) )* )
-	|
-	;
-
-element
-    :   #(ROOT element)
-    |   #(BANG element)
-    |   atom
-    |   #(NOT element)
-    |   #(RANGE atom atom)
-    |   #(CHAR_RANGE atom atom)
-    |	#(ASSIGN ID element)
-    |	#(PLUS_ASSIGN ID element)
-    |   ebnf
-    |   tree
-    |   #( SYNPRED block )
-    |   FORCED_ACTION
-    |   ACTION
-    |   SEMPRED
-    |   SYN_SEMPRED
-    |   BACKTRACK_SEMPRED
-    |   GATED_SEMPRED
-    |   EPSILON
-    ;
-
-ebnf:   block
-    |   #( OPTIONAL block )
-    |   #( CLOSURE block )
-    |   #( POSITIVE_CLOSURE block )
-    ;
-
-tree:   #(TREE_BEGIN  element (element)*  )
-    ;
-
-atom
-    :   #( rr:RULE_REF (rarg:ARG_ACTION)? )
-    |   #( t:TOKEN_REF (targ:ARG_ACTION )? ) {trackToken(t);}
-    |   c:CHAR_LITERAL   {trackString(c);}
-    |   s:STRING_LITERAL {trackString(s);}
-    |   WILDCARD
-    |   #(DOT ID atom) // scope override on rule
-    ;
-
-ast_suffix
-	:	ROOT
-	|	BANG
-	;
diff --git a/tool/src/main/antlr2/org/antlr/grammar/v2/buildnfa.g b/tool/src/main/antlr2/org/antlr/grammar/v2/buildnfa.g
deleted file mode 100644
index 2523d5d..0000000
--- a/tool/src/main/antlr2/org/antlr/grammar/v2/buildnfa.g
+++ /dev/null
@@ -1,746 +0,0 @@
-header {
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.antlr.grammar.v2;
-import java.util.*;
-import org.antlr.analysis.*;
-import org.antlr.misc.*;
-import org.antlr.tool.*;
-}
-
-/** Build an NFA from a tree representing an ANTLR grammar. */
-class TreeToNFAConverter extends TreeParser;
-
-options {
-	importVocab = ANTLR;
-	ASTLabelType = "GrammarAST";
-}
-
-{
-
-/** Factory used to create nodes and submachines */
-protected NFAFactory factory = null;
-
-/** Which NFA object are we filling in? */
-protected NFA nfa = null;
-
-/** Which grammar are we converting an NFA for? */
-protected Grammar grammar = null;
-
-protected String currentRuleName = null;
-
-protected int outerAltNum = 0;
-protected int blockLevel = 0;
-
-public TreeToNFAConverter(Grammar g, NFA nfa, NFAFactory factory) {
-	this();
-	this.grammar = g;
-	this.nfa = nfa;
-	this.factory = factory;
-}
-
-/*
-protected void init() {
-    // define all the rule begin/end NFAStates to solve forward reference issues
-    Collection rules = grammar.getRules();
-    for (Iterator itr = rules.iterator(); itr.hasNext();) {
-		Rule r = (Rule) itr.next();
-        String ruleName = r.name;
-        NFAState ruleBeginState = factory.newState();
-        ruleBeginState.setDescription("rule "+ruleName+" start");
-		ruleBeginState.enclosingRule = r;
-        r.startState = ruleBeginState;
-        NFAState ruleEndState = factory.newState();
-        ruleEndState.setDescription("rule "+ruleName+" end");
-        ruleEndState.setAcceptState(true);
-		ruleEndState.enclosingRule = r;
-        r.stopState = ruleEndState;
-    }
-}
-*/
-
-protected void addFollowTransition(String ruleName, NFAState following) {
-     //System.out.println("adding follow link to rule "+ruleName);
-     // find last link in FOLLOW chain emanating from rule
-     Rule r = grammar.getRule(ruleName);
-     NFAState end = r.stopState;
-     while ( end.transition(1)!=null ) {
-         end = (NFAState)end.transition(1).target;
-     }
-     if ( end.transition(0)!=null ) {
-         // already points to a following node
-         // gotta add another node to keep edges to a max of 2
-         NFAState n = factory.newState();
-         Transition e = new Transition(Label.EPSILON, n);
-         end.addTransition(e);
-         end = n;
-     }
-     Transition followEdge = new Transition(Label.EPSILON, following);
-     end.addTransition(followEdge);
-}
-
-protected void finish() {
-    List rules = new LinkedList();
-    rules.addAll(grammar.getRules());
-    int numEntryPoints = factory.build_EOFStates(rules);
-    if ( numEntryPoints==0 ) {
-        ErrorManager.grammarWarning(ErrorManager.MSG_NO_GRAMMAR_START_RULE,
-                                   grammar,
-                                   null,
-                                   grammar.name);
-    }
-}
-
-    public void reportError(RecognitionException ex) {
-		Token token = null;
-		if ( ex instanceof MismatchedTokenException ) {
-			token = ((MismatchedTokenException)ex).token;
-		}
-		else if ( ex instanceof NoViableAltException ) {
-			token = ((NoViableAltException)ex).token;
-		}
-        ErrorManager.syntaxError(
-            ErrorManager.MSG_SYNTAX_ERROR,
-            grammar,
-            token,
-            "buildnfa: "+ex.toString(),
-            ex);
-    }
-}
-
-grammar
-    :   ( #( LEXER_GRAMMAR grammarSpec )
-	    | #( PARSER_GRAMMAR grammarSpec )
-	    | #( TREE_GRAMMAR grammarSpec )
-	    | #( COMBINED_GRAMMAR grammarSpec )
-	    )
-        {finish();}
-    ;
-
-attrScope
-	:	#( "scope" ID ACTION )
-	;
-
-grammarSpec
-	:	ID
-		(cmt:DOC_COMMENT)?
-        ( #(OPTIONS .) )?
-        ( #("import" .) )?
-        ( #(TOKENS .) )?
-        (attrScope)*
-        (AMPERSAND)* // skip actions
-        rules
-	;
-
-rules
-    :   ( rule | PREC_RULE )+
-    ;
-
-rule
-{
-    StateCluster g=null;
-    StateCluster b = null;
-    String r=null;
-}
-    :   #( RULE id:ID {r=#id.getText();}
-		{
-        currentRuleName = r;
-        factory.setCurrentRule(grammar.getLocallyDefinedRule(r));
-        }
-		(modifier)?
-        (ARG (ARG_ACTION)?)
-        (RET (ARG_ACTION)?)
-		( OPTIONS )?
-		( ruleScopeSpec )?
-		   (AMPERSAND)*
-		   {GrammarAST blk = (GrammarAST)_t;}
-		   b=block
-           (exceptionGroup)?
-           EOR
-           {
-                if ( blk.getSetValue() !=null ) {
-                    // if block comes back as a set not BLOCK, make it
-                    // a single ALT block
-                    b = factory.build_AlternativeBlockFromSet(b);
-                }
-				if ( Character.isLowerCase(r.charAt(0)) ||
-					 grammar.type==Grammar.LEXER )
-				{
-					// attach start node to block for this rule
-                    Rule thisR = grammar.getLocallyDefinedRule(r);
-					NFAState start = thisR.startState;
-					start.associatedASTNode = #id;
-					start.addTransition(new Transition(Label.EPSILON, b.left));
-
-					// track decision if > 1 alts
-					if ( grammar.getNumberOfAltsForDecisionNFA(b.left)>1 ) {
-						b.left.setDescription(grammar.grammarTreeToString(#rule,false));
-						b.left.setDecisionASTNode(blk);
-						int d = grammar.assignDecisionNumber( b.left );
-						grammar.setDecisionNFA( d, b.left );
-                    	grammar.setDecisionBlockAST(d, blk);
-					}
-
-					// hook to end of rule node
-					NFAState end = thisR.stopState;
-					b.right.addTransition(new Transition(Label.EPSILON,end));
-				}
-           }
-         )
-    ;
-
-modifier
-	:	"protected"
-	|	"public"
-	|	"private"
-	|	"fragment"
-	;
-
-ruleScopeSpec
- 	:	#( "scope" (ACTION)? ( ID )* )
- 	;
-
-block returns [StateCluster g = null]
-{
-    StateCluster a = null;
-    List alts = new LinkedList();
-    this.blockLevel++;
-    if ( this.blockLevel==1 ) {this.outerAltNum=1;}
-}
-    :   {grammar.isValidSet(this,#block) &&
-		 !currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME)}?
-		g=set
-        {this.blockLevel--;}
-
-    |	#( BLOCK ( OPTIONS )?
-           ( a=alternative rewrite
-             {
-             alts.add(a);
-             if ( this.blockLevel==1 ) {this.outerAltNum++;}
-             }
-           )+
-           EOB
-        )
-        {g = factory.build_AlternativeBlock(alts);}
-        {this.blockLevel--;}
-    ;
-
-alternative returns [StateCluster g=null]
-{
-    StateCluster e = null;
-}
-    :   #( ALT (e=element {g = factory.build_AB(g,e);} )+ )
-        {
-        if (g==null) { // if alt was a list of actions or whatever
-            g = factory.build_Epsilon();
-        }
-        else {
-        	factory.optimizeAlternative(g);
-        }
-        }
-    ;
-
-exceptionGroup
-	:	( exceptionHandler )+ (finallyClause)?
-	|	finallyClause
-    ;
-
-exceptionHandler
-    :    #("catch" ARG_ACTION ACTION)
-    ;
-
-finallyClause
-    :    #("finally" ACTION)
-    ;
-
-rewrite
-	:	#(REWRITES
-            (
-                {
-                if ( grammar.getOption("output")==null ) {
-                    ErrorManager.grammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
-                                              grammar, #rewrite.token, currentRuleName);
-                }
-                }
-                #( REWRITE (SEMPRED)? (ALT|TEMPLATE|ACTION|ETC) )
-            )*
-		)
-	|
-	;
-
-element returns [StateCluster g=null]
-    :   #(ROOT g=element)
-    |   #(BANG g=element)
-    |	#(ASSIGN ID g=element)
-    |	#(PLUS_ASSIGN ID g=element)
-    |   #(RANGE a:atom[null] b:atom[null])
-        {g = factory.build_Range(grammar.getTokenType(#a.getText()),
-                                 grammar.getTokenType(#b.getText()));}
-    |   #(CHAR_RANGE c1:CHAR_LITERAL c2:CHAR_LITERAL)
-        {
-        if ( grammar.type==Grammar.LEXER ) {
-        	g = factory.build_CharRange(#c1.getText(), #c2.getText());
-        }
-        }
-    |   g=atom_or_notatom
-    |   g=ebnf
-    |   g=tree
-    |   #( SYNPRED block )
-    |   ACTION {g = factory.build_Action(#ACTION);}
-    |   FORCED_ACTION {g = factory.build_Action(#FORCED_ACTION);}
-    |   pred:SEMPRED {g = factory.build_SemanticPredicate(#pred);}
-    |   spred:SYN_SEMPRED {g = factory.build_SemanticPredicate(#spred);}
-    |   bpred:BACKTRACK_SEMPRED {g = factory.build_SemanticPredicate(#bpred);}
-    |   gpred:GATED_SEMPRED {g = factory.build_SemanticPredicate(#gpred);}
-    |   EPSILON {g = factory.build_Epsilon();}
-    ;
-
-ebnf returns [StateCluster g=null]
-{
-    StateCluster b = null;
-    GrammarAST blk = #ebnf;
-    if ( blk.getType()!=BLOCK ) {
-    	blk = (GrammarAST)blk.getFirstChild();
-    }
-    GrammarAST eob = blk.getLastChild();
-}
-    :   {grammar.isValidSet(this,#ebnf)}? g=set
-
-    |	b=block
-        {
-        // track decision if > 1 alts
-        if ( grammar.getNumberOfAltsForDecisionNFA(b.left)>1 ) {
-            b.left.setDescription(grammar.grammarTreeToString(blk,false));
-            b.left.setDecisionASTNode(blk);
-            int d = grammar.assignDecisionNumber( b.left );
-            grammar.setDecisionNFA( d, b.left );
-            grammar.setDecisionBlockAST(d, blk);
-        }
-        g = b;
-        }
-    |   #( OPTIONAL b=block )
-        {
-        if ( blk.getSetValue() !=null ) {
-            // if block comes back SET not BLOCK, make it
-            // a single ALT block
-            b = factory.build_AlternativeBlockFromSet(b);
-        }
-        g = factory.build_Aoptional(b);
-    	g.left.setDescription(grammar.grammarTreeToString(#ebnf,false));
-        // there is always at least one alt even if block has just 1 alt
-        int d = grammar.assignDecisionNumber( g.left );
-		grammar.setDecisionNFA(d, g.left);
-        grammar.setDecisionBlockAST(d, blk);
-        g.left.setDecisionASTNode(#ebnf);
-    	}
-    |   #( CLOSURE b=block )
-        {
-        if (  blk.getSetValue() !=null ) {
-            b = factory.build_AlternativeBlockFromSet(b);
-        }
-        g = factory.build_Astar(b);
-		// track the loop back / exit decision point
-    	b.right.setDescription("()* loopback of "+grammar.grammarTreeToString(#ebnf,false));
-        int d = grammar.assignDecisionNumber( b.right );
-		grammar.setDecisionNFA(d, b.right);
-        grammar.setDecisionBlockAST(d, blk);
-        b.right.setDecisionASTNode(eob);
-        // make block entry state also have same decision for interpreting grammar
-        NFAState altBlockState = (NFAState)g.left.transition(0).target;
-        altBlockState.setDecisionASTNode(#ebnf);
-        altBlockState.setDecisionNumber(d);
-        g.left.setDecisionNumber(d); // this is the bypass decision (2 alts)
-        g.left.setDecisionASTNode(#ebnf);
-    	}
-    |   #( POSITIVE_CLOSURE b=block )
-        {
-        if ( blk.getSetValue() !=null ) {
-            b = factory.build_AlternativeBlockFromSet(b);
-        }
-        g = factory.build_Aplus(b);
-        // don't make a decision on left edge, can reuse loop end decision
-		// track the loop back / exit decision point
-    	b.right.setDescription("()+ loopback of "+grammar.grammarTreeToString(#ebnf,false));
-        int d = grammar.assignDecisionNumber( b.right );
-		grammar.setDecisionNFA(d, b.right);
-        grammar.setDecisionBlockAST(d, blk);
-        b.right.setDecisionASTNode(eob);
-        // make block entry state also have same decision for interpreting grammar
-        NFAState altBlockState = (NFAState)g.left.transition(0).target;
-        altBlockState.setDecisionASTNode(#ebnf);
-        altBlockState.setDecisionNumber(d);
-        }
-    ;
-
-tree returns [StateCluster g=null]
-{
-StateCluster e=null;
-GrammarAST el=null;
-StateCluster down=null, up=null;
-}
-	:   #( TREE_BEGIN
-		   {el=(GrammarAST)_t;}
-		   g=element
-		   {
-           down = factory.build_Atom(Label.DOWN, el);
-           // TODO set following states for imaginary nodes?
-           //el.followingNFAState = down.right;
-		   g = factory.build_AB(g,down);
-		   }
-		   ( {el=(GrammarAST)_t;} e=element {g = factory.build_AB(g,e);} )*
-		   {
-           up = factory.build_Atom(Label.UP, el);
-           //el.followingNFAState = up.right;
-		   g = factory.build_AB(g,up);
-		   // tree roots point at right edge of DOWN for LOOK computation later
-		   #tree.NFATreeDownState = down.left;
-		   }
-		 )
-    ;
-
-atom_or_notatom returns [StateCluster g=null]
-	:	g=atom[null]
-	|	#(  n:NOT
-            (  c:CHAR_LITERAL (ast1:ast_suffix)?
-	           {
-	            int ttype=0;
-     			if ( grammar.type==Grammar.LEXER ) {
-        			ttype = Grammar.getCharValueFromGrammarCharLiteral(#c.getText());
-     			}
-     			else {
-        			ttype = grammar.getTokenType(#c.getText());
-        		}
-                IntSet notAtom = grammar.complement(ttype);
-                if ( notAtom.isNil() ) {
-                    ErrorManager.grammarError(ErrorManager.MSG_EMPTY_COMPLEMENT,
-					  			              grammar,
-								              #c.token,
-									          #c.getText());
-                }
-	            g=factory.build_Set(notAtom,#n);
-	           }
-            |  t:TOKEN_REF (ast3:ast_suffix)?
-	           {
-	            int ttype=0;
-                IntSet notAtom = null;
-     			if ( grammar.type==Grammar.LEXER ) {
-        			notAtom = grammar.getSetFromRule(this,#t.getText());
-        	   		if ( notAtom==null ) {
-                  		ErrorManager.grammarError(ErrorManager.MSG_RULE_INVALID_SET,
-				  			              grammar,
-							              #t.token,
-								          #t.getText());
-        	   		}
-        	   		else {
-	            		notAtom = grammar.complement(notAtom);
-	            	}
-     			}
-     			else {
-        			ttype = grammar.getTokenType(#t.getText());
-	            	notAtom = grammar.complement(ttype);
-        		}
-               if ( notAtom==null || notAtom.isNil() ) {
-                  ErrorManager.grammarError(ErrorManager.MSG_EMPTY_COMPLEMENT,
-				  			              grammar,
-							              #t.token,
-								          #t.getText());
-               }
-	           g=factory.build_Set(notAtom,#n);
-	           }
-            |  g=set
-	           {
-	           GrammarAST stNode = (GrammarAST)n.getFirstChild();
-               //IntSet notSet = grammar.complement(stNode.getSetValue());
-               // let code generator complement the sets
-               IntSet s = stNode.getSetValue();
-               stNode.setSetValue(s);
-               // let code gen do the complement again; here we compute
-               // for NFA construction
-               s = grammar.complement(s);
-               if ( s.isNil() ) {
-                  ErrorManager.grammarError(ErrorManager.MSG_EMPTY_COMPLEMENT,
-				  			              grammar,
-							              #n.token);
-               }
-	           g=factory.build_Set(s,#n);
-	           }
-            )
-        	{#n.followingNFAState = g.right;}
-         )
-	;
-
-atom[String scopeName] returns [StateCluster g=null]
-    :   #( r:RULE_REF (rarg:ARG_ACTION)? (as1:ast_suffix)? )
-        {
-        NFAState start = grammar.getRuleStartState(scopeName,r.getText());
-        if ( start!=null ) {
-            Rule rr = grammar.getRule(scopeName,r.getText());
-            g = factory.build_RuleRef(rr, start);
-            r.followingNFAState = g.right;
-            r.NFAStartState = g.left;
-            if ( g.left.transition(0) instanceof RuleClosureTransition
-            	 && grammar.type!=Grammar.LEXER )
-            {
-                addFollowTransition(r.getText(), g.right);
-            }
-            // else rule ref got inlined to a set
-        }
-        }
-
-    |   #( t:TOKEN_REF  (targ:ARG_ACTION)? (as2:ast_suffix)? )
-        {
-        if ( grammar.type==Grammar.LEXER ) {
-            NFAState start = grammar.getRuleStartState(scopeName,t.getText());
-            if ( start!=null ) {
-                Rule rr = grammar.getRule(scopeName,t.getText());
-                g = factory.build_RuleRef(rr, start);
-            	t.NFAStartState = g.left;
-                // don't add FOLLOW transitions in the lexer;
-                // only exact context should be used.
-            }
-        }
-        else {
-            g = factory.build_Atom(t);
-            t.followingNFAState = g.right;
-        }
-        }
-
-    |   #( c:CHAR_LITERAL  (as3:ast_suffix)? )
-    	{
-    	if ( grammar.type==Grammar.LEXER ) {
-    		g = factory.build_CharLiteralAtom(c);
-    	}
-    	else {
-            g = factory.build_Atom(c);
-            c.followingNFAState = g.right;
-    	}
-    	}
-
-    |   #( s:STRING_LITERAL  (as4:ast_suffix)? )
-    	{
-     	if ( grammar.type==Grammar.LEXER ) {
-     		g = factory.build_StringLiteralAtom(s);
-     	}
-     	else {
-             g = factory.build_Atom(s);
-             s.followingNFAState = g.right;
-     	}
-     	}
-
-    |   #( w:WILDCARD (as5:ast_suffix)? )
-        {
-        if ( nfa.grammar.type==Grammar.TREE_PARSER ) {
-            g = factory.build_WildcardTree(#w);
-        }
-        else {
-            g = factory.build_Wildcard(#w);
-        }
-        }
-
-    |   #( DOT scope:ID g=atom[#scope.getText()] ) // scope override
-	;
-
-ast_suffix
-	:	ROOT
-	|	BANG
-	;
-
-set returns [StateCluster g=null]
-{
-IntSet elements=new IntervalSet();
-#set.setSetValue(elements); // track set for use by code gen
-}
-	:	#( b:BLOCK
-           (#(ALT (BACKTRACK_SEMPRED)? setElement[elements] EOA))+
-           EOB
-         )
-        {
-        g = factory.build_Set(elements,#b);
-        #b.followingNFAState = g.right;
-        #b.setSetValue(elements); // track set value of this block
-        }
-		//{System.out.println("set elements="+elements.toString(grammar));}
-	;
-
-setRule returns [IntSet elements=new IntervalSet()]
-{IntSet s=null;}
-	:	#( RULE id:ID (modifier)? ARG RET ( OPTIONS )? ( ruleScopeSpec )?
-		   	(AMPERSAND)*
-           	#( BLOCK ( OPTIONS )?
-           	   ( #(ALT (BACKTRACK_SEMPRED)? setElement[elements] EOA) )+
-           	   EOB
-           	 )
-           	(exceptionGroup)?
-           	EOR
-         )
-    ;
-    exception
-    	catch[RecognitionException re] {throw re;}
-
-setElement[IntSet elements]
-{
-    int ttype;
-    IntSet ns=null;
-    StateCluster gset;
-}
-    :   c:CHAR_LITERAL
-        {
-     	if ( grammar.type==Grammar.LEXER ) {
-        	ttype = Grammar.getCharValueFromGrammarCharLiteral(c.getText());
-     	}
-     	else {
-        	ttype = grammar.getTokenType(c.getText());
-        }
-        if ( elements.member(ttype) ) {
-			ErrorManager.grammarError(ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-									  grammar,
-									  #c.token,
-									  #c.getText());
-        }
-        elements.add(ttype);
-        }
-    |   t:TOKEN_REF
-        {
-		if ( grammar.type==Grammar.LEXER ) {
-			// recursively will invoke this rule to match elements in target rule ref
-			IntSet ruleSet = grammar.getSetFromRule(this,#t.getText());
-			if ( ruleSet==null ) {
-				ErrorManager.grammarError(ErrorManager.MSG_RULE_INVALID_SET,
-								  grammar,
-								  #t.token,
-								  #t.getText());
-			}
-			else {
-				elements.addAll(ruleSet);
-			}
-		}
-		else {
-			ttype = grammar.getTokenType(t.getText());
-			if ( elements.member(ttype) ) {
-				ErrorManager.grammarError(ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-										  grammar,
-										  #t.token,
-										  #t.getText());
-			}
-			elements.add(ttype);
-			}
-        }
-
-    |   s:STRING_LITERAL
-        {
-        ttype = grammar.getTokenType(s.getText());
-        if ( elements.member(ttype) ) {
-			ErrorManager.grammarError(ErrorManager.MSG_DUPLICATE_SET_ENTRY,
-									  grammar,
-									  #s.token,
-									  #s.getText());
-        }
-        elements.add(ttype);
-        }
-    |	#(CHAR_RANGE c1:CHAR_LITERAL c2:CHAR_LITERAL)
-    	{
-     	if ( grammar.type==Grammar.LEXER ) {
-	        int a = Grammar.getCharValueFromGrammarCharLiteral(c1.getText());
-    	    int b = Grammar.getCharValueFromGrammarCharLiteral(c2.getText());
-    		elements.addAll(IntervalSet.of(a,b));
-     	}
-    	}
-
-	|   gset=set
-        {
-		Transition setTrans = gset.left.transition(0);
-        elements.addAll(setTrans.label.getSet());
-        }
-
-    |   #(  NOT {ns=new IntervalSet();}
-            setElement[ns]
-            {
-                IntSet not = grammar.complement(ns);
-                elements.addAll(not);
-            }
-        )
-    ;
-
-/** Check to see if this block can be a set.  Can't have actions
- *  etc...  Also can't be in a rule with a rewrite as we need
- *  to track what's inside set for use in rewrite.
- */
-testBlockAsSet
-{
-    int nAlts=0;
-    Rule r = grammar.getLocallyDefinedRule(currentRuleName);
-}
-	:   #( BLOCK
-           (   #(ALT (BACKTRACK_SEMPRED)? testSetElement {nAlts++;} EOA)
-                {!r.hasRewrite(outerAltNum)}?
-           )+
-           EOB
-        )
-        {nAlts>1}? // set of 1 element is not good
-	;
-    exception
-    	catch[RecognitionException re] {throw re;}
-
-testSetRule
-	:	#( RULE id:ID (modifier)? ARG RET ( OPTIONS )? ( ruleScopeSpec )?
-		   	(AMPERSAND)*
-            #( BLOCK
-                ( #(ALT (BACKTRACK_SEMPRED)? testSetElement EOA) )+
-                EOB
-            )
-           	(exceptionGroup)?
-           	EOR
-         )
-    ;
-    exception
-    	catch[RecognitionException re] {throw re;}
-
-/** Match just an element; no ast suffix etc.. */
-testSetElement
-{
-AST r = _t;
-}
-    :   c:CHAR_LITERAL
-    |   t:TOKEN_REF
-        {
-		if ( grammar.type==Grammar.LEXER ) {
-	        Rule rule = grammar.getRule(#t.getText());
-	        if ( rule==null ) {
-	        	throw new RecognitionException("invalid rule");
-	        }
-			// recursively will invoke this rule to match elements in target rule ref
-	        testSetRule(rule.tree);
-		}
-        }
-    |   {grammar.type!=Grammar.LEXER}? s:STRING_LITERAL
-    |	#(CHAR_RANGE c1:CHAR_LITERAL c2:CHAR_LITERAL)
-	|   testBlockAsSet
-    |   #( NOT testSetElement )
-    ;
-    exception
-     	catch[RecognitionException re] {throw re;}
diff --git a/tool/src/main/antlr2/org/antlr/grammar/v2/codegen.g b/tool/src/main/antlr2/org/antlr/grammar/v2/codegen.g
deleted file mode 100644
index 83e483d..0000000
--- a/tool/src/main/antlr2/org/antlr/grammar/v2/codegen.g
+++ /dev/null
@@ -1,1434 +0,0 @@
-header {
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-	package org.antlr.grammar.v2;
-    import org.antlr.tool.*;
-    import org.antlr.analysis.*;
-    import org.antlr.misc.*;
-	import java.util.*;
-	import org.antlr.stringtemplate.*;
-    import antlr.TokenWithIndex;
-    import antlr.CommonToken;
-    import org.antlr.codegen.*;
-}
-
-/** Walk a grammar and generate code by gradually building up
- *  a bigger and bigger StringTemplate.
- *
- *  Terence Parr
- *  University of San Francisco
- *  June 15, 2004
- */
-class CodeGenTreeWalker extends TreeParser;
-
-options {
-    // warning! ANTLR cannot see another directory to get vocabs, so I had
-    // to copy the ANTLRTokenTypes.txt file into this dir from ../tools!
-    // Yuck!  If you modify ../tools/antlr.g, make sure to copy the vocab here.
-	importVocab = ANTLR;
-    codeGenBitsetTestThreshold=999;
-    ASTLabelType=GrammarAST;
-}
-
-{
-	protected static final int RULE_BLOCK_NESTING_LEVEL = 0;
-	protected static final int OUTER_REWRITE_NESTING_LEVEL = 0;
-
-    public String getCurrentRuleName() {
-        return currentRuleName;
-    }
-
-    public void setCurrentRuleName(String currentRuleName) {
-        this.currentRuleName = currentRuleName;
-    }
-
-    public int getOuterAltNum() {
-        return outerAltNum;
-    }
-
-    public void setOuterAltNum(int outerAltNum) {
-        this.outerAltNum = outerAltNum;
-    }
-
-    protected String currentRuleName = null;
-    protected int blockNestingLevel = 0;
-    protected int rewriteBlockNestingLevel = 0;
-	protected int outerAltNum = 0;
-    protected StringTemplate currentBlockST = null;
-    protected boolean currentAltHasASTRewrite = false;
-    protected int rewriteTreeNestingLevel = 0;
-    protected Set rewriteRuleRefs = null;
-
-    public void reportError(RecognitionException ex) {
-		Token token = null;
-		if ( ex instanceof MismatchedTokenException ) {
-			token = ((MismatchedTokenException)ex).token;
-		}
-		else if ( ex instanceof NoViableAltException ) {
-			token = ((NoViableAltException)ex).token;
-		}
-        ErrorManager.syntaxError(
-            ErrorManager.MSG_SYNTAX_ERROR,
-            grammar,
-            token,
-            "codegen: "+ex.toString(),
-            ex);
-    }
-
-    public void reportError(String s) {
-        System.out.println("codegen: error: " + s);
-    }
-
-    protected CodeGenerator generator;
-    protected Grammar grammar;
-    protected StringTemplateGroup templates;
-
-    /** The overall lexer/parser template; simulate dynamically scoped
-     *  attributes by making this an instance var of the walker.
-     */
-    protected StringTemplate recognizerST;
-
-    protected StringTemplate outputFileST;
-    protected StringTemplate headerFileST;
-
-    protected String outputOption = "";
-
-	protected StringTemplate getWildcardST(GrammarAST elementAST, GrammarAST ast_suffix, String label) {
-		String name = "wildcard";
-		if ( grammar.type==Grammar.LEXER ) {
-			name = "wildcardChar";
-		}
-		return getTokenElementST(name, name, elementAST, ast_suffix, label);
-	}
-
-	protected StringTemplate getRuleElementST(String name,
-										      String ruleTargetName,
-											  GrammarAST elementAST,
-    										  GrammarAST ast_suffix,
-    										  String label)
-	{
-		String suffix = getSTSuffix(elementAST,ast_suffix,label);
-		name += suffix;
-		// if we're building trees and there is no label, gen a label
-		// unless we're in a synpred rule.
-		Rule r = grammar.getRule(currentRuleName);
-		if ( (grammar.buildAST()||suffix.length()>0) && label==null &&
-		     (r==null || !r.isSynPred) )
-		{
-			// we will need a label to do the AST or tracking, make one
-			label = generator.createUniqueLabel(ruleTargetName);
-			CommonToken labelTok = new CommonToken(ANTLRParser.ID, label);
-			grammar.defineRuleRefLabel(currentRuleName, labelTok, elementAST);
-		}
-		StringTemplate elementST = templates.getInstanceOf(name);
-		if ( label!=null ) {
-			elementST.setAttribute("label", label);
-		}
-		return elementST;
-	}
-
-	protected StringTemplate getTokenElementST(String name,
-											   String elementName,
-											   GrammarAST elementAST,
-											   GrammarAST ast_suffix,
-											   String label)
-	{
-		String suffix = getSTSuffix(elementAST,ast_suffix,label);
-		name += suffix;
-		// if we're building trees and there is no label, gen a label
-		// unless we're in a synpred rule.
-		Rule r = grammar.getRule(currentRuleName);
-		if ( (grammar.buildAST()||suffix.length()>0) && label==null &&
-		     (r==null || !r.isSynPred) )
-		{
-			label = generator.createUniqueLabel(elementName);
-			CommonToken labelTok = new CommonToken(ANTLRParser.ID, label);
-			grammar.defineTokenRefLabel(currentRuleName, labelTok, elementAST);
-		}
-		StringTemplate elementST = templates.getInstanceOf(name);
-		if ( label!=null ) {
-			elementST.setAttribute("label", label);
-		}
-		return elementST;
-	}
-
-    public boolean isListLabel(String label) {
-		boolean hasListLabel=false;
-		if ( label!=null ) {
-			Rule r = grammar.getRule(currentRuleName);
-			String stName = null;
-			if ( r!=null ) {
-				Grammar.LabelElementPair pair = r.getLabel(label);
-				if ( pair!=null &&
-					 (pair.type==Grammar.TOKEN_LIST_LABEL||
-					  pair.type==Grammar.RULE_LIST_LABEL||
-					  pair.type==Grammar.WILDCARD_TREE_LIST_LABEL) )
-				{
-					hasListLabel=true;
-				}
-			}
-		}
-        return hasListLabel;
-    }
-
-	/** Return a non-empty template name suffix if the token is to be
-	 *  tracked, added to a tree, or both.
-	 */
-	protected String getSTSuffix(GrammarAST elementAST, GrammarAST ast_suffix, String label) {
-		if ( grammar.type==Grammar.LEXER ) {
-			return "";
-		}
-		// handle list label stuff; make element use "Track"
-
-		String operatorPart = "";
-		String rewritePart = "";
-		String listLabelPart = "";
-		Rule ruleDescr = grammar.getRule(currentRuleName);
-		if ( ast_suffix!=null && !ruleDescr.isSynPred ) {
-			if ( ast_suffix.getType()==ANTLRParser.ROOT ) {
-    			operatorPart = "RuleRoot";
-    		}
-    		else if ( ast_suffix.getType()==ANTLRParser.BANG ) {
-    			operatorPart = "Bang";
-    		}
-   		}
-		if ( currentAltHasASTRewrite && elementAST.getType()!=WILDCARD ) {
-			rewritePart = "Track";
-		}
-		if ( isListLabel(label) ) {
-			listLabelPart = "AndListLabel";
-		}
-		String STsuffix = operatorPart+rewritePart+listLabelPart;
-		//System.out.println("suffix = "+STsuffix);
-
-    	return STsuffix;
-	}
-
-    /** Convert rewrite AST lists to target labels list */
-    protected List<String> getTokenTypesAsTargetLabels(Set<GrammarAST> refs) {
-        if ( refs==null || refs.size()==0 ) {
-            return null;
-        }
-        List<String> labels = new ArrayList<String>(refs.size());
-        for (GrammarAST t : refs) {
-            String label;
-            if ( t.getType()==ANTLRParser.RULE_REF ) {
-                label = t.getText();
-            }
-            else if ( t.getType()==ANTLRParser.TOKEN_REF ) {
-                label = t.getText();
-            }
-            else if ( t.getType()==ANTLRParser.LABEL ) {
-                label = t.getText();
-            }
-            else {
-                // must be char or string literal
-                label = generator.getTokenTypeAsTargetLabel(
-                            grammar.getTokenType(t.getText()));
-            }
-            labels.add(label);
-        }
-        return labels;
-    }
-
-    public void init(Grammar g) {
-        this.grammar = g;
-        this.generator = grammar.getCodeGenerator();
-        this.templates = generator.getTemplates();
-    }
-}
-
-grammar[Grammar g,
-        StringTemplate recognizerST,
-        StringTemplate outputFileST,
-        StringTemplate headerFileST]
-{
-    init(g);
-    this.recognizerST = recognizerST;
-    this.outputFileST = outputFileST;
-    this.headerFileST = headerFileST;
-    String superClass = (String)g.getOption("superClass");
-    outputOption = (String)g.getOption("output");
-    recognizerST.setAttribute("superClass", superClass);
-    if ( g.type!=Grammar.LEXER ) {
-		recognizerST.setAttribute("ASTLabelType", g.getOption("ASTLabelType"));
-	}
-    if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
-		ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
-								   g,
-								   null,
-								   g.name);
-	}
-    if ( g.type!=Grammar.TREE_PARSER ) {
-		recognizerST.setAttribute("labelType", g.getOption("TokenLabelType"));
-	}
-	recognizerST.setAttribute("numRules", grammar.getRules().size());
-	outputFileST.setAttribute("numRules", grammar.getRules().size());
-	headerFileST.setAttribute("numRules", grammar.getRules().size());
-}
-    :   ( #( LEXER_GRAMMAR grammarSpec )
-	    | #( PARSER_GRAMMAR grammarSpec )
-	    | #( TREE_GRAMMAR grammarSpec
-	       )
-	    | #( COMBINED_GRAMMAR grammarSpec )
-	    )
-    ;
-
-attrScope
-	:	#( "scope" ID ACTION )
-	;
-
-grammarSpec
-	:   name:ID
-		(cmt:DOC_COMMENT
-		 {
-		 outputFileST.setAttribute("docComment", #cmt.getText());
-		 headerFileST.setAttribute("docComment", #cmt.getText());
-		 }
-		)?
-		{
-		recognizerST.setAttribute("name", grammar.getRecognizerName());
-		outputFileST.setAttribute("name", grammar.getRecognizerName());
-		headerFileST.setAttribute("name", grammar.getRecognizerName());
-		recognizerST.setAttribute("scopes", grammar.getGlobalScopes());
-		headerFileST.setAttribute("scopes", grammar.getGlobalScopes());
-		}
-		( #(OPTIONS .) )?
-		( #(IMPORT .) )?
-		( #(TOKENS .) )?
-        (attrScope)*
-        (AMPERSAND)*
-		rules[recognizerST]
-	;
-
-rules[StringTemplate recognizerST]
-{
-StringTemplate rST;
-}
-    :   (	(	{
-    			String ruleName = _t.getFirstChild().getText();
-    			Rule r = grammar.getRule(ruleName);
-    			}
-     		:
-                {grammar.generateMethodForRule(ruleName)}?
-    			rST=rule
-				{
-				if ( rST!=null ) {
-					recognizerST.setAttribute("rules", rST);
-					outputFileST.setAttribute("rules", rST);
-					headerFileST.setAttribute("rules", rST);
-				}
-				}
-    		|	RULE
-    		|   PREC_RULE // ignore
-    		)
-   		)+
-    ;
-
-rule returns [StringTemplate code=null]
-{
-    String r;
-    String initAction = null;
-    StringTemplate b;
-	// get the dfa for the BLOCK
-    GrammarAST block=#rule.getFirstChildWithType(BLOCK);
-    DFA dfa=block.getLookaheadDFA();
-	// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
-	// for alts of rule
-	blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
-	Rule ruleDescr = grammar.getRule(#rule.getFirstChild().getText());
-
-	// For syn preds, we don't want any AST code etc... in there.
-	// Save old templates ptr and restore later.  Base templates include Dbg.
-	StringTemplateGroup saveGroup = templates;
-	if ( ruleDescr.isSynPred ) {
-		templates = generator.getBaseTemplates();
-	}
-}
-    :   #( RULE id:ID {r=#id.getText(); currentRuleName = r;}
-		    (mod:modifier)?
-            #(ARG (ARG_ACTION)?)
-            #(RET (ARG_ACTION)?)
-			( #(OPTIONS .) )?
-			(ruleScopeSpec)?
-		    (AMPERSAND)*
-            b=block["ruleBlock", dfa]
-			{
-			String description =
-				grammar.grammarTreeToString(#rule.getFirstChildWithType(BLOCK),
-                                            false);
-			description =
-                generator.target.getTargetStringLiteralFromString(description);
-			b.setAttribute("description", description);
-			// do not generate lexer rules in combined grammar
-			String stName = null;
-			if ( ruleDescr.isSynPred ) {
-				stName = "synpredRule";
-			}
-			else if ( grammar.type==Grammar.LEXER ) {
-				if ( r.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ) {
-					stName = "tokensRule";
-				}
-				else {
-					stName = "lexerRule";
-				}
-			}
-			else {
-				if ( !(grammar.type==Grammar.COMBINED &&
-					 Character.isUpperCase(r.charAt(0))) )
-				{
-					stName = "rule";
-				}
-			}
-			code = templates.getInstanceOf(stName);
-			if ( code.getName().equals("rule") ) {
-				code.setAttribute("emptyRule",
-					Boolean.valueOf(grammar.isEmptyRule(block)));
-			}
-			code.setAttribute("ruleDescriptor", ruleDescr);
-			String memo = (String)grammar.getBlockOption(#rule,"memoize");
-			if ( memo==null ) {
-				memo = (String)grammar.getOption("memoize");
-			}
-			if ( memo!=null && memo.equals("true") &&
-			     (stName.equals("rule")||stName.equals("lexerRule")) )
-			{
-            	code.setAttribute("memoize",
-            		Boolean.valueOf(memo!=null && memo.equals("true")));
-            }
-			}
-
-	     	(exceptionGroup[code])?
-	     	EOR
-         )
-        {
-        if ( code!=null ) {
-			if ( grammar.type==Grammar.LEXER ) {
-		    	boolean naked =
-		    		r.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
-		    	    (mod!=null&&mod.getText().equals(Grammar.FRAGMENT_RULE_MODIFIER));
-		    	code.setAttribute("nakedBlock", Boolean.valueOf(naked));
-			}
-			else {
-				description =
-					grammar.grammarTreeToString(#rule,false);
-				description =
-				    generator.target.getTargetStringLiteralFromString(description);
-				code.setAttribute("description", description);
-			}
-			Rule theRule = grammar.getRule(r);
-			generator.translateActionAttributeReferencesForSingleScope(
-				theRule,
-				theRule.getActions()
-			);
-			code.setAttribute("ruleName", r);
-			code.setAttribute("block", b);
-			if ( initAction!=null ) {
-				code.setAttribute("initAction", initAction);
-			}
-        }
-		templates = saveGroup;
-        }
-    ;
-
-modifier
-	:	"protected"
-	|	"public"
-	|	"private"
-	|	"fragment"
-	;
-
-ruleScopeSpec
- 	:	#( "scope" (ACTION)? ( ID )* )
- 	;
-
-block[String blockTemplateName, DFA dfa]
-     returns [StringTemplate code=null]
-{
-    StringTemplate decision = null;
-    if ( dfa!=null ) {
-        code = templates.getInstanceOf(blockTemplateName);
-        decision = generator.genLookaheadDecision(recognizerST,dfa);
-        code.setAttribute("decision", decision);
-        code.setAttribute("decisionNumber", dfa.getDecisionNumber());
-		code.setAttribute("maxK",dfa.getMaxLookaheadDepth());
-		code.setAttribute("maxAlt",dfa.getNumberOfAlts());
-    }
-    else {
-        code = templates.getInstanceOf(blockTemplateName+"SingleAlt");
-    }
-    blockNestingLevel++;
-    code.setAttribute("blockLevel", blockNestingLevel);
-    code.setAttribute("enclosingBlockLevel", blockNestingLevel-1);
-    StringTemplate alt = null;
-    StringTemplate rew = null;
-    StringTemplate sb = null;
-    GrammarAST r = null;
-    int altNum = 1;
-	if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
-        this.outerAltNum=1;
-    }
-}
-    :   {#block.getSetValue()!=null}? sb=setBlock
-        {
-            code.setAttribute("alts",sb);
-            blockNestingLevel--;
-        }
-
-    |   #(  BLOCK
-    	    ( OPTIONS )? // ignore
-            ( alt=alternative {r=(GrammarAST)_t;} rew=rewrite
-              {
-              if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
-              	this.outerAltNum++;
-              }
-              // add the rewrite code as just another element in the alt :)
-              // (unless it's a " -> ..." rewrite
-              // ( -> ... )
-              GrammarAST firstRewriteAST = (GrammarAST)r.findFirstType(REWRITE);
-              boolean etc =
-              	r.getType()==REWRITES &&
-              	firstRewriteAST.getFirstChild()!=null &&
-		  		firstRewriteAST.getFirstChild().getType()==ETC;
-    		  if ( rew!=null && !etc ) { alt.setAttribute("rew", rew); }
-    		  // add this alt to the list of alts for this block
-              code.setAttribute("alts",alt);
-              alt.setAttribute("altNum", Utils.integer(altNum));
-              alt.setAttribute("outerAlt",
-                  Boolean.valueOf(blockNestingLevel==RULE_BLOCK_NESTING_LEVEL));
-              altNum++;
-              }
-            )+
-            EOB
-         )
-    	{blockNestingLevel--;}
-    ;
-
-setBlock returns [StringTemplate code=null]
-{
-StringTemplate setcode = null;
-if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.buildAST() ) {
-    Rule r = grammar.getRule(currentRuleName);
-    currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
-    if ( currentAltHasASTRewrite ) {
-        r.trackTokenReferenceInAlt(#setBlock, outerAltNum);
-    }
-}
-}
-    :   s:BLOCK
-        {
-        int i = ((TokenWithIndex)#s.getToken()).getIndex();
-		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
-			setcode = getTokenElementST("matchRuleBlockSet", "set", #s, null, null);
-		}
-		else {
-			setcode = getTokenElementST("matchSet", "set", #s, null, null);
-		}
-		setcode.setAttribute("elementIndex", i);
-//		if ( grammar.type!=Grammar.LEXER ) {
-//			generator.generateLocalFOLLOW(#s,"set",currentRuleName,i);
-//        }
-        setcode.setAttribute("s",
-            generator.genSetExpr(templates,#s.getSetValue(),1,false));
-        StringTemplate altcode=templates.getInstanceOf("alt");
-		altcode.setAttribute("elements.{el,line,pos}",
-						     setcode,
-                             Utils.integer(#s.getLine()),
-                             Utils.integer(#s.getColumn())
-                            );
-        altcode.setAttribute("altNum", Utils.integer(1));
-        altcode.setAttribute("outerAlt",
-           Boolean.valueOf(blockNestingLevel==RULE_BLOCK_NESTING_LEVEL));
-        if ( !currentAltHasASTRewrite && grammar.buildAST() ) {
-            altcode.setAttribute("autoAST", Boolean.valueOf(true));
-        }
-        altcode.setAttribute("treeLevel", rewriteTreeNestingLevel);
-        code = altcode;
-        }
-    ;
-
-exceptionGroup[StringTemplate ruleST]
-	:	( exceptionHandler[ruleST] )+ (finallyClause[ruleST])?
-	|   finallyClause[ruleST]
-    ;
-
-exceptionHandler[StringTemplate ruleST]
-    :    #("catch" ARG_ACTION ACTION)
-    	{
-    	List chunks = generator.translateAction(currentRuleName,#ACTION);
-    	ruleST.setAttribute("exceptions.{decl,action}",#ARG_ACTION.getText(),chunks);
-    	}
-    ;
-
-finallyClause[StringTemplate ruleST]
-    :    #("finally" ACTION)
-    	{
-    	List chunks = generator.translateAction(currentRuleName,#ACTION);
-    	ruleST.setAttribute("finally",chunks);
-    	}
-    ;
-
-alternative returns [StringTemplate code=templates.getInstanceOf("alt")]
-{
-if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.buildAST() ) {
-    Rule r = grammar.getRule(currentRuleName);
-    currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
-}
-String description = grammar.grammarTreeToString(#alternative, false);
-description = generator.target.getTargetStringLiteralFromString(description);
-code.setAttribute("description", description);
-code.setAttribute("treeLevel", rewriteTreeNestingLevel);
-if ( !currentAltHasASTRewrite && grammar.buildAST() ) {
-	code.setAttribute("autoAST", Boolean.valueOf(true));
-}
-StringTemplate e;
-}
-    :   #(	a:ALT
-    		(	{GrammarAST elAST=(GrammarAST)_t;}
-    			e=element[null,null]
-    			{
-    			if ( e!=null ) {
-					code.setAttribute("elements.{el,line,pos}",
-									  e,
-									  Utils.integer(elAST.getLine()),
-									  Utils.integer(elAST.getColumn())
-									 );
-    			}
-    			}
-    		)+
-    		EOA
-    	 )
-    ;
-
-element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
-{
-    IntSet elements=null;
-    GrammarAST ast = null;
-}
-    :   #(ROOT code=element[label,#ROOT])
-
-    |   #(BANG code=element[label,#BANG])
-
-    |   #( n:NOT code=notElement[#n, label, astSuffix] )
-
-    |	#( ASSIGN alabel:ID code=element[#alabel,astSuffix] )
-
-    |	#( PLUS_ASSIGN label2:ID code=element[#label2,astSuffix] )
-
-    |   #(CHAR_RANGE a:CHAR_LITERAL b:CHAR_LITERAL)
-        {code = templates.getInstanceOf("charRangeRef");
-		 String low =
-		 	generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,a.getText());
-		 String high =
-		 	generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,b.getText());
-         code.setAttribute("a", low);
-         code.setAttribute("b", high);
-         if ( label!=null ) {
-             code.setAttribute("label", label.getText());
-         }
-        }
-
-    |   {#element.getSetValue()==null}? code=ebnf
-
-    |   code=atom[null, label, astSuffix]
-
-    |   code=tree
-
-    |   code=element_action
-
-    |   (sp:SEMPRED|gsp:GATED_SEMPRED {#sp=#gsp;})
-        {
-        code = templates.getInstanceOf("validateSemanticPredicate");
-        code.setAttribute("pred", generator.translateAction(currentRuleName,#sp));
-		String description =
-			generator.target.getTargetStringLiteralFromString(#sp.getText());
-		code.setAttribute("description", description);
-        }
-
-    |	SYN_SEMPRED // used only in lookahead; don't generate validating pred
-
-    |	BACKTRACK_SEMPRED
-
-    |   EPSILON
-    ;
-
-element_action returns [StringTemplate code=null]
-    :   act:ACTION
-        {
-        code = templates.getInstanceOf("execAction");
-        code.setAttribute("action", generator.translateAction(currentRuleName,#act));
-        }
-    |   act2:FORCED_ACTION
-        {
-        code = templates.getInstanceOf("execForcedAction");
-        code.setAttribute("action", generator.translateAction(currentRuleName,#act2));
-        }
-    ;
-
-notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix]
-returns [StringTemplate code=null]
-{
-    IntSet elements=null;
-    String labelText = null;
-    if ( label!=null ) {
-        labelText = label.getText();
-    }
-}
-    :   (assign_c:CHAR_LITERAL
-        {
-        int ttype=0;
-        if ( grammar.type==Grammar.LEXER ) {
-            ttype = Grammar.getCharValueFromGrammarCharLiteral(assign_c.getText());
-        }
-        else {
-            ttype = grammar.getTokenType(assign_c.getText());
-        }
-        elements = grammar.complement(ttype);
-        }
-    |   assign_s:STRING_LITERAL
-        {
-        int ttype=0;
-        if ( grammar.type==Grammar.LEXER ) {
-            // TODO: error!
-        }
-        else {
-            ttype = grammar.getTokenType(assign_s.getText());
-        }
-        elements = grammar.complement(ttype);
-        }
-    |   assign_t:TOKEN_REF
-        {
-        int ttype = grammar.getTokenType(assign_t.getText());
-        elements = grammar.complement(ttype);
-        }
-    |   assign_st:BLOCK
-        {
-        elements = assign_st.getSetValue();
-        elements = grammar.complement(elements);
-        }
-        )
-        {
-        code = getTokenElementST("matchSet",
-                                 "set",
-                                 (GrammarAST)n.getFirstChild(),
-                                 astSuffix,
-                                 labelText);
-        code.setAttribute("s",generator.genSetExpr(templates,elements,1,false));
-        int i = ((TokenWithIndex)n.getToken()).getIndex();
-        code.setAttribute("elementIndex", i);
-        if ( grammar.type!=Grammar.LEXER ) {
-            generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
-        }
-        }
-    ;
-
-ebnf returns [StringTemplate code=null]
-{
-    DFA dfa=null;
-    GrammarAST b = (GrammarAST)#ebnf.getFirstChild();
-    GrammarAST eob = (GrammarAST)#b.getLastChild(); // loops will use EOB DFA
-}
-    :   (	{dfa = #ebnf.getLookaheadDFA();}
-			code=block["block", dfa]
-		|   {dfa = #ebnf.getLookaheadDFA();}
-			#( OPTIONAL code=block["optionalBlock", dfa] )
-		|   {dfa = #eob.getLookaheadDFA();}
-			#( CLOSURE code=block["closureBlock", dfa] )
-		|   {dfa = #eob.getLookaheadDFA();}
-			#( POSITIVE_CLOSURE code=block["positiveClosureBlock", dfa] )
-		)
-		{
-		String description = grammar.grammarTreeToString(#ebnf, false);
-		description = generator.target.getTargetStringLiteralFromString(description);
-    	code.setAttribute("description", description);
-    	}
-    ;
-
-tree returns [StringTemplate code=templates.getInstanceOf("tree")]
-{
-StringTemplate el=null, act=null;
-GrammarAST elAST=null, actAST=null;
-NFAState afterDOWN = (NFAState)tree_AST_in.NFATreeDownState.transition(0).target;
-LookaheadSet s = grammar.LOOK(afterDOWN);
-if ( s.member(Label.UP) ) {
-	// nullable child list if we can see the UP as the next token
-	// we need an "if ( input.LA(1)==Token.DOWN )" gate around
-	// the child list.
-	code.setAttribute("nullableChildList", "true");
-}
-rewriteTreeNestingLevel++;
-code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
-code.setAttribute("treeLevel", rewriteTreeNestingLevel);
-Rule r = grammar.getRule(currentRuleName);
-GrammarAST rootSuffix = null;
-if ( grammar.buildAST() && !r.hasRewrite(outerAltNum) ) {
-	rootSuffix = new GrammarAST(ROOT,"ROOT");
-}
-}
-    :   #( TREE_BEGIN {elAST=(GrammarAST)_t;}
-    	   el=element[null,rootSuffix]
-           {
-           code.setAttribute("root.{el,line,pos}",
-							  el,
-							  Utils.integer(elAST.getLine()),
-							  Utils.integer(elAST.getColumn())
-							  );
-           }
-           // push all the immediately-following actions out before children
-           // so actions aren't guarded by the "if (input.LA(1)==Token.DOWN)"
-           // guard in generated code.
-           (    options {greedy=true;}:
-                {actAST=(GrammarAST)_t;}
-                act=element_action
-                {
-                code.setAttribute("actionsAfterRoot.{el,line,pos}",
-                                  act,
-                                  Utils.integer(actAST.getLine()),
-                                  Utils.integer(actAST.getColumn())
-                );
-                }
-           )*
-           ( {elAST=(GrammarAST)_t;}
-    		 el=element[null,null]
-           	 {
-			 code.setAttribute("children.{el,line,pos}",
-							  el,
-							  Utils.integer(elAST.getLine()),
-							  Utils.integer(elAST.getColumn())
-							  );
-			 }
-           )*
-         )
-         {rewriteTreeNestingLevel--;}
-    ;
-
-atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
-    returns [StringTemplate code=null]
-{
-String labelText=null;
-if ( label!=null ) {
-    labelText = label.getText();
-}
-if ( grammar.type!=Grammar.LEXER &&
-     (#atom.getType()==RULE_REF||#atom.getType()==TOKEN_REF||
-      #atom.getType()==CHAR_LITERAL||#atom.getType()==STRING_LITERAL) )
-{
-	Rule encRule = grammar.getRule(((GrammarAST)#atom).enclosingRuleName);
-	if ( encRule!=null && encRule.hasRewrite(outerAltNum) && astSuffix!=null ) {
-		ErrorManager.grammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
-								  grammar,
-								  ((GrammarAST)#atom).getToken(),
-								  ((GrammarAST)#atom).enclosingRuleName,
-								  new Integer(outerAltNum));
-		astSuffix = null;
-	}
-}
-}
-    :   #( r:RULE_REF (rarg:ARG_ACTION)? )
-        {
-        grammar.checkRuleReference(scope, #r, #rarg, currentRuleName);
-        String scopeName = null;
-        if ( scope!=null ) {
-            scopeName = scope.getText();
-        }
-        Rule rdef = grammar.getRule(scopeName, #r.getText());
-        // don't insert label=r() if $label.attr not used, no ret value, ...
-        if ( !rdef.getHasReturnValue() ) {
-            labelText = null;
-        }
-        code = getRuleElementST("ruleRef", #r.getText(), #r, astSuffix, labelText);
-		code.setAttribute("rule", rdef);
-        if ( scope!=null ) { // scoped rule ref
-            Grammar scopeG = grammar.composite.getGrammar(scope.getText());
-            code.setAttribute("scope", scopeG);
-        }
-        else if ( rdef.grammar != this.grammar ) { // nonlocal
-            // if rule definition is not in this grammar, it's nonlocal
-			List<Grammar> rdefDelegates = rdef.grammar.getDelegates();
-			if ( rdefDelegates.contains(this.grammar) ) {
-				code.setAttribute("scope", rdef.grammar);
-			}
-			else {
-				// defining grammar is not a delegate, scope all the
-				// back to root, which has delegate methods for all
-				// rules.  Don't use scope if we are root.
-				if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
-					code.setAttribute("scope",
-									  rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
-				}
-			}
-        }
-
-		if ( #rarg!=null ) {
-			List args = generator.translateAction(currentRuleName,#rarg);
-			code.setAttribute("args", args);
-		}
-        int i = ((TokenWithIndex)r.getToken()).getIndex();
-		code.setAttribute("elementIndex", i);
-		generator.generateLocalFOLLOW(#r,#r.getText(),currentRuleName,i);
-		#r.code = code;
-        }
-
-    |   #( t:TOKEN_REF (targ:ARG_ACTION)? )
-        {
-           if ( currentAltHasASTRewrite && #t.terminalOptions!=null &&
-                #t.terminalOptions.get(Grammar.defaultTokenOption)!=null ) {
-			ErrorManager.grammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
-									  grammar,
-									  ((GrammarAST)(#t)).getToken(),
-									  #t.getText());
-           }
-           grammar.checkRuleReference(scope, #t, #targ, currentRuleName);
-		   if ( grammar.type==Grammar.LEXER ) {
-				if ( grammar.getTokenType(t.getText())==Label.EOF ) {
-					code = templates.getInstanceOf("lexerMatchEOF");
-				}
-			    else {
-					code = templates.getInstanceOf("lexerRuleRef");
-                    if ( isListLabel(labelText) ) {
-                        code = templates.getInstanceOf("lexerRuleRefAndListLabel");
-                    }
-                    String scopeName = null;
-                    if ( scope!=null ) {
-                        scopeName = scope.getText();
-                    }
-                    Rule rdef2 = grammar.getRule(scopeName, #t.getText());
-					code.setAttribute("rule", rdef2);
-                    if ( scope!=null ) { // scoped rule ref
-                        Grammar scopeG = grammar.composite.getGrammar(scope.getText());
-                        code.setAttribute("scope", scopeG);
-                    }
-                    else if ( rdef2.grammar != this.grammar ) { // nonlocal
-                        // if rule definition is not in this grammar, it's nonlocal
-                        code.setAttribute("scope", rdef2.grammar);
-                    }
-					if ( #targ!=null ) {
-						List args = generator.translateAction(currentRuleName,#targ);
-						code.setAttribute("args", args);
-					}
-				}
-                int i = ((TokenWithIndex)#t.getToken()).getIndex();
-			    code.setAttribute("elementIndex", i);
-			    if ( label!=null ) code.setAttribute("label", labelText);
-		   }
-		   else {
-				code = getTokenElementST("tokenRef", #t.getText(), #t, astSuffix, labelText);
-				String tokenLabel =
-				   generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.getText()));
-				code.setAttribute("token",tokenLabel);
-				if ( !currentAltHasASTRewrite && #t.terminalOptions!=null ) {
-                    code.setAttribute("terminalOptions",#t.terminalOptions);
-                }
-                int i = ((TokenWithIndex)#t.getToken()).getIndex();
-			    code.setAttribute("elementIndex", i);
-			    generator.generateLocalFOLLOW(#t,tokenLabel,currentRuleName,i);
-		   }
-		   #t.code = code;
-		}
-
-    |   c:CHAR_LITERAL
-        {
-		if ( grammar.type==Grammar.LEXER ) {
-			code = templates.getInstanceOf("charRef");
-			code.setAttribute("char",
-			   generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,c.getText()));
-			if ( label!=null ) {
-				code.setAttribute("label", labelText);
-			}
-		}
-		else { // else it's a token type reference
-			code = getTokenElementST("tokenRef", "char_literal", #c, astSuffix, labelText);
-			String tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType(c.getText()));
-			code.setAttribute("token",tokenLabel);
-            if ( #c.terminalOptions!=null ) {
-                code.setAttribute("terminalOptions",#c.terminalOptions);
-            }
-            int i = ((TokenWithIndex)#c.getToken()).getIndex();
-			code.setAttribute("elementIndex", i);
-			generator.generateLocalFOLLOW(#c,tokenLabel,currentRuleName,i);
-		}
-        }
-
-    |   s:STRING_LITERAL
-        {
-        int i = ((TokenWithIndex)#s.getToken()).getIndex();
-		if ( grammar.type==Grammar.LEXER ) {
-			code = templates.getInstanceOf("lexerStringRef");
-			code.setAttribute("string",
-			   generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,s.getText()));
-			code.setAttribute("elementIndex", i);
-			if ( label!=null ) {
-				code.setAttribute("label", labelText);
-			}
-		}
-		else { // else it's a token type reference
-			code = getTokenElementST("tokenRef", "string_literal", #s, astSuffix, labelText);
-			String tokenLabel =
-			   generator.getTokenTypeAsTargetLabel(grammar.getTokenType(#s.getText()));
-			code.setAttribute("token",tokenLabel);
-            if ( #s.terminalOptions!=null ) {
-                code.setAttribute("terminalOptions",#s.terminalOptions);
-            }
-			code.setAttribute("elementIndex", i);
-			generator.generateLocalFOLLOW(#s,tokenLabel,currentRuleName,i);
-		}
-		}
-
-    |   w:WILDCARD
-        {
-		code = getWildcardST(#w,astSuffix,labelText);
-		code.setAttribute("elementIndex", ((TokenWithIndex)#w.getToken()).getIndex());
-		}
-
-    |   #(DOT ID code=atom[#ID, label, astSuffix]) // scope override on rule or token
-
-    |	code=set[label,astSuffix]
-    ;
-
-ast_suffix
-	:	ROOT
-	|	BANG
-	;
-
-
-set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
-{
-String labelText=null;
-if ( label!=null ) {
-    labelText = label.getText();
-}
-}
-	:   s:BLOCK // only care that it's a BLOCK with setValue!=null
-        {
-        code = getTokenElementST("matchSet", "set", #s, astSuffix, labelText);
-        int i = ((TokenWithIndex)#s.getToken()).getIndex();
-		code.setAttribute("elementIndex", i);
-		if ( grammar.type!=Grammar.LEXER ) {
-			generator.generateLocalFOLLOW(#s,"set",currentRuleName,i);
-        }
-        code.setAttribute("s", generator.genSetExpr(templates,#s.getSetValue(),1,false));
-        }
-    ;
-
-setElement
-    :   c:CHAR_LITERAL
-    |   t:TOKEN_REF
-    |   s:STRING_LITERAL
-    |	#(CHAR_RANGE c1:CHAR_LITERAL c2:CHAR_LITERAL)
-    ;
-
-// REWRITE stuff
-
-rewrite returns [StringTemplate code=null]
-{
-StringTemplate alt;
-//GrammarAST firstRewriteAST = (GrammarAST)#rewrite.getFirstChild();
-if ( #rewrite.getType()==REWRITES ) {
-	if ( generator.grammar.buildTemplate() ) {
-		code = templates.getInstanceOf("rewriteTemplate");
-	}
-	else {
-		code = templates.getInstanceOf("rewriteCode");
-		code.setAttribute("treeLevel", Utils.integer(OUTER_REWRITE_NESTING_LEVEL));
-		code.setAttribute("rewriteBlockLevel", Utils.integer(OUTER_REWRITE_NESTING_LEVEL));
-        code.setAttribute("referencedElementsDeep",
-                          getTokenTypesAsTargetLabels(#rewrite.rewriteRefsDeep));
-        Set<String> tokenLabels =
-            grammar.getLabels(#rewrite.rewriteRefsDeep, Grammar.TOKEN_LABEL);
-        Set<String> tokenListLabels =
-            grammar.getLabels(#rewrite.rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
-        Set<String> ruleLabels =
-            grammar.getLabels(#rewrite.rewriteRefsDeep, Grammar.RULE_LABEL);
-        Set<String> ruleListLabels =
-            grammar.getLabels(#rewrite.rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
-        Set<String> wildcardLabels =
-            grammar.getLabels(#rewrite.rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
-        Set<String> wildcardListLabels =
-            grammar.getLabels(#rewrite.rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
-        // just in case they ref $r for "previous value", make a stream
-        // from retval.tree
-        StringTemplate retvalST = templates.getInstanceOf("prevRuleRootRef");
-        ruleLabels.add(retvalST.toString());
-        code.setAttribute("referencedTokenLabels", tokenLabels);
-        code.setAttribute("referencedTokenListLabels", tokenListLabels);
-        code.setAttribute("referencedRuleLabels", ruleLabels);
-        code.setAttribute("referencedRuleListLabels", ruleListLabels);
-        code.setAttribute("referencedWildcardLabels", wildcardLabels);
-        code.setAttribute("referencedWildcardListLabels", wildcardListLabels);
-	}
-}
-else {
-		code = templates.getInstanceOf("noRewrite");
-		code.setAttribute("treeLevel", Utils.integer(OUTER_REWRITE_NESTING_LEVEL));
-		code.setAttribute("rewriteBlockLevel", Utils.integer(OUTER_REWRITE_NESTING_LEVEL));
-}
-}
-	:	#(REWRITES
-            (
-                {rewriteRuleRefs = new HashSet();}
-                #( r:REWRITE (pred:SEMPRED)? alt=rewrite_alternative )
-                {
-                rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
-                List predChunks = null;
-                if ( #pred!=null ) {
-                    //predText = #pred.getText();
-                    predChunks = generator.translateAction(currentRuleName,#pred);
-                }
-                String description =
-                    grammar.grammarTreeToString(#r,false);
-                description = generator.target.getTargetStringLiteralFromString(description);
-                code.setAttribute("alts.{pred,alt,description}",
-                                  predChunks,
-                                  alt,
-                                  description);
-                pred=null;
-                }
-            )*
-		)
-	|
-	;
-
-rewrite_block[String blockTemplateName] returns [StringTemplate code=null]
-{
-rewriteBlockNestingLevel++;
-code = templates.getInstanceOf(blockTemplateName);
-StringTemplate save_currentBlockST = currentBlockST;
-currentBlockST = code;
-code.setAttribute("rewriteBlockLevel", rewriteBlockNestingLevel);
-StringTemplate alt=null;
-}
-    :   #(  BLOCK
-            {
-            currentBlockST.setAttribute("referencedElementsDeep",
-                getTokenTypesAsTargetLabels(#BLOCK.rewriteRefsDeep));
-            currentBlockST.setAttribute("referencedElements",
-                getTokenTypesAsTargetLabels(#BLOCK.rewriteRefsShallow));
-            }
-            alt=rewrite_alternative
-            EOB
-         )
-    	{
-    	code.setAttribute("alt", alt);
-    	rewriteBlockNestingLevel--;
-    	currentBlockST = save_currentBlockST;
-    	}
-    ;
-
-rewrite_alternative
-	returns [StringTemplate code=null]
-{
-StringTemplate el,st;
-}
-    :   {generator.grammar.buildAST()}?
-    	#(	a:ALT {code=templates.getInstanceOf("rewriteElementList");}
-			(	(	{GrammarAST elAST=(GrammarAST)_t;}
-    				el=rewrite_element
-					{code.setAttribute("elements.{el,line,pos}",
-					 					el,
-    							  		Utils.integer(elAST.getLine()),
-    							  		Utils.integer(elAST.getColumn())
-					 					);
-					}
-				)+
-    		|	EPSILON
-    			{code.setAttribute("elements.{el,line,pos}",
-    							   templates.getInstanceOf("rewriteEmptyAlt"),
-    							   Utils.integer(#a.getLine()),
-    							   Utils.integer(#a.getColumn())
-					 			   );
-				}
-    		)
-    		EOA
-    	 )
-
-    |	{generator.grammar.buildTemplate()}? code=rewrite_template
-
-    |	// reproduce same input (only AST at moment)
-    	ETC
-    ;
-
-rewrite_element returns [StringTemplate code=null]
-{
-    IntSet elements=null;
-    GrammarAST ast = null;
-}
-    :   code=rewrite_atom[false]
-
-    |   code=rewrite_ebnf
-
-    |   code=rewrite_tree
-    ;
-
-rewrite_ebnf returns [StringTemplate code=null]
-    :   #( OPTIONAL code=rewrite_block["rewriteOptionalBlock"] )
-		{
-		String description = grammar.grammarTreeToString(#rewrite_ebnf, false);
-		description = generator.target.getTargetStringLiteralFromString(description);
-		code.setAttribute("description", description);
-		}
-    |   #( CLOSURE code=rewrite_block["rewriteClosureBlock"] )
-		{
-		String description = grammar.grammarTreeToString(#rewrite_ebnf, false);
-		description = generator.target.getTargetStringLiteralFromString(description);
-		code.setAttribute("description", description);
-		}
-    |   #( POSITIVE_CLOSURE code=rewrite_block["rewritePositiveClosureBlock"] )
-		{
-		String description = grammar.grammarTreeToString(#rewrite_ebnf, false);
-		description = generator.target.getTargetStringLiteralFromString(description);
-		code.setAttribute("description", description);
-		}
-    ;
-
-rewrite_tree returns [StringTemplate code=templates.getInstanceOf("rewriteTree")]
-{
-rewriteTreeNestingLevel++;
-code.setAttribute("treeLevel", rewriteTreeNestingLevel);
-code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
-StringTemplate r, el;
-GrammarAST elAST=null;
-}
-	:   #(	TREE_BEGIN {elAST=(GrammarAST)_t;}
-			r=rewrite_atom[true]
-			{code.setAttribute("root.{el,line,pos}",
-							   r,
-							   Utils.integer(elAST.getLine()),
-							   Utils.integer(elAST.getColumn())
-							  );
-			}
-			( {elAST=(GrammarAST)_t;}
-			  el=rewrite_element
-			  {
-			  code.setAttribute("children.{el,line,pos}",
-							    el,
-							    Utils.integer(elAST.getLine()),
-							    Utils.integer(elAST.getColumn())
-							    );
-			  }
-			)*
-		)
-		{
-		String description = grammar.grammarTreeToString(#rewrite_tree, false);
-		description = generator.target.getTargetStringLiteralFromString(description);
-		code.setAttribute("description", description);
-    	rewriteTreeNestingLevel--;
-		}
-    ;
-
-rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
-    :   r:RULE_REF
-    	{
-    	String ruleRefName = #r.getText();
-    	String stName = "rewriteRuleRef";
-    	if ( isRoot ) {
-    		stName += "Root";
-    	}
-    	code = templates.getInstanceOf(stName);
-    	code.setAttribute("rule", ruleRefName);
-    	if ( grammar.getRule(ruleRefName)==null ) {
-			ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
-									  grammar,
-									  ((GrammarAST)(#r)).getToken(),
-									  ruleRefName);
-    		code = new StringTemplate(); // blank; no code gen
-    	}
-    	else if ( grammar.getRule(currentRuleName)
-    			     .getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
-		{
-			ErrorManager.grammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
-									  grammar,
-									  ((GrammarAST)(#r)).getToken(),
-									  ruleRefName);
-    		code = new StringTemplate(); // blank; no code gen
-    	}
-    	else {
-    		// track all rule refs as we must copy 2nd ref to rule and beyond
-    		if ( !rewriteRuleRefs.contains(ruleRefName) ) {
-	    		rewriteRuleRefs.add(ruleRefName);
-    		}
-		}
-    	}
-
-    |   {GrammarAST term=(GrammarAST)_t;}
-		( #(tk:TOKEN_REF (arg:ARG_ACTION)?)
-        | cl:CHAR_LITERAL
-        | sl:STRING_LITERAL
-        )
-    	{
-    	String tokenName = #rewrite_atom.getText();
-    	String stName = "rewriteTokenRef";
-    	Rule rule = grammar.getRule(currentRuleName);
-    	Set tokenRefsInAlt = rule.getTokenRefsInAlt(outerAltNum);
-    	boolean createNewNode = !tokenRefsInAlt.contains(tokenName) || #arg!=null;
-    	if ( createNewNode ) {
-    		stName = "rewriteImaginaryTokenRef";
-    	}
-    	if ( isRoot ) {
-    		stName += "Root";
-    	}
-    	code = templates.getInstanceOf(stName);
-		code.setAttribute("terminalOptions",term.terminalOptions);
-    	if ( #arg!=null ) {
-			List args = generator.translateAction(currentRuleName,#arg);
-			code.setAttribute("args", args);
-    	}
-		code.setAttribute("elementIndex", ((TokenWithIndex)#rewrite_atom.getToken()).getIndex());
-		int ttype = grammar.getTokenType(tokenName);
-		String tok = generator.getTokenTypeAsTargetLabel(ttype);
-    	code.setAttribute("token", tok);
-    	if ( grammar.getTokenType(tokenName)==Label.INVALID ) {
-			ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
-									  grammar,
-									  ((GrammarAST)(#rewrite_atom)).getToken(),
-									  tokenName);
-    		code = new StringTemplate(); // blank; no code gen
-    	}
-    	}
-
-    |	LABEL
-    	{
-    	String labelName = #LABEL.getText();
-    	Rule rule = grammar.getRule(currentRuleName);
-    	Grammar.LabelElementPair pair = rule.getLabel(labelName);
-    	if ( labelName.equals(currentRuleName) ) {
-    		// special case; ref to old value via $rule
-			if ( rule.hasRewrite(outerAltNum) &&
-				 rule.getRuleRefsInAlt(outerAltNum).contains(labelName) )
-			{
-				ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
-										  grammar,
-										  ((GrammarAST)(#LABEL)).getToken(),
-										  labelName);
-    		}
-    		StringTemplate labelST = templates.getInstanceOf("prevRuleRootRef");
-    		code = templates.getInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
-    		code.setAttribute("label", labelST);
-    	}
-    	else if ( pair==null ) {
-			ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
-									  grammar,
-									  ((GrammarAST)(#LABEL)).getToken(),
-									  labelName);
-			code = new StringTemplate();
-    	}
-    	else {
-			String stName = null;
-			switch ( pair.type ) {
-				case Grammar.TOKEN_LABEL :
-					stName = "rewriteTokenLabelRef";
-					break;
-				case Grammar.WILDCARD_TREE_LABEL :
-					stName = "rewriteWildcardLabelRef";
-					break;
-				case Grammar.WILDCARD_TREE_LIST_LABEL :
-					stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
-					break;
-				case Grammar.RULE_LABEL :
-					stName = "rewriteRuleLabelRef";
-					break;
-				case Grammar.TOKEN_LIST_LABEL :
-					stName = "rewriteTokenListLabelRef";
-					break;
-				case Grammar.RULE_LIST_LABEL :
-					stName = "rewriteRuleListLabelRef";
-					break;
-			}
-			if ( isRoot ) {
-				stName += "Root";
-			}
-			code = templates.getInstanceOf(stName);
-			code.setAttribute("label", labelName);
-		}
-    	}
-
-    |   ACTION
-        {
-        // actions in rewrite rules yield a tree object
-        String actText = #ACTION.getText();
-        List chunks = generator.translateAction(currentRuleName,#ACTION);
-		code = templates.getInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
-		code.setAttribute("action", chunks);
-        }
-    ;
-
-rewrite_template returns [StringTemplate code=null]
-    :	#( ALT EPSILON EOA ) {code=templates.getInstanceOf("rewriteEmptyTemplate");}
-   	|	#( TEMPLATE (id:ID|ind:ACTION)
-		   {
-		   if ( #id!=null && #id.getText().equals("template") ) {
-		   		code = templates.getInstanceOf("rewriteInlineTemplate");
-		   }
-		   else if ( #id!=null ) {
-		   		code = templates.getInstanceOf("rewriteExternalTemplate");
-		   		code.setAttribute("name", #id.getText());
-		   }
-		   else if ( #ind!=null ) { // must be %({expr})(args)
-		   		code = templates.getInstanceOf("rewriteIndirectTemplate");
-				List chunks=generator.translateAction(currentRuleName,#ind);
-		   		code.setAttribute("expr", chunks);
-		   }
-		   }
-	       #( ARGLIST
-	       	  ( #( ARG arg:ID a:ACTION
-		   		   {
-                   // must set alt num here rather than in define.g
-                   // because actions like %foo(name={$ID.text}) aren't
-                   // broken up yet into trees.
-				   #a.outerAltNum = this.outerAltNum;
-		   		   List chunks = generator.translateAction(currentRuleName,#a);
-		   		   code.setAttribute("args.{name,value}", #arg.getText(), chunks);
-		   		   }
-	             )
-	          )*
-	        )
-		   ( DOUBLE_QUOTE_STRING_LITERAL
-             {
-             String sl = #DOUBLE_QUOTE_STRING_LITERAL.getText();
-			 String t = sl.substring(1,sl.length()-1); // strip quotes
-			 t = generator.target.getTargetStringLiteralFromString(t);
-             code.setAttribute("template",t);
-             }
-		   | DOUBLE_ANGLE_STRING_LITERAL
-             {
-             String sl = #DOUBLE_ANGLE_STRING_LITERAL.getText();
-			 String t = sl.substring(2,sl.length()-2); // strip double angle quotes
-			 t = generator.target.getTargetStringLiteralFromString(t);
-             code.setAttribute("template",t);
-             }
-		   )?
-	     )
-
-	|	act:ACTION
-   		{
-        // set alt num for same reason as ARGLIST above
-        #act.outerAltNum = this.outerAltNum;
-   		code=templates.getInstanceOf("rewriteAction");
-   		code.setAttribute("action",
-   						  generator.translateAction(currentRuleName,#act));
-   		}
-	;
diff --git a/tool/src/main/antlr2/org/antlr/grammar/v2/define.g b/tool/src/main/antlr2/org/antlr/grammar/v2/define.g
deleted file mode 100644
index c6f5f9b..0000000
--- a/tool/src/main/antlr2/org/antlr/grammar/v2/define.g
+++ /dev/null
@@ -1,653 +0,0 @@
-header {
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-	package org.antlr.grammar.v2;
-	import java.util.*;
-	import org.antlr.misc.*;
-    import org.antlr.tool.*;
-}
-
-class DefineGrammarItemsWalker extends TreeParser;
-
-options {
-	importVocab = ANTLR;
-	ASTLabelType = "GrammarAST";
-    codeGenBitsetTestThreshold=999;
-}
-
-{
-
-protected Grammar grammar;
-protected GrammarAST root;
-protected String currentRuleName;
-protected GrammarAST currentRewriteBlock;
-protected GrammarAST currentRewriteRule;
-protected int outerAltNum = 0;
-protected int blockLevel = 0;
-
-    public void reportError(RecognitionException ex) {
-		Token token = null;
-		if ( ex instanceof MismatchedTokenException ) {
-			token = ((MismatchedTokenException)ex).token;
-		}
-		else if ( ex instanceof NoViableAltException ) {
-			token = ((NoViableAltException)ex).token;
-		}
-        ErrorManager.syntaxError(
-            ErrorManager.MSG_SYNTAX_ERROR,
-            grammar,
-            token,
-            "define: "+ex.toString(),
-            ex);
-    }
-
-	protected void finish() {
-		trimGrammar();
-	}
-
-	/** Remove any lexer rules from a COMBINED; already passed to lexer */
-	protected void trimGrammar() {
-		if ( grammar.type!=Grammar.COMBINED ) {
-			return;
-		}
-		// form is (header ... ) ( grammar ID (scope ...) ... ( rule ... ) ( rule ... ) ... )
-		GrammarAST p = root;
-		// find the grammar spec
-		while ( !p.getText().equals("grammar") ) {
-			p = (GrammarAST)p.getNextSibling();
-		}
-		p = (GrammarAST)p.getFirstChild(); // jump down to first child of grammar
-		// look for first RULE def
-		GrammarAST prev = p; // points to the ID (grammar name)
-		while ( p.getType()!=RULE ) {
-			prev = p;
-			p = (GrammarAST)p.getNextSibling();
-		}
-		// prev points at last node before first rule subtree at this point
-		while ( p!=null ) {
-			String ruleName = p.getFirstChild().getText();
-			//System.out.println("rule "+ruleName+" prev="+prev.getText());
-			if ( Character.isUpperCase(ruleName.charAt(0)) ) {
-				// remove lexer rule
-				prev.setNextSibling(p.getNextSibling());
-			}
-			else {
-				prev = p; // non-lexer rule; move on
-			}
-			p = (GrammarAST)p.getNextSibling();
-		}
-		//System.out.println("root after removal is: "+root.toStringList());
-	}
-
-    protected void trackInlineAction(GrammarAST actionAST) {
-		Rule r = grammar.getRule(currentRuleName);
-        if ( r!=null ) {
-            r.trackInlineAction(actionAST);
-        }
-    }
-
-}
-
-grammar[Grammar g]
-{
-grammar = g;
-root = #grammar;
-}
-    :   ( #( LEXER_GRAMMAR 	  {grammar.type = Grammar.LEXER;} 	    grammarSpec )
-	    | #( PARSER_GRAMMAR   {grammar.type = Grammar.PARSER;}      grammarSpec )
-	    | #( TREE_GRAMMAR     {grammar.type = Grammar.TREE_PARSER;} grammarSpec )
-	    | #( COMBINED_GRAMMAR {grammar.type = Grammar.COMBINED;}    grammarSpec )
-	    )
-	    {finish();}
-    ;
-
-attrScope
-	:	#( "scope" name:ID attrs:ACTION )
-		{
-		AttributeScope scope = grammar.defineGlobalScope(name.getText(),#attrs.token);
-		scope.isDynamicGlobalScope = true;
-		scope.addAttributes(attrs.getText(), ';');
-		}
-	;
-
-grammarSpec
-{
-Map opts=null;
-Token optionsStartToken=null;
-}
-	:	id:ID
-		(cmt:DOC_COMMENT)?
-        //(#(OPTIONS .))? // already parsed these in assign.types.g
-        ( {optionsStartToken=((GrammarAST)_t).getToken();}
-          optionsSpec
-        )?
-        (delegateGrammars)?
-        (tokensSpec)?
-        (attrScope)*
-        (actions)?
-        rules
-	;
-
-actions
-	:	( action )+
-	;
-
-action
-{
-String scope=null;
-GrammarAST nameAST=null, actionAST=null;
-}
-	:	#(amp:AMPERSAND id1:ID
-			( id2:ID a1:ACTION
-			  {scope=#id1.getText(); nameAST=#id2; actionAST=#a1;}
-			| a2:ACTION
-			  {scope=null; nameAST=#id1; actionAST=#a2;}
-			)
-		 )
-		 {
-		 grammar.defineNamedAction(#amp,scope,nameAST,actionAST);
-		 }
-	;
-
-optionsSpec
-	:	OPTIONS
-	;
-
-delegateGrammars
-	:	#( "import" ( #(ASSIGN ID ID) | ID )+ )
-	;
-
-tokensSpec
-	:	#( TOKENS ( tokenSpec )+ )
-	;
-
-tokenSpec
-	:	t:TOKEN_REF
-	|	#( ASSIGN
-		   t2:TOKEN_REF
-		   ( s:STRING_LITERAL
-		   | c:CHAR_LITERAL
-		   )
-		 )
-	;
-
-rules
-    :   ( rule | PREC_RULE )+
-    ;
-
-rule
-{
-String mod=null;
-String name=null;
-Map opts=null;
-Rule r = null;
-}
-    :   #( RULE id:ID {opts = #RULE.getBlockOptions();}
-           (mod=modifier)?
-           #( ARG (args:ARG_ACTION)? )
-           #( RET (ret:ARG_ACTION)? )
-           (optionsSpec)?
-			{
-			name = #id.getText();
-			currentRuleName = name;
-			if ( Character.isUpperCase(name.charAt(0)) &&
-				 grammar.type==Grammar.COMBINED )
-			{
-				// a merged grammar spec, track lexer rules and send to another grammar
-				grammar.defineLexerRuleFoundInParser(#id.getToken(), #rule);
-			}
-			else {
-				int numAlts = countAltsForRule(#rule);
-				grammar.defineRule(#id.getToken(), mod, opts, #rule, #args, numAlts);
-				r = grammar.getRule(name);
-				if ( #args!=null ) {
-					r.parameterScope = grammar.createParameterScope(name,#args.token);
-					r.parameterScope.addAttributes(#args.getText(), ',');
-				}
-				if ( #ret!=null ) {
-					r.returnScope = grammar.createReturnScope(name,#ret.token);
-					r.returnScope.addAttributes(#ret.getText(), ',');
-				}
-			}
-			}
-           (ruleScopeSpec[r])?
-		   (ruleAction[r])*
-           {this.blockLevel=0;}
-           b:block
-           (exceptionGroup)?
-           EOR
-           {
-           // copy rule options into the block AST, which is where
-           // the analysis will look for k option etc...
-           #b.setBlockOptions(opts);
-           }
-         )
-    ;
-
-countAltsForRule returns [int n=0]
-    :   #( RULE id:ID (modifier)? ARG RET (OPTIONS)? ("scope")? (AMPERSAND)*
-           #(  BLOCK (OPTIONS)? (ALT (REWRITES)? {n++;})+ EOB )
-           (exceptionGroup)?
-           EOR
-         )
-	;
-
-ruleAction[Rule r]
-	:	#(amp:AMPERSAND id:ID a:ACTION ) {if (r!=null) r.defineNamedAction(#amp,#id,#a);}
-	;
-
-modifier returns [String mod]
-{
-mod = #modifier.getText();
-}
-	:	"protected"
-	|	"public"
-	|	"private"
-	|	"fragment"
-	;
-
-ruleScopeSpec[Rule r]
- 	:	#( "scope"
- 	       ( attrs:ACTION
- 	         {
- 	         r.ruleScope = grammar.createRuleScope(r.name,#attrs.token);
-			 r.ruleScope.isDynamicRuleScope = true;
-			 r.ruleScope.addAttributes(#attrs.getText(), ';');
-			 }
-		   )?
- 	       ( uses:ID
- 	         {
- 	         if ( grammar.getGlobalScope(#uses.getText())==null ) {
-				 ErrorManager.grammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
-										   grammar,
-										   #uses.token,
-										   #uses.getText());
-	         }
- 	         else {
- 	         	if ( r.useScopes==null ) {r.useScopes=new ArrayList();}
- 	         	r.useScopes.add(#uses.getText());
- 	         }
- 	         }
- 	       )*
- 	     )
- 	;
-
-block
-{
-this.blockLevel++;
-if ( this.blockLevel==1 ) {this.outerAltNum=1;}
-}
-    :   #(  BLOCK
-            (optionsSpec)?
-            (blockAction)*
-            ( alternative rewrite
-              {if ( this.blockLevel==1 ) {this.outerAltNum++;}}
-            )+
-            EOB
-         )
-         {this.blockLevel--;}
-    ;
-
-// TODO: this does nothing now! subrules cannot have init actions. :(
-blockAction
-	:	#(amp:AMPERSAND id:ID a:ACTION ) // {r.defineAction(#amp,#id,#a);}
-	;
-
-alternative
-/*
-{
-if ( grammar.type!=Grammar.LEXER && grammar.getOption("output")!=null && blockLevel==1 ) {
-    GrammarAST aRewriteNode = alternative_AST_in.findFirstType(REWRITES); // alt itself has rewrite?
-    GrammarAST rewriteAST = (GrammarAST)alternative_AST_in.getNextSibling();
-    GrammarAST firstRewriteAST = (GrammarAST)alternative_AST_in.findFirstType(REWRITE);
-    // we have a rewrite if alt uses it inside subrule or this alt has one
-    // but don't count -> ... rewrites, which mean "do default auto construction"
-    if ( aRewriteNode!=null||
-         (firstRewriteAST!=null &&
-          firstRewriteAST.getType()==REWRITE &&
-          firstRewriteAST.getFirstChild()!=null &&
-          firstRewriteAST.getFirstChild().getType()!=ETC) )
-    {
-        Rule r = grammar.getRule(currentRuleName);
-        r.trackAltsWithRewrites(alternative_AST_in,this.outerAltNum);
-    }
-}
-}
-*/
-    :   #( ALT (element)+ EOA )
-    ;
-
-exceptionGroup
-	:	( exceptionHandler )+ (finallyClause)?
-	|	finallyClause
-    ;
-
-exceptionHandler
-    :   #("catch" ARG_ACTION ACTION) {trackInlineAction(#ACTION);}
-    ;
-
-finallyClause
-    :    #("finally" ACTION) {trackInlineAction(#ACTION);}
-    ;
-
-element
-    :   #(ROOT element)
-    |   #(BANG element)
-    |   atom[null]
-    |   #(NOT element)
-    |   #(RANGE atom[null] atom[null])
-    |   #(CHAR_RANGE atom[null] atom[null])
-    |	#(ASSIGN id:ID el:element)
-    	{
-		if ( #el.getType()==ANTLRParser.ROOT ||
-             #el.getType()==ANTLRParser.BANG )
-		{
-            #el = (GrammarAST)#el.getFirstChild();
-        }
-    	if ( #el.getType()==RULE_REF) {
-    		grammar.defineRuleRefLabel(currentRuleName,#id.getToken(),#el);
-    	}
-    	else if ( #el.getType()==WILDCARD && grammar.type==Grammar.TREE_PARSER ) {
-    		grammar.defineWildcardTreeLabel(currentRuleName,#id.getToken(),#el);
-    	}
-    	else {
-    		grammar.defineTokenRefLabel(currentRuleName,#id.getToken(),#el);
-    	}
-    	}
-    |	#(	PLUS_ASSIGN id2:ID a2:element
-    	    {
-            if ( #a2.getType()==ANTLRParser.ROOT ||
-                 #a2.getType()==ANTLRParser.BANG )
-            {
-                #a2 = (GrammarAST)#a2.getFirstChild();
-            }
-    	    if ( #a2.getType()==RULE_REF ) {
-    	    	grammar.defineRuleListLabel(currentRuleName,#id2.getToken(),#a2);
-    	    }
-            else if ( #a2.getType()==WILDCARD && grammar.type==Grammar.TREE_PARSER ) {
-                grammar.defineWildcardTreeListLabel(currentRuleName,#id2.getToken(),#a2);
-            }
-    	    else {
-    	    	grammar.defineTokenListLabel(currentRuleName,#id2.getToken(),#a2);
-    	    }
-    	    }
-         )
-    |   ebnf
-    |   tree
-    |   #( SYNPRED block )
-    |   act:ACTION
-        {
-        #act.outerAltNum = this.outerAltNum;
-		trackInlineAction(#act);
-        }
-    |   act2:FORCED_ACTION
-        {
-        #act2.outerAltNum = this.outerAltNum;
-		trackInlineAction(#act2);
-        }
-    |   SEMPRED
-        {
-        #SEMPRED.outerAltNum = this.outerAltNum;
-        trackInlineAction(#SEMPRED);
-        }
-    |   SYN_SEMPRED
-    |   BACKTRACK_SEMPRED
-    |   GATED_SEMPRED
-        {
-        #GATED_SEMPRED.outerAltNum = this.outerAltNum;
-        trackInlineAction(#GATED_SEMPRED);
-        }
-    |   EPSILON
-    ;
-
-ebnf:   (dotLoop)=> dotLoop // .* or .+
-    |   block
-    |   #( OPTIONAL block )
-    |   #( CLOSURE block )
-    |   #( POSITIVE_CLOSURE block )
-    ;
-
-/** Track the .* and .+ idioms and make them nongreedy by default.
- */
-dotLoop
-{
-    GrammarAST block = (GrammarAST)#dotLoop.getFirstChild();
-}
-    :   (   #( CLOSURE dotBlock )
-        |   #( POSITIVE_CLOSURE dotBlock )
-        )
-        {
-        Map opts=new HashMap();
-        opts.put("greedy", "false");
-        if ( grammar.type!=Grammar.LEXER ) {
-            // parser grammars assume k=1 for .* loops
-            // otherwise they (analysis?) look til EOF!
-            opts.put("k", Utils.integer(1));
-        }
-        block.setOptions(grammar,opts);
-        }
-    ;
-
-dotBlock
-    :   #( BLOCK #( ALT WILDCARD EOA ) EOB )
-    ;
-
-tree:   #(TREE_BEGIN element (element)*)
-    ;
-
-atom[GrammarAST scope]
-    :   #( rr:RULE_REF (rarg:ARG_ACTION)? )
-    	{
-        grammar.altReferencesRule(currentRuleName, scope, #rr, this.outerAltNum);
-		if ( #rarg!=null ) {
-            #rarg.outerAltNum = this.outerAltNum;
-            trackInlineAction(#rarg);
-        }
-        }
-    |   #( t:TOKEN_REF  (targ:ARG_ACTION )? )
-    	{
-		if ( #targ!=null ) {
-            #targ.outerAltNum = this.outerAltNum;
-            trackInlineAction(#targ);
-        }
-    	if ( grammar.type==Grammar.LEXER ) {
-    		grammar.altReferencesRule(currentRuleName, scope, #t, this.outerAltNum);
-    	}
-    	else {
-    		grammar.altReferencesTokenID(currentRuleName, #t, this.outerAltNum);
-    	}
-    	}
-    |   c:CHAR_LITERAL
-    	{
-    	if ( grammar.type!=Grammar.LEXER ) {
-    		Rule rule = grammar.getRule(currentRuleName);
-			if ( rule!=null ) {
-				rule.trackTokenReferenceInAlt(#c, outerAltNum);
-    		}
-    	}
-    	}
-    |   s:STRING_LITERAL
-    	{
-    	if ( grammar.type!=Grammar.LEXER ) {
-    		Rule rule = grammar.getRule(currentRuleName);
-			if ( rule!=null ) {
-				rule.trackTokenReferenceInAlt(#s, outerAltNum);
-    		}
-    	}
-    	}
-    |   WILDCARD
-    |   #(DOT ID atom[#ID]) // scope override on rule
-    ;
-
-ast_suffix
-	:	ROOT
-	|	BANG
-	;
-
-rewrite
-{
-// track top level REWRITES node, store stuff there
-currentRewriteRule = #rewrite; // has to execute during guessing
-if ( grammar.buildAST() ) {
-    currentRewriteRule.rewriteRefsDeep = new HashSet<GrammarAST>();
-}
-}
-	:	#(REWRITES
-            (   #( REWRITE (pred:SEMPRED)? rewrite_alternative )
-                {
-                if ( #pred!=null ) {
-                    #pred.outerAltNum = this.outerAltNum;
-                    trackInlineAction(#pred);
-                }
-                }
-            )*
-        )
-//        {System.out.println("-> refs = "+currentRewriteRule.rewriteRefsDeep);}
-    |
-	;
-
-rewrite_block
-{
-GrammarAST enclosingBlock = currentRewriteBlock;
-if ( inputState.guessing==0 ) {  // don't do if guessing
-    currentRewriteBlock=#rewrite_block; // pts to BLOCK node
-    currentRewriteBlock.rewriteRefsShallow = new HashSet<GrammarAST>();
-    currentRewriteBlock.rewriteRefsDeep = new HashSet<GrammarAST>();
-}
-}
-    :   #( BLOCK rewrite_alternative EOB )
-        //{System.out.println("atoms="+currentRewriteBlock.rewriteRefs);}
-        {
-        // copy the element refs in this block to the surrounding block
-        if ( enclosingBlock!=null ) {
-            enclosingBlock.rewriteRefsDeep
-                .addAll(currentRewriteBlock.rewriteRefsShallow);
-        }
-        currentRewriteBlock = enclosingBlock; // restore old BLOCK ptr
-        }
-    ;
-
-rewrite_alternative
-    :   {grammar.buildAST()}?
-    	#( a:ALT ( ( rewrite_element )+ | EPSILON ) EOA )
-    |	{grammar.buildTemplate()}? rewrite_template
-	|	ETC {this.blockLevel==1}? // only valid as outermost rewrite
-
-    ;
-
-rewrite_element
-    :   rewrite_atom
-    |   rewrite_ebnf
-    |   rewrite_tree
-    ;
-
-rewrite_ebnf
-    :   #( OPTIONAL rewrite_block )
-    |   #( CLOSURE rewrite_block )
-    |   #( POSITIVE_CLOSURE rewrite_block )
-    ;
-
-rewrite_tree
-	:   #(	TREE_BEGIN rewrite_atom ( rewrite_element )* )
-    ;
-
-rewrite_atom
-{
-Rule r = grammar.getRule(currentRuleName);
-Set tokenRefsInAlt = r.getTokenRefsInAlt(outerAltNum);
-boolean imaginary =
-    #rewrite_atom.getType()==TOKEN_REF &&
-    !tokenRefsInAlt.contains(#rewrite_atom.getText());
-if ( !imaginary && grammar.buildAST() &&
-     (#rewrite_atom.getType()==RULE_REF ||
-      #rewrite_atom.getType()==LABEL ||
-      #rewrite_atom.getType()==TOKEN_REF ||
-      #rewrite_atom.getType()==CHAR_LITERAL ||
-      #rewrite_atom.getType()==STRING_LITERAL) )
-{
-    // track per block and for entire rewrite rule
-    if ( currentRewriteBlock!=null ) {
-        currentRewriteBlock.rewriteRefsShallow.add(#rewrite_atom);
-        currentRewriteBlock.rewriteRefsDeep.add(#rewrite_atom);
-    }
-    //System.out.println("adding "+#rewrite_atom.getText()+" to "+currentRewriteRule.getText());
-    currentRewriteRule.rewriteRefsDeep.add(#rewrite_atom);
-}
-}
-    :   RULE_REF
-    |   ( #(TOKEN_REF
-            (arg:ARG_ACTION)?
-           )
-        | CHAR_LITERAL
-        | STRING_LITERAL
-        )
-        {
-        if ( #arg!=null ) {
-            #arg.outerAltNum = this.outerAltNum;
-            trackInlineAction(#arg);
-        }
-        }
-
-    |	LABEL
-
-    |	ACTION
-        {
-            #ACTION.outerAltNum = this.outerAltNum;
-            trackInlineAction(#ACTION);
-        }
-    ;
-
-rewrite_template
-    :	#( ALT EPSILON EOA )
-   	|	#( TEMPLATE (id:ID|ind:ACTION)
-	       #( ARGLIST
-                ( #( ARG arg:ID a:ACTION )
-                {
-                    #a.outerAltNum = this.outerAltNum;
-                    trackInlineAction(#a);
-                }
-                )*
-            )
-            {
-            if ( #ind!=null ) {
-                #ind.outerAltNum = this.outerAltNum;
-                trackInlineAction(#ind);
-            }
-            }
-
-		   ( DOUBLE_QUOTE_STRING_LITERAL
-		   | DOUBLE_ANGLE_STRING_LITERAL
-		   )?
-	     )
-
-	|	act:ACTION
-        {
-        #act.outerAltNum = this.outerAltNum;
-        trackInlineAction(#act);
-        }
-	;
diff --git a/tool/src/main/antlr2/org/antlr/grammar/v2/left.recur.rules.g b/tool/src/main/antlr2/org/antlr/grammar/v2/left.recur.rules.g
deleted file mode 100644
index b9e4096..0000000
--- a/tool/src/main/antlr2/org/antlr/grammar/v2/left.recur.rules.g
+++ /dev/null
@@ -1,279 +0,0 @@
-header {
-/*
- [The "BSD license"]
- Copyright (c) 2010 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-	package org.antlr.grammar.v2;
-	import java.util.*;
-	import org.antlr.analysis.*;
-	import org.antlr.misc.*;
-	import java.io.*;
-    import org.antlr.tool.*;
-    import antlr.TokenWithIndex;
-}
-
-/** Find left-recursive rules */
-class LeftRecursiveRuleWalker extends TreeParser;
-
-options {
-	importVocab = ANTLR;
-	ASTLabelType = "GrammarAST";
-    codeGenBitsetTestThreshold=999;
-}
-
-{
-    public void reportError(RecognitionException ex) {
-		Token token = null;
-		if ( ex instanceof MismatchedTokenException ) {
-			token = ((MismatchedTokenException)ex).token;
-		}
-		else if ( ex instanceof NoViableAltException ) {
-			token = ((NoViableAltException)ex).token;
-		}
-        ErrorManager.syntaxError(
-            ErrorManager.MSG_SYNTAX_ERROR,
-            grammar,
-            token,
-            "assign.types: "+ex.toString(),
-            ex);
-    }
-
-
-protected Grammar grammar;
-String ruleName;
-int outerAlt; // which outer alt of rule?
-public int numAlts;  // how many alts for this rule total?
-public void setTokenPrec(GrammarAST t, int alt) {;}
-
-public void binaryAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {;}
-public void ternaryAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {;}
-public void prefixAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {;}
-public void suffixAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {;}
-public void otherAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {;}
-public void setReturnValues(GrammarAST t) {;}
-}
-
-optionsSpec
-    :   #( OPTIONS (option)+ )
-    ;
-
-option
-    :   #( ASSIGN id:ID optionValue )
-    ;
-
-optionValue
-    :   id:ID
-    |   s:STRING_LITERAL
-    |   c:CHAR_LITERAL
-    |   i:INT
-    ;
-
-charSetElement
-	:   c:CHAR_LITERAL
-	|   #( OR c1:CHAR_LITERAL c2:CHAR_LITERAL )
-	|   #( RANGE c3:CHAR_LITERAL c4:CHAR_LITERAL )
-	;
-
-rec_rule[Grammar g] returns [boolean isLeftRec=false]
-{
-	grammar = g;
-	outerAlt = 1;
-}
-    :   #( r:RULE id:ID {ruleName=#id.getText();}
-           (m:modifier)?
-           #(ARG (arg:ARG_ACTION)?)
-           #(RET (ret:ARG_ACTION {setReturnValues(#ret);})?)
-           (optionsSpec)?
-           (ruleScopeSpec)?
-       	   (AMPERSAND)*
-           isLeftRec=ruleBlock
-           (exceptionGroup)?
-           EOR
-         )
-         {if ( isLeftRec ) r.setType(PREC_RULE);}
-    ;
-
-modifier
-	:	"protected"
-	|	"public"
-	|	"private"
-	|	"fragment"
-	;
-
-ruleScopeSpec
- 	:	#( "scope" (ACTION)? ( ID )* )
- 	;
-
-ruleBlock returns [boolean isLeftRec=false]
-{boolean lr=false; this.numAlts = #ruleBlock.getNumberOfChildren();}
-    :   #(  BLOCK
-            (optionsSpec)?
-            (
-                lr=outerAlternative
-                {if ( lr ) isLeftRec = true;}
-                (r:rewrite | {#r=null;})
-                {
-                outerAlt++;
-                }
-            )+
-            EOB
-         )
-    ;
-
-block
-    :   #(  BLOCK
-            (optionsSpec)?
-            ( #( ALT (element)+ EOA ) (rewrite)? )+
-            EOB
-         )
-    ;
-
-/** An alt is either prefix, suffix, binary, or ternary operation or "other" */
-outerAlternative returns [boolean isLeftRec=false]
-{
-GrammarAST alt=#outerAlternative, rew=(GrammarAST)alt.getNextSibling();
-if ( rew.getType()!=REWRITES ) rew = null;
-//System.out.println("alt "+alt.toStringTree());
-}
-    :   (binaryMultipleOp)=> binaryMultipleOp
-                             {binaryAlt(alt, rew, outerAlt); isLeftRec=true;}
-    |   (binary)=>           b:binary
-                             {binaryAlt(alt, rew, outerAlt); isLeftRec=true;}
-    |   (ternary)=>          ternary
-                             {ternaryAlt(alt, rew, outerAlt); isLeftRec=true;}
-    |   (prefix)=>           prefix
-                             {prefixAlt(alt, rew, outerAlt);}
-                             // prefix alone not enough to trigger match
-    |   (suffix)=>           s:suffix
-                             {suffixAlt(alt, rew, outerAlt); isLeftRec=true;}
-    |   #( ALT (element)+ EOA ) // "other" case
-                             {otherAlt(alt, rew, outerAlt);}
-    ;
-
-binary
-{GrammarAST op=null;}
-    :   #( ALT (BACKTRACK_SEMPRED)? recurseNoLabel op=token recurse EOA ) {setTokenPrec(op, outerAlt);}
-    ;
-
-binaryMultipleOp
-{GrammarAST op=null;}
-    :   #( ALT (BACKTRACK_SEMPRED)? recurseNoLabel #( BLOCK ( #( ALT op=token EOA {setTokenPrec(op, outerAlt);} ) )+ EOB ) recurse EOA )
-    ;
-
-ternary
-{GrammarAST op=null;}
-    : #( ALT (BACKTRACK_SEMPRED)? recurseNoLabel op=token recurse token recurse EOA ) {setTokenPrec(op, outerAlt);}
-    ;
-
-prefix : #( ALT (BACKTRACK_SEMPRED)? {setTokenPrec((GrammarAST)_t, outerAlt);} ({!_t.getText().equals(ruleName)}? element)+ recurse EOA ) ;
-
-suffix : #( ALT (BACKTRACK_SEMPRED)? recurseNoLabel {setTokenPrec((GrammarAST)_t, outerAlt);} (e:element)+  EOA ) ;
-
-recurse
-    :   #(ASSIGN ID recurseNoLabel)
-    |   #(PLUS_ASSIGN ID recurseNoLabel)
-    |   recurseNoLabel
-    ;
-
-recurseNoLabel : {_t.getText().equals(ruleName)}? RULE_REF;
-
-/*
-elementNotRecursiveRule
-    :   {_t.findFirstType(RULE_REF)!=null && _t.findFirstType(RULE_REF).getText().equals(ruleName)}?
-        e:element
-    ;
-*/
-
-token returns [GrammarAST t=null]
-    :   #(ASSIGN ID t=token)
-    |   #(PLUS_ASSIGN ID t=token)
-    |   #(ROOT t=token)
-    |   #(BANG t=token)
-    |   a:CHAR_LITERAL      {t = a;}
-    |   b:STRING_LITERAL    {t = b;}
-    |   c:TOKEN_REF         {t = c;}
-    ;
-
-exceptionGroup
-	:	( exceptionHandler )+ (finallyClause)?
-	|	finallyClause
-    ;
-
-exceptionHandler
-    :    #("catch" ARG_ACTION ACTION)
-    ;
-
-finallyClause
-    :    #("finally" ACTION)
-    ;
-
-rewrite
-	:	#(REWRITES ( #( REWRITE (SEMPRED)? (ALT|TEMPLATE|ACTION|ETC) ) )* )
-	;
-
-element
-    :   #(ROOT element)
-    |   #(BANG element)
-    |   atom
-    |   #(NOT element)
-    |   #(RANGE atom atom)
-    |	#(ASSIGN ID element)
-    |	#(PLUS_ASSIGN ID element)
-    |   ebnf
-    |   tree
-    |   #( SYNPRED block )
-    |   FORCED_ACTION
-    |   ACTION
-    |   SEMPRED
-    |   SYN_SEMPRED
-    |   BACKTRACK_SEMPRED
-    |   GATED_SEMPRED
-    |   EPSILON
-    ;
-
-ebnf:   block
-    |   #( OPTIONAL block )
-    |   #( CLOSURE block )
-    |   #( POSITIVE_CLOSURE block )
-    ;
-
-tree:   #(TREE_BEGIN  element (element)*  )
-    ;
-
-
-atom
-    :   #( rr:RULE_REF (rarg:ARG_ACTION)? )
-    |   #( t:TOKEN_REF (targ:ARG_ACTION )? )
-    |   c:CHAR_LITERAL
-    |   s:STRING_LITERAL
-    |   WILDCARD
-    |   #(DOT ID atom) // scope override on rule
-    ;
-
-ast_suffix
-	:	ROOT
-	|	BANG
-	;

