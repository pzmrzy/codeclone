commit 5ebc0f6132b4e6128bd88fb518c5a04c26ba15dc
Author:     acondit <acondit@parrt.spork>
AuthorDate: Sat May 7 08:07:52 2011 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Sat May 7 08:07:52 2011 -0800

Changes to Match ANTLR3.4 revision.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8413]

diff --git a/runtime/ObjC/Framework/examples/hoistedPredicates/T.tokens b/runtime/ObjC/Framework/examples/hoistedPredicates/T.tokens
index 04386de..fa10173 100644
--- a/runtime/ObjC/Framework/examples/hoistedPredicates/T.tokens
+++ b/runtime/ObjC/Framework/examples/hoistedPredicates/T.tokens
@@ -1,5 +1,5 @@
-WS=6
-INT=5
-ID=4
T__7=7
+ID=4
+INT=5
+WS=6
'enum'=7
diff --git a/runtime/ObjC/Framework/examples/hoistedPredicates/TLexer.h b/runtime/ObjC/Framework/examples/hoistedPredicates/TLexer.h
index 47e26b1..9f5067d 100644
--- a/runtime/ObjC/Framework/examples/hoistedPredicates/TLexer.h
+++ b/runtime/ObjC/Framework/examples/hoistedPredicates/TLexer.h
@@ -1,10 +1,10 @@
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 T.g 2010-08-24 13:53:45
+// $ANTLR ${project.version} ${buildNumber} T.g 2011-05-06 19:14:23

/* =============================================================================
* Standard antlr3 OBJC runtime definitions
*/
#import <Cocoa/Cocoa.h>
-#import "antlr3.h"
+#import <ANTLR/ANTLR.h>
/* End of standard antlr3 runtime definitions
* =============================================================================
*/
@@ -14,21 +14,28 @@
#pragma mark Rule return scopes start
#pragma mark Rule return scopes end
#pragma mark Tokens
-#define WS 6
-#define INT 5
-#define ID 4
+#ifdef EOF
+#undef EOF
+#endif
#define EOF -1
#define T__7 7
+#define ID 4
+#define INT 5
+#define WS 6
+/* interface lexer class */
@interface TLexer : ANTLRLexer { // line 283
-// start of actions.lexer.memVars
-// start of action-actionScope-memVars
+/* ObjC start of actions.lexer.memVars */
+/* ObjC end of actions.lexer.memVars */
}
++ (void) initialize;
+ (TLexer *)newTLexerWithCharStream:(id<ANTLRCharStream>)anInput;
-
-- (void)mT__7;
-- (void)mID;
-- (void)mINT;
-- (void)mWS;
-- (void)mTokens;
+/* ObjC start actions.lexer.methodsDecl */
+/* ObjC end actions.lexer.methodsDecl */
+- (void) mT__7 ;
+- (void) mID ;
+- (void) mINT ;
+- (void) mWS ;
+- (void) mTokens ;

@end /* end of TLexer interface */
+
diff --git a/runtime/ObjC/Framework/examples/hoistedPredicates/TLexer.m b/runtime/ObjC/Framework/examples/hoistedPredicates/TLexer.m
index c7d010b..b55e539 100644
--- a/runtime/ObjC/Framework/examples/hoistedPredicates/TLexer.m
+++ b/runtime/ObjC/Framework/examples/hoistedPredicates/TLexer.m
@@ -1,43 +1,18 @@
/** \file
- *  This OBJC source file was generated by $ANTLR version 3.2 Aug 24, 2010 10:45:57
+ *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
*
*     -  From the grammar source file : T.g
- *     -                            On : 2010-08-24 13:53:45
- *     -                 for the lexer : TLexerLexer *
- * Editing it, at least manually, is not wise.
+ *     -                            On : 2011-05-06 19:14:23
+ *     -                 for the lexer : TLexerLexer
+ *
+ * Editing it, at least manually, is not wise.
*
* ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
*
*
*/
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 T.g 2010-08-24 13:53:45
+// $ANTLR ${project.version} ${buildNumber} T.g 2011-05-06 19:14:23
+

/* -----------------------------------------
* Include the ANTLR3 generated header file.
@@ -47,12 +22,10 @@


/* ============================================================================= */
-
/* =============================================================================
* Start of recognizer
*/

-
/** As per Terence: No returns for lexer rules! */
@implementation TLexer // line 330

@@ -73,8 +46,8 @@

- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
{
-    if ((self = [super initWithCharStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:5+1]]) != nil) {
-
+    self = [super initWithCharStream:anInput State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:5+1] retain]];
+    if ( self != nil ) {
}
return self;
}
@@ -84,15 +57,18 @@
[super dealloc];
}

-/* Start of actions.lexer.methods */
-/* start methods() */
+/* ObjC Start of actions.lexer.methods */
+/* ObjC end of actions.lexer.methods */
+/* ObjC start methods() */
+/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "T__7"
- (void) mT__7
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = T__7;
@@ -101,28 +77,31 @@
// T.g:7:8: 'enum' // alt
{
[self matchString:@"enum"];
-          /* element() */
-         /* elements */
+
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "T__7"
+/* $ANTLR end "T__7" */

// $ANTLR start "ID"
- (void) mID
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = ID;
@@ -132,16 +111,17 @@
{
if ((([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
[input consume];
-
} else {
-            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
[self recover:mse];
-            @throw mse;}
-          /* element() */
+            @throw mse;
+        }
+
+
do {
NSInteger alt1=2;
NSInteger LA1_0 = [input LA:1];
-            if ( ((LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) ) {
+            if ( ((LA1_0 >= '0' && LA1_0 <= '9')||(LA1_0 >= 'A' && LA1_0 <= 'Z')||LA1_0=='_'||(LA1_0 >= 'a' && LA1_0 <= 'z')) ) {
alt1=1;
}

@@ -152,13 +132,13 @@
{
if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))||(([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
[input consume];
-
} else {
-                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
[self recover:mse];
-                        @throw mse;}
-                      /* element() */
-                     /* elements */
+                        @throw mse;
+                    }
+
+
}
break;

@@ -167,28 +147,30 @@
}
} while (YES);
loop1: ;
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "ID"
+/* $ANTLR end "ID" */

// $ANTLR start "INT"
- (void) mINT
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = INT;
@@ -197,55 +179,65 @@
// T.g:40:7: ( '0' .. '9' )+ // alt
{
// T.g:40:7: ( '0' .. '9' )+ // positiveClosureBlock
-        NSInteger cnt2=0;
+        NSInteger cnt2 = 0;
do {
-            NSInteger alt2=2;
+            NSInteger alt2 = 2;
NSInteger LA2_0 = [input LA:1];
-            if ( ((LA2_0>='0' && LA2_0<='9')) ) {
+            if ( ((LA2_0 >= '0' && LA2_0 <= '9')) ) {
alt2=1;
}


switch (alt2) {
case 1 : ;
-                    // T.g:40:8: '0' .. '9' // alt
+                    // T.g: // alt
{
-                    [self matchRangeFromChar:'0' to:'9'];   /* element() */
-                     /* elements */
+                    if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))) {
+                        [input consume];
+                    } else {
+                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
+                        [self recover:mse];
+                        @throw mse;
+                    }
+
+
}
break;

default :
if ( cnt2 >= 1 )
goto loop2;
-                    ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:2];
+                    ANTLREarlyExitException *eee =
+                        [ANTLREarlyExitException newException:input decisionNumber:2];
@throw eee;
}
cnt2++;
} while (YES);
loop2: ;
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "INT"
+/* $ANTLR end "INT" */

// $ANTLR start "WS"
- (void) mWS
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = WS;
@@ -254,11 +246,11 @@
// T.g:43:9: ( ' ' | '\\t' | '\\r' | '\\n' )+ // alt
{
// T.g:43:9: ( ' ' | '\\t' | '\\r' | '\\n' )+ // positiveClosureBlock
-        NSInteger cnt3=0;
+        NSInteger cnt3 = 0;
do {
-            NSInteger alt3=2;
+            NSInteger alt3 = 2;
NSInteger LA3_0 = [input LA:1];
-            if ( ((LA3_0>='\t' && LA3_0<='\n')||LA3_0=='\r'||LA3_0==' ') ) {
+            if ( ((LA3_0 >= '\t' && LA3_0 <= '\n')||LA3_0=='\r'||LA3_0==' ') ) {
alt3=1;
}

@@ -269,48 +261,53 @@
{
if ((([input LA:1] >= '\t') && ([input LA:1] <= '\n'))||[input LA:1] == '\r'||[input LA:1] == ' ') {
[input consume];
-
} else {
-                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
[self recover:mse];
-                        @throw mse;}
-                      /* element() */
-                     /* elements */
+                        @throw mse;
+                    }
+
+
}
break;

default :
if ( cnt3 >= 1 )
goto loop3;
-                    ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:3];
+                    ANTLREarlyExitException *eee =
+                        [ANTLREarlyExitException newException:input decisionNumber:3];
@throw eee;
}
cnt3++;
} while (YES);
loop3: ;
-          /* element() */
-         _channel=99;   /* element() */
-         /* elements */
+
+
+         _channel=99;
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "WS"
+/* $ANTLR end "WS" */

- (void) mTokens
{
// T.g:1:8: ( T__7 | ID | INT | WS ) //ruleblock
NSInteger alt4=4;
-    switch ([input LA:1]) {
+    unichar charLA4 = [input LA:1];
+    switch (charLA4) {
case 'e': ;
{
NSInteger LA4_1 = [input LA:2];
@@ -324,20 +321,24 @@
if ( (LA4_6=='m') ) {
NSInteger LA4_7 = [input LA:5];

-                        if ( ((LA4_7>='0' && LA4_7<='9')||(LA4_7>='A' && LA4_7<='Z')||LA4_7=='_'||(LA4_7>='a' && LA4_7<='z')) ) {
+                        if ( ((LA4_7 >= '0' && LA4_7 <= '9')||(LA4_7 >= 'A' && LA4_7 <= 'Z')||LA4_7=='_'||(LA4_7 >= 'a' && LA4_7 <= 'z')) ) {
alt4=2;
}
else {
-                            alt4 = 1;}
+                            alt4 = 1;
+                        }
}
else {
-                        alt4 = 2;}
+                        alt4 = 2;
+                    }
}
else {
-                    alt4 = 2;}
+                    alt4 = 2;
+                }
}
else {
-                alt4 = 2;}
+                alt4 = 2;
+            }
}
break;
case 'A': ;
@@ -420,41 +421,47 @@
break;

default: ;
-        ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:4 state:0 stream:input];
+        ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:4 state:0 stream:input];
+        nvae.c = charLA4;
@throw nvae;
+
}

switch (alt4) {
case 1 : ;
// T.g:1:10: T__7 // alt
{
-                [self mT__7];
-              /* element() */
-             /* elements */
+            [self mT__7];
+
+
+
}
break;
case 2 : ;
// T.g:1:15: ID // alt
{
-                [self mID];
-              /* element() */
-             /* elements */
+            [self mID];
+
+
+
}
break;
case 3 : ;
// T.g:1:18: INT // alt
{
-                [self mINT];
-              /* element() */
-             /* elements */
+            [self mINT];
+
+
+
}
break;
case 4 : ;
// T.g:1:22: WS // alt
{
-                [self mWS];
-              /* element() */
-             /* elements */
+            [self mWS];
+
+
+
}
break;

@@ -462,8 +469,4 @@

}

-@end /* end of TLexer implementation line 397 */
-
-/* End of code
- * =============================================================================
- */
+@end /* end of TLexer implementation line 397 */
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/examples/hoistedPredicates/TParser.h b/runtime/ObjC/Framework/examples/hoistedPredicates/TParser.h
index d46867e..898d0de 100644
--- a/runtime/ObjC/Framework/examples/hoistedPredicates/TParser.h
+++ b/runtime/ObjC/Framework/examples/hoistedPredicates/TParser.h
@@ -1,43 +1,73 @@
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 T.g 2010-08-24 13:53:44
+// $ANTLR ${project.version} ${buildNumber} T.g 2011-05-06 19:14:23

/* =============================================================================
* Standard antlr3 OBJC runtime definitions
*/
#import <Cocoa/Cocoa.h>
-#import "antlr3.h"
+#import <ANTLR/ANTLR.h>
/* End of standard antlr3 runtime definitions
* =============================================================================
*/

/* parserHeaderFile */
+#ifndef ANTLR3TokenTypeAlreadyDefined
+#define ANTLR3TokenTypeAlreadyDefined
+typedef enum {
+    ANTLR_EOF = -1,
+    INVALID,
+    EOR,
+    DOWN,
+    UP,
+    MIN
+} ANTLR3TokenType;
+#endif
+
#pragma mark Tokens
-#define WS 6
-#define INT 5
-#define ID 4
+#ifdef EOF
+#undef EOF
+#endif
#define EOF -1
#define T__7 7
+#define ID 4
+#define INT 5
+#define WS 6
#pragma mark Dynamic Global Scopes
#pragma mark Dynamic Rule Scopes
#pragma mark Rule Return Scopes start
-#pragma mark Rule return scopes end
+
+/* Interface grammar class */
@interface TParser : ANTLRParser { /* line 572 */
-// start of globalAttributeScopeMemVar
+/* ObjC start of ruleAttributeScopeMemVar */


-// start of action-actionScope-memVars
+/* ObjC end of ruleAttributeScopeMemVar */
+/* ObjC start of globalAttributeScopeMemVar */

-/* With this true, enum is seen as a keyword.  False, it's an identifier */
-BOOL enableEnum;

-// start of ruleAttributeScopeMemVar
+/* ObjC end of globalAttributeScopeMemVar */
+/* ObjC start of actions.(actionScope).memVars */

+/* With this true, enum is seen as a keyword.  False, it's an identifier */
+BOOL enableEnum;

-// Start of memVars
+/* ObjC end of actions.(actionScope).memVars */
+/* ObjC start of memVars */
+/* ObjC end of memVars */

}

-// start of action-actionScope-methodsDecl
+/* ObjC start of actions.(actionScope).properties */
+/* ObjC end of actions.(actionScope).properties */
+/* ObjC start of properties */
+/* ObjC end of properties */
+
++ (void) initialize;
++ (id) newTParser:(id<ANTLRTokenStream>)aStream;
+/* ObjC start of actions.(actionScope).methodsDecl */
+/* ObjC end of actions.(actionScope).methodsDecl */

+/* ObjC start of methodsDecl */
+/* ObjC end of methodsDecl */

- (void)stat;
- (void)identifier;
@@ -46,6 +76,7 @@ BOOL enableEnum;


@end /* end of TParser interface */
+
/** Demonstrates how semantic predicates get hoisted out of the rule in
*  which they are found and used in other decisions.  This grammar illustrates
*  how predicates can be used to distinguish between enum as a keyword and
diff --git a/runtime/ObjC/Framework/examples/hoistedPredicates/TParser.m b/runtime/ObjC/Framework/examples/hoistedPredicates/TParser.m
index d638971..e440290 100644
--- a/runtime/ObjC/Framework/examples/hoistedPredicates/TParser.m
+++ b/runtime/ObjC/Framework/examples/hoistedPredicates/TParser.m
@@ -1,43 +1,18 @@
/** \file
- *  This OBJC source file was generated by $ANTLR version 3.2 Aug 24, 2010 10:45:57
+ *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
*
*     -  From the grammar source file : T.g
- *     -                            On : 2010-08-24 13:53:44
- *     -                for the parser : TParserParser *
- * Editing it, at least manually, is not wise.
+ *     -                            On : 2011-05-06 19:14:23
+ *     -                for the parser : TParserParser
+ *
+ * Editing it, at least manually, is not wise.
*
* ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
*
*
*/
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 T.g 2010-08-24 13:53:44
+// $ANTLR ${project.version} ${buildNumber} T.g 2011-05-06 19:14:23
+

/* -----------------------------------------
* Include the ANTLR3 generated header file.
@@ -55,13 +30,10 @@
*/

/* ============================================================================= */
-
/* =============================================================================
* Start of recognizer
*/

-
-
#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_identifier_in_stat34;
static const unsigned long long FOLLOW_identifier_in_stat34_data[] = { 0x0000000000000002LL};
@@ -81,19 +53,25 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000

#pragma mark Dynamic Rule Scopes

-#pragma mark Rule return scopes start
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
+#pragma mark Rule Return Scopes start
+//#pragma mark Rule return scopes start
+//

+#pragma mark Rule return scopes start

@implementation TParser  // line 637

+/* ObjC start of ruleAttributeScope */
+#pragma mark Dynamic Rule Scopes
+/* ObjC end of ruleAttributeScope */
+#pragma mark global Attribute Scopes
+/* ObjC start globalAttributeScope */
+/* ObjC end globalAttributeScope */
+/* ObjC start actions.(actionScope).synthesize */
+/* ObjC end actions.(actionScope).synthesize */
+/* ObjC start synthesize() */
+/* ObjC end synthesize() */
+
+ (void) initialize
{
#pragma mark Bitsets
@@ -104,20 +82,22 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000
FOLLOW_7_in_enumAsKeyword89 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_7_in_enumAsKeyword89_data Count:(NSUInteger)1] retain];
FOLLOW_7_in_enumAsID100 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_7_in_enumAsID100_data Count:(NSUInteger)1] retain];

-    [ANTLRBaseRecognizer setTokenNames:[[[NSArray alloc] initWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>",
+    [ANTLRBaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>",
@"ID", @"INT", @"WS", @"'enum'", nil] retain]];
+    [ANTLRBaseRecognizer setGrammarFileName:@"T.g"];
}

+ (TParser *)newTParser:(id<ANTLRTokenStream>)aStream
{
return [[TParser alloc] initWithTokenStream:aStream];

+
}

- (id) initWithTokenStream:(id<ANTLRTokenStream>)aStream
{
-    if ((self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:4+1] retain]]) != nil) {
-
+    self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:4+1] retain]];
+    if ( self != nil ) {


/* start of actions-actionScope-init */
@@ -133,16 +113,22 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000
{
[super dealloc];
}
-// start actions.actionScope.methods
-// start methods()
-// start rules
+
+/* ObjC start members */
+/* ObjC end members */
+/* ObjC start actions.(actionScope).methods */
+/* ObjC end actions.(actionScope).methods */
+/* ObjC start methods() */
+/* ObjC end methods() */
+/* ObjC start rules */
/*
* $ANTLR start stat
* T.g:24:1: stat : ( identifier | enumAsKeyword );
*/
- (void) stat
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// T.g:24:5: ( identifier | enumAsKeyword ) //ruleblock
@@ -162,37 +148,49 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000
alt1=2;
}
else {
-                ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:1 state:2 stream:input];
+                ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:1 state:2 stream:input];
+                nvae.c = LA1_2;
@throw nvae;
+
}
}
else {
-            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:1 state:0 stream:input];
+            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:1 state:0 stream:input];
+            nvae.c = LA1_0;
@throw nvae;
+
}
switch (alt1) {
case 1 : ;
// T.g:24:7: identifier // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_identifier_in_stat34];
[self identifier];
+
[self popFollow];

-                  /* element() */
-                NSLog(@"enum is an ID");  /* element() */
-                 /* elements */
+
+
+                NSLog(@"enum is an ID");
+
+
}
break;
case 2 : ;
// T.g:25:7: enumAsKeyword // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_enumAsKeyword_in_stat47];
[self enumAsKeyword];
+
[self popFollow];

-                  /* element() */
-                NSLog(@"enum is a keyword");  /* element() */
-                 /* elements */
+
+
+                NSLog(@"enum is a keyword");
+
+
}
break;

@@ -203,18 +201,24 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end stat */
+
/*
* $ANTLR start identifier
* T.g:28:1: identifier : ( ID | enumAsID );
*/
- (void) identifier
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// T.g:29:5: ( ID | enumAsID ) //ruleblock
@@ -228,26 +232,30 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000
alt2=2;
}
else {
-            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:2 state:0 stream:input];
+            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:2 state:0 stream:input];
+            nvae.c = LA2_0;
@throw nvae;
+
}
switch (alt2) {
case 1 : ;
// T.g:29:7: ID // alt
{
-                [self match:input TokenType:ID Follow:FOLLOW_ID_in_identifier66];   /* element() */
-                 /* elements */
+                [self match:input TokenType:ID Follow:FOLLOW_ID_in_identifier66];
+
}
break;
case 2 : ;
// T.g:30:7: enumAsID // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_enumAsID_in_identifier74];
[self enumAsID];
+
[self popFollow];

-                  /* element() */
-                 /* elements */
+
+
}
break;

@@ -258,28 +266,35 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end identifier */
+
/*
* $ANTLR start enumAsKeyword
- * T.g:33:1: enumAsKeyword : {...}? 'enum' ;
+ * T.g:33:1: enumAsKeyword :{...}? 'enum' ;
*/
- (void) enumAsKeyword
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// T.g:33:15: ({...}? 'enum' ) // ruleBlockSingleAlt
// T.g:33:17: {...}? 'enum' // alt
{
if ( !((enableEnum)) ) {
-            @throw [ANTLRFailedPredicateException exceptionWithRuleName:@"enumAsKeyword" predicate:@"enableEnum" stream:input];
-        }  /* element() */
-        [self match:input TokenType:7 Follow:FOLLOW_7_in_enumAsKeyword89];   /* element() */
-         /* elements */
+            @throw [ANTLRFailedPredicateException newException:@"enumAsKeyword" predicate:@"enableEnum" stream:input];
+        }
+
+        [self match:input TokenType:7 Follow:FOLLOW_7_in_enumAsKeyword89];
+
}

// token+rule list labels
@@ -288,28 +303,35 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end enumAsKeyword */
+
/*
* $ANTLR start enumAsID
- * T.g:35:1: enumAsID : {...}? 'enum' ;
+ * T.g:35:1: enumAsID :{...}? 'enum' ;
*/
- (void) enumAsID
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// T.g:35:10: ({...}? 'enum' ) // ruleBlockSingleAlt
// T.g:35:12: {...}? 'enum' // alt
{
if ( !((!enableEnum)) ) {
-            @throw [ANTLRFailedPredicateException exceptionWithRuleName:@"enumAsID" predicate:@"!enableEnum" stream:input];
-        }  /* element() */
-        [self match:input TokenType:7 Follow:FOLLOW_7_in_enumAsID100];   /* element() */
-         /* elements */
+            @throw [ANTLRFailedPredicateException newException:@"enumAsID" predicate:@"!enableEnum" stream:input];
+        }
+
+        [self match:input TokenType:7 Follow:FOLLOW_7_in_enumAsID100];
+
}

// token+rule list labels
@@ -318,15 +340,15 @@ static const unsigned long long FOLLOW_7_in_enumAsID100_data[] = { 0x00000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end enumAsID */
+/* ObjC end rules */

@end /* end of TParser implementation line 692 */
-
-
-/* End of code
- * =============================================================================
- */

