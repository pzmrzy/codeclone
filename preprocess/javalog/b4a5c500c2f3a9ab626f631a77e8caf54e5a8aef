commit b4a5c500c2f3a9ab626f631a77e8caf54e5a8aef
Author:     acondit <acondit@parrt.spork>
AuthorDate: Sat May 7 08:08:29 2011 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Sat May 7 08:08:29 2011 -0800

Changes to match ANTLR3.4 revision.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8414]

diff --git a/runtime/ObjC/Framework/examples/lexertest-simple/TestLexer.m b/runtime/ObjC/Framework/examples/lexertest-simple/TestLexer.m
index 8e1bf20..bb95f66 100644
--- a/runtime/ObjC/Framework/examples/lexertest-simple/TestLexer.m
+++ b/runtime/ObjC/Framework/examples/lexertest-simple/TestLexer.m
@@ -1,43 +1,18 @@
/** \file
- *  This OBJC source file was generated by $ANTLR version 3.2 Aug 24, 2010 10:45:57
+ *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
*
*     -  From the grammar source file : TestLexer.g
- *     -                            On : 2010-08-24 13:53:39
- *     -                 for the lexer : TestLexerLexer *
- * Editing it, at least manually, is not wise.
+ *     -                            On : 2011-05-06 19:16:22
+ *     -                 for the lexer : TestLexerLexer
+ *
+ * Editing it, at least manually, is not wise.
*
* ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
*
*
*/
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 TestLexer.g 2010-08-24 13:53:39
+// $ANTLR ${project.version} ${buildNumber} TestLexer.g 2011-05-06 19:16:22
+

/* -----------------------------------------
* Include the ANTLR3 generated header file.
@@ -47,12 +22,10 @@


/* ============================================================================= */
-
/* =============================================================================
* Start of recognizer
*/

-
/** As per Terence: No returns for lexer rules! */
@implementation TestLexer // line 330

@@ -73,8 +46,8 @@

- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
{
-    if ((self = [super initWithCharStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:4+1]]) != nil) {
-
+    self = [super initWithCharStream:anInput State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:4+1] retain]];
+    if ( self != nil ) {
}
return self;
}
@@ -84,15 +57,18 @@
[super dealloc];
}

-/* Start of actions.lexer.methods */
-/* start methods() */
+/* ObjC Start of actions.lexer.methods */
+/* ObjC end of actions.lexer.methods */
+/* ObjC start methods() */
+/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "ID"
- (void) mID
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = ID;
@@ -100,12 +76,14 @@
// TestLexer.g:8:4: ( LETTER ( LETTER | DIGIT )* ) // ruleBlockSingleAlt
// TestLexer.g:8:6: LETTER ( LETTER | DIGIT )* // alt
{
-            [self mLETTER];
-          /* element() */
+        [self mLETTER];
+
+
+
do {
NSInteger alt1=2;
NSInteger LA1_0 = [input LA:1];
-            if ( ((LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||(LA1_0>='a' && LA1_0<='z')) ) {
+            if ( ((LA1_0 >= '0' && LA1_0 <= '9')||(LA1_0 >= 'A' && LA1_0 <= 'Z')||(LA1_0 >= 'a' && LA1_0 <= 'z')) ) {
alt1=1;
}

@@ -116,13 +94,13 @@
{
if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))||(([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
[input consume];
-
} else {
-                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
[self recover:mse];
-                        @throw mse;}
-                      /* element() */
-                     /* elements */
+                        @throw mse;
+                    }
+
+
}
break;

@@ -131,50 +109,63 @@
}
} while (YES);
loop1: ;
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "ID"
+/* $ANTLR end "ID" */

// $ANTLR start "DIGIT"
- (void) mDIGIT
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// TestLexer.g:11:16: ( '0' .. '9' ) // ruleBlockSingleAlt
-        // TestLexer.g:11:18: '0' .. '9' // alt
+        // TestLexer.g: // alt
{
-        [self matchRangeFromChar:'0' to:'9'];   /* element() */
-         /* elements */
+        if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))) {
+            [input consume];
+        } else {
+            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
+            [self recover:mse];
+            @throw mse;
+        }
+
+
}

+
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "DIGIT"
+/* $ANTLR end "DIGIT" */

// $ANTLR start "LETTER"
- (void) mLETTER
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// TestLexer.g:15:2: ( 'a' .. 'z' | 'A' .. 'Z' ) // ruleBlockSingleAlt
@@ -182,38 +173,38 @@
{
if ((([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
[input consume];
-
} else {
-            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
[self recover:mse];
-            @throw mse;}
-          /* element() */
-         /* elements */
+            @throw mse;
+        }
+
+
}

+
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "LETTER"
+/* $ANTLR end "LETTER" */

- (void) mTokens
{
// TestLexer.g:1:8: ( ID ) // ruleBlockSingleAlt
// TestLexer.g:1:10: ID // alt
{
-        [self mID];
-      /* element() */
-     /* elements */
+    [self mID];
+
+
+
}


}

-@end /* end of TestLexer implementation line 397 */
-
-/* End of code
- * =============================================================================
- */
+@end /* end of TestLexer implementation line 397 */
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/examples/lexertest-simple/TestLexer.tokens b/runtime/ObjC/Framework/examples/lexertest-simple/TestLexer.tokens
index 2100fc5..000c040 100644
--- a/runtime/ObjC/Framework/examples/lexertest-simple/TestLexer.tokens
+++ b/runtime/ObjC/Framework/examples/lexertest-simple/TestLexer.tokens
@@ -1,3 +1,3 @@
-DIGIT=5
-ID=6
-LETTER=4
+DIGIT=4
+ID=5
+LETTER=6
diff --git a/runtime/ObjC/Framework/examples/lexertest-simple/TestLexerLexer.h b/runtime/ObjC/Framework/examples/lexertest-simple/TestLexerLexer.h
index 68396e4..cdd1cee 100644
--- a/runtime/ObjC/Framework/examples/lexertest-simple/TestLexerLexer.h
+++ b/runtime/ObjC/Framework/examples/lexertest-simple/TestLexerLexer.h
@@ -1,10 +1,10 @@
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 TestLexer.g 2010-08-24 13:53:39
+// $ANTLR ${project.version} ${buildNumber} TestLexer.g 2011-05-06 19:16:22

/* =============================================================================
* Standard antlr3 OBJC runtime definitions
*/
#import <Cocoa/Cocoa.h>
-#import "antlr3.h"
+#import <ANTLR/ANTLR.h>
/* End of standard antlr3 runtime definitions
* =============================================================================
*/
@@ -14,19 +14,26 @@
#pragma mark Rule return scopes start
#pragma mark Rule return scopes end
#pragma mark Tokens
-#define DIGIT 5
-#define ID 6
+#ifdef EOF
+#undef EOF
+#endif
#define EOF -1
-#define LETTER 4
+#define DIGIT 4
+#define ID 5
+#define LETTER 6
+/* interface lexer class */
@interface TestLexer : ANTLRLexer { // line 283
-// start of actions.lexer.memVars
-// start of action-actionScope-memVars
+/* ObjC start of actions.lexer.memVars */
+/* ObjC end of actions.lexer.memVars */
}
++ (void) initialize;
+ (TestLexer *)newTestLexerWithCharStream:(id<ANTLRCharStream>)anInput;
-
-- (void)mID;
-- (void)mDIGIT;
-- (void)mLETTER;
-- (void)mTokens;
+/* ObjC start actions.lexer.methodsDecl */
+/* ObjC end actions.lexer.methodsDecl */
+- (void) mID ;
+- (void) mDIGIT ;
+- (void) mLETTER ;
+- (void) mTokens ;

@end /* end of TestLexer interface */
+

