commit 714942f30c6f8763a8bd7e4214e232bee37f7533
Author:     Alan Condit <acondit@ipns.com>
AuthorDate: Sun Apr 15 19:41:41 2012 -0700
Commit:     Alan Condit <acondit@ipns.com>
CommitDate: Sun Apr 15 19:41:41 2012 -0700

Added replacement for Java LinkedHashMap that required a number of changes to add additional exception handling,
changes to HashMap. These changes all related to getting ST4 to work.

diff --git a/runtime/ObjC/Framework/ACBTree.h b/runtime/ObjC/Framework/ACBTree.h
index 0656556..3783cc9 100644
--- a/runtime/ObjC/Framework/ACBTree.h
+++ b/runtime/ObjC/Framework/ACBTree.h
@@ -18,7 +18,13 @@ typedef enum {
#define BTNODESIZE 11
#define BTHNODESIZE ((BTNODESIZE-1)/2)
#define BTKeySize  38
+#if defined FAILURE
+#undef FAILURE
+#endif
#define FAILURE -1
+#if defined SUCCESS
+#undef SUCCESS
+#endif
#define SUCCESS 0

@interface ACBKey : NSObject {
diff --git a/runtime/ObjC/Framework/ANTLR.h b/runtime/ObjC/Framework/ANTLR.h
index 33b18b6..048cdd6 100644
--- a/runtime/ObjC/Framework/ANTLR.h
+++ b/runtime/ObjC/Framework/ANTLR.h
@@ -61,6 +61,7 @@
#import <ANTLR/DebugTreeParser.h>
#import <ANTLR/DoubleKeyMap.h>
#import <ANTLR/EarlyExitException.h>
+#import <ANTLR/Entry.h>
#import <ANTLR/FailedPredicateException.h>
#import <ANTLR/FastQueue.h>
#import <ANTLR/HashMap.h>
@@ -70,6 +71,8 @@
#import <ANTLR/Lexer.h>
#import <ANTLR/LexerRuleReturnScope.h>
#import <ANTLR/LinkBase.h>
+#import <ANTLR/LinkedHashMap.h>
+#import <ANTLR/LinkedList.h>
#import <ANTLR/LookaheadStream.h>
#import <ANTLR/MapElement.h>
#import <ANTLR/Map.h>
diff --git a/runtime/ObjC/Framework/Entry.h b/runtime/ObjC/Framework/Entry.h
new file mode 100644
index 0000000..eabbba2
--- /dev/null
+++ b/runtime/ObjC/Framework/Entry.h
@@ -0,0 +1,46 @@
+
+@class HashTable;
+
+/**
+ * HashTable entry.
+ */
+
+@interface HTEntry : NSObject {
+    HTEntry *next;
+    NSInteger hash;
+    NSString *key;
+    id value;
+}
+
+@property(nonatomic, retain) HTEntry  *next;
+@property(assign)           NSInteger  hash;
+@property(nonatomic, retain) NSString *key;
+@property(nonatomic, retain)        id value;
+
++ (HTEntry *)newEntry:(NSInteger)h key:(NSString *)k value:(id)v next:(HTEntry *) n;
+- (id) init:(NSInteger)h key:(NSString *)k value:(id)v next:(HTEntry *)n;
+- (id) copyWithZone:(NSZone *)zone;
+- (void) setValue:(id)newValue;
+- (BOOL) isEqualTo:(id)o;
+- (NSInteger) hash;
+- (NSString *) description;
+@end
+
+/**
+ * LinkedMap entry.
+ */
+
+@interface LMNode : NSObject {
+    LMNode *next;
+    LMNode *prev;
+    id item;
+}
+
+@property(nonatomic, retain) LMNode *next;
+@property(nonatomic, retain) LMNode *prev;
+@property(nonatomic, retain)      id item;
+
++ (LMNode *) newNode:(LMNode *)aPrev element:(id)anElement next:(LMNode *)aNext;
+- (id) init:(LMNode *)aPrev element:(id)anElement next:(LMNode *)aNext;
+@end
+
diff --git a/runtime/ObjC/Framework/Entry.m b/runtime/ObjC/Framework/Entry.m
new file mode 100644
index 0000000..bbc8b8c
--- /dev/null
+++ b/runtime/ObjC/Framework/Entry.m
@@ -0,0 +1,110 @@
+#import "Entry.h"
+#import <Cocoa/Cocoa.h>
+#import "RuntimeException.h"
+
+@implementation HTEntry
+
+@synthesize next;
+@synthesize hash;
+@synthesize key;
+@synthesize value;
+
++ (id) newEntry:(int)aHash key:(NSString *)aKey value:(id)aValue next:(HTEntry *)aNext
+{
+    return [[HTEntry alloc] init:aHash key:aKey value:aValue next:aNext];
+}
+
+- (id) init:(int)aHash key:(NSString *)aKey value:(id)aValue next:(HTEntry *)aNext
+{
+    if ( (self = [super init]) != nil) {
+        next  = aNext;
+        hash  = aHash;
+        key   = aKey;
+        value = aValue;
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+    [next release];
+    [key release];
+    [value release];
+    [super dealloc];
+}
+
+
+- (id) copyWithZone:(NSZone *)zone
+{
+    HTEntry *copy = [[HTEntry allocWithZone:zone] init:hash key:key value:value next:next];
+    copy.next  = next;
+    copy.hash  = hash;
+    copy.key   = key;
+    copy.value = value;
+    //    return [[[HTEntry allocWithZone:zone] init:hash key:key value:value next:(next == nil ? nil : (HTEntry *)[next copyWithZone])] autorelease];
+    return copy;
+}
+
+- (void) setValue:(id)aValue
+{
+    if (aValue == nil)
+        @throw [[[NullPointerException alloc] init] autorelease];
+    //    id oldValue = value;
+    value = aValue;
+    //    return oldValue;
+}
+
+- (BOOL) isEqualTo:(id)o
+{
+/*
+    if (!([o conformsToProtocol:@protocol(HTEntry)]))
+        return NO;
+ */
+    HTEntry *e = (HTEntry *)o;
+    return (key == nil ? e.key == nil : [key isEqualTo:e.key]) && (value == nil ? e.value == nil : [value isEqualTo:e.value]);
+}
+
+- (int) hash
+{
+    return hash ^ (value == nil ? 0 : [value hash]);
+}
+
+- (NSString *) description
+{
+    return [NSString stringWithFormat:@"%@ = %@",[key description], [value description]];
+}
+
+@end
+
+@implementation LMNode
+
+@synthesize next;
+@synthesize prev;
+@synthesize item;
+
++ (LMNode *) newNode:(LMNode *)aPrev element:(id)anElement next:(LMNode *)aNext
+{
+    return [[LMNode alloc] init:aPrev element:anElement next:aNext];
+}
+
+- (id) init:(LMNode *)aPrev element:(id)anElement next:(LMNode *)aNext
+{
+    self = [super init];
+    if (self) {
+        item = anElement;
+        next = aNext;
+        prev = aPrev;
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+    [item release];
+    [next release];
+    [prev release];
+    [super dealloc];
+}
+
+@end
+
diff --git a/runtime/ObjC/Framework/HashMap.h b/runtime/ObjC/Framework/HashMap.h
index 5b9ea5c..f4a3778 100644
--- a/runtime/ObjC/Framework/HashMap.h
+++ b/runtime/ObjC/Framework/HashMap.h
@@ -28,41 +28,238 @@
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#import <Cocoa/Cocoa.h>
+#import <Foundation/Foundation.h>
+#import "AMutableArray.h"
+#import "AMutableDictionary.h"
+#import "ArrayIterator.h"
#import "LinkBase.h"
#import "MapElement.h"
+#import "PtrBuffer.h"

#define GLOBAL_SCOPE       0
#define LOCAL_SCOPE        1
#define HASHSIZE         101
#define HBUFSIZE      0x2000

+@class HashMap;
+
+/**
+ * HashMap entry.
+ */
+
+@interface HMEntry : NSObject {
+    HMEntry  *next;
+    NSInteger hash;
+    NSString *key;
+    id value;
+}
+
+@property(nonatomic, retain) HMEntry  *next;
+@property(assign)            NSInteger  hash;
+@property(nonatomic, retain) NSString *key;
+@property(nonatomic, retain) id value;
+
++ (HMEntry *)newEntry:(NSInteger)h key:(NSString *)k value:(id)v next:(HMEntry *) n;
+- (id) init:(NSInteger)h key:(NSString *)k value:(id)v next:(HMEntry *)n;
+- (void) setValue:(id)newValue;
+- (BOOL) isEqualTo:(id)o;
+- (NSInteger) hashCode;
+- (NSString *) description;
+- (void) recordAccess:(HashMap *)m;
+- (void) recordRemoval:(HashMap *)m;
+@end
+
+@interface HashIterator : ArrayIterator {
+    HMEntry  *next;
+    NSInteger expectedModCount;
+    NSInteger idx;
+    HMEntry  *current;
+    HashMap  *hm;
+}
+
++ (HashIterator *) newIterator:(HashMap *)aHM;
+
+- (id) init:(HashMap *)aHM;
+- (BOOL) hasNext;
+- (HMEntry *) next;
+- (void) remove;
+@end
+
+@interface HMEntryIterator : HashIterator
+{
+}
+
++ (HMEntryIterator *)newIterator:(HashMap *)aHM;
+
+- (id) init:(HashMap *)aHM;
+- (HMEntry *) next;
+@end
+
+@interface HMValueIterator : HashIterator
+{
+}
+
++ (HMValueIterator *)newIterator:(HashMap *)aHM;
+
+- (id) init:(HashMap *)aHM;
+- (id) next;
+@end
+
+@interface HMKeyIterator : HashIterator
+{
+}
+
++ (HMKeyIterator *)newIterator:(HashMap *)aHM;
+
+- (id) init:(HashMap *)aHM;
+- (NSString *) next;
+@end
+
+@interface HMKeySet : NSSet
+{
+    HashMap *hm;
+    AMutableArray *anArray;
+}
+
+@property (retain) HashMap *hm;
+@property (retain) AMutableArray *anArray;
+
++ (HMKeySet *)newKeySet:(HashMap *)aHM;
+
+- (id) init:(HashMap *)aHM;
+- (HashIterator *) iterator;
+- (NSUInteger) count;
+- (BOOL) contains:(id)o;
+- (BOOL) remove:(id)o;
+- (void) clear;
+- (NSArray *)toArray;
+@end
+
+@interface Values : PtrBuffer
+{
+    HashMap *hm;
+    AMutableArray *anArray;
+}
+
+@property (retain) HashMap *hm;
+@property (retain) AMutableArray *anArray;
+
++ (Values *)newValueSet:(HashMap *)aHM;
+
+- (id) init:(HashMap *)aHM;
+- (HashIterator *) iterator;
+- (NSUInteger) count;
+- (BOOL) contains:(id)o;
+- (void) clear;
+- (NSArray *)toArray;
+@end
+
+@interface HMEntrySet : NSSet
+{
+    HashMap *hm;
+    AMutableArray *anArray;
+}
+
+@property (retain) HashMap *hm;
+@property (retain) AMutableArray *anArray;
+
++ (HMEntrySet *)newEntrySet:(HashMap *)aHM;
+
+- (id) init:(HashMap *)aHM;
+- (HashIterator *) iterator;
+- (BOOL) contains:(id)o;
+- (BOOL) remove:(id)o;
+- (NSUInteger) count;
+- (void) clear;
+- (NSArray *)toArray;
+@end
+
@interface HashMap : LinkBase {
//    TStringPool *fPool;
NSInteger Scope;
NSInteger LastHash;
NSInteger BuffSize;
+    NSInteger Capacity;
+    /**
+     * The number of key-value mappings contained in this map.
+     */
NSUInteger count;
NSUInteger ptr;
__strong NSMutableData *buffer;
__strong MapElement **ptrBuffer;
NSInteger mode;
+    /**
+     * The table, resized as necessary. Length MUST Always be a power of two.
+     */
+//    AMutableArray *table;
+
+    /**
+     * The next size value at which to resize (capacity * load factor).
+     * @serial
+     */
+    NSInteger threshold;
+
+    /**
+     * The load factor for the hash table.
+     *
+     * @serial
+     */
+    float loadFactor;
+    /**
+     * The number of times this HashMap has been structurally modified
+     * Structural modifications are those that change the number of mappings in
+     * the HashMap or otherwise modify its internal structure (e.g.,
+     * rehash).  This field is used to make iterators on Collection-views of
+     * the HashMap fail-fast.  (See ConcurrentModificationException).
+     */
+    NSInteger modCount;
+    HMEntrySet *entrySet;
+    BOOL empty;
+    HMKeySet *keySet;
+    Values *values;
}

+//@property (copy) TStringPool *fPool;
+@property (getter=getScope, setter=setScope:) NSInteger Scope;
+@property (getter=getLastHash, setter=setLastHash:) NSInteger LastHash;
+
+@property (getter=getMode,setter=setMode:) NSInteger mode;
+@property (assign) NSInteger BuffSize;
+@property (assign) NSInteger Capacity;
+@property (getter=getCount, setter=setCount:) NSUInteger count;
+@property (assign) NSUInteger ptr;
+@property (retain, getter=getBuffer, setter=setBuffer:) NSMutableData *buffer;
+@property (assign, getter=getPtrBuffer, setter=setPtrBuffer:) MapElement **ptrBuffer;
+@property (assign) NSInteger threshold;
+@property (assign) float loadFactor;
+@property (assign) NSInteger modCount;
+@property (retain) HMEntrySet *entrySet;
+@property (nonatomic, readonly) BOOL empty;
+@property (retain) HMKeySet *keySet;
+@property (retain) Values *values;
+
// Contruction/Destruction
-+ (id)newHashMap;
-+ (id)newHashMapWithLen:(NSInteger)aBuffSize;
-- (id)init;
-- (id)initWithLen:(NSInteger)aBuffSize;
++ (id) newHashMap;
++ (id) newHashMap:(NSInteger)anInitialCapacity loadFactor:(float)loadFactor;
++ (id) newHashMap:(NSInteger)anInitialCapacity;
++ (id) newHashMapWithLen:(NSInteger)aBuffSize;
+- (id) init;
+- (id) initWithLen:(NSInteger)aBuffSize;
+- (id) init:(NSInteger)anInitialCapacity;
+- (id) init:(NSInteger)anInitialCapacity loadFactor:(float)loadFactor;
+- (id) initWithM:(HashMap *)m;
- (void)dealloc;
- (HashMap *)PushScope:( HashMap **)map;
- (HashMap *)PopScope:( HashMap **)map;

-- (NSInteger)count;
+- (NSUInteger)count;
- (NSInteger)size;

// Instance Methods
/*    form hash value for string s */
- (NSInteger)hash:(NSString *)s;
+- (NSInteger)hashInt:(NSInteger)anInt;
+- (NSInteger) indexFor:(NSInteger)h length:(NSInteger)length;
/*   look for s in ptrBuffer  */
- (HashMap *)findscope:(NSInteger)level;
/*   look for s in ptrBuffer  */
@@ -97,14 +294,34 @@
- (BOOL) hasNext;
- (MapElement *)nextObject;

-//@property (copy) TStringPool *fPool;
-@property (getter=getScope, setter=setScope:) NSInteger Scope;
-@property (getter=getLastHash, setter=setLastHash:) NSInteger LastHash;
+- (NSUInteger) count;
+- (id) get:(NSString *)key;
+- (id) getForNullKey;
+- (BOOL) containsKey:(NSString *)key;
+- (HMEntry *) getEntry:(NSString *)key;
+- (id) put:(NSString *)key value:(id)value;
+- (id) putForNullKey:(id)value;
+- (void) putForCreate:(NSString *)key value:(id)value;
+- (void) putAllForCreate:(HashMap *)m;
+- (void) resize:(NSInteger)newCapacity;
+- (void) transfer:(NSArray *)newTable;
+- (void) putAll:(HashMap *)m;
+- (id) remove:(NSString *)key;
+- (HMEntry *) removeEntryForKey:(NSString *)key;
+- (HMEntry *) removeMapping:(id)o;
+- (void) clear;
+- (BOOL) containsValue:(id)value;
+- (id) copyWithZone:(NSZone *)zone;
+- (NSString *) description;
+- (void) addEntry:(NSInteger)hash key:(NSString *)key value:(id)value bucketIndex:(NSInteger)bucketIndex;
+- (void) createEntry:(NSInteger)hash key:(NSString *)key value:(id)value bucketIndex:(NSInteger)bucketIndex;
+- (HMKeyIterator *) newKeyIterator;
+- (HMValueIterator *) newValueIterator;
+- (HMEntryIterator *) newEntryIterator;
+- (HMKeySet *) keySet;
+- (Values *) values;
+- (HMEntrySet *) entrySet;
+- (NSInteger) capacity;
+- (float) loadFactor;

-@property (getter=getMode,setter=setMode:) NSInteger mode;
-@property NSInteger BuffSize;
-@property (getter=getCount, setter=setCount:) NSUInteger count;
-@property (assign) NSUInteger ptr;
-@property (retain, getter=getBuffer, setter=setBuffer:) NSMutableData *buffer;
-@property (assign, getter=getPtrBuffer, setter=setPtrBuffer:) MapElement **ptrBuffer;
@end
diff --git a/runtime/ObjC/Framework/HashMap.m b/runtime/ObjC/Framework/HashMap.m
index 2081814..1f1fa7c 100644
--- a/runtime/ObjC/Framework/HashMap.m
+++ b/runtime/ObjC/Framework/HashMap.m
@@ -31,9 +31,425 @@
#define FAILURE (-1)

#import "HashMap.h"
+#import "AMutableArray.h"
+#import "RuntimeException.h"
+
+extern NSInteger max(NSInteger a, NSInteger b);

static NSInteger itIndex;

+@implementation HMEntry
+
+@synthesize next;
+@synthesize hash;
+@synthesize key;
+@synthesize value;
+
+/**
+ * Creates new entry.
+ */
++ (HMEntry *)newEntry:(NSInteger)h key:(NSString *)k value:(id)v next:(HMEntry *) n
+{
+    return [[HMEntry alloc] init:h key:k value:v next:n];
+}
+
+- (id) init:(NSInteger)h key:(NSString *)k value:(id)v next:(HMEntry *)n
+{
+    self = [super init];
+    if ( self ) {
+        value = v;
+        next = n;
+        key = k;
+        hash = h;
+    }
+    return self;
+}
+
+- (void) setValue:(id)newValue
+{
+    value = newValue;
+    //    return oldValue;
+}
+
+- (BOOL) isEqualTo:(id)o
+{
+    /*
+     if (!([o conformsToProtocol:@protocol(HMEntry)]))
+     return NO;
+     */
+    HMEntry *e = (HMEntry *)o;
+    NSString *k1 = [self key];
+    NSString *k2 = [e key];
+    if (k1 == k2 || (k1 != nil && [k1 isEqualTo:k2])) {
+        id v1 = [self value];
+        id v2 = [e value];
+        if (v1 == v2 || (v1 != nil && [v1 isEqualTo:v2]))
+            return YES;
+    }
+    return NO;
+}
+
+- (NSInteger) hashCode
+{
+    return (key == nil ? 0 : [key hashCode]) ^ (value == nil ? 0 : [value hash]);
+}
+
+- (NSString *) description
+{
+    return [NSString stringWithFormat:@"%@ = %@",[key description], [value description]];
+}
+
+
+/**
+ * This method is invoked whenever the value in an entry is
+ * overwritten by an invocation of put(k,v) for a key k that's already
+ * in the HashMap.
+ */
+- (void) recordAccess:(HashMap *)m
+{
+}
+
+
+/**
+ * This method is invoked whenever the entry is
+ * removed from the table.
+ */
+- (void) recordRemoval:(HashMap *)m
+{
+}
+
+- (void) dealloc
+{
+    [key release];
+    [value release];
+    [next release];
+    [super dealloc];
+}
+
+@end
+
+@implementation HashIterator
+
++ (HashIterator *)newIterator:(HashMap *)aHM
+{
+    return [[HashIterator alloc] init:aHM];
+}
+
+- (id) init:(HashMap *)aHM
+{
+    self = [super init];
+    if ( self ) {
+        hm = aHM;
+        expectedModCount = hm.modCount;
+        if (count > 0) {
+            while ( idx < [hm.buffer length] ) {
+                next = (HMEntry *)hm.ptrBuffer[idx++];
+                if ( next == nil )
+                    break;
+            }
+        }
+    }
+    return self;
+}
+
+- (BOOL) hasNext
+{
+    return next != nil;
+}
+
+- (HMEntry *) next
+{
+//    if (hm.modCount != expectedModCount)
+//        @throw [[ConcurrentModificationException alloc] init];
+    HMEntry *e = next;
+    if (e == nil)
+        @throw [[NoSuchElementException alloc] init];
+    if ((next = e.next) == nil) {
+        while ( idx < [hm.buffer length] ) {
+            next = [anArray objectAtIndex:idx++];
+            if ( next == nil )
+                break;
+        }
+    }
+    current = e;
+    return e;
+}
+
+- (void) remove
+{
+    if (current == nil)
+        @throw [[IllegalStateException alloc] init];
+//    if (modCount != expectedModCount)
+//        @throw [[ConcurrentModificationException alloc] init];
+    NSString *k = current.key;
+    current = nil;
+    [hm removeEntryForKey:k];
+    expectedModCount = hm.modCount;
+}
+
+- (void) dealloc
+{
+    [next release];
+    [current release];
+    [super dealloc];
+}
+
+@end
+
+@implementation HMValueIterator
+
++ (HMValueIterator *)newIterator:(HashMap *)aHM
+{
+    return [[HMValueIterator alloc] init:aHM];
+}
+
+- (id) init:(HashMap *)aHM
+{
+    self = [super init:aHM];
+    if ( self ) {
+    }
+    return self;
+}
+
+- (id) next
+{
+    return [super next].value;
+}
+
+@end
+
+@implementation HMKeyIterator
+
++ (HMKeyIterator *)newIterator:(HashMap *)aHM
+{
+    return [[HMKeyIterator alloc] init:aHM];
+}
+
+- (id) init:(HashMap *)aHM
+{
+    self = [super init:aHM];
+    if ( self ) {
+    }
+    return self;
+}
+
+- (NSString *) next
+{
+    return [super next].key;
+}
+
+@end
+
+@implementation HMEntryIterator
+
++ (HMEntryIterator *)newIterator:(HashMap *)aHM
+{
+    return [[HMEntryIterator alloc] init:aHM];
+}
+
+- (id) init:(HashMap *)aHM
+{
+    self = [super init:aHM];
+    if ( self ) {
+    }
+    return self;
+}
+
+- (HMEntry *) next
+{
+    return [super next];
+}
+
+@end
+
+@implementation HMKeySet
+
+@synthesize hm;
+@synthesize anArray;
+
++ (HMKeySet *)newKeySet:(HashMap *)aHM
+{
+    return [[HMKeySet alloc] init:(HashMap *)aHM];
+}
+
+- (id) init:(HashMap *)aHM
+{
+    self = [super init];
+    if ( self ) {
+        hm = aHM;
+        anArray = [[AMutableArray arrayWithCapacity:16] retain];
+        HMKeyIterator *it = [hm newKeyIterator];
+        while ( [it hasNext] ) {
+            NSString *aKey = [it next];
+            [anArray addObject:aKey];
+        }
+    }
+    return self;
+}
+
+- (HashIterator *) iterator
+{
+    return [HMKeyIterator newIterator:hm];
+}
+
+- (NSUInteger) count
+{
+    return hm.count;
+}
+
+- (BOOL) contains:(id)o
+{
+    return [hm containsKey:o];
+}
+
+- (BOOL) remove:(id)o
+{
+    return [hm removeEntryForKey:o] != nil;
+}
+
+- (void) clear {
+    [hm clear];
+}
+
+- (NSArray *)toArray
+{
+    return anArray;
+}
+
+@end
+
+@implementation Values
+
+@synthesize hm;
+@synthesize anArray;
+
++ (Values *)newValueSet:(HashMap *)aHM
+{
+    return [[Values alloc] init:aHM];
+}
+
+- (id) init:(HashMap *)aHM
+{
+    self = [super init];
+    if ( self ) {
+        hm = aHM;
+        anArray = [[AMutableArray arrayWithCapacity:16] retain];
+        HMValueIterator *it = [hm newValueIterator];
+        while ( [it hasNext] ) {
+            id aValue = [it next];
+            [anArray addObject:aValue];
+        }
+    }
+    return self;
+}
+
+- (ArrayIterator *) iterator
+{
+    return [HMValueIterator newIterator:hm];
+}
+
+- (NSUInteger) count
+{
+    return hm.count;
+}
+
+- (BOOL) contains:(id)o
+{
+    return [hm containsValue:o];
+}
+
+- (void) clear {
+    [hm clear];
+}
+
+- (NSArray *)toArray
+{
+    return anArray;
+}
+
+@end
+
+@implementation HMEntrySet
+
+@synthesize hm;
+@synthesize anArray;
+
++ (HMEntrySet *)newEntrySet:(HashMap *)aHM
+{
+    return [[HMEntrySet alloc] init:aHM];
+}
+
+- (id) init:(HashMap *)aHM
+{
+    self = [super init];
+    if ( self ) {
+        hm = aHM;
+        anArray = [[AMutableArray arrayWithCapacity:16] retain];
+        HMEntryIterator *it = [hm newEntryIterator:hm];
+        while ( [it hasNext] ) {
+            HMEntry *entry = [it next];
+            [anArray addObject:entry];
+        }
+    }
+    return self;
+}
+
+- (HashIterator *) iterator
+{
+    return [HMEntryIterator newIterator:hm];
+}
+
+- (BOOL) contains:(id)o
+{
+/*
+    if (!([o conformsToProtocol:@protocol(HMEntry)]))
+        return NO;
+ */
+    HMEntry *e = (HMEntry *)o;
+    HMEntry *candidate = [hm getEntry:e.key];
+    return candidate != nil && [candidate isEqualTo:e];
+}
+
+- (BOOL) remove:(id)o
+{
+    return [hm removeMapping:o] != nil;
+}
+
+- (NSUInteger) count
+{
+    return hm.count;
+}
+
+- (void) clear
+{
+    [hm clear];
+}
+
+- (NSArray *)toArray
+{
+    return anArray;
+}
+
+@end
+
+/**
+ * The default initial capacity - MUST be a power of two.
+ */
+NSInteger const DEFAULT_INITIAL_CAPACITY = 16;
+
+/**
+ * The maximum capacity, used if a higher value is implicitly specified
+ * by either of the constructors with arguments.
+ * MUST be a power of two <= 1<<30.
+ */
+NSInteger const MAXIMUM_CAPACITY = 1 << 30;
+
+/**
+ * The load factor used when none specified in constructor.
+ */
+float const DEFAULT_LOAD_FACTOR = 0.75f;
+//long const serialVersionUID = 362498820763181265L;
+
/*
* Start of HashMap
*/
@@ -41,6 +457,19 @@ static NSInteger itIndex;

@synthesize Scope;
@synthesize LastHash;
+@synthesize BuffSize;
+@synthesize Capacity;
+@synthesize count;
+@synthesize ptr;
+@synthesize ptrBuffer;
+@synthesize buffer;
+@synthesize threshold;
+@synthesize loadFactor;
+@synthesize modCount;
+@synthesize entrySet;
+@synthesize empty;
+@synthesize keySet;
+@synthesize values;

+(id)newHashMap
{
@@ -52,15 +481,40 @@ static NSInteger itIndex;
return [[HashMap alloc] initWithLen:aBuffSize];
}

--(id)init
++ (id) newHashMap:(NSInteger)initialCapacity
+{
+    return [[HashMap alloc] init:initialCapacity loadFactor:DEFAULT_LOAD_FACTOR];
+}
+
++ (id) newHashMap:(NSInteger)initialCapacity loadFactor:(float)aLoadFactor
+{
+    return [[HashMap alloc] init:initialCapacity loadFactor:aLoadFactor];
+}
+
+/**
+ * Constructs an empty <tt>HashMap</tt> with the default initial capacity
+ * (16) and the default load factor (0.75).
+ */
+- (id) init
{
NSInteger idx;
-
-    if ((self = [super init]) != nil) {
+
+    self = [super init];
+    if ( self ) {
+        entrySet = nil;
+        loadFactor = DEFAULT_LOAD_FACTOR;
+        threshold = (NSInteger)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
+        count = 0;
+        BuffSize = HASHSIZE;
+        NSInteger capacity = 1;
+
+        while (capacity < BuffSize)
+            capacity <<= 1;
+
+        BuffSize = capacity;
fNext = nil;
Scope = 0;
ptr = 0;
-        BuffSize = HASHSIZE;
buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
ptrBuffer = (MapElement **) [buffer mutableBytes];
if ( fNext != nil ) {
@@ -70,32 +524,160 @@ static NSInteger itIndex;
}
}
mode = 0;
-    }
-    return( self );
+        keySet = nil;
+        values = nil;
+   }
+    return self;
}

-(id)initWithLen:(NSInteger)aBuffSize
{
NSInteger idx;

-    if ((self = [super init]) != nil) {
+    self = [super init];
+    if ( self ) {
fNext = nil;
+        entrySet = nil;
+        loadFactor = DEFAULT_LOAD_FACTOR;
+        threshold = (NSInteger)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);
+        count = 0;
BuffSize = aBuffSize;
+        NSInteger capacity = 1;
+
+        while (capacity < BuffSize)
+            capacity <<= 1;
+
+        BuffSize = capacity * sizeof(id);
+        Capacity = capacity;
Scope = 0;
ptr = 0;
-        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize] retain];
ptrBuffer = (MapElement **) [buffer mutableBytes];
if ( fNext != nil ) {
Scope = ((HashMap *)fNext)->Scope+1;
-            for( idx = 0; idx < BuffSize; idx++ ) {
+            for( idx = 0; idx < Capacity; idx++ ) {
ptrBuffer[idx] = ((HashMap *)fNext)->ptrBuffer[idx];
}
}
mode = 0;
+        keySet = nil;
+        values = nil;
}
return( self );
}

+/**
+ * Constructs an empty <tt>HashMap</tt> with the specified initial
+ * capacity and load factor.
+ *
+ * @param  initialCapacity the initial capacity
+ * @param  loadFactor      the load factor
+ * @throws IllegalArgumentException if the initial capacity is negative
+ * or the load factor is nonpositive
+ */
+- (id) init:(NSInteger)initialCapacity loadFactor:(float)aLoadFactor
+{
+    self = [super init];
+    if ( self ) {
+        entrySet = nil;
+        if (initialCapacity < 0)
+            @throw [[IllegalArgumentException alloc] init:[NSString stringWithFormat:@"Illegal initial capacity: %d", initialCapacity]];
+        if (initialCapacity > MAXIMUM_CAPACITY)
+            initialCapacity = MAXIMUM_CAPACITY;
+        if (aLoadFactor <= 0 /* || [Float isNaN:loadFactor] */)
+            @throw [[IllegalArgumentException alloc] init:[NSString stringWithFormat:@"Illegal load factor:%d ", aLoadFactor]];
+        NSInteger capacity = 1;
+
+        while (capacity < initialCapacity)
+            capacity <<= 1;
+
+        count = 0;
+        BuffSize = capacity * sizeof(id);
+        Capacity = capacity;
+        loadFactor = aLoadFactor;
+        threshold = (NSInteger)(capacity * loadFactor);
+//        ptrBuffer = [AMutableArray arrayWithCapacity:initialCapacity];
+//        [self init];
+        keySet = nil;
+        values = nil;
+        Scope = 0;
+        ptr = 0;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize] retain];
+        ptrBuffer = (MapElement **) [buffer mutableBytes];
+    }
+    return self;
+}
+
+
+/**
+ * Constructs an empty <tt>HashMap</tt> with the specified initial
+ * capacity and the default load factor (0.75).
+ *
+ * @param  initialCapacity the initial capacity.
+ * @throws IllegalArgumentException if the initial capacity is negative.
+ */
+- (id) init:(NSInteger)anInitialCapacity
+{
+    self = [super init];
+    if ( self ) {
+        entrySet = nil;
+        NSInteger initialCapacity = anInitialCapacity;
+        if (initialCapacity > MAXIMUM_CAPACITY)
+            initialCapacity = MAXIMUM_CAPACITY;
+        NSInteger capacity = 1;
+        while (capacity < initialCapacity)
+            capacity <<= 1;
+        count = 0;
+        BuffSize = capacity;
+        loadFactor = DEFAULT_LOAD_FACTOR;
+        threshold = (NSInteger)(capacity * loadFactor);
+        keySet = nil;
+        values = nil;
+        Scope = 0;
+        ptr = 0;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize] retain];
+        ptrBuffer = (MapElement **) [buffer mutableBytes];
+    }
+    return self;
+}
+
+/**
+ * Constructs a new <tt>HashMap</tt> with the same mappings as the
+ * specified <tt>Map</tt>.  The <tt>HashMap</tt> is created with
+ * default load factor (0.75) and an initial capacity sufficient to
+ * hold the mappings in the specified <tt>Map</tt>.
+ *
+ * @param   m the map whose mappings are to be placed in this map
+ * @throws  NullPointerException if the specified map is null
+ */
+- (id) initWithM:(HashMap *)m
+{
+    self = [super init];
+    self = [self init:(NSInteger)max((([m count] / DEFAULT_LOAD_FACTOR) + 1), DEFAULT_INITIAL_CAPACITY) loadFactor:DEFAULT_LOAD_FACTOR];
+    if ( self ) {
+        entrySet = nil;
+        NSInteger initialCapacity = max((([m count] / DEFAULT_LOAD_FACTOR) + 1), DEFAULT_INITIAL_CAPACITY);
+        if (initialCapacity > MAXIMUM_CAPACITY)
+            initialCapacity = MAXIMUM_CAPACITY;
+        NSInteger capacity = 1;
+        while (capacity < initialCapacity)
+            capacity <<= 1;
+        count = 0;
+        BuffSize = capacity * sizeof(id);
+        Capacity = capacity;
+        loadFactor = DEFAULT_LOAD_FACTOR;
+        threshold = (NSInteger)(capacity * loadFactor);
+        keySet = nil;
+        values = nil;
+        Scope = 0;
+        ptr = 0;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize] retain];
+        ptrBuffer = (MapElement **) [buffer mutableBytes];
+        [self putAllForCreate:m];
+    }
+    return self;
+}
+
-(void)dealloc
{
#ifdef DEBUG_DEALLOC
@@ -105,7 +687,7 @@ static NSInteger itIndex;
NSInteger idx;

if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
+        for( idx = 0; idx < Capacity; idx++ ) {
tmp = ptrBuffer[idx];
while ( tmp && tmp != [((HashMap *)fNext) getptrBufferEntry:idx] ) {
rtmp = tmp;
@@ -116,14 +698,20 @@ static NSInteger itIndex;
}
}
if ( buffer ) [buffer release];
+#ifdef DONTUSEYET
+    [ptrBuffer release];
+    [entrySet release];
+#endif
+    if ( keySet ) [keySet release];
+    if ( values ) [values release];
[super dealloc];
}

-- (NSInteger)count
+- (NSUInteger)count
{
-    NSInteger aCnt = 0;
+    NSUInteger aCnt = 0;

-    for (NSInteger i = 0; i < BuffSize; i++) {
+    for (NSUInteger i = 0; i < Capacity; i++) {
if ( ptrBuffer[i] != nil ) {
aCnt++;
}
@@ -135,7 +723,7 @@ static NSInteger itIndex;
{
NSInteger aSize = 0;

-    for (NSInteger i = 0; i < BuffSize; i++) {
+    for (NSInteger i = 0; i < Capacity; i++) {
if ( ptrBuffer[i] != nil ) {
aSize += sizeof(id);
}
@@ -150,7 +738,7 @@ static NSInteger itIndex;
NSInteger idx;

if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
+        for( idx = 0; idx < Capacity; idx++ ) {
tmp = ptrBuffer[idx];
while ( tmp && tmp != (LinkBase *)[((HashMap *)fNext) getptrBufferEntry:idx] ) {
rtmp = tmp;
@@ -170,7 +758,7 @@ static NSInteger itIndex;
if ( *map != nil ) {
((HashMap *)htmp)->fNext = *map;
[htmp setScope:[((HashMap *)htmp->fNext) getScope]+1];
-        for( idx = 0; idx < BuffSize; idx++ ) {
+        for( idx = 0; idx < Capacity; idx++ ) {
htmp->ptrBuffer[idx] = ((HashMap *)htmp->fNext)->ptrBuffer[idx];
}
}
@@ -188,7 +776,7 @@ static NSInteger itIndex;
htmp = *map;
if ( (*map)->fNext != nil ) {
*map = (HashMap *)htmp->fNext;
-        for( idx = 0; idx < BuffSize; idx++ ) {
+        for( idx = 0; idx < Capacity; idx++ ) {
if ( htmp->ptrBuffer[idx] == nil ||
htmp->ptrBuffer[idx] == (*map)->ptrBuffer[idx] ) {
break;
@@ -209,7 +797,7 @@ static NSInteger itIndex;

#ifdef USERDOC
/*
- *  HASH        hash entry to get index to table
+ *  HASH        hash entry to get idx to table
*  NSInteger hash( HashMap *self, char *s );
*
*     Inputs:  char *s             string to find
@@ -227,10 +815,34 @@ static NSInteger itIndex;
tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
for( hashval = 0; *tmp != '\0'; )
hashval += *tmp++;
-    self->LastHash = hashval % BuffSize;
+    self->LastHash = hashval % Capacity;
return( self->LastHash );
}

+/**
+ * Applies a supplemental hash function to a given hashCode, which
+ * defends against poor quality hash functions.  This is critical
+ * because HashMap uses power-of-two length hash tables, that
+ * otherwise encounter collisions for hashCodes that do not differ
+ * in lower bits. Note: Null keys always map to hash 0, thus idx 0.
+ */
+- (NSInteger) hashInt:(NSInteger) h
+{
+    // This function ensures that hashCodes that differ only by
+    // constant multiples at each bit position have a bounded
+    // number of collisions (approximately 8 at default load factor).
+    h ^= (h >> 20) ^ (h >> 12);
+    return h ^ (h >> 7) ^ (h >> 4);
+}
+
+/**
+ * Returns idx for hash code h.
+ */
+- (NSInteger) indexFor:(NSInteger)h length:(NSInteger)length
+{
+    return h & (length - 1);
+}
+
#ifdef USERDOC
/*
*  FINDSCOPE  search hashed list for entry
@@ -370,7 +982,7 @@ static NSInteger itIndex;

-(void)setptrBuffer:(MapElement *)np Index:(NSInteger)idx
{
-    if ( idx < BuffSize ) {
+    if ( idx < Capacity ) {
[np retain];
ptrBuffer[idx] = np;
}
@@ -399,7 +1011,7 @@ static NSInteger itIndex;
MapElement *np;
NSInteger aTType;

-    aTType = ttype % BuffSize;
+    aTType = ttype % Capacity;
for( np = self->ptrBuffer[aTType]; np != nil; np = [np getfNext] ) {
if ( [(ACNumber *)np.node integerValue] == ttype ) {
return( np );        /*   found it       */
@@ -438,8 +1050,8 @@ static NSInteger itIndex;
NSInteger idx;

idx = [self count];
-    if ( idx >= BuffSize ) {
-        idx %= BuffSize;
+    if ( idx >= Capacity ) {
+        idx %= Capacity;
}
ptrBuffer[idx] = aRule;
}
@@ -448,8 +1060,8 @@ static NSInteger itIndex;
*/
- (void) insertObject:(id)aRule atIndex:(NSInteger)idx
{
-    if ( idx >= BuffSize ) {
-        idx %= BuffSize;
+    if ( idx >= Capacity ) {
+        idx %= Capacity;
}
if ( aRule != ptrBuffer[idx] ) {
if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
@@ -460,18 +1072,659 @@ static NSInteger itIndex;

- (id)objectAtIndex:(NSInteger)idx
{
-    if ( idx >= BuffSize ) {
-        idx %= BuffSize;
+    if ( idx >= Capacity ) {
+        idx %= Capacity;
}
return ptrBuffer[idx];
}

+/**
+ * Returns <tt>true</tt> if this map contains no key-value mappings.
+ *
+ * @return <tt>true</tt> if this map contains no key-value mappings
+ */
+- (BOOL) empty
+{
+    return count == 0;
+}
+
+/**
+ * Offloaded version of get() to look up null keys.  Null keys map
+ * to idx 0.  This null case is split out into separate methods
+ * for the sake of performance in the two most commonly used
+ * operations (get and put), but incorporated with conditionals in
+ * others.
+ */
+- (id) getForNullKey
+{
+
+    for (HMEntry *e = (HMEntry *)ptrBuffer[0]; e != nil; e = e.next) {
+        if (e.key == nil)
+            return e.value;
+    }
+
+    return nil;
+}
+
+/**
+ * Returns the value to which the specified key is mapped,
+ * or {@code null} if this map contains no mapping for the key.
+ *
+ * <p>More formally, if this map contains a mapping from a key
+ * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
+ * key.equals(k))}, then this method returns {@code v}; otherwise
+ * it returns {@code null}.  (There can be at most one such mapping.)
+ *
+ * <p>A return value of {@code null} does not <i>necessarily</i>
+ * indicate that the map contains no mapping for the key; it's also
+ * possible that the map explicitly maps the key to {@code null}.
+ * The {@link #containsKey containsKey} operation may be used to
+ * distinguish these two cases.
+ *
+ * @see #put(Object, Object)
+ */
+- (id) get:(NSString *)key
+{
+    if (key == nil)
+        return [self getForNullKey];
+    NSInteger hash = [self hashInt:[self hash:key]];
+
+    for (HMEntry *e = (HMEntry *)ptrBuffer[[self indexFor:hash length:[self capacity]]]; e != nil; e = e.next) {
+        NSString *k;
+        if (e.hash == hash && ((k = e.key) == key || [key isEqualTo:k]))
+            return e.value;
+    }
+
+    return nil;
+}
+
+
+/**
+ * Returns <tt>true</tt> if this map contains a mapping for the
+ * specified key.
+ *
+ * @param   key   The key whose presence in this map is to be tested
+ * @return <tt>true</tt> if this map contains a mapping for the specified
+ * key.
+ */
+- (BOOL) containsKey:(NSString *)key
+{
+    return [self getEntry:key] != nil;
+}
+
+/**
+ * Returns the entry associated with the specified key in the
+ * HashMap.  Returns null if the HashMap contains no mapping
+ * for the key.
+ */
+- (HMEntry *) getEntry:(NSString *)key
+{
+    NSInteger hash = (key == nil) ? 0 : [self hashInt:[self hash:key]];
+
+    for (HMEntry *e = (HMEntry *)ptrBuffer[[self indexFor:hash length:Capacity]]; e != nil; e = e.next) {
+        NSString *k;
+        if (e.hash == hash && ((k = e.key) == key || (key != nil && [key isEqualTo:k])))
+            return e;
+    }
+
+    return nil;
+}
+
+
+/**
+ * Associates the specified value with the specified key in this map.
+ * If the map previously contained a mapping for the key, the old
+ * value is replaced.
+ *
+ * @param key key with which the specified value is to be associated
+ * @param value value to be associated with the specified key
+ * @return the previous value associated with <tt>key</tt>, or
+ * <tt>null</tt> if there was no mapping for <tt>key</tt>.
+ * (A <tt>null</tt> return can also indicate that the map
+ * previously associated <tt>null</tt> with <tt>key</tt>.)
+ */
+- (id) put:(NSString *)key value:(id)value
+{
+    if (key == nil)
+        return [self putForNullKey:value];
+    NSInteger hash = [self hashInt:[self hash:key]];
+    NSInteger i = [self indexFor:hash length:[self capacity]];
+
+    for (HMEntry *e = (HMEntry *)ptrBuffer[i]; e != nil; e = e.next) {
+        NSString *k;
+        if (e.hash == hash && ((k = e.key) == key || [key isEqualTo:k])) {
+            id oldValue = e.value;
+            e.value = value;
+            [e recordAccess:self];
+            return oldValue;
+        }
+    }
+
+    modCount++;
+    [self addEntry:hash key:key value:value bucketIndex:i];
+    return nil;
+}
+
+
+/**
+ * Offloaded version of put for null keys
+ */
+- (id) putForNullKey:(id)value
+{
+
+    for (HMEntry *e = (HMEntry *)ptrBuffer[0]; e != nil; e = e.next) {
+        if (e.key == nil) {
+            id oldValue = e.value;
+            e.value = value;
+            [e recordAccess:self];
+            return oldValue;
+        }
+    }
+
+    modCount++;
+    [self addEntry:0 key:nil value:value bucketIndex:0];
+    return nil;
+}
+
+/**
+ * This method is used instead of put by constructors and
+ * pseudoconstructors (clone, readObject).  It does not resize the table,
+ * check for comodification, etc.  It calls createEntry rather than
+ * addEntry.
+ */
+- (void) putForCreate:(NSString *)key value:(id)value
+{
+    NSInteger hash = (key == nil) ? 0 : [self hashInt:[self hash:key]];
+    NSInteger i = [self indexFor:hash length:[self capacity]];
+
+    for (HMEntry *e = (HMEntry *)ptrBuffer[i]; e != nil; e = e.next) {
+        NSString *k;
+        if (e.hash == hash && ((k = e.key) == key || (key != nil && [key isEqualTo:k]))) {
+            e.value = value;
+            return;
+        }
+    }
+
+    [self createEntry:hash key:key value:value bucketIndex:i];
+}
+
+- (void) putAllForCreate:(HashMap *)m
+{
+
+    for (HMEntry *e in [m entrySet])
+        [self putForCreate:[e key] value:[e value]];
+
+}
+
+/**
+ * Rehashes the contents of this map into a new array with a
+ * larger capacity.  This method is called automatically when the
+ * number of keys in this map reaches its threshold.
+ *
+ * If current capacity is MAXIMUM_CAPACITY, this method does not
+ * resize the map, but sets threshold to Integer.MAX_VALUE.
+ * This has the effect of preventing future calls.
+ *
+ * @param newCapacity the new capacity, MUST be a power of two;
+ * must be greater than current capacity unless current
+ * capacity is MAXIMUM_CAPACITY (in which case value
+ * is irrelevant).
+ */
+- (void) resize:(NSInteger)newCapacity
+{
+//    NSArray * oldTable = ptrBuffer;
+    NSInteger oldCapacity = Capacity;
+    if (oldCapacity == MAXIMUM_CAPACITY) {
+        threshold = NSIntegerMax;
+        return;
+    }
+//    NSArray * newTable = [NSArray array];
+//    [self transfer:newTable];
+    BuffSize = newCapacity * sizeof(id);
+    Capacity = newCapacity;
+    [buffer setLength:BuffSize];
+    ptrBuffer = [buffer mutableBytes];
+    threshold = (NSInteger)(newCapacity * loadFactor);
+}
+
+
+/**
+ * Transfers all entries from current table to newTable.
+ */
+- (void) transfer:(AMutableArray *)newTable
+{
+    NSInteger newCapacity = [newTable count];
+
+    for (NSInteger j = 0; j < [self capacity]; j++) {
+        HMEntry *e = (HMEntry *)ptrBuffer[j];
+        if (e != nil) {
+            ptrBuffer[j] = nil;
+
+            do {
+                HMEntry *next = e.next;
+                NSInteger i = [self indexFor:e.hash length:newCapacity];
+                e.next = [newTable objectAtIndex:i];
+                [newTable replaceObjectAtIndex:i withObject:e];
+                e = next;
+            }
+            while (e != nil);
+        }
+    }
+
+}
+
+
+/**
+ * Copies all of the mappings from the specified map to this map.
+ * These mappings will replace any mappings that this map had for
+ * any of the keys currently in the specified map.
+ *
+ * @param m mappings to be stored in this map
+ * @throws NullPointerException if the specified map is null
+ */
+- (void) putAll:(HashMap *)m
+{
+    NSInteger numKeysToBeAdded = [m count];
+    if (numKeysToBeAdded == 0)
+        return;
+    if (numKeysToBeAdded > threshold) {
+        NSInteger targetCapacity = (NSInteger)(numKeysToBeAdded / loadFactor + 1);
+        if (targetCapacity > MAXIMUM_CAPACITY)
+            targetCapacity = MAXIMUM_CAPACITY;
+        NSInteger newCapacity = Capacity;
+
+        while (newCapacity < targetCapacity)
+            newCapacity <<= 1;
+
+        if (newCapacity > Capacity)
+            [self resize:newCapacity];
+    }
+
+    for (HMEntry *e in [m entrySet])
+        [self put:[e key] value:[e value]];
+
+}
+
+/**
+ * Removes the mapping for the specified key from this map if present.
+ *
+ * @param  key key whose mapping is to be removed from the map
+ * @return the previous value associated with <tt>key</tt>, or
+ * <tt>null</tt> if there was no mapping for <tt>key</tt>.
+ * (A <tt>null</tt> return can also indicate that the map
+ * previously associated <tt>null</tt> with <tt>key</tt>.)
+ */
+- (id) remove:(NSString *)key
+{
+    HMEntry *e = [self removeEntryForKey:key];
+    return (e == nil ? nil : e.value);
+}
+
+
+/**
+ * Removes and returns the entry associated with the specified key
+ * in the HashMap.  Returns null if the HashMap contains no mapping
+ * for this key.
+ */
+- (HMEntry *) removeEntryForKey:(NSString *)key
+{
+    NSInteger hash = (key == nil) ? 0 : [self hashInt:[self hash:key]];
+    NSInteger i = [self indexFor:hash length:Capacity];
+    HMEntry *prev = (HMEntry *)ptrBuffer[i];
+    HMEntry *e = prev;
+
+    while (e != nil) {
+        HMEntry *next = e.next;
+        NSString *k;
+        if (e.hash == hash && ((k = e.key) == key || (key != nil && [key isEqualTo:k]))) {
+            modCount++;
+            count--;
+            if (prev == e)
+                ptrBuffer[i] = (id) next;
+            else
+                prev.next = next;
+            [e recordRemoval:self];
+            return e;
+        }
+        prev = e;
+        e = next;
+    }
+
+    return e;
+}
+
+/**
+ * Special version of remove for EntrySet.
+ */
+- (HMEntry *) removeMapping:(id)o
+{
+//    if (!([o conformsToProtocol:@protocol(HMEntry)]))
+//        return nil;
+    HMEntry *entry = (HMEntry *)o;
+    NSString *key = entry.key;
+    NSInteger hash = (key == nil) ? 0 : [self hashInt:[self hash:key]];
+    NSInteger i = [self indexFor:hash length:Capacity];
+    HMEntry *prev = (HMEntry *)ptrBuffer[i];
+    HMEntry *e = prev;
+
+    while (e != nil) {
+        HMEntry *next = e.next;
+        if (e.hash == hash && [e isEqualTo:entry]) {
+            modCount++;
+            count--;
+            if (prev == e)
+                ptrBuffer[i] = (id)next;
+            else
+                prev.next = next;
+            [e recordRemoval:self];
+            return e;
+        }
+        prev = e;
+        e = next;
+    }
+
+    return e;
+}
+
+/**
+ * Removes all of the mappings from this map.
+ * The map will be empty after this call returns.
+ */
+- (void) clear
+{
+    modCount++;
+    id tmp;
+
+    for (NSInteger i = 0; i < Capacity; i++) {
+        tmp = ptrBuffer[i];
+        if ( tmp ) {
+            [tmp release];
+        }
+        ptrBuffer[i] = nil;
+    }
+    count = 0;
+}
+
+
+/**
+ * Special-case code for containsValue with null argument
+ */
+- (BOOL) containsNullValue
+{
+    for (NSInteger i = 0; i < Capacity; i++)
+
+        for (HMEntry *e = (HMEntry *)ptrBuffer[i]; e != nil; e = e.next)
+            if (e.value == nil)
+                return YES;
+    return NO;
+}
+
+/**
+ * Returns <tt>true</tt> if this map maps one or more keys to the
+ * specified value.
+ *
+ * @param value value whose presence in this map is to be tested
+ * @return <tt>true</tt> if this map maps one or more keys to the
+ * specified value
+ */
+- (BOOL) containsValue:(id)value
+{
+    if (value == nil)
+        return [self containsNullValue];
+
+    for (NSInteger i = 0; i < Capacity; i++)
+
+        for (HMEntry *e = (HMEntry *)ptrBuffer[i]; e != nil; e = e.next)
+            if ([value isEqualTo:e.value])
+                return YES;
+
+
+    return NO;
+}
+
+/**
+ * Returns a shallow copy of this <tt>HashMap</tt> instance: the keys and
+ * values themselves are not cloned.
+ *
+ * @return a shallow copy of this map
+ */
+- (id) copyWithZone:(NSZone *)zone
+{
+    HashMap *result = nil;
+
+    //    @try {
+    result = [HashMap allocWithZone:zone];
+//        result = (HashMap *)[super copyWithZone:zone];
+//    }
+//    @catch (CloneNotSupportedException * e) {
+//    }
+    result.ptrBuffer = ptrBuffer;
+    result.entrySet = nil;
+    //    result.modCount = 0;
+    //    result.count = 0;
+    //    [result init];
+    [result putAllForCreate:self];
+    result.count = count;
+    result.threshold = threshold;
+    result.loadFactor = loadFactor;
+    result.modCount = modCount;
+    result.entrySet = entrySet;
+    return result;
+}
+
+
+/**
+ * Returns a string representation of this map.  The string representation
+ * consists of a list of key-value mappings in the order returned by the
+ * map's <tt>entrySet</tt> view's iterator, enclosed in braces
+ * (<tt>"{}"</tt>).  Adjacent mappings are separated by the characters
+ * <tt>", "</tt> (comma and space).  Each key-value mapping is rendered as
+ * the key followed by an equals sign (<tt>"="</tt>) followed by the
+ * associated value.  Keys and values are converted to strings as by
+ * {@link String#valueOf(Object)}.
+ *
+ * @return a string representation of this map
+ */
+- (NSString *)description
+{
+    HashIterator *it = [[self entrySet] iterator];
+    if (![it hasNext])
+        return @"{}";
+
+    NSMutableString *sb = [NSMutableString stringWithCapacity:40];
+    [sb appendString:@"{"];
+    while ( YES ) {
+        HMEntry *e = [it next];
+        NSString *key = e.key;
+        id value = e.value;
+        [sb appendFormat:@"%@=%@", (key == self ? @"[self Map]" : key), (value == self ? @"[self Map]" : value)];
+        if ( ![it hasNext] )
+            return [sb append:@"}"];
+        [sb appendString:@", "];
+    }
+}
+
+/**
+ * Adds a new entry with the specified key, value and hash code to
+ * the specified bucket.  It is the responsibility of this
+ * method to resize the table if appropriate.
+ *
+ * Subclass overrides this to alter the behavior of put method.
+ */
+- (void) addEntry:(NSInteger)hash key:(NSString *)key value:(id)value bucketIndex:(NSInteger)bucketIndex
+{
+    HMEntry *e = (HMEntry *)ptrBuffer[bucketIndex];
+    ptrBuffer[bucketIndex] = [[HMEntry alloc] init:hash key:key value:value next:e];
+    if (count++ >= threshold)
+        [self resize:2 * BuffSize];
+}
+
+/**
+ * Like addEntry except that this version is used when creating entries
+ * as part of Map construction or "pseudo-construction" (cloning,
+ * deserialization).  This version needn't worry about resizing the table.
+ *
+ * Subclass overrides this to alter the behavior of HashMap(Map),
+ * clone, and readObject.
+ */
+- (void) createEntry:(NSInteger)hash key:(NSString *)key value:(id)value bucketIndex:(NSInteger)bucketIndex
+{
+    HMEntry *e = (HMEntry *)ptrBuffer[bucketIndex];
+    ptrBuffer[bucketIndex] = [[HMEntry alloc] init:hash key:key value:value next:e];
+    count++;
+}
+
+- (HMKeyIterator *) newKeyIterator
+{
+    return [HMKeyIterator newIterator:self];
+}
+
+- (HMValueIterator *) newValueIterator
+{
+    return [HMValueIterator newIterator:self];
+}
+
+- (HMEntryIterator *) newEntryIterator
+{
+    return [HMEntryIterator newIterator:self];
+}
+
+
+/**
+ * Returns a {@link Set} view of the keys contained in this map.
+ * The set is backed by the map, so changes to the map are
+ * reflected in the set, and vice-versa.  If the map is modified
+ * while an iteration over the set is in progress (except through
+ * the iterator's own <tt>remove</tt> operation), the results of
+ * the iteration are undefined.  The set supports element removal,
+ * which removes the corresponding mapping from the map, via the
+ * <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,
+ * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>
+ * operations.  It does not support the <tt>add</tt> or <tt>addAll</tt>
+ * operations.
+ */
+- (HMKeySet *) keySet
+{
+    HMKeySet *ks = keySet;
+    return (ks != nil ? ks : (keySet = [HMKeySet newKeySet:self]));
+}
+
+
+/**
+ * Returns a {@link Collection} view of the values contained in this map.
+ * The collection is backed by the map, so changes to the map are
+ * reflected in the collection, and vice-versa.  If the map is
+ * modified while an iteration over the collection is in progress
+ * (except through the iterator's own <tt>remove</tt> operation),
+ * the results of the iteration are undefined.  The collection
+ * supports element removal, which removes the corresponding
+ * mapping from the map, via the <tt>Iterator.remove</tt>,
+ * <tt>Collection.remove</tt>, <tt>removeAll</tt>,
+ * <tt>retainAll</tt> and <tt>clear</tt> operations.  It does not
+ * support the <tt>add</tt> or <tt>addAll</tt> operations.
+ */
+- (Values *) values
+{
+    Values *vs = values;
+    return (vs != nil ? vs : (values = [Values newValueSet:self]));
+}
+
+
+/**
+ * Returns a {@link Set} view of the mappings contained in this map.
+ * The set is backed by the map, so changes to the map are
+ * reflected in the set, and vice-versa.  If the map is modified
+ * while an iteration over the set is in progress (except through
+ * the iterator's own <tt>remove</tt> operation, or through the
+ * <tt>setValue</tt> operation on a map entry returned by the
+ * iterator) the results of the iteration are undefined.  The set
+ * supports element removal, which removes the corresponding
+ * mapping from the map, via the <tt>Iterator.remove</tt>,
+ * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and
+ * <tt>clear</tt> operations.  It does not support the
+ * <tt>add</tt> or <tt>addAll</tt> operations.
+ *
+ * @return a set view of the mappings contained in this map
+ */
+- (HMEntrySet *) entrySet0
+{
+    HMEntrySet *es = entrySet;
+    return es != nil ? es : (entrySet = [HMEntrySet newEntrySet:self]);
+}
+
+- (HMEntrySet *) entrySet
+{
+    return [self entrySet0];
+}
+
+
+/**
+ * Save the state of the <tt>HashMap</tt> instance to a stream (i.e.,
+ * serialize it).
+ *
+ * @serialData The <i>capacity</i> of the HashMap (the length of the
+ * bucket array) is emitted (NSInteger), followed by the
+ * <i>count</i> (an NSInteger, the number of key-value
+ * mappings), followed by the key (Object) and value (Object)
+ * for each key-value mapping.  The key-value mappings are
+ * emitted in no particular order.
+ */
+- (void) writeObject:(NSOutputStream *)s
+{
+/*
+    NSEnumerator * i = (count > 0) ? [[self entrySet0] iterator] : nil;
+    [s defaultWriteObject];
+    [s writeInt:[buffer length]];
+    [s writeInt:count];
+    if (i != nil) {
+        while ([i hasNext]) {
+            HMEntry *e = [i nextObject];
+            [s writeObject:[e key]];
+            [s writeObject:[e value]];
+        }
+
+    }
+ */
+}
+
+
+/**
+ * Reconstitute the <tt>HashMap</tt> instance from a stream (i.e.,
+ * deserialize it).
+ */
+- (void) readObject:(NSInputStream *)s
+{
+/*
+    [s defaultReadObject];
+    NSInteger numBuckets = [s readInt];
+    ptrBuffer = [NSArray array];
+    [self init];
+    NSInteger count = [s readInt];
+
+    for (NSInteger i = 0; i < count; i++) {
+        NSString * key = (NSString *)[s readObject];
+        id value = (id)[s readObject];
+        [self putForCreate:key value:value];
+    }
+ */
+}
+
+- (NSInteger) capacity
+{
+    return Capacity;
+}
+
+- (float) loadFactor
+{
+    return loadFactor;
+}
+
/* this will never link into the chain
*/
- (void) setObject:(id)aRule atIndex:(NSInteger)idx
{
-    if ( idx >= BuffSize ) {
-        idx %= BuffSize;
+    if ( idx >= Capacity ) {
+        idx %= Capacity;
}
if ( aRule != ptrBuffer[idx] ) {
if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
@@ -507,7 +1760,7 @@ static NSInteger itIndex;

- (BOOL)hasNext
{
-    if (self && [self count] < BuffSize-1) {
+    if (self && [self count] < Capacity-1) {
return YES;
}
return NO;
@@ -515,15 +1768,11 @@ static NSInteger itIndex;

- (MapElement *)nextObject
{
-    if (self && itIndex < BuffSize-1) {
+    if (self && itIndex < Capacity-1) {
return ptrBuffer[itIndex];
}
return nil;
}

-@synthesize BuffSize;
-@synthesize count;
-@synthesize ptr;
-@synthesize ptrBuffer;
-@synthesize buffer;
@end
+
diff --git a/runtime/ObjC/Framework/LinkedHashMap.h b/runtime/ObjC/Framework/LinkedHashMap.h
new file mode 100644
index 0000000..224ea0c
--- /dev/null
+++ b/runtime/ObjC/Framework/LinkedHashMap.h
@@ -0,0 +1,240 @@
+#import "HashMap.h"
+/**
+ * <p>Hash table and linked list implementation of the <tt>Map</tt> interface,
+ * with predictable iteration order.  This implementation differs from
+ * <tt>HashMap</tt> in that it maintains a doubly-linked list running through
+ * all of its entries.  This linked list defines the iteration ordering,
+ * which is normally the order in which keys were inserted into the map
+ * (<i>insertion-order</i>).  Note that insertion order is not affected
+ * if a key is <i>re-inserted</i> into the map.  (A key <tt>k</tt> is
+ * reinserted into a map <tt>m</tt> if <tt>m.put(k, v)</tt> is invoked when
+ * <tt>m.containsKey(k)</tt> would return <tt>true</tt> immediately prior to
+ * the invocation.)
+ *
+ * <p>This implementation spares its clients from the unspecified, generally
+ * chaotic ordering provided by {@link HashMap} (and {@link Hashtable}),
+ * without incurring the increased cost associated with {@link TreeMap}.  It
+ * can be used to produce a copy of a map that has the same order as the
+ * original, regardless of the original map's implementation:
+ * <pre>
+ * void foo(Map m) {
+ * Map copy = new LinkedHashMap(m);
+ * ...
+ * }
+ * </pre>
+ * This technique is particularly useful if a module takes a map on input,
+ * copies it, and later returns results whose order is determined by that of
+ * the copy.  (Clients generally appreciate having things returned in the same
+ * order they were presented.)
+ *
+ * <p>A special {@link #LinkedHashMap(NSInteger,float,boolean) constructor} is
+ * provided to create a linked hash map whose order of iteration is the order
+ * in which its entries were last accessed, from least-recently accessed to
+ * most-recently (<i>access-order</i>).  This kind of map is well-suited to
+ * building LRU caches.  Invoking the <tt>put</tt> or <tt>get</tt> method
+ * results in an access to the corresponding entry (assuming it exists after
+ * the invocation completes).  The <tt>putAll</tt> method generates one entry
+ * access for each mapping in the specified map, in the order that key-value
+ * mappings are provided by the specified map's entry set iterator.  <i>No
+ * other methods generate entry accesses.</i> In particular, operations on
+ * collection-views do <i>not</i> affect the order of iteration of the backing
+ * map.
+ *
+ * <p>The {@link #removeEldestEntry(Map.Entry)} method may be overridden to
+ * impose a policy for removing stale mappings automatically when new mappings
+ * are added to the map.
+ *
+ * <p>This class provides all of the optional <tt>Map</tt> operations, and
+ * permits null elements.  Like <tt>HashMap</tt>, it provides constant-time
+ * performance for the basic operations (<tt>add</tt>, <tt>contains</tt> and
+ * <tt>remove</tt>), assuming the hash function disperses elements
+ * properly among the buckets.  Performance is likely to be just slightly
+ * below that of <tt>HashMap</tt>, due to the added expense of maintaining the
+ * linked list, with one exception: Iteration over the collection-views
+ * of a <tt>LinkedHashMap</tt> requires time proportional to the <i>size</i>
+ * of the map, regardless of its capacity.  Iteration over a <tt>HashMap</tt>
+ * is likely to be more expensive, requiring time proportional to its
+ * <i>capacity</i>.
+ *
+ * <p>A linked hash map has two parameters that affect its performance:
+ * <i>initial capacity</i> and <i>load factor</i>.  They are defined precisely
+ * as for <tt>HashMap</tt>.  Note, however, that the penalty for choosing an
+ * excessively high value for initial capacity is less severe for this class
+ * than for <tt>HashMap</tt>, as iteration times for this class are unaffected
+ * by capacity.
+ *
+ * <p><strong>Note that this implementation is not synchronized.</strong>
+ * If multiple threads access a linked hash map concurrently, and at least
+ * one of the threads modifies the map structurally, it <em>must</em> be
+ * synchronized externally.  This is typically accomplished by
+ * synchronizing on some object that naturally encapsulates the map.
+ *
+ * If no such object exists, the map should be "wrapped" using the
+ * {@link Collections#synchronizedMap Collections.synchronizedMap}
+ * method.  This is best done at creation time, to prevent accidental
+ * unsynchronized access to the map:<pre>
+ * Map m = Collections.synchronizedMap(new LinkedHashMap(...));</pre>
+ *
+ * A structural modification is any operation that adds or deletes one or more
+ * mappings or, in the case of access-ordered linked hash maps, affects
+ * iteration order.  In insertion-ordered linked hash maps, merely changing
+ * the value associated with a key that is already contained in the map is not
+ * a structural modification.  <strong>In access-ordered linked hash maps,
+ * merely querying the map with <tt>get</tt> is a structural
+ * modification.</strong>)
+ *
+ * <p>The iterators returned by the <tt>iterator</tt> method of the collections
+ * returned by all of this class's collection view methods are
+ * <em>fail-fast</em>: if the map is structurally modified at any time after
+ * the iterator is created, in any way except through the iterator's own
+ * <tt>remove</tt> method, the iterator will throw a {@link
+ * ConcurrentModificationException}.  Thus, in the face of concurrent
+ * modification, the iterator fails quickly and cleanly, rather than risking
+ * arbitrary, non-deterministic behavior at an undetermined time in the future.
+ *
+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
+ * as it is, generally speaking, impossible to make any hard guarantees in the
+ * presence of unsynchronized concurrent modification.  Fail-fast iterators
+ * throw <tt>ConcurrentModificationException</tt> on a best-effort basis.
+ * Therefore, it would be wrong to write a program that depended on this
+ * exception for its correctness:   <i>the fail-fast behavior of iterators
+ * should be used only to detect bugs.</i>
+ *
+ * <p>This class is a member of the
+ * <a href="{@docRoot}/../technotes/guides/collections/index.html">
+ * Java Collections Framework</a>.
+ *
+ * @param <K> the type of keys maintained by this map
+ * @param <V> the type of mapped values
+ *
+ * @author  Josh Bloch
+ * @see     Object#hashCode()
+ * @see     Collection
+ * @see     Map
+ * @see     HashMap
+ * @see     TreeMap
+ * @see     Hashtable
+ * @since   1.4
+ */
+@class LinkedHashMap;
+
+/**
+ * LinkedHashMap entry.
+ */
+
+@interface LHMEntry : HMEntry
+{
+    LHMEntry *before;
+    LHMEntry *after;
+    BOOL accessOrder;
+}
+
+@property (retain) LHMEntry *before;
+@property (retain) LHMEntry *after;
+@property (assign) BOOL accessOrder;
+
+- (id) newEntry:(NSInteger)aHash key:(NSString *)aKey value:(id)aValue next:(LHMEntry *)aNext;
+
+- (id) init:(NSInteger)hash key:(NSString *)key value:(id)value next:(LHMEntry *)next;
+- (void) recordAccess:(LinkedHashMap *)m;
+- (void) recordRemoval:(LinkedHashMap *)m;
+
+@end
+
+/**
+ * LinkedHashMapIterator.
+ */
+
+@interface LinkedHashIterator : HashIterator
+{
+    LHMEntry *nextEntry;
+    LHMEntry *lastReturned;
+    LinkedHashMap *lhm;
+}
+
+@property (retain) LHMEntry *nextEntry;
+@property (retain) LHMEntry *lastReturned;
+@property (retain) LinkedHashMap *lhm;
+
++ (LinkedHashIterator *) newIterator:(LinkedHashMap *)aLHM;
+
+- (id) init:(LinkedHashMap *)aLHM;
+- (BOOL) hasNext;
+- (void) remove;
+- (LHMEntry *) nextEntry;
+@end
+
+@interface LHMEntryIterator : LinkedHashIterator
+{
+}
+
++ (LHMEntryIterator *)newIterator:(LinkedHashMap *)aHM;
+
+- (id) init:(LinkedHashMap *)aHM;
+- (LHMEntry *) next;
+@end
+
+@interface LHMKeyIterator : LinkedHashIterator
+{
+}
+
++ (LHMKeyIterator *)newIterator:(LinkedHashMap *)aHM;
+
+- (id) init:(LinkedHashMap *)aHM;
+- (NSString *) next;
+@end
+
+@interface LHMValueIterator : LinkedHashIterator
+{
+}
+
++ (LHMValueIterator *)newIterator:(LinkedHashMap *)aHM;
+
+- (id) init:(LinkedHashMap *)aHM;
+- (id) next;
+@end
+
+
+@interface LinkedHashMap : HashMap
+{
+
+    /**
+     * The head of the doubly linked list.
+     */
+    LHMEntry *header;
+    /**
+     * The iteration ordering method for this linked hash map: <tt>true</tt>
+     * for access-order, <tt>false</tt> for insertion-order.
+     *
+     * @serial
+     */
+    BOOL accessOrder;
+
+}
+
+@property (retain) LHMEntry *header;
+@property (assign) BOOL accessOrder;
+
++ (id) newLinkedHashMap:(NSInteger)anInitialCapacity;
++ (id) newLinkedHashMap:(NSInteger)anInitialCapacity
+             loadFactor:(float)loadFactor;
++ (id) newLinkedHashMap:(NSInteger)anInitialCapacity
+             loadFactor:(float)loadFactor
+            accessOrder:(BOOL)anAccessOrder;
+
+- (id) init:(NSInteger)initialCapacity loadFactor:(float)loadFactor accessOrder:(BOOL)accessOrder;
+- (id) init:(NSInteger)initialCapacity loadFactor:(float)loadFactor;
+- (id) init:(NSInteger)initialCapacity;
+- (id) init;
+- (id) initWithM:(AMutableDictionary *)m;
+- (void) transfer:(NSArray *)newTable;
+- (BOOL) containsValue:(NSObject *)value;
+- (id) get:(NSString *)key;
+- (void) clear;
+- (LHMEntryIterator *) newEntryIterator;
+- (LHMKeyIterator *) newKeyIterator;
+- (LHMValueIterator *) newValueIterator;
+- (void) addEntry:(NSInteger)hash key:(NSString *)key value:(id)value bucketIndex:(NSInteger)bucketIndex;
+- (void) createEntry:(NSInteger)hash key:(NSString *)key value:(id)value bucketIndex:(NSInteger)bucketIndex;
+- (BOOL) removeEldestEntry:(LHMEntry *)eldest;
+@end
diff --git a/runtime/ObjC/Framework/LinkedHashMap.m b/runtime/ObjC/Framework/LinkedHashMap.m
new file mode 100644
index 0000000..cbb03ee
--- /dev/null
+++ b/runtime/ObjC/Framework/LinkedHashMap.m
@@ -0,0 +1,513 @@
+#import <Cocoa/Cocoa.h>
+#import "AMutableArray.h"
+#import "LinkedHashMap.h"
+#import "RuntimeException.h"
+
+extern NSInteger const DEFAULT_INITIAL_CAPACITY;
+extern float const DEFAULT_LOAD_FACTOR;
+
+@implementation LHMEntry
+
+@synthesize before;
+@synthesize after;
+@synthesize accessOrder;
+
+- (id) newEntry:(NSInteger)aHash key:(NSString *)aKey value:(id)aValue next:(LHMEntry *)aNext
+{
+    return [[LHMEntry alloc] init:aHash key:aKey value:aValue next:aNext];
+}
+
+- (id) init:(NSInteger)aHash key:(NSString *)aKey value:(id)aValue next:(LHMEntry *)aNext
+{
+    self = [super init:aHash key:aKey value:aValue next:aNext];
+    if (self) {
+    }
+    return self;
+}
+
+
+- (void) dealloc
+{
+    [before release];
+    [after release];
+    [super dealloc];
+}
+
+/**
+ * Removes this entry from the linked list.
+ */
+- (void) removeEntry
+{
+    before.after = after;
+    after.before = before;
+}
+
+
+/**
+ * Inserts this entry before the specified existing entry in the list.
+ */
+- (void) addBefore:(LHMEntry *)existingEntry
+{
+    after = [existingEntry retain];
+    before = [existingEntry.before retain];
+    before.after = [self retain];
+    after.before = [self retain];
+}
+
+
+/**
+ * This method is invoked by the superclass whenever the value
+ * of a pre-existing entry is read by Map.get or modified by Map.set.
+ * If the enclosing Map is access-ordered, it moves the entry
+ * to the end of the list; otherwise, it does nothing.
+ */
+- (void) recordAccess:(LinkedHashMap *)m
+{
+    LinkedHashMap *lhm = (LinkedHashMap *)m;
+    if (lhm.accessOrder) {
+        lhm.modCount++;
+        [self removeEntry];
+        [self addBefore:lhm.header];
+    }
+}
+
+- (void) recordRemoval:(LinkedHashMap *)m
+{
+    [self removeEntry];
+}
+
+@end
+
+@implementation LinkedHashIterator
+
+@synthesize nextEntry;
+@synthesize lastReturned;
+@synthesize lhm;
+
++ (LinkedHashIterator *) newIterator:(LinkedHashMap *)aLHM
+{
+    return [[LinkedHashIterator alloc] init:aLHM];
+}
+
+- (id) init:(LinkedHashMap *)aLHM
+{
+    self = [super init];
+    if ( self ) {
+        lhm = aLHM;
+        nextEntry = lhm.header.after;
+        lastReturned = nil;
+        expectedModCount = lhm.modCount;
+/*
+        AMutableArray *a = [AMutableArray arrayWithCapacity:lhm.Capacity];
+        LHMEntry *tmp = lhm.header.after;
+        while ( tmp != lhm.header ) {
+            [a addObject:tmp];
+            tmp = tmp.after;
+        }
+        anArray = [NSArray arrayWithArray:a];
+ */
+    }
+    return self;
+}
+
+- (BOOL) hasNext
+{
+    return nextEntry != lhm.header;
+}
+
+- (void) remove
+{
+    if (lastReturned == nil)
+        @throw [[IllegalStateException newException] autorelease];
+    if (lhm.modCount != expectedModCount)
+        @throw [[ConcurrentModificationException newException:@"Unexpected modCount"] autorelease];
+    [lhm remove:(NSString *)(lastReturned.key)];
+    lastReturned = nil;
+    expectedModCount = lhm.modCount;
+}
+
+- (LHMEntry *) nextEntry
+{
+    if (lhm.modCount != expectedModCount)
+        @throw [[ConcurrentModificationException newException:@"Unexpected modCount"] autorelease];
+    if (nextEntry == lhm.header)
+        @throw [[[NoSuchElementException alloc] init] autorelease];
+    LHMEntry * e = lastReturned = nextEntry;
+    nextEntry = e.after;
+    return e;
+}
+
+- (void) dealloc
+{
+    [nextEntry release];
+    [lastReturned release];
+    [super dealloc];
+}
+
+@end
+
+@implementation LHMKeyIterator
++ (LHMKeyIterator *)newIterator:(LinkedHashMap *)aLHM
+{
+    return [[LHMKeyIterator alloc] init:aLHM];
+}
+
+- (id) init:(LinkedHashMap *)aLHM
+{
+    self = [super init:aLHM];
+    if ( self ) {
+    }
+    return self;
+}
+
+- (NSString *) next
+{
+    return [self nextEntry].key;
+}
+
+@end
+
+@implementation LHMValueIterator
++ (LHMValueIterator *)newIterator:(LinkedHashMap *)aLHM
+{
+    return [[LHMValueIterator alloc] init:aLHM];
+}
+
+- (id) init:(LinkedHashMap *)aLHM
+{
+    self = [super init:aLHM];
+    if ( self ) {
+    }
+    return self;
+}
+
+- (id) next
+{
+    return [self nextEntry].value;
+}
+
+@end
+
+@implementation LHMEntryIterator
++ (LHMEntryIterator *)newIterator:(LinkedHashMap *)aLHM
+{
+    return [[LHMEntryIterator alloc] init:aLHM];
+}
+
+- (id) init:(LinkedHashMap *)aLHM
+{
+    self = [super init:aLHM];
+    if ( self ) {
+    }
+    return self;
+}
+
+- (LHMEntry *) next
+{
+    return [self nextEntry];
+}
+
+@end
+
+//long const serialVersionUID = 3801124242820219131L;
+
+@implementation LinkedHashMap
+
+@synthesize header;
+@synthesize accessOrder;
+
+/**
+ * Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance
+ * with the specified initial capacity and load factor.
+ *
+ * @param  initialCapacity the initial capacity
+ * @param  loadFactor      the load factor
+ * @throws IllegalArgumentException if the initial capacity is negative
+ * or the load factor is nonpositive
+ */
++ (id) newLinkedHashMap:(NSInteger)anInitialCapacity
+             loadFactor:(float)loadFactor
+            accessOrder:(BOOL)anAccessOrder
+{
+    return [[LinkedHashMap alloc] init:anInitialCapacity
+                            loadFactor:loadFactor
+                           accessOrder:(BOOL)anAccessOrder];
+}
+
++ (id) newLinkedHashMap:(NSInteger)anInitialCapacity loadFactor:(float)loadFactor
+{
+    return [[LinkedHashMap alloc] init:anInitialCapacity loadFactor:loadFactor];
+}
+
++ (id) newLinkedHashMap:(NSInteger)anInitialCapacity
+{
+    return [[LinkedHashMap alloc] init:anInitialCapacity loadFactor:DEFAULT_LOAD_FACTOR];
+}
+
+/**
+ * Constructs an empty <tt>LinkedHashMap</tt> instance with the
+ * specified initial capacity, load factor and ordering mode.
+ *
+ * @param  initialCapacity the initial capacity
+ * @param  loadFactor      the load factor
+ * @param  accessOrder     the ordering mode - <tt>true</tt> for
+ * access-order, <tt>false</tt> for insertion-order
+ * @throws IllegalArgumentException if the initial capacity is negative
+ * or the load factor is nonpositive
+ */
+- (id) init:(NSInteger)anInitialCapacity loadFactor:(float)aLoadFactor accessOrder:(BOOL)anAccessOrder
+{
+    self = [super init:anInitialCapacity loadFactor:aLoadFactor];
+    if ( self ) {
+        accessOrder = anAccessOrder;
+        header = [[[LHMEntry alloc] init:-1 key:nil value:nil next:nil] retain];
+        header.before = header.after = header;
+    }
+    return self;
+}
+
+- (id) init:(NSInteger)anInitialCapacity loadFactor:(float)aLoadFactor
+{
+    self = [super init:anInitialCapacity loadFactor:aLoadFactor];
+    if ( self ) {
+        accessOrder = NO;
+        header = [[[LHMEntry alloc] init:-1 key:nil value:nil next:nil] retain];
+        header.before = header.after = header;
+    }
+    return self;
+}
+
+/**
+ * Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance
+ * with the specified initial capacity and a default load factor (0.75).
+ *
+ * @param  initialCapacity the initial capacity
+ * @throws IllegalArgumentException if the initial capacity is negative
+ */
+- (id) init:(NSInteger)initialCapacity
+{
+    self = [super init:initialCapacity loadFactor:DEFAULT_LOAD_FACTOR];
+    if ( self ) {
+        accessOrder = NO;
+        header = [[[LHMEntry alloc] init:-1 key:nil value:nil next:nil] retain];
+        header.before = header.after = header;
+    }
+    return self;
+}
+
+/**
+ * Constructs an insertion-ordered <tt>LinkedHashMap</tt> instance with
+ * the same mappings as the specified map.  The <tt>LinkedHashMap</tt>
+ * instance is created with a default load factor (0.75) and an initial
+ * capacity sufficient to hold the mappings in the specified map.
+ *
+ * @param  m the map whose mappings are to be placed in this map
+ * @throws NullPointerException if the specified map is null
+ */
+- (id) initWithM:(LinkedHashMap *)m
+{
+    self = [super initWithM:m];
+    if ( self ) {
+        accessOrder = NO;
+        header = [[[LHMEntry alloc] init:-1 key:nil value:nil next:nil] retain];
+        header.before = header.after = header;
+    }
+    return self;
+}
+
+/**
+ * Constructs an empty insertion-ordered <tt>LinkedHashMap</tt> instance
+ * with the default initial capacity (16) and load factor (0.75).
+ */
+- (id) init
+{
+    self = [super init];
+    if ( self ) {
+        accessOrder = NO;
+        header = [[[LHMEntry alloc] init:-1 key:nil value:nil next:nil] retain];
+        header.before = header.after = header;
+    }
+    return self;
+}
+
+
+/**
+ * Transfers all entries to new table array.  This method is called
+ * by superclass resize.  It is overridden for performance, as it is
+ * faster to iterate using our linked list.
+ */
+- (void) transfer:(AMutableArray *)newTable
+{
+    NSInteger newCapacity = [newTable count];
+
+    for (LHMEntry * e = header.after; e != header; e = e.after) {
+        NSInteger index = [self indexFor:e.hash length:newCapacity];
+        e.next = [newTable objectAtIndex:index];
+        [newTable replaceObjectAtIndex:index withObject:e];
+    }
+
+}
+
+/**
+ * Returns <tt>true</tt> if this map maps one or more keys to the
+ * specified value.
+ *
+ * @param value value whose presence in this map is to be tested
+ * @return <tt>true</tt> if this map maps one or more keys to the
+ * specified value
+ */
+- (BOOL) containsValue:(id)value
+{
+    if (value == nil) {
+
+        for (LHMEntry * e = header.after; e != header; e = e.after)
+            if (e.value == nil)
+                return YES;
+
+    }
+    else {
+
+        for (LHMEntry * e = header.after; e != header; e = e.after)
+            if ([value isEqualTo:e.value])
+                return YES;
+
+    }
+    return NO;
+}
+
+/**
+ * Returns the value to which the specified key is mapped,
+ * or {@code null} if this map contains no mapping for the key.
+ *
+ * <p>More formally, if this map contains a mapping from a key
+ * {@code k} to a value {@code v} such that {@code (key==null ? k==null :
+ * key.equals(k))}, then this method returns {@code v}; otherwise
+ * it returns {@code null}.  (There can be at most one such mapping.)
+ *
+ * <p>A return value of {@code null} does not <i>necessarily</i>
+ * indicate that the map contains no mapping for the key; it's also
+ * possible that the map explicitly maps the key to {@code null}.
+ * The {@link #containsKey containsKey} operation may be used to
+ * distinguish these two cases.
+ */
+- (id) get:(NSString *)aKey
+{
+    LHMEntry * e = (LHMEntry *)[self getEntry:aKey];
+    if (e == nil)
+        return nil;
+    [e recordAccess:self];
+    return e.value;
+}
+
+
+/**
+ * Removes all of the mappings from this map.
+ * The map will be empty after this call returns.
+ */
+- (void) clear
+{
+    [super clear];
+    header.before = header.after = header;
+}
+
+- (void) dealloc {
+    [header release];
+    [super dealloc];
+}
+
+- (LHMEntryIterator *) newEntryIterator
+{
+    return [LHMEntryIterator newIterator:self];
+}
+
+- (LHMKeyIterator *) newKeyIterator
+{
+    return [LHMKeyIterator newIterator:self];
+}
+
+- (LHMValueIterator *) newValueIterator
+{
+    return [LHMValueIterator newIterator:self];
+}
+
+
+/**
+ * This override alters behavior of superclass put method. It causes newly
+ * allocated entry to get inserted at the end of the linked list and
+ * removes the eldest entry if appropriate.
+ */
+- (void) addEntry:(NSInteger)aHash key:(NSString *)aKey value:(id)aValue bucketIndex:(NSInteger)aBucketIndex
+{
+    [self createEntry:aHash key:aKey value:aValue bucketIndex:aBucketIndex];
+    LHMEntry * eldest = header.after;
+    if ([self removeEldestEntry:eldest]) {
+        [self removeEntryForKey:eldest.key];
+    }
+    else {
+        if (count >= threshold)
+            [self resize:2 * [buffer length]];
+    }
+}
+
+
+/**
+ * This override differs from addEntry in that it doesn't resize the
+ * table or remove the eldest entry.
+ */
+- (void) createEntry:(NSInteger)aHash key:(NSString *)aKey value:(id)aValue bucketIndex:(NSInteger)bucketIndex
+{
+    LHMEntry *old = (LHMEntry *)ptrBuffer[bucketIndex];
+    LHMEntry *e = [[[LHMEntry alloc] init:aHash key:aKey value:aValue next:old] retain];
+    ptrBuffer[bucketIndex] = (id)e;
+    [e addBefore:header];
+    count++;
+}
+
+
+/**
+ * Returns <tt>true</tt> if this map should remove its eldest entry.
+ * This method is invoked by <tt>put</tt> and <tt>putAll</tt> after
+ * inserting a new entry into the map.  It provides the implementor
+ * with the opportunity to remove the eldest entry each time a new one
+ * is added.  This is useful if the map represents a cache: it allows
+ * the map to reduce memory consumption by deleting stale entries.
+ *
+ * <p>Sample use: this override will allow the map to grow up to 100
+ * entries and then delete the eldest entry each time a new entry is
+ * added, maintaining a steady state of 100 entries.
+ * <pre>
+ * private static final NSInteger MAX_ENTRIES = 100;
+ *
+ * protected boolean removeEldestEntry(Map.LHMEntry eldest) {
+ * return count() > MAX_ENTRIES;
+ * }
+ * </pre>
+ *
+ * <p>This method typically does not modify the map in any way,
+ * instead allowing the map to modify itself as directed by its
+ * return value.  It <i>is</i> permitted for this method to modify
+ * the map directly, but if it does so, it <i>must</i> return
+ * <tt>false</tt> (indicating that the map should not attempt any
+ * further modification).  The effects of returning <tt>true</tt>
+ * after modifying the map from within this method are unspecified.
+ *
+ * <p>This implementation merely returns <tt>false</tt> (so that this
+ * map acts like a normal map - the eldest element is never removed).
+ *
+ * @param    eldest The least recently inserted entry in the map, or if
+ * this is an access-ordered map, the least recently accessed
+ * entry.  This is the entry that will be removed it this
+ * method returns <tt>true</tt>.  If the map was empty prior
+ * to the <tt>put</tt> or <tt>putAll</tt> invocation resulting
+ * in this invocation, this will be the entry that was just
+ * inserted; in other words, if the map contains a single
+ * entry, the eldest entry is also the newest.
+ * @return   <tt>true</tt> if the eldest entry should be removed
+ * from the map; <tt>false</tt> if it should be retained.
+ */
+- (BOOL) removeEldestEntry:(LHMEntry *)eldest
+{
+    return NO;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/LinkedList.h b/runtime/ObjC/Framework/LinkedList.h
new file mode 100644
index 0000000..65de874
--- /dev/null
+++ b/runtime/ObjC/Framework/LinkedList.h
@@ -0,0 +1,189 @@
+#import "ArrayIterator.h"
+
+@class LinkedList;
+
+/**
+ * LinkedList entry.
+ */
+
+@interface LLNode : NSObject
+{
+    LLNode *next;
+    LLNode *prev;
+    id item;
+}
+
+@property(retain) LLNode *next;
+@property(retain) LLNode *prev;
+@property(retain)      id item;
+
++ (LLNode *) newNode:(LLNode *)aPrev element:(id)anElement next:(LLNode *)aNext;
+
+- (id) init:(LLNode *)aPrev element:(id)anElement next:(LLNode *)aNext;
+- (void) dealloc;
+@end
+
+@interface ListIterator : ArrayIterator {
+    LLNode * lastReturned;
+    LLNode * next;
+    NSInteger nextIndex;
+    NSInteger expectedModCount;
+    LinkedList *ll;
+}
+
++ (ListIterator *) newIterator:(LinkedList *)anLL;
++ (ListIterator *) newIterator:(LinkedList *)anLL withIndex:(NSInteger)anIndex;
+
+- (id) init:(LinkedList *)anLL withIndex:(NSInteger)anIndex;
+- (BOOL) hasNext;
+- (LLNode *) next;
+- (BOOL) hasPrevious;
+- (LLNode *) previous;
+- (NSInteger) nextIndex;
+- (NSInteger) previousIndex;
+- (void) remove;
+- (void) set:(LLNode *)e;
+- (void) add:(LLNode *)e;
+- (void) checkForComodification;
+@end
+
+/**
+ * Adapter to provide descending iterators via ListItr.previous
+ */
+
+@interface DescendingIterator : ListIterator {
+}
+
++ (DescendingIterator *) newIterator:(LinkedList *)anLL;
+- (id) init:(LinkedList *)anLL;
+- (BOOL) hasNext;
+- (LLNode *) next;
+- (void) remove;
+- (void) dealloc;
+@end
+
+/**
+ * Doubly-linked list implementation of the {@code List} and {@code Deque}
+ * interfaces.  Implements all optional list operations, and permits all
+ * elements (including {@code null}).
+ *
+ * <p>All of the operations perform as could be expected for a doubly-linked
+ * list.  Operations that index into the list will traverse the list from
+ * the beginning or the end, whichever is closer to the specified index.
+ *
+ * <p><strong>Note that this implementation is not synchronized.</strong>
+ * If multiple threads access a linked list concurrently, and at least
+ * one of the threads modifies the list structurally, it <i>must</i> be
+ * synchronized externally.  (A structural modification is any operation
+ * that adds or deletes one or more elements; merely setting the value of
+ * an element is not a structural modification.)  This is typically
+ * accomplished by synchronizing on some object that naturally
+ * encapsulates the list.
+ *
+ * If no such object exists, the list should be "wrapped" using the
+ * {@link Collections#synchronizedList Collections.synchronizedList}
+ * method.  This is best done at creation time, to prevent accidental
+ * unsynchronized access to the list:<pre>
+ * List list = Collections.synchronizedList(new LinkedList(...));</pre>
+ *
+ * <p>The iterators returned by this class's {@code iterator} and
+ * {@code listIterator} methods are <i>fail-fast</i>: if the list is
+ * structurally modified at any time after the iterator is created, in
+ * any way except through the Iterator's own {@code remove} or
+ * {@code add} methods, the iterator will throw a {@link
+ * ConcurrentModificationException}.  Thus, in the face of concurrent
+ * modification, the iterator fails quickly and cleanly, rather than
+ * risking arbitrary, non-deterministic behavior at an undetermined
+ * time in the future.
+ *
+ * <p>Note that the fail-fast behavior of an iterator cannot be guaranteed
+ * as it is, generally speaking, impossible to make any hard guarantees in the
+ * presence of unsynchronized concurrent modification.  Fail-fast iterators
+ * throw {@code ConcurrentModificationException} on a best-effort basis.
+ * Therefore, it would be wrong to write a program that depended on this
+ * exception for its correctness:   <i>the fail-fast behavior of iterators
+ * should be used only to detect bugs.</i>
+ *
+ * <p>This class is a member of the
+ * <a href="{@docRoot}/../technotes/guides/collections/index.html">
+ * Java Collections Framework</a>.
+ *
+ * @author  Josh Bloch
+ * @see     List
+ * @see     ArrayList
+ * @since 1.2
+ * @param <E> the type of elements held in this collection
+ */
+
+@interface LinkedList : NSObject {
+    /**
+     * Pointer to first node.
+     * Invariant: (first == null && last == null) ||
+     * (first.prev == null && first.item != null)
+     */
+    LLNode *first;
+
+    /**
+     * Pointer to last node.
+     * Invariant: (first == null && last == null) ||
+     * (last.next == null && last.item != null)
+     */
+    LLNode *last;
+    NSInteger count;
+    NSInteger modCount;
+}
+
+@property(nonatomic, retain) LLNode *first;
+@property(nonatomic, retain) LLNode *last;
+@property(assign) NSInteger count;
+@property(assign) NSInteger modCount;
+
++ (LinkedList *)newLinkedList;
++ (LinkedList *)newLinkedList:(NSArray *)c;
+
+- (id) init;
+- (id) initWithC:(NSArray *)c;
+- (void) linkLast:(LLNode *)e;
+- (void) linkBefore:(LLNode *)e succ:(LLNode *)succ;
+- (LLNode *) unlink:(LLNode *)x;
+- (LLNode *) removeFirst;
+- (LLNode *) removeLast;
+- (void) addFirst:(LLNode *)e;
+- (void) addLast:(LLNode *)e;
+- (BOOL) contains:(id)o;
+- (NSInteger) count;
+- (BOOL) add:(LLNode *)e;
+- (BOOL) remove:(id)o;
+- (BOOL) addAll:(NSArray *)c;
+- (BOOL) addAll:(NSInteger)index c:(NSArray *)c;
+- (void) clear;
+- (LLNode *) get:(NSInteger)index;
+- (LLNode *) set:(NSInteger)index element:(LLNode *)element;
+- (void) add:(NSInteger)index element:(LLNode *)element;
+- (LLNode *) removeIdx:(NSInteger)index;
+- (void) checkElementIndex:(NSInteger)index;
+- (void) checkPositionIndex:(NSInteger)index;
+- (LLNode *) node:(NSInteger)index;
+- (NSInteger) indexOf:(id)o;
+- (NSInteger) lastIndexOf:(id)o;
+- (LLNode *) peek;
+- (LLNode *) element;
+- (LLNode *) poll;
+- (LLNode *) remove;
+- (BOOL) offer:(LLNode *)e;
+- (BOOL) offerFirst:(LLNode *)e;
+- (BOOL) offerLast:(LLNode *)e;
+- (LLNode *) peekFirst;
+- (LLNode *) peekLast;
+- (LLNode *) pollFirst;
+- (LLNode *) pollLast;
+- (void) push:(LLNode *)e;
+- (LLNode *) pop;
+- (BOOL) removeFirstOccurrence:(id)o;
+- (BOOL) removeLastOccurrence:(id)o;
+- (ListIterator *) listIterator:(NSInteger)index;
+- (NSEnumerator *) descendingIterator;
+- (id) copyWithZone:(NSZone *)zone;
+- (NSArray *) toArray;
+- (NSArray *) toArray:(NSArray *)a;
+@end
diff --git a/runtime/ObjC/Framework/LinkedList.m b/runtime/ObjC/Framework/LinkedList.m
new file mode 100644
index 0000000..2829869
--- /dev/null
+++ b/runtime/ObjC/Framework/LinkedList.m
@@ -0,0 +1,1256 @@
+#import "LinkedList.h"
+#import <Cocoa/Cocoa.h>
+#import "AMutableArray.h"
+#import "RuntimeException.h"
+
+@implementation LLNode
+
+@synthesize next;
+@synthesize prev;
+@synthesize item;
+
++ (LLNode *) newNode:(LLNode *)aPrev element:(id)anElement next:(LLNode *)aNext
+{
+    return [[LLNode alloc] init:aPrev element:anElement next:aNext];
+}
+
+- (id) init:(LLNode *)aPrev element:(id)anElement next:(LLNode *)aNext
+{
+    self = [super init];
+    if (self) {
+        item = anElement;
+        next = aNext;
+        prev = aPrev;
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+    [item release];
+    [next release];
+    [prev release];
+    [super dealloc];
+}
+
+@end
+
+@implementation ListIterator
+
++ (ListIterator *) newIterator:(LinkedList *)anLL
+{
+    return [[ListIterator alloc] init:anLL withIndex:0];
+}
+
++ (ListIterator *) newIterator:(LinkedList *)anLL withIndex:(NSInteger)anIndex
+{
+    return [[ListIterator alloc] init:anLL withIndex:anIndex];
+}
+
+- (id) init:(LinkedList *)anLL withIndex:(NSInteger)anIndex
+{
+    self = [super init];
+    if ( self ) {
+        ll = anLL;
+        index = anIndex;
+        lastReturned = nil;
+        expectedModCount = ll.modCount;
+        next = (index == count) ? nil : [ll node:anIndex];
+        nextIndex = index;
+    }
+    return self;
+}
+
+- (BOOL) hasNext
+{
+    return nextIndex < count;
+}
+
+- (id) next
+{
+    [self checkForComodification];
+    if (![self hasNext])
+        @throw [[[NoSuchElementException alloc] init] autorelease];
+    lastReturned = next;
+    next = next.next;
+    nextIndex++;
+    return lastReturned.item;
+}
+
+- (BOOL) hasPrevious
+{
+    return nextIndex > 0;
+}
+
+- (id) previous
+{
+    [self checkForComodification];
+    if (![self hasPrevious])
+        @throw [[[NoSuchElementException alloc] init] autorelease];
+    lastReturned = next = (next == nil) ? ll.last : next.prev;
+    nextIndex--;
+    return lastReturned.item;
+}
+
+- (NSInteger) nextIndex
+{
+    return nextIndex;
+}
+
+- (NSInteger) previousIndex
+{
+    return nextIndex - 1;
+}
+
+- (void) remove
+{
+    [self checkForComodification];
+    if (lastReturned == nil)
+        @throw [[[IllegalStateException alloc] init] autorelease];
+    LLNode *lastNext = lastReturned.next;
+    [ll unlink:lastReturned];
+    if (next == lastReturned)
+        next = lastNext;
+    else
+        nextIndex--;
+    lastReturned = nil;
+    expectedModCount++;
+}
+
+- (void) set:(id)e
+{
+    if (lastReturned == nil)
+        @throw [[[IllegalStateException alloc] init] autorelease];
+    [self checkForComodification];
+    lastReturned.item = e;
+}
+
+- (void) add:(id)e
+{
+    [self checkForComodification];
+    lastReturned = nil;
+    if (next == nil)
+        [ll linkLast:e];
+    else
+        [ll linkBefore:e succ:next];
+    nextIndex++;
+    expectedModCount++;
+}
+
+- (void) checkForComodification
+{
+    if (ll.modCount != expectedModCount)
+        @throw [[[ConcurrentModificationException alloc] init] autorelease];
+}
+
+- (void) dealloc
+{
+    [lastReturned release];
+    [next release];
+    [super dealloc];
+}
+
+@end
+
+@implementation DescendingIterator
+
++ (DescendingIterator *)newIterator:(LinkedList *)anLL
+{
+    return [[DescendingIterator alloc] init:anLL];
+}
+
+- (id) init:(LinkedList *)anLL
+{
+    self = [super init:anLL withIndex:[anLL count]];
+    if ( self ) {
+
+    }
+    return self;
+}
+
+- (BOOL) hasNext
+{
+    return [self hasPrevious];
+}
+
+- (id) next
+{
+    return [self previous];
+}
+
+- (void) remove
+{
+    [self remove];
+}
+
+- (void) dealloc
+{
+    [super dealloc];
+}
+
+@end
+
+//long const serialVersionUID = 876323262645176354L;
+
+@implementation LinkedList
+
+@synthesize first;
+@synthesize last;
+@synthesize count;
+@synthesize modCount;
+
++ (LinkedList *)newLinkedList
+{
+    return [[LinkedList alloc] init];
+}
+
++ (LinkedList *)newLinkedList:(NSArray *)c
+{
+    return [[LinkedList alloc] initWithC:c];
+}
+
+/**
+ * Constructs an empty list.
+ */
+- (id) init
+{
+    self = [super init];
+    if ( self ) {
+        count = 0;
+    }
+    return self;
+}
+
+
+/**
+ * Constructs a list containing the elements of the specified
+ * collection, in the order they are returned by the collection's
+ * iterator.
+ *
+ * @param  c the collection whose elements are to be placed into this list
+ * @throws NullPointerException if the specified collection is null
+ */
+- (id) initWithC:(NSArray *)c
+{
+    self = [super init];
+    if ( self ) {
+        count = 0;
+        [self addAll:c];
+    }
+    return self;
+}
+
+
+- (void) dealloc
+{
+    [first release];
+    [last release];
+    [super dealloc];
+}
+
+/**
+ * Links e as first element.
+ */
+- (void) linkFirst:(id)e
+{
+    LLNode *f = first;
+    LLNode *newNode = [[LLNode newNode:nil element:e next:f] autorelease];
+    first = newNode;
+    if (f == nil)
+        last = newNode;
+    else
+        f.prev = newNode;
+    count++;
+    modCount++;
+}
+
+
+/**
+ * Links e as last element.
+ */
+- (void) linkLast:(id)e
+{
+    LLNode *l = last;
+    LLNode *newNode = [[LLNode newNode:l element:e next:nil] autorelease];
+    last = newNode;
+    if (l == nil)
+        first = newNode;
+    else
+        l.next = newNode;
+    count++;
+    modCount++;
+}
+
+
+/**
+ * Inserts element e before non-null LLNode succ.
+ */
+- (void) linkBefore:(id)e succ:(LLNode *)succ
+{
+    LLNode *pred = succ.prev;
+    LLNode *newNode = [[LLNode newNode:pred element:e next:succ] autorelease];
+    succ.prev = newNode;
+    if (pred == nil)
+        first = newNode;
+    else
+        pred.next = newNode;
+    count++;
+    modCount++;
+}
+
+
+/**
+ * Unlinks non-null first node f.
+ */
+- (id) unlinkFirst:(LLNode *)f
+{
+    id element = f.item;
+    LLNode *next = f.next;
+    f.item = nil;
+    f.next = nil;
+    first = next;
+    if (next == nil)
+        last = nil;
+    else
+        next.prev = nil;
+    count--;
+    modCount++;
+    return element;
+}
+
+
+/**
+ * Unlinks non-null last node l.
+ */
+- (id) unlinkLast:(LLNode *)l
+{
+    id element = l.item;
+    LLNode *prev = l.prev;
+    l.item = nil;
+    l.prev = nil;
+    last = prev;
+    if (prev == nil)
+        first = nil;
+    else
+        prev.next = nil;
+    count--;
+    modCount++;
+    return element;
+}
+
+
+/**
+ * Unlinks non-null node x.
+ */
+- (LLNode *) unlink:(LLNode *)x
+{
+    id element = x.item;
+    LLNode *next = x.next;
+    LLNode *prev = x.prev;
+    if (prev == nil) {
+        first = next;
+    }
+    else {
+        prev.next = next;
+        x.prev = nil;
+    }
+    if (next == nil) {
+        last = prev;
+    }
+    else {
+        next.prev = prev;
+        x.next = nil;
+    }
+    x.item = nil;
+    count--;
+    modCount++;
+    return element;
+}
+
+
+/**
+ * Returns the first element in this list.
+ *
+ * @return the first element in this list
+ * @throws NoSuchElementException if this list is empty
+ */
+- (LLNode *) first
+{
+    LLNode *f = first;
+    if (f == nil)
+        @throw [[[NoSuchElementException alloc] init] autorelease];
+    return f.item;
+}
+
+
+/**
+ * Returns the last element in this list.
+ *
+ * @return the last element in this list
+ * @throws NoSuchElementException if this list is empty
+ */
+- (LLNode *) last
+{
+    LLNode *l = last;
+    if (l == nil)
+        @throw [[[NoSuchElementException alloc] init] autorelease];
+    return l.item;
+}
+
+
+/**
+ * Removes and returns the first element from this list.
+ *
+ * @return the first element from this list
+ * @throws NoSuchElementException if this list is empty
+ */
+- (LLNode *) removeFirst
+{
+    LLNode *f = first;
+    if (f == nil)
+        @throw [[[NoSuchElementException alloc] init] autorelease];
+    return [self unlinkFirst:f];
+}
+
+
+/**
+ * Removes and returns the last element from this list.
+ *
+ * @return the last element from this list
+ * @throws NoSuchElementException if this list is empty
+ */
+- (LLNode *) removeLast
+{
+    LLNode *l = last;
+    if (l == nil)
+        @throw [[[NoSuchElementException alloc] init] autorelease];
+    return [self unlinkLast:l];
+}
+
+
+/**
+ * Inserts the specified element at the beginning of this list.
+ *
+ * @param e the element to add
+ */
+- (void) addFirst:(LLNode *)e
+{
+    [self linkFirst:e];
+}
+
+
+/**
+ * Appends the specified element to the end of this list.
+ *
+ * <p>This method is equivalent to {@link #add}.
+ *
+ * @param e the element to add
+ */
+- (void) addLast:(LLNode *)e
+{
+    [self linkLast:e];
+}
+
+
+/**
+ * Returns {@code true} if this list contains the specified element.
+ * More formally, returns {@code true} if and only if this list contains
+ * at least one element {@code e} such that
+ * <tt>(o==null&nbsp;?&nbsp;e==null&nbsp;:&nbsp;o.equals(e))</tt>.
+ *
+ * @param o element whose presence in this list is to be tested
+ * @return {@code true} if this list contains the specified element
+ */
+- (BOOL) contains:(id)o
+{
+    return [self indexOf:o] != -1;
+}
+
+
+/**
+ * Returns the number of elements in this list.
+ *
+ * @return the number of elements in this list
+ */
+- (NSInteger) count
+{
+    return count;
+}
+
+
+/**
+ * Appends the specified element to the end of this list.
+ *
+ * <p>This method is equivalent to {@link #addLast}.
+ *
+ * @param e element to be appended to this list
+ * @return {@code true} (as specified by {@link Collection#add})
+ */
+- (BOOL) add:(LLNode *)e
+{
+    [self linkLast:e];
+    return YES;
+}
+
+
+/**
+ * Removes the first occurrence of the specified element from this list,
+ * if it is present.  If this list does not contain the element, it is
+ * unchanged.  More formally, removes the element with the lowest index
+ * {@code i} such that
+ * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>
+ * (if such an element exists).  Returns {@code true} if this list
+ * contained the specified element (or equivalently, if this list
+ * changed as a result of the call).
+ *
+ * @param o element to be removed from this list, if present
+ * @return {@code true} if this list contained the specified element
+ */
+- (BOOL) remove:(id)o
+{
+    if (o == nil) {
+
+        for (LLNode *x = first; x != nil; x = x.next) {
+            if (x.item == nil) {
+                [self unlink:x];
+                return YES;
+            }
+        }
+
+    }
+    else {
+
+        for (LLNode *x = first; x != nil; x = x.next) {
+            if ([o isEqualTo:x.item]) {
+                [self unlink:x];
+                return YES;
+            }
+        }
+
+    }
+    return NO;
+}
+
+
+/**
+ * Appends all of the elements in the specified collection to the end of
+ * this list, in the order that they are returned by the specified
+ * collection's iterator.  The behavior of this operation is undefined if
+ * the specified collection is modified while the operation is in
+ * progress.  (Note that this will occur if the specified collection is
+ * this list, and it's nonempty.)
+ *
+ * @param c collection containing elements to be added to this list
+ * @return {@code true} if this list changed as a result of the call
+ * @throws NullPointerException if the specified collection is null
+ */
+- (BOOL) addAll:(NSArray *)c
+{
+    return [self addAll:count c:c];
+}
+
+
+/**
+ * Inserts all of the elements in the specified collection into this
+ * list, starting at the specified position.  Shifts the element
+ * currently at that position (if any) and any subsequent elements to
+ * the right (increases their indices).  The new elements will appear
+ * in the list in the order that they are returned by the
+ * specified collection's iterator.
+ *
+ * @param index index at which to insert the first element
+ * from the specified collection
+ * @param c collection containing elements to be added to this list
+ * @return {@code true} if this list changed as a result of the call
+ * @throws IndexOutOfBoundsException {@inheritDoc}
+ * @throws NullPointerException if the specified collection is null
+ */
+- (BOOL) addAll:(NSInteger)index c:(NSArray *)c
+{
+    [self checkPositionIndex:index];
+    AMutableArray *a = [AMutableArray arrayWithArray:c];
+    NSInteger numNew = [a count];
+    if (numNew == 0)
+        return NO;
+    LLNode *pred, *succ;
+    if (index == count) {
+        succ = nil;
+        pred = last;
+    }
+    else {
+        succ = [self node:index];
+        pred = succ.prev;
+    }
+
+    for (id o in a) {
+        id e = (id)o;
+        LLNode *newNode = [[LLNode newNode:pred element:e next:nil] autorelease];
+        if (pred == nil)
+            first = newNode;
+        else
+            pred.next = newNode;
+        pred = newNode;
+    }
+
+    if (succ == nil) {
+        last = pred;
+    }
+    else {
+        pred.next = succ;
+        succ.prev = pred;
+    }
+    count += numNew;
+    modCount++;
+    return YES;
+}
+
+
+/**
+ * Removes all of the elements from this list.
+ * The list will be empty after this call returns.
+ */
+- (void) clear
+{
+
+    for (LLNode *x = first; x != nil; ) {
+        LLNode *next = x.next;
+        x.item = nil;
+        x.next = nil;
+        x.prev = nil;
+        x = next;
+    }
+
+    first = last = nil;
+    count = 0;
+    modCount++;
+}
+
+
+/**
+ * Returns the element at the specified position in this list.
+ *
+ * @param index index of the element to return
+ * @return the element at the specified position in this list
+ * @throws IndexOutOfBoundsException {@inheritDoc}
+ */
+- (id) get:(NSInteger)index
+{
+    [self checkElementIndex:index];
+    return [self node:index].item;
+}
+
+
+/**
+ * Replaces the element at the specified position in this list with the
+ * specified element.
+ *
+ * @param index index of the element to replace
+ * @param element element to be stored at the specified position
+ * @return the element previously at the specified position
+ * @throws IndexOutOfBoundsException {@inheritDoc}
+ */
+- (id) set:(NSInteger)index element:(id)element
+{
+    [self checkElementIndex:index];
+    LLNode *x = [self node:index];
+    id oldVal = x.item;
+    x.item = element;
+    return oldVal;
+}
+
+
+/**
+ * Inserts the specified element at the specified position in this list.
+ * Shifts the element currently at that position (if any) and any
+ * subsequent elements to the right (adds one to their indices).
+ *
+ * @param index index at which the specified element is to be inserted
+ * @param element element to be inserted
+ * @throws IndexOutOfBoundsException {@inheritDoc}
+ */
+- (void) add:(NSInteger)index element:(LLNode *)element
+{
+    [self checkPositionIndex:index];
+    if (index == count)
+        [self linkLast:element];
+    else
+        [self linkBefore:element succ:[self node:index]];
+}
+
+
+/**
+ * Removes the element at the specified position in this list.  Shifts any
+ * subsequent elements to the left (subtracts one from their indices).
+ * Returns the element that was removed from the list.
+ *
+ * @param index the index of the element to be removed
+ * @return the element previously at the specified position
+ * @throws IndexOutOfBoundsException {@inheritDoc}
+ */
+- (LLNode *) removeIdx:(NSInteger)index
+{
+    [self checkElementIndex:index];
+    return [self unlink:[self node:index]];
+}
+
+
+/**
+ * Tells if the argument is the index of an existing element.
+ */
+- (BOOL) isElementIndex:(NSInteger)index
+{
+    return index >= 0 && index < count;
+}
+
+
+/**
+ * Tells if the argument is the index of a valid position for an
+ * iterator or an add operation.
+ */
+- (BOOL) isPositionIndex:(NSInteger)index
+{
+    return index >= 0 && index <= count;
+}
+
+
+/**
+ * Constructs an IndexOutOfBoundsException detail message.
+ * Of the many possible refactorings of the error handling code,
+ * this "outlining" performs best with both server and client VMs.
+ */
+- (NSString *) outOfBoundsMsg:(NSInteger)index
+{
+    return [NSString stringWithFormat:@"Index: %d, Size: %d", index, count];
+}
+
+- (void) checkElementIndex:(NSInteger)index
+{
+    if (![self isElementIndex:index])
+        @throw [[IndexOutOfBoundsException newException:[self outOfBoundsMsg:index]] autorelease];
+}
+
+- (void) checkPositionIndex:(NSInteger)index
+{
+    if (![self isPositionIndex:index])
+        @throw [[IndexOutOfBoundsException newException:[self outOfBoundsMsg:index]] autorelease];
+}
+
+
+/**
+ * Returns the (non-null) LLNode at the specified element index.
+ */
+- (LLNode *) node:(NSInteger)index
+{
+    if (index < (count >> 1)) {
+        LLNode *x = first;
+
+        for (NSInteger i = 0; i < index; i++)
+            x = x.next;
+
+        return x;
+    }
+    else {
+        LLNode *x = last;
+
+        for (NSInteger i = count - 1; i > index; i--)
+            x = x.prev;
+
+        return x;
+    }
+}
+
+
+/**
+ * Returns the index of the first occurrence of the specified element
+ * in this list, or -1 if this list does not contain the element.
+ * More formally, returns the lowest index {@code i} such that
+ * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,
+ * or -1 if there is no such index.
+ *
+ * @param o element to search for
+ * @return the index of the first occurrence of the specified element in
+ * this list, or -1 if this list does not contain the element
+ */
+- (NSInteger) indexOf:(id)o
+{
+    NSInteger index = 0;
+    if (o == nil) {
+
+        for (LLNode *x = first; x != nil; x = x.next) {
+            if (x.item == nil)
+                return index;
+            index++;
+        }
+
+    }
+    else {
+
+        for (LLNode *x = first; x != nil; x = x.next) {
+            if ([o isEqualTo:x.item])
+                return index;
+            index++;
+        }
+
+    }
+    return -1;
+}
+
+
+/**
+ * Returns the index of the last occurrence of the specified element
+ * in this list, or -1 if this list does not contain the element.
+ * More formally, returns the highest index {@code i} such that
+ * <tt>(o==null&nbsp;?&nbsp;get(i)==null&nbsp;:&nbsp;o.equals(get(i)))</tt>,
+ * or -1 if there is no such index.
+ *
+ * @param o element to search for
+ * @return the index of the last occurrence of the specified element in
+ * this list, or -1 if this list does not contain the element
+ */
+- (NSInteger) lastIndexOf:(id)o
+{
+    NSInteger index = count;
+    if (o == nil) {
+
+        for (LLNode *x = last; x != nil; x = x.prev) {
+            index--;
+            if (x.item == nil)
+                return index;
+        }
+
+    }
+    else {
+
+        for (LLNode *x = last; x != nil; x = x.prev) {
+            index--;
+            if ([o isEqualTo:x.item])
+                return index;
+        }
+
+    }
+    return -1;
+}
+
+
+/**
+ * Retrieves, but does not remove, the head (first element) of this list.
+ *
+ * @return the head of this list, or {@code null} if this list is empty
+ * @since 1.5
+ */
+- (LLNode *) peek
+{
+    LLNode *f = first;
+    return (f == nil) ? nil : f.item;
+}
+
+
+/**
+ * Retrieves, but does not remove, the head (first element) of this list.
+ *
+ * @return the head of this list
+ * @throws NoSuchElementException if this list is empty
+ * @since 1.5
+ */
+- (LLNode *) element
+{
+    return [self first];
+}
+
+
+/**
+ * Retrieves and removes the head (first element) of this list.
+ *
+ * @return the head of this list, or {@code null} if this list is empty
+ * @since 1.5
+ */
+- (LLNode *) poll
+{
+    LLNode *f = first;
+    return (f == nil) ? nil : [self unlinkFirst:f];
+}
+
+
+/**
+ * Retrieves and removes the head (first element) of this list.
+ *
+ * @return the head of this list
+ * @throws NoSuchElementException if this list is empty
+ * @since 1.5
+ */
+- (LLNode *) remove
+{
+    return [self removeFirst];
+}
+
+
+/**
+ * Adds the specified element as the tail (last element) of this list.
+ *
+ * @param e the element to add
+ * @return {@code true} (as specified by {@link Queue#offer})
+ * @since 1.5
+ */
+- (BOOL) offer:(LLNode *)e
+{
+    return [self add:e];
+}
+
+
+/**
+ * Inserts the specified element at the front of this list.
+ *
+ * @param e the element to insert
+ * @return {@code true} (as specified by {@link Deque#offerFirst})
+ * @since 1.6
+ */
+- (BOOL) offerFirst:(LLNode *)e
+{
+    [self addFirst:e];
+    return YES;
+}
+
+
+/**
+ * Inserts the specified element at the end of this list.
+ *
+ * @param e the element to insert
+ * @return {@code true} (as specified by {@link Deque#offerLast})
+ * @since 1.6
+ */
+- (BOOL) offerLast:(LLNode *)e
+{
+    [self addLast:e];
+    return YES;
+}
+
+
+/**
+ * Retrieves, but does not remove, the first element of this list,
+ * or returns {@code null} if this list is empty.
+ *
+ * @return the first element of this list, or {@code null}
+ * if this list is empty
+ * @since 1.6
+ */
+- (LLNode *) peekFirst
+{
+    LLNode *f = first;
+    return (f == nil) ? nil : f.item;
+}
+
+
+/**
+ * Retrieves, but does not remove, the last element of this list,
+ * or returns {@code null} if this list is empty.
+ *
+ * @return the last element of this list, or {@code null}
+ * if this list is empty
+ * @since 1.6
+ */
+- (LLNode *) peekLast
+{
+    LLNode *l = last;
+    return (l == nil) ? nil : l.item;
+}
+
+
+/**
+ * Retrieves and removes the first element of this list,
+ * or returns {@code null} if this list is empty.
+ *
+ * @return the first element of this list, or {@code null} if
+ * this list is empty
+ * @since 1.6
+ */
+- (LLNode *) pollFirst
+{
+    LLNode *f = first;
+    return (f == nil) ? nil : [self unlinkFirst:f];
+}
+
+
+/**
+ * Retrieves and removes the last element of this list,
+ * or returns {@code null} if this list is empty.
+ *
+ * @return the last element of this list, or {@code null} if
+ * this list is empty
+ * @since 1.6
+ */
+- (LLNode *) pollLast
+{
+    LLNode *l = last;
+    return (l == nil) ? nil : [self unlinkLast:l];
+}
+
+
+/**
+ * Pushes an element onto the stack represented by this list.  In other
+ * words, inserts the element at the front of this list.
+ *
+ * <p>This method is equivalent to {@link #addFirst}.
+ *
+ * @param e the element to push
+ * @since 1.6
+ */
+- (void) push:(LLNode *)e
+{
+    [self addFirst:e];
+}
+
+
+/**
+ * Pops an element from the stack represented by this list.  In other
+ * words, removes and returns the first element of this list.
+ *
+ * <p>This method is equivalent to {@link #removeFirst()}.
+ *
+ * @return the element at the front of this list (which is the top
+ * of the stack represented by this list)
+ * @throws NoSuchElementException if this list is empty
+ * @since 1.6
+ */
+- (LLNode *) pop
+{
+    return [self removeFirst];
+}
+
+
+/**
+ * Removes the first occurrence of the specified element in this
+ * list (when traversing the list from head to tail).  If the list
+ * does not contain the element, it is unchanged.
+ *
+ * @param o element to be removed from this list, if present
+ * @return {@code true} if the list contained the specified element
+ * @since 1.6
+ */
+- (BOOL) removeFirstOccurrence:(id)o
+{
+    return [self remove:o];
+}
+
+
+/**
+ * Removes the last occurrence of the specified element in this
+ * list (when traversing the list from head to tail).  If the list
+ * does not contain the element, it is unchanged.
+ *
+ * @param o element to be removed from this list, if present
+ * @return {@code true} if the list contained the specified element
+ * @since 1.6
+ */
+- (BOOL) removeLastOccurrence:(id)o
+{
+    if (o == nil) {
+
+        for (LLNode *x = last; x != nil; x = x.prev) {
+            if (x.item == nil) {
+                [self unlink:x];
+                return YES;
+            }
+        }
+
+    }
+    else {
+
+        for (LLNode *x = last; x != nil; x = x.prev) {
+            if ([o isEqualTo:x.item]) {
+                [self unlink:x];
+                return YES;
+            }
+        }
+
+    }
+    return NO;
+}
+
+
+/**
+ * Returns a list-iterator of the elements in this list (in proper
+ * sequence), starting at the specified position in the list.
+ * Obeys the general contract of {@code List.listIterator(NSInteger)}.<p>
+ *
+ * The list-iterator is <i>fail-fast</i>: if the list is structurally
+ * modified at any time after the Iterator is created, in any way except
+ * through the list-iterator's own {@code remove} or {@code add}
+ * methods, the list-iterator will throw a
+ * {@code ConcurrentModificationException}.  Thus, in the face of
+ * concurrent modification, the iterator fails quickly and cleanly, rather
+ * than risking arbitrary, non-deterministic behavior at an undetermined
+ * time in the future.
+ *
+ * @param index index of the first element to be returned from the
+ * list-iterator (by a call to {@code next})
+ * @return a ListIterator of the elements in this list (in proper
+ * sequence), starting at the specified position in the list
+ * @throws IndexOutOfBoundsException {@inheritDoc}
+ * @see List#listIterator(NSInteger)
+ */
+- (ListIterator *) listIterator:(NSInteger)index
+{
+    [self checkPositionIndex:index];
+    return [[ListIterator newIterator:self withIndex:index] autorelease];
+}
+
+
+/**
+ * @since 1.6
+ */
+- (NSEnumerator *) descendingIterator
+{
+    return [[[DescendingIterator alloc] init] autorelease];
+}
+
+/*
+- (LinkedList *) superClone:(NSZone *)zone
+{
+
+    @try {
+        return (LinkedList *)[super copyWithZone:zone];
+    }
+    @catch (CloneNotSupportedException * e) {
+        @throw [[[NSException exceptionWithName:@"InternalException" reason:@"Attempted to Clone non-cloneable List" userInfo:nil] autorelease];
+    }
+}
+*/
+
+/**
+ * Returns a shallow copy of this {@code LinkedList}. (The elements
+ * themselves are not cloned.)
+ *
+ * @return a shallow copy of this {@code LinkedList} instance
+ */
+- (id) copyWithZone:(NSZone *)zone
+{
+    LinkedList *clone = [LinkedList allocWithZone:zone];
+    clone.first = nil;
+    clone.last = nil;
+    clone.count = 0;
+    clone.modCount = 0;
+
+    for (LLNode *x = first; x != nil; x = x.next)
+        [clone add:x.item];
+
+    clone.count = count;
+    clone.first = first;
+    clone.last = last;
+    return clone;
+}
+
+
+/**
+ * Returns an array containing all of the elements in this list
+ * in proper sequence (from first to last element).
+ *
+ * <p>The returned array will be "safe" in that no references to it are
+ * maintained by this list.  (In other words, this method must allocate
+ * a new array).  The caller is thus free to modify the returned array.
+ *
+ * <p>This method acts as bridge between array-based and collection-based
+ * APIs.
+ *
+ * @return an array containing all of the elements in this list
+ * in proper sequence
+ */
+- (NSArray *) toArray
+{
+    AMutableArray *result = [AMutableArray arrayWithCapacity:10];
+
+    for (LLNode *x = first; x != nil; x = x.next)
+        [result addObject:x.item];
+
+    return result;
+}
+
+
+/**
+ * Returns an array containing all of the elements in this list in
+ * proper sequence (from first to last element); the runtime type of
+ * the returned array is that of the specified array.  If the list fits
+ * in the specified array, it is returned therein.  Otherwise, a new
+ * array is allocated with the runtime type of the specified array and
+ * the size of this list.
+ *
+ * <p>If the list fits in the specified array with room to spare (i.e.,
+ * the array has more elements than the list), the element in the array
+ * immediately following the end of the list is set to {@code null}.
+ * (This is useful in determining the length of the list <i>only</i> if
+ * the caller knows that the list does not contain any null elements.)
+ *
+ * <p>Like the {@link #toArray()} method, this method acts as bridge between
+ * array-based and collection-based APIs.  Further, this method allows
+ * precise control over the runtime type of the output array, and may,
+ * under certain circumstances, be used to save allocation costs.
+ *
+ * <p>Suppose {@code x} is a list known to contain only strings.
+ * The following code can be used to dump the list into a newly
+ * allocated array of {@code String}:
+ *
+ * <pre>
+ * String[] y = x.toArray(new String[0]);</pre>
+ *
+ * Note that {@code toArray(new Object[0])} is identical in function to
+ * {@code toArray()}.
+ *
+ * @param a the array into which the elements of the list are to
+ * be stored, if it is big enough; otherwise, a new array of the
+ * same runtime type is allocated for this purpose.
+ * @return an array containing the elements of the list
+ * @throws ArrayStoreException if the runtime type of the specified array
+ * is not a supertype of the runtime type of every element in
+ * this list
+ * @throws NullPointerException if the specified array is null
+ */
+- (NSArray *) toArray:(AMutableArray *)a
+{
+    if ( [a count] < count )
+        a = (AMutableArray *)[AMutableArray arrayWithArray:a];
+    AMutableArray *result = a;
+
+    for (LLNode *x = first; x != nil; x = x.next)
+        [result addObject:x.item];
+
+    if ([a count] > count)
+        [a replaceObjectAtIndex:count withObject:nil];
+    return a;
+}
+
+
+/**
+ * Saves the state of this {@code LinkedList} instance to a stream
+ * (that is, serializes it).
+ *
+ * @serialData The size of the list (the number of elements it
+ * contains) is emitted (NSInteger), followed by all of its
+ * elements (each an Object) in the proper order.
+ */
+- (void) writeObject:(NSOutputStream *)s
+{
+/*
+    [s defaultWriteObject];
+    [s writeInt:count];
+
+    for (LLNode *x = first; x != nil; x = x.next)
+        [s writeObject:x.item];
+ */
+}
+
+
+/**
+ * Reconstitutes this {@code LinkedList} instance from a stream
+ * (that is, deserializes it).
+ */
+- (void) readObject:(NSInputStream *)s
+{
+/*
+    [s defaultReadObject];
+    NSInteger len = [s readInt];
+
+    for (NSInteger i = 0; i < len; i++)
+        [self linkLast:(id)[s readObject]];
+ */
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RecognitionException.m b/runtime/ObjC/Framework/RecognitionException.m
index f1c2615..d6430b7 100644
--- a/runtime/ObjC/Framework/RecognitionException.m
+++ b/runtime/ObjC/Framework/RecognitionException.m
@@ -138,9 +138,9 @@
[super dealloc];
}

-- (void) extractInformationFromTreeNodeStream:(id<TreeNodeStream>)input
+- (void) extractInformationFromTreeNodeStream:(id<TreeNodeStream>)anInput
{
-    id<TreeNodeStream> nodes = input;
+    id<TreeNodeStream> nodes = anInput;
node = [nodes LT:1];
id<TreeAdaptor> adaptor = [nodes getTreeAdaptor];
id<Token> payload = [adaptor getToken:node];
diff --git a/runtime/ObjC/Framework/RuntimeException.h b/runtime/ObjC/Framework/RuntimeException.h
index 9eb1269..7122696 100644
--- a/runtime/ObjC/Framework/RuntimeException.h
+++ b/runtime/ObjC/Framework/RuntimeException.h
@@ -52,6 +52,29 @@

@end

+@interface CloneNotSupportedException : RuntimeException {
+}
+
++ (id) newException;
++ (id) newException:(NSString *)aReason;
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (id) init;
+- (id) init:(NSString *)aReason;
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+@end
+
+@interface ConcurrentModificationException : RuntimeException {
+}
+
++ (id) newException:(NSString *)aReason;
+
+- (id) init;
+- (id) init:(NSString *)aReason;
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+@end
+
@interface IllegalArgumentException : RuntimeException {
}

@@ -60,12 +83,25 @@
+ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;

- (id) init;
+- (id) init:(NSString *)aReason;
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+@end
+
+@interface IllegalStateException : RuntimeException {
+}
+
++ (id) newException;
++ (id) newException:(NSString *)aReason;
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (id) init;
- (id)init:(NSString *)aReason;
- (id)init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;

@end

-@interface IllegalStateException : RuntimeException {
+@interface IndexOutOfBoundsException : RuntimeException {
}

+ (id) newException;
@@ -91,6 +127,19 @@

@end

+@interface NullPointerException : RuntimeException {
+}
+
++ (id) newException;
++ (id) newException:(NSString *)aReason;
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (id) init;
+- (id) init:(NSString *)aReason;
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+@end
+
@interface RewriteEarlyExitException : RuntimeException {
}

diff --git a/runtime/ObjC/Framework/RuntimeException.m b/runtime/ObjC/Framework/RuntimeException.m
index e697132..25e17d6 100644
--- a/runtime/ObjC/Framework/RuntimeException.m
+++ b/runtime/ObjC/Framework/RuntimeException.m
@@ -113,6 +113,80 @@

@end

+@implementation CloneNotSupportedException
+
++ (id) newException
+{
+    return [[CloneNotSupportedException alloc] init];
+}
+
++ (id) newException:(NSString *)aReason
+{
+    return [[CloneNotSupportedException alloc] init:aReason];
+}
+
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    return [[CloneNotSupportedException alloc] init:aReason userInfo:aUserInfo];
+}
+
+- (id) init
+{
+    self = [super initWithName:@"CloneNotSupportedException" reason:@"Attempted to clone non-cloneable object" userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason
+{
+    self = [super initWithName:@"CloneNotSupportedException" reason:(NSString *)aReason userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:@"CloneNotSupportedException" reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+@end
+
+@implementation ConcurrentModificationException
+
++ (id) newException
+{
+    return [[ConcurrentModificationException alloc] init];
+}
+
++ (id) newException:(NSString *)aReason
+{
+    return [[ConcurrentModificationException alloc] init:aReason];
+}
+
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    return [[ConcurrentModificationException alloc] init:aReason userInfo:aUserInfo];
+}
+
+- (id) init
+{
+    self = [super initWithName:@"ConcurrentModificationException" reason:@"UnknownException" userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason
+{
+    self = [super initWithName:@"ConcurrentModificationException" reason:(NSString *)aReason userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:@"ConcurrentModificationException" reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+@end
+
@implementation IllegalArgumentException

+ (id) newException
@@ -132,7 +206,7 @@

- (id) init
{
-    self = [super initWithName:@"IllegalArgumentException" reason:@"UnknownException" userInfo:nil];
+    self = [super initWithName:@"IllegalArgumentException" reason:@"IllegalStateException" userInfo:nil];
return(self);
}

@@ -169,7 +243,7 @@

- (id) init
{
-    self = [super initWithName:@"IllegalStateException" reason:@"UnknownException" userInfo:nil];
+    self = [super initWithName:@"IllegalStateException" reason:@"IllegalStateException" userInfo:nil];
return(self);
}

@@ -187,6 +261,43 @@

@end

+@implementation IndexOutOfBoundsException
+
++ (id) newException
+{
+    return [[IndexOutOfBoundsException alloc] init];
+}
+
++ (id) newException:(NSString *)aReason
+{
+    return [[IndexOutOfBoundsException alloc] init:aReason];
+}
+
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    return [[IndexOutOfBoundsException alloc] init:aReason userInfo:aUserInfo];
+}
+
+- (id) init
+{
+    self = [super initWithName:@"IndexOutOfBoundsException" reason:@"IndexOutOfBoundsException" userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason
+{
+    self = [super initWithName:@"IndexOutOfBoundsException" reason:(NSString *)aReason userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:@"IndexOutOfBoundsException" reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+@end
+
@implementation NoSuchElementException

+ (id) newException
@@ -230,6 +341,43 @@

@end

+@implementation NullPointerException
+
++ (id) newException
+{
+    return [[NullPointerException alloc] init];
+}
+
++ (id) newException:(NSString *)aReason
+{
+    return [[NullPointerException alloc] init:aReason];
+}
+
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    return [[NullPointerException alloc] init:aReason userInfo:(NSDictionary *)aUserInfo];
+}
+
+- (id) init
+{
+    self = [super initWithName:@"NullPointerException" reason:@"UnknownException" userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason
+{
+    self = [super initWithName:@"NullPointerException" reason:(NSString *)aReason userInfo:(NSDictionary *)nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:@"NullPointerException" reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+@end
+
@implementation RewriteEarlyExitException

+ (id) newException
diff --git a/runtime/ObjC/Framework/antlr3.h b/runtime/ObjC/Framework/antlr3.h
index 124ef63..80bc08b 100644
--- a/runtime/ObjC/Framework/antlr3.h
+++ b/runtime/ObjC/Framework/antlr3.h
@@ -61,6 +61,7 @@
#import <ANTLR/DebugTreeParser.h>
#import <ANTLR/DoubleKeyMap.h>
#import <ANTLR/EarlyExitException.h>
+#import <ANTLR/Entry.h>
#import <ANTLR/FailedPredicateException.h>
#import <ANTLR/FastQueue.h>
#import <ANTLR/HashMap.h>
@@ -70,6 +71,8 @@
#import <ANTLR/Lexer.h>
#import <ANTLR/LexerRuleReturnScope.h>
#import <ANTLR/LinkBase.h>
+#import <ANTLR/LinkedHashMap.h>
+#import <ANTLR/LinkedList.h>
#import <ANTLR/LookaheadStream.h>
#import <ANTLR/MapElement.h>
#import <ANTLR/Map.h>

