commit a99bde3bafd6f133a38c84f0c901ac4368ff5afc
Author:     Mike Lischke <mike@lischke-online.de>
AuthorDate: Mon Sep 24 10:02:37 2012 +0200
Commit:     Mike Lischke <mike@lischke-online.de>
CommitDate: Mon Sep 24 10:02:37 2012 +0200

Fixed tree construction and compile issues

- Added missing setParent calls when nodes are moved between trees, so
they maintain the correct relationship.
- Added a number of casts to satisfy the compiler.
- Renamed an all-uppercase member variable to all-lowercase as it
conflicts with an existing macro.
- Removed declaration and usage of "true" and "false" typedefs.
- Removed reference to Perforce from the MSVC solution.

diff --git a/runtime/C/C.sln b/runtime/C/C.sln
index f841177..e86daeb 100644
--- a/runtime/C/C.sln
+++ b/runtime/C/C.sln
@@ -3,16 +3,6 @@ Microsoft Visual Studio Solution File, Format Version 10.00
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "C", "C.vcproj", "{0F0FE03A-78F3-4B34-9DCE-0CDFF1FB5C40}"
EndProject
Global
-	GlobalSection(SourceCodeControl) = preSolution
-		SccNumberOfProjects = 2
-		SccProjectName0 = Perforce\u0020Project
-		SccLocalPath0 = ..\\..
-		SccProvider0 = MSSCCI:Perforce\u0020SCM
-		SccProjectFilePathRelativizedFromConnection0 = runtime\\C\\
-		SccProjectUniqueName1 = C.vcproj
-		SccLocalPath1 = ..\\..
-		SccProjectFilePathRelativizedFromConnection1 = runtime\\C\\
-	EndGlobalSection
GlobalSection(SolutionConfigurationPlatforms) = preSolution
Debug|Win32 = Debug|Win32
Debug|x64 = Debug|x64
diff --git a/runtime/C/C.vcproj b/runtime/C/C.vcproj
index 16d9c2b..25aaf8b 100644
--- a/runtime/C/C.vcproj
+++ b/runtime/C/C.vcproj
@@ -5,9 +5,6 @@
Name="C"
ProjectGUID="{0F0FE03A-78F3-4B34-9DCE-0CDFF1FB5C40}"
RootNamespace="C"
-	SccProjectName="Perforce Project"
-	SccLocalPath="..\.."
-	SccProvider="MSSCCI:Perforce SCM"
Keyword="Win32Proj"
TargetFrameworkVersion="131072"
>
diff --git a/runtime/C/configure.ac b/runtime/C/configure.ac
index 38ed0df..b3d9c3a 100644
--- a/runtime/C/configure.ac
+++ b/runtime/C/configure.ac
@@ -1,7 +1,7 @@
#                                               -*- Autoconf -*-
# Process this file with autoconf to produce a configure script.

-AC_INIT(libantlr3c, 3.4-beta3, jimi@temporal-wave.com)
+AC_INIT(libantlr3c, 3.4, jimi@temporal-wave.com)
AC_PREREQ(2.60)
AC_COPYRIGHT([
(The "BSD licence")
diff --git a/runtime/C/include/antlr3convertutf.h b/runtime/C/include/antlr3convertutf.h
index 79cc82c..e0c5603 100644
--- a/runtime/C/include/antlr3convertutf.h
+++ b/runtime/C/include/antlr3convertutf.h
@@ -118,8 +118,6 @@ typedef ANTLR3_UINT8	UTF8;	/* typically 8 bits */
#define UNI_SUR_HIGH_END    (UTF32)0xDBFF
#define UNI_SUR_LOW_START   (UTF32)0xDC00
#define UNI_SUR_LOW_END     (UTF32)0xDFFF
-#define false	            ANTLR3_FALSE
-#define true	            ANTLR3_TRUE
#define halfShift           ((UTF32)10)
#define halfBase            ((UTF32)0x0010000UL)
#define halfMask            ((UTF32)0x3FFUL)
diff --git a/runtime/C/include/antlr3debugeventlistener.h b/runtime/C/include/antlr3debugeventlistener.h
index c9cd6ce..1d1b38e 100644
--- a/runtime/C/include/antlr3debugeventlistener.h
+++ b/runtime/C/include/antlr3debugeventlistener.h
@@ -73,7 +73,7 @@ typedef struct ANTLR3_DEBUG_EVENT_LISTENER_struct
/** The version of the debugging protocol supported by the providing
*  instance of the debug event listener.
*/
-	int					PROTOCOL_VERSION;
+	int					protocol_version;

/// The name of the grammar file that we are debugging
///
diff --git a/runtime/C/src/antlr3baserecognizer.c b/runtime/C/src/antlr3baserecognizer.c
index e2eccc6..00adf64 100644
--- a/runtime/C/src/antlr3baserecognizer.c
+++ b/runtime/C/src/antlr3baserecognizer.c
@@ -345,8 +345,8 @@ antlr3RecognitionExceptionNew(pANTLR3_BASE_RECOGNIZER recognizer)
case    ANTLR3_TOKENSTREAM:

ex->token		= cts->tstream->_LT						(cts->tstream, 1);	    /* Current input token			    */
-		ex->line		= ((pANTLR3_COMMON_TOKEN)(ex->token))->getLine			(ex->token);
-		ex->charPositionInLine	= ((pANTLR3_COMMON_TOKEN)(ex->token))->getCharPositionInLine	(ex->token);
+		ex->line		= ((pANTLR3_COMMON_TOKEN)(ex->token))->getLine			((pANTLR3_COMMON_TOKEN)(ex->token));
+		ex->charPositionInLine	= ((pANTLR3_COMMON_TOKEN)(ex->token))->getCharPositionInLine	((pANTLR3_COMMON_TOKEN)(ex->token));
ex->index		= cts->tstream->istream->index					(cts->tstream->istream);
if	(((pANTLR3_COMMON_TOKEN)(ex->token))->type == ANTLR3_TOKEN_EOF)
{
@@ -362,8 +362,8 @@ antlr3RecognitionExceptionNew(pANTLR3_BASE_RECOGNIZER recognizer)
case    ANTLR3_COMMONTREENODE:

ex->token		= tns->_LT						    (tns, 1);	    /* Current input tree node			    */
-		ex->line		= ((pANTLR3_BASE_TREE)(ex->token))->getLine		    (ex->token);
-		ex->charPositionInLine	= ((pANTLR3_BASE_TREE)(ex->token))->getCharPositionInLine   (ex->token);
+		ex->line		= ((pANTLR3_BASE_TREE)(ex->token))->getLine		    ((pANTLR3_BASE_TREE)(ex->token));
+		ex->charPositionInLine	= ((pANTLR3_BASE_TREE)(ex->token))->getCharPositionInLine   ((pANTLR3_BASE_TREE)(ex->token));
ex->index		= tns->istream->index					    (tns->istream);

// Are you ready for this? Deep breath now...
@@ -586,7 +586,7 @@ mismatchIsMissingToken(pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is
// EOR can follow, but if we are not the start symbol, we
// need to remove it.
//
-		if	(recognizer->state->following->vector->count >= 0)
+		//if	(recognizer->state->following->vector->count >= 0) ml: always true
{
followClone->remove(followClone, ANTLR3_EOR_TOKEN_TYPE);
}
@@ -1589,7 +1589,7 @@ recoverFromMismatchedSet	    (pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_BITSET
{
// We can fake the missing token and proceed
//
-		matchedSymbol = recognizer->getMissingSymbol(recognizer, is, recognizer->state->exception, ANTLR3_TOKEN_INVALID, follow);
+		matchedSymbol = (pANTLR3_COMMON_TOKEN)recognizer->getMissingSymbol(recognizer, is, recognizer->state->exception, ANTLR3_TOKEN_INVALID, follow);
recognizer->state->exception->type	= ANTLR3_MISSING_TOKEN_EXCEPTION;
recognizer->state->exception->token	= matchedSymbol;

diff --git a/runtime/C/src/antlr3basetree.c b/runtime/C/src/antlr3basetree.c
index bbc81e7..f191f6f 100644
--- a/runtime/C/src/antlr3basetree.c
+++ b/runtime/C/src/antlr3basetree.c
@@ -187,13 +187,16 @@ addChild (pANTLR3_BASE_TREE tree, pANTLR3_BASE_TREE child)
for (i = 0; i < n; i++)
{
pANTLR3_BASE_TREE entry;
-                    entry = child->children->get(child->children, i);
+                    entry = (pANTLR3_BASE_TREE)child->children->get(child->children, i);

// ANTLR3 lists can be sparse, unlike Array Lists
//
if (entry != NULL)
{
-                        tree->children->add(tree->children, entry, (void (ANTLR3_CDECL *) (void *))child->free);
+                        ANTLR3_UINT32 count = tree->children->add(tree->children, entry, (void (ANTLR3_CDECL *) (void *))child->free);
+
+                        entry->setChildIndex(entry, count - 1);
+                        entry->setParent(entry, tree);
}
}
}
@@ -211,8 +214,9 @@ addChild (pANTLR3_BASE_TREE tree, pANTLR3_BASE_TREE child)
tree->createChildrenList(tree);
}

-		tree->children->add(tree->children, child, (void (ANTLR3_CDECL *)(void *))child->free);
-
+		ANTLR3_UINT32 count = tree->children->add(tree->children, child, (void (ANTLR3_CDECL *)(void *))child->free);
+		child->setChildIndex(child, count - 1);
+		child->setParent(child, tree);
}
}

@@ -260,7 +264,7 @@ dupTree		(pANTLR3_BASE_TREE tree)
ANTLR3_UINT32	i;
ANTLR3_UINT32	s;

-	newTree = tree->dupNode	    (tree);
+	newTree = (pANTLR3_BASE_TREE)tree->dupNode	    (tree);

if	(tree->children != NULL)
{
@@ -275,7 +279,7 @@ dupTree		(pANTLR3_BASE_TREE tree)

if  (t!= NULL)
{
-				newNode	    = t->dupTree(t);
+				newNode	    = (pANTLR3_BASE_TREE)t->dupTree(t);
newTree->addChild(newTree, newNode);
}
}
@@ -480,7 +484,7 @@ freshenPACIndexes	(pANTLR3_BASE_TREE tree, ANTLR3_UINT32 offset)
{
pANTLR3_BASE_TREE	child;

-		child = tree->getChild(tree, c);
+		child = (pANTLR3_BASE_TREE)tree->getChild(tree, c);

child->setChildIndex(child, c);
child->setParent(child, tree);
diff --git a/runtime/C/src/antlr3basetreeadaptor.c b/runtime/C/src/antlr3basetreeadaptor.c
index e35878f..1f42751 100644
--- a/runtime/C/src/antlr3basetreeadaptor.c
+++ b/runtime/C/src/antlr3basetreeadaptor.c
@@ -192,7 +192,7 @@ defineDotNodes(pANTLR3_BASE_TREE_ADAPTOR adaptor, void * t, pANTLR3_STRING dotSp

// Pick up a pointer for the child
//
-		child = adaptor->getChild(adaptor, t, i);
+		child = (pANTLR3_BASE_TREE)adaptor->getChild(adaptor, t, i);

// Name the node
//
@@ -275,7 +275,7 @@ defineDotEdges(pANTLR3_BASE_TREE_ADAPTOR adaptor, void * t, pANTLR3_STRING dotSp

// Next child
//
-		child	= adaptor->getChild(adaptor, t, i);
+		child	= (pANTLR3_BASE_TREE)adaptor->getChild(adaptor, t, i);

// Create the edge relation
//
@@ -440,7 +440,7 @@ makeDot	(pANTLR3_BASE_TREE_ADAPTOR adaptor, void * theTree)
static	pANTLR3_BASE_TREE
nilNode	    (pANTLR3_BASE_TREE_ADAPTOR adaptor)
{
-	return	adaptor->create(adaptor, NULL);
+	return	(pANTLR3_BASE_TREE)adaptor->create(adaptor, NULL);
}

static	pANTLR3_BASE_TREE
@@ -448,7 +448,7 @@ dbgNil	    (pANTLR3_BASE_TREE_ADAPTOR adaptor)
{
pANTLR3_BASE_TREE t;

-	t = adaptor->create				(adaptor, NULL);
+	t = (pANTLR3_BASE_TREE)adaptor->create				(adaptor, NULL);
adaptor->debugger->createNode	(adaptor->debugger, t);

return	t;
@@ -460,7 +460,7 @@ dbgNil	    (pANTLR3_BASE_TREE_ADAPTOR adaptor)
static	pANTLR3_BASE_TREE
dupTree  (pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE t)
{
-	return	adaptor->dupTreeTT(adaptor, t, NULL);
+	return	(pANTLR3_BASE_TREE)adaptor->dupTreeTT(adaptor, t, NULL);
}

pANTLR3_BASE_TREE
@@ -476,7 +476,7 @@ dupTreeTT			(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE t, pANTLR3_BAS
{
return NULL;
}
-	newTree = t->dupNode(t);
+	newTree = (pANTLR3_BASE_TREE)t->dupNode(t);

// Ensure new subtree root has parent/child index set
//
@@ -486,8 +486,8 @@ dupTreeTT			(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE t, pANTLR3_BAS

for	(i=0; i < n; i++)
{
-		child = adaptor->getChild		(adaptor, t, i);
-		newSubTree = adaptor->dupTreeTT	(adaptor, child, t);
+		child = (pANTLR3_BASE_TREE)adaptor->getChild		(adaptor, t, i);
+		newSubTree = (pANTLR3_BASE_TREE)adaptor->dupTreeTT	(adaptor, child, t);
adaptor->addChild				(adaptor, newTree, newSubTree);
}
return	newTree;
@@ -510,7 +510,7 @@ simulateTreeConstruction(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE tr
n = adaptor->getChildCount(adaptor, tree);
for	(i = 0; i < n; i++)
{
-		child = adaptor->getChild(adaptor, tree, i);
+		child = (pANTLR3_BASE_TREE)adaptor->getChild(adaptor, tree, i);
simulateTreeConstruction(adaptor, child);
adaptor->debugger->addChild(adaptor->debugger, tree, child);
}
@@ -523,7 +523,7 @@ dbgDupTree		(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE tree)

// Call the normal dup tree mechanism first
//
-	t = adaptor->dupTreeTT(adaptor, tree, NULL);
+	t = (pANTLR3_BASE_TREE)adaptor->dupTreeTT(adaptor, tree, NULL);

// In order to tell the debugger what we have just done, we now
// simulate the tree building mechanism. THis will fire
@@ -578,7 +578,7 @@ dbgAddChildToken		(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE t, pANTL

if	(t != NULL && child != NULL)
{
-		tc = adaptor->create(adaptor, child);
+		tc = (pANTLR3_BASE_TREE)adaptor->create(adaptor, child);
adaptor->addChild(adaptor, t, tc);
adaptor->debugger->addChild(adaptor->debugger, t, tc);
}
@@ -654,7 +654,7 @@ becomeRoot	(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE newRootTree, pA
* because if it was a Nil Node, then we can reuse it now.
*/
saveRoot    = newRootTree;
-		newRootTree = newRootTree->getChild(newRootTree, 0);
+		newRootTree = (pANTLR3_BASE_TREE)newRootTree->getChild(newRootTree, 0);

// Reclaim the old nilNode()
//
@@ -718,7 +718,7 @@ static	pANTLR3_BASE_TREE
}
else if	(root->getChildCount(root) == 1)
{
-			root = root->getChild(root, 0);
+			root = (pANTLR3_BASE_TREE)root->getChild(root, 0);
root->setParent(root, NULL);
root->setChildIndex(root, -1);

@@ -739,14 +739,14 @@ static	pANTLR3_BASE_TREE
static	pANTLR3_BASE_TREE
becomeRootToken	(pANTLR3_BASE_TREE_ADAPTOR adaptor, void * newRoot, pANTLR3_BASE_TREE oldRoot)
{
-	return	adaptor->becomeRoot(adaptor, adaptor->create(adaptor, newRoot), oldRoot);
+	return	(pANTLR3_BASE_TREE)adaptor->becomeRoot(adaptor, adaptor->create(adaptor, (pANTLR3_COMMON_TOKEN)newRoot), oldRoot);
}
static	pANTLR3_BASE_TREE
dbgBecomeRootToken	(pANTLR3_BASE_TREE_ADAPTOR adaptor, void * newRoot, pANTLR3_BASE_TREE oldRoot)
{
pANTLR3_BASE_TREE	t;

-	t =	adaptor->becomeRoot(adaptor, adaptor->create(adaptor, newRoot), oldRoot);
+	t =	(pANTLR3_BASE_TREE)adaptor->becomeRoot(adaptor, adaptor->create(adaptor, (pANTLR3_COMMON_TOKEN)newRoot), oldRoot);

adaptor->debugger->becomeRoot(adaptor->debugger,t, oldRoot);

@@ -769,7 +769,7 @@ createTypeToken	(pANTLR3_BASE_TREE_ADAPTOR adaptor, ANTLR3_UINT32 tokenType, pAN

/* Return a new node based upon this token
*/
-	return	adaptor->create(adaptor, fromToken);
+	return	(pANTLR3_BASE_TREE)adaptor->create(adaptor, fromToken);
}
static	pANTLR3_BASE_TREE
dbgCreateTypeToken	(pANTLR3_BASE_TREE_ADAPTOR adaptor, ANTLR3_UINT32 tokenType, pANTLR3_COMMON_TOKEN fromToken)
@@ -800,7 +800,7 @@ createTypeTokenText	(pANTLR3_BASE_TREE_ADAPTOR adaptor, ANTLR3_UINT32 tokenType,

/* Return a new node based upon this token
*/
-	return	adaptor->create(adaptor, fromToken);
+	return	(pANTLR3_BASE_TREE)adaptor->create(adaptor, fromToken);
}
static	pANTLR3_BASE_TREE
dbgCreateTypeTokenText	(pANTLR3_BASE_TREE_ADAPTOR adaptor, ANTLR3_UINT32 tokenType, pANTLR3_COMMON_TOKEN fromToken, pANTLR3_UINT8 text)
@@ -825,7 +825,7 @@ static	pANTLR3_BASE_TREE

/* Return a new node based upon this token
*/
-	return	adaptor->create(adaptor, fromToken);
+	return	(pANTLR3_BASE_TREE)adaptor->create(adaptor, fromToken);
}
static	pANTLR3_BASE_TREE
dbgCreateTypeText	(pANTLR3_BASE_TREE_ADAPTOR adaptor, ANTLR3_UINT32 tokenType, pANTLR3_UINT8 text)
diff --git a/runtime/C/src/antlr3collections.c b/runtime/C/src/antlr3collections.c
index d9e22e9..6efb5d4 100644
--- a/runtime/C/src/antlr3collections.c
+++ b/runtime/C/src/antlr3collections.c
@@ -132,7 +132,7 @@ antlr3HashTableNew(ANTLR3_UINT32 sizeHint)

ANTLR3_UINT32	bucket;	// Used to traverse the buckets

-	table   = ANTLR3_MALLOC(sizeof(ANTLR3_HASH_TABLE));
+	table   = (pANTLR3_HASH_TABLE)ANTLR3_MALLOC(sizeof(ANTLR3_HASH_TABLE));

// Error out if no memory left
if	(table	== NULL)
@@ -653,7 +653,7 @@ antlr3HashPut(pANTLR3_HASH_TABLE table, void * key, void * element, void (ANTLR3
}
else
{
-        entry->keybase.key.sKey	= key;                  /* Record the key value								*/
+        entry->keybase.key.sKey	= (pANTLR3_UINT8)key;                  /* Record the key value								*/
}
entry->nextEntry		= NULL;					/* Ensure that the forward pointer ends the chain   */

@@ -1641,7 +1641,7 @@ newVector(pANTLR3_VECTOR_FACTORY factory)

// If we have anything on the re claim stack, reuse it
//
-	vector = factory->freeStack->peek(factory->freeStack);
+	vector = (pANTLR3_VECTOR)factory->freeStack->peek(factory->freeStack);

if  (vector != NULL)
{
@@ -2337,7 +2337,7 @@ addEdge          (pANTLR3_TOPO topo, ANTLR3_UINT32 edge, ANTLR3_UINT32 dependenc
{
// We don't have any edges yet, so create an array to hold them
//
-        topo->edges = ANTLR3_CALLOC(sizeof(pANTLR3_BITSET) * (maxEdge + 1), 1);
+        topo->edges = (pANTLR3_BITSET*)ANTLR3_CALLOC(sizeof(pANTLR3_BITSET) * (maxEdge + 1), 1);
if (topo->edges == NULL)
{
return;
@@ -2351,7 +2351,7 @@ addEdge          (pANTLR3_TOPO topo, ANTLR3_UINT32 edge, ANTLR3_UINT32 dependenc
{
// WE have some edges but not enough
//
-        topo->edges = ANTLR3_REALLOC(topo->edges, sizeof(pANTLR3_BITSET) * (maxEdge + 1));
+        topo->edges = (pANTLR3_BITSET*)ANTLR3_REALLOC(topo->edges, sizeof(pANTLR3_BITSET) * (maxEdge + 1));
if (topo->edges == NULL)
{
return;
@@ -2535,8 +2535,8 @@ sortToArray      (pANTLR3_TOPO topo)
// entries to accomodate the sorted list and another to accomodate
// the maximum cycle we could detect which is all nodes such as 0->1->2->3->0
//
-    topo->sorted    = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));
-    topo->cycle     = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));
+    topo->sorted    = (pANTLR3_UINT32)ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));
+    topo->cycle     = (pANTLR3_UINT32)ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));

// Next we need an empty bitset to show whether we have visited a node
// or not. This is the bit that gives us linear time of course as we are essentially
@@ -2639,7 +2639,7 @@ sortVector       (pANTLR3_TOPO topo, pANTLR3_VECTOR v)
// acording to where we moved it last. Then we can just swap vector entries until
// we are done :-)
//
-    vIndex = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));
+    vIndex = (pANTLR3_UINT32)ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));

// Start index, each vector entry is located where you think it is
//
diff --git a/runtime/C/src/antlr3commontree.c b/runtime/C/src/antlr3commontree.c
index 65de38f..cffc8cc 100644
--- a/runtime/C/src/antlr3commontree.c
+++ b/runtime/C/src/antlr3commontree.c
@@ -157,7 +157,7 @@ newPoolTree	    (pANTLR3_ARBORETUM factory)

// If we have anything on the re claim stack, reuse that sucker first
//
-    tree = factory->nilStack->peek(factory->nilStack);
+    tree = (pANTLR3_COMMON_TREE)factory->nilStack->peek(factory->nilStack);

if  (tree != NULL)
{
@@ -337,7 +337,7 @@ ANTLR3_API pANTLR3_COMMON_TREE
antlr3CommonTreeNew()
{
pANTLR3_COMMON_TREE	tree;
-	tree    = ANTLR3_CALLOC(1, sizeof(ANTLR3_COMMON_TREE));
+	tree    = (pANTLR3_COMMON_TREE)ANTLR3_CALLOC(1, sizeof(ANTLR3_COMMON_TREE));

if	(tree == NULL)
{
@@ -503,6 +503,8 @@ static pANTLR3_STRING	    toString			(pANTLR3_BASE_TREE tree)
static pANTLR3_BASE_TREE
getParent				(pANTLR3_BASE_TREE tree)
{
+	if (((pANTLR3_COMMON_TREE)(tree->super))->parent == NULL)
+		return NULL;
return & (((pANTLR3_COMMON_TREE)(tree->super))->parent->baseTree);
}

diff --git a/runtime/C/src/antlr3commontreeadaptor.c b/runtime/C/src/antlr3commontreeadaptor.c
index abce6f0..38697f1 100644
--- a/runtime/C/src/antlr3commontreeadaptor.c
+++ b/runtime/C/src/antlr3commontreeadaptor.c
@@ -243,7 +243,7 @@ errorNode				(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_TOKEN_STREAM ctnstream,
// need to track and free the memory allocated to it, so for now, we just
// want something in the tree that isn't a NULL pointer.
//
-	return adaptor->createTypeText(adaptor, ANTLR3_TOKEN_INVALID, (pANTLR3_UINT8)"Tree Error Node");
+	return (pANTLR3_BASE_TREE)adaptor->createTypeText(adaptor, ANTLR3_TOKEN_INVALID, (pANTLR3_UINT8)"Tree Error Node");

}

@@ -252,7 +252,7 @@ errorNode				(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_TOKEN_STREAM ctnstream,
static	pANTLR3_BASE_TREE
dupNode		(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE treeNode)
{
-	return  treeNode == NULL ? NULL : treeNode->dupNode(treeNode);
+	return  treeNode == NULL ? NULL : (pANTLR3_BASE_TREE)treeNode->dupNode(treeNode);
}

static	pANTLR3_BASE_TREE
@@ -453,7 +453,7 @@ replaceChildren
static	pANTLR3_BASE_TREE
getChild				(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE t, ANTLR3_UINT32 i)
{
-	return t->getChild(t, i);
+	return (pANTLR3_BASE_TREE)t->getChild(t, i);
}
static  void
setChild				(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_BASE_TREE t, ANTLR3_UINT32 i, pANTLR3_BASE_TREE child)
diff --git a/runtime/C/src/antlr3commontreenodestream.c b/runtime/C/src/antlr3commontreenodestream.c
index a759d34..54d5184 100644
--- a/runtime/C/src/antlr3commontreenodestream.c
+++ b/runtime/C/src/antlr3commontreenodestream.c
@@ -503,7 +503,7 @@ fillBuffer(pANTLR3_COMMON_TREE_NODE_STREAM ctns, pANTLR3_BASE_TREE t)
//
for	(c = 0; c < nCount; c++)
{
-		fillBuffer(ctns, ctns->adaptor->getChild(ctns->adaptor, t, c));
+		fillBuffer(ctns, (pANTLR3_BASE_TREE)ctns->adaptor->getChild(ctns->adaptor, t, c));
}

// If the tree had children and was not a nil (list) node, then we
@@ -560,7 +560,7 @@ LB(pANTLR3_TREE_NODE_STREAM tns, ANTLR3_INT32 k)
return	&(tns->ctns->INVALID_NODE.baseTree);
}

-	return tns->ctns->nodes->get(tns->ctns->nodes, tns->ctns->p - k);
+	return (pANTLR3_BASE_TREE)tns->ctns->nodes->get(tns->ctns->nodes, tns->ctns->p - k);
}

/// Get tree node at current input pointer + i ahead where i=1 is next node.
@@ -597,7 +597,7 @@ _LT	    (pANTLR3_TREE_NODE_STREAM tns, ANTLR3_INT32 k)
return &(tns->ctns->EOF_NODE.baseTree);
}

-	return	tns->ctns->nodes->get(tns->ctns->nodes, tns->ctns->p + k - 1);
+	return	(pANTLR3_BASE_TREE)tns->ctns->nodes->get(tns->ctns->nodes, tns->ctns->p + k - 1);
}

/// Where is this stream pulling nodes from?  This is not the name, but
@@ -867,7 +867,7 @@ toStringWork	(pANTLR3_TREE_NODE_STREAM tns, pANTLR3_BASE_TREE p, pANTLR3_BASE_TR
{
pANTLR3_BASE_TREE   child;

-		child = p->getChild(p, c);
+		child = (pANTLR3_BASE_TREE)p->getChild(p, c);
tns->toStringWork(tns, child, stop, buf);
}

@@ -947,7 +947,7 @@ get							(pANTLR3_TREE_NODE_STREAM tns, ANTLR3_INT32 k)
fillBufferRoot(tns->ctns);
}

-	return tns->ctns->nodes->get(tns->ctns->nodes, k);
+	return (pANTLR3_BASE_TREE)tns->ctns->nodes->get(tns->ctns->nodes, k);
}

static	void
diff --git a/runtime/C/src/antlr3convertutf.c b/runtime/C/src/antlr3convertutf.c
index 7c2f060..9d2bcf1 100644
--- a/runtime/C/src/antlr3convertutf.c
+++ b/runtime/C/src/antlr3convertutf.c
@@ -288,25 +288,25 @@ isLegalUTF8(const UTF8 *source, int length) {
UTF8 a;
const UTF8 *srcptr = source+length;
switch (length) {
-    default: return false;
+    default: return ANTLR3_FALSE;
/* Everything else falls through when "true"... */
-    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
-    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return false;
-    case 2: if ((a = (*--srcptr)) > 0xBF) return false;
+    case 4: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return ANTLR3_FALSE;
+    case 3: if ((a = (*--srcptr)) < 0x80 || a > 0xBF) return ANTLR3_FALSE;
+    case 2: if ((a = (*--srcptr)) > 0xBF) return ANTLR3_FALSE;

switch (*source) {
/* no fall-through in this inner switch */
-	    case 0xE0: if (a < 0xA0) return false; break;
-	    case 0xED: if (a > 0x9F) return false; break;
-	    case 0xF0: if (a < 0x90) return false; break;
-	    case 0xF4: if (a > 0x8F) return false; break;
-	    default:   if (a < 0x80) return false;
+	    case 0xE0: if (a < 0xA0) return ANTLR3_FALSE; break;
+	    case 0xED: if (a > 0x9F) return ANTLR3_FALSE; break;
+	    case 0xF0: if (a < 0x90) return ANTLR3_FALSE; break;
+	    case 0xF4: if (a > 0x8F) return ANTLR3_FALSE; break;
+	    default:   if (a < 0x80) return ANTLR3_FALSE;
}

-    case 1: if (*source >= 0x80 && *source < 0xC2) return false;
+    case 1: if (*source >= 0x80 && *source < 0xC2) return ANTLR3_FALSE;
}
-    if (*source > 0xF4) return false;
-    return true;
+    if (*source > 0xF4) return ANTLR3_FALSE;
+    return ANTLR3_TRUE;
}

/* --------------------------------------------------------------------- */
@@ -319,7 +319,7 @@ ANTLR3_BOOLEAN
isLegalUTF8Sequence(const UTF8 *source, const UTF8 *sourceEnd) {
int length = trailingBytesForUTF8[*source]+1;
if (source+length > sourceEnd) {
-	return false;
+	return ANTLR3_FALSE;
}
return isLegalUTF8(source, length);
}
diff --git a/runtime/C/src/antlr3debughandlers.c b/runtime/C/src/antlr3debughandlers.c
index d5f177a..5202e8e 100644
--- a/runtime/C/src/antlr3debughandlers.c
+++ b/runtime/C/src/antlr3debughandlers.c
@@ -94,7 +94,7 @@ antlr3DebugListenerNew()
{
pANTLR3_DEBUG_EVENT_LISTENER	delboy;

-	delboy = ANTLR3_CALLOC(1, sizeof(ANTLR3_DEBUG_EVENT_LISTENER));
+	delboy = (pANTLR3_DEBUG_EVENT_LISTENER)ANTLR3_CALLOC(1, sizeof(ANTLR3_DEBUG_EVENT_LISTENER));

if	(delboy == NULL)
{
@@ -136,7 +136,7 @@ antlr3DebugListenerNew()
delboy->terminate				= terminate;
delboy->errorNode				= errorNode;

-	delboy->PROTOCOL_VERSION		= 2;	// ANTLR 3.1 is at protocol version 2
+	delboy->protocol_version		= 2;	// ANTLR 3.1 is at protocol version 2

delboy->port					= DEFAULT_DEBUGGER_PORT;

@@ -299,7 +299,7 @@ handshake				(pANTLR3_DEBUG_EVENT_LISTENER delboy)
// Disable Nagle as this is essentially a chat exchange
//
optVal	= 1;
-		setsockopt(delboy->socket, SOL_SOCKET, TCP_NODELAY, (const void *)&optVal, sizeof(optVal));
+		setsockopt(delboy->socket, SOL_SOCKET, TCP_NODELAY, (const char *)&optVal, sizeof(optVal));

}

@@ -307,7 +307,7 @@ handshake				(pANTLR3_DEBUG_EVENT_LISTENER delboy)
// send it the protocol version we are using and what the name of the grammar
// is that we represent.
//
-	sprintf		(message, "ANTLR %d\n", delboy->PROTOCOL_VERSION);
+	sprintf		(message, "ANTLR %d\n", delboy->protocol_version);
sockSend	(delboy->socket, message, (int)strlen(message));
sprintf		(message, "grammar \"%s\n", delboy->grammarFileName->chars);
sockSend	(delboy->socket, message, (int)strlen(message));
diff --git a/runtime/C/src/antlr3inputstream.c b/runtime/C/src/antlr3inputstream.c
index e3f1c26..6ec7f85 100644
--- a/runtime/C/src/antlr3inputstream.c
+++ b/runtime/C/src/antlr3inputstream.c
@@ -458,7 +458,7 @@ antlr38BitMark	(pANTLR3_INT_STREAM is)
*/
if	(input->markDepth > input->markers->count)
{
-	state	= ANTLR3_MALLOC(sizeof(ANTLR3_LEX_STATE));
+	state	= (pANTLR3_LEX_STATE)ANTLR3_MALLOC(sizeof(ANTLR3_LEX_STATE));

/* Add it to the table
*/
@@ -572,7 +572,7 @@ antlr38BitSeek	(pANTLR3_INT_STREAM is, ANTLR3_MARKER seekPoint)
ANTLR3_INT32   count;
pANTLR3_INPUT_STREAM input;

-	input   = ANTLR3_FUNC_PTR(((pANTLR3_INPUT_STREAM) is->super));
+	input   = (pANTLR3_INPUT_STREAM)ANTLR3_FUNC_PTR(((pANTLR3_INPUT_STREAM) is->super));

/* If the requested seek point is less than the current
* input point, then we assume that we are resetting from a mark
@@ -865,7 +865,7 @@ antlr3UTF16LA(pANTLR3_INT_STREAM is, ANTLR3_INT32 la)
// in the input stream
//
input       = ((pANTLR3_INPUT_STREAM) (is->super));
-        nextChar    = input->nextChar;
+        nextChar    = (UTF16*)input->nextChar;

// If a positive offset then advance forward, else retreat
//
@@ -1145,7 +1145,7 @@ antlr3UTF16LALE(pANTLR3_INT_STREAM is, ANTLR3_INT32 la)
// in the input stream
//
input       = ((pANTLR3_INPUT_STREAM) (is->super));
-        nextChar    = input->nextChar;
+        nextChar    = (pANTLR3_UCHAR)input->nextChar;

// If a positive offset then advance forward, else retreat
//
@@ -1366,7 +1366,7 @@ antlr3UTF16LABE(pANTLR3_INT_STREAM is, ANTLR3_INT32 la)
// in the input stream
//
input       = ((pANTLR3_INPUT_STREAM) (is->super));
-        nextChar    = input->nextChar;
+        nextChar    = (pANTLR3_UCHAR)input->nextChar;

// If a positive offset then advance forward, else retreat
//
@@ -1810,7 +1810,7 @@ antlr3UTF8Consume(pANTLR3_INT_STREAM is)

input   = ((pANTLR3_INPUT_STREAM) (is->super));

-    nextChar = input->nextChar;
+    nextChar = (pANTLR3_UINT8)input->nextChar;

if	(nextChar < (((pANTLR3_UINT8)input->data) + input->sizeBuf))
{
@@ -1876,7 +1876,7 @@ antlr3UTF8LA(pANTLR3_INT_STREAM is, ANTLR3_INT32 la)

input   = ((pANTLR3_INPUT_STREAM) (is->super));

-    nextChar = input->nextChar;
+    nextChar = (pANTLR3_UINT8)input->nextChar;

// Do we need to traverse forwards or backwards?
// - LA(0) is treated as LA(1) and we assume that the nextChar is
diff --git a/runtime/C/src/antlr3lexer.c b/runtime/C/src/antlr3lexer.c
index d981ab7..b51d12d 100644
--- a/runtime/C/src/antlr3lexer.c
+++ b/runtime/C/src/antlr3lexer.c
@@ -176,7 +176,7 @@ reset	(pANTLR3_BASE_RECOGNIZER rec)
{
pANTLR3_LEXER   lexer;

-    lexer   = rec->super;
+    lexer   = (pANTLR3_LEXER)rec->super;

lexer->rec->state->token			    = NULL;
lexer->rec->state->type			    = ANTLR3_TOKEN_INVALID;
diff --git a/runtime/C/src/antlr3rewritestreams.c b/runtime/C/src/antlr3rewritestreams.c
index 9afb6e1..8da3011 100644
--- a/runtime/C/src/antlr3rewritestreams.c
+++ b/runtime/C/src/antlr3rewritestreams.c
@@ -197,7 +197,7 @@ antlr3RewriteRuleElementStreamNewAE(pANTLR3_BASE_TREE_ADAPTOR adaptor, pANTLR3_B
// Remove the entry from the vector. We do not
// cause it to be freed by using remove.
//
-		stream = rec->state->rStreams->remove(rec->state->rStreams, rec->state->rStreams->count - 1);
+		stream = (pANTLR3_REWRITE_RULE_ELEMENT_STREAM)rec->state->rStreams->remove(rec->state->rStreams, rec->state->rStreams->count - 1);

// We found a stream we can reuse.
// If the stream had a vector, then it will have been cleared
@@ -577,13 +577,13 @@ nextTree(pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream)
// if out of elements and size is 1, dup
//
el = stream->_next(stream);
-		return stream->dup(stream, el);
+		return (pANTLR3_BASE_TREE)stream->dup(stream, el);
}

// test size above then fetch
//
el = stream->_next(stream);
-	return el;
+	return (pANTLR3_BASE_TREE)el;
}

/// Return the next element for a caller that wants just the token
@@ -607,7 +607,7 @@ next	    (pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream)
{
pANTLR3_BASE_TREE el;

-		el = stream->_next(stream);
+		el = (pANTLR3_BASE_TREE)stream->_next(stream);

return	stream->dup(stream, el);
}
@@ -737,7 +737,7 @@ toTree   (pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream, void * element)
static pANTLR3_BASE_TREE
toTreeNode   (pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream, void * element)
{
-	return stream->adaptor->dupNode(stream->adaptor, (pANTLR3_BASE_TREE)element);
+	return (pANTLR3_BASE_TREE)stream->adaptor->dupNode(stream->adaptor, (pANTLR3_BASE_TREE)element);
}

#ifdef ANTLR3_WINDOWS
@@ -766,13 +766,13 @@ hasNext  (pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream)
static pANTLR3_BASE_TREE
nextNodeToken(pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream)
{
-	return stream->adaptor->create(stream->adaptor, stream->_next(stream));
+	return (pANTLR3_BASE_TREE)stream->adaptor->create(stream->adaptor, (pANTLR3_COMMON_TOKEN)stream->_next(stream));
}

static pANTLR3_BASE_TREE
nextNodeNode(pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream)
{
-	return stream->_next(stream);
+	return (pANTLR3_BASE_TREE)stream->_next(stream);
}

/// Treat next element as a single node even if it's a subtree.
@@ -789,7 +789,7 @@ nextNode (pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream)
{

ANTLR3_UINT32	n;
-	pANTLR3_BASE_TREE	el = stream->_next(stream);
+	pANTLR3_BASE_TREE	el = (pANTLR3_BASE_TREE)stream->_next(stream);

n = stream->size(stream);
if (stream->dirty == ANTLR3_TRUE || (stream->cursor > n && n == 1))
@@ -797,7 +797,7 @@ nextNode (pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream)
// We are out of elements and the size is 1, which means we just
// dup the node that we have
//
-		return	stream->adaptor->dupNode(stream->adaptor, el);
+		return	(pANTLR3_BASE_TREE)stream->adaptor->dupNode(stream->adaptor, el);
}

// We were not out of nodes, so the one we received is the one to return
@@ -837,7 +837,7 @@ getDescription  (pANTLR3_REWRITE_RULE_ELEMENT_STREAM stream)
{
if (stream->elementDescription == NULL)
{
-		stream->elementDescription = "<unknown source>";
+		stream->elementDescription = (void*)"<unknown source>";
}

return  stream->elementDescription;
diff --git a/runtime/C/src/antlr3treeparser.c b/runtime/C/src/antlr3treeparser.c
index b7e035a..c40a1ef 100644
--- a/runtime/C/src/antlr3treeparser.c
+++ b/runtime/C/src/antlr3treeparser.c
@@ -232,7 +232,7 @@ getMissingSymbol			(pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM	istre
current = tns->_LT(tns, i--);
}

-	node	= current->dupNode(current);
+	node	= (pANTLR3_BASE_TREE)current->dupNode(current);

// Find the newly dupicated token
//

