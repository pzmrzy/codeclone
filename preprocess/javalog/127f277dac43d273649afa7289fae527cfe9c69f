commit 127f277dac43d273649afa7289fae527cfe9c69f
Author:     Ivan Brezina <ibrezina@ibrezina.net>
AuthorDate: Fri Jun 14 22:53:03 2013 +0200
Commit:     Ivan Brezina <ibrezina@ibrezina.net>
CommitDate: Wed Jun 26 22:28:36 2013 +0200

Lexer tests added

diff --git a/runtime/Cpp/tests/.gitignore b/runtime/Cpp/tests/.gitignore
new file mode 100644
index 0000000..52e8c1a
--- /dev/null
+++ b/runtime/Cpp/tests/.gitignore
@@ -0,0 +1,20 @@
+# Windows test files
+t[0-9][0-9][0-9].exe
+
+# Unix test files
+t[0-9][0-9][0-9]
+
+# ANTLR generated files
+t[0-9][0-9][0-9]?*.cpp
+t[0-9][0-9][0-9]?*.hpp
+t[0-9][0-9][0-9]*.tokens
+
+# MSVC files
+*.vcxproj
+*.vcxproj.user
+Debug/
+Release/
+
+# Eclipse CDT files
+.cproject
+
diff --git a/runtime/Cpp/tests/Makefile b/runtime/Cpp/tests/Makefile
new file mode 100644
index 0000000..0c3b35d
--- /dev/null
+++ b/runtime/Cpp/tests/Makefile
@@ -0,0 +1,95 @@
+.PRECIOUS=.o
+
+ANTLRGRAMMARS ?= $(wildcard t0[01]*.g)
+HEADERS = $(wildcard *.hpp) $(wildcard *.inl)
+RUNTIME_HEADERS = $(wildcard ../include/*.hpp) $(wildcard ../include/*.inl)
+SOURCES = $(wildcard *.cpp)
+POBJS = $(PSOURCES:.cpp=.o)
+TOKENS = $(ANTLRGRAMMARS:.g=.tokens)
+
+GRAMMAROPTIONS= #-report -Xconversiontimeout 1500000 -Xmultithreaded -Xwatchconversion
+ANTLR = ../../../antlr-complete/target/antlr-complete-3.5.1-SNAPSHOT.jar
+STGS  = $(wildcard ../../../tool/src/main/resources/org/antlr/codegen/templates/Cpp/*.stg)
+
+.SUFFIXES:
+
+INCLUDES= -I. -I../include/
+
+CFLAGS=-ggdb3 -O0 -fno-inline -Wall -Wno-unused-variable
+#CFLAGS=-ggdb3 -O3
+
+TOBJS= utils.o
+
+all: $(ANTLR) $(TOKENS) t001 t002 t003 t004 t005 t006 t006 t007 t008 t009 t010 t011 t012
+
+# For devel only. This will replace .stg files in the tool in a fast way
+#
+$(ANTLR): $(STGS)
+	jar uvf $(ANTLR) -C ../../../tool/src/main/resources \
+	org/antlr/codegen/templates/Cpp/Cpp.stg
+
+t001:	t001.cpp t001lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t002:	t002.cpp t002lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t003:	t003.cpp t003lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t004:	t004.cpp t004lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t005:	t005.cpp t005lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t006:	t006.cpp t006lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t007:	t007.cpp t007lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t008:	t008.cpp t008lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t009:	t009.cpp t009lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t010:	t010.cpp t010lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t011:	t011.cpp t011lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+t012:	t012.cpp t012lexerXMLLexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+
+# AST commented out
+# t039:	t039.cpp t039labels.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+# 	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+#
+# t042:	t042.cpp t005lexer.tokens UserTestTraits.hpp Makefile $(ANTLR) $(RUNTIME_HEADERS)
+# 	g++ $(CFLAGS) -DUSESTL $(INCLUDES) $< $@?*.cpp -o $@
+
+clean:
+	rm -f *.o t0[0-9][0-9]??*.[ch]pp *.tokens t[0-9][0-9][0-9] t0[0-9][0-9].exe
+
+# %.u: %.g
+# 	@echo "Bulding dependencies for "$<
+# 	java -jar $(ANTLR) -depend $< > $@
+# 	@grep ":" $@ |awk 'BEGIN {printf "ANTLRGENLIST := " }{printf " " $$1}END {print ""}'  >> $@.tmp
+# 	@cat $@.tmp >> $@
+# 	$(RM) $@.tmp
+
+%.tokens %.cpp %Lexer.c %Parser.c %Lexer.h %Parser.h %.hpp: %.g $(ANTLR)
+	java -jar $(ANTLR) $(GRAMMAROPTIONS) $<
+
+ifneq ($(MAKECMDGOALS),clean)
+ifneq ($(strip $(ANTLRGRAMMARS)),)
+#-include $(ANTLRGRAMMARS:.g=.u)
+endif
+endif
+
+%.o: %.cpp $(HEADERS) utils.hpp
+	g++ $(CFLAGS) -DUSESTL $(INCLUDES) -c $< -o $@
diff --git a/runtime/Cpp/tests/UserTestTraits.hpp b/runtime/Cpp/tests/UserTestTraits.hpp
new file mode 100644
index 0000000..f73faa2
--- /dev/null
+++ b/runtime/Cpp/tests/UserTestTraits.hpp
@@ -0,0 +1,66 @@
+#ifndef	_T_TEST_TRAITS_H
+#define	_T_TEST_TRAITS_H
+
+// First thing we always do is include the ANTLR3 generated files, which
+// will automatically include the antlr3 runtime header files.
+// The compiler must use -I (or set the project settings in VS2005)
+// to locate the antlr3 runtime files and -I. to find this file
+#include <antlr3.hpp>
+
+// Forward declaration for Lexer&Parser class(es)
+namespace Antlr3Test {
+	class S1Lexer;
+	class S1Parser;
+
+	class t001lexer;
+	class t002lexer;
+	class t003lexer;
+	class t004lexer;
+	class t005lexer;
+	class t006lexer;
+	class t007lexer;
+	class t008lexer;
+	class t009lexer;
+	class t010lexer;
+	class t011lexer;
+	class t012lexerXMLLexer;
+
+	class t039labelsLexer;
+	class t039labelsParser;
+};
+
+namespace Antlr3Test {
+
+	//code for overriding
+	template<class ImplTraits>
+	class UserTraits : public antlr3::CustomTraitsBase<ImplTraits>
+	{
+	public:
+	};
+
+	// Even Lexer only samples need some Parser class as a template parameter
+	class NoParser {
+	};
+
+	// Instantiate the Traits class(will be used for Lexer/Parser template instantiations)
+	typedef antlr3::Traits<S1Lexer, S1Parser, UserTraits> S1LexerTraits;
+	typedef antlr3::Traits<S1Lexer, S1Parser, UserTraits> S1ParserTraits;
+
+	typedef antlr3::Traits<t001lexer, NoParser, UserTraits> t001lexerTraits;
+	typedef antlr3::Traits<t002lexer, NoParser, UserTraits> t002lexerTraits;
+	typedef antlr3::Traits<t003lexer, NoParser, UserTraits> t003lexerTraits;
+	typedef antlr3::Traits<t004lexer, NoParser, UserTraits> t004lexerTraits;
+	typedef antlr3::Traits<t005lexer, NoParser, UserTraits> t005lexerTraits;
+	typedef antlr3::Traits<t006lexer, NoParser, UserTraits> t006lexerTraits;
+	typedef antlr3::Traits<t007lexer, NoParser, UserTraits> t007lexerTraits;
+	typedef antlr3::Traits<t008lexer, NoParser, UserTraits> t008lexerTraits;
+	typedef antlr3::Traits<t009lexer, NoParser, UserTraits> t009lexerTraits;
+	typedef antlr3::Traits<t010lexer, NoParser, UserTraits> t010lexerTraits;
+	typedef antlr3::Traits<t011lexer, NoParser, UserTraits> t011lexerTraits;
+	typedef antlr3::Traits<t012lexerXMLLexer, NoParser, UserTraits> t012lexerXMLLexerTraits;
+
+	typedef antlr3::Traits<t039labelsLexer, t039labelsParser, UserTraits> t039labelsLexerTraits;
+	typedef t039labelsLexerTraits t039labelsParserTraits;
+};
+
+#endif
diff --git a/runtime/Cpp/tests/t001.cpp b/runtime/Cpp/tests/t001.cpp
new file mode 100644
index 0000000..6feb1c8
--- /dev/null
+++ b/runtime/Cpp/tests/t001.cpp
@@ -0,0 +1,95 @@
+#include "UserTestTraits.hpp"
+#include "t001lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testIteratorInterface(string const& data);
+int testMalformedInput(string const& data);
+
+static    t001lexer*		    lxr;
+
+int main (int argc, char *argv[])
+{
+	testValid("0");
+	testIteratorInterface("0");
+	testMalformedInput("1");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t001lexerTraits::InputStreamType* input	= new t001lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t001");
+	if (lxr == NULL)
+		lxr = new t001lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	t001lexerTraits::CommonTokenType *token0 = lxr->nextToken();
+	t001lexerTraits::CommonTokenType *token1 = lxr->nextToken();
+
+	std::cout << token0->getText() << std::endl;
+	std::cout << token1->getText() << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testIteratorInterface(string const& data)
+{
+	t001lexerTraits::InputStreamType* input	= new t001lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t001");
+	if (lxr == NULL)
+		lxr = new t001lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testIteratorInterface: \"" << data << '"' <<std::endl;
+
+	t001lexerTraits::TokenStreamType *tstream = new t001lexerTraits::TokenStreamType(ANTLR_SIZE_HINT, lxr->get_tokSource());
+	t001lexerTraits::CommonTokenType const *token0 = tstream->_LT(1);
+	t001lexerTraits::CommonTokenType const *token1 = tstream->_LT(2);
+
+	std::cout << token0->getText() << std::endl;
+	std::cout << token1->getText() << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t001lexerTraits::InputStreamType* input	= new t001lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t001");
+	if (lxr == NULL)
+		lxr = new t001lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t001lexerTraits::CommonTokenType *token0 = lxr->nextToken();
+	std::cout << token0->getText() << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t001lexer.g b/runtime/Cpp/tests/t001lexer.g
new file mode 100644
index 0000000..a9594d4
--- /dev/null
+++ b/runtime/Cpp/tests/t001lexer.g
@@ -0,0 +1,13 @@
+lexer grammar t001lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+ZERO: '0';
diff --git a/runtime/Cpp/tests/t002.cpp b/runtime/Cpp/tests/t002.cpp
new file mode 100644
index 0000000..b04c463
--- /dev/null
+++ b/runtime/Cpp/tests/t002.cpp
@@ -0,0 +1,106 @@
+#include "UserTestTraits.hpp"
+#include "t002lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testIteratorInterface(string const& data);
+int testMalformedInput(string const& data);
+
+static t002lexer *lxr;
+static t002lexerTokens::Tokens ExpectedTokens[] =
+  {
+    t002lexerTokens::ZERO,
+    t002lexerTokens::ONE,
+    t002lexerTokens::EOF_TOKEN
+  };
+
+int main (int argc, char *argv[])
+{
+	testValid("01");
+	testIteratorInterface("01");
+	testMalformedInput("2");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t002lexerTraits::InputStreamType* input	= new t002lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t002");
+	if (lxr == NULL)
+		lxr = new t002lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	for(unsigned i = 0; i <= 2 ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t002lexerTraits::CommonTokenType *token = lxr->nextToken();
+		std::cout << token->getText() << '\t'
+			  << (token->getType() == ExpectedTokens[i] ? "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testIteratorInterface(string const& data)
+{
+	t002lexerTraits::InputStreamType* input	= new t002lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t002");
+	if (lxr == NULL)
+		lxr = new t002lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testIteratorInterface: \"" << data << '"' <<std::endl;
+
+	t002lexerTraits::TokenStreamType *tstream = new t002lexerTraits::TokenStreamType(ANTLR_SIZE_HINT, lxr->get_tokSource());
+	t002lexerTraits::CommonTokenType const *token0 = tstream->_LT(1);
+	t002lexerTraits::CommonTokenType const *token1 = tstream->_LT(2);
+	t002lexerTraits::CommonTokenType const *token2 = tstream->_LT(3);
+
+	std::cout << token0->getText() << std::endl;
+	std::cout << token1->getText() << std::endl;
+	std::cout << token2->getText() << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t002lexerTraits::InputStreamType* input	= new t002lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t002");
+	if (lxr == NULL)
+		lxr = new t002lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t002lexerTraits::CommonTokenType *token0 = lxr->nextToken();
+	std::cout << token0->getText() << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t002lexer.g b/runtime/Cpp/tests/t002lexer.g
new file mode 100644
index 0000000..c367547
--- /dev/null
+++ b/runtime/Cpp/tests/t002lexer.g
@@ -0,0 +1,14 @@
+lexer grammar t002lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+ZERO: '0';
+ONE: '1';
diff --git a/runtime/Cpp/tests/t003.cpp b/runtime/Cpp/tests/t003.cpp
new file mode 100644
index 0000000..e6dc059
--- /dev/null
+++ b/runtime/Cpp/tests/t003.cpp
@@ -0,0 +1,118 @@
+#include "UserTestTraits.hpp"
+#include "t003lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testIteratorInterface(string const& data);
+int testMalformedInput(string const& data);
+
+static t003lexer *lxr;
+
+struct TokenData
+{
+	t003lexerTokens::Tokens type;
+	//unsigned start;
+	//unsigned stop;
+	//const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	{ t003lexerTokens::ZERO      },
+	{ t003lexerTokens::FOOZE     },
+	{ t003lexerTokens::ONE       },
+	{ t003lexerTokens::EOF_TOKEN }
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("0fooze1");
+	testIteratorInterface("0fooze1");
+	testMalformedInput("2");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t003lexerTraits::InputStreamType* input	= new t003lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t003");
+	if (lxr == NULL)
+		lxr = new t003lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t003lexerTraits::CommonTokenType *token = lxr->nextToken();
+		std::cout << token->getText() << '\t'
+			  << (token->getType() == ExpectedTokens[i].type ? "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testIteratorInterface(string const& data)
+{
+	t003lexerTraits::InputStreamType* input	= new t003lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t003");
+	if (lxr == NULL)
+		lxr = new t003lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testIteratorInterface: \"" << data << '"' <<std::endl;
+
+	t003lexerTraits::TokenStreamType *tstream = new t003lexerTraits::TokenStreamType(ANTLR_SIZE_HINT, lxr->get_tokSource());
+	t003lexerTraits::CommonTokenType const *token0 = tstream->_LT(1);
+	t003lexerTraits::CommonTokenType const *token1 = tstream->_LT(2);
+	t003lexerTraits::CommonTokenType const *token2 = tstream->_LT(3);
+	t003lexerTraits::CommonTokenType const *token3 = tstream->_LT(4);
+
+	std::cout << token0->getText() << std::endl;
+	std::cout << token1->getText() << std::endl;
+	std::cout << token2->getText() << std::endl;
+	std::cout << token3->getText() << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t003lexerTraits::InputStreamType* input	= new t003lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t003");
+	if (lxr == NULL)
+		lxr = new t003lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t003lexerTraits::CommonTokenType *token0 = lxr->nextToken();
+	std::cout << token0->getText() << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t003lexer.g b/runtime/Cpp/tests/t003lexer.g
new file mode 100644
index 0000000..72e671b
--- /dev/null
+++ b/runtime/Cpp/tests/t003lexer.g
@@ -0,0 +1,15 @@
+lexer grammar t003lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+ZERO: '0';
+ONE: '1';
+FOOZE: 'fooze';
diff --git a/runtime/Cpp/tests/t004.cpp b/runtime/Cpp/tests/t004.cpp
new file mode 100644
index 0000000..fc0ecd3
--- /dev/null
+++ b/runtime/Cpp/tests/t004.cpp
@@ -0,0 +1,100 @@
+#include "UserTestTraits.hpp"
+#include "t004lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput(string const& data);
+
+static t004lexer *lxr;
+
+struct TokenData
+{
+	t004lexerTokens::Tokens type;
+	unsigned start;
+	unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	{ t004lexerTokens::FOO, 0, 0, "f"},
+	{ t004lexerTokens::FOO, 1, 2, "fo"},
+	{ t004lexerTokens::FOO, 3, 5, "foo"},
+	{ t004lexerTokens::FOO, 6, 9, "fooo"}
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("ffofoofooo");
+	testMalformedInput("2");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t004lexerTraits::InputStreamType* input	= new t004lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t004");
+	if (lxr == NULL)
+		lxr = new t004lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	std::cout << "Text:"  << '\t'
+		  << "Type:"  << '\t'
+		  << "Start:" << '\t'
+		  << "Stop:"  << '\t'
+		  << "Text:"  << '\t' << std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t004lexerTraits::CommonTokenType *token = lxr->nextToken();
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getType()       == ExpectedTokens[i].type ?  "OK" : "Fail")
+			  << '\t' << (startIndex == ExpectedTokens[i].start ? "OK" : "Fail")
+			  << '\t' << (stopIndex  == ExpectedTokens[i].stop ?  "OK" : "Fail")
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t004lexerTraits::InputStreamType* input	= new t004lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t004");
+	if (lxr == NULL)
+		lxr = new t004lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t004lexerTraits::CommonTokenType *token0 = lxr->nextToken();
+	std::cout << token0->getText() << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t004lexer.g b/runtime/Cpp/tests/t004lexer.g
new file mode 100644
index 0000000..2079c7c
--- /dev/null
+++ b/runtime/Cpp/tests/t004lexer.g
@@ -0,0 +1,13 @@
+lexer grammar t004lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+FOO: 'f' 'o'*;
diff --git a/runtime/Cpp/tests/t005.cpp b/runtime/Cpp/tests/t005.cpp
new file mode 100644
index 0000000..7484630
--- /dev/null
+++ b/runtime/Cpp/tests/t005.cpp
@@ -0,0 +1,131 @@
+#include "UserTestTraits.hpp"
+#include "t005lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput1(string const& data);
+int testMalformedInput2(string const& data);
+
+static t005lexer *lxr;
+
+struct TokenData
+{
+	t005lexerTokens::Tokens type;
+	unsigned start;
+	unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	// "fofoofooo"
+	{ t005lexerTokens::FOO, 0, 1, "fo"},
+	{ t005lexerTokens::FOO, 2, 4, "foo"},
+	{ t005lexerTokens::FOO, 5, 8, "fooo"},
+	{ t005lexerTokens::EOF_TOKEN, 9, 9, "<EOF>"}
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("fofoofooo");
+	testMalformedInput1("2");
+	testMalformedInput2("f");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t005lexerTraits::InputStreamType* input	= new t005lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t005");
+	if (lxr == NULL)
+		lxr = new t005lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	std::cout << "Text:"  << '\t'
+		  << "Type:"  << '\t'
+		  << "Start:" << '\t'
+		  << "Stop:"  << '\t'
+		  << "Text:"  << '\t' << std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t005lexerTraits::CommonTokenType *token = lxr->nextToken();
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getType()       == ExpectedTokens[i].type ?  "OK" : "Fail")
+			  << '\t' << (startIndex == ExpectedTokens[i].start ? "OK" : "Fail")
+			  << '\t' << (stopIndex  == ExpectedTokens[i].stop ?  "OK" : "Fail")
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput1(string const& data)
+{
+	t005lexerTraits::InputStreamType* input	= new t005lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t005");
+	if (lxr == NULL)
+		lxr = new t005lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput1: \"" << data << '"' <<std::endl;
+
+	t005lexerTraits::CommonTokenType *token0 = lxr->nextToken();
+	std::cout << token0->getText() << std::endl;
+
+	//except antlr3.MismatchedTokenException as exc:
+	//self.assertEqual(exc.expecting, 'f')
+	//self.assertEqual(exc.unexpectedType, '2')
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput2(string const& data)
+{
+	t005lexerTraits::InputStreamType* input	= new t005lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t005");
+	if (lxr == NULL)
+		lxr = new t005lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput2: \"" << data << '"' <<std::endl;
+
+	t005lexerTraits::CommonTokenType *token0 = lxr->nextToken();
+	std::cout << token0->getText() << std::endl;
+
+	//except antlr3.EarlyExitException as exc:
+	//self.assertEqual(exc.unexpectedType, antlr3.EOF)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t005lexer.g b/runtime/Cpp/tests/t005lexer.g
new file mode 100644
index 0000000..64e856e
--- /dev/null
+++ b/runtime/Cpp/tests/t005lexer.g
@@ -0,0 +1,13 @@
+lexer grammar t005lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+FOO: 'f' 'o'+;
diff --git a/runtime/Cpp/tests/t006.cpp b/runtime/Cpp/tests/t006.cpp
new file mode 100644
index 0000000..38c6d2f
--- /dev/null
+++ b/runtime/Cpp/tests/t006.cpp
@@ -0,0 +1,111 @@
+#include "UserTestTraits.hpp"
+#include "t006lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput(string const& data);
+
+static t006lexer *lxr;
+
+struct TokenData
+{
+	t006lexerTokens::Tokens type;
+	unsigned start;
+	unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	// "fofaaooa"
+	{ t006lexerTokens::FOO, 0, 1, "fo"},
+	{ t006lexerTokens::FOO, 2, 7, "faaooa"},
+	{ t006lexerTokens::EOF_TOKEN, 8, 8, "<EOF>"}
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("fofaaooa");
+	testMalformedInput("fofoaooaoa2");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t006lexerTraits::InputStreamType* input	= new t006lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t006");
+	if (lxr == NULL)
+		lxr = new t006lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	std::cout << "Text:"  << '\t'
+		  << "Type:"  << '\t'
+		  << "Start:" << '\t'
+		  << "Stop:"  << '\t'
+		  << "Text:"  << '\t' << std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t006lexerTraits::CommonTokenType *token = lxr->nextToken();
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getType()       == ExpectedTokens[i].type ?  "OK" : "Fail")
+			  << '\t' << (startIndex == ExpectedTokens[i].start ? "OK" : "Fail")
+			  << '\t' << (stopIndex  == ExpectedTokens[i].stop ?  "OK" : "Fail")
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t006lexerTraits::InputStreamType* input	= new t006lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t006");
+	if (lxr == NULL)
+		lxr = new t006lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t006lexerTraits::CommonTokenType *token;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+
+    //except antlr3.MismatchedTokenException as exc:
+    //self.assertEqual(exc.expecting, 'f')
+    //self.assertEqual(exc.unexpectedType, '2')
+    //self.assertEqual(exc.charPositionInLine, 10)
+    //self.assertEqual(exc.line, 1)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t006lexer.g b/runtime/Cpp/tests/t006lexer.g
new file mode 100644
index 0000000..ce7a9a2
--- /dev/null
+++ b/runtime/Cpp/tests/t006lexer.g
@@ -0,0 +1,13 @@
+lexer grammar t006lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+FOO: 'f' ('o' | 'a')*;
diff --git a/runtime/Cpp/tests/t007.cpp b/runtime/Cpp/tests/t007.cpp
new file mode 100644
index 0000000..dc9b5a3
--- /dev/null
+++ b/runtime/Cpp/tests/t007.cpp
@@ -0,0 +1,105 @@
+#include "UserTestTraits.hpp"
+#include "t007lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput(string const& data);
+
+static t007lexer *lxr;
+
+struct TokenData
+{
+	t007lexerTokens::Tokens type;
+	unsigned start;
+	unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	// "fofababbooabb"
+	{ t007lexerTokens::FOO, 0, 1, "fo"},
+	{ t007lexerTokens::FOO, 2, 12, "fababbooabb"},
+	{ t007lexerTokens::EOF_TOKEN, 13, 13, "<EOF>"}
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("fofababbooabb");
+	testMalformedInput("foaboao");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t007lexerTraits::InputStreamType* input	= new t007lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t007");
+	if (lxr == NULL)
+		lxr = new t007lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	std::cout << "Text:"  << '\t'
+		  << "Type:"  << '\t'
+		  << "Start:" << '\t'
+		  << "Stop:"  << '\t'
+		  << "Text:"  << '\t' << std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t007lexerTraits::CommonTokenType *token = lxr->nextToken();
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getType()       == ExpectedTokens[i].type ?  "OK" : "Fail")
+			  << '\t' << (startIndex == ExpectedTokens[i].start ? "OK" : "Fail")
+			  << '\t' << (stopIndex  == ExpectedTokens[i].stop ?  "OK" : "Fail")
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t007lexerTraits::InputStreamType* input	= new t007lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t007");
+	if (lxr == NULL)
+		lxr = new t007lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t007lexerTraits::CommonTokenType *token0 = lxr->nextToken();
+	std::cout << token0->getText() << std::endl;
+
+    //except antlr3.EarlyExitException as exc:
+    //   self.assertEqual(exc.unexpectedType, 'o')
+    //   self.assertEqual(exc.charPositionInLine, 6)
+    //   self.assertEqual(exc.line, 1)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t007lexer.g b/runtime/Cpp/tests/t007lexer.g
new file mode 100644
index 0000000..1eac531
--- /dev/null
+++ b/runtime/Cpp/tests/t007lexer.g
@@ -0,0 +1,13 @@
+lexer grammar t007lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+FOO: 'f' ('o' | 'a' 'b'+)*;
diff --git a/runtime/Cpp/tests/t008.cpp b/runtime/Cpp/tests/t008.cpp
new file mode 100644
index 0000000..fbb541b
--- /dev/null
+++ b/runtime/Cpp/tests/t008.cpp
@@ -0,0 +1,111 @@
+#include "UserTestTraits.hpp"
+#include "t008lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput(string const& data);
+
+static t008lexer *lxr;
+
+struct TokenData
+{
+	t008lexerTokens::Tokens type;
+	unsigned start;
+	unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	// "ffaf"
+	{ t008lexerTokens::FOO, 0, 0, "f"},
+	{ t008lexerTokens::FOO, 1, 2, "fa"},
+	{ t008lexerTokens::FOO, 3, 3, "f"},
+	{ t008lexerTokens::EOF_TOKEN, 4, 4, "<EOF>"}
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("ffaf");
+	testMalformedInput("fafb");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t008lexerTraits::InputStreamType* input	= new t008lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t008");
+	if (lxr == NULL)
+		lxr = new t008lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	std::cout << "Text:"  << '\t'
+		  << "Type:"  << '\t'
+		  << "Start:" << '\t'
+		  << "Stop:"  << '\t'
+		  << "Text:"  << '\t' << std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t008lexerTraits::CommonTokenType *token = lxr->nextToken();
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getType()       == ExpectedTokens[i].type ?  "OK" : "Fail")
+			  << '\t' << (startIndex == ExpectedTokens[i].start ? "OK" : "Fail")
+			  << '\t' << (stopIndex  == ExpectedTokens[i].stop ?  "OK" : "Fail")
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t008lexerTraits::InputStreamType* input	= new t008lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t008");
+	if (lxr == NULL)
+		lxr = new t008lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t008lexerTraits::CommonTokenType *token;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+
+	//except antlr3.MismatchedTokenException as exc:
+    //   self.assertEqual(exc.unexpectedType, 'b')
+    //   self.assertEqual(exc.charPositionInLine, 3)
+    //   self.assertEqual(exc.line, 1)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t008lexer.g b/runtime/Cpp/tests/t008lexer.g
new file mode 100644
index 0000000..0294155
--- /dev/null
+++ b/runtime/Cpp/tests/t008lexer.g
@@ -0,0 +1,13 @@
+lexer grammar t008lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+FOO: 'f' 'a'?;
diff --git a/runtime/Cpp/tests/t009.cpp b/runtime/Cpp/tests/t009.cpp
new file mode 100644
index 0000000..75b2fca
--- /dev/null
+++ b/runtime/Cpp/tests/t009.cpp
@@ -0,0 +1,111 @@
+#include "UserTestTraits.hpp"
+#include "t009lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput(string const& data);
+
+static t009lexer *lxr;
+
+struct TokenData
+{
+	t009lexerTokens::Tokens type;
+	unsigned start;
+	unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	// "085"
+	{ t009lexerTokens::DIGIT, 0, 0, "0"},
+	{ t009lexerTokens::DIGIT, 1, 1, "8"},
+	{ t009lexerTokens::DIGIT, 2, 2, "5"},
+	{ t009lexerTokens::EOF_TOKEN, 3, 3, "<EOF>"}
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("085");
+	testMalformedInput("2a");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t009lexerTraits::InputStreamType* input	= new t009lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t009");
+	if (lxr == NULL)
+		lxr = new t009lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	std::cout << "Text:"  << '\t'
+		  << "Type:"  << '\t'
+		  << "Start:" << '\t'
+		  << "Stop:"  << '\t'
+		  << "Text:"  << '\t' << std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t009lexerTraits::CommonTokenType *token = lxr->nextToken();
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getType()       == ExpectedTokens[i].type ?  "OK" : "Fail")
+			  << '\t' << (startIndex == ExpectedTokens[i].start ? "OK" : "Fail")
+			  << '\t' << (stopIndex  == ExpectedTokens[i].stop ?  "OK" : "Fail")
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t009lexerTraits::InputStreamType* input	= new t009lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t009");
+	if (lxr == NULL)
+		lxr = new t009lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t009lexerTraits::CommonTokenType *token;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+
+	//except antlr3.MismatchedSetException as exc:
+	//   # TODO: This should provide more useful information
+	//   self.assertIsNone(exc.expecting)
+	//   self.assertEqual(exc.unexpectedType, 'a')
+	//   self.assertEqual(exc.charPositionInLine, 1)
+	//   self.assertEqual(exc.line, 1)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t009lexer.g b/runtime/Cpp/tests/t009lexer.g
new file mode 100644
index 0000000..928f97b
--- /dev/null
+++ b/runtime/Cpp/tests/t009lexer.g
@@ -0,0 +1,13 @@
+lexer grammar t009lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+DIGIT: '0' .. '9';
diff --git a/runtime/Cpp/tests/t010.cpp b/runtime/Cpp/tests/t010.cpp
new file mode 100644
index 0000000..0b9fca7
--- /dev/null
+++ b/runtime/Cpp/tests/t010.cpp
@@ -0,0 +1,111 @@
+#include "UserTestTraits.hpp"
+#include "t010lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput(string const& data);
+
+static t010lexer *lxr;
+
+struct TokenData
+{
+	t010lexerTokens::Tokens type;
+	unsigned start;
+	unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	// "foobar _Ab98 \n A12sdf"
+	{ t010lexerTokens::IDENTIFIER,  0,   5, "foobar"},
+	{ t010lexerTokens::WS,          6,   6, " "},
+	{ t010lexerTokens::IDENTIFIER,  7,  11, "_Ab98"},
+	{ t010lexerTokens::WS,         12, 14, " \n "},
+	{ t010lexerTokens::IDENTIFIER, 15, 20, "A12sdf"},
+	{ t010lexerTokens::EOF_TOKEN,  21, 21, "<EOF>"}
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("foobar _Ab98 \n A12sdf");
+	testMalformedInput("a-b");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t010lexerTraits::InputStreamType* input	= new t010lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t010");
+	if (lxr == NULL)
+		lxr = new t010lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	std::cout << "Text:"  << '\t'
+		  << "Type:"  << '\t'
+		  << "Start:" << '\t'
+		  << "Stop:"  << '\t'
+		  << "Text:"  << '\t' << std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t010lexerTraits::CommonTokenType *token = lxr->nextToken();
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getType()       == ExpectedTokens[i].type ?  "OK" : "Fail")
+			  << '\t' << (startIndex == ExpectedTokens[i].start ? "OK" : "Fail")
+			  << '\t' << (stopIndex  == ExpectedTokens[i].stop ?  "OK" : "Fail")
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t010lexerTraits::InputStreamType* input	= new t010lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t010");
+	if (lxr == NULL)
+		lxr = new t010lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t010lexerTraits::CommonTokenType *token;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+
+	//except antlr3.NoViableAltException as exc:
+	//    self.assertEqual(exc.unexpectedType, '-')
+	//    self.assertEqual(exc.charPositionInLine, 1)
+	//    self.assertEqual(exc.line, 1)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t010lexer.g b/runtime/Cpp/tests/t010lexer.g
new file mode 100644
index 0000000..bb5a53e
--- /dev/null
+++ b/runtime/Cpp/tests/t010lexer.g
@@ -0,0 +1,14 @@
+lexer grammar t010lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+IDENTIFIER: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*;
+WS: (' ' | '\n')+;
diff --git a/runtime/Cpp/tests/t011.cpp b/runtime/Cpp/tests/t011.cpp
new file mode 100644
index 0000000..d8e40c7
--- /dev/null
+++ b/runtime/Cpp/tests/t011.cpp
@@ -0,0 +1,113 @@
+#include "UserTestTraits.hpp"
+#include "t011lexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput(string const& data);
+
+static t011lexer *lxr;
+
+struct TokenData
+{
+	t011lexerTokens::Tokens type;
+	unsigned start;
+	unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+	// "foobar _Ab98 \n A12sdf"
+	{ t011lexerTokens::IDENTIFIER,  0,   5, "foobar"},
+	{ t011lexerTokens::WS,          6,   6, " "},
+	{ t011lexerTokens::IDENTIFIER,  7,  11, "_Ab98"},
+	{ t011lexerTokens::WS,         12, 14, " \n "},
+	{ t011lexerTokens::IDENTIFIER, 15, 20, "A12sdf"},
+	{ t011lexerTokens::EOF_TOKEN,  21, 21, "<EOF>"}
+};
+
+int main (int argc, char *argv[])
+{
+	testValid("foobar _Ab98 \n A12sdf");
+	testMalformedInput("a-b");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t011lexerTraits::InputStreamType* input	= new t011lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t011");
+	if (lxr == NULL)
+		lxr = new t011lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	std::cout << "Text:"  << '\t'
+		  << "Type:"  << '\t'
+		  << "Start:" << '\t'
+		  << "Stop:"  << '\t'
+		  << "Text:"  << '\t' << std::endl;
+
+	for(unsigned i = 0; i < sizeof(ExpectedTokens)/sizeof(TokenData) ; i++)
+	{
+		// nextToken does not allocate any new Token instance(the same instance is returned again and again)
+		t011lexerTraits::CommonTokenType *token = lxr->nextToken();
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getType()       == ExpectedTokens[i].type ?  "OK" : "Fail")
+			  << '\t' << (startIndex == ExpectedTokens[i].start ? "OK" : "Fail")
+			  << '\t' << (stopIndex  == ExpectedTokens[i].stop ?  "OK" : "Fail")
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput(string const& data)
+{
+	t011lexerTraits::InputStreamType* input	= new t011lexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t011");
+	if (lxr == NULL)
+		lxr = new t011lexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput: \"" << data << '"' <<std::endl;
+
+	t011lexerTraits::CommonTokenType *token;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+
+	//except antlr3.NoViableAltException as exc:
+	//    self.assertEqual(exc.unexpectedType, '-')
+	//    self.assertEqual(exc.charPositionInLine, 1)
+	//    self.assertEqual(exc.line, 1)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
diff --git a/runtime/Cpp/tests/t011lexer.g b/runtime/Cpp/tests/t011lexer.g
new file mode 100644
index 0000000..06a8704
--- /dev/null
+++ b/runtime/Cpp/tests/t011lexer.g
@@ -0,0 +1,27 @@
+lexer grammar t011lexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+#include <iostream>
+}
+@lexer::namespace
+{ Antlr3Test }
+
+IDENTIFIER:
+        ('a'..'z'|'A'..'Z'|'_')
+        ('a'..'z'
+        |'A'..'Z'
+        |'0'..'9'
+        |'_'
+            {
+              std::cout << "Underscore";
+              std::cout << "foo";
+            }
+        )*
+    ;
+
+WS: (' ' | '\n')+;
diff --git a/runtime/Cpp/tests/t012.cpp b/runtime/Cpp/tests/t012.cpp
new file mode 100644
index 0000000..fe9d0c9
--- /dev/null
+++ b/runtime/Cpp/tests/t012.cpp
@@ -0,0 +1,187 @@
+#include "UserTestTraits.hpp"
+#include "t012lexerXMLLexer.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& in, string const& out);
+int testMalformedInput1(string const& data);
+int testMalformedInput2(string const& data);
+int testMalformedInput3(string const& data);
+string slurp(string const& fileName);
+
+static t012lexerXMLLexer *lxr;
+
+int main (int argc, char *argv[])
+{
+	testValid("t012lexerXML.input", "t012lexerXML.output");
+	testMalformedInput1("<?xml version='1.0'?>\n<document d>\n</document>\n");
+	testMalformedInput2("<?tml version='1.0'?>\n<document>\n</document>\n");
+	testMalformedInput3("<?xml version='1.0'?>\n<docu ment attr=\"foo\">\n</document>\n");
+
+	return 0;
+}
+
+int testValid(string const& inFilename, string const& outFilename)
+{
+	string data = slurp(inFilename);
+	t012lexerXMLLexerTraits::InputStreamType* input	= new t012lexerXMLLexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+											   (ANTLR_UINT8*)inFilename.c_str());
+	if (lxr == NULL)
+		lxr = new t012lexerXMLLexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << inFilename << '"' <<std::endl;
+	for(;;)
+	{
+		t012lexerXMLLexerTraits::CommonTokenType *token = lxr->nextToken();
+		if( token->getType() == t012lexerXMLLexerTokens::EOF_TOKEN)
+			break;
+	}
+
+	string expOutput = slurp(outFilename);
+	string lxrOutput = lxr->outbuf.str();
+
+	ofstream out("t012.lxr.output");
+	out << lxrOutput;
+
+	std::cout << inFilename << '\t' << (expOutput == lxrOutput ?  "OK" : "Fail") << std::endl;
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput1(string const& data)
+{
+	t012lexerXMLLexerTraits::InputStreamType* input	= new t012lexerXMLLexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t012");
+	if (lxr == NULL)
+		lxr = new t012lexerXMLLexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput1: \"" << data << '"' <<std::endl;
+
+	t012lexerXMLLexerTraits::CommonTokenType *token;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+
+        // try:
+        //     while True:
+        //         token = lexer.nextToken()
+        //         # Should raise NoViableAltException before hitting EOF
+        //         if token.type == antlr3.EOF:
+        //             self.fail()
+	//
+        // except antlr3.NoViableAltException as exc:
+        //     self.assertEqual(exc.unexpectedType, '>')
+        //     self.assertEqual(exc.charPositionInLine, 11)
+        //     self.assertEqual(exc.line, 2)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput2(string const& data)
+{
+	t012lexerXMLLexerTraits::InputStreamType* input	= new t012lexerXMLLexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t012");
+	if (lxr == NULL)
+		lxr = new t012lexerXMLLexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput2: \"" << data << '"' <<std::endl;
+
+	t012lexerXMLLexerTraits::CommonTokenType *token;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+
+        // try:
+        //     while True:
+        //         token = lexer.nextToken()
+        //         # Should raise NoViableAltException before hitting EOF
+        //         if token.type == antlr3.EOF:
+        //             self.fail()
+	//
+        // except antlr3.MismatchedSetException as exc:
+        //     self.assertEqual(exc.unexpectedType, 't')
+        //     self.assertEqual(exc.charPositionInLine, 2)
+        //     self.assertEqual(exc.line, 1)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+int testMalformedInput3(string const& data)
+{
+	t012lexerXMLLexerTraits::InputStreamType* input	= new t012lexerXMLLexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t012");
+	if (lxr == NULL)
+		lxr = new t012lexerXMLLexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testMalformedInput3: \"" << data << '"' <<std::endl;
+
+	t012lexerXMLLexerTraits::CommonTokenType *token;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+	token = lxr->nextToken();
+	std::cout << token->getText() << std::endl;
+
+        // try:
+        //     while True:
+        //         token = lexer.nextToken()
+        //         # Should raise NoViableAltException before hitting EOF
+        //         if token.type == antlr3.EOF:
+        //             self.fail()
+	//
+        // except antlr3.NoViableAltException as exc:
+        //     self.assertEqual(exc.unexpectedType, 'a')
+        //     self.assertEqual(exc.charPositionInLine, 11)
+        //     self.assertEqual(exc.line, 2)
+
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+string slurp(string const& fileName)
+{
+	ifstream ifs(fileName.c_str(), ios::in | ios::binary | ios::ate);
+	ifstream::pos_type fileSize = ifs.tellg();
+	ifs.seekg(0, ios::beg);
+
+	stringstream sstr;
+	sstr << ifs.rdbuf();
+	return sstr.str();
+}
diff --git a/runtime/Cpp/tests/t012lexerXML.input b/runtime/Cpp/tests/t012lexerXML.input
new file mode 100644
index 0000000..1815a9f
--- /dev/null
+++ b/runtime/Cpp/tests/t012lexerXML.input
@@ -0,0 +1,21 @@
+<?xml version='1.0'?>
+<!DOCTYPE component [
+<!ELEMENT component (PCDATA|sub)*>
+<!ATTLIST component
+          attr CDATA #IMPLIED
+          attr2 CDATA #IMPLIED
+>
+<!ELMENT sub EMPTY>
+
+]>
+<component attr="val'ue" attr2='val"ue'>
+<!-- This is a comment -->
+Text
+<![CDATA[huhu]]>
+öäüß
+&amp;
+&lt;
+<?xtal cursor='11'?>
+<sub/>
+<sub></sub>
+</component>
\ No newline at end of file
diff --git a/runtime/Cpp/tests/t012lexerXML.output b/runtime/Cpp/tests/t012lexerXML.output
new file mode 100644
index 0000000..825c37f
--- /dev/null
+++ b/runtime/Cpp/tests/t012lexerXML.output
@@ -0,0 +1,39 @@
+XML declaration
+Attr: version='1.0'
+ROOTELEMENT: component
+INTERNAL DTD: [
+<!ELEMENT component (PCDATA|sub)*>
+<!ATTLIST component
+          attr CDATA #IMPLIED
+          attr2 CDATA #IMPLIED
+>
+<!ELMENT sub EMPTY>
+
+]
+Start Tag: component
+Attr: attr="val'ue"
+Attr: attr2='val"ue'
+PCDATA: "
+"
+Comment: "<!-- This is a comment -->"
+PCDATA: "
+Text
+"
+CDATA: "<![CDATA[huhu]]>"
+PCDATA: "
+öäüß
+&amp;
+&lt;
+"
+PI: xtal
+Attr: cursor='11'
+PCDATA: "
+"
+Empty Element: sub
+PCDATA: "
+"
+Start Tag: sub
+End Tag: sub
+PCDATA: "
+"
+End Tag: component
diff --git a/runtime/Cpp/tests/t012lexerXMLLexer.g b/runtime/Cpp/tests/t012lexerXMLLexer.g
new file mode 100644
index 0000000..04e3e81
--- /dev/null
+++ b/runtime/Cpp/tests/t012lexerXMLLexer.g
@@ -0,0 +1,160 @@
+lexer grammar t012lexerXMLLexer;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+#include <iostream>
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@lexer::init {
+self.outbuf = StringIO()
+}
+
+@lexer::context {
+ImplTraits::StringStreamType outbuf;
+
+void output(const char* line)
+{
+    outbuf << line << "\r\n";
+}
+
+void output(const char* line1, const char *line2)
+{
+    outbuf << line1 << line2 << "\r\n";
+}
+
+void output(const char* line1, ImplTraits::StringType const& line2)
+{
+    outbuf << line1 << line2 << "\r\n";
+}
+
+void appendArribute(const char* prefix, ImplTraits::StringType const& name, ImplTraits::StringType const& value)
+{
+    outbuf << prefix << name << '=' << value << "\r\n";
+}
+
+void appendString(const char* name, ImplTraits::StringType const& value)
+{
+    outbuf << name << '"' << value << '"' << "\r\n";
+}
+
+}
+DOCUMENT
+    :  XMLDECL? WS? DOCTYPE? WS? ELEMENT WS?
+    ;
+
+fragment DOCTYPE
+    :
+        '<!DOCTYPE' WS rootElementName=GENERIC_ID
+        { output("ROOTELEMENT: ", $rootElementName.text);}
+        WS
+        (
+            ( 'SYSTEM' WS sys1=VALUE
+                {output("SYSTEM: ", $sys1.text);}
+
+            | 'PUBLIC' WS pub=VALUE WS sys2=VALUE
+                {output("PUBLIC: ", $pub.text);}
+                {output("SYSTEM: ", $sys2.text);}
+            )
+            ( WS )?
+        )?
+        ( dtd=INTERNAL_DTD
+            {output("INTERNAL DTD: ", $dtd.text);}
+        )?
+		'>'
+	;
+
+fragment INTERNAL_DTD : '[' (options {greedy=false;} : .)* ']' ;
+
+fragment PI :
+        '<?' target=GENERIC_ID WS?
+          {output("PI: ", $target.text);}
+        ( ATTRIBUTE WS? )*  '?>'
+	;
+
+fragment XMLDECL :
+        '<?' ('x'|'X') ('m'|'M') ('l'|'L') WS?
+          {output("XML declaration");}
+        ( ATTRIBUTE WS? )*  '?>'
+	;
+
+
+fragment ELEMENT
+    : ( START_TAG
+            (ELEMENT
+            | t=PCDATA
+                {appendString("PCDATA: ", $t.text);}
+            | t=CDATA
+                {appendString("CDATA: ", $t.text);}
+            | t=COMMENT
+                {appendString("Comment: ", $t.text);}
+            | pi=PI
+            )*
+            END_TAG
+        | EMPTY_ELEMENT
+        )
+    ;
+
+fragment START_TAG
+    : '<' WS? name=GENERIC_ID WS?
+          {output("Start Tag: ", $name.text);}
+        ( ATTRIBUTE WS? )* '>'
+    ;
+
+fragment EMPTY_ELEMENT
+    : '<' WS? name=GENERIC_ID WS?
+          {output("Empty Element: ", $name.text);}
+        ( ATTRIBUTE WS? )* '/>'
+    ;
+
+fragment ATTRIBUTE
+    : name=GENERIC_ID WS? '=' WS? value=VALUE
+        {appendArribute("Attr: ", $name.text, $value.text);}
+    ;
+
+fragment END_TAG
+    : '</' WS? name=GENERIC_ID WS? '>'
+        {output("End Tag: ", $name.text);}
+    ;
+
+fragment COMMENT
+	:	'<!--' (options {greedy=false;} : .)* '-->'
+	;
+
+fragment CDATA
+	:	'<![CDATA[' (options {greedy=false;} : .)* ']]>'
+	;
+
+fragment PCDATA : (~'<')+ ;
+
+fragment VALUE :
+        ( '\"' (~'\"')* '\"'
+        | '\'' (~'\'')* '\''
+        )
+	;
+
+fragment GENERIC_ID
+    : ( LETTER | '_' | ':')
+        ( options {greedy=true;} : LETTER | '0'..'9' | '.' | '-' | '_' | ':' )*
+	;
+
+fragment LETTER
+	: 'a'..'z'
+	| 'A'..'Z'
+	;
+
+fragment WS  :
+        (   ' '
+        |   '\t'
+        |  ( '\n'
+            |	'\r\n'
+            |	'\r'
+            )
+        )+
+    ;
+
diff --git a/runtime/Cpp/tests/t013parser.g b/runtime/Cpp/tests/t013parser.g
new file mode 100644
index 0000000..c962132
--- /dev/null
+++ b/runtime/Cpp/tests/t013parser.g
@@ -0,0 +1,36 @@
+grammar t013parser;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@parser::init {
+self.identifiers = []
+self.reportedErrors = []
+}
+
+@parser::members {
+def foundIdentifier(self, name):
+    self.identifiers.append(name)
+
+def emitErrorMessage(self, msg):
+    self.reportedErrors.append(msg)
+}
+
+document:
+        t=IDENTIFIER {self.foundIdentifier($t.text)}
+        ;
+
+IDENTIFIER: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*;
diff --git a/runtime/Cpp/tests/t014parser.g b/runtime/Cpp/tests/t014parser.g
new file mode 100644
index 0000000..4fa5d1d
--- /dev/null
+++ b/runtime/Cpp/tests/t014parser.g
@@ -0,0 +1,48 @@
+grammar t014parser;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@parser::init {
+self.events = []
+self.reportedErrors = []
+}
+
+@parser::members {
+def emitErrorMessage(self, msg):
+    self.reportedErrors.append(msg)
+}
+
+
+document:
+        ( declaration
+        | call
+        )*
+        EOF
+    ;
+
+declaration:
+        'var' t=IDENTIFIER ';'
+        {self.events.append(('decl', $t.text))}
+    ;
+
+call:
+        t=IDENTIFIER '(' ')' ';'
+        {self.events.append(('call', $t.text))}
+    ;
+
+IDENTIFIER: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*;
+WS:  (' '|'\r'|'\t'|'\n') {$channel=HIDDEN;};
diff --git a/runtime/Cpp/tests/t015calc.g b/runtime/Cpp/tests/t015calc.g
new file mode 100644
index 0000000..5af908a
--- /dev/null
+++ b/runtime/Cpp/tests/t015calc.g
@@ -0,0 +1,67 @@
+grammar t015calc;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@header {
+import math
+}
+
+@parser::init {
+self.reportedErrors = []
+}
+
+@parser::members {
+def emitErrorMessage(self, msg):
+    self.reportedErrors.append(msg)
+}
+
+evaluate returns [result]: r=expression {result = r};
+
+expression returns [result]: r=mult (
+    '+' r2=mult {r += r2}
+  | '-' r2=mult {r -= r2}
+  )* {result = r};
+
+mult returns [result]: r=log (
+    '*' r2=log {r *= r2}
+  | '/' r2=log {r /= r2}
+//  | '%' r2=log {r %= r2}
+  )* {result = r};
+
+log returns [result]: 'ln' r=exp {result = math.log(r)}
+    | r=exp {result = r}
+    ;
+
+exp returns [result]: r=atom ('^' r2=atom {r = math.pow(r,r2)} )? {result = r}
+    ;
+
+atom returns [result]:
+    n=INTEGER {result = int($n.text)}
+  | n=DECIMAL {result = float($n.text)}
+  | '(' r=expression {result = r} ')'
+  | 'PI' {result = math.pi}
+  | 'E' {result = math.e}
+  ;
+
+INTEGER: DIGIT+;
+
+DECIMAL: DIGIT+ '.' DIGIT+;
+
+fragment
+DIGIT: '0'..'9';
+
+WS: (' ' | '\n' | '\t')+ {$channel = HIDDEN};
diff --git a/runtime/Cpp/tests/t016actions.g b/runtime/Cpp/tests/t016actions.g
new file mode 100644
index 0000000..ca2189a
--- /dev/null
+++ b/runtime/Cpp/tests/t016actions.g
@@ -0,0 +1,44 @@
+grammar t016actions;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+declaration returns [name]
+    :   functionHeader ';'
+        {$name = $functionHeader.name}
+    ;
+
+functionHeader returns [name]
+    :   type ID
+	{$name = $ID.text}
+    ;
+
+type
+    :   'int'
+    |   'char'
+    |   'void'
+    ;
+
+ID  :   ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*
+    ;
+
+WS  :   (   ' '
+        |   '\t'
+        |   '\r'
+        |   '\n'
+        )+
+        {$channel=HIDDEN}
+    ;
diff --git a/runtime/Cpp/tests/t017parser.g b/runtime/Cpp/tests/t017parser.g
new file mode 100644
index 0000000..cd251b9
--- /dev/null
+++ b/runtime/Cpp/tests/t017parser.g
@@ -0,0 +1,104 @@
+grammar t017parser;
+
+options {
+    language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+program
+    :   declaration+
+    ;
+
+declaration
+    :   variable
+    |   functionHeader ';'
+    |   functionHeader block
+    ;
+
+variable
+    :   type declarator ';'
+    ;
+
+declarator
+    :   ID
+    ;
+
+functionHeader
+    :   type ID '(' ( formalParameter ( ',' formalParameter )* )? ')'
+    ;
+
+formalParameter
+    :   type declarator
+    ;
+
+type
+    :   'int'
+    |   'char'
+    |   'void'
+    |   ID
+    ;
+
+block
+    :   '{'
+            variable*
+            stat*
+        '}'
+    ;
+
+stat: forStat
+    | expr ';'
+    | block
+    | assignStat ';'
+    | ';'
+    ;
+
+forStat
+    :   'for' '(' assignStat ';' expr ';' assignStat ')' block
+    ;
+
+assignStat
+    :   ID '=' expr
+    ;
+
+expr:   condExpr
+    ;
+
+condExpr
+    :   aexpr ( ('==' | '<') aexpr )?
+    ;
+
+aexpr
+    :   atom ( '+' atom )*
+    ;
+
+atom
+    : ID
+    | INT
+    | '(' expr ')'
+    ;
+
+ID  :   ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*
+    ;
+
+INT :	('0'..'9')+
+    ;
+
+WS  :   (   ' '
+        |   '\t'
+        |   '\r'
+        |   '\n'
+        )+
+        {$channel=HIDDEN}
+    ;
diff --git a/runtime/Cpp/tests/t018llstar.g b/runtime/Cpp/tests/t018llstar.g
new file mode 100644
index 0000000..e682d2c
--- /dev/null
+++ b/runtime/Cpp/tests/t018llstar.g
@@ -0,0 +1,124 @@
+grammar t018llstar;
+
+options {
+    language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@header {
+from io import StringIO
+}
+
+@init {
+self.output = StringIO()
+}
+
+program
+    :   declaration+
+    ;
+
+/** In this rule, the functionHeader left prefix on the last two
+ *  alternatives is not LL(k) for a fixed k.  However, it is
+ *  LL(*).  The LL(*) algorithm simply scans ahead until it sees
+ *  either the ';' or the '{' of the block and then it picks
+ *  the appropriate alternative.  Lookhead can be arbitrarily
+ *  long in theory, but is <=10 in most cases.  Works great.
+ *  Use ANTLRWorks to see the lookahead use (step by Location)
+ *  and look for blue tokens in the input window pane. :)
+ */
+declaration
+    :   variable
+    |   functionHeader ';'
+	{self.output.write($functionHeader.name+" is a declaration\n")}
+    |   functionHeader block
+	{self.output.write($functionHeader.name+" is a definition\n")}
+    ;
+
+variable
+    :   type declarator ';'
+    ;
+
+declarator
+    :   ID
+    ;
+
+functionHeader returns [name]
+    :   type ID '(' ( formalParameter ( ',' formalParameter )* )? ')'
+	{$name = $ID.text}
+    ;
+
+formalParameter
+    :   type declarator
+    ;
+
+type
+    :   'int'
+    |   'char'
+    |   'void'
+    |   ID
+    ;
+
+block
+    :   '{'
+            variable*
+            stat*
+        '}'
+    ;
+
+stat: forStat
+    | expr ';'
+    | block
+    | assignStat ';'
+    | ';'
+    ;
+
+forStat
+    :   'for' '(' assignStat ';' expr ';' assignStat ')' block
+    ;
+
+assignStat
+    :   ID '=' expr
+    ;
+
+expr:   condExpr
+    ;
+
+condExpr
+    :   aexpr ( ('==' | '<') aexpr )?
+    ;
+
+aexpr
+    :   atom ( '+' atom )*
+    ;
+
+atom
+    : ID
+    | INT
+    | '(' expr ')'
+    ;
+
+ID  :   ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*
+    ;
+
+INT :	('0'..'9')+
+    ;
+
+WS  :   (   ' '
+        |   '\t'
+        |   '\r'
+        |   '\n'
+        )+
+        {$channel=HIDDEN}
+    ;
diff --git a/runtime/Cpp/tests/t019lexer.g b/runtime/Cpp/tests/t019lexer.g
new file mode 100644
index 0000000..192f993
--- /dev/null
+++ b/runtime/Cpp/tests/t019lexer.g
@@ -0,0 +1,71 @@
+lexer grammar t019lexer;
+options {
+    language=Cpp;
+    filter=true;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+IMPORT
+	:	'import' WS name=QIDStar WS? ';'
+	;
+
+/** Avoids having "return foo;" match as a field */
+RETURN
+	:	'return' (options {greedy=false;}:.)* ';'
+	;
+
+CLASS
+	:	'class' WS name=ID WS? ('extends' WS QID WS?)?
+		('implements' WS QID WS? (',' WS? QID WS?)*)? '{'
+	;
+
+COMMENT
+    :   '/*' (options {greedy=false;} : . )* '*/'
+    ;
+
+STRING
+    :	'"' (options {greedy=false;}: ESC | .)* '"'
+	;
+
+CHAR
+	:	'\'' (options {greedy=false;}: ESC | .)* '\''
+	;
+
+WS  :   (' '|'\t'|'\n')+
+    ;
+
+fragment
+QID :	ID ('.' ID)*
+	;
+
+/** QID cannot see beyond end of token so using QID '.*'? somewhere won't
+ *  ever match since k=1 lookahead in the QID loop of '.' will make it loop.
+ *  I made this rule to compensate.
+ */
+fragment
+QIDStar
+	:	ID ('.' ID)* '.*'?
+	;
+
+fragment
+TYPE:   QID '[]'?
+    ;
+
+fragment
+ARG :   TYPE WS ID
+    ;
+
+fragment
+ID  :   ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
+    ;
+
+fragment
+ESC	:	'\\' ('"'|'\''|'\\')
+	;
+
diff --git a/runtime/Cpp/tests/t020fuzzyLexer.g b/runtime/Cpp/tests/t020fuzzyLexer.g
new file mode 100644
index 0000000..0fc913f
--- /dev/null
+++ b/runtime/Cpp/tests/t020fuzzyLexer.g
@@ -0,0 +1,103 @@
+lexer grammar t020fuzzyLexer;
+options {
+    language=Cpp;
+    filter=true;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@header {
+from io import StringIO
+}
+
+@init {
+self.output = StringIO()
+}
+
+IMPORT
+	:	'import' WS name=QIDStar WS? ';'
+	;
+
+/** Avoids having "return foo;" match as a field */
+RETURN
+	:	'return' (options {greedy=false;}:.)* ';'
+	;
+
+CLASS
+	:	'class' WS name=ID WS? ('extends' WS QID WS?)?
+		('implements' WS QID WS? (',' WS? QID WS?)*)? '{'
+        {self.output.write("found class "+$name.text+"\n")}
+	;
+
+METHOD
+    :   TYPE WS name=ID WS? '(' ( ARG WS? (',' WS? ARG WS?)* )? ')' WS?
+       ('throws' WS QID WS? (',' WS? QID WS?)*)? '{'
+        {self.output.write("found method "+$name.text+"\n");}
+    ;
+
+FIELD
+    :   TYPE WS name=ID '[]'? WS? (';'|'=')
+        {self.output.write("found var "+$name.text+"\n");}
+    ;
+
+STAT:	('if'|'while'|'switch'|'for') WS? '(' ;
+
+CALL
+    :   name=QID WS? '('
+        {self.output.write("found call "+$name.text+"\n");}
+    ;
+
+COMMENT
+    :   '/*' (options {greedy=false;} : . )* '*/'
+        {self.output.write("found comment "+self.getText()+"\n");}
+    ;
+
+SL_COMMENT
+    :   '//' (options {greedy=false;} : . )* '\n'
+        {self.output.write("found // comment "+self.getText()+"\n");}
+    ;
+
+STRING
+	:	'"' (options {greedy=false;}: ESC | .)* '"'
+	;
+
+CHAR
+	:	'\'' (options {greedy=false;}: ESC | .)* '\''
+	;
+
+WS  :   (' '|'\t'|'\n')+
+    ;
+
+fragment
+QID :	ID ('.' ID)*
+	;
+
+/** QID cannot see beyond end of token so using QID '.*'? somewhere won't
+ *  ever match since k=1 lookahead in the QID loop of '.' will make it loop.
+ *  I made this rule to compensate.
+ */
+fragment
+QIDStar
+	:	ID ('.' ID)* '.*'?
+	;
+
+fragment
+TYPE:   QID '[]'?
+    ;
+
+fragment
+ARG :   TYPE WS ID
+    ;
+
+fragment
+ID  :   ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
+    ;
+
+fragment
+ESC	:	'\\' ('"'|'\''|'\\')
+	;
diff --git a/runtime/Cpp/tests/t021hoist.g b/runtime/Cpp/tests/t021hoist.g
new file mode 100644
index 0000000..51201c1
--- /dev/null
+++ b/runtime/Cpp/tests/t021hoist.g
@@ -0,0 +1,50 @@
+grammar t021hoist;
+options {
+    language=Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+/* With this true, enum is seen as a keyword.  False, it's an identifier */
+@parser::init {
+self.enableEnum = False
+}
+
+stat returns [enumIs]
+    : identifier    {enumIs = "ID"}
+    | enumAsKeyword {enumIs = "keyword"}
+    ;
+
+identifier
+    : ID
+    | enumAsID
+    ;
+
+enumAsKeyword : {self.enableEnum}? 'enum' ;
+
+enumAsID : {not self.enableEnum}? 'enum' ;
+
+ID  :   ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*
+    ;
+
+INT :	('0'..'9')+
+    ;
+
+WS  :   (   ' '
+        |   '\t'
+        |   '\r'
+        |   '\n'
+        )+
+        {$channel=HIDDEN}
+    ;
diff --git a/runtime/Cpp/tests/t022scopes.g b/runtime/Cpp/tests/t022scopes.g
new file mode 100644
index 0000000..b7870c0
--- /dev/null
+++ b/runtime/Cpp/tests/t022scopes.g
@@ -0,0 +1,138 @@
+grammar t022scopes;
+
+options {
+    language=Cpp;
+}
+
+/* global scopes */
+scope aScope {
+names
+}
+
+@lexer::includes{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+a
+scope aScope;
+    :   {$aScope::names = [];} ID*
+    ;
+
+
+/* rule scopes, from the book, final beta, p.147 */
+
+b[v]
+scope {x}
+    : {$b::x = v;} b2
+    ;
+
+b2
+    : b3
+    ;
+
+b3
+    : {$b::x}?=> ID // only visible, if b was called with True
+    | NUM
+    ;
+
+
+/* rule scopes, from the book, final beta, p.148 */
+
+c returns [res]
+scope {
+    symbols
+}
+@init {
+    $c::symbols = set();
+}
+    : '{' c1* c2+ '}'
+        { $res = $c::symbols; }
+    ;
+
+c1
+    : 'int' ID {$c::symbols.add($ID.text)} ';'
+    ;
+
+c2
+    : ID '=' NUM ';'
+        {
+            if $ID.text not in $c::symbols:
+                raise RuntimeError($ID.text)
+        }
+    ;
+
+/* recursive rule scopes, from the book, final beta, p.150 */
+
+d returns [res]
+scope {
+    symbols
+}
+@init {
+    $d::symbols = set();
+}
+    : '{' d1* d2* '}'
+        { $res = $d::symbols; }
+    ;
+
+d1
+    : 'int' ID {$d::symbols.add($ID.text)} ';'
+    ;
+
+d2
+    : ID '=' NUM ';'
+        {
+            for s in reversed(range(len($d))):
+                if $ID.text in $d[s]::symbols:
+                    break
+            else:
+                raise RuntimeError($ID.text)
+        }
+    | d
+    ;
+
+/* recursive rule scopes, access bottom-most scope */
+
+e returns [res]
+scope {
+    a
+}
+@after {
+    $res = $e::a;
+}
+    : NUM { $e[0]::a = int($NUM.text); }
+    | '{' e '}'
+    ;
+
+
+/* recursive rule scopes, access with negative index */
+
+f returns [res]
+scope {
+    a
+}
+@after {
+    $res = $f::a;
+}
+    : NUM { $f[-2]::a = int($NUM.text); }
+    | '{' f '}'
+    ;
+
+
+/* tokens */
+
+ID  :   ('a'..'z')+
+    ;
+
+NUM :   ('0'..'9')+
+    ;
+
+WS  :   (' '|'\n'|'\r')+ {$channel=HIDDEN}
+    ;
diff --git a/runtime/Cpp/tests/t023scopes.g b/runtime/Cpp/tests/t023scopes.g
new file mode 100644
index 0000000..f5b89fb
--- /dev/null
+++ b/runtime/Cpp/tests/t023scopes.g
@@ -0,0 +1,31 @@
+grammar t023scopes;
+
+options {
+    language=Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+prog
+scope {
+name
+}
+    :   ID {$prog::name=$ID.text;}
+    ;
+
+ID  :   ('a'..'z')+
+    ;
+
+WS  :   (' '|'\n'|'\r')+ {$channel=HIDDEN}
+    ;
diff --git a/runtime/Cpp/tests/t024finally.g b/runtime/Cpp/tests/t024finally.g
new file mode 100644
index 0000000..2cbda0a
--- /dev/null
+++ b/runtime/Cpp/tests/t024finally.g
@@ -0,0 +1,32 @@
+grammar t024finally;
+
+options {
+    language=Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+prog returns [events]
+@init {events = []}
+@after {events.append('after')}
+    :   ID {raise RuntimeError}
+    ;
+    catch [RuntimeError] {events.append('catch')}
+    finally {events.append('finally')}
+
+ID  :   ('a'..'z')+
+    ;
+
+WS  :   (' '|'\n'|'\r')+ {$channel=HIDDEN}
+    ;
diff --git a/runtime/Cpp/tests/t025lexerRulePropertyRef.g b/runtime/Cpp/tests/t025lexerRulePropertyRef.g
new file mode 100644
index 0000000..3271dd4
--- /dev/null
+++ b/runtime/Cpp/tests/t025lexerRulePropertyRef.g
@@ -0,0 +1,25 @@
+lexer grammar t025lexerRulePropertyRef;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@lexer::init {
+self.properties = []
+}
+
+IDENTIFIER:
+        ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*
+        {
+self.properties.append(
+    ($text, $type, $line, $pos, $index, $channel, $start, $stop)
+)
+        }
+    ;
+WS: (' ' | '\n')+;
diff --git a/runtime/Cpp/tests/t026actions.g b/runtime/Cpp/tests/t026actions.g
new file mode 100644
index 0000000..d699c06
--- /dev/null
+++ b/runtime/Cpp/tests/t026actions.g
@@ -0,0 +1,52 @@
+grammar t026actions;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@lexer::init {
+    self.foobar = 'attribute;'
+}
+
+prog
+@init {
+    self.capture('init;')
+}
+@after {
+    self.capture('after;')
+}
+    :   IDENTIFIER EOF
+    ;
+    catch [ RecognitionException as exc ] {
+        self.capture('catch;')
+        raise
+    }
+    finally {
+        self.capture('finally;')
+    }
+
+
+IDENTIFIER
+    : ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*
+        {
+            # a comment
+          self.capture('action;')
+            self.capture('{!r} {!r} {!r} {!r} {!r} {!r} {!r} {!r};'.format($text, $type, $line, $pos, $index, $channel, $start, $stop))
+            if True:
+                self.capture(self.foobar)
+        }
+    ;
+
+WS: (' ' | '\n')+;
diff --git a/runtime/Cpp/tests/t027eof.g b/runtime/Cpp/tests/t027eof.g
new file mode 100644
index 0000000..6cf6d6a
--- /dev/null
+++ b/runtime/Cpp/tests/t027eof.g
@@ -0,0 +1,15 @@
+lexer grammar t027eof;
+
+options {
+    language=Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+END: EOF;
+SPACE: ' ';
diff --git a/runtime/Cpp/tests/t029synpredgate.g b/runtime/Cpp/tests/t029synpredgate.g
new file mode 100644
index 0000000..5a1a4ab
--- /dev/null
+++ b/runtime/Cpp/tests/t029synpredgate.g
@@ -0,0 +1,23 @@
+lexer grammar t029synpredgate;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+FOO
+    : ('ab')=> A
+    | ('ac')=> B
+    ;
+
+fragment
+A: 'a';
+
+fragment
+B: 'a';
+
diff --git a/runtime/Cpp/tests/t030specialStates.g b/runtime/Cpp/tests/t030specialStates.g
new file mode 100644
index 0000000..62d2dbf
--- /dev/null
+++ b/runtime/Cpp/tests/t030specialStates.g
@@ -0,0 +1,39 @@
+grammar t030specialStates;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@init {
+self.cond = True
+}
+
+@members {
+def recover(self, input, re):
+    # no error recovery yet, just crash!
+    raise re
+}
+
+r
+    : ( {self.cond}? NAME
+        | {not self.cond}? NAME WS+ NAME
+        )
+        ( WS+ NAME )?
+        EOF
+    ;
+
+NAME: ('a'..'z') ('a'..'z' | '0'..'9')+;
+NUMBER: ('0'..'9')+;
+WS: ' '+;
diff --git a/runtime/Cpp/tests/t031emptyAlt.g b/runtime/Cpp/tests/t031emptyAlt.g
new file mode 100644
index 0000000..23b32f3
--- /dev/null
+++ b/runtime/Cpp/tests/t031emptyAlt.g
@@ -0,0 +1,29 @@
+grammar t031emptyAlt;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+r
+    : NAME
+        ( {self.cond}?=> WS+ NAME
+        |
+        )
+        EOF
+    ;
+
+NAME: ('a'..'z') ('a'..'z' | '0'..'9')+;
+NUMBER: ('0'..'9')+;
+WS: ' '+;
diff --git a/runtime/Cpp/tests/t032subrulePredict.g b/runtime/Cpp/tests/t032subrulePredict.g
new file mode 100644
index 0000000..4b760e1
--- /dev/null
+++ b/runtime/Cpp/tests/t032subrulePredict.g
@@ -0,0 +1,21 @@
+grammar t032subrulePredict;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+a: 'BEGIN' b WS+ 'END';
+b: ( WS+ 'A' )+;
+WS: ' ';
diff --git a/runtime/Cpp/tests/t033backtracking.g b/runtime/Cpp/tests/t033backtracking.g
new file mode 100644
index 0000000..a5b233b
--- /dev/null
+++ b/runtime/Cpp/tests/t033backtracking.g
@@ -0,0 +1,528 @@
+grammar t033backtracking;
+options {
+    language=Cpp;
+    backtrack=true;
+    memoize=true;
+    k=2;
+}
+
+scope Symbols {
+	types;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@members {
+    def isTypeName(self, name):
+        for scope in reversed(self.Symbols_stack):
+            if name in scope.types:
+                return True
+
+        return False
+
+}
+
+translation_unit
+scope Symbols; // entire file is a scope
+@init {
+  $Symbols::types = set()
+}
+	: external_declaration+
+	;
+
+/** Either a function definition or any other kind of C decl/def.
+ *  The LL(*) analysis algorithm fails to deal with this due to
+ *  recursion in the declarator rules.  I'm putting in a
+ *  manual predicate here so that we don't backtrack over
+ *  the entire function.  Further, you get a better error
+ *  as errors within the function itself don't make it fail
+ *  to predict that it's a function.  Weird errors previously.
+ *  Remember: the goal is to avoid backtrack like the plague
+ *  because it makes debugging, actions, and errors harder.
+ *
+ *  Note that k=1 results in a much smaller predictor for the
+ *  fixed lookahead; k=2 made a few extra thousand lines. ;)
+ *  I'll have to optimize that in the future.
+ */
+external_declaration
+options {k=1;}
+	: ( declaration_specifiers? declarator declaration* '{' )=> function_definition
+	| declaration
+	;
+
+function_definition
+scope Symbols; // put parameters and locals into same scope for now
+@init {
+  $Symbols::types = set()
+}
+	:	declaration_specifiers? declarator
+// 		(	declaration+ compound_statement	// K&R style
+// 		|	compound_statement				// ANSI style
+// 		)
+	;
+
+declaration
+scope {
+  isTypedef;
+}
+@init {
+  $declaration::isTypedef = False
+}
+	: 'typedef' declaration_specifiers? {$declaration::isTypedef = True}
+	  init_declarator_list ';' // special case, looking for typedef
+	| declaration_specifiers init_declarator_list? ';'
+	;
+
+declaration_specifiers
+	:   (   storage_class_specifier
+		|   type_specifier
+        |   type_qualifier
+        )+
+	;
+
+init_declarator_list
+	: init_declarator (',' init_declarator)*
+	;
+
+init_declarator
+	: declarator //('=' initializer)?
+	;
+
+storage_class_specifier
+	: 'extern'
+	| 'static'
+	| 'auto'
+	| 'register'
+	;
+
+type_specifier
+	: 'void'
+	| 'char'
+	| 'short'
+	| 'int'
+	| 'long'
+	| 'float'
+	| 'double'
+	| 'signed'
+	| 'unsigned'
+// 	| struct_or_union_specifier
+// 	| enum_specifier
+	| type_id
+	;
+
+type_id
+    :   {self.isTypeName(self.input.LT(1).getText())}? IDENTIFIER
+//    	{System.out.println($IDENTIFIER.text+" is a type");}
+    ;
+
+// struct_or_union_specifier
+// options {k=3;}
+// scope Symbols; // structs are scopes
+// @init {
+//   $Symbols::types = set()
+// }
+// 	: struct_or_union IDENTIFIER? '{' struct_declaration_list '}'
+// 	| struct_or_union IDENTIFIER
+// 	;
+
+// struct_or_union
+// 	: 'struct'
+// 	| 'union'
+// 	;
+
+// struct_declaration_list
+// 	: struct_declaration+
+// 	;
+
+// struct_declaration
+// 	: specifier_qualifier_list struct_declarator_list ';'
+// 	;
+
+// specifier_qualifier_list
+// 	: ( type_qualifier | type_specifier )+
+// 	;
+
+// struct_declarator_list
+// 	: struct_declarator (',' struct_declarator)*
+// 	;
+
+// struct_declarator
+// 	: declarator (':' constant_expression)?
+// 	| ':' constant_expression
+// 	;
+
+// enum_specifier
+// options {k=3;}
+// 	: 'enum' '{' enumerator_list '}'
+// 	| 'enum' IDENTIFIER '{' enumerator_list '}'
+// 	| 'enum' IDENTIFIER
+// 	;
+
+// enumerator_list
+// 	: enumerator (',' enumerator)*
+// 	;
+
+// enumerator
+// 	: IDENTIFIER ('=' constant_expression)?
+// 	;
+
+type_qualifier
+	: 'const'
+	| 'volatile'
+	;
+
+declarator
+	: pointer? direct_declarator
+	| pointer
+	;
+
+direct_declarator
+	:   (	IDENTIFIER
+			{
+			if $declaration and $declaration::isTypedef:
+				$Symbols::types.add($IDENTIFIER.text)
+				print("define type "+$IDENTIFIER.text)
+			}
+		|	'(' declarator ')'
+		)
+        declarator_suffix*
+	;
+
+declarator_suffix
+	:   /*'[' constant_expression ']'
+    |*/   '[' ']'
+//     |   '(' parameter_type_list ')'
+//     |   '(' identifier_list ')'
+    |   '(' ')'
+	;
+
+pointer
+	: '*' type_qualifier+ pointer?
+	| '*' pointer
+	| '*'
+	;
+
+// parameter_type_list
+// 	: parameter_list (',' '...')?
+// 	;
+
+// parameter_list
+// 	: parameter_declaration (',' parameter_declaration)*
+// 	;
+
+// parameter_declaration
+// 	: declaration_specifiers (declarator|abstract_declarator)*
+// 	;
+
+// identifier_list
+// 	: IDENTIFIER (',' IDENTIFIER)*
+// 	;
+
+// type_name
+// 	: specifier_qualifier_list abstract_declarator?
+// 	;
+
+// abstract_declarator
+// 	: pointer direct_abstract_declarator?
+// 	| direct_abstract_declarator
+// 	;
+
+// direct_abstract_declarator
+// 	:	( '(' abstract_declarator ')' | abstract_declarator_suffix ) abstract_declarator_suffix*
+// 	;
+
+// abstract_declarator_suffix
+// 	:	'[' ']'
+// 	|	'[' constant_expression ']'
+// 	|	'(' ')'
+// 	|	'(' parameter_type_list ')'
+// 	;
+
+// initializer
+// 	: assignment_expression
+// 	| '{' initializer_list ','? '}'
+// 	;
+
+// initializer_list
+// 	: initializer (',' initializer)*
+// 	;
+
+// // E x p r e s s i o n s
+
+// argument_expression_list
+// 	:   assignment_expression (',' assignment_expression)*
+// 	;
+
+// additive_expression
+// 	: (multiplicative_expression) ('+' multiplicative_expression | '-' multiplicative_expression)*
+// 	;
+
+// multiplicative_expression
+// 	: (cast_expression) ('*' cast_expression | '/' cast_expression | '%' cast_expression)*
+// 	;
+
+// cast_expression
+// 	: '(' type_name ')' cast_expression
+// 	| unary_expression
+// 	;
+
+// unary_expression
+// 	: postfix_expression
+// 	| '++' unary_expression
+// 	| '--' unary_expression
+// 	| unary_operator cast_expression
+// 	| 'sizeof' unary_expression
+// 	| 'sizeof' '(' type_name ')'
+// 	;
+
+// postfix_expression
+// 	:   primary_expression
+//         (   '[' expression ']'
+//         |   '(' ')'
+//         |   '(' argument_expression_list ')'
+//         |   '.' IDENTIFIER
+//         |   '*' IDENTIFIER
+//         |   '->' IDENTIFIER
+//         |   '++'
+//         |   '--'
+//         )*
+// 	;
+
+// unary_operator
+// 	: '&'
+// 	| '*'
+// 	| '+'
+// 	| '-'
+// 	| '~'
+// 	| '!'
+// 	;
+
+// primary_expression
+// 	: IDENTIFIER
+// 	| constant
+// 	| '(' expression ')'
+// 	;
+
+// constant
+//     :   HEX_LITERAL
+//     |   OCTAL_LITERAL
+//     |   DECIMAL_LITERAL
+//     |	CHARACTER_LITERAL
+// 	|	STRING_LITERAL
+//     |   FLOATING_POINT_LITERAL
+//     ;
+
+// /////
+
+// expression
+// 	: assignment_expression (',' assignment_expression)*
+// 	;
+
+// constant_expression
+// 	: conditional_expression
+// 	;
+
+// assignment_expression
+// 	: lvalue assignment_operator assignment_expression
+// 	| conditional_expression
+// 	;
+
+// lvalue
+// 	:	unary_expression
+// 	;
+
+// assignment_operator
+// 	: '='
+// 	| '*='
+// 	| '/='
+// 	| '%='
+// 	| '+='
+// 	| '-='
+// 	| '<<='
+// 	| '>>='
+// 	| '&='
+// 	| '^='
+// 	| '|='
+// 	;
+
+// conditional_expression
+// 	: logical_or_expression ('?' expression ':' conditional_expression)?
+// 	;
+
+// logical_or_expression
+// 	: logical_and_expression ('||' logical_and_expression)*
+// 	;
+
+// logical_and_expression
+// 	: inclusive_or_expression ('&&' inclusive_or_expression)*
+// 	;
+
+// inclusive_or_expression
+// 	: exclusive_or_expression ('|' exclusive_or_expression)*
+// 	;
+
+// exclusive_or_expression
+// 	: and_expression ('^' and_expression)*
+// 	;
+
+// and_expression
+// 	: equality_expression ('&' equality_expression)*
+// 	;
+// equality_expression
+// 	: relational_expression (('=='|'!=') relational_expression)*
+// 	;
+
+// relational_expression
+// 	: shift_expression (('<'|'>'|'<='|'>=') shift_expression)*
+// 	;
+
+// shift_expression
+// 	: additive_expression (('<<'|'>>') additive_expression)*
+// 	;
+
+// // S t a t e m e n t s
+
+// statement
+// 	: labeled_statement
+// 	| compound_statement
+// 	| expression_statement
+// 	| selection_statement
+// 	| iteration_statement
+// 	| jump_statement
+// 	;
+
+// labeled_statement
+// 	: IDENTIFIER ':' statement
+// 	| 'case' constant_expression ':' statement
+// 	| 'default' ':' statement
+// 	;
+
+// compound_statement
+// scope Symbols; // blocks have a scope of symbols
+// @init {
+//   $Symbols::types = {}
+// }
+// 	: '{' declaration* statement_list? '}'
+// 	;
+
+// statement_list
+// 	: statement+
+// 	;
+
+// expression_statement
+// 	: ';'
+// 	| expression ';'
+// 	;
+
+// selection_statement
+// 	: 'if' '(' expression ')' statement (options {k=1; backtrack=false;}:'else' statement)?
+// 	| 'switch' '(' expression ')' statement
+// 	;
+
+// iteration_statement
+// 	: 'while' '(' expression ')' statement
+// 	| 'do' statement 'while' '(' expression ')' ';'
+// 	| 'for' '(' expression_statement expression_statement expression? ')' statement
+// 	;
+
+// jump_statement
+// 	: 'goto' IDENTIFIER ';'
+// 	| 'continue' ';'
+// 	| 'break' ';'
+// 	| 'return' ';'
+// 	| 'return' expression ';'
+// 	;
+
+IDENTIFIER
+	:	LETTER (LETTER|'0'..'9')*
+	;
+
+fragment
+LETTER
+	:	'$'
+	|	'A'..'Z'
+	|	'a'..'z'
+	|	'_'
+	;
+
+CHARACTER_LITERAL
+    :   '\'' ( EscapeSequence | ~('\''|'\\') ) '\''
+    ;
+
+STRING_LITERAL
+    :  '"' ( EscapeSequence | ~('\\'|'"') )* '"'
+    ;
+
+HEX_LITERAL : '0' ('x'|'X') HexDigit+ IntegerTypeSuffix? ;
+
+DECIMAL_LITERAL : ('0' | '1'..'9' '0'..'9'*) IntegerTypeSuffix? ;
+
+OCTAL_LITERAL : '0' ('0'..'7')+ IntegerTypeSuffix? ;
+
+fragment
+HexDigit : ('0'..'9'|'a'..'f'|'A'..'F') ;
+
+fragment
+IntegerTypeSuffix
+	:	('u'|'U')? ('l'|'L')
+	|	('u'|'U')  ('l'|'L')?
+	;
+
+FLOATING_POINT_LITERAL
+    :   ('0'..'9')+ '.' ('0'..'9')* Exponent? FloatTypeSuffix?
+    |   '.' ('0'..'9')+ Exponent? FloatTypeSuffix?
+    |   ('0'..'9')+ Exponent FloatTypeSuffix?
+    |   ('0'..'9')+ Exponent? FloatTypeSuffix
+	;
+
+fragment
+Exponent : ('e'|'E') ('+'|'-')? ('0'..'9')+ ;
+
+fragment
+FloatTypeSuffix : ('f'|'F'|'d'|'D') ;
+
+fragment
+EscapeSequence
+    :   '\\' ('b'|'t'|'n'|'f'|'r'|'\"'|'\''|'\\')
+    |   OctalEscape
+    ;
+
+fragment
+OctalEscape
+    :   '\\' ('0'..'3') ('0'..'7') ('0'..'7')
+    |   '\\' ('0'..'7') ('0'..'7')
+    |   '\\' ('0'..'7')
+    ;
+
+fragment
+UnicodeEscape
+    :   '\\' 'u' HexDigit HexDigit HexDigit HexDigit
+    ;
+
+WS  :  (' '|'\r'|'\t'|'\u000C'|'\n') {$channel=HIDDEN;}
+    ;
+
+COMMENT
+    :   '/*' ( options {greedy=false;} : . )* '*/' {$channel=HIDDEN;}
+    ;
+
+LINE_COMMENT
+    : '//' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;}
+    ;
+
+// ignore #line info for now
+LINE_COMMAND
+    : '#' ~('\n'|'\r')* '\r'? '\n' {$channel=HIDDEN;}
+    ;
+
diff --git a/runtime/Cpp/tests/t034tokenLabelPropertyRef.g b/runtime/Cpp/tests/t034tokenLabelPropertyRef.g
new file mode 100644
index 0000000..6a03bf2
--- /dev/null
+++ b/runtime/Cpp/tests/t034tokenLabelPropertyRef.g
@@ -0,0 +1,43 @@
+grammar t034tokenLabelPropertyRef;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+a: t=A
+        {
+            print($t.text)
+            print($t.type)
+            print($t.line)
+            print($t.pos)
+            print($t.channel)
+            print($t.index)
+            #print($t.tree)
+        }
+    ;
+
+A: 'a'..'z';
+
+WS  :
+        (   ' '
+        |   '\t'
+        |  ( '\n'
+            |	'\r\n'
+            |	'\r'
+            )
+        )+
+        { $channel = HIDDEN }
+    ;
+
diff --git a/runtime/Cpp/tests/t035ruleLabelPropertyRef.g b/runtime/Cpp/tests/t035ruleLabelPropertyRef.g
new file mode 100644
index 0000000..c3b9eb9
--- /dev/null
+++ b/runtime/Cpp/tests/t035ruleLabelPropertyRef.g
@@ -0,0 +1,29 @@
+grammar t035ruleLabelPropertyRef;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+a returns [bla]: t=b
+        {
+            $bla = $t.start, $t.stop, $t.text
+        }
+    ;
+
+b: A+;
+
+A: 'a'..'z';
+
+WS: ' '+  { $channel = HIDDEN };
diff --git a/runtime/Cpp/tests/t036multipleReturnValues.g b/runtime/Cpp/tests/t036multipleReturnValues.g
new file mode 100644
index 0000000..8c4748c
--- /dev/null
+++ b/runtime/Cpp/tests/t036multipleReturnValues.g
@@ -0,0 +1,38 @@
+grammar t036multipleReturnValues;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+a returns [foo, bar]: A
+        {
+            $foo = "foo";
+            $bar = "bar";
+        }
+    ;
+
+A: 'a'..'z';
+
+WS  :
+        (   ' '
+        |   '\t'
+        |  ( '\n'
+            |	'\r\n'
+            |	'\r'
+            )
+        )+
+        { $channel = HIDDEN }
+    ;
+
diff --git a/runtime/Cpp/tests/t037rulePropertyRef.g b/runtime/Cpp/tests/t037rulePropertyRef.g
new file mode 100644
index 0000000..b510092
--- /dev/null
+++ b/runtime/Cpp/tests/t037rulePropertyRef.g
@@ -0,0 +1,28 @@
+grammar t037rulePropertyRef;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+a returns [bla]
+@after {
+    $bla = $start, $stop, $text
+}
+    : A+
+    ;
+
+A: 'a'..'z';
+
+WS: ' '+  { $channel = HIDDEN };
diff --git a/runtime/Cpp/tests/t038lexerRuleLabel.g b/runtime/Cpp/tests/t038lexerRuleLabel.g
new file mode 100644
index 0000000..28dbedc
--- /dev/null
+++ b/runtime/Cpp/tests/t038lexerRuleLabel.g
@@ -0,0 +1,35 @@
+lexer grammar t038lexerRuleLabel;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+A: 'a'..'z' WS '0'..'9'
+        {
+            print($WS)
+            print($WS.type)
+            print($WS.line)
+            print($WS.pos)
+            print($WS.channel)
+            print($WS.index)
+            print($WS.text)
+        }
+    ;
+
+fragment WS  :
+        (   ' '
+        |   '\t'
+        |  ( '\n'
+            |	'\r\n'
+            |	'\r'
+            )
+        )+
+        { $channel = HIDDEN }
+    ;
+
diff --git a/runtime/Cpp/tests/t039.cpp b/runtime/Cpp/tests/t039.cpp
new file mode 100644
index 0000000..f87ea87
--- /dev/null
+++ b/runtime/Cpp/tests/t039.cpp
@@ -0,0 +1,122 @@
+#include "UserTestTraits.hpp"
+#include "t039labelsLexer.hpp"
+#include "t039labelsParser.hpp"
+
+#include <sys/types.h>
+
+#include <iostream>
+#include <sstream>
+#include <fstream>
+
+using namespace Antlr3Test;
+using namespace std;
+
+int testValid(string const& data);
+int testMalformedInput(string const& data);
+
+static t039labelsLexer *lxr;
+
+
+struct TokenData
+{
+	//t039labelsLexerTokens::Tokens type;
+	//unsigned start;
+	//unsigned stop;
+	const char* text;
+};
+
+static TokenData ExpectedTokens[] =
+{
+  /*
+        lexer = self.getLexer(cStream)
+        tStream = antlr3.CommonTokenStream(lexer)
+        parser = self.getParser(tStream)
+        ids, w = parser.a()
+
+        self.assertEqual(len(ids), 6, ids)
+        self.assertEqual(ids[0].text, 'a', ids[0])
+        self.assertEqual(ids[1].text, 'b', ids[1])
+        self.assertEqual(ids[2].text, 'c', ids[2])
+        self.assertEqual(ids[3].text, '1', ids[3])
+        self.assertEqual(ids[4].text, '2', ids[4])
+        self.assertEqual(ids[5].text, 'A', ids[5])
+
+        self.assertEqual(w.text, 'GNU1', w)
+  */
+	// "a, b, c, 1, 2 A FOOBAR GNU1 A BLARZ"
+	{ "a"},
+	{ "b"},
+	{ "c"},
+	{ "1"},
+	{ "2"},
+	{ "A"},
+};
+
+
+int main (int argc, char *argv[])
+{
+	testValid("a, b, c, 1, 2 A FOOBAR GNU1 A BLARZ");
+	return 0;
+}
+
+int testValid(string const& data)
+{
+	t039labelsLexerTraits::InputStreamType* input	= new t039labelsLexerTraits::InputStreamType((const ANTLR_UINT8 *)data.c_str(),
+										       ANTLR_ENC_8BIT,
+										       data.length(), //strlen(data.c_str()),
+										       (ANTLR_UINT8*)"t039");
+	if (lxr == NULL)
+		lxr = new t039labelsLexer(input);
+	else
+		lxr->setCharStream(input);
+
+	std::cout << "testValid: \"" << data << '"' <<std::endl;
+
+	t039labelsLexerTraits::TokenStreamType *tstream = new t039labelsLexerTraits::TokenStreamType(ANTLR_SIZE_HINT, lxr->get_tokSource());
+	t039labelsParser *psr = new t039labelsParser(tstream);
+	t039labelsParser::TokenList r = psr->a();
+
+	for(unsigned i = 0; i < r.tokens.size() ; i++)
+	{
+		t039labelsLexerTraits::CommonTokenType *token = r.tokens.at(i);
+
+		size_t startIndex = ((const char*)token->get_startIndex()) - data.c_str();
+		size_t stopIndex = ((const char*)token->get_stopIndex()) - data.c_str();
+
+		std::cout << token->getText()
+			  << '\t' << (token->getText()       == ExpectedTokens[i].text ?  "OK" : "Fail")
+			  << std::endl;
+
+	}
+	delete lxr; lxr = NULL;
+	delete input;
+	return 0;
+}
+
+/*
+    def testValid1(self):
+        cStream = antlr3.StringStream(
+            'a, b, c, 1, 2 A FOOBAR GNU1 A BLARZ'
+            )
+
+        lexer = self.getLexer(cStream)
+        tStream = antlr3.CommonTokenStream(lexer)
+        parser = self.getParser(tStream)
+        ids, w = parser.a()
+
+        self.assertEqual(len(ids), 6, ids)
+        self.assertEqual(ids[0].text, 'a', ids[0])
+        self.assertEqual(ids[1].text, 'b', ids[1])
+        self.assertEqual(ids[2].text, 'c', ids[2])
+        self.assertEqual(ids[3].text, '1', ids[3])
+        self.assertEqual(ids[4].text, '2', ids[4])
+        self.assertEqual(ids[5].text, 'A', ids[5])
+
+        self.assertEqual(w.text, 'GNU1', w)
+
+
+if __name__ == '__main__':
+    unittest.main()
+
+
+*/
diff --git a/runtime/Cpp/tests/t039labels.g b/runtime/Cpp/tests/t039labels.g
new file mode 100644
index 0000000..dc24366
--- /dev/null
+++ b/runtime/Cpp/tests/t039labels.g
@@ -0,0 +1,43 @@
+grammar t039labels;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+#include <iostream>
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+#include "t039labelsLexer.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+@parser::members {
+	class TokenList {
+	public:
+        TokenList() : token() {}
+        TokenList(TokenList const& other) : tokens(other.tokens), token(other.token) {}
+        TokenList(ImplTraits::TokenPtrsListType const& lst, ImplTraits::CommonTokenType *t) : tokens(lst), token(t) {}
+	//private:
+        ImplTraits::TokenPtrsListType tokens;
+        ImplTraits::CommonTokenType* token;
+    };
+}
+a returns [t039labelsParser::TokenList retval]
+    : ids+=A ( ',' ids+=(A|B) )* C D w=. ids+=. F EOF
+        { retval = t039labelsParser::TokenList($ids, $w); }
+    ;
+
+A: 'a'..'z';
+B: '0'..'9';
+C: a='A'         { std::cout << $a << std::endl; };
+D: a='FOOBAR'    { std::cout << $a << std::endl; };
+E: 'GNU' a=.     { std::cout << $a << std::endl; };
+F: 'BLARZ' a=EOF { std::cout << $a << std::endl; };
+
+WS: ' '+  { $channel = HIDDEN; };
diff --git a/runtime/Cpp/tests/t040bug80.g b/runtime/Cpp/tests/t040bug80.g
new file mode 100644
index 0000000..3aa55d0
--- /dev/null
+++ b/runtime/Cpp/tests/t040bug80.g
@@ -0,0 +1,20 @@
+lexer grammar t040bug80;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+ID_LIKE
+    : 'defined'
+    | {False}? Identifier
+    | Identifier
+    ;
+
+fragment
+Identifier: 'a'..'z'+ ; // with just 'a', output compiles
diff --git a/runtime/Cpp/tests/t041parameters.g b/runtime/Cpp/tests/t041parameters.g
new file mode 100644
index 0000000..47b64b7
--- /dev/null
+++ b/runtime/Cpp/tests/t041parameters.g
@@ -0,0 +1,29 @@
+grammar t041parameters;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+a[arg1, arg2] returns [l]
+    : A+ EOF
+        {
+            l = ($arg1, $arg2)
+            $arg1 = "gnarz"
+        }
+    ;
+
+A: 'a'..'z';
+
+WS: ' '+  { $channel = HIDDEN };
diff --git a/runtime/Cpp/tests/t042ast.g b/runtime/Cpp/tests/t042ast.g
new file mode 100644
index 0000000..e2d4fc1
--- /dev/null
+++ b/runtime/Cpp/tests/t042ast.g
@@ -0,0 +1,366 @@
+grammar t042ast;
+options {
+    language =Cpp;
+    output = AST;
+}
+
+tokens {
+    VARDEF;
+    FLOAT;
+    EXPR;
+    BLOCK;
+    VARIABLE;
+    FIELD;
+    CALL;
+    INDEX;
+    FIELDACCESS;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@init {
+self.flag = False
+}
+
+r1
+    : INT ('+'^ INT)*
+    ;
+
+r2
+    : 'assert'^ x=expression (':'! y=expression)? ';'!
+    ;
+
+r3
+    : 'if'^ expression s1=statement ('else'! s2=statement)?
+    ;
+
+r4
+    : 'while'^ expression statement
+    ;
+
+r5
+    : 'return'^ expression? ';'!
+    ;
+
+r6
+    : (INT|ID)+
+    ;
+
+r7
+    : INT ->
+    ;
+
+r8
+    : 'var' ID ':' type -> ^('var' type ID)
+    ;
+
+r9
+    : type ID ';' -> ^(VARDEF type ID)
+    ;
+
+r10
+    : INT -> {CommonTree(CommonToken(type=FLOAT, text=$INT.text + ".0"))}
+    ;
+
+r11
+    : expression -> ^(EXPR expression)
+    | -> EXPR
+    ;
+
+r12
+    : ID (',' ID)* -> ID+
+    ;
+
+r13
+    : type ID (',' ID)* ';' -> ^(type ID+)
+    ;
+
+r14
+    :   expression? statement* type+
+        -> ^(EXPR expression? statement* type+)
+    ;
+
+r15
+    : INT -> INT INT
+    ;
+
+r16
+    : 'int' ID (',' ID)* -> ^('int' ID)+
+    ;
+
+r17
+    : 'for' '(' start=statement ';' expression ';' next=statement ')' statement
+        -> ^('for' $start expression $next statement)
+    ;
+
+r18
+    : t='for' -> ^(BLOCK)
+    ;
+
+r19
+    : t='for' -> ^(BLOCK[$t])
+    ;
+
+r20
+    : t='for' -> ^(BLOCK[$t,"FOR"])
+    ;
+
+r21
+    : t='for' -> BLOCK
+    ;
+
+r22
+    : t='for' -> BLOCK[$t]
+    ;
+
+r23
+    : t='for' -> BLOCK[$t,"FOR"]
+    ;
+
+r24
+    : r=statement expression -> ^($r expression)
+    ;
+
+r25
+    : r+=statement (',' r+=statement)+ expression -> ^($r expression)
+    ;
+
+r26
+    : r+=statement (',' r+=statement)+ -> ^(BLOCK $r+)
+    ;
+
+r27
+    : r=statement expression -> ^($r ^($r expression))
+    ;
+
+r28
+    : ('foo28a'|'foo28b') ->
+    ;
+
+r29
+    : (r+=statement)* -> ^(BLOCK $r+)
+    ;
+
+r30
+    : statement* -> ^(BLOCK statement?)
+    ;
+
+r31
+    : modifier type ID ('=' expression)? ';'
+        -> {self.flag == 0}? ^(VARDEF ID modifier* type expression?)
+        -> {self.flag == 1}? ^(VARIABLE ID modifier* type expression?)
+        ->                   ^(FIELD ID modifier* type expression?)
+    ;
+
+r32[which]
+  : ID INT -> {which==1}? ID
+           -> {which==2}? INT
+           -> // yield nothing as else-clause
+  ;
+
+r33
+    :   modifiers! statement
+    ;
+
+r34
+    :   modifiers! r34a[$modifiers.tree]
+    //|   modifiers! r33b[$modifiers.tree]
+    ;
+
+r34a[mod]
+    :   'class' ID ('extends' sup=type)?
+        ( 'implements' i+=type (',' i+=type)*)?
+        '{' statement* '}'
+        -> ^('class' ID {$mod} ^('extends' $sup)? ^('implements' $i+)? statement* )
+    ;
+
+r35
+    : '{' 'extends' (sup=type)? '}'
+        ->  ^('extends' $sup)?
+    ;
+
+r36
+    : 'if' '(' expression ')' s1=statement
+        ( 'else' s2=statement -> ^('if' ^(EXPR expression) $s1 $s2)
+        |                     -> ^('if' ^(EXPR expression) $s1)
+        )
+    ;
+
+r37
+    : (INT -> INT) ('+' i=INT -> ^('+' $r37 $i) )*
+    ;
+
+r38
+    : INT ('+'^ INT)*
+    ;
+
+r39
+    : (primary->primary) // set return tree to just primary
+        ( '(' arg=expression ')'
+            -> ^(CALL $r39 $arg)
+        | '[' ie=expression ']'
+            -> ^(INDEX $r39 $ie)
+        | '.' p=primary
+            -> ^(FIELDACCESS $r39 $p)
+        )*
+    ;
+
+r40
+    : (INT -> INT) ( ('+' i+=INT)* -> ^('+' $r40 $i*) ) ';'
+    ;
+
+r41
+    : (INT -> INT) ( ('+' i=INT) -> ^($i $r41) )* ';'
+    ;
+
+r42
+    : ids+=ID (','! ids+=ID)*
+    ;
+
+r43 returns [res]
+    : ids+=ID! (','! ids+=ID!)* {$res = [id.text for id in $ids]}
+    ;
+
+r44
+    : ids+=ID^ (','! ids+=ID^)*
+    ;
+
+r45
+    : primary^
+    ;
+
+r46 returns [res]
+    : ids+=primary! (','! ids+=primary!)* {$res = [id.text for id in $ids]}
+    ;
+
+r47
+    : ids+=primary (','! ids+=primary)*
+    ;
+
+r48
+    : ids+=. (','! ids+=.)*
+    ;
+
+r49
+    : .^ ID
+    ;
+
+r50
+    : ID
+        -> ^({CommonTree(CommonToken(type=FLOAT, text="1.0"))} ID)
+    ;
+
+/** templates tested:
+    tokenLabelPropertyRef_tree
+*/
+r51 returns [res]
+    : ID t=ID ID
+        { $res = $t.tree }
+    ;
+
+/** templates tested:
+    rulePropertyRef_tree
+*/
+r52 returns [res]
+@after {
+    $res = $tree
+}
+    : ID
+    ;
+
+/** templates tested:
+    ruleLabelPropertyRef_tree
+*/
+r53 returns [res]
+    : t=primary
+        { $res = $t.tree }
+    ;
+
+/** templates tested:
+    ruleSetPropertyRef_tree
+*/
+r54 returns [res]
+@after {
+    $tree = $t.tree;
+}
+    : ID t=expression ID
+    ;
+
+/** backtracking */
+r55
+options { backtrack=true; k=1; }
+    : (modifier+ INT)=> modifier+ expression
+    | modifier+ statement
+    ;
+
+
+/** templates tested:
+    rewriteTokenRef with len(args)>0
+*/
+r56
+    : t=ID* -> ID[$t,'foo']
+    ;
+
+/** templates tested:
+    rewriteTokenRefRoot with len(args)>0
+*/
+r57
+    : t=ID* -> ^(ID[$t,'foo'])
+    ;
+
+/** templates tested:
+    ???
+*/
+r58
+    : ({CommonTree(CommonToken(type=FLOAT, text="2.0"))})^
+    ;
+
+/** templates tested:
+    rewriteTokenListLabelRefRoot
+*/
+r59
+    : (t+=ID)+ statement -> ^($t statement)+
+    ;
+
+primary
+    : ID
+    ;
+
+expression
+    : r1
+    ;
+
+statement
+    : 'fooze'
+    | 'fooze2'
+    ;
+
+modifiers
+    : modifier+
+    ;
+
+modifier
+    : 'public'
+    | 'private'
+    ;
+
+type
+    : 'int'
+    | 'bool'
+    ;
+
+ID : 'a'..'z' + ;
+INT : '0'..'9' +;
+WS: (' ' | '\n' | '\t')+ {$channel = HIDDEN;};
+
diff --git a/runtime/Cpp/tests/t043synpred.g b/runtime/Cpp/tests/t043synpred.g
new file mode 100644
index 0000000..b54cef8
--- /dev/null
+++ b/runtime/Cpp/tests/t043synpred.g
@@ -0,0 +1,27 @@
+grammar t043synpred;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+a: ((s+ P)=> s+ b)? E;
+b: P 'foo';
+
+s: S;
+
+
+S: ' ';
+P: '+';
+E: '>';
diff --git a/runtime/Cpp/tests/t044trace.g b/runtime/Cpp/tests/t044trace.g
new file mode 100644
index 0000000..002aa2f
--- /dev/null
+++ b/runtime/Cpp/tests/t044trace.g
@@ -0,0 +1,33 @@
+grammar t044trace;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@init {
+    self._stack = None
+}
+
+a: '<' ((INT '+')=>b|c) '>';
+b: c ('+' c)*;
+c: INT
+    {
+        if self._stack is None:
+            self._stack = self.getRuleInvocationStack()
+    }
+    ;
+
+INT: ('0'..'9')+;
+WS: (' ' | '\n' | '\t')+ {$channel = HIDDEN;};
diff --git a/runtime/Cpp/tests/t045dfabug.g b/runtime/Cpp/tests/t045dfabug.g
new file mode 100644
index 0000000..101c582
--- /dev/null
+++ b/runtime/Cpp/tests/t045dfabug.g
@@ -0,0 +1,44 @@
+grammar t045dfabug;
+options {
+    language =Cpp;
+    output = AST;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+// this rule used to generate an infinite loop in DFA.predict
+r
+options { backtrack=true; }
+    : (modifier+ INT)=> modifier+ expression
+    | modifier+ statement
+    ;
+
+expression
+    : INT '+' INT
+    ;
+
+statement
+    : 'fooze'
+    | 'fooze2'
+    ;
+
+modifier
+    : 'public'
+    | 'private'
+    ;
+
+ID : 'a'..'z' + ;
+INT : '0'..'9' +;
+WS: (' ' | '\n' | '\t')+ {$channel = HIDDEN;};
+
diff --git a/runtime/Cpp/tests/t046rewrite.g b/runtime/Cpp/tests/t046rewrite.g
new file mode 100644
index 0000000..60d8a41
--- /dev/null
+++ b/runtime/Cpp/tests/t046rewrite.g
@@ -0,0 +1,67 @@
+grammar t046rewrite;
+options {
+    language=Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+program
+@init {
+    start = self.input.LT(1)
+}
+    :   method+
+        {
+        self.input.insertBefore(start,"public class Wrapper {\n")
+        self.input.insertAfter($method.stop, "\n}\n")
+        }
+    ;
+
+method
+    :   m='method' ID '(' ')' body
+        {self.input.replace($m, "public void");}
+    ;
+
+body
+scope {
+    decls
+}
+@init {
+    $body::decls = set()
+}
+    :   lcurly='{' stat* '}'
+        {
+        for it in $body::decls:
+            self.input.insertAfter($lcurly, "\nint "+it+";")
+        }
+    ;
+
+stat:   ID '=' expr ';' {$body::decls.add($ID.text);}
+    ;
+
+expr:   mul ('+' mul)*
+    ;
+
+mul :   atom ('*' atom)*
+    ;
+
+atom:   ID
+    |   INT
+    ;
+
+ID  :   ('a'..'z'|'A'..'Z')+ ;
+
+INT :   ('0'..'9')+ ;
+
+WS  :   (' '|'\t'|'\n')+ {$channel=HIDDEN;}
+    ;
diff --git a/runtime/Cpp/tests/t047treeparser.g b/runtime/Cpp/tests/t047treeparser.g
new file mode 100644
index 0000000..375d84f
--- /dev/null
+++ b/runtime/Cpp/tests/t047treeparser.g
@@ -0,0 +1,126 @@
+grammar t047treeparser;
+options {
+    language=Cpp;
+    output=AST;
+}
+
+tokens {
+    VAR_DEF;
+    ARG_DEF;
+    FUNC_HDR;
+    FUNC_DECL;
+    FUNC_DEF;
+    BLOCK;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+program
+    :   declaration+
+    ;
+
+declaration
+    :   variable
+    |   functionHeader ';' -> ^(FUNC_DECL functionHeader)
+    |   functionHeader block -> ^(FUNC_DEF functionHeader block)
+    ;
+
+variable
+    :   type declarator ';' -> ^(VAR_DEF type declarator)
+    ;
+
+declarator
+    :   ID
+    ;
+
+functionHeader
+    :   type ID '(' ( formalParameter ( ',' formalParameter )* )? ')'
+        -> ^(FUNC_HDR type ID formalParameter+)
+    ;
+
+formalParameter
+    :   type declarator -> ^(ARG_DEF type declarator)
+    ;
+
+type
+    :   'int'
+    |   'char'
+    |   'void'
+    |   ID
+    ;
+
+block
+    :   lc='{'
+            variable*
+            stat*
+        '}'
+        -> ^(BLOCK[$lc,"BLOCK"] variable* stat*)
+    ;
+
+stat: forStat
+    | expr ';'!
+    | block
+    | assignStat ';'!
+    | ';'!
+    ;
+
+forStat
+    :   'for' '(' start=assignStat ';' expr ';' next=assignStat ')' block
+        -> ^('for' $start expr $next block)
+    ;
+
+assignStat
+    :   ID EQ expr -> ^(EQ ID expr)
+    ;
+
+expr:   condExpr
+    ;
+
+condExpr
+    :   aexpr ( ('=='^ | '<'^) aexpr )?
+    ;
+
+aexpr
+    :   atom ( '+'^ atom )*
+    ;
+
+atom
+    : ID
+    | INT
+    | '(' expr ')' -> expr
+    ;
+
+FOR : 'for' ;
+INT_TYPE : 'int' ;
+CHAR: 'char';
+VOID: 'void';
+
+ID  :   ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*
+    ;
+
+INT :	('0'..'9')+
+    ;
+
+EQ   : '=' ;
+EQEQ : '==' ;
+LT   : '<' ;
+PLUS : '+' ;
+
+WS  :   (   ' '
+        |   '\t'
+        |   '\r'
+        |   '\n'
+        )+
+        { $channel=HIDDEN }
+    ;
diff --git a/runtime/Cpp/tests/t047treeparserWalker.g b/runtime/Cpp/tests/t047treeparserWalker.g
new file mode 100644
index 0000000..1d4d622
--- /dev/null
+++ b/runtime/Cpp/tests/t047treeparserWalker.g
@@ -0,0 +1,73 @@
+tree grammar t047treeparserWalker;
+options {
+    language=Cpp;
+    tokenVocab=t047treeparser;
+    ASTLabelType=CommonTree;
+}
+
+@includes {
+#include "UserTestTraits.hpp"
+}
+@namespace
+{ Antlr3Test }
+
+program
+    :   declaration+
+    ;
+
+declaration
+    :   variable
+    |   ^(FUNC_DECL functionHeader)
+    |   ^(FUNC_DEF functionHeader block)
+    ;
+
+variable returns [res]
+    :   ^(VAR_DEF type declarator)
+        {
+            $res = $declarator.text;
+        }
+    ;
+
+declarator
+    :   ID
+    ;
+
+functionHeader
+    :   ^(FUNC_HDR type ID formalParameter+)
+    ;
+
+formalParameter
+    :   ^(ARG_DEF type declarator)
+    ;
+
+type
+    :   'int'
+    |   'char'
+    |   'void'
+    |   ID
+    ;
+
+block
+    :   ^(BLOCK variable* stat*)
+    ;
+
+stat: forStat
+    | expr
+    | block
+    ;
+
+forStat
+    :   ^('for' expr expr expr block)
+    ;
+
+expr:   ^(EQEQ expr expr)
+    |   ^(LT expr expr)
+    |   ^(PLUS expr expr)
+    |   ^(EQ ID expr)
+    |   atom
+    ;
+
+atom
+    : ID
+    | INT
+    ;
diff --git a/runtime/Cpp/tests/t048rewrite.g b/runtime/Cpp/tests/t048rewrite.g
new file mode 100644
index 0000000..2cd40fe
--- /dev/null
+++ b/runtime/Cpp/tests/t048rewrite.g
@@ -0,0 +1,16 @@
+lexer grammar t048rewrite;
+options {
+    language=Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+A: 'a';
+B: 'b';
+C: 'c';
+
diff --git a/runtime/Cpp/tests/t048rewrite2.g b/runtime/Cpp/tests/t048rewrite2.g
new file mode 100644
index 0000000..c7bb2dd
--- /dev/null
+++ b/runtime/Cpp/tests/t048rewrite2.g
@@ -0,0 +1,19 @@
+lexer grammar t048rewrite2;
+options {
+    language=Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+ID : 'a'..'z'+;
+INT : '0'..'9'+;
+SEMI : ';';
+PLUS : '+';
+MUL : '*';
+ASSIGN : '=';
+WS : ' '+;
diff --git a/runtime/Cpp/tests/t050decorate.g b/runtime/Cpp/tests/t050decorate.g
new file mode 100644
index 0000000..2f6ea71
--- /dev/null
+++ b/runtime/Cpp/tests/t050decorate.g
@@ -0,0 +1,42 @@
+grammar t050decorate;
+options {
+  language =Cpp;
+}
+
+@lexer::includes
+{
+#include "UserTestTraits.hpp"
+}
+@lexer::namespace
+{ Antlr3Test }
+
+@parser::includes {
+#include "UserTestTraits.hpp"
+}
+@parser::namespace
+{ Antlr3Test }
+
+@header {
+    def logme(func):
+        def decorated(self, *args, **kwargs):
+            self.events.append('before')
+            try:
+                return func(self, *args, **kwargs)
+            finally:
+                self.events.append('after')
+
+        return decorated
+}
+
+@parser::init {
+self.events = []
+}
+
+document
+@decorate {
+    @logme
+}
+    : IDENTIFIER
+    ;
+
+IDENTIFIER: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'0'..'9'|'_')*;

