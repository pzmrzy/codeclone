commit 3bfbd9c9cd88d6a3bb693fe6560ec04a72f5500c
Author:     Benjamin Niemann <pink@odahoda.de>
AuthorDate: Fri Apr 1 08:47:15 2011 -0800
Commit:     Benjamin Niemann <pink@odahoda.de>
CommitDate: Fri Apr 1 08:47:15 2011 -0800

[Python] Slowly catching up with the changes since V3.1.3

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8021]

diff --git a/runtime/Python/antlr3/tree.py b/runtime/Python/antlr3/tree.py
index 5fcf526..a85a317 100644
--- a/runtime/Python/antlr3/tree.py
+++ b/runtime/Python/antlr3/tree.py
@@ -98,7 +98,7 @@ class RewriteEmptyStreamException(RewriteCardinalityException):
class Tree(object):
"""
@brief Abstract baseclass for tree nodes.
-
+
What does a tree look like?  ANTLR has a number of support classes
such as CommonTreeNodeStream that work on these kinds of trees.  You
don't have to make your trees implement this interface, but if you do,
@@ -106,29 +106,29 @@ class Tree(object):

NOTE: When constructing trees, ANTLR can build any kind of tree; it can
even use Token objects as trees if you add a child list to your tokens.
-
+
This is a tree node without any payload; just navigation and factory stuff.
"""


def getChild(self, i):
raise NotImplementedError
-
+

def getChildCount(self):
raise NotImplementedError
-
+

def getParent(self):
"""Tree tracks parent and child index now > 3.0"""

raise NotImplementedError
-
+
def setParent(self, t):
"""Tree tracks parent and child index now > 3.0"""

raise NotImplementedError
-
+

def hasAncestor(self, ttype):
"""Walk upwards looking for ancestor with this token type."""
@@ -154,19 +154,19 @@ class Tree(object):
"""This node is what child index? 0..n-1"""

raise NotImplementedError
-
+
def setChildIndex(self, index):
"""This node is what child index? 0..n-1"""

raise NotImplementedError
-
+

def freshenParentAndChildIndexes(self):
"""Set the parent and child index values for all children"""
-
+
raise NotImplementedError

-
+
def addChild(self, t):
"""
Add t as a child to this node.  If t is null, do nothing.  If t
@@ -174,18 +174,18 @@ class Tree(object):
"""

raise NotImplementedError
-
+

def setChild(self, i, t):
"""Set ith child (0..n-1) to t; t must be non-null and non-nil node"""

raise NotImplementedError

-
+
def deleteChild(self, i):
raise NotImplementedError
-
-
+
+
def replaceChildren(self, startChildIndex, stopChildIndex, t):
"""
Delete children from start to stop and replace with t even if t is
@@ -204,7 +204,7 @@ class Tree(object):
"""

raise NotImplementedError
-
+

def getTokenStartIndex(self):
"""
@@ -234,17 +234,17 @@ class Tree(object):

def dupNode(self):
raise NotImplementedError
-
-
+
+
def getType(self):
"""Return a token type; needed for tree parsing."""

raise NotImplementedError
-
+

def getText(self):
raise NotImplementedError
-
+

def getLine(self):
"""
@@ -252,7 +252,7 @@ class Tree(object):
"""

raise NotImplementedError
-
+

def getCharPositionInLine(self):
raise NotImplementedError
@@ -270,7 +270,7 @@ class Tree(object):
class TreeAdaptor(object):
"""
@brief Abstract baseclass for tree adaptors.
-
+
How to create and navigate trees.  Rather than have a separate factory
and adaptor, I've merged them.  Makes sense to encapsulate.

@@ -280,7 +280,7 @@ class TreeAdaptor(object):
I do not need to know the type of a tree at all so they are all
generic Objects.  This may increase the amount of typecasting needed. :(
"""
-
+
# C o n s t r u c t i o n

def createWithPayload(self, payload):
@@ -293,7 +293,7 @@ class TreeAdaptor(object):
"""

raise NotImplementedError
-
+

def dupNode(self, treeNode):
"""Duplicate a single tree node.
@@ -362,7 +362,7 @@ class TreeAdaptor(object):
"""
If oldRoot is a nil root, just copy or move the children to newRoot.
If not a nil root, make oldRoot a child of newRoot.
-
+
old=^(nil a b c), new=r yields ^(r a b c)
old=^(a b c), new=r yields ^(r ^(a b c))

@@ -505,14 +505,14 @@ class TreeAdaptor(object):

raise NotImplementedError

-
+
def getTokenStopIndex(self, t):
"""
Get the token stop index for this subtree; return -1 if no such index
"""

raise NotImplementedError
-
+

# N a v i g a t i o n  /  T r e e  P a r s i n g

@@ -530,7 +530,7 @@ class TreeAdaptor(object):

def deleteChild(self, t, i):
"""Remove ith child and shift children down from right."""
-
+
raise NotImplementedError


@@ -546,7 +546,7 @@ class TreeAdaptor(object):
If your node type doesn't handle this, it's ok but the tree rewrites
in tree parsers need this functionality.
"""
-
+
raise NotImplementedError


@@ -569,7 +569,7 @@ class TreeAdaptor(object):

raise NotImplementedError

-
+
def setChildIndex(self, t, index):
"""
What index is this node in the child list? Range: 0..n-1
@@ -600,7 +600,7 @@ class TreeAdaptor(object):
Deprecated, use createWithPayload, createFromToken or createFromType.

This method only exists to mimic the Java interface of TreeAdaptor.
-
+
"""

if len(args) == 1 and isinstance(args[0], Token):
@@ -653,7 +653,7 @@ class TreeAdaptor(object):
"No create method with this signature found: %s"
% (', '.join(type(v).__name__ for v in args))
)
-
+

############################################################################
#
@@ -682,19 +682,19 @@ class BaseTree(Tree):
# BaseTree is abstract, no need to complain about not implemented abstract
# methods
# pylint: disable-msg=W0223
-
+
def __init__(self, node=None):
"""
Create a new node from an existing node does nothing for BaseTree
as there are no fields other than the children list, which cannot
-        be copied as the children are not considered part of this node.
+        be copied as the children are not considered part of this node.
"""
-
+
Tree.__init__(self)
self.children = []
self.parent = None
self.childIndex = 0
-
+

def getChild(self, i):
try:
@@ -709,7 +709,7 @@ class BaseTree(Tree):
Note that if you directly mess with
the list, do so at your own risk.
"""
-
+
# FIXME: mark as deprecated
return self.children

@@ -736,7 +736,7 @@ class BaseTree(Tree):

# this implementation is much simpler and probably less efficient
# than the mumbo-jumbo that Ter did for the Java runtime.
-
+
if childTree is None:
return

@@ -750,7 +750,7 @@ class BaseTree(Tree):
for idx, child in enumerate(childTree.children):
child.parent = self
child.childIndex = len(self.children) + idx
-
+
self.children += childTree.children

else:
@@ -772,24 +772,24 @@ class BaseTree(Tree):

if t.isNil():
raise ValueError("Can't set single child to a list")
-
+
self.children[i] = t
t.parent = self
t.childIndex = i
-
+

def deleteChild(self, i):
killed = self.children[i]
-
+
del self.children[i]
-
+
# walk rest and decrement their child indexes
for idx, child in enumerate(self.children[i:]):
child.childIndex = i + idx
-
+
return killed

-
+
def replaceChildren(self, startChildIndex, stopChildIndex, newTree):
"""
Delete children from start to stop and replace with t even if t is
@@ -814,8 +814,8 @@ class BaseTree(Tree):

replacingWithHowMany = len(newChildren)
delta = replacingHowMany - replacingWithHowMany
-
-
+
+
if delta == 0:
# if same number of nodes, do direct replace
for idx, child in enumerate(newChildren):
@@ -834,7 +834,7 @@ class BaseTree(Tree):

# ...and fix indeces
self.freshenParentAndChildIndexes(startChildIndex)
-
+

def isNil(self):
return False
@@ -852,7 +852,7 @@ class BaseTree(Tree):
"parents don't match; expected %r found %r"
% (parent, self.parent)
)
-
+
if i != self.childIndex:
raise ValueError(
"child indexes don't match; expected %d found %d"
@@ -865,7 +865,7 @@ class BaseTree(Tree):

def getChildIndex(self):
"""BaseTree doesn't track child indexes."""
-
+
return 0


@@ -873,7 +873,7 @@ class BaseTree(Tree):
"""BaseTree doesn't track child indexes."""

pass
-
+

def getParent(self):
"""BaseTree doesn't track parent pointers."""
@@ -960,11 +960,11 @@ class BaseTreeAdaptor(TreeAdaptor):
"""
@brief A TreeAdaptor that works with any Tree implementation.
"""
-
+
# BaseTreeAdaptor is abstract, no need to complain about not implemented
# abstract methods
# pylint: disable-msg=W0223
-
+
def nil(self):
return self.createWithPayload(None)

@@ -982,9 +982,9 @@ class BaseTreeAdaptor(TreeAdaptor):
You don't have to subclass CommonErrorNode; you will likely need to
subclass your own tree node class to avoid class cast exception.
"""
-
+
return CommonErrorNode(input, start, stop, exc)
-
+

def isNil(self, tree):
return tree.isNil()
@@ -1001,12 +1001,12 @@ class BaseTreeAdaptor(TreeAdaptor):
return None

newTree = self.dupNode(t)
-
+
# ensure new subtree root has parent/child index set

# same index in new tree
self.setChildIndex(newTree, self.getChildIndex(t))
-
+
self.setParent(newTree, parent)

for i in range(self.getChildCount(t)):
@@ -1029,7 +1029,7 @@ class BaseTreeAdaptor(TreeAdaptor):

#if isinstance(child, Token):
#    child = self.createWithPayload(child)
-
+
if tree is not None and child is not None:
tree.addChild(child)

@@ -1068,7 +1068,7 @@ class BaseTreeAdaptor(TreeAdaptor):

if oldRoot is None:
return newRoot
-
+
if not isinstance(newRoot, CommonTree):
newRoot = self.createWithPayload(newRoot)

@@ -1077,7 +1077,7 @@ class BaseTreeAdaptor(TreeAdaptor):
nc = newRoot.getChildCount()
if nc == 1:
newRoot = newRoot.getChild(0)
-
+
elif nc > 1:
# TODO: make tree run time exceptions hierarchy
raise RuntimeError("more than one node as root")
@@ -1091,7 +1091,7 @@ class BaseTreeAdaptor(TreeAdaptor):

def rulePostProcessing(self, root):
"""Transform ^(nil x) to x and nil to null"""
-
+
if root is not None and root.isNil():
if root.getChildCount() == 0:
root = None
@@ -1121,7 +1121,7 @@ class BaseTreeAdaptor(TreeAdaptor):
def createFromType(self, tokenType, text):
assert isinstance(tokenType, (int, long)), type(tokenType).__name__
assert isinstance(text, basestring) or text is None, type(text).__name__
-
+
fromToken = self.createToken(tokenType=tokenType, text=text)
t = self.createWithPayload(fromToken)
return t
@@ -1201,12 +1201,12 @@ class CommonTree(BaseTree):
parent and child index is very difficult and cumbersome.  Better to
spend the space in every tree node.  If you don't want these extra
fields, it's easy to cut them out in your own BaseTree subclass.
-
+
"""

def __init__(self, payload):
BaseTree.__init__(self)
-
+
# What token indexes bracket all tokens associated with this node
# and below?
self.startIndex = -1
@@ -1214,22 +1214,22 @@ class CommonTree(BaseTree):

# Who is the parent node of this node; if null, implies node is root
self.parent = None
-
+
# What index is this node in the child list? Range: 0..n-1
self.childIndex = -1

# A single token is the payload
if payload is None:
self.token = None
-
+
elif isinstance(payload, CommonTree):
self.token = payload.token
self.startIndex = payload.startIndex
self.stopIndex = payload.stopIndex
-
+
elif payload is None or isinstance(payload, Token):
self.token = payload
-
+
else:
raise TypeError(type(payload).__name__)

@@ -1254,16 +1254,16 @@ class CommonTree(BaseTree):
return self.token.getType()

type = property(getType)
-
+

def getText(self):
if self.token is None:
return None
-
+
return self.token.text

text = property(getText)
-
+

def getLine(self):
if self.token is None or self.token.getLine() == 0:
@@ -1275,7 +1275,7 @@ class CommonTree(BaseTree):
return self.token.getLine()

line = property(getLine)
-
+

def getCharPositionInLine(self):
if self.token is None or self.token.getCharPositionInLine() == -1:
@@ -1288,14 +1288,14 @@ class CommonTree(BaseTree):
return self.token.getCharPositionInLine()

charPositionInLine = property(getCharPositionInLine)
-
+

def getTokenStartIndex(self):
if self.startIndex == -1 and self.token is not None:
return self.token.getTokenIndex()
-
+
return self.startIndex
-
+
def setTokenStartIndex(self, index):
self.startIndex = index

@@ -1305,7 +1305,7 @@ class CommonTree(BaseTree):
def getTokenStopIndex(self):
if self.stopIndex == -1 and self.token is not None:
return self.token.getTokenIndex()
-
+
return self.stopIndex

def setTokenStopIndex(self, index):
@@ -1325,7 +1325,7 @@ class CommonTree(BaseTree):
self.startIndex = self.stopIndex = self.token.getTokenIndex()

return
-
+
for child in self.children:
child.setUnknownTokenBoundaries()

@@ -1359,7 +1359,7 @@ class CommonTree(BaseTree):
#FIXME: mark as deprecated
self.parent = t

-
+
def toString(self):
if self.isNil():
return "nil"
@@ -1369,7 +1369,7 @@ class CommonTree(BaseTree):

return self.token.text

-    __str__ = toString
+    __str__ = toString



@@ -1380,7 +1380,7 @@ class CommonTree(BaseTree):
ret = ''
if not self.isNil():
ret += '(%s ' % (self.toString())
-
+
ret += ' '.join([child.toStringTree() for child in self.children])

if not self.isNil():
@@ -1470,7 +1470,7 @@ class CommonErrorNode(CommonTree):
class CommonTreeAdaptor(BaseTreeAdaptor):
"""
@brief A TreeAdaptor that works with any Tree implementation.
-
+
It provides
really just factory methods; all the work is done by BaseTreeAdaptor.
If you would like to have different tokens created than ClassicToken
@@ -1481,7 +1481,7 @@ class CommonTreeAdaptor(BaseTreeAdaptor):
create(Token), errorNode(), and to be safe, YourTreeClass.dupNode().
dupNode is called to duplicate nodes during rewrite operations.
"""
-
+
def dupNode(self, treeNode):
"""
Duplicate a node.  This is part of the factory;
@@ -1493,7 +1493,7 @@ class CommonTreeAdaptor(BaseTreeAdaptor):

if treeNode is None:
return None
-
+
return treeNode.dupNode()


@@ -1511,7 +1511,7 @@ class CommonTreeAdaptor(BaseTreeAdaptor):
If you care what the token payload objects' type is, you should
override this method and any other createToken variant.
"""
-
+
if fromToken is not None:
return CommonToken(oldToken=fromToken)

@@ -1525,16 +1525,16 @@ class CommonTreeAdaptor(BaseTreeAdaptor):
seems like this will yield start=i and stop=i-1 in a nil node.
Might be useful info so I'll not force to be i..i.
"""
-
+
if t is None:
return

start = 0
stop = 0
-
+
if startToken is not None:
start = startToken.index
-
+
if stopToken is not None:
stop = stopToken.index

@@ -1563,7 +1563,7 @@ class CommonTreeAdaptor(BaseTreeAdaptor):
def getType(self, t):
if t is None:
return INVALID_TOKEN_TYPE
-
+
return t.getType()


@@ -1636,11 +1636,11 @@ class TreeNodeStream(IntStream):

It accessing nodes from a tree of some kind.
"""
-
+
# TreeNodeStream is abstract, no need to complain about not implemented
# abstract methods
# pylint: disable-msg=W0223
-
+
def get(self, i):
"""Get a tree node at an absolute index i; 0..n-1.
If you don't want to buffer up nodes, then this method makes no
@@ -1674,7 +1674,7 @@ class TreeNodeStream(IntStream):
"""

raise NotImplementedError
-
+

def getTokenStream(self):
"""
@@ -1694,7 +1694,7 @@ class TreeNodeStream(IntStream):
"""

raise NotImplementedError
-
+

def setUniqueNavigationNodes(self, uniqueNavigationNodes):
"""
@@ -1706,7 +1706,16 @@ class TreeNodeStream(IntStream):
"""

raise NotImplementedError
-
+
+
+    def reset(self):
+        """
+        Reset the tree node stream in such a way that it acts like
+        a freshly constructed stream.
+        """
+
+        raise NotImplementedError
+

def toString(self, start, stop):
"""
@@ -1756,7 +1765,7 @@ class CommonTreeNodeStream(TreeNodeStream):

@see UnBufferedTreeNodeStream
"""
-
+
def __init__(self, *args):
TreeNodeStream.__init__(self)

@@ -1793,7 +1802,7 @@ class CommonTreeNodeStream(TreeNodeStream):

else:
raise TypeError("Invalid arguments")
-
+
# all these navigation nodes are shared and hence they
# cannot contain any line/column info
if down is not None:
@@ -1858,7 +1867,7 @@ class CommonTreeNodeStream(TreeNodeStream):

def _fillBuffer(self, t):
nil = self.adaptor.isNil(t)
-
+
if not nil:
self.nodes.append(t) # add this node

@@ -1880,7 +1889,7 @@ class CommonTreeNodeStream(TreeNodeStream):
"""What is the stream index for node? 0..n-1
Return -1 if node not found.
"""
-
+
if self.p == -1:
self.fillBuffer()

@@ -1897,9 +1906,9 @@ class CommonTreeNodeStream(TreeNodeStream):
the tree structure.  When debugging we need unique nodes
so instantiate new ones when uniqueNavigationNodes is true.
"""
-
+
navNode = None
-
+
if ttype == DOWN:
if self.hasUniqueNavigationNodes():
navNode = self.adaptor.createFromType(DOWN, "DOWN")
@@ -1910,7 +1919,7 @@ class CommonTreeNodeStream(TreeNodeStream):
else:
if self.hasUniqueNavigationNodes():
navNode = self.adaptor.createFromType(UP, "UP")
-
+
else:
navNode = self.up

@@ -1938,7 +1947,7 @@ class CommonTreeNodeStream(TreeNodeStream):
return self.eof

return self.nodes[self.p + k - 1]
-
+

def getCurrentSymbol(self):
return self.LT(1)
@@ -1946,7 +1955,7 @@ class CommonTreeNodeStream(TreeNodeStream):

def LB(self, k):
"""Look backwards k nodes"""
-
+
if k == 0:
return None

@@ -1987,10 +1996,10 @@ class CommonTreeNodeStream(TreeNodeStream):
def consume(self):
if self.p == -1:
self.fillBuffer()
-
+
self.p += 1

-
+
def LA(self, i):
return self.adaptor.getType(self.LT(i))

@@ -1999,7 +2008,7 @@ class CommonTreeNodeStream(TreeNodeStream):
if self.p == -1:
self.fillBuffer()

-
+
self.lastMarker = self.index()
return self.lastMarker

@@ -2017,7 +2026,7 @@ class CommonTreeNodeStream(TreeNodeStream):
def rewind(self, marker=None):
if marker is None:
marker = self.lastMarker
-
+
self.seek(marker)


@@ -2054,7 +2063,7 @@ class CommonTreeNodeStream(TreeNodeStream):
self.lastMarker = 0
self.calls = []

-
+
def size(self):
if self.p == -1:
self.fillBuffer()
@@ -2098,12 +2107,12 @@ class CommonTreeNodeStream(TreeNodeStream):
#    System.out.println(((CommonTree)stop).getToken());
#else
#    System.out.println(stop);
-
+
# if we have the token stream, use that to dump text in order
if self.tokens is not None:
beginTokenIndex = self.adaptor.getTokenStartIndex(start)
endTokenIndex = self.adaptor.getTokenStopIndex(stop)
-
+
# if it's a tree, use start/stop index from start node
# else use token range from start/stop nodes
if self.adaptor.getType(stop) == UP:
@@ -2138,9 +2147,9 @@ class CommonTreeNodeStream(TreeNodeStream):
text = " " +self.adaptor.getType(stop)

buf.append(text)
-
+
return ''.join(buf)
-
+

## iterator interface
def __iter__(self):
@@ -2159,7 +2168,7 @@ class CommonTreeNodeStream(TreeNodeStream):

class TreeParser(BaseRecognizer):
"""@brief Baseclass for generated tree parsers.
-
+
A parser for a stream of tree nodes.  "tree grammars" result in a subclass
of this.  All the error reporting and recovery is shared with Parser via
the BaseRecognizer superclass.
@@ -2218,11 +2227,11 @@ class TreeParser(BaseRecognizer):
that is a METHOD node.  The first node in the context is not
necessarily the root.  The context matcher stops matching and returns
true when it runs out of context.  There is no way to force the first
-        node to be the root.
+        node to be the root.
"""

return _inContext(
-            self.input.getTreeAdaptor(), self.getTokenNames(),
+            self.input.getTreeAdaptor(), self.getTokenNames(),
self.input.LT(1), context)

@classmethod
@@ -2292,7 +2301,7 @@ class TreeParser(BaseRecognizer):
entire tree if node has children.  If children, scan until
corresponding UP node.
"""
-
+
self._state.errorRecovery = False

look = self.input.LT(1)
@@ -2384,7 +2393,7 @@ class TreeVisitor(object):
self.adaptor = adaptor
else:
self.adaptor = CommonTreeAdaptor()
-
+
def visit(self, t, pre_action=None, post_action=None):
"""Visit every node in tree t and trigger an action for each node
before/after having visited all of its children.  Bottom up walk.
@@ -2414,6 +2423,120 @@ class TreeVisitor(object):

return t

+#############################################################################
+#
+# tree iterator
+#
+#############################################################################
+
+class TreeIterator(object):
+    """
+    Return a node stream from a doubly-linked tree whose nodes
+    know what child index they are.
+
+    Emit navigation nodes (DOWN, UP, and EOF) to let show tree structure.
+    """
+
+    def __init__(self, tree, adaptor=None):
+        if adaptor is None:
+            adaptor = CommonTreeAdaptor()
+
+        self.root = tree
+        self.adaptor = adaptor
+
+        self.first_time = True
+        self.tree = tree
+
+        # If we emit UP/DOWN nodes, we need to spit out multiple nodes per
+        # next() call.
+        self.nodes = []
+
+        # navigation nodes to return during walk and at end
+        self.down = adaptor.createFromType(DOWN, "DOWN")
+        self.up = adaptor.createFromType(UP, "UP")
+        self.eof = adaptor.createFromType(EOF, "EOF")
+
+
+    def reset(self):
+        self.first_time = True
+        self.tree = self.root
+        self.nodes = []
+
+
+    def __iter__(self):
+        return self
+
+
+    def has_next(self):
+        if self.first_time:
+            return self.root is not None
+
+        if len(self.nodes) > 0:
+            return True
+
+        if self.tree is None:
+            return False
+
+        if self.adaptor.getChildCount(self.tree) > 0:
+            return True
+
+        # back at root?
+        return self.adaptor.getParent(self.tree) is not None
+
+
+    def next(self):
+        if not self.has_next():
+            raise StopIteration
+
+        if self.first_time:
+            # initial condition
+            self.first_time = False
+            if self.adaptor.getChildCount(self.tree) == 0:
+                # single node tree (special)
+                self.nodes.append(self.eof)
+                return self.tree
+
+            return self.tree
+
+        # if any queued up, use those first
+        if len(self.nodes) > 0:
+            return self.nodes.pop(0)
+
+        # no nodes left?
+        if self.tree is None:
+            return self.eof
+
+        # next node will be child 0 if any children
+        if self.adaptor.getChildCount(self.tree) > 0:
+            self.tree = self.adaptor.getChild(self.tree, 0)
+            # real node is next after DOWN
+            self.nodes.append(self.tree)
+            return self.down
+
+        # if no children, look for next sibling of tree or ancestor
+        parent = self.adaptor.getParent(self.tree)
+        # while we're out of siblings, keep popping back up towards root
+        while (parent is not None
+               and self.adaptor.getChildIndex(self.tree)+1 >= self.adaptor.getChildCount(parent)):
+            # we're moving back up
+            self.nodes.append(self.up)
+            self.tree = parent
+            parent = self.adaptor.getParent(self.tree)
+
+        # no nodes left?
+        if parent is None:
+            self.tree = None # back at root? nothing left then
+            self.nodes.append(self.eof) # add to queue, might have UP nodes in there
+            return self.nodes.pop(0)
+
+        # must have found a node with an unvisited sibling
+        # move to it and return it
+        nextSiblingIndex = self.adaptor.getChildIndex(self.tree) + 1
+        self.tree = self.adaptor.getChild(parent, nextSiblingIndex)
+        self.nodes.append(self.tree) # add to queue, might have UP nodes in there
+        return self.nodes.pop(0)
+
+

#############################################################################
#
@@ -2423,7 +2546,7 @@ class TreeVisitor(object):

class RewriteRuleElementStream(object):
"""@brief Internal helper class.
-
+
A generic list of elements tracked in an alternative to be used in
a -> rewrite rule.  We need to subclass to fill in the next() method,
which returns either an AST node wrapped around a token payload or
@@ -2434,7 +2557,7 @@ class RewriteRuleElementStream(object):

@see org.antlr.runtime.tree.RewriteRuleSubtreeStream
@see org.antlr.runtime.tree.RewriteRuleTokenStream
-
+
TODO: add mechanism to detect/puke on modification after reading from
stream
"""
@@ -2455,7 +2578,7 @@ class RewriteRuleElementStream(object):
# can be reused in future subrules.  So, reset must set a dirty bit.
# If dirty, then next() always returns a dup.
self.dirty = False
-
+
# The element or stream description; usually has name of the token or
# rule reference that this list tracks.  Can include rulename too, but
# the exception would track that info.
@@ -2480,11 +2603,11 @@ class RewriteRuleElementStream(object):
Once we reset the stream, any future use will need duplicates.  Set
the dirty bit.
"""
-
+
self.cursor = 0
self.dirty = True

-
+
def add(self, el):
if el is None:
return
@@ -2508,11 +2631,11 @@ class RewriteRuleElementStream(object):
"""
Return the next element in the stream.  If out of elements, throw
an exception unless size()==1.  If size is 1, then return elements[0].
-
+
Return a duplicate node/subtree if stream is out of elements and
size==1. If we've already used the element, dup (dirty bit set).
"""
-
+
if (self.dirty
or (self.cursor >= len(self) and len(self) == 1)
):
@@ -2536,9 +2659,9 @@ class RewriteRuleElementStream(object):

if len(self) == 0:
raise RewriteEmptyStreamException(self.elementDescription)
-
+
if self.cursor >= len(self): # out of elements?
-            if len(self) == 1: # if size is 1, it's ok; return and we'll dup
+            if len(self) == 1: # if size is 1, it's ok; return and we'll dup
return self.toTree(self.singleElement)

# out of elements and size was not 1, so we can't dup
@@ -2564,7 +2687,7 @@ class RewriteRuleElementStream(object):
"""

raise NotImplementedError
-
+

def toTree(self, el):
"""
@@ -2582,7 +2705,7 @@ class RewriteRuleElementStream(object):
)
)

-
+
def size(self):
if self.singleElement is not None:
return 1
@@ -2593,11 +2716,11 @@ class RewriteRuleElementStream(object):
return 0

__len__ = size
-
+

def getDescription(self):
"""Deprecated. Directly access elementDescription attribute"""
-
+
return self.elementDescription


@@ -2614,11 +2737,11 @@ class RewriteRuleTokenStream(RewriteRuleElementStream):
t = self._next()
return self.adaptor.createWithPayload(t)

-
+
def nextToken(self):
return self._next()

-
+
def dup(self, el):
raise TypeError("dup can't be called for a token stream.")

@@ -2641,7 +2764,7 @@ class RewriteRuleSubtreeStream(RewriteRuleElementStream):
a proper way to refactor.  This needs to always call dup node
and super.next() doesn't know which to call: dup node or dup tree.
"""
-
+
if (self.dirty
or (self.cursor >= len(self) and len(self) == 1)
):
@@ -2663,9 +2786,9 @@ class RewriteRuleSubtreeStream(RewriteRuleElementStream):
class RewriteRuleNodeStream(RewriteRuleElementStream):
"""
Queues up nodes matched on left side of -> in a tree parser. This is
-    the analog of RewriteRuleTokenStream for normal parsers.
+    the analog of RewriteRuleTokenStream for normal parsers.
"""
-
+
def nextNode(self):
return self._next()

@@ -2691,12 +2814,11 @@ class TreeRuleReturnScope(RuleReturnScope):
def __init__(self):
self.start = None
self.tree = None
-
-
+
+
def getStart(self):
return self.start

-
+
def getTree(self):
return self.tree
-
diff --git a/runtime/Python/tests/t053hetero.py b/runtime/Python/tests/t053hetero.py
index a8b6fca..363eed2 100644
--- a/runtime/Python/tests/t053hetero.py
+++ b/runtime/Python/tests/t053hetero.py
@@ -29,9 +29,9 @@ class T(testbase.ANTLRTest):
def recover(self, input, re):
# no error recovery yet, just crash!
raise
-
+
return TParser
-
+

def lexerClass(self, base):
class TLexer(base):
@@ -56,9 +56,9 @@ class T(testbase.ANTLRTest):
def recover(self, input, re):
# no error recovery yet, just crash!
raise
-
+
return TLexer
-
+

def execParser(self, grammar, grammarEntry, input):
lexerCls, parserCls = self.compileInlineGrammar(grammar)
@@ -73,7 +73,7 @@ class T(testbase.ANTLRTest):
return r.tree.toStringTree()

return ""
-
+

def execTreeParser(self, grammar, grammarEntry, treeGrammar, treeEntry, input):
lexerCls, parserCls = self.compileInlineGrammar(grammar)
@@ -143,7 +143,7 @@ class T(testbase.ANTLRTest):
ID : 'a'..'z'+ ;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(
grammar, 'a',
input="a"
@@ -152,6 +152,29 @@ class T(testbase.ANTLRTest):
self.failUnlessEqual("a<V>", found)


+    def testNamedType(self):
+        grammar = textwrap.dedent(
+            r"""
+            grammar $T;
+            options {
+                language=Python;
+                output=AST;
+            }
+            @header {
+            class V(CommonTree):
+                def toString(self):
+                    return self.token.text + "<V>"
+                __str__ = toString
+            }
+            a : ID<node=V> ;
+            ID : 'a'..'z'+ ;
+            WS : (' '|'\\n') {$channel=HIDDEN;} ;
+            """)
+
+        found = self.execParser(grammar, 'a', input="a")
+        self.assertEquals("a<V>", found)
+
+
def testTokenWithLabel(self):
grammar = textwrap.dedent(
r'''
@@ -381,7 +404,7 @@ class T(testbase.ANTLRTest):
self.x = x
self.y = y
self.z = z
-
+
def toString(self):
txt = ""
if self.token is not None:
@@ -557,7 +580,7 @@ class T(testbase.ANTLRTest):
self.failUnlessEqual("(int<V> a) (int<V> b) (int<V> c)", found)

# TREE PARSERS -- REWRITE AST
-
+
def testTreeParserRewriteFlatList(self):
grammar = textwrap.dedent(
r'''
@@ -682,7 +705,7 @@ class T(testbase.ANTLRTest):
class V(CommonTree):
def __init__(self, tokenType):
CommonTree.__init__(self, CommonToken(tokenType))
-
+
def toString(self):
return tokenNames[self.token.type] + "<V>"
__str__ = toString
@@ -731,7 +754,7 @@ class T(testbase.ANTLRTest):
def __init__(self, tokenType, x):
CommonTree.__init__(self, CommonToken(tokenType))
self.x = x
-
+
def toString(self):
return tokenNames[self.token.type] + "<V>;" + str(self.x)
__str__ = toString
@@ -778,7 +801,7 @@ class T(testbase.ANTLRTest):
class V(CommonTree):
def __init__(self, tokenType):
CommonTree.__init__(self, CommonToken(tokenType))
-
+
def toString(self):
return tokenNames[self.token.type] + "<V>"
__str__ = toString
@@ -829,7 +852,7 @@ class T(testbase.ANTLRTest):
else:
CommonTree.__init__(self, tree)
self.token.type = tokenType
-
+
def toString(self):
return tokenNames[self.token.type]+"<V>@"+str(self.token.line)
__str__ = toString
@@ -861,7 +884,7 @@ class T(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
treeGrammar = textwrap.dedent(
r'''
tree grammar TP;
@@ -879,10 +902,10 @@ class T(testbase.ANTLRTest):
__str__ = toString

}
-
+
a : ID<V> ';'<V>;
''')
-
+
found = self.execTreeParser(
grammar, 'a',
treeGrammar, 'a',
diff --git a/runtime/Python/tests/t057autoAST.py b/runtime/Python/tests/t057autoAST.py
index b44740e..e95469a 100644
--- a/runtime/Python/tests/t057autoAST.py
+++ b/runtime/Python/tests/t057autoAST.py
@@ -30,9 +30,9 @@ class TestAutoAST(testbase.ANTLRTest):
def emitErrorMessage(self, msg):
self._errors.append(msg)

-
+
return TParser
-
+

def lexerClass(self, base):
class TLexer(base):
@@ -57,9 +57,9 @@ class TestAutoAST(testbase.ANTLRTest):
def recover(self, input, re):
# no error recovery yet, just crash!
raise
-
+
return TLexer
-
+

def execParser(self, grammar, grammarEntry, input, expectErrors=False):
lexerCls, parserCls = self.compileInlineGrammar(grammar)
@@ -87,7 +87,7 @@ class TestAutoAST(testbase.ANTLRTest):

else:
return result, parser._errors
-
+

def execTreeParser(self, grammar, grammarEntry, treeGrammar, treeEntry, input):
lexerCls, parserCls = self.compileInlineGrammar(grammar)
@@ -119,7 +119,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;};
''')
-
+
found = self.execParser(grammar, "a", "abc 34")
self.assertEquals("abc 34", found);

@@ -149,7 +149,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "abc 34")
self.assertEquals("(abc 34)", found)

@@ -164,7 +164,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "34 abc")
self.assertEquals("(abc 34)", found)

@@ -179,7 +179,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "abc 34 dag 4532")
self.assertEquals("abc 4532", found)

@@ -209,7 +209,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "void foo;")
self.assertEquals("(void foo ;)", found)

@@ -239,7 +239,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "void foo;")
self.assertEquals("(foo void ;)", found)

@@ -254,7 +254,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "void foo;")
self.assertEquals("(foo void ;)", found)

@@ -269,7 +269,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "void foo;")
self.assertEquals("(foo void ;)", found)

@@ -299,7 +299,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a 34 c")
self.assertEquals("(34 a c)", found)

@@ -314,7 +314,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a 34 c")
self.assertEquals("(c (34 a))", found)

@@ -329,7 +329,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a 34 * b 9 * c")
self.assertEquals("(* (* (a 34) b 9) c)", found)

@@ -344,7 +344,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "void a b;")
self.assertEquals("void a b ;", found)

@@ -360,7 +360,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "int a")
self.assertEquals("int a", found)

@@ -376,7 +376,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "int a")
self.assertEquals("(int a)", found)

@@ -392,7 +392,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "int a")
self.assertEquals("(int a)", found)

@@ -408,7 +408,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "int a")
self.assertEquals("(int a)", found)

@@ -423,7 +423,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a+b+c+d")
self.assertEquals("(+ (+ (+ a b) c) d)", found)

@@ -439,7 +439,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a+b+c-d")
self.assertEquals("(- (+ (+ a b) c) d)", found)

@@ -456,7 +456,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "s", "3 exp 4 exp 5")
self.assertEquals("(exp 3 (exp 4 5))", found)

@@ -471,7 +471,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "abc")
self.assertEquals("abc", found)

@@ -486,12 +486,13 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "+abc")
self.assertEquals("(+ abc)", found)


-    @testbase.broken("FAILS until antlr.g rebuilt in v3", RuntimeError)
+    @testbase.broken(
+        "FAILS until antlr.g rebuilt in v3", testbase.GrammarCompileError)
def testSetRootWithLabel(self):
grammar = textwrap.dedent(
r'''
@@ -502,7 +503,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "+abc")
self.assertEquals("(+ abc)", found)

@@ -517,7 +518,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a+b-c")
self.assertEquals("(- (+ a b) c)", found)

@@ -532,7 +533,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "34+2")
self.assertEquals("34 + 2", found)

@@ -547,7 +548,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "34+2")
self.assertEquals("34 + 2", found)

@@ -562,7 +563,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "34+2")
self.assertEquals("34 + 2", found)

@@ -577,7 +578,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "34 55")
self.assertEquals("(34 55)", found)

@@ -592,7 +593,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "34 55")
self.assertEquals("(34 55)", found)

@@ -607,7 +608,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "34 55")
self.assertEquals("(34 55)", found)

@@ -623,7 +624,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "3+4+5")
self.assertEquals("(+ (+ 3 4) 5)", found)

@@ -640,7 +641,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a b")
self.assertEquals("2nd id=b;a b", found)

@@ -656,7 +657,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a b")
self.assertEquals("2nd id=b,(b a)", found)

@@ -691,7 +692,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a b")
expecting = "id list=[a,b],(a b)"
self.assertEquals(expecting, found)
@@ -707,7 +708,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a")
self.assertEquals("a", found)

@@ -722,7 +723,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a")
self.assertEquals("", found)

@@ -741,7 +742,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a b")
self.assertEquals("2nd x=b,a b", found)

@@ -759,7 +760,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a b")
self.assertEquals("x=(b a),(b a)", found)

@@ -777,7 +778,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a b")
self.assertEquals("1st x=a,b", found)

@@ -795,7 +796,7 @@ class TestAutoAST(testbase.ANTLRTest):
D : 'd' ;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "a b b c c d")
self.assertEquals("a b b c c d", found)

@@ -811,7 +812,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found = self.execParser(grammar, "a", "abc 34")
self.assertEquals("34\nabc 34", found)

@@ -821,12 +822,12 @@ class TestAutoAST(testbase.ANTLRTest):
r'''
grammar T;
options { language=Python;output=AST; }
-            r : (INT|ID)+ ;
+            r : (INT|ID)+ ;
ID : 'a'..'z' + ;
INT : '0'..'9' +;
WS: (' ' | '\n' | '\\t')+ {$channel = HIDDEN;};
''')
-
+
found = self.execParser(grammar, "r", "abc 34 d")
self.assertEquals("abc 34 d", found)

@@ -842,7 +843,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "decl", "int 34 x=1;",
expectErrors=True)
self.assertEquals(["line 1:4 extraneous input u'34' expecting ID"],
@@ -862,7 +863,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "decl", "int =1;",
expectErrors=True)
self.assertEquals(["line 1:4 missing ID at u'='"], errors)
@@ -881,7 +882,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "decl", "x=1;",
expectErrors=True)
self.assertEquals(["line 1:0 mismatched input u'x' expecting set None"], errors)
@@ -898,7 +899,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "a", "abc", expectErrors=True)
self.assertEquals(["line 0:-1 missing INT at '<EOF>'"], errors)
self.assertEquals("abc <missing INT>", found)
@@ -915,7 +916,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "a", "abc", expectErrors=True)
self.assertEquals(["line 0:-1 mismatched input '<EOF>' expecting INT"], errors)
self.assertEquals("<mismatched token: <EOF>, resync=abc>", found)
@@ -933,7 +934,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "a", "abc ick 34",
expectErrors=True)
self.assertEquals(["line 1:4 extraneous input u'ick' expecting INT"],
@@ -951,7 +952,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "a", "34", expectErrors=True)
self.assertEquals(["line 1:0 missing ID at u'34'"], errors)
self.assertEquals("<missing ID> 34", found)
@@ -969,9 +970,9 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "a", "34", expectErrors=True)
-
+
# finds an error at the first token, 34, and re-syncs.
# re-synchronizing does not consume a token because 34 follows
# ref to rule b (start of c). It then matches 34 in c.
@@ -992,7 +993,7 @@ class TestAutoAST(testbase.ANTLRTest):
INT : '0'..'9'+;
WS : (' '|'\n') {$channel=HIDDEN;} ;
''')
-
+
found, errors = self.execParser(grammar, "a", "*", expectErrors=True)
self.assertEquals(["line 1:0 no viable alternative at input u'*'"],
errors)
diff --git a/runtime/Python/tests/testbase.py b/runtime/Python/tests/testbase.py
index acb41e7..19d1a12 100644
--- a/runtime/Python/tests/testbase.py
+++ b/runtime/Python/tests/testbase.py
@@ -8,6 +8,7 @@ import re
import tempfile
import shutil
import inspect
+import hashlib
from distutils.errors import *
import antlr3

@@ -343,6 +344,14 @@ class ANTLRTest(unittest.TestCase):


def writeInlineGrammar(self, grammar):
+        # Create a unique ID for this test and use it as the grammar name,
+        # to avoid class name reuse. This kinda sucks. Need to find a way so
+        # tests can use the same grammar name without messing up the namespace.
+        # Well, first I should figure out what the exact problem is...
+        id = hashlib.md5(self.baseDir).hexdigest()[-8:]
+        grammar = grammar.replace('$TP', 'TP' + id)
+        grammar = grammar.replace('$T', 'T' + id)
+
# get type and name from first grammar line
m = re.match(r'\s*((lexer|parser|tree)\s+|)grammar\s+(\S+);', grammar, re.MULTILINE)
assert m is not None, grammar
diff --git a/runtime/Python/unittests/testtree.py b/runtime/Python/unittests/testtree.py
index be9a884..dc7b6aa 100644
--- a/runtime/Python/unittests/testtree.py
+++ b/runtime/Python/unittests/testtree.py
@@ -5,7 +5,7 @@ import unittest
from StringIO import StringIO

from antlr3.tree import (CommonTreeNodeStream, CommonTree, CommonTreeAdaptor,
-                         TreeParser, TreeVisitor)
+                         TreeParser, TreeVisitor, TreeIterator)
from antlr3 import CommonToken, UP, DOWN, EOF
from antlr3.treewizard import TreeWizard

@@ -338,6 +338,27 @@ class TestTreeNodeStream(unittest.TestCase):
self.failUnlessEqual(104, stream.LT(1).getType())


+    def testReset(self):
+        # ^(101 ^(102 103 ^(106 107) ) 104 105)
+        # stream has 7 real + 6 nav nodes
+        # Sequence of types: 101 DN 102 DN 103 106 DN 107 UP UP 104 105 UP EOF
+        r0 = CommonTree(CommonToken(101))
+        r1 = CommonTree(CommonToken(102))
+        r0.addChild(r1)
+        r1.addChild(CommonTree(CommonToken(103)))
+        r2 = CommonTree(CommonToken(106))
+        r2.addChild(CommonTree(CommonToken(107)))
+        r1.addChild(r2)
+        r0.addChild(CommonTree(CommonToken(104)))
+        r0.addChild(CommonTree(CommonToken(105)))
+
+        stream = CommonTreeNodeStream(r0)
+        v1 = self.toNodesOnlyString(stream) # scan all
+        stream.reset()
+        v2 = self.toNodesOnlyString(stream) # scan all
+        self.assertEquals(v1, v2)
+
+
def toNodesOnlyString(self, nodes):
buf = []
for i in range(nodes.size()):
@@ -347,7 +368,7 @@ class TestTreeNodeStream(unittest.TestCase):
buf.append(str(type))

return ' '.join(buf)
-
+

class TestCommonTreeNodeStream(unittest.TestCase):
"""Test case for the CommonTreeNodeStream class."""
@@ -380,7 +401,7 @@ class TestCommonTreeNodeStream(unittest.TestCase):
indexOf107 = 12
for _ in range(indexOf107):# consume til 107 node
stream.consume()
-
+
# CALL 102
self.failUnlessEqual(107, stream.LT(1).getType())
stream.push(indexOf102)
@@ -513,7 +534,7 @@ class TestCommonTree(unittest.TestCase):

self.adaptor = CommonTreeAdaptor()

-
+
def testSingleNode(self):
t = CommonTree(CommonToken(101))
self.failUnless(t.parent is None)
@@ -546,7 +567,7 @@ class TestCommonTree(unittest.TestCase):
self.failUnlessEqual(r0, c0.parent)
self.failUnlessEqual(0, c0.childIndex)
self.failUnlessEqual(r0, c1.parent)
-        self.failUnlessEqual(1, c1.childIndex)
+        self.failUnlessEqual(1, c1.childIndex)
self.failUnlessEqual(r0, c2.parent)
self.failUnlessEqual(2, c2.childIndex)

@@ -698,10 +719,10 @@ class TestCommonTree(unittest.TestCase):
error = False
try:
t.replaceChildren(0, 0, newChild)
-
+
except IndexError:
error = True
-
+
self.failUnless(error)


@@ -1157,7 +1178,7 @@ class TestTreeContext(unittest.TestCase):
try:
TreeParser._inContext(adaptor, self.tokenNames, node, "PRINT ... ... VEC")
self.fail()
-        except ValueError, exc:
+        except ValueError, exc:
expecting = "invalid syntax: ... ..."
found = str(exc)
self.assertEquals(expecting, found)
@@ -1218,5 +1239,94 @@ class TestTreeVisitor(unittest.TestCase):

self.assertEquals(expecting, found)

+
+class TestTreeIterator(unittest.TestCase):
+    tokens = [
+        "<invalid>", "<EOR>", "<DOWN>", "<UP>",
+        "A", "B", "C", "D", "E", "F", "G" ]
+
+    def testNode(self):
+        adaptor = CommonTreeAdaptor()
+        wiz = TreeWizard(adaptor, self.tokens)
+        t = wiz.create("A")
+        it = TreeIterator(t)
+        expecting = "A EOF"
+        found = self.toString(it)
+        self.assertEquals(expecting, found)
+
+
+    def testFlatAB(self):
+        adaptor = CommonTreeAdaptor()
+        wiz = TreeWizard(adaptor, self.tokens)
+        t = wiz.create("(nil A B)")
+        it = TreeIterator(t)
+        expecting = "nil DOWN A B UP EOF"
+        found = self.toString(it)
+        self.assertEquals(expecting, found)
+
+
+    def testAB(self):
+        adaptor = CommonTreeAdaptor()
+        wiz = TreeWizard(adaptor, self.tokens)
+        t = wiz.create("(A B)")
+        it = TreeIterator(t)
+        expecting = "A DOWN B UP EOF"
+        found = self.toString(it)
+        self.assertEquals(expecting, found)
+
+
+    def testABC(self):
+        adaptor = CommonTreeAdaptor()
+        wiz = TreeWizard(adaptor, self.tokens)
+        t = wiz.create("(A B C)")
+        it = TreeIterator(t)
+        expecting = "A DOWN B C UP EOF"
+        found = self.toString(it)
+        self.assertEquals(expecting, found)
+
+
+    def testVerticalList(self):
+        adaptor = CommonTreeAdaptor()
+        wiz = TreeWizard(adaptor, self.tokens)
+        t = wiz.create("(A (B C))")
+        it = TreeIterator(t)
+        expecting = "A DOWN B DOWN C UP UP EOF"
+        found = self.toString(it)
+        self.assertEquals(expecting, found)
+
+
+    def testComplex(self):
+        adaptor = CommonTreeAdaptor()
+        wiz = TreeWizard(adaptor, self.tokens)
+        t = wiz.create("(A (B (C D E) F) G)")
+        it = TreeIterator(t)
+        expecting = "A DOWN B DOWN C DOWN D E UP F UP G UP EOF"
+        found = self.toString(it)
+        self.assertEquals(expecting, found)
+
+
+    def testReset(self):
+        adaptor = CommonTreeAdaptor()
+        wiz = TreeWizard(adaptor, self.tokens)
+        t = wiz.create("(A (B (C D E) F) G)")
+        it = TreeIterator(t)
+        expecting = "A DOWN B DOWN C DOWN D E UP F UP G UP EOF"
+        found = self.toString(it)
+        self.assertEquals(expecting, found)
+
+        it.reset()
+        expecting = "A DOWN B DOWN C DOWN D E UP F UP G UP EOF"
+        found = self.toString(it)
+        self.assertEquals(expecting, found)
+
+
+    def toString(self, it):
+        buf = []
+        for n in it:
+            buf.append(str(n))
+
+        return ' '.join(buf)
+
+
if __name__ == "__main__":
unittest.main(testRunner=unittest.TextTestRunner(verbosity=2))
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Python/Python.stg b/tool/src/main/resources/org/antlr/codegen/templates/Python/Python.stg
index b2234eb..ad3b17c 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Python/Python.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Python/Python.stg
@@ -316,6 +316,7 @@ synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
# $ANTLR start "<ruleName>"
def <ruleName>_fragment(self, <ruleDescriptor.parameterScope:parameterScope(scope=it)>):
+    <ruleLabelDefs()>
<if(trace)>
self.traceIn("<ruleName>_fragment", <ruleDescriptor.index>)
try:
@@ -817,7 +818,7 @@ lexerStringRef(string,label,elementIndex) ::= <<
<if(label)>
<label>Start = self.getCharIndex()
self.match(<string>)
-<label> = CommonToken(input=self.input, type=INVALID_TOKEN_TYPE, channel=DEFAULT_CHANNEL, start=<label>Start, stop=self.getCharIndex()-1)
+<label> = <labelType>(input=self.input, type=INVALID_TOKEN_TYPE, channel=DEFAULT_CHANNEL, start=<label>Start, stop=self.getCharIndex()-1)
<else>
self.match(<string>)
<endif>
@@ -875,7 +876,7 @@ lexerRuleRef(rule,label,args,elementIndex,scope) ::= <<
<if(label)>
<label>Start<elementIndex> = self.getCharIndex()
self.<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">)
-<label> = CommonToken(
+<label> = <labelType>(
input=self.input,
type=INVALID_TOKEN_TYPE,
channel=DEFAULT_CHANNEL,
@@ -898,7 +899,7 @@ lexerMatchEOF(label,elementIndex) ::= <<
<if(label)>
<label>Start<elementIndex> = self.getCharIndex()
self.match(EOF)
-<label> = CommonToken(input=self.input, type=EOF, channel=DEFAULT_CHANNEL, start=<label>Start<elementIndex>, stop=self.getCharIndex()-1)
+<label> = <labelType>(input=self.input, type=EOF, channel=DEFAULT_CHANNEL, start=<label>Start<elementIndex>, stop=self.getCharIndex()-1)
<else>
self.match(EOF)
<endif>

