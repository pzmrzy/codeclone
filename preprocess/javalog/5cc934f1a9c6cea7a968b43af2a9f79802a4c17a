commit 5cc934f1a9c6cea7a968b43af2a9f79802a4c17a
Author:     acondit <acondit@parrt.spork>
AuthorDate: Tue May 17 10:16:41 2011 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Tue May 17 10:16:41 2011 -0800

More work on ANTLR3.4 revision and XCode4 LLVM2.0 compiler

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8527]

diff --git a/runtime/ObjC/Framework/ANTLRBaseTree.h b/runtime/ObjC/Framework/ANTLRBaseTree.h
index edb8075..1139cd0 100755
--- a/runtime/ObjC/Framework/ANTLRBaseTree.h
+++ b/runtime/ObjC/Framework/ANTLRBaseTree.h
@@ -143,7 +143,7 @@
- (void) freshenParentAndChildIndexes;
- (void) freshenParentAndChildIndexes:(NSInteger) offset;
- (void) sanityCheckParentAndChildIndexes;
-- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>) parent At:(NSInteger) i;
+- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>)parent At:(NSInteger) i;

- (NSInteger) getChildIndex;
- (void) setChildIndex:(NSInteger)i;
diff --git a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m b/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m
index 245261c..ea95286 100644
--- a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m
+++ b/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m
@@ -251,7 +251,7 @@

- (NSInteger) getType:(ANTLRCommonTree *) t
{
-    return t.type;
+    return [t type];
}

- (void) setType:(id)t Type:(NSInteger)type
@@ -273,7 +273,7 @@

- (NSString *)getText:(ANTLRCommonTree *)t
{
-    return t.text;
+    return [t text];
}

- (void) setText:(id)t Text:(NSString *)text
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m b/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m
index 651a5d9..7609698 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m
+++ b/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m
@@ -135,11 +135,11 @@
return [(id<ANTLRBaseTree>)t getTokenStopIndex];
}

-- (NSString *)getText:(id<ANTLRBaseTree>)t
+- (NSString *)getText:(ANTLRCommonTree *)t
{
if ( t == nil )
return nil;
-    return [(id<ANTLRBaseTree>) t text];
+    return t.token.text;
}

- (void)setText:(id<ANTLRBaseTree>)t Text:(NSString *)text
@@ -148,11 +148,11 @@
return;
}

-- (NSInteger)getType:(id<ANTLRBaseTree>)t
+- (NSInteger)getType:(ANTLRCommonTree *)t
{
if ( t==nil )
return ANTLRTokenTypeInvalid;
-    return [(id<ANTLRBaseTree>) t type];
+    return t.token.type;
}

- (void) setType:(id<ANTLRBaseTree>)t Type:(NSInteger)tokenType
@@ -168,7 +168,7 @@
- (id<ANTLRToken>) getToken:(ANTLRCommonTree *) t
{
if ( [t isKindOfClass:[ANTLRCommonTree class]] ) {
-        return [t getToken];
+        return t.token;
}
return nil; // no idea what to do
}
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.h b/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.h
index 1e57633..52efc0f 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.h
+++ b/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.h
@@ -76,7 +76,7 @@ NSInteger level;
*/
- (id) nextElement;

-- (BOOL) isEOF:(id<ANTLRBaseTree>) o;
+- (BOOL) isEOF:(id<ANTLRBaseTree>) obj;
- (void) setUniqueNavigationNodes:(BOOL) uniqueNavigationNodes;

- (id) getTreeSource;
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m
index 6ad86e4..23eddee 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m
+++ b/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m
@@ -29,6 +29,7 @@
#import "ANTLRIntStream.h"
#import "ANTLRCharStream.h"
#import "AMutableArray.h"
+#import "ANTLRCommonTreeAdaptor.h"

#ifndef DEBUG_DEALLOC
#define DEBUG_DEALLOC
@@ -54,9 +55,9 @@
- (id) initWithTree:(ANTLRCommonTree *)theTree
{
if ((self = [super init]) != nil ) {
-        navigationNodeEOF = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain]; // set EOF
-        root = [theTree retain];
adaptor = [[ANTLRCommonTreeAdaptor newTreeAdaptor] retain];
+        root = [theTree retain];
+        navigationNodeEOF = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain]; // set EOF
it = [[ANTLRTreeIterator newANTRLTreeIteratorWithAdaptor:adaptor andTree:root] retain];
calls = [[ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE] retain];
/** Tree (nil A B C) trees like flat A B C streams */
@@ -70,8 +71,8 @@
{
if ((self = [super init]) != nil ) {
adaptor = [anAdaptor retain];
-        navigationNodeEOF = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain]; // set EOF
root = [theTree retain];
+        navigationNodeEOF = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain]; // set EOF
//    it = [root objectEnumerator];
it = [[ANTLRTreeIterator newANTRLTreeIteratorWithAdaptor:adaptor andTree:root] retain];
calls = [[ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE] retain];
@@ -229,14 +230,14 @@
{
[self reset];
NSMutableString *buf = [NSMutableString stringWithCapacity:5];
-    id o = [self LT:1];
-    NSInteger type = [adaptor getType:o];
+    id obj = [self LT:1];
+    NSInteger type = [adaptor getType:obj];
while ( type != ANTLRTokenTypeEOF ) {
[buf appendString:@" "];
[buf appendString:[NSString stringWithFormat:@"%d", type]];
[self consume];
-        o = [self LT:1];
-        type = [adaptor getType:o];
+        obj = [self LT:1];
+        type = [adaptor getType:obj];
}
return buf;
}
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m
index acf9cf8..37f55de 100644
--- a/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m
+++ b/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m
@@ -124,7 +124,7 @@
- (NSInteger) LA:(NSUInteger) i
{
id<ANTLRBaseTree> node = [self LT:1];
-	return [node getType];
+	return node.type;
}

- (NSUInteger) mark
diff --git a/runtime/ObjC/Framework/ANTLRFastQueue.h b/runtime/ObjC/Framework/ANTLRFastQueue.h
index 7de4f51..f5ba582 100644
--- a/runtime/ObjC/Framework/ANTLRFastQueue.h
+++ b/runtime/ObjC/Framework/ANTLRFastQueue.h
@@ -51,7 +51,7 @@

- (void) reset;
- (id) remove;
-- (void) addObject:(id) o;
+- (void) addObject:(id) obj;
- (NSUInteger) count;
- (NSUInteger) size;
- (NSUInteger) range;
diff --git a/runtime/ObjC/Framework/ANTLRFastQueue.m b/runtime/ObjC/Framework/ANTLRFastQueue.m
index 4fb5c9b..6944b6d 100644
--- a/runtime/ObjC/Framework/ANTLRFastQueue.m
+++ b/runtime/ObjC/Framework/ANTLRFastQueue.m
@@ -91,19 +91,19 @@

- (id) remove
{
-	id o = [self objectAtIndex:0];
+	id obj = [self objectAtIndex:0];
p++;
// check to see if we have hit the end of the buffer
if ( p == [data count] ) {
// if we have, then we need to clear it out
[self clear];
}
-	return o;
+	return obj;
}

-- (void) addObject:(id) o
+- (void) addObject:(id) obj
{
-    [data addObject:o];
+    [data addObject:obj];
}

- (NSUInteger) count
diff --git a/runtime/ObjC/Framework/ANTLRHashRule.m b/runtime/ObjC/Framework/ANTLRHashRule.m
index 478abaf..71fede8 100644
--- a/runtime/ObjC/Framework/ANTLRHashRule.m
+++ b/runtime/ObjC/Framework/ANTLRHashRule.m
@@ -164,7 +164,7 @@
NSNumber *stopIndex;
NSInteger anIndex;

-    anIndex = ( aStartIndex >= BuffSize ) ? aStartIndex %= BuffSize : aStartIndex;
+    anIndex = ( aStartIndex >= BuffSize ) ? aStartIndex % BuffSize : aStartIndex;
if ((aRule = ptrBuffer[anIndex]) == nil) {
return nil;
}
@@ -198,7 +198,7 @@
NSInteger anIndex;
NSInteger aMatchIndex;

-    anIndex = (aStartIndex >= BuffSize) ? aStartIndex %= BuffSize : aStartIndex;
+    anIndex = (aStartIndex >= BuffSize) ? aStartIndex % BuffSize : aStartIndex;
aRule = ptrBuffer[anIndex];
if ( aRule == nil ) {
aRule = [ANTLRRuleMemo newANTLRRuleMemoWithStartIndex:[NSNumber numberWithInteger:aStartIndex]
@@ -259,7 +259,7 @@
{
NSInteger Index;

-    Index = ( anIndex >= BuffSize ) ? anIndex %= BuffSize : anIndex;
+    Index = ( anIndex >= BuffSize ) ? anIndex % BuffSize : anIndex;
if (aRule != ptrBuffer[Index]) {
if (ptrBuffer[Index] != nil) {
[ptrBuffer[Index] release];
@@ -273,7 +273,7 @@
{
NSInteger anIdx;

-    anIdx = ( anIndex >= BuffSize ) ? anIndex %= BuffSize : anIndex;
+    anIdx = ( anIndex >= BuffSize ) ? anIndex % BuffSize : anIndex;
return ptrBuffer[anIdx];
}

diff --git a/runtime/ObjC/Framework/ANTLRLookaheadStream.h b/runtime/ObjC/Framework/ANTLRLookaheadStream.h
index 8b625cb..3ec121e 100644
--- a/runtime/ObjC/Framework/ANTLRLookaheadStream.h
+++ b/runtime/ObjC/Framework/ANTLRLookaheadStream.h
@@ -51,7 +51,7 @@
@property (assign, getter=getMarkDepth, setter=setMarkDepth:) NSInteger markDepth;
@property (retain) id prevElement;

-- (id) initWithEOF:(id) o;
+- (id) initWithEOF:(id) obj;
- (id) nextElement;
- (id) remove;
- (void) consume;
diff --git a/runtime/ObjC/Framework/ANTLRLookaheadStream.m b/runtime/ObjC/Framework/ANTLRLookaheadStream.m
index a5ef8bd..fc1a720 100644
--- a/runtime/ObjC/Framework/ANTLRLookaheadStream.m
+++ b/runtime/ObjC/Framework/ANTLRLookaheadStream.m
@@ -46,7 +46,8 @@

-(id) init
{
-	if ((self = [super init]) != nil) {
+	self = [super init];
+	if ( self != nil ) {
eof = [[ANTLRCommonToken eofToken] retain];
eofElementIndex = UNITIALIZED_EOF_ELEMENT_INDEX;
markDepth = 0;
@@ -55,7 +56,7 @@
return self;
}

--(id) initWithEOF:(id) obj
+-(id) initWithEOF:(id)obj
{
if ((self = [super init]) != nil) {
self.eof = [obj retain];
@@ -80,15 +81,15 @@

- (id) remove
{
-    id o = [self objectAtIndex:0];
+    id obj = [self objectAtIndex:0];
p++;
// have we hit end of buffer and not backtracking?
if ( p == [data count] && markDepth==0 ) {
// if so, it's an opportunity to start filling at index 0 again
[self clear]; // size goes to 0, but retains memory
}
-    [o release];
-    return o;
+    [obj release];
+    return obj;
}

-(void) consume
@@ -101,21 +102,22 @@
-(void) sync:(NSInteger) need
{
NSInteger n = (p + need - 1) - [data count] + 1;
-	if (n > 0) {
+	if ( n > 0 ) {
[self fill:n];
}
}

-(void) fill:(NSInteger) n
{
+    id obj;
for (NSInteger i = 1; i <= n; i++) {
-		id o = [self nextElement];
-		if (o == eof) {
+		obj = [self nextElement];
+		if ( obj == eof ) {
[data addObject:self.eof];
eofElementIndex = [data count] - 1;
}
else {
-			[data addObject:o];
+			[data addObject:obj];
}
}
}
diff --git a/runtime/ObjC/Framework/ANTLRParser.m b/runtime/ObjC/Framework/ANTLRParser.m
index 5f0d3d5..df559b2 100644
--- a/runtime/ObjC/Framework/ANTLRParser.m
+++ b/runtime/ObjC/Framework/ANTLRParser.m
@@ -107,7 +107,7 @@
tokenText = [NSString stringWithFormat:@"<missing %@>\n",[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:expectedTokenType]];
ANTLRCommonToken *t = [[ANTLRCommonToken newToken:expectedTokenType Text:tokenText] retain];
ANTLRCommonToken *current = [anInput LT:1];
-    if ( [current type] == ANTLRTokenTypeEOF ) {
+    if ( current.type == ANTLRTokenTypeEOF ) {
current = [anInput LT:-1];
}
t.line = current.line;
diff --git a/runtime/ObjC/Framework/ANTLRStreamEnumerator.h b/runtime/ObjC/Framework/ANTLRStreamEnumerator.h
index 9462ccd..9e102f2 100644
--- a/runtime/ObjC/Framework/ANTLRStreamEnumerator.h
+++ b/runtime/ObjC/Framework/ANTLRStreamEnumerator.h
@@ -39,7 +39,7 @@
AMutableArray *nodes;
}

--(id) initWithNodes:(AMutableArray *) n andEOF:(id) o;
+-(id) initWithNodes:(AMutableArray *) n andEOF:(id) obj;
-(BOOL) hasNext;

@property NSInteger i;
diff --git a/runtime/ObjC/Framework/ANTLRStreamEnumerator.m b/runtime/ObjC/Framework/ANTLRStreamEnumerator.m
index e1a426f..103646e 100644
--- a/runtime/ObjC/Framework/ANTLRStreamEnumerator.m
+++ b/runtime/ObjC/Framework/ANTLRStreamEnumerator.m
@@ -44,13 +44,13 @@
return self;
}

--(id) initWithNodes:(AMutableArray *) n andEOF:(id) o
+-(id) initWithNodes:(AMutableArray *) n andEOF:(id) obj
{
self = [self init];
if (self)
{
nodes = n;
-		eof = o;
+		eof = obj;
}
return self;
}
diff --git a/runtime/ObjC/Framework/ANTLRTreeIterator.m b/runtime/ObjC/Framework/ANTLRTreeIterator.m
index 7f76c3b..b760f88 100644
--- a/runtime/ObjC/Framework/ANTLRTreeIterator.m
+++ b/runtime/ObjC/Framework/ANTLRTreeIterator.m
@@ -47,38 +47,49 @@

- (id) init
{
-	self = [super init];
+    self = [super init];
if ( self != nil ) {
-		firstTime = YES;
-		nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
-		down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-		up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-		eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-		tree = eof;
-		root = eof;
-	}
-	return self;
+        firstTime = YES;
+        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+        tree = eof;
+        root = eof;
+    }
+    return self;
}

-(id) initWithTree:(id<ANTLRBaseTree>) t
{
-	return [self initWithTreeAdaptor:[ANTLRCommonTreeAdaptor newTreeAdaptor] andTree:t];
+    self = [super init];
+    if ( self != nil ) {
+        firstTime = YES;
+        adaptor = [[ANTLRCommonTreeAdaptor newTreeAdaptor] retain];
+        tree = [t retain];
+        root = t;
+        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+    }
+    return self;
}

-(id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)a andTree:(id<ANTLRBaseTree>)t
{
self = [super init];
if ( self != nil ) {
-		firstTime = YES;
-		adaptor = [a retain];
-		tree = [t retain];
-		root = t;
-		nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
-		down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-		up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-		eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-	}
-	return self;
+        firstTime = YES;
+        adaptor = [a retain];
+        tree = [t retain];
+        root = t;
+        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+    }
+    return self;
}

- (void)dealloc
@@ -89,7 +100,7 @@
if ( adaptor ) [adaptor release];
if ( nodes ) [nodes release];
if ( tree && tree != eof ) [tree release];
-    if ( root && root != tree && root != eof ) [root release];
+    if ( root && root != eof && root != tree ) [root release];
if ( down ) [down release];
if ( up ) [up release];
if ( eof ) [eof release];
@@ -98,79 +109,79 @@

- (void)reset
{
-	firstTime = YES;
-	tree = root;
-	[nodes clear];
+    firstTime = YES;
+    tree = root;
+    [nodes clear];
}

-(BOOL) hasNext
{
-	if ( firstTime ) {
+    if ( firstTime ) {
return root != nil;
}
-	if ( nodes && [nodes size] > 0) {
+    if ( nodes && [nodes size] > 0) {
return YES;
}
-	if ( tree == nil ) {
+    if ( tree == nil ) {
return NO;
}
-	if ( [adaptor getChildCount:tree] > 0 ) {
+    if ( [adaptor getChildCount:tree] > 0 ) {
return YES;
}
-	return [adaptor getParent:tree] != nil;
+    return [adaptor getParent:tree] != nil;
}

-(id) nextObject
{
-	// is this the first time we are using this method?
-	if ( firstTime ) {
-		firstTime = NO;
-		if ( [adaptor getChildCount:tree] == 0 ) {
-			[nodes addObject:eof];
-			return tree;
-		}
-		return tree;
-	}
-	// do we have any objects queued up?
-	if ( nodes && [nodes size] > 0 ) {
-		return [nodes remove];
-	}
-	// no nodes left?
-	if ( tree == nil ) {
-		return eof;
-	}
-	if ( [adaptor getChildCount:tree] > 0 ) {
-		tree = [adaptor getChild:tree At:0];
-		[nodes addObject:tree]; // real node is next after down
-		return self.down;
-	}
-	// if no children, look for next sibling of ancestor
-	id<ANTLRBaseTree> parent = [adaptor getParent:tree];
-	while (parent != nil && ([adaptor getChildIndex:tree] + 1) >= [adaptor getChildCount:parent]) {
-		[nodes addObject:up];
-		tree = parent;
-		parent = [adaptor getParent:tree];
-	}
-	if ( parent == nil ) {
-		tree = nil;
-		[nodes addObject:self.eof];
-		return [nodes remove];
-	}
-	// must have found a node with an unvisited sibling
-	// move to it and return it
-	NSInteger nextSiblingIndex = [adaptor getChildIndex:tree] + 1;
-	tree = [adaptor getChild:parent At:nextSiblingIndex];
-	[nodes addObject:tree];
-	return [nodes remove];
+    // is this the first time we are using this method?
+    if ( firstTime ) {
+        firstTime = NO;
+        if ( [adaptor getChildCount:tree] == 0 ) {
+            [nodes addObject:eof];
+            return tree;
+        }
+        return tree;
+    }
+    // do we have any objects queued up?
+    if ( nodes && [nodes size] > 0 ) {
+        return [nodes remove];
+    }
+    // no nodes left?
+    if ( tree == nil ) {
+        return eof;
+    }
+    if ( [adaptor getChildCount:tree] > 0 ) {
+        tree = [adaptor getChild:tree At:0];
+        [nodes addObject:tree]; // real node is next after down
+        return self.down;
+    }
+    // if no children, look for next sibling of ancestor
+    id<ANTLRBaseTree> parent = [adaptor getParent:tree];
+    while (parent != nil && ([adaptor getChildIndex:tree] + 1) >= [adaptor getChildCount:parent]) {
+        [nodes addObject:up];
+        tree = parent;
+        parent = [adaptor getParent:tree];
+    }
+    if ( parent == nil ) {
+        tree = nil;
+        [nodes addObject:self.eof];
+        return [nodes remove];
+    }
+    // must have found a node with an unvisited sibling
+    // move to it and return it
+    NSInteger nextSiblingIndex = [adaptor getChildIndex:tree] + 1;
+    tree = [adaptor getChild:parent At:nextSiblingIndex];
+    [nodes addObject:tree];
+    return [nodes remove];
}

-(NSArray *) allObjects
{
-	AMutableArray *array = [AMutableArray arrayWithCapacity:10];
-	while ( [self hasNext] ) {
-		[array addObject:[self nextObject]];
-	}
-	return array;
+    AMutableArray *array = [AMutableArray arrayWithCapacity:10];
+    while ( [self hasNext] ) {
+        [array addObject:[self nextObject]];
+    }
+    return array;
}

- (void)remove
diff --git a/runtime/ObjC/Framework/ANTLRTreeWizard.m b/runtime/ObjC/Framework/ANTLRTreeWizard.m
index 15165ec..78131a8 100644
--- a/runtime/ObjC/Framework/ANTLRTreeWizard.m
+++ b/runtime/ObjC/Framework/ANTLRTreeWizard.m
@@ -45,7 +45,6 @@
{
if ((self = [super init]) != nil) {
action = anAction;
-        if ( action ) [action retain];
actor = anActor;
if ( actor ) [actor retain];
object1 = anObject1;
@@ -61,7 +60,6 @@
#ifdef DEBUG_DEALLOC
NSLog( @"called dealloc in ANTLRVisitor" );
#endif
-    if ( action ) [action release];
if ( actor ) [actor release];
if ( object1 ) [object1 release];
if ( object2 ) [object2 release];
@@ -446,7 +444,7 @@
ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
ANTLRTreePatternParser *parser =
[ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer Wizard:self Adaptor:[ANTLRTreePatternTreeAdaptor newTreeAdaptor]];
-    ANTLRCommonTree * tpattern = [parser pattern];
+    ANTLRCommonTree *tpattern = [parser pattern];
// don't allow invalid patterns
if ( tpattern == nil ||
[tpattern isNil] ||
@@ -501,7 +499,7 @@
ANTLRTreePatternParser *parser = [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer
Wizard:self
Adaptor:[ANTLRTreePatternTreeAdaptor newTreeAdaptor]];
-    ANTLRCommonTree * tpattern = [parser pattern];
+    ANTLRCommonTree *tpattern = [parser pattern];
/*
System.out.println("t="+((Tree)t).toStringTree());
System.out.println("scant="+tpattern.toStringTree());
diff --git a/runtime/ObjC/Framework/ArrayIterator.m b/runtime/ObjC/Framework/ArrayIterator.m
index 0ae5317..5d01527 100644
--- a/runtime/ObjC/Framework/ArrayIterator.m
+++ b/runtime/ObjC/Framework/ArrayIterator.m
@@ -25,6 +25,7 @@
*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
*  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
+#import "AMutableArray.h"
#import "ArrayIterator.h"
#import "ANTLRRuntimeException.h"


