commit 60b26d052234ad0eab0b76cac4c561d84cda72c9
Author:     acondit <acondit@parrt.spork>
AuthorDate: Sat May 7 08:14:53 2011 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Sat May 7 08:14:53 2011 -0800

Changes to match ANTLR3.4 revision.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8419]

diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleC.tokens b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleC.tokens
index 67e632b..965ef1f 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleC.tokens
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleC.tokens
@@ -1,23 +1,23 @@
-K_ID=11
-K_RCURLY=19
-K_RCURVE=14
-K_INT=25
-K_EQEQ=22
-K_FOR=20
-FUNC_HDR=6
-FUNC_DEF=8
-K_SEMICOLON=10
-K_INT_TYPE=15
-FUNC_DECL=7
-K_COMMA=13
-ARG_DEF=5
-K_LCURLY=18
+ARG_DEF=4
+BLOCK=5
+FUNC_DECL=6
+FUNC_DEF=7
+FUNC_HDR=8
+K_CHAR=9
+K_COMMA=10
+K_EQ=11
+K_EQEQ=12
+K_FOR=13
+K_ID=14
+K_INT=15
+K_INT_TYPE=16
+K_LCURLY=17
+K_LCURVE=18
+K_LT=19
+K_PLUS=20
+K_RCURLY=21
+K_RCURVE=22
+K_SEMICOLON=23
+K_VOID=24
+VAR_DEF=25
WS=26
-K_EQ=21
-BLOCK=9
-K_LT=23
-K_LCURVE=12
-K_CHAR=16
-K_VOID=17
-VAR_DEF=4
-K_PLUS=24
diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCLexer.h b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCLexer.h
index fee8681..6c33456 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCLexer.h
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCLexer.h
@@ -1,75 +1,73 @@
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 SimpleC.g 2010-08-25 11:11:23
+// $ANTLR ${project.version} ${buildNumber} SimpleC.g 2011-05-06 15:09:17

/* =============================================================================
* Standard antlr3 OBJC runtime definitions
*/
#import <Cocoa/Cocoa.h>
-#import "antlr3.h"
+#import <ANTLR/ANTLR.h>
/* End of standard antlr3 runtime definitions
* =============================================================================
*/

/* Start cyclicDFAInterface */
-#pragma mark Cyclic DFA interface start DFA4
-@interface DFA4 : ANTLRDFA {
-}
-+ newDFA4WithRecognizer:(ANTLRBaseRecognizer *)theRecognizer;
-- initWithRecognizer:(ANTLRBaseRecognizer *)recognizer;
-@end /* end of DFA4 interface  */
-
-#pragma mark Cyclic DFA interface end DFA4

#pragma mark Rule return scopes start
#pragma mark Rule return scopes end
#pragma mark Tokens
-#define K_ID 11
-#define K_RCURLY 19
-#define K_RCURVE 14
-#define K_INT 25
-#define K_EQEQ 22
-#define K_FOR 20
-#define FUNC_HDR 6
-#define FUNC_DEF 8
+#ifdef EOF
+#undef EOF
+#endif
#define EOF -1
-#define K_SEMICOLON 10
-#define K_INT_TYPE 15
-#define FUNC_DECL 7
-#define K_COMMA 13
-#define ARG_DEF 5
-#define K_LCURLY 18
+#define ARG_DEF 4
+#define BLOCK 5
+#define FUNC_DECL 6
+#define FUNC_DEF 7
+#define FUNC_HDR 8
+#define K_CHAR 9
+#define K_COMMA 10
+#define K_EQ 11
+#define K_EQEQ 12
+#define K_FOR 13
+#define K_ID 14
+#define K_INT 15
+#define K_INT_TYPE 16
+#define K_LCURLY 17
+#define K_LCURVE 18
+#define K_LT 19
+#define K_PLUS 20
+#define K_RCURLY 21
+#define K_RCURVE 22
+#define K_SEMICOLON 23
+#define K_VOID 24
+#define VAR_DEF 25
#define WS 26
-#define K_EQ 21
-#define BLOCK 9
-#define K_LCURVE 12
-#define K_LT 23
-#define K_CHAR 16
-#define K_VOID 17
-#define VAR_DEF 4
-#define K_PLUS 24
+/* interface lexer class */
@interface SimpleCLexer : ANTLRLexer { // line 283
-DFA4 *dfa4;
-// start of actions.lexer.memVars
-// start of action-actionScope-memVars
+/* ObjC start of actions.lexer.memVars */
+/* ObjC end of actions.lexer.memVars */
}
++ (void) initialize;
+ (SimpleCLexer *)newSimpleCLexerWithCharStream:(id<ANTLRCharStream>)anInput;
-
-- (void)mK_FOR;
-- (void)mK_CHAR;
-- (void)mK_INT_TYPE;
-- (void)mK_VOID;
-- (void)mK_ID;
-- (void)mK_INT;
-- (void)mK_LCURVE;
-- (void)mK_RCURVE;
-- (void)mK_PLUS;
-- (void)mK_COMMA;
-- (void)mK_SEMICOLON;
-- (void)mK_LT;
-- (void)mK_EQ;
-- (void)mK_EQEQ;
-- (void)mK_LCURLY;
-- (void)mK_RCURLY;
-- (void)mWS;
-- (void)mTokens;
+/* ObjC start actions.lexer.methodsDecl */
+/* ObjC end actions.lexer.methodsDecl */
+- (void) mK_FOR ;
+- (void) mK_CHAR ;
+- (void) mK_INT_TYPE ;
+- (void) mK_VOID ;
+- (void) mK_ID ;
+- (void) mK_INT ;
+- (void) mK_LCURVE ;
+- (void) mK_RCURVE ;
+- (void) mK_PLUS ;
+- (void) mK_COMMA ;
+- (void) mK_SEMICOLON ;
+- (void) mK_LT ;
+- (void) mK_EQ ;
+- (void) mK_EQEQ ;
+- (void) mK_LCURLY ;
+- (void) mK_RCURLY ;
+- (void) mWS ;
+- (void) mTokens ;

@end /* end of SimpleCLexer interface */
+
diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCLexer.m b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCLexer.m
index adb9afa..ce506e1 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCLexer.m
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCLexer.m
@@ -1,43 +1,18 @@
/** \file
- *  This OBJC source file was generated by $ANTLR version 3.2 Aug 24, 2010 10:45:57
+ *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
*
*     -  From the grammar source file : SimpleC.g
- *     -                            On : 2010-08-25 11:11:23
- *     -                 for the lexer : SimpleCLexerLexer *
- * Editing it, at least manually, is not wise.
+ *     -                            On : 2011-05-06 15:09:17
+ *     -                 for the lexer : SimpleCLexerLexer
+ *
+ * Editing it, at least manually, is not wise.
*
* ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
*
*
*/
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 SimpleC.g 2010-08-25 11:11:23
+// $ANTLR ${project.version} ${buildNumber} SimpleC.g 2011-05-06 15:09:17
+

/* -----------------------------------------
* Include the ANTLR3 generated header file.
@@ -47,131 +22,10 @@


/* ============================================================================= */
-
/* =============================================================================
* Start of recognizer
*/

-#pragma mark Cyclic DFA implementation start DFA4
-@implementation DFA4
-const static NSInteger dfa4_eot[33] =
-    {-1,5,5,5,5,-1,-1,-1,-1,-1,-1,-1,-1,22,-1,-1,-1,5,5,5,5,-1,-1,27,5,29,
-     5,-1,31,-1,32,-1,-1};
-const static NSInteger dfa4_eof[33] =
-    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
-const static unichar dfa4_min[33] =
-    {9,111,104,110,111,0,0,0,0,0,0,0,0,61,0,0,0,114,97,116,105,0,0,48,114,
-     48,100,0,48,0,48,0,0};
-const static unichar dfa4_max[33] =
-    {125,111,104,110,111,0,0,0,0,0,0,0,0,61,0,0,0,114,97,116,105,0,0,122,
-     114,122,100,0,122,0,122,0,0};
-const static NSInteger dfa4_accept[33] =
-    {-1,-1,-1,-1,-1,5,6,7,8,9,10,11,12,-1,15,16,17,-1,-1,-1,-1,14,13,-1,
-     -1,-1,-1,1,-1,3,-1,2,4};
-const static NSInteger dfa4_special[33] =
-    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
-const static NSInteger dfa4_transition[] = {};
-const static NSInteger dfa4_transition0[] = {5, 5, 5, 5, 5, 5, 5, 5, 5,
- 5, -1, -1, -1, -1, -1, -1, -1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
- 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, -1, -1, -1, -1, 5, -1, 5, 5, 5, 5,
- 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5};
-const static NSInteger dfa4_transition1[] = {21};
-const static NSInteger dfa4_transition2[] = {16, 16, -1, -1, 16, -1, -1,
- -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 16, -1,
- -1, -1, -1, -1, -1, -1, 7, 8, -1, 9, 10, -1, -1, -1, 6, 6, 6, 6, 6, 6,
- 6, 6, 6, 6, -1, 11, 12, 13, -1, -1, -1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
- 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, -1, -1, -1, -1, 5, -1, 5,
- 5, 2, 5, 5, 1, 5, 5, 3, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5, 5,
- 5, 14, -1, 15};
-const static NSInteger dfa4_transition3[] = {19};
-const static NSInteger dfa4_transition4[] = {28};
-const static NSInteger dfa4_transition5[] = {18};
-const static NSInteger dfa4_transition6[] = {24};
-const static NSInteger dfa4_transition7[] = {23};
-const static NSInteger dfa4_transition8[] = {20};
-const static NSInteger dfa4_transition9[] = {30};
-const static NSInteger dfa4_transition10[] = {26};
-const static NSInteger dfa4_transition11[] = {17};
-const static NSInteger dfa4_transition12[] = {25};
-
-
-+ () newDFA4WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
-{
-    return [[[DFA4 alloc] initWithRecognizer:aRecognizer] retain];
-}
-
-- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
-{
-    if ((self = [super initWithRecognizer:theRecognizer]) != nil) {
-        decisionNumber = 4;
-        eot = dfa4_eot;
-        eof = dfa4_eof;
-        min = dfa4_min;
-        max = dfa4_max;
-        accept = dfa4_accept;
-        special = dfa4_special;
-        if (!(transition = calloc(33, sizeof(void*)))) {
-            [self release];
-            return nil;
-        }
-        len = 33;
-        transition[0] = dfa4_transition2;
-        transition[1] = dfa4_transition11;
-        transition[2] = dfa4_transition5;
-        transition[3] = dfa4_transition3;
-        transition[4] = dfa4_transition8;
-        transition[5] = dfa4_transition;
-        transition[6] = dfa4_transition;
-        transition[7] = dfa4_transition;
-        transition[8] = dfa4_transition;
-        transition[9] = dfa4_transition;
-        transition[10] = dfa4_transition;
-        transition[11] = dfa4_transition;
-        transition[12] = dfa4_transition;
-        transition[13] = dfa4_transition1;
-        transition[14] = dfa4_transition;
-        transition[15] = dfa4_transition;
-        transition[16] = dfa4_transition;
-        transition[17] = dfa4_transition7;
-        transition[18] = dfa4_transition6;
-        transition[19] = dfa4_transition12;
-        transition[20] = dfa4_transition10;
-        transition[21] = dfa4_transition;
-        transition[22] = dfa4_transition;
-        transition[23] = dfa4_transition0;
-        transition[24] = dfa4_transition4;
-        transition[25] = dfa4_transition0;
-        transition[26] = dfa4_transition9;
-        transition[27] = dfa4_transition;
-        transition[28] = dfa4_transition0;
-        transition[29] = dfa4_transition;
-        transition[30] = dfa4_transition0;
-        transition[31] = dfa4_transition;
-        transition[32] = dfa4_transition;
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-    free(transition);
-    [super dealloc];
-}
-
-- (NSString *) description
-{
-    return @"1:1: Tokens : ( K_FOR | K_CHAR | K_INT_TYPE | K_VOID | K_ID | K_INT | K_LCURVE | K_RCURVE | K_PLUS | K_COMMA | K_SEMICOLON | K_LT | K_EQ | K_EQEQ | K_LCURLY | K_RCURLY | WS );";
-}
-
-
-@end /* end DFA4 implementation */
-
-#pragma mark Cyclic DFA implementation end DFA4
-
-
-
/** As per Terence: No returns for lexer rules! */
@implementation SimpleCLexer // line 330

@@ -192,28 +46,29 @@ const static NSInteger dfa4_transition12[] = {25};

- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
{
-    if ((self = [super initWithCharStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:18+1]]) != nil) {
-
-        dfa4 = [DFA4 newDFA4WithRecognizer:self];
+    self = [super initWithCharStream:anInput State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:18+1] retain]];
+    if ( self != nil ) {
}
return self;
}

- (void) dealloc
{
-    [dfa4 release];
[super dealloc];
}

-/* Start of actions.lexer.methods */
-/* start methods() */
+/* ObjC Start of actions.lexer.methods */
+/* ObjC end of actions.lexer.methods */
+/* ObjC start methods() */
+/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "K_FOR"
- (void) mK_FOR
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_FOR;
@@ -222,28 +77,31 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:91:9: 'for' // alt
{
[self matchString:@"for"];
-          /* element() */
-         /* elements */
+
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_FOR"
+/* $ANTLR end "K_FOR" */

// $ANTLR start "K_CHAR"
- (void) mK_CHAR
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_CHAR;
@@ -252,28 +110,31 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:92:9: 'char' // alt
{
[self matchString:@"char"];
-          /* element() */
-         /* elements */
+
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_CHAR"
+/* $ANTLR end "K_CHAR" */

// $ANTLR start "K_INT_TYPE"
- (void) mK_INT_TYPE
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_INT_TYPE;
@@ -282,28 +143,31 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:93:14: 'int' // alt
{
[self matchString:@"int"];
-          /* element() */
-         /* elements */
+
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_INT_TYPE"
+/* $ANTLR end "K_INT_TYPE" */

// $ANTLR start "K_VOID"
- (void) mK_VOID
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_VOID;
@@ -312,28 +176,31 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:94:9: 'void' // alt
{
[self matchString:@"void"];
-          /* element() */
-         /* elements */
+
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_VOID"
+/* $ANTLR end "K_VOID" */

// $ANTLR start "K_ID"
- (void) mK_ID
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_ID;
@@ -343,16 +210,17 @@ const static NSInteger dfa4_transition12[] = {25};
{
if ((([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
[input consume];
-
} else {
-            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
[self recover:mse];
-            @throw mse;}
-          /* element() */
+            @throw mse;
+        }
+
+
do {
NSInteger alt1=2;
NSInteger LA1_0 = [input LA:1];
-            if ( ((LA1_0>='0' && LA1_0<='9')||(LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z')) ) {
+            if ( ((LA1_0 >= '0' && LA1_0 <= '9')||(LA1_0 >= 'A' && LA1_0 <= 'Z')||LA1_0=='_'||(LA1_0 >= 'a' && LA1_0 <= 'z')) ) {
alt1=1;
}

@@ -363,13 +231,13 @@ const static NSInteger dfa4_transition12[] = {25};
{
if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))||(([input LA:1] >= 'A') && ([input LA:1] <= 'Z'))||[input LA:1] == '_'||(([input LA:1] >= 'a') && ([input LA:1] <= 'z'))) {
[input consume];
-
} else {
-                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
[self recover:mse];
-                        @throw mse;}
-                      /* element() */
-                     /* elements */
+                        @throw mse;
+                    }
+
+
}
break;

@@ -378,43 +246,45 @@ const static NSInteger dfa4_transition12[] = {25};
}
} while (YES);
loop1: ;
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_ID"
+/* $ANTLR end "K_ID" */

// $ANTLR start "K_INT"
- (void) mK_INT
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_INT;
NSInteger _channel = ANTLRTokenChannelDefault;
-        id<ANTLRToken> *anInt=nil;
-        NSMutableArray *list_anInt=nil;
+        ANTLRCommonToken *anInt=nil;
+        AMutableArray *list_anInt=nil;
// SimpleC.g:99:7: ( (anInt+= ( '0' .. '9' ) )+ ) // ruleBlockSingleAlt
// SimpleC.g:99:9: (anInt+= ( '0' .. '9' ) )+ // alt
{
// SimpleC.g:99:14: (anInt+= ( '0' .. '9' ) )+ // positiveClosureBlock
-        NSInteger cnt2=0;
+        NSInteger cnt2 = 0;
do {
-            NSInteger alt2=2;
+            NSInteger alt2 = 2;
NSInteger LA2_0 = [input LA:1];
-            if ( ((LA2_0>='0' && LA2_0<='9')) ) {
+            if ( ((LA2_0 >= '0' && LA2_0 <= '9')) ) {
alt2=1;
}

@@ -423,50 +293,59 @@ const static NSInteger dfa4_transition12[] = {25};
case 1 : ;
// SimpleC.g:99:14: anInt+= ( '0' .. '9' ) // alt
{
-                    // SimpleC.g:99:16: ( '0' .. '9' ) // blockSingleAlt
-                    // SimpleC.g:99:17: '0' .. '9' // alt
-                    {
-                    [self matchRangeFromChar:'0' to:'9'];   /* element() */
-                     /* elements */
+                    anInt = [input LA:1];
+
+                    if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))) {
+                        [input consume];
+                    } else {
+                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
+                        mse.c = anInt;
+                        [self recover:mse];
+                        @throw mse;
}
-                      /* element() */
-                     /* elements */
+
+
}
break;

default :
if ( cnt2 >= 1 )
goto loop2;
-                    ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:2];
+                    ANTLREarlyExitException *eee =
+                        [ANTLREarlyExitException newException:input decisionNumber:2];
@throw eee;
}
cnt2++;
} while (YES);
loop2: ;
-          /* element() */
-        NSLog(@"%@", list_anInt);  /* element() */
-         /* elements */
+
+
+        NSLog(@"%@", list_anInt);
+
+
}

// token+rule list labels
[list_anInt release];

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_INT"
+/* $ANTLR end "K_INT" */

// $ANTLR start "K_LCURVE"
- (void) mK_LCURVE
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_LCURVE;
@@ -475,28 +354,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:102:12: '(' // alt
{
[self matchChar:'('];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_LCURVE"
+/* $ANTLR end "K_LCURVE" */

// $ANTLR start "K_RCURVE"
- (void) mK_RCURVE
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_RCURVE;
@@ -505,28 +386,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:103:12: ')' // alt
{
[self matchChar:')'];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_RCURVE"
+/* $ANTLR end "K_RCURVE" */

// $ANTLR start "K_PLUS"
- (void) mK_PLUS
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_PLUS;
@@ -535,28 +418,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:104:10: '+' // alt
{
[self matchChar:'+'];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_PLUS"
+/* $ANTLR end "K_PLUS" */

// $ANTLR start "K_COMMA"
- (void) mK_COMMA
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_COMMA;
@@ -565,28 +450,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:105:11: ',' // alt
{
[self matchChar:','];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_COMMA"
+/* $ANTLR end "K_COMMA" */

// $ANTLR start "K_SEMICOLON"
- (void) mK_SEMICOLON
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_SEMICOLON;
@@ -595,28 +482,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:106:15: ';' // alt
{
[self matchChar:';'];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_SEMICOLON"
+/* $ANTLR end "K_SEMICOLON" */

// $ANTLR start "K_LT"
- (void) mK_LT
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_LT;
@@ -625,28 +514,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:107:10: '<' // alt
{
[self matchChar:'<'];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_LT"
+/* $ANTLR end "K_LT" */

// $ANTLR start "K_EQ"
- (void) mK_EQ
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_EQ;
@@ -655,28 +546,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:108:10: '=' // alt
{
[self matchChar:'='];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_EQ"
+/* $ANTLR end "K_EQ" */

// $ANTLR start "K_EQEQ"
- (void) mK_EQEQ
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_EQEQ;
@@ -685,28 +578,31 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:109:10: '==' // alt
{
[self matchString:@"=="];
-          /* element() */
-         /* elements */
+
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_EQEQ"
+/* $ANTLR end "K_EQEQ" */

// $ANTLR start "K_LCURLY"
- (void) mK_LCURLY
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_LCURLY;
@@ -715,28 +611,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:110:12: '{' // alt
{
[self matchChar:'{'];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_LCURLY"
+/* $ANTLR end "K_LCURLY" */

// $ANTLR start "K_RCURLY"
- (void) mK_RCURLY
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = K_RCURLY;
@@ -745,28 +643,30 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:111:12: '}' // alt
{
[self matchChar:'}'];
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "K_RCURLY"
+/* $ANTLR end "K_RCURLY" */

// $ANTLR start "WS"
- (void) mWS
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = WS;
@@ -775,11 +675,11 @@ const static NSInteger dfa4_transition12[] = {25};
// SimpleC.g:113:9: ( ' ' | '\\t' | '\\r' | '\\n' )+ // alt
{
// SimpleC.g:113:9: ( ' ' | '\\t' | '\\r' | '\\n' )+ // positiveClosureBlock
-        NSInteger cnt3=0;
+        NSInteger cnt3 = 0;
do {
-            NSInteger alt3=2;
+            NSInteger alt3 = 2;
NSInteger LA3_0 = [input LA:1];
-            if ( ((LA3_0>='\t' && LA3_0<='\n')||LA3_0=='\r'||LA3_0==' ') ) {
+            if ( ((LA3_0 >= '\t' && LA3_0 <= '\n')||LA3_0=='\r'||LA3_0==' ') ) {
alt3=1;
}

@@ -790,183 +690,458 @@ const static NSInteger dfa4_transition12[] = {25};
{
if ((([input LA:1] >= '\t') && ([input LA:1] <= '\n'))||[input LA:1] == '\r'||[input LA:1] == ' ') {
[input consume];
-
} else {
-                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
[self recover:mse];
-                        @throw mse;}
-                      /* element() */
-                     /* elements */
+                        @throw mse;
+                    }
+
+
}
break;

default :
if ( cnt3 >= 1 )
goto loop3;
-                    ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:3];
+                    ANTLREarlyExitException *eee =
+                        [ANTLREarlyExitException newException:input decisionNumber:3];
@throw eee;
}
cnt3++;
} while (YES);
loop3: ;
-          /* element() */
-         _channel=99;   /* element() */
-         /* elements */
+
+
+         _channel=HIDDEN;
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "WS"
+/* $ANTLR end "WS" */

- (void) mTokens
{
// SimpleC.g:1:8: ( K_FOR | K_CHAR | K_INT_TYPE | K_VOID | K_ID | K_INT | K_LCURVE | K_RCURVE | K_PLUS | K_COMMA | K_SEMICOLON | K_LT | K_EQ | K_EQEQ | K_LCURLY | K_RCURLY | WS ) //ruleblock
NSInteger alt4=17;
-    alt4 = [dfa4 predict:input];
+    unichar charLA4 = [input LA:1];
+    switch (charLA4) {
+        case 'f': ;
+            {
+            NSInteger LA4_1 = [input LA:2];
+
+            if ( (LA4_1=='o') ) {
+                NSInteger LA4_17 = [input LA:3];
+
+                if ( (LA4_17=='r') ) {
+                    NSInteger LA4_23 = [input LA:4];
+
+                    if ( ((LA4_23 >= '0' && LA4_23 <= '9')||(LA4_23 >= 'A' && LA4_23 <= 'Z')||LA4_23=='_'||(LA4_23 >= 'a' && LA4_23 <= 'z')) ) {
+                        alt4=5;
+                    }
+                    else {
+                        alt4 = 1;
+                    }
+                }
+                else {
+                    alt4 = 5;
+                }
+            }
+            else {
+                alt4 = 5;
+            }
+            }
+            break;
+        case 'c': ;
+            {
+            NSInteger LA4_2 = [input LA:2];
+
+            if ( (LA4_2=='h') ) {
+                NSInteger LA4_18 = [input LA:3];
+
+                if ( (LA4_18=='a') ) {
+                    NSInteger LA4_24 = [input LA:4];
+
+                    if ( (LA4_24=='r') ) {
+                        NSInteger LA4_28 = [input LA:5];
+
+                        if ( ((LA4_28 >= '0' && LA4_28 <= '9')||(LA4_28 >= 'A' && LA4_28 <= 'Z')||LA4_28=='_'||(LA4_28 >= 'a' && LA4_28 <= 'z')) ) {
+                            alt4=5;
+                        }
+                        else {
+                            alt4 = 2;
+                        }
+                    }
+                    else {
+                        alt4 = 5;
+                    }
+                }
+                else {
+                    alt4 = 5;
+                }
+            }
+            else {
+                alt4 = 5;
+            }
+            }
+            break;
+        case 'i': ;
+            {
+            NSInteger LA4_3 = [input LA:2];
+
+            if ( (LA4_3=='n') ) {
+                NSInteger LA4_19 = [input LA:3];
+
+                if ( (LA4_19=='t') ) {
+                    NSInteger LA4_25 = [input LA:4];
+
+                    if ( ((LA4_25 >= '0' && LA4_25 <= '9')||(LA4_25 >= 'A' && LA4_25 <= 'Z')||LA4_25=='_'||(LA4_25 >= 'a' && LA4_25 <= 'z')) ) {
+                        alt4=5;
+                    }
+                    else {
+                        alt4 = 3;
+                    }
+                }
+                else {
+                    alt4 = 5;
+                }
+            }
+            else {
+                alt4 = 5;
+            }
+            }
+            break;
+        case 'v': ;
+            {
+            NSInteger LA4_4 = [input LA:2];
+
+            if ( (LA4_4=='o') ) {
+                NSInteger LA4_20 = [input LA:3];
+
+                if ( (LA4_20=='i') ) {
+                    NSInteger LA4_26 = [input LA:4];
+
+                    if ( (LA4_26=='d') ) {
+                        NSInteger LA4_30 = [input LA:5];
+
+                        if ( ((LA4_30 >= '0' && LA4_30 <= '9')||(LA4_30 >= 'A' && LA4_30 <= 'Z')||LA4_30=='_'||(LA4_30 >= 'a' && LA4_30 <= 'z')) ) {
+                            alt4=5;
+                        }
+                        else {
+                            alt4 = 4;
+                        }
+                    }
+                    else {
+                        alt4 = 5;
+                    }
+                }
+                else {
+                    alt4 = 5;
+                }
+            }
+            else {
+                alt4 = 5;
+            }
+            }
+            break;
+        case 'A': ;
+        case 'B': ;
+        case 'C': ;
+        case 'D': ;
+        case 'E': ;
+        case 'F': ;
+        case 'G': ;
+        case 'H': ;
+        case 'I': ;
+        case 'J': ;
+        case 'K': ;
+        case 'L': ;
+        case 'M': ;
+        case 'N': ;
+        case 'O': ;
+        case 'P': ;
+        case 'Q': ;
+        case 'R': ;
+        case 'S': ;
+        case 'T': ;
+        case 'U': ;
+        case 'V': ;
+        case 'W': ;
+        case 'X': ;
+        case 'Y': ;
+        case 'Z': ;
+        case '_': ;
+        case 'a': ;
+        case 'b': ;
+        case 'd': ;
+        case 'e': ;
+        case 'g': ;
+        case 'h': ;
+        case 'j': ;
+        case 'k': ;
+        case 'l': ;
+        case 'm': ;
+        case 'n': ;
+        case 'o': ;
+        case 'p': ;
+        case 'q': ;
+        case 'r': ;
+        case 's': ;
+        case 't': ;
+        case 'u': ;
+        case 'w': ;
+        case 'x': ;
+        case 'y': ;
+        case 'z': ;
+            {
+            alt4=5;
+            }
+            break;
+        case '0': ;
+        case '1': ;
+        case '2': ;
+        case '3': ;
+        case '4': ;
+        case '5': ;
+        case '6': ;
+        case '7': ;
+        case '8': ;
+        case '9': ;
+            {
+            alt4=6;
+            }
+            break;
+        case '(': ;
+            {
+            alt4=7;
+            }
+            break;
+        case ')': ;
+            {
+            alt4=8;
+            }
+            break;
+        case '+': ;
+            {
+            alt4=9;
+            }
+            break;
+        case ',': ;
+            {
+            alt4=10;
+            }
+            break;
+        case ';': ;
+            {
+            alt4=11;
+            }
+            break;
+        case '<': ;
+            {
+            alt4=12;
+            }
+            break;
+        case '=': ;
+            {
+            NSInteger LA4_13 = [input LA:2];
+
+            if ( (LA4_13=='=') ) {
+                alt4=14;
+            }
+            else {
+                alt4 = 13;
+            }
+            }
+            break;
+        case '{': ;
+            {
+            alt4=15;
+            }
+            break;
+        case '}': ;
+            {
+            alt4=16;
+            }
+            break;
+        case '\t': ;
+        case '\n': ;
+        case '\r': ;
+        case ' ': ;
+            {
+            alt4=17;
+            }
+            break;
+
+    default: ;
+        ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:4 state:0 stream:input];
+        nvae.c = charLA4;
+        @throw nvae;
+
+    }
+
switch (alt4) {
case 1 : ;
// SimpleC.g:1:10: K_FOR // alt
{
-                [self mK_FOR];
-              /* element() */
-             /* elements */
+            [self mK_FOR];
+
+
+
}
break;
case 2 : ;
// SimpleC.g:1:16: K_CHAR // alt
{
-                [self mK_CHAR];
-              /* element() */
-             /* elements */
+            [self mK_CHAR];
+
+
+
}
break;
case 3 : ;
// SimpleC.g:1:23: K_INT_TYPE // alt
{
-                [self mK_INT_TYPE];
-              /* element() */
-             /* elements */
+            [self mK_INT_TYPE];
+
+
+
}
break;
case 4 : ;
// SimpleC.g:1:34: K_VOID // alt
{
-                [self mK_VOID];
-              /* element() */
-             /* elements */
+            [self mK_VOID];
+
+
+
}
break;
case 5 : ;
// SimpleC.g:1:41: K_ID // alt
{
-                [self mK_ID];
-              /* element() */
-             /* elements */
+            [self mK_ID];
+
+
+
}
break;
case 6 : ;
// SimpleC.g:1:46: K_INT // alt
{
-                [self mK_INT];
-              /* element() */
-             /* elements */
+            [self mK_INT];
+
+
+
}
break;
case 7 : ;
// SimpleC.g:1:52: K_LCURVE // alt
{
-                [self mK_LCURVE];
-              /* element() */
-             /* elements */
+            [self mK_LCURVE];
+
+
+
}
break;
case 8 : ;
// SimpleC.g:1:61: K_RCURVE // alt
{
-                [self mK_RCURVE];
-              /* element() */
-             /* elements */
+            [self mK_RCURVE];
+
+
+
}
break;
case 9 : ;
// SimpleC.g:1:70: K_PLUS // alt
{
-                [self mK_PLUS];
-              /* element() */
-             /* elements */
+            [self mK_PLUS];
+
+
+
}
break;
case 10 : ;
// SimpleC.g:1:77: K_COMMA // alt
{
-                [self mK_COMMA];
-              /* element() */
-             /* elements */
+            [self mK_COMMA];
+
+
+
}
break;
case 11 : ;
// SimpleC.g:1:85: K_SEMICOLON // alt
{
-                [self mK_SEMICOLON];
-              /* element() */
-             /* elements */
+            [self mK_SEMICOLON];
+
+
+
}
break;
case 12 : ;
// SimpleC.g:1:97: K_LT // alt
{
-                [self mK_LT];
-              /* element() */
-             /* elements */
+            [self mK_LT];
+
+
+
}
break;
case 13 : ;
// SimpleC.g:1:102: K_EQ // alt
{
-                [self mK_EQ];
-              /* element() */
-             /* elements */
+            [self mK_EQ];
+
+
+
}
break;
case 14 : ;
// SimpleC.g:1:107: K_EQEQ // alt
{
-                [self mK_EQEQ];
-              /* element() */
-             /* elements */
+            [self mK_EQEQ];
+
+
+
}
break;
case 15 : ;
// SimpleC.g:1:114: K_LCURLY // alt
{
-                [self mK_LCURLY];
-              /* element() */
-             /* elements */
+            [self mK_LCURLY];
+
+
+
}
break;
case 16 : ;
// SimpleC.g:1:123: K_RCURLY // alt
{
-                [self mK_RCURLY];
-              /* element() */
-             /* elements */
+            [self mK_RCURLY];
+
+
+
}
break;
case 17 : ;
// SimpleC.g:1:132: WS // alt
{
-                [self mWS];
-              /* element() */
-             /* elements */
+            [self mWS];
+
+
+
}
break;

@@ -974,8 +1149,4 @@ const static NSInteger dfa4_transition12[] = {25};

}

-@end /* end of SimpleCLexer implementation line 397 */
-
-/* End of code
- * =============================================================================
- */
+@end /* end of SimpleCLexer implementation line 397 */
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCParser.h b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCParser.h
index 1d007af..a5420cc 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCParser.h
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCParser.h
@@ -1,15 +1,27 @@
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 SimpleC.g 2010-08-25 11:11:22
+// $ANTLR ${project.version} ${buildNumber} SimpleC.g 2011-05-06 15:09:17

/* =============================================================================
* Standard antlr3 OBJC runtime definitions
*/
#import <Cocoa/Cocoa.h>
-#import "antlr3.h"
+#import <ANTLR/ANTLR.h>
/* End of standard antlr3 runtime definitions
* =============================================================================
*/

/* parserHeaderFile */
+#ifndef ANTLR3TokenTypeAlreadyDefined
+#define ANTLR3TokenTypeAlreadyDefined
+typedef enum {
+    ANTLR_EOF = -1,
+    INVALID,
+    EOR,
+    DOWN,
+    UP,
+    MIN
+} ANTLR3TokenType;
+#endif
+
#pragma mark Cyclic DFA interface start DFA2
@interface DFA2 : ANTLRDFA {
}
@@ -18,268 +30,369 @@
@end /* end of DFA2 interface  */

#pragma mark Cyclic DFA interface end DFA2
+
#pragma mark Tokens
-#define K_ID 11
-#define K_RCURLY 19
-#define K_RCURVE 14
-#define K_INT 25
-#define K_EQEQ 22
-#define K_FOR 20
-#define FUNC_HDR 6
-#define FUNC_DEF 8
+#ifdef EOF
+#undef EOF
+#endif
#define EOF -1
-#define K_SEMICOLON 10
-#define K_INT_TYPE 15
-#define FUNC_DECL 7
-#define K_COMMA 13
-#define ARG_DEF 5
-#define K_LCURLY 18
+#define ARG_DEF 4
+#define BLOCK 5
+#define FUNC_DECL 6
+#define FUNC_DEF 7
+#define FUNC_HDR 8
+#define K_CHAR 9
+#define K_COMMA 10
+#define K_EQ 11
+#define K_EQEQ 12
+#define K_FOR 13
+#define K_ID 14
+#define K_INT 15
+#define K_INT_TYPE 16
+#define K_LCURLY 17
+#define K_LCURVE 18
+#define K_LT 19
+#define K_PLUS 20
+#define K_RCURLY 21
+#define K_RCURVE 22
+#define K_SEMICOLON 23
+#define K_VOID 24
+#define VAR_DEF 25
#define WS 26
-#define K_EQ 21
-#define BLOCK 9
-#define K_LT 23
-#define K_LCURVE 12
-#define K_CHAR 16
-#define K_VOID 17
-#define VAR_DEF 4
-#define K_PLUS 24
#pragma mark Dynamic Global Scopes
#pragma mark Dynamic Rule Scopes
#pragma mark Rule Return Scopes start
-/* returnScopeInterface */
-@interface SimpleCParser_program_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+/* returnScopeInterface SimpleCParser_program_return */
+@interface SimpleCParser_program_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_program_return *)newSimpleCParser_program_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_declaration_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_declaration_return */
+@interface SimpleCParser_declaration_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_declaration_return *)newSimpleCParser_declaration_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_variable_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_variable_return */
+@interface SimpleCParser_variable_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_variable_return *)newSimpleCParser_variable_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_declarator_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_declarator_return */
+@interface SimpleCParser_declarator_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_declarator_return *)newSimpleCParser_declarator_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_functionHeader_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_functionHeader_return */
+@interface SimpleCParser_functionHeader_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_functionHeader_return *)newSimpleCParser_functionHeader_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_formalParameter_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_formalParameter_return */
+@interface SimpleCParser_formalParameter_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_formalParameter_return *)newSimpleCParser_formalParameter_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_type_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_type_return */
+@interface SimpleCParser_type_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_type_return *)newSimpleCParser_type_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_block_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_block_return */
+@interface SimpleCParser_block_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_block_return *)newSimpleCParser_block_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_stat_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_stat_return */
+@interface SimpleCParser_stat_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_stat_return *)newSimpleCParser_stat_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_forStat_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_forStat_return */
+@interface SimpleCParser_forStat_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_forStat_return *)newSimpleCParser_forStat_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_assignStat_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_assignStat_return */
+@interface SimpleCParser_assignStat_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_assignStat_return *)newSimpleCParser_assignStat_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_expr_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_expr_return */
+@interface SimpleCParser_expr_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_expr_return *)newSimpleCParser_expr_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_condExpr_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_condExpr_return */
+@interface SimpleCParser_condExpr_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_condExpr_return *)newSimpleCParser_condExpr_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_aexpr_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_aexpr_return */
+@interface SimpleCParser_aexpr_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_aexpr_return *)newSimpleCParser_aexpr_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface SimpleCParser_atom_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface SimpleCParser_atom_return */
+@interface SimpleCParser_atom_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (SimpleCParser_atom_return *)newSimpleCParser_atom_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */

-#pragma mark Rule return scopes end
+
+
+
+/* Interface grammar class */
@interface SimpleCParser : ANTLRParser { /* line 572 */
-// start of globalAttributeScopeMemVar
+/* ObjC start of ruleAttributeScopeMemVar */


-// start of action-actionScope-memVars
-// start of ruleAttributeScopeMemVar
+/* ObjC end of ruleAttributeScopeMemVar */
+/* ObjC start of globalAttributeScopeMemVar */


-// Start of memVars
+/* ObjC end of globalAttributeScopeMemVar */
+/* ObjC start of actions.(actionScope).memVars */
+/* ObjC end of actions.(actionScope).memVars */
+/* ObjC start of memVars */
/* AST parserHeaderFile.memVars */
-/* AST parsermemVars */
-id<ANTLRTreeAdaptor> treeAdaptor;
+NSInteger ruleLevel;
+NSArray *ruleNames;
+  /* AST super.memVars */
+/* AST parserMemVars */
+id<ANTLRTreeAdaptor> treeAdaptor;   /* AST parserMemVars */
+/* ObjC end of memVars */

DFA2 *dfa2;
}

-// start of action-actionScope-methodsDecl
+/* ObjC start of actions.(actionScope).properties */
+/* ObjC end of actions.(actionScope).properties */
+/* ObjC start of properties */
+/* AST parserHeaderFile.properties */
+  /* AST super.properties */
+/* AST parserProperties */
+@property (retain, getter=getTreeAdaptor, setter=setTreeAdaptor:) id<ANTLRTreeAdaptor> treeAdaptor;   /* AST parserproperties */
+/* ObjC end of properties */

-/* AST parserHeaderFile.methodsdecl */
++ (void) initialize;
++ (id) newSimpleCParser:(id<ANTLRTokenStream>)aStream;
+/* ObjC start of actions.(actionScope).methodsDecl */
+/* ObjC end of actions.(actionScope).methodsDecl */
+
+/* ObjC start of methodsDecl */
+/* AST parserHeaderFile.methodsDecl */
+  /* AST super.methodsDecl */
/* AST parserMethodsDecl */
- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)theTreeAdaptor;
+- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)theTreeAdaptor;   /* AST parsermethodsDecl */
+/* ObjC end of methodsDecl */

- (SimpleCParser_program_return *)program;
- (SimpleCParser_declaration_return *)declaration;
@@ -299,3 +412,4 @@ DFA2 *dfa2;


@end /* end of SimpleCParser interface */
+
diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCParser.m b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCParser.m
index c6b81a1..882a065 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCParser.m
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCParser.m
@@ -1,43 +1,18 @@
/** \file
- *  This OBJC source file was generated by $ANTLR version 3.2 Aug 24, 2010 10:45:57
+ *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
*
*     -  From the grammar source file : SimpleC.g
- *     -                            On : 2010-08-25 11:11:22
- *     -                for the parser : SimpleCParserParser *
- * Editing it, at least manually, is not wise.
+ *     -                            On : 2011-05-06 15:09:17
+ *     -                for the parser : SimpleCParserParser
+ *
+ * Editing it, at least manually, is not wise.
*
* ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
*
*
*/
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 SimpleC.g 2010-08-25 11:11:22
+// $ANTLR ${project.version} ${buildNumber} SimpleC.g 2011-05-06 15:09:17
+

/* -----------------------------------------
* Include the ANTLR3 generated header file.
@@ -47,12 +22,9 @@


/* ============================================================================= */
-
/* =============================================================================
* Start of recognizer
*/
-
-
#pragma mark Cyclic DFA implementation start DFA2
@implementation DFA2
const static NSInteger dfa2_eot[13] =
@@ -60,34 +32,38 @@ const static NSInteger dfa2_eot[13] =
const static NSInteger dfa2_eof[13] =
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar dfa2_min[13] =
-    {11,11,10,11,0,11,10,13,0,0,11,11,13};
+    {9,14,18,9,0,14,17,10,0,0,9,14,10};
const static unichar dfa2_max[13] =
-    {17,11,12,17,0,11,18,14,0,0,17,11,14};
+    {24,14,23,24,0,14,23,22,0,0,24,14,22};
const static NSInteger dfa2_accept[13] =
-    {-1,-1,-1,-1,1,-1,-1,-1,3,2,-1,-1,-1};
+    {-1,-1,-1,-1,1,-1,-1,-1,2,3,-1,-1,-1};
const static NSInteger dfa2_special[13] =
{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static NSInteger dfa2_transition[] = {};
-const static NSInteger dfa2_transition0[] = {9, -1, -1, -1, -1, -1, -1,
- -1, 8};
-const static NSInteger dfa2_transition1[] = {10, 6};
-const static NSInteger dfa2_transition2[] = {5, -1, -1, 6, 5, 5, 5};
-const static NSInteger dfa2_transition3[] = {11, -1, -1, -1, 11, 11, 11};
-const static NSInteger dfa2_transition4[] = {4, -1, 3};
-const static NSInteger dfa2_transition5[] = {1, -1, -1, -1, 1, 1, 1};
+const static NSInteger dfa2_transition0[] = {9, -1, -1, -1, -1, -1, 8};
+const static NSInteger dfa2_transition1[] = {10, -1, -1, -1, -1, -1, -1,
+ -1, -1, -1, -1, -1, 6};
+const static NSInteger dfa2_transition2[] = {5, -1, -1, -1, -1, 5, -1, 5,
+ -1, -1, -1, -1, -1, 6, -1, 5};
+const static NSInteger dfa2_transition3[] = {11, -1, -1, -1, -1, 11, -1,
+ 11, -1, -1, -1, -1, -1, -1, -1, 11};
+const static NSInteger dfa2_transition4[] = {3, -1, -1, -1, -1, 4};
+const static NSInteger dfa2_transition5[] = {1, -1, -1, -1, -1, 1, -1, 1,
+ -1, -1, -1, -1, -1, -1, -1, 1};
const static NSInteger dfa2_transition6[] = {7};
const static NSInteger dfa2_transition7[] = {12};
const static NSInteger dfa2_transition8[] = {2};


-+ () newDFA2WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
++ (id) newDFA2WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
{
return [[[DFA2 alloc] initWithRecognizer:aRecognizer] retain];
}

- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
{
-    if ((self = [super initWithRecognizer:theRecognizer]) != nil) {
+    self = [super initWithRecognizer:theRecognizer];
+    if ( self != nil ) {
decisionNumber = 2;
eot = dfa2_eot;
eof = dfa2_eof;
@@ -104,15 +80,15 @@ const static NSInteger dfa2_transition8[] = {2};
transition[1] = dfa2_transition8;
transition[2] = dfa2_transition4;
transition[3] = dfa2_transition2;
-        transition[4] = dfa2_transition;
-        transition[5] = dfa2_transition6;
-        transition[6] = dfa2_transition0;
-        transition[7] = dfa2_transition1;
-        transition[8] = dfa2_transition;
-        transition[9] = dfa2_transition;
-        transition[10] = dfa2_transition3;
-        transition[11] = dfa2_transition7;
-        transition[12] = dfa2_transition1;
+
+        transition[4] = dfa2_transition6;
+        transition[5] = dfa2_transition0;
+        transition[6] = dfa2_transition1;
+
+
+        transition[7] = dfa2_transition3;
+        transition[8] = dfa2_transition7;
+        transition[9] = dfa2_transition1;
}
return self;
}
@@ -137,115 +113,113 @@ const static NSInteger dfa2_transition8[] = {2};

#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_declaration_in_program85;
-static const unsigned long long FOLLOW_declaration_in_program85_data[] = { 0x0000000000038802LL};
+static const unsigned long long FOLLOW_declaration_in_program85_data[] = { 0x0000000001014202LL};
static ANTLRBitSet *FOLLOW_variable_in_declaration105;
static const unsigned long long FOLLOW_variable_in_declaration105_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration115;
-static const unsigned long long FOLLOW_functionHeader_in_declaration115_data[] = { 0x0000000000000400LL};
+static const unsigned long long FOLLOW_functionHeader_in_declaration115_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_declaration117;
static const unsigned long long FOLLOW_K_SEMICOLON_in_declaration117_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration135;
-static const unsigned long long FOLLOW_functionHeader_in_declaration135_data[] = { 0x0000000000040000LL};
+static const unsigned long long FOLLOW_functionHeader_in_declaration135_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_block_in_declaration137;
static const unsigned long long FOLLOW_block_in_declaration137_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_type_in_variable166;
-static const unsigned long long FOLLOW_type_in_variable166_data[] = { 0x0000000000000800LL};
+static const unsigned long long FOLLOW_type_in_variable166_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_declarator_in_variable168;
-static const unsigned long long FOLLOW_declarator_in_variable168_data[] = { 0x0000000000000400LL};
+static const unsigned long long FOLLOW_declarator_in_variable168_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_variable170;
static const unsigned long long FOLLOW_K_SEMICOLON_in_variable170_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_ID_in_declarator199;
static const unsigned long long FOLLOW_K_ID_in_declarator199_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_type_in_functionHeader219;
-static const unsigned long long FOLLOW_type_in_functionHeader219_data[] = { 0x0000000000000800LL};
+static const unsigned long long FOLLOW_type_in_functionHeader219_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_K_ID_in_functionHeader221;
-static const unsigned long long FOLLOW_K_ID_in_functionHeader221_data[] = { 0x0000000000001000LL};
+static const unsigned long long FOLLOW_K_ID_in_functionHeader221_data[] = { 0x0000000000040000LL};
static ANTLRBitSet *FOLLOW_K_LCURVE_in_functionHeader223;
-static const unsigned long long FOLLOW_K_LCURVE_in_functionHeader223_data[] = { 0x000000000003C800LL};
+static const unsigned long long FOLLOW_K_LCURVE_in_functionHeader223_data[] = { 0x0000000001414200LL};
static ANTLRBitSet *FOLLOW_formalParameter_in_functionHeader227;
-static const unsigned long long FOLLOW_formalParameter_in_functionHeader227_data[] = { 0x0000000000006000LL};
+static const unsigned long long FOLLOW_formalParameter_in_functionHeader227_data[] = { 0x0000000000400400LL};
static ANTLRBitSet *FOLLOW_K_COMMA_in_functionHeader231;
-static const unsigned long long FOLLOW_K_COMMA_in_functionHeader231_data[] = { 0x0000000000038800LL};
+static const unsigned long long FOLLOW_K_COMMA_in_functionHeader231_data[] = { 0x0000000001014200LL};
static ANTLRBitSet *FOLLOW_formalParameter_in_functionHeader233;
-static const unsigned long long FOLLOW_formalParameter_in_functionHeader233_data[] = { 0x0000000000006000LL};
+static const unsigned long long FOLLOW_formalParameter_in_functionHeader233_data[] = { 0x0000000000400400LL};
static ANTLRBitSet *FOLLOW_K_RCURVE_in_functionHeader241;
static const unsigned long long FOLLOW_K_RCURVE_in_functionHeader241_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_type_in_formalParameter281;
-static const unsigned long long FOLLOW_type_in_formalParameter281_data[] = { 0x0000000000000800LL};
+static const unsigned long long FOLLOW_type_in_formalParameter281_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_declarator_in_formalParameter283;
static const unsigned long long FOLLOW_declarator_in_formalParameter283_data[] = { 0x0000000000000002LL};
-static ANTLRBitSet *FOLLOW_set_in_type0;
-static const unsigned long long FOLLOW_set_in_type0_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_LCURLY_in_block376;
-static const unsigned long long FOLLOW_K_LCURLY_in_block376_data[] = { 0x00000000021F9C00LL};
+static const unsigned long long FOLLOW_K_LCURLY_in_block376_data[] = { 0x0000000001A7E200LL};
static ANTLRBitSet *FOLLOW_variable_in_block390;
-static const unsigned long long FOLLOW_variable_in_block390_data[] = { 0x00000000021F9C00LL};
+static const unsigned long long FOLLOW_variable_in_block390_data[] = { 0x0000000001A7E200LL};
static ANTLRBitSet *FOLLOW_stat_in_block405;
-static const unsigned long long FOLLOW_stat_in_block405_data[] = { 0x00000000021C1C00LL};
+static const unsigned long long FOLLOW_stat_in_block405_data[] = { 0x0000000000A6E000LL};
static ANTLRBitSet *FOLLOW_K_RCURLY_in_block416;
static const unsigned long long FOLLOW_K_RCURLY_in_block416_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_forStat_in_stat449;
static const unsigned long long FOLLOW_forStat_in_stat449_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_expr_in_stat457;
-static const unsigned long long FOLLOW_expr_in_stat457_data[] = { 0x0000000000000400LL};
+static const unsigned long long FOLLOW_expr_in_stat457_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_stat459;
static const unsigned long long FOLLOW_K_SEMICOLON_in_stat459_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_block_in_stat468;
static const unsigned long long FOLLOW_block_in_stat468_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_assignStat_in_stat476;
-static const unsigned long long FOLLOW_assignStat_in_stat476_data[] = { 0x0000000000000400LL};
+static const unsigned long long FOLLOW_assignStat_in_stat476_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_stat478;
static const unsigned long long FOLLOW_K_SEMICOLON_in_stat478_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_stat487;
static const unsigned long long FOLLOW_K_SEMICOLON_in_stat487_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_FOR_in_forStat507;
-static const unsigned long long FOLLOW_K_FOR_in_forStat507_data[] = { 0x0000000000001000LL};
+static const unsigned long long FOLLOW_K_FOR_in_forStat507_data[] = { 0x0000000000040000LL};
static ANTLRBitSet *FOLLOW_K_LCURVE_in_forStat509;
-static const unsigned long long FOLLOW_K_LCURVE_in_forStat509_data[] = { 0x0000000000000800LL};
+static const unsigned long long FOLLOW_K_LCURVE_in_forStat509_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_assignStat_in_forStat513;
-static const unsigned long long FOLLOW_assignStat_in_forStat513_data[] = { 0x0000000000000400LL};
+static const unsigned long long FOLLOW_assignStat_in_forStat513_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_forStat515;
-static const unsigned long long FOLLOW_K_SEMICOLON_in_forStat515_data[] = { 0x0000000002001800LL};
+static const unsigned long long FOLLOW_K_SEMICOLON_in_forStat515_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat517;
-static const unsigned long long FOLLOW_expr_in_forStat517_data[] = { 0x0000000000000400LL};
+static const unsigned long long FOLLOW_expr_in_forStat517_data[] = { 0x0000000000800000LL};
static ANTLRBitSet *FOLLOW_K_SEMICOLON_in_forStat519;
-static const unsigned long long FOLLOW_K_SEMICOLON_in_forStat519_data[] = { 0x0000000000000800LL};
+static const unsigned long long FOLLOW_K_SEMICOLON_in_forStat519_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_assignStat_in_forStat523;
-static const unsigned long long FOLLOW_assignStat_in_forStat523_data[] = { 0x0000000000004000LL};
+static const unsigned long long FOLLOW_assignStat_in_forStat523_data[] = { 0x0000000000400000LL};
static ANTLRBitSet *FOLLOW_K_RCURVE_in_forStat525;
-static const unsigned long long FOLLOW_K_RCURVE_in_forStat525_data[] = { 0x0000000000040000LL};
+static const unsigned long long FOLLOW_K_RCURVE_in_forStat525_data[] = { 0x0000000000020000LL};
static ANTLRBitSet *FOLLOW_block_in_forStat527;
static const unsigned long long FOLLOW_block_in_forStat527_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_ID_in_assignStat570;
-static const unsigned long long FOLLOW_K_ID_in_assignStat570_data[] = { 0x0000000000200000LL};
+static const unsigned long long FOLLOW_K_ID_in_assignStat570_data[] = { 0x0000000000000800LL};
static ANTLRBitSet *FOLLOW_K_EQ_in_assignStat572;
-static const unsigned long long FOLLOW_K_EQ_in_assignStat572_data[] = { 0x0000000002001800LL};
+static const unsigned long long FOLLOW_K_EQ_in_assignStat572_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_expr_in_assignStat574;
static const unsigned long long FOLLOW_expr_in_assignStat574_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_condExpr_in_expr598;
static const unsigned long long FOLLOW_condExpr_in_expr598_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_aexpr_in_condExpr617;
-static const unsigned long long FOLLOW_aexpr_in_condExpr617_data[] = { 0x0000000000C00002LL};
+static const unsigned long long FOLLOW_aexpr_in_condExpr617_data[] = { 0x0000000000081002LL};
static ANTLRBitSet *FOLLOW_K_EQEQ_in_condExpr622;
-static const unsigned long long FOLLOW_K_EQEQ_in_condExpr622_data[] = { 0x0000000002001800LL};
+static const unsigned long long FOLLOW_K_EQEQ_in_condExpr622_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_K_LT_in_condExpr627;
-static const unsigned long long FOLLOW_K_LT_in_condExpr627_data[] = { 0x0000000002001800LL};
+static const unsigned long long FOLLOW_K_LT_in_condExpr627_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_aexpr_in_condExpr631;
static const unsigned long long FOLLOW_aexpr_in_condExpr631_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_atom_in_aexpr653;
-static const unsigned long long FOLLOW_atom_in_aexpr653_data[] = { 0x0000000001000002LL};
+static const unsigned long long FOLLOW_atom_in_aexpr653_data[] = { 0x0000000000100002LL};
static ANTLRBitSet *FOLLOW_K_PLUS_in_aexpr657;
-static const unsigned long long FOLLOW_K_PLUS_in_aexpr657_data[] = { 0x0000000002001800LL};
+static const unsigned long long FOLLOW_K_PLUS_in_aexpr657_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_atom_in_aexpr660;
-static const unsigned long long FOLLOW_atom_in_aexpr660_data[] = { 0x0000000001000002LL};
+static const unsigned long long FOLLOW_atom_in_aexpr660_data[] = { 0x0000000000100002LL};
static ANTLRBitSet *FOLLOW_K_ID_in_atom680;
static const unsigned long long FOLLOW_K_ID_in_atom680_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_INT_in_atom694;
static const unsigned long long FOLLOW_K_INT_in_atom694_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_K_LCURVE_in_atom708;
-static const unsigned long long FOLLOW_K_LCURVE_in_atom708_data[] = { 0x0000000002001800LL};
+static const unsigned long long FOLLOW_K_LCURVE_in_atom708_data[] = { 0x000000000004C000LL};
static ANTLRBitSet *FOLLOW_expr_in_atom710;
-static const unsigned long long FOLLOW_expr_in_atom710_data[] = { 0x0000000000004000LL};
+static const unsigned long long FOLLOW_expr_in_atom710_data[] = { 0x0000000000400000LL};
static ANTLRBitSet *FOLLOW_K_RCURVE_in_atom712;
static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x0000000000000002LL};

@@ -254,8 +228,7 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

#pragma mark Dynamic Rule Scopes

-#pragma mark Rule return scopes start
-/* returnScope */
+#pragma mark Rule Return Scopes start
@implementation SimpleCParser_program_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -264,6 +237,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_program_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -281,16 +260,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_declaration_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -299,6 +277,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_declaration_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -316,16 +300,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_variable_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -334,6 +317,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_variable_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -351,16 +340,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_declarator_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -369,6 +357,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_declarator_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -386,16 +380,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_functionHeader_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -404,6 +397,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_functionHeader_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -421,16 +420,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_formalParameter_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -439,6 +437,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_formalParameter_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -456,16 +460,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_type_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -474,6 +477,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_type_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -491,16 +500,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_block_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -509,6 +517,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_block_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -526,16 +540,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_stat_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -544,6 +557,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_stat_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -561,16 +580,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_forStat_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -579,6 +597,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_forStat_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -596,16 +620,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_assignStat_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -614,6 +637,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_assignStat_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -631,16 +660,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_expr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -649,6 +677,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_expr_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -666,16 +700,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_condExpr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -684,6 +717,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_condExpr_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -701,16 +740,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_aexpr_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -719,6 +757,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_aexpr_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -736,16 +780,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation SimpleCParser_atom_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -754,6 +797,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
return [[[SimpleCParser_atom_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -771,19 +820,36 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */


+//#pragma mark Rule return scopes start
+//
+
+#pragma mark Rule return scopes start

@implementation SimpleCParser  // line 637

+/* ObjC start of ruleAttributeScope */
+#pragma mark Dynamic Rule Scopes
+/* ObjC end of ruleAttributeScope */
+#pragma mark global Attribute Scopes
+/* ObjC start globalAttributeScope */
+/* ObjC end globalAttributeScope */
+/* ObjC start actions.(actionScope).synthesize */
+/* ObjC end actions.(actionScope).synthesize */
+/* ObjC start synthesize() */
+/* AST genericParser.synthesize */
+/* AST parserProperties */
+@synthesize treeAdaptor;
+/* ObjC end synthesize() */
+
+ (void) initialize
{
#pragma mark Bitsets
@@ -806,7 +872,6 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
FOLLOW_K_RCURVE_in_functionHeader241 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_RCURVE_in_functionHeader241_data Count:(NSUInteger)1] retain];
FOLLOW_type_in_formalParameter281 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_formalParameter281_data Count:(NSUInteger)1] retain];
FOLLOW_declarator_in_formalParameter283 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declarator_in_formalParameter283_data Count:(NSUInteger)1] retain];
-    FOLLOW_set_in_type0 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_set_in_type0_data Count:(NSUInteger)1] retain];
FOLLOW_K_LCURLY_in_block376 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_LCURLY_in_block376_data Count:(NSUInteger)1] retain];
FOLLOW_variable_in_block390 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_variable_in_block390_data Count:(NSUInteger)1] retain];
FOLLOW_stat_in_block405 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_stat_in_block405_data Count:(NSUInteger)1] retain];
@@ -844,30 +909,32 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
FOLLOW_expr_in_atom710 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_atom710_data Count:(NSUInteger)1] retain];
FOLLOW_K_RCURVE_in_atom712 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_RCURVE_in_atom712_data Count:(NSUInteger)1] retain];

-    [ANTLRBaseRecognizer setTokenNames:[[[NSArray alloc] initWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>",
- @"VAR_DEF", @"ARG_DEF", @"FUNC_HDR", @"FUNC_DECL", @"FUNC_DEF", @"BLOCK",
- @"K_SEMICOLON", @"K_ID", @"K_LCURVE", @"K_COMMA", @"K_RCURVE", @"K_INT_TYPE",
- @"K_CHAR", @"K_VOID", @"K_LCURLY", @"K_RCURLY", @"K_FOR", @"K_EQ", @"K_EQEQ",
- @"K_LT", @"K_PLUS", @"K_INT", @"WS", nil] retain]];
+    [ANTLRBaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>",
+ @"ARG_DEF", @"BLOCK", @"FUNC_DECL", @"FUNC_DEF", @"FUNC_HDR", @"K_CHAR",
+ @"K_COMMA", @"K_EQ", @"K_EQEQ", @"K_FOR", @"K_ID", @"K_INT", @"K_INT_TYPE",
+ @"K_LCURLY", @"K_LCURVE", @"K_LT", @"K_PLUS", @"K_RCURLY", @"K_RCURVE",
+ @"K_SEMICOLON", @"K_VOID", @"VAR_DEF", @"WS", nil] retain]];
+    [ANTLRBaseRecognizer setGrammarFileName:@"SimpleC.g"];
}

+ (SimpleCParser *)newSimpleCParser:(id<ANTLRTokenStream>)aStream
{
return [[SimpleCParser alloc] initWithTokenStream:aStream];

+
}

- (id) initWithTokenStream:(id<ANTLRTokenStream>)aStream
{
-    if ((self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:15+1] retain]]) != nil) {
+    self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:15+1] retain]];
+    if ( self != nil ) {


dfa2 = [DFA2 newDFA2WithRecognizer:self];
-
/* start of actions-actionScope-init */
/* start of init */
/* AST genericParser.init */
-        [self setTreeAdaptor:[[ANTLRCommonTreeAdaptor newANTLRCommonTreeAdaptor] retain]];
+        [self setTreeAdaptor:[[ANTLRCommonTreeAdaptor newTreeAdaptor] retain]];
}
return self;
}
@@ -880,8 +947,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

[super dealloc];
}
-// start actions.actionScope.methods
-// start methods()
+
+/* ObjC start members */
+/* ObjC end members */
+/* ObjC start actions.(actionScope).methods */
+/* ObjC end actions.(actionScope).methods */
+/* ObjC start methods() */
/* AST genericParser.methods */
/* AST parserMethods */
- (id<ANTLRTreeAdaptor>) getTreeAdaptor
@@ -895,25 +966,28 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
treeAdaptor = aTreeAdaptor;
}
}
-// start rules
+/* ObjC end methods() */
+/* ObjC start rules */
/*
* $ANTLR start program
* SimpleC.g:16:1: program : ( declaration )+ ;
*/
- (SimpleCParser_program_return *) program
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_program_return * retval = [SimpleCParser_program_return newSimpleCParser_program_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
-        SimpleCParser_declaration_return * declaration1 = nil;
-
+         SimpleCParser_declaration_return * declaration1 = nil ;
+


// SimpleC.g:17:5: ( ( declaration )+ ) // ruleBlockSingleAlt
@@ -921,12 +995,13 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
// SimpleC.g:17:9: ( declaration )+ // positiveClosureBlock
-        NSInteger cnt1=0;
+        NSInteger cnt1 = 0;
do {
-            NSInteger alt1=2;
+            NSInteger alt1 = 2;
NSInteger LA1_0 = [input LA:1];
-            if ( (LA1_0==K_ID||(LA1_0>=K_INT_TYPE && LA1_0<=K_VOID)) ) {
+            if ( (LA1_0==K_CHAR||LA1_0==K_ID||LA1_0==K_INT_TYPE||LA1_0==K_VOID) ) {
alt1=1;
}

@@ -936,27 +1011,30 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:17:9: declaration // alt
{
/* ASTParser ruleRef */
+                    /* ruleRef */
[self pushFollow:FOLLOW_declaration_in_program85];
declaration1 = [self declaration];
+
[self popFollow];


-                    [treeAdaptor addChild:[declaration1 getTree] toTree:root_0];  /* element() */
-                     /* elements */
+                    [treeAdaptor addChild:[declaration1 getTree] toTree:root_0];
+
}
break;

default :
if ( cnt1 >= 1 )
goto loop1;
-                    ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:1];
+                    ANTLREarlyExitException *eee =
+                        [ANTLREarlyExitException newException:input decisionNumber:1];
@throw eee;
}
cnt1++;
} while (YES);
loop1: ;
-          /* element() */
-         /* elements */
+
+
}

/* ASTParser ruleCleanUp */
@@ -965,55 +1043,63 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[retval setStop:[input LT:-1]];


+
retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end program */
+
/*
* $ANTLR start declaration
* SimpleC.g:20:1: declaration : ( variable | functionHeader K_SEMICOLON -> ^( FUNC_DECL functionHeader ) | functionHeader block -> ^( FUNC_DEF functionHeader block ) );
*/
- (SimpleCParser_declaration_return *) declaration
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_declaration_return * retval = [SimpleCParser_declaration_return newSimpleCParser_declaration_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
ANTLRCommonToken *K_SEMICOLON4 = nil;
-        SimpleCParser_variable_return * variable2 = nil;
-
-        SimpleCParser_functionHeader_return * functionHeader3 = nil;
-
-        SimpleCParser_functionHeader_return * functionHeader5 = nil;
-
-        SimpleCParser_block_return * block6 = nil;
-
+         SimpleCParser_variable_return * variable2 = nil ;
+
+         SimpleCParser_functionHeader_return * functionHeader3 = nil ;
+
+         SimpleCParser_functionHeader_return * functionHeader5 = nil ;
+
+         SimpleCParser_block_return * block6 = nil ;
+

ANTLRCommonTree *K_SEMICOLON4_tree=nil;
-        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
+        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_SEMICOLON"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_functionHeader =
+        ANTLRRewriteRuleSubtreeStream *stream_functionHeader =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule functionHeader"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_block =
+        ANTLRRewriteRuleSubtreeStream *stream_block =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule block"] retain];
// SimpleC.g:21:5: ( variable | functionHeader K_SEMICOLON -> ^( FUNC_DECL functionHeader ) | functionHeader block -> ^( FUNC_DEF functionHeader block ) ) //ruleblock
@@ -1025,29 +1111,34 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser ruleRef */
+                /* ruleRef */
[self pushFollow:FOLLOW_variable_in_declaration105];
variable2 = [self variable];
+
[self popFollow];


-                [treeAdaptor addChild:[variable2 getTree] toTree:root_0];  /* element() */
-                 /* elements */
+                [treeAdaptor addChild:[variable2 getTree] toTree:root_0];
+
}
break;
case 2 : ;
// SimpleC.g:22:9: functionHeader K_SEMICOLON // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_functionHeader_in_declaration115];
functionHeader3 = [self functionHeader];
+
[self popFollow];


-                [stream_functionHeader addElement:[functionHeader3 getTree]];  /* element() */
+                [stream_functionHeader addElement:[functionHeader3 getTree]];
+
K_SEMICOLON4=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_declaration117];
[stream_K_SEMICOLON addElement:K_SEMICOLON4];
-                  /* element() */
-                 /* elements */
+

// AST REWRITE
// elements: functionHeader
@@ -1056,14 +1147,11 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token list labels:
// rule list labels:
// wildcard labels:
-                 [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                        description:@"token retval"
-                                                                            element:retval!=nil?[retval getTree]:nil] retain];
+                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -1072,8 +1160,9 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:22:39: ^( FUNC_DECL functionHeader )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:[[treeAdaptor createTree:(NSInteger)FUNC_DECL Text:[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:(NSUInteger)FUNC_DECL]] retain]
-                                                                               old:root_1];
+                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
+                                [treeAdaptor createTree:FUNC_DECL Text:@"FUNC_DECL"]
+                         old:root_1];

[treeAdaptor addChild:[stream_functionHeader nextTree] toTree:root_1];

@@ -1082,42 +1171,45 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}
break;
case 3 : ;
// SimpleC.g:23:9: functionHeader block // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_functionHeader_in_declaration135];
functionHeader5 = [self functionHeader];
+
[self popFollow];


-                [stream_functionHeader addElement:[functionHeader5 getTree]];  /* element() */
+                [stream_functionHeader addElement:[functionHeader5 getTree]];
+
+                /* ruleRef */
[self pushFollow:FOLLOW_block_in_declaration137];
block6 = [self block];
+
[self popFollow];


-                [stream_block addElement:[block6 getTree]];  /* element() */
-                 /* elements */
+                [stream_block addElement:[block6 getTree]];

// AST REWRITE
-                // elements: block, functionHeader
+                // elements: functionHeader, block
// token labels:
// rule labels: retval
// token list labels:
// rule list labels:
// wildcard labels:
-                 [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                        description:@"token retval"
-                                                                            element:retval!=nil?[retval getTree]:nil] retain];
+                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -1126,10 +1218,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:23:33: ^( FUNC_DEF functionHeader block )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:[[treeAdaptor createTree:(NSInteger)FUNC_DEF Text:[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:(NSUInteger)FUNC_DEF]] retain]
-                                                                               old:root_1];
+                        root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
+                                [treeAdaptor createTree:FUNC_DEF Text:@"FUNC_DEF"]
+                         old:root_1];

[treeAdaptor addChild:[stream_functionHeader nextTree] toTree:root_1];
+
[treeAdaptor addChild:[stream_block nextTree] toTree:root_1];

[treeAdaptor addChild:root_1 toTree:root_0];
@@ -1137,8 +1231,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}
break;

@@ -1148,76 +1244,89 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_K_SEMICOLON release];
[stream_functionHeader release];
[stream_block release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end declaration */
+
/*
* $ANTLR start variable
* SimpleC.g:26:1: variable : type declarator K_SEMICOLON -> ^( VAR_DEF type declarator ) ;
*/
- (SimpleCParser_variable_return *) variable
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_variable_return * retval = [SimpleCParser_variable_return newSimpleCParser_variable_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
ANTLRCommonToken *K_SEMICOLON9 = nil;
-        SimpleCParser_type_return * type7 = nil;
-
-        SimpleCParser_declarator_return * declarator8 = nil;
-
+         SimpleCParser_type_return * type7 = nil ;
+
+         SimpleCParser_declarator_return * declarator8 = nil ;
+

ANTLRCommonTree *K_SEMICOLON9_tree=nil;
-        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
+        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_SEMICOLON"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_declarator =
+        ANTLRRewriteRuleSubtreeStream *stream_declarator =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule declarator"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_type =
+        ANTLRRewriteRuleSubtreeStream *stream_type =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule type"] retain];
// SimpleC.g:27:5: ( type declarator K_SEMICOLON -> ^( VAR_DEF type declarator ) ) // ruleBlockSingleAlt
// SimpleC.g:27:9: type declarator K_SEMICOLON // alt
{
+        /* ruleRef */
[self pushFollow:FOLLOW_type_in_variable166];
type7 = [self type];
+
[self popFollow];


-        [stream_type addElement:[type7 getTree]];  /* element() */
+        [stream_type addElement:[type7 getTree]];
+
+        /* ruleRef */
[self pushFollow:FOLLOW_declarator_in_variable168];
declarator8 = [self declarator];
+
[self popFollow];


-        [stream_declarator addElement:[declarator8 getTree]];  /* element() */
+        [stream_declarator addElement:[declarator8 getTree]];
+
K_SEMICOLON9=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_variable170];
[stream_K_SEMICOLON addElement:K_SEMICOLON9];
-          /* element() */
-         /* elements */
+

// AST REWRITE
// elements: declarator, type
@@ -1226,14 +1335,11 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token list labels:
// rule list labels:
// wildcard labels:
-         [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token retval"
-                                                                    element:retval!=nil?[retval getTree]:nil] retain];
+                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -1242,10 +1348,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:27:40: ^( VAR_DEF type declarator )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:[[treeAdaptor createTree:(NSInteger)VAR_DEF Text:[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:(NSUInteger)VAR_DEF]] retain]
-                                                                       old:root_1];
+                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
+                        [treeAdaptor createTree:VAR_DEF Text:@"VAR_DEF"]
+                 old:root_1];

[treeAdaptor addChild:[stream_type nextTree] toTree:root_1];
+
[treeAdaptor addChild:[stream_declarator nextTree] toTree:root_1];

[treeAdaptor addChild:root_1 toTree:root_0];
@@ -1253,8 +1361,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}

/* ASTParser ruleCleanUp */
@@ -1262,37 +1372,45 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_K_SEMICOLON release];
[stream_declarator release];
[stream_type release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end variable */
+
/*
* $ANTLR start declarator
* SimpleC.g:30:1: declarator : K_ID ;
*/
- (SimpleCParser_declarator_return *) declarator
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_declarator_return * retval = [SimpleCParser_declarator_return newSimpleCParser_declarator_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
@@ -1306,13 +1424,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser tokenRef */
K_ID10=(ANTLRCommonToken *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_declarator199];
K_ID10_tree = /* ASTParser createNodeFromToken */
-        (ANTLRCommonTree *)[[treeAdaptor createTree:K_ID10] retain];
+        (ANTLRCommonTree *)[[treeAdaptor create:K_ID10] retain]
+        ;
[treeAdaptor addChild:K_ID10_tree  toTree:root_0];
-          /* element() */
-         /* elements */
+
+
}

/* ASTParser ruleCleanUp */
@@ -1321,33 +1441,41 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[retval setStop:[input LT:-1]];


+
retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end declarator */
+
/*
* $ANTLR start functionHeader
* SimpleC.g:34:1: functionHeader : type K_ID K_LCURVE ( formalParameter ( K_COMMA formalParameter )* )? K_RCURVE -> ^( FUNC_HDR type K_ID ( formalParameter )+ ) ;
*/
- (SimpleCParser_functionHeader_return *) functionHeader
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_functionHeader_return * retval = [SimpleCParser_functionHeader_return newSimpleCParser_functionHeader_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
@@ -1356,67 +1484,75 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
ANTLRCommonToken *K_LCURVE13 = nil;
ANTLRCommonToken *K_COMMA15 = nil;
ANTLRCommonToken *K_RCURVE17 = nil;
-        SimpleCParser_type_return * type11 = nil;
-
-        SimpleCParser_formalParameter_return * formalParameter14 = nil;
-
-        SimpleCParser_formalParameter_return * formalParameter16 = nil;
-
+         SimpleCParser_type_return * type11 = nil ;
+
+         SimpleCParser_formalParameter_return * formalParameter14 = nil ;
+
+         SimpleCParser_formalParameter_return * formalParameter16 = nil ;
+

ANTLRCommonTree *K_ID12_tree=nil;
ANTLRCommonTree *K_LCURVE13_tree=nil;
ANTLRCommonTree *K_COMMA15_tree=nil;
ANTLRCommonTree *K_RCURVE17_tree=nil;
-        ANTLRRewriteRuleTokenStream *stream_K_ID =
+        ANTLRRewriteRuleTokenStream *stream_K_ID =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_ID"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
+        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_LCURVE"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
+        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_RCURVE"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_COMMA =
+        ANTLRRewriteRuleTokenStream *stream_K_COMMA =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_COMMA"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_formalParameter =
+        ANTLRRewriteRuleSubtreeStream *stream_formalParameter =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule formalParameter"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_type =
+        ANTLRRewriteRuleSubtreeStream *stream_type =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule type"] retain];
// SimpleC.g:35:5: ( type K_ID K_LCURVE ( formalParameter ( K_COMMA formalParameter )* )? K_RCURVE -> ^( FUNC_HDR type K_ID ( formalParameter )+ ) ) // ruleBlockSingleAlt
// SimpleC.g:35:9: type K_ID K_LCURVE ( formalParameter ( K_COMMA formalParameter )* )? K_RCURVE // alt
{
+        /* ruleRef */
[self pushFollow:FOLLOW_type_in_functionHeader219];
type11 = [self type];
+
[self popFollow];


-        [stream_type addElement:[type11 getTree]];  /* element() */
+        [stream_type addElement:[type11 getTree]];
+
K_ID12=(ANTLRCommonToken *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_functionHeader221];
[stream_K_ID addElement:K_ID12];
-          /* element() */
+
+
K_LCURVE13=(ANTLRCommonToken *)[self match:input TokenType:K_LCURVE Follow:FOLLOW_K_LCURVE_in_functionHeader223];
[stream_K_LCURVE addElement:K_LCURVE13];
-          /* element() */
+
+
// SimpleC.g:35:28: ( formalParameter ( K_COMMA formalParameter )* )? // block
NSInteger alt4=2;
NSInteger LA4_0 = [input LA:1];

-        if ( (LA4_0==K_ID||(LA4_0>=K_INT_TYPE && LA4_0<=K_VOID)) ) {
+        if ( (LA4_0==K_CHAR||LA4_0==K_ID||LA4_0==K_INT_TYPE||LA4_0==K_VOID) ) {
alt4=1;
}
switch (alt4) {
case 1 : ;
// SimpleC.g:35:30: formalParameter ( K_COMMA formalParameter )* // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_formalParameter_in_functionHeader227];
formalParameter14 = [self formalParameter];
+
[self popFollow];


-                [stream_formalParameter addElement:[formalParameter14 getTree]];  /* element() */
+                [stream_formalParameter addElement:[formalParameter14 getTree]];
+
do {
NSInteger alt3=2;
NSInteger LA3_0 = [input LA:1];
@@ -1431,14 +1567,17 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
K_COMMA15=(ANTLRCommonToken *)[self match:input TokenType:K_COMMA Follow:FOLLOW_K_COMMA_in_functionHeader231];
[stream_K_COMMA addElement:K_COMMA15];
-                              /* element() */
+
+
+                            /* ruleRef */
[self pushFollow:FOLLOW_formalParameter_in_functionHeader233];
formalParameter16 = [self formalParameter];
+
[self popFollow];


-                            [stream_formalParameter addElement:[formalParameter16 getTree]];  /* element() */
-                             /* elements */
+                            [stream_formalParameter addElement:[formalParameter16 getTree]];
+
}
break;

@@ -1447,17 +1586,17 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
}
} while (YES);
loop3: ;
-                  /* element() */
-                 /* elements */
+
+
}
break;

}
-          /* element() */
+
+
K_RCURVE17=(ANTLRCommonToken *)[self match:input TokenType:K_RCURVE Follow:FOLLOW_K_RCURVE_in_functionHeader241];
[stream_K_RCURVE addElement:K_RCURVE17];
-          /* element() */
-         /* elements */
+

// AST REWRITE
// elements: formalParameter, type, K_ID
@@ -1466,14 +1605,11 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token list labels:
// rule list labels:
// wildcard labels:
-         [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token retval"
-                                                                    element:retval!=nil?[retval getTree]:nil] retain];
+                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -1482,16 +1618,21 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:36:12: ^( FUNC_HDR type K_ID ( formalParameter )+ )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:[[treeAdaptor createTree:(NSInteger)FUNC_HDR Text:[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:(NSUInteger)FUNC_HDR]] retain]
-                                                                       old:root_1];
+                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
+                        [treeAdaptor createTree:FUNC_HDR Text:@"FUNC_HDR"]
+                 old:root_1];

[treeAdaptor addChild:[stream_type nextTree] toTree:root_1];
+
// TODO: args:
-                [treeAdaptor addChild:[stream_K_ID nextNode] toTree:root_1];
+                [treeAdaptor addChild:
+                            [stream_K_ID nextNode]
+                 toTree:root_1];
+
// SimpleC.g:36:33: ( formalParameter )+
{
if ( !([stream_formalParameter hasNext]) ) {
-                    @throw [NSException exceptionWithName:@"RewriteEarlyExitException" reason:nil userInfo:nil];
+                    @throw [ANTLRRewriteEarlyExitException newException];
}
while ( [stream_formalParameter hasNext] ) {
[treeAdaptor addChild:[stream_formalParameter nextTree] toTree:root_1];
@@ -1505,8 +1646,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}

/* ASTParser ruleCleanUp */
@@ -1514,6 +1657,7 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_K_ID release];
[stream_K_LCURVE release];
[stream_K_RCURVE release];
@@ -1522,63 +1666,74 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[stream_type release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end functionHeader */
+
/*
* $ANTLR start formalParameter
* SimpleC.g:39:1: formalParameter : type declarator -> ^( ARG_DEF type declarator ) ;
*/
- (SimpleCParser_formalParameter_return *) formalParameter
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_formalParameter_return * retval = [SimpleCParser_formalParameter_return newSimpleCParser_formalParameter_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
-        SimpleCParser_type_return * type18 = nil;
-
-        SimpleCParser_declarator_return * declarator19 = nil;
+         SimpleCParser_type_return * type18 = nil ;
+
+         SimpleCParser_declarator_return * declarator19 = nil ;
+

-
-        ANTLRRewriteRuleSubtreeStream *stream_declarator =
+        ANTLRRewriteRuleSubtreeStream *stream_declarator =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule declarator"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_type =
+        ANTLRRewriteRuleSubtreeStream *stream_type =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule type"] retain];
// SimpleC.g:40:5: ( type declarator -> ^( ARG_DEF type declarator ) ) // ruleBlockSingleAlt
// SimpleC.g:40:9: type declarator // alt
{
+        /* ruleRef */
[self pushFollow:FOLLOW_type_in_formalParameter281];
type18 = [self type];
+
[self popFollow];


-        [stream_type addElement:[type18 getTree]];  /* element() */
+        [stream_type addElement:[type18 getTree]];
+
+        /* ruleRef */
[self pushFollow:FOLLOW_declarator_in_formalParameter283];
declarator19 = [self declarator];
+
[self popFollow];


-        [stream_declarator addElement:[declarator19 getTree]];  /* element() */
-         /* elements */
+        [stream_declarator addElement:[declarator19 getTree]];

// AST REWRITE
// elements: declarator, type
@@ -1587,14 +1742,11 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token list labels:
// rule list labels:
// wildcard labels:
-         [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token retval"
-                                                                    element:retval!=nil?[retval getTree]:nil] retain];
+                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -1603,10 +1755,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:40:28: ^( ARG_DEF type declarator )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:[[treeAdaptor createTree:(NSInteger)ARG_DEF Text:[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:(NSUInteger)ARG_DEF]] retain]
-                                                                       old:root_1];
+                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
+                        [treeAdaptor createTree:ARG_DEF Text:@"ARG_DEF"]
+                 old:root_1];

[treeAdaptor addChild:[stream_type nextTree] toTree:root_1];
+
[treeAdaptor addChild:[stream_declarator nextTree] toTree:root_1];

[treeAdaptor addChild:root_1 toTree:root_0];
@@ -1614,8 +1768,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}

/* ASTParser ruleCleanUp */
@@ -1623,36 +1779,44 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_declarator release];
[stream_type release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end formalParameter */
+
/*
* $ANTLR start type
* SimpleC.g:43:1: type : ( K_INT_TYPE | K_CHAR | K_VOID | K_ID );
*/
- (SimpleCParser_type_return *) type
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_type_return * retval = [SimpleCParser_type_return newSimpleCParser_type_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
@@ -1666,20 +1830,23 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser matchRuleBlockSet */
/* ASTParser matchSet */
-        set20 = (ANTLRCommonToken *)[input LT:1];
-        if ([input LA:1] == K_ID||(([input LA:1] >= K_INT_TYPE) && ([input LA:1] <= K_VOID))) {
+        set20 = (ANTLRCommonToken *)[input LT:1]; /* matchSet */
+
+        if ([input LA:1] == K_CHAR||[input LA:1] == K_ID||[input LA:1] == K_INT_TYPE||[input LA:1] == K_VOID) {
[input consume];
-                [treeAdaptor addChild:/* ASTParser createNodeFromToken */
-            (ANTLRCommonTree *)[[treeAdaptor createTree:set20] retain] toTree:root_0 ];
+            [treeAdaptor addChild:/* ASTParser createNodeFromToken */
+            (ANTLRCommonTree *)[[treeAdaptor create:set20] retain]
+             toTree:root_0 ];
[state setIsErrorRecovery:NO];
} else {
-            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
@throw mse;
}
-          /* element() */
-         /* elements */
+
+
}

/* ASTParser ruleCleanUp */
@@ -1688,56 +1855,64 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[retval setStop:[input LT:-1]];


+
retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end type */
+
/*
* $ANTLR start block
* SimpleC.g:50:1: block : lc= K_LCURLY ( variable )* ( stat )* K_RCURLY -> ^( BLOCK[$lc,@\"BLOCK\"] ( variable )* ( stat )* ) ;
*/
- (SimpleCParser_block_return *) block
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_block_return * retval = [SimpleCParser_block_return newSimpleCParser_block_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
ANTLRCommonToken *lc = nil;
ANTLRCommonToken *K_RCURLY23 = nil;
-        SimpleCParser_variable_return * variable21 = nil;
-
-        SimpleCParser_stat_return * stat22 = nil;
-
+         SimpleCParser_variable_return * variable21 = nil ;
+
+         SimpleCParser_stat_return * stat22 = nil ;
+

ANTLRCommonTree *lc_tree=nil;
ANTLRCommonTree *K_RCURLY23_tree=nil;
-        ANTLRRewriteRuleTokenStream *stream_K_LCURLY =
+        ANTLRRewriteRuleTokenStream *stream_K_LCURLY =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_LCURLY"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_RCURLY =
+        ANTLRRewriteRuleTokenStream *stream_K_RCURLY =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_RCURLY"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_variable =
+        ANTLRRewriteRuleSubtreeStream *stream_variable =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule variable"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_stat =
+        ANTLRRewriteRuleSubtreeStream *stream_stat =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule stat"] retain];
// SimpleC.g:51:5: (lc= K_LCURLY ( variable )* ( stat )* K_RCURLY -> ^( BLOCK[$lc,@\"BLOCK\"] ( variable )* ( stat )* ) ) // ruleBlockSingleAlt
@@ -1745,7 +1920,8 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
lc=(ANTLRCommonToken *)[self match:input TokenType:K_LCURLY Follow:FOLLOW_K_LCURLY_in_block376];
[stream_K_LCURLY addElement:lc];
-          /* element() */
+
+
do {
NSInteger alt5=2;
NSInteger LA5_0 = [input LA:1];
@@ -1757,7 +1933,7 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000


}
-            else if ( ((LA5_0>=K_INT_TYPE && LA5_0<=K_VOID)) ) {
+            else if ( (LA5_0==K_CHAR||LA5_0==K_INT_TYPE||LA5_0==K_VOID) ) {
alt5=1;
}

@@ -1766,13 +1942,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
case 1 : ;
// SimpleC.g:52:13: variable // alt
{
+                    /* ruleRef */
[self pushFollow:FOLLOW_variable_in_block390];
variable21 = [self variable];
+
[self popFollow];


-                    [stream_variable addElement:[variable21 getTree]];  /* element() */
-                     /* elements */
+                    [stream_variable addElement:[variable21 getTree]];
+
}
break;

@@ -1781,11 +1959,12 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
}
} while (YES);
loop5: ;
-          /* element() */
+
+
do {
NSInteger alt6=2;
NSInteger LA6_0 = [input LA:1];
-            if ( ((LA6_0>=K_SEMICOLON && LA6_0<=K_LCURVE)||LA6_0==K_LCURLY||LA6_0==K_FOR||LA6_0==K_INT) ) {
+            if ( ((LA6_0 >= K_FOR && LA6_0 <= K_INT)||(LA6_0 >= K_LCURLY && LA6_0 <= K_LCURVE)||LA6_0==K_SEMICOLON) ) {
alt6=1;
}

@@ -1794,13 +1973,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
case 1 : ;
// SimpleC.g:53:13: stat // alt
{
+                    /* ruleRef */
[self pushFollow:FOLLOW_stat_in_block405];
stat22 = [self stat];
+
[self popFollow];


-                    [stream_stat addElement:[stat22 getTree]];  /* element() */
-                     /* elements */
+                    [stream_stat addElement:[stat22 getTree]];
+
}
break;

@@ -1809,27 +1990,24 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
}
} while (YES);
loop6: ;
-          /* element() */
+
+
K_RCURLY23=(ANTLRCommonToken *)[self match:input TokenType:K_RCURLY Follow:FOLLOW_K_RCURLY_in_block416];
[stream_K_RCURLY addElement:K_RCURLY23];
-          /* element() */
-         /* elements */
+

// AST REWRITE
-        // elements: variable, stat
+        // elements: stat, variable
// token labels:
// rule labels: retval
// token list labels:
// rule list labels:
// wildcard labels:
-         [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token retval"
-                                                                    element:retval!=nil?[retval getTree]:nil] retain];
+                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -1838,8 +2016,9 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:55:12: ^( BLOCK[$lc,@\"BLOCK\"] ( variable )* ( stat )* )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:[[treeAdaptor createTree:(NSInteger)BLOCK Text:[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:(NSUInteger)BLOCK]] retain]
-                                                                       old:root_1];
+                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
+                        [treeAdaptor createTree:BLOCK FromToken:lc Text:@"BLOCK"]
+                 old:root_1];

// SimpleC.g:55:34: ( variable )*
while ( [stream_variable hasNext] ) {
@@ -1847,6 +2026,7 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}
[stream_variable reset];
+
// SimpleC.g:55:44: ( stat )*
while ( [stream_stat hasNext] ) {
[treeAdaptor addChild:[stream_stat nextTree] toTree:root_1];
@@ -1859,8 +2039,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}

/* ASTParser ruleCleanUp */
@@ -1868,38 +2050,46 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_K_LCURLY release];
[stream_K_RCURLY release];
[stream_variable release];
[stream_stat release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end block */
+
/*
* $ANTLR start stat
- * SimpleC.g:58:1: stat : ( forStat | expr K_SEMICOLON | block | assignStat K_SEMICOLON | K_SEMICOLON );
+ * SimpleC.g:58:1: stat : ( forStat | expr K_SEMICOLON !| block | assignStat K_SEMICOLON !| K_SEMICOLON !);
*/
- (SimpleCParser_stat_return *) stat
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_stat_return * retval = [SimpleCParser_stat_return newSimpleCParser_stat_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
@@ -1907,22 +2097,23 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
ANTLRCommonToken *K_SEMICOLON26 = nil;
ANTLRCommonToken *K_SEMICOLON29 = nil;
ANTLRCommonToken *K_SEMICOLON30 = nil;
-        SimpleCParser_forStat_return * forStat24 = nil;
-
-        SimpleCParser_expr_return * expr25 = nil;
-
-        SimpleCParser_block_return * block27 = nil;
-
-        SimpleCParser_assignStat_return * assignStat28 = nil;
-
+         SimpleCParser_forStat_return * forStat24 = nil ;
+
+         SimpleCParser_expr_return * expr25 = nil ;
+
+         SimpleCParser_block_return * block27 = nil ;
+
+         SimpleCParser_assignStat_return * assignStat28 = nil ;
+

ANTLRCommonTree *K_SEMICOLON26_tree=nil;
ANTLRCommonTree *K_SEMICOLON29_tree=nil;
ANTLRCommonTree *K_SEMICOLON30_tree=nil;

-        // SimpleC.g:58:5: ( forStat | expr K_SEMICOLON | block | assignStat K_SEMICOLON | K_SEMICOLON ) //ruleblock
+        // SimpleC.g:58:5: ( forStat | expr K_SEMICOLON !| block | assignStat K_SEMICOLON !| K_SEMICOLON !) //ruleblock
NSInteger alt7=5;
-        switch ([input LA:1]) {
+        unichar charLA7 = [input LA:1];
+        switch (charLA7) {
case K_FOR: ;
{
alt7=1;
@@ -1935,17 +2126,19 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
if ( (LA7_2==K_EQ) ) {
alt7=4;
}
-                else if ( (LA7_2==K_SEMICOLON||(LA7_2>=K_EQEQ && LA7_2<=K_PLUS)) ) {
+                else if ( (LA7_2==K_EQEQ||(LA7_2 >= K_LT && LA7_2 <= K_PLUS)||LA7_2==K_SEMICOLON) ) {
alt7=2;
}
else {
-                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:7 state:2 stream:input];
+                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:7 state:2 stream:input];
+                    nvae.c = LA7_2;
@throw nvae;
+
}
}
break;
-            case K_LCURVE: ;
case K_INT: ;
+            case K_LCURVE: ;
{
alt7=2;
}
@@ -1962,8 +2155,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
break;

default: ;
-            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:7 state:0 stream:input];
+            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:7 state:0 stream:input];
+            nvae.c = charLA7;
@throw nvae;
+
}

switch (alt7) {
@@ -1972,30 +2167,37 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser ruleRef */
+                /* ruleRef */
[self pushFollow:FOLLOW_forStat_in_stat449];
forStat24 = [self forStat];
+
[self popFollow];


-                [treeAdaptor addChild:[forStat24 getTree] toTree:root_0];  /* element() */
-                 /* elements */
+                [treeAdaptor addChild:[forStat24 getTree] toTree:root_0];
+
}
break;
case 2 : ;
-                // SimpleC.g:59:7: expr K_SEMICOLON // alt
+                // SimpleC.g:59:7: expr K_SEMICOLON ! // alt
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser ruleRef */
+                /* ruleRef */
[self pushFollow:FOLLOW_expr_in_stat457];
expr25 = [self expr];
+
[self popFollow];


-                [treeAdaptor addChild:[expr25 getTree] toTree:root_0];  /* element() */
-                K_SEMICOLON26=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat459];   /* element() */
-                 /* elements */
+                [treeAdaptor addChild:[expr25 getTree] toTree:root_0];
+
+                K_SEMICOLON26=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat459];
+
}
break;
case 3 : ;
@@ -2003,39 +2205,47 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser ruleRef */
+                /* ruleRef */
[self pushFollow:FOLLOW_block_in_stat468];
block27 = [self block];
+
[self popFollow];


-                [treeAdaptor addChild:[block27 getTree] toTree:root_0];  /* element() */
-                 /* elements */
+                [treeAdaptor addChild:[block27 getTree] toTree:root_0];
+
}
break;
case 4 : ;
-                // SimpleC.g:61:7: assignStat K_SEMICOLON // alt
+                // SimpleC.g:61:7: assignStat K_SEMICOLON ! // alt
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser ruleRef */
+                /* ruleRef */
[self pushFollow:FOLLOW_assignStat_in_stat476];
assignStat28 = [self assignStat];
+
[self popFollow];


-                [treeAdaptor addChild:[assignStat28 getTree] toTree:root_0];  /* element() */
-                K_SEMICOLON29=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat478];   /* element() */
-                 /* elements */
+                [treeAdaptor addChild:[assignStat28 getTree] toTree:root_0];
+
+                K_SEMICOLON29=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat478];
+
}
break;
case 5 : ;
-                // SimpleC.g:62:7: K_SEMICOLON // alt
+                // SimpleC.g:62:7: K_SEMICOLON ! // alt
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

-                K_SEMICOLON30=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat487];   /* element() */
-                 /* elements */
+
+                K_SEMICOLON30=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_stat487];
+
}
break;

@@ -2046,33 +2256,41 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[retval setStop:[input LT:-1]];


+
retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end stat */
+
/*
* $ANTLR start forStat
* SimpleC.g:65:1: forStat : K_FOR K_LCURVE start= assignStat K_SEMICOLON expr K_SEMICOLON next= assignStat K_RCURVE block -> ^( K_FOR $start expr $next block ) ;
*/
- (SimpleCParser_forStat_return *) forStat
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_forStat_return * retval = [SimpleCParser_forStat_return newSimpleCParser_forStat_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
@@ -2082,39 +2300,39 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
ANTLRCommonToken *K_SEMICOLON33 = nil;
ANTLRCommonToken *K_SEMICOLON35 = nil;
ANTLRCommonToken *K_RCURVE36 = nil;
-        SimpleCParser_assignStat_return * start = nil;
-
-        SimpleCParser_assignStat_return * next = nil;
-
-        SimpleCParser_expr_return * expr34 = nil;
-
-        SimpleCParser_block_return * block37 = nil;
-
+         SimpleCParser_assignStat_return * start = nil ;
+
+         SimpleCParser_assignStat_return * next = nil ;
+
+         SimpleCParser_expr_return * expr34 = nil ;
+
+         SimpleCParser_block_return * block37 = nil ;
+

ANTLRCommonTree *K_FOR31_tree=nil;
ANTLRCommonTree *K_LCURVE32_tree=nil;
ANTLRCommonTree *K_SEMICOLON33_tree=nil;
ANTLRCommonTree *K_SEMICOLON35_tree=nil;
ANTLRCommonTree *K_RCURVE36_tree=nil;
-        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
+        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_LCURVE"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
+        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_RCURVE"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
+        ANTLRRewriteRuleTokenStream *stream_K_SEMICOLON =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_SEMICOLON"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_FOR =
+        ANTLRRewriteRuleTokenStream *stream_K_FOR =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_FOR"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_assignStat =
+        ANTLRRewriteRuleSubtreeStream *stream_assignStat =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule assignStat"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_block =
+        ANTLRRewriteRuleSubtreeStream *stream_block =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule block"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_expr =
+        ANTLRRewriteRuleSubtreeStream *stream_expr =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule expr"] retain];
// SimpleC.g:66:5: ( K_FOR K_LCURVE start= assignStat K_SEMICOLON expr K_SEMICOLON next= assignStat K_RCURVE block -> ^( K_FOR $start expr $next block ) ) // ruleBlockSingleAlt
@@ -2122,68 +2340,78 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
K_FOR31=(ANTLRCommonToken *)[self match:input TokenType:K_FOR Follow:FOLLOW_K_FOR_in_forStat507];
[stream_K_FOR addElement:K_FOR31];
-          /* element() */
+
+
K_LCURVE32=(ANTLRCommonToken *)[self match:input TokenType:K_LCURVE Follow:FOLLOW_K_LCURVE_in_forStat509];
[stream_K_LCURVE addElement:K_LCURVE32];
-          /* element() */
+
+
+        /* ruleRef */
[self pushFollow:FOLLOW_assignStat_in_forStat513];
start = [self assignStat];
+
[self popFollow];


-        [stream_assignStat addElement:[start getTree]];  /* element() */
+        [stream_assignStat addElement:[start getTree]];
+
K_SEMICOLON33=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_forStat515];
[stream_K_SEMICOLON addElement:K_SEMICOLON33];
-          /* element() */
+
+
+        /* ruleRef */
[self pushFollow:FOLLOW_expr_in_forStat517];
expr34 = [self expr];
+
[self popFollow];


-        [stream_expr addElement:[expr34 getTree]];  /* element() */
+        [stream_expr addElement:[expr34 getTree]];
+
K_SEMICOLON35=(ANTLRCommonToken *)[self match:input TokenType:K_SEMICOLON Follow:FOLLOW_K_SEMICOLON_in_forStat519];
[stream_K_SEMICOLON addElement:K_SEMICOLON35];
-          /* element() */
+
+
+        /* ruleRef */
[self pushFollow:FOLLOW_assignStat_in_forStat523];
next = [self assignStat];
+
[self popFollow];


-        [stream_assignStat addElement:[next getTree]];  /* element() */
+        [stream_assignStat addElement:[next getTree]];
+
K_RCURVE36=(ANTLRCommonToken *)[self match:input TokenType:K_RCURVE Follow:FOLLOW_K_RCURVE_in_forStat525];
[stream_K_RCURVE addElement:K_RCURVE36];
-          /* element() */
+
+
+        /* ruleRef */
[self pushFollow:FOLLOW_block_in_forStat527];
block37 = [self block];
+
[self popFollow];


-        [stream_block addElement:[block37 getTree]];  /* element() */
-         /* elements */
+        [stream_block addElement:[block37 getTree]];

// AST REWRITE
-        // elements: expr, start, block, next, K_FOR
+        // elements: start, next, expr, block, K_FOR
// token labels:
// rule labels: retval, start, next
// token list labels:
// rule list labels:
// wildcard labels:
-         [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token retval"
-                                                                    element:retval!=nil?[retval getTree]:nil] retain];
+                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];
ANTLRRewriteRuleSubtreeStream *stream_start =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token start"
-                                                                    element:start!=nil?[start getTree]:nil] retain];
+                description:@"token start" element:start!=nil?[start getTree]:nil] retain];
ANTLRRewriteRuleSubtreeStream *stream_next =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token next"
-                                                                    element:next!=nil?[next getTree]:nil] retain];
+                description:@"token next" element:next!=nil?[next getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -2192,11 +2420,16 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:67:12: ^( K_FOR $start expr $next block )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:[stream_K_FOR nextNode] old:root_1];
+                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
+                            [stream_K_FOR nextNode]
+                 old:root_1];

[treeAdaptor addChild:[stream_start nextTree] toTree:root_1];
+
[treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];
+
[treeAdaptor addChild:[stream_next nextTree] toTree:root_1];
+
[treeAdaptor addChild:[stream_block nextTree] toTree:root_1];

[treeAdaptor addChild:root_1 toTree:root_0];
@@ -2204,8 +2437,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}

/* ASTParser ruleCleanUp */
@@ -2213,6 +2448,7 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_K_LCURVE release];
[stream_K_RCURVE release];
[stream_K_SEMICOLON release];
@@ -2222,50 +2458,57 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[stream_expr release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end forStat */
+
/*
* $ANTLR start assignStat
* SimpleC.g:70:1: assignStat : K_ID K_EQ expr -> ^( K_EQ K_ID expr ) ;
*/
- (SimpleCParser_assignStat_return *) assignStat
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_assignStat_return * retval = [SimpleCParser_assignStat_return newSimpleCParser_assignStat_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
ANTLRCommonToken *K_ID38 = nil;
ANTLRCommonToken *K_EQ39 = nil;
-        SimpleCParser_expr_return * expr40 = nil;
-
+         SimpleCParser_expr_return * expr40 = nil ;
+

ANTLRCommonTree *K_ID38_tree=nil;
ANTLRCommonTree *K_EQ39_tree=nil;
-        ANTLRRewriteRuleTokenStream *stream_K_ID =
+        ANTLRRewriteRuleTokenStream *stream_K_ID =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_ID"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_EQ =
+        ANTLRRewriteRuleTokenStream *stream_K_EQ =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_EQ"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_expr =
+        ANTLRRewriteRuleSubtreeStream *stream_expr =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule expr"] retain];
// SimpleC.g:71:5: ( K_ID K_EQ expr -> ^( K_EQ K_ID expr ) ) // ruleBlockSingleAlt
@@ -2273,33 +2516,33 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
K_ID38=(ANTLRCommonToken *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_assignStat570];
[stream_K_ID addElement:K_ID38];
-          /* element() */
+
+
K_EQ39=(ANTLRCommonToken *)[self match:input TokenType:K_EQ Follow:FOLLOW_K_EQ_in_assignStat572];
[stream_K_EQ addElement:K_EQ39];
-          /* element() */
+
+
+        /* ruleRef */
[self pushFollow:FOLLOW_expr_in_assignStat574];
expr40 = [self expr];
+
[self popFollow];


-        [stream_expr addElement:[expr40 getTree]];  /* element() */
-         /* elements */
+        [stream_expr addElement:[expr40 getTree]];

// AST REWRITE
-        // elements: K_EQ, expr, K_ID
+        // elements: K_ID, K_EQ, expr
// token labels:
// rule labels: retval
// token list labels:
// rule list labels:
// wildcard labels:
-         [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token retval"
-                                                                    element:retval!=nil?[retval getTree]:nil] retain];
+                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -2308,10 +2551,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// SimpleC.g:71:27: ^( K_EQ K_ID expr )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:[stream_K_EQ nextNode] old:root_1];
+                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:
+                            [stream_K_EQ nextNode]
+                 old:root_1];

// TODO: args:
-                [treeAdaptor addChild:[stream_K_ID nextNode] toTree:root_1];
+                [treeAdaptor addChild:
+                            [stream_K_ID nextNode]
+                 toTree:root_1];
+
[treeAdaptor addChild:[stream_expr nextTree] toTree:root_1];

[treeAdaptor addChild:root_1 toTree:root_0];
@@ -2319,8 +2567,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}

/* ASTParser ruleCleanUp */
@@ -2328,43 +2578,51 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_K_ID release];
[stream_K_EQ release];
[stream_expr release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end assignStat */
+
/*
* $ANTLR start expr
* SimpleC.g:74:1: expr : condExpr ;
*/
- (SimpleCParser_expr_return *) expr
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_expr_return * retval = [SimpleCParser_expr_return newSimpleCParser_expr_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
-        SimpleCParser_condExpr_return * condExpr41 = nil;
-
+         SimpleCParser_condExpr_return * condExpr41 = nil ;
+


// SimpleC.g:74:5: ( condExpr ) // ruleBlockSingleAlt
@@ -2372,14 +2630,17 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser ruleRef */
+        /* ruleRef */
[self pushFollow:FOLLOW_condExpr_in_expr598];
condExpr41 = [self condExpr];
+
[self popFollow];


-        [treeAdaptor addChild:[condExpr41 getTree] toTree:root_0];  /* element() */
-         /* elements */
+        [treeAdaptor addChild:[condExpr41 getTree] toTree:root_0];
+
}

/* ASTParser ruleCleanUp */
@@ -2388,71 +2649,83 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[retval setStop:[input LT:-1]];


+
retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end expr */
+
/*
* $ANTLR start condExpr
- * SimpleC.g:77:1: condExpr : aexpr ( ( K_EQEQ | K_LT ) aexpr )? ;
+ * SimpleC.g:77:1: condExpr : aexpr ( ( K_EQEQ ^| K_LT ^) aexpr )? ;
*/
- (SimpleCParser_condExpr_return *) condExpr
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_condExpr_return * retval = [SimpleCParser_condExpr_return newSimpleCParser_condExpr_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
ANTLRCommonToken *K_EQEQ43 = nil;
ANTLRCommonToken *K_LT44 = nil;
-        SimpleCParser_aexpr_return * aexpr42 = nil;
-
-        SimpleCParser_aexpr_return * aexpr45 = nil;
-
+         SimpleCParser_aexpr_return * aexpr42 = nil ;
+
+         SimpleCParser_aexpr_return * aexpr45 = nil ;
+

ANTLRCommonTree *K_EQEQ43_tree=nil;
ANTLRCommonTree *K_LT44_tree=nil;

-        // SimpleC.g:78:5: ( aexpr ( ( K_EQEQ | K_LT ) aexpr )? ) // ruleBlockSingleAlt
-        // SimpleC.g:78:9: aexpr ( ( K_EQEQ | K_LT ) aexpr )? // alt
+        // SimpleC.g:78:5: ( aexpr ( ( K_EQEQ ^| K_LT ^) aexpr )? ) // ruleBlockSingleAlt
+        // SimpleC.g:78:9: aexpr ( ( K_EQEQ ^| K_LT ^) aexpr )? // alt
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser ruleRef */
+        /* ruleRef */
[self pushFollow:FOLLOW_aexpr_in_condExpr617];
aexpr42 = [self aexpr];
+
[self popFollow];


-        [treeAdaptor addChild:[aexpr42 getTree] toTree:root_0];  /* element() */
-        // SimpleC.g:78:15: ( ( K_EQEQ | K_LT ) aexpr )? // block
+        [treeAdaptor addChild:[aexpr42 getTree] toTree:root_0];
+
+        // SimpleC.g:78:15: ( ( K_EQEQ ^| K_LT ^) aexpr )? // block
NSInteger alt9=2;
NSInteger LA9_0 = [input LA:1];

-        if ( ((LA9_0>=K_EQEQ && LA9_0<=K_LT)) ) {
+        if ( (LA9_0==K_EQEQ||LA9_0==K_LT) ) {
alt9=1;
}
switch (alt9) {
case 1 : ;
-                // SimpleC.g:78:17: ( K_EQEQ | K_LT ) aexpr // alt
+                // SimpleC.g:78:17: ( K_EQEQ ^| K_LT ^) aexpr // alt
{
-                // SimpleC.g:78:17: ( K_EQEQ | K_LT ) // block
+                // SimpleC.g:78:17: ( K_EQEQ ^| K_LT ^) // block
NSInteger alt8=2;
NSInteger LA8_0 = [input LA:1];

@@ -2463,49 +2736,56 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
alt8=2;
}
else {
-                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:8 state:0 stream:input];
+                    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:8 state:0 stream:input];
+                    nvae.c = LA8_0;
@throw nvae;
+
}
switch (alt8) {
case 1 : ;
-                        // SimpleC.g:78:18: K_EQEQ // alt
+                        // SimpleC.g:78:18: K_EQEQ ^ // alt
{
K_EQEQ43=(ANTLRCommonToken *)[self match:input TokenType:K_EQEQ Follow:FOLLOW_K_EQEQ_in_condExpr622];
K_EQEQ43_tree = /* ASTParser createNodeFromToken */
-                        (ANTLRCommonTree *)[[treeAdaptor createTree:K_EQEQ43] retain];
+                        (ANTLRCommonTree *)[[treeAdaptor create:K_EQEQ43] retain]
+                        ;
root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:K_EQEQ43_tree old:root_0];
-                          /* element() */
-                         /* elements */
+
+
}
break;
case 2 : ;
-                        // SimpleC.g:78:28: K_LT // alt
+                        // SimpleC.g:78:28: K_LT ^ // alt
{
K_LT44=(ANTLRCommonToken *)[self match:input TokenType:K_LT Follow:FOLLOW_K_LT_in_condExpr627];
K_LT44_tree = /* ASTParser createNodeFromToken */
-                        (ANTLRCommonTree *)[[treeAdaptor createTree:K_LT44] retain];
+                        (ANTLRCommonTree *)[[treeAdaptor create:K_LT44] retain]
+                        ;
root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:K_LT44_tree old:root_0];
-                          /* element() */
-                         /* elements */
+
+
}
break;

}
-                  /* element() */
+
+
/* ASTParser ruleRef */
+                /* ruleRef */
[self pushFollow:FOLLOW_aexpr_in_condExpr631];
aexpr45 = [self aexpr];
+
[self popFollow];


-                [treeAdaptor addChild:[aexpr45 getTree] toTree:root_0];  /* element() */
-                 /* elements */
+                [treeAdaptor addChild:[aexpr45 getTree] toTree:root_0];
+
}
break;

}
-          /* element() */
-         /* elements */
+
+
}

/* ASTParser ruleCleanUp */
@@ -2514,57 +2794,69 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[retval setStop:[input LT:-1]];


+
retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end condExpr */
+
/*
* $ANTLR start aexpr
- * SimpleC.g:81:1: aexpr : atom ( K_PLUS atom )* ;
+ * SimpleC.g:81:1: aexpr : atom ( K_PLUS ^ atom )* ;
*/
- (SimpleCParser_aexpr_return *) aexpr
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_aexpr_return * retval = [SimpleCParser_aexpr_return newSimpleCParser_aexpr_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
ANTLRCommonToken *K_PLUS47 = nil;
-        SimpleCParser_atom_return * atom46 = nil;
-
-        SimpleCParser_atom_return * atom48 = nil;
-
+         SimpleCParser_atom_return * atom46 = nil ;
+
+         SimpleCParser_atom_return * atom48 = nil ;
+

ANTLRCommonTree *K_PLUS47_tree=nil;

-        // SimpleC.g:82:5: ( atom ( K_PLUS atom )* ) // ruleBlockSingleAlt
-        // SimpleC.g:82:9: atom ( K_PLUS atom )* // alt
+        // SimpleC.g:82:5: ( atom ( K_PLUS ^ atom )* ) // ruleBlockSingleAlt
+        // SimpleC.g:82:9: atom ( K_PLUS ^ atom )* // alt
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser ruleRef */
+        /* ruleRef */
[self pushFollow:FOLLOW_atom_in_aexpr653];
atom46 = [self atom];
+
[self popFollow];


-        [treeAdaptor addChild:[atom46 getTree] toTree:root_0];  /* element() */
+        [treeAdaptor addChild:[atom46 getTree] toTree:root_0];
+
do {
NSInteger alt10=2;
NSInteger LA10_0 = [input LA:1];
@@ -2575,21 +2867,25 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

switch (alt10) {
case 1 : ;
-                    // SimpleC.g:82:16: K_PLUS atom // alt
+                    // SimpleC.g:82:16: K_PLUS ^ atom // alt
{
K_PLUS47=(ANTLRCommonToken *)[self match:input TokenType:K_PLUS Follow:FOLLOW_K_PLUS_in_aexpr657];
K_PLUS47_tree = /* ASTParser createNodeFromToken */
-                    (ANTLRCommonTree *)[[treeAdaptor createTree:K_PLUS47] retain];
+                    (ANTLRCommonTree *)[[treeAdaptor create:K_PLUS47] retain]
+                    ;
root_0 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:K_PLUS47_tree old:root_0];
-                      /* element() */
+
+
/* ASTParser ruleRef */
+                    /* ruleRef */
[self pushFollow:FOLLOW_atom_in_aexpr660];
atom48 = [self atom];
+
[self popFollow];


-                    [treeAdaptor addChild:[atom48 getTree] toTree:root_0];  /* element() */
-                     /* elements */
+                    [treeAdaptor addChild:[atom48 getTree] toTree:root_0];
+
}
break;

@@ -2598,8 +2894,8 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
}
} while (YES);
loop10: ;
-          /* element() */
-         /* elements */
+
+
}

/* ASTParser ruleCleanUp */
@@ -2608,33 +2904,41 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
[retval setStop:[input LT:-1]];


+
retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end aexpr */
+
/*
* $ANTLR start atom
* SimpleC.g:85:1: atom : ( K_ID | K_INT | K_LCURVE expr K_RCURVE -> expr );
*/
- (SimpleCParser_atom_return *) atom
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
SimpleCParser_atom_return * retval = [SimpleCParser_atom_return newSimpleCParser_atom_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
@@ -2643,25 +2947,26 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
ANTLRCommonToken *K_INT50 = nil;
ANTLRCommonToken *K_LCURVE51 = nil;
ANTLRCommonToken *K_RCURVE53 = nil;
-        SimpleCParser_expr_return * expr52 = nil;
-
+         SimpleCParser_expr_return * expr52 = nil ;
+

ANTLRCommonTree *K_ID49_tree=nil;
ANTLRCommonTree *K_INT50_tree=nil;
ANTLRCommonTree *K_LCURVE51_tree=nil;
ANTLRCommonTree *K_RCURVE53_tree=nil;
-        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
+        ANTLRRewriteRuleTokenStream *stream_K_LCURVE =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_LCURVE"] retain];
-        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
+        ANTLRRewriteRuleTokenStream *stream_K_RCURVE =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token K_RCURVE"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_expr =
+        ANTLRRewriteRuleSubtreeStream *stream_expr =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule expr"] retain];
// SimpleC.g:86:5: ( K_ID | K_INT | K_LCURVE expr K_RCURVE -> expr ) //ruleblock
NSInteger alt11=3;
-        switch ([input LA:1]) {
+        unichar charLA11 = [input LA:1];
+        switch (charLA11) {
case K_ID: ;
{
alt11=1;
@@ -2679,8 +2984,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
break;

default: ;
-            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:11 state:0 stream:input];
+            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:11 state:0 stream:input];
+            nvae.c = charLA11;
@throw nvae;
+
}

switch (alt11) {
@@ -2689,13 +2996,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser tokenRef */
K_ID49=(ANTLRCommonToken *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_atom680];
K_ID49_tree = /* ASTParser createNodeFromToken */
-                (ANTLRCommonTree *)[[treeAdaptor createTree:K_ID49] retain];
+                (ANTLRCommonTree *)[[treeAdaptor create:K_ID49] retain]
+                ;
[treeAdaptor addChild:K_ID49_tree  toTree:root_0];
-                  /* element() */
-                 /* elements */
+
+
}
break;
case 2 : ;
@@ -2703,13 +3012,15 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser tokenRef */
K_INT50=(ANTLRCommonToken *)[self match:input TokenType:K_INT Follow:FOLLOW_K_INT_in_atom694];
K_INT50_tree = /* ASTParser createNodeFromToken */
-                (ANTLRCommonTree *)[[treeAdaptor createTree:K_INT50] retain];
+                (ANTLRCommonTree *)[[treeAdaptor create:K_INT50] retain]
+                ;
[treeAdaptor addChild:K_INT50_tree  toTree:root_0];
-                  /* element() */
-                 /* elements */
+
+
}
break;
case 3 : ;
@@ -2717,17 +3028,20 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
{
K_LCURVE51=(ANTLRCommonToken *)[self match:input TokenType:K_LCURVE Follow:FOLLOW_K_LCURVE_in_atom708];
[stream_K_LCURVE addElement:K_LCURVE51];
-                  /* element() */
+
+
+                /* ruleRef */
[self pushFollow:FOLLOW_expr_in_atom710];
expr52 = [self expr];
+
[self popFollow];


-                [stream_expr addElement:[expr52 getTree]];  /* element() */
+                [stream_expr addElement:[expr52 getTree]];
+
K_RCURVE53=(ANTLRCommonToken *)[self match:input TokenType:K_RCURVE Follow:FOLLOW_K_RCURVE_in_atom712];
[stream_K_RCURVE addElement:K_RCURVE53];
-                  /* element() */
-                 /* elements */
+

// AST REWRITE
// elements: expr
@@ -2736,14 +3050,11 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token list labels:
// rule list labels:
// wildcard labels:
-                 [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                        description:@"token retval"
-                                                                            element:retval!=nil?[retval getTree]:nil] retain];
+                        description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -2753,8 +3064,10 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000

}

+
retval.tree = root_0;

+
}
break;

@@ -2764,29 +3077,30 @@ static const unsigned long long FOLLOW_K_RCURVE_in_atom712_data[] = { 0x00000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_K_LCURVE release];
[stream_K_RCURVE release];
[stream_expr release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end atom */
+/* ObjC end rules */

@end /* end of SimpleCParser implementation line 692 */
-
-
-/* End of code
- * =============================================================================
- */
diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.h b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.h
index 5f60eaa..2832b66 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.h
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.h
@@ -1,89 +1,126 @@
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 SimpleCTP.g 2010-08-25 11:11:23
+// $ANTLR ${project.version} ${buildNumber} SimpleCTP.g 2011-05-06 15:09:28

/* =============================================================================
* Standard antlr3 OBJC runtime definitions
*/
#import <Cocoa/Cocoa.h>
-#import "antlr3.h"
+#import <ANTLR/ANTLR.h>
/* End of standard antlr3 runtime definitions
* =============================================================================
*/

/* treeParserHeaderFile */
+#ifndef ANTLR3TokenTypeAlreadyDefined
+#define ANTLR3TokenTypeAlreadyDefined
+typedef enum {
+    ANTLR_EOF = -1,
+    INVALID,
+    EOR,
+    DOWN,
+    UP,
+    MIN
+} ANTLR3TokenType;
+#endif
+
#pragma mark Tokens
-#define K_ID 11
-#define K_RCURLY 19
-#define K_RCURVE 14
-#define K_INT 25
-#define K_EQEQ 22
-#define K_FOR 20
-#define FUNC_HDR 6
-#define FUNC_DEF 8
+#ifdef EOF
+#undef EOF
+#endif
#define EOF -1
-#define K_SEMICOLON 10
-#define K_INT_TYPE 15
-#define FUNC_DECL 7
-#define K_COMMA 13
-#define ARG_DEF 5
-#define K_LCURLY 18
+#define ARG_DEF 4
+#define BLOCK 5
+#define FUNC_DECL 6
+#define FUNC_DEF 7
+#define FUNC_HDR 8
+#define K_CHAR 9
+#define K_COMMA 10
+#define K_EQ 11
+#define K_EQEQ 12
+#define K_FOR 13
+#define K_ID 14
+#define K_INT 15
+#define K_INT_TYPE 16
+#define K_LCURLY 17
+#define K_LCURVE 18
+#define K_LT 19
+#define K_PLUS 20
+#define K_RCURLY 21
+#define K_RCURVE 22
+#define K_SEMICOLON 23
+#define K_VOID 24
+#define VAR_DEF 25
#define WS 26
-#define K_EQ 21
-#define BLOCK 9
-#define K_LCURVE 12
-#define K_LT 23
-#define K_CHAR 16
-#define K_VOID 17
-#define VAR_DEF 4
-#define K_PLUS 24
#pragma mark Dynamic Global Scopes
-@interface Symbols_Scope : ANTLRSymbolsScope {  /* globalAttributeScopeDecl */
+/* globalAttributeScopeInterface */
+@interface Symbols_Scope : ANTLRSymbolsScope {
ANTLRCommonTree * tree;
+
}
-/* start of properties */
+/* start of globalAttributeScopeInterface properties */
+
+@property (assign, getter=gettree, setter=settree:) ANTLRCommonTree * tree;

-@property (retain, getter=gettree, setter=settree:) ANTLRCommonTree * tree;
+/* end globalAttributeScopeInterface properties */

-/* end properties */

+ (Symbols_Scope *)newSymbols_Scope;
-/* start of iterated get and set functions */
+- (id) init;
+/* start of globalAttributeScopeInterface methodsDecl */

- (ANTLRCommonTree *)gettree;
- (void)settree:(ANTLRCommonTree *)aVal;

-/* End of iterated get and set functions */
+/* End of globalAttributeScopeInterface methodsDecl */

@end /* end of Symbols_Scope interface */

#pragma mark Dynamic Rule Scopes
#pragma mark Rule Return Scopes start
-/* returnScopeInterface */
-@interface SimpleCTP_expr_return :ANTLRTreeRuleReturnScope { /* returnScopeInterface line 1806 */
- /* start of memVars() */
+/* returnScopeInterface SimpleCTP_expr_return */
+@interface SimpleCTP_expr_return :ANTLRTreeRuleReturnScope { /* returnScopeInterface line 1838 */
+ /* ObjC start of memVars() */
}
- /* start properties */
+/* start properties */
+ (SimpleCTP_expr_return *)newSimpleCTP_expr_return;
/* this is start of set and get methods */
/* methodsDecl */
@end /* end of returnScopeInterface interface */

-#pragma mark Rule return scopes end
+
+
+
+/* Interface grammar class */
@interface SimpleCTP : ANTLRTreeParser { /* line 572 */
-// start of globalAttributeScopeMemVar
-/* globalAttributeScopeMemVar */
-ANTLRSymbolStack *gStack;
-Symbols_Scope *Symbols_scope;
+/* ObjC start of ruleAttributeScopeMemVar */

-// start of action-actionScope-memVars
-// start of ruleAttributeScopeMemVar

+/* ObjC end of ruleAttributeScopeMemVar */
+/* ObjC start of globalAttributeScopeMemVar */
+/* globalAttributeScopeMemVar */
+//ANTLRSymbolStack *gStack;
+ANTLRSymbolStack *Symbols_stack;
+Symbols_Scope *Symbols_scope;

-// Start of memVars
+/* ObjC end of globalAttributeScopeMemVar */
+/* ObjC start of actions.(actionScope).memVars */
+/* ObjC end of actions.(actionScope).memVars */
+/* ObjC start of memVars */
+/* ObjC end of memVars */

}

-// start of action-actionScope-methodsDecl
+/* ObjC start of actions.(actionScope).properties */
+/* ObjC end of actions.(actionScope).properties */
+/* ObjC start of properties */
+/* ObjC end of properties */
+
++ (void) initialize;
++ (id) newSimpleCTP:(id<ANTLRTreeNodeStream>)aStream;
+/* ObjC start of actions.(actionScope).methodsDecl */
+/* ObjC end of actions.(actionScope).methodsDecl */

+/* ObjC start of methodsDecl */
+/* ObjC end of methodsDecl */

- (void)program;
- (void)declaration;
@@ -100,3 +137,4 @@ Symbols_Scope *Symbols_scope;


@end /* end of SimpleCTP interface */
+
diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.m b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.m
index 15ea63d..a9100eb 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.m
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.m
@@ -1,43 +1,18 @@
/** \file
- *  This OBJC source file was generated by $ANTLR version 3.2 Aug 24, 2010 10:45:57
+ *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
*
*     -  From the grammar source file : SimpleCTP.g
- *     -                            On : 2010-08-25 11:11:23
- *     -           for the tree parser : SimpleCTPTreeParser *
- * Editing it, at least manually, is not wise.
+ *     -                            On : 2011-05-06 15:09:28
+ *     -           for the tree parser : SimpleCTPTreeParser
+ *
+ * Editing it, at least manually, is not wise.
*
* ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
*
*
*/
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 SimpleCTP.g 2010-08-25 11:11:23
+// $ANTLR ${project.version} ${buildNumber} SimpleCTP.g 2011-05-06 15:09:28
+

/* -----------------------------------------
* Include the ANTLR3 generated header file.
@@ -47,16 +22,13 @@


/* ============================================================================= */
-
/* =============================================================================
* Start of recognizer
*/

-
-
#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_declaration_in_program56;
-static const unsigned long long FOLLOW_declaration_in_program56_data[] = { 0x0000000000000192LL};
+static const unsigned long long FOLLOW_declaration_in_program56_data[] = { 0x00000000020000C2LL};
static ANTLRBitSet *FOLLOW_variable_in_declaration76;
static const unsigned long long FOLLOW_variable_in_declaration76_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_FUNC_DECL_in_declaration87;
@@ -66,13 +38,13 @@ static const unsigned long long FOLLOW_functionHeader_in_declaration89_data[] =
static ANTLRBitSet *FOLLOW_FUNC_DEF_in_declaration101;
static const unsigned long long FOLLOW_FUNC_DEF_in_declaration101_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_functionHeader_in_declaration103;
-static const unsigned long long FOLLOW_functionHeader_in_declaration103_data[] = { 0x0000000000000200LL};
+static const unsigned long long FOLLOW_functionHeader_in_declaration103_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_block_in_declaration105;
static const unsigned long long FOLLOW_block_in_declaration105_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_VAR_DEF_in_variable126;
static const unsigned long long FOLLOW_VAR_DEF_in_variable126_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_type_in_variable128;
-static const unsigned long long FOLLOW_type_in_variable128_data[] = { 0x0000000000000800LL};
+static const unsigned long long FOLLOW_type_in_variable128_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_declarator_in_variable130;
static const unsigned long long FOLLOW_declarator_in_variable130_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_ID_in_declarator150;
@@ -80,25 +52,23 @@ static const unsigned long long FOLLOW_K_ID_in_declarator150_data[] = { 0x000000
static ANTLRBitSet *FOLLOW_FUNC_HDR_in_functionHeader171;
static const unsigned long long FOLLOW_FUNC_HDR_in_functionHeader171_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_type_in_functionHeader173;
-static const unsigned long long FOLLOW_type_in_functionHeader173_data[] = { 0x0000000000000800LL};
+static const unsigned long long FOLLOW_type_in_functionHeader173_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_K_ID_in_functionHeader175;
-static const unsigned long long FOLLOW_K_ID_in_functionHeader175_data[] = { 0x0000000000000020LL};
+static const unsigned long long FOLLOW_K_ID_in_functionHeader175_data[] = { 0x0000000000000010LL};
static ANTLRBitSet *FOLLOW_formalParameter_in_functionHeader177;
-static const unsigned long long FOLLOW_formalParameter_in_functionHeader177_data[] = { 0x0000000000000028LL};
+static const unsigned long long FOLLOW_formalParameter_in_functionHeader177_data[] = { 0x0000000000000018LL};
static ANTLRBitSet *FOLLOW_ARG_DEF_in_formalParameter199;
static const unsigned long long FOLLOW_ARG_DEF_in_formalParameter199_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_type_in_formalParameter201;
-static const unsigned long long FOLLOW_type_in_formalParameter201_data[] = { 0x0000000000000800LL};
+static const unsigned long long FOLLOW_type_in_formalParameter201_data[] = { 0x0000000000004000LL};
static ANTLRBitSet *FOLLOW_declarator_in_formalParameter203;
static const unsigned long long FOLLOW_declarator_in_formalParameter203_data[] = { 0x0000000000000008LL};
-static ANTLRBitSet *FOLLOW_set_in_type0;
-static const unsigned long long FOLLOW_set_in_type0_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_BLOCK_in_block283;
static const unsigned long long FOLLOW_BLOCK_in_block283_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_variable_in_block285;
-static const unsigned long long FOLLOW_variable_in_block285_data[] = { 0x0000000003F00A18LL};
+static const unsigned long long FOLLOW_variable_in_block285_data[] = { 0x000000000218F828LL};
static ANTLRBitSet *FOLLOW_stat_in_block288;
-static const unsigned long long FOLLOW_stat_in_block288_data[] = { 0x0000000003F00A08LL};
+static const unsigned long long FOLLOW_stat_in_block288_data[] = { 0x000000000018F828LL};
static ANTLRBitSet *FOLLOW_forStat_in_stat302;
static const unsigned long long FOLLOW_forStat_in_stat302_data[] = { 0x0000000000000002LL};
static ANTLRBitSet *FOLLOW_expr_in_stat310;
@@ -108,60 +78,64 @@ static const unsigned long long FOLLOW_block_in_stat318_data[] = { 0x00000000000
static ANTLRBitSet *FOLLOW_K_FOR_in_forStat338;
static const unsigned long long FOLLOW_K_FOR_in_forStat338_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat340;
-static const unsigned long long FOLLOW_expr_in_forStat340_data[] = { 0x0000000003E00800LL};
+static const unsigned long long FOLLOW_expr_in_forStat340_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat342;
-static const unsigned long long FOLLOW_expr_in_forStat342_data[] = { 0x0000000003E00800LL};
+static const unsigned long long FOLLOW_expr_in_forStat342_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_forStat344;
-static const unsigned long long FOLLOW_expr_in_forStat344_data[] = { 0x0000000000000200LL};
+static const unsigned long long FOLLOW_expr_in_forStat344_data[] = { 0x0000000000000020LL};
static ANTLRBitSet *FOLLOW_block_in_forStat346;
static const unsigned long long FOLLOW_block_in_forStat346_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_EQEQ_in_expr362;
static const unsigned long long FOLLOW_K_EQEQ_in_expr362_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_expr_in_expr364;
-static const unsigned long long FOLLOW_expr_in_expr364_data[] = { 0x0000000003E00800LL};
+static const unsigned long long FOLLOW_expr_in_expr364_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_expr366;
static const unsigned long long FOLLOW_expr_in_expr366_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_LT_in_expr378;
static const unsigned long long FOLLOW_K_LT_in_expr378_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_expr_in_expr380;
-static const unsigned long long FOLLOW_expr_in_expr380_data[] = { 0x0000000003E00800LL};
+static const unsigned long long FOLLOW_expr_in_expr380_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_expr382;
static const unsigned long long FOLLOW_expr_in_expr382_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_PLUS_in_expr394;
static const unsigned long long FOLLOW_K_PLUS_in_expr394_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_expr_in_expr396;
-static const unsigned long long FOLLOW_expr_in_expr396_data[] = { 0x0000000003E00800LL};
+static const unsigned long long FOLLOW_expr_in_expr396_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_expr398;
static const unsigned long long FOLLOW_expr_in_expr398_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_K_EQ_in_expr410;
static const unsigned long long FOLLOW_K_EQ_in_expr410_data[] = { 0x0000000000000004LL};
static ANTLRBitSet *FOLLOW_K_ID_in_expr412;
-static const unsigned long long FOLLOW_K_ID_in_expr412_data[] = { 0x0000000003E00800LL};
+static const unsigned long long FOLLOW_K_ID_in_expr412_data[] = { 0x000000000018D800LL};
static ANTLRBitSet *FOLLOW_expr_in_expr416;
static const unsigned long long FOLLOW_expr_in_expr416_data[] = { 0x0000000000000008LL};
static ANTLRBitSet *FOLLOW_atom_in_expr429;
static const unsigned long long FOLLOW_atom_in_expr429_data[] = { 0x0000000000000002LL};
-static ANTLRBitSet *FOLLOW_set_in_atom0;
-static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x0000000000000002LL};


#pragma mark Dynamic Global Scopes
-@implementation Symbols_Scope  /* globalAttributeScopeImpl */
+@implementation Symbols_Scope  /* globalAttributeScopeImplementation */
/* start of synthesize -- OBJC-Line 1750 */

@synthesize tree;
+
+ (Symbols_Scope *)newSymbols_Scope
{
return [[[Symbols_Scope alloc] init] retain];
}
+
+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* start of iterate get and set functions */

- (ANTLRCommonTree *)gettree { return( tree ); }

- (void)settree:(ANTLRCommonTree *)aVal { tree = aVal; }

-
-
/* End of iterate get and set functions */

@end /* end of Symbols_Scope implementation */
@@ -169,28 +143,7 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000

#pragma mark Dynamic Rule Scopes

-#pragma mark Rule return scopes start
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
-
-/* returnScope */
+#pragma mark Rule Return Scopes start
@implementation SimpleCTP_expr_return /* returnScope */
/* start of synthesize -- OBJC-Line 1837 */
+ (SimpleCTP_expr_return *)newSimpleCTP_expr_return
@@ -198,17 +151,37 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
return [[[SimpleCTP_expr_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}



@end /* end of returnScope implementation */

-/* returnScope */

+//#pragma mark Rule return scopes start
+//

+#pragma mark Rule return scopes start

@implementation SimpleCTP  // line 637

+/* ObjC start of ruleAttributeScope */
+#pragma mark Dynamic Rule Scopes
+/* ObjC end of ruleAttributeScope */
+#pragma mark global Attribute Scopes
+/* ObjC start globalAttributeScope */
+static _stack;
+
+/* ObjC end globalAttributeScope */
+/* ObjC start actions.(actionScope).synthesize */
+/* ObjC end actions.(actionScope).synthesize */
+/* ObjC start synthesize() */
+/* ObjC end synthesize() */
+
+ (void) initialize
{
#pragma mark Bitsets
@@ -230,7 +203,6 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
FOLLOW_ARG_DEF_in_formalParameter199 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_ARG_DEF_in_formalParameter199_data Count:(NSUInteger)1] retain];
FOLLOW_type_in_formalParameter201 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_type_in_formalParameter201_data Count:(NSUInteger)1] retain];
FOLLOW_declarator_in_formalParameter203 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_declarator_in_formalParameter203_data Count:(NSUInteger)1] retain];
-    FOLLOW_set_in_type0 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_set_in_type0_data Count:(NSUInteger)1] retain];
FOLLOW_BLOCK_in_block283 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_BLOCK_in_block283_data Count:(NSUInteger)1] retain];
FOLLOW_variable_in_block285 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_variable_in_block285_data Count:(NSUInteger)1] retain];
FOLLOW_stat_in_block288 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_stat_in_block288_data Count:(NSUInteger)1] retain];
@@ -255,29 +227,31 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
FOLLOW_K_ID_in_expr412 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_K_ID_in_expr412_data Count:(NSUInteger)1] retain];
FOLLOW_expr_in_expr416 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_expr_in_expr416_data Count:(NSUInteger)1] retain];
FOLLOW_atom_in_expr429 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_atom_in_expr429_data Count:(NSUInteger)1] retain];
-    FOLLOW_set_in_atom0 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_set_in_atom0_data Count:(NSUInteger)1] retain];

-    [ANTLRBaseRecognizer setTokenNames:[[[NSArray alloc] initWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>",
- @"VAR_DEF", @"ARG_DEF", @"FUNC_HDR", @"FUNC_DECL", @"FUNC_DEF", @"BLOCK",
- @"K_SEMICOLON", @"K_ID", @"K_LCURVE", @"K_COMMA", @"K_RCURVE", @"K_INT_TYPE",
- @"K_CHAR", @"K_VOID", @"K_LCURLY", @"K_RCURLY", @"K_FOR", @"K_EQ", @"K_EQEQ",
- @"K_LT", @"K_PLUS", @"K_INT", @"WS", nil] retain]];
+    [ANTLRBaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>",
+ @"ARG_DEF", @"BLOCK", @"FUNC_DECL", @"FUNC_DEF", @"FUNC_HDR", @"K_CHAR",
+ @"K_COMMA", @"K_EQ", @"K_EQEQ", @"K_FOR", @"K_ID", @"K_INT", @"K_INT_TYPE",
+ @"K_LCURLY", @"K_LCURVE", @"K_LT", @"K_PLUS", @"K_RCURLY", @"K_RCURVE",
+ @"K_SEMICOLON", @"K_VOID", @"VAR_DEF", @"WS", nil] retain]];
+    [ANTLRBaseRecognizer setGrammarFileName:@"SimpleCTP.g"];
}

+ (SimpleCTP *)newSimpleCTP:(id<ANTLRTreeNodeStream>)aStream
{
-
return [[SimpleCTP alloc] initWithStream:aStream];

-}

+}

- (id) initWithStream:(id<ANTLRTreeNodeStream>)aStream
{
-    if ((self = [super initWithStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:12+1] retain]]) != nil) {
-
+    self = [super initWithStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:12+1] retain]];
+    if ( self != nil ) {


+        /* globalAttributeScopeInit */
+        Symbols_scope = [Symbols_Scope newSymbols_Scope];
+        Symbols_stack = [ANTLRSymbolStack newANTLRSymbolStackWithLen:30];
/* start of actions-actionScope-init */
/* start of init */
}
@@ -286,30 +260,36 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000

- (void) dealloc
{
-    [Symbols_scope release];
+    [Symbols_stack release];
[super dealloc];
}
-// start actions.actionScope.methods
-// start methods()
-// start rules
+
+/* ObjC start members */
+/* ObjC end members */
+/* ObjC start actions.(actionScope).methods */
+/* ObjC end actions.(actionScope).methods */
+/* ObjC start methods() */
+/* ObjC end methods() */
+/* ObjC start rules */
/*
* $ANTLR start program
* SimpleCTP.g:13:1: program : ( declaration )+ ;
*/
- (void) program
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:14:5: ( ( declaration )+ ) // ruleBlockSingleAlt
// SimpleCTP.g:14:9: ( declaration )+ // alt
{
// SimpleCTP.g:14:9: ( declaration )+ // positiveClosureBlock
-        NSInteger cnt1=0;
+        NSInteger cnt1 = 0;
do {
-            NSInteger alt1=2;
+            NSInteger alt1 = 2;
NSInteger LA1_0 = [input LA:1];
-            if ( (LA1_0==VAR_DEF||(LA1_0>=FUNC_DECL && LA1_0<=FUNC_DEF)) ) {
+            if ( ((LA1_0 >= FUNC_DECL && LA1_0 <= FUNC_DEF)||LA1_0==VAR_DEF) ) {
alt1=1;
}

@@ -318,26 +298,29 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
case 1 : ;
// SimpleCTP.g:14:9: declaration // alt
{
+                    /* ruleRef */
[self pushFollow:FOLLOW_declaration_in_program56];
[self declaration];
+
[self popFollow];

-                      /* element() */
-                     /* elements */
+
+
}
break;

default :
if ( cnt1 >= 1 )
goto loop1;
-                    ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:1];
+                    ANTLREarlyExitException *eee =
+                        [ANTLREarlyExitException newException:input decisionNumber:1];
@throw eee;
}
cnt1++;
} while (YES);
loop1: ;
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels
@@ -346,23 +329,30 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end program */
+
/*
* $ANTLR start declaration
* SimpleCTP.g:17:1: declaration : ( variable | ^( FUNC_DECL functionHeader ) | ^( FUNC_DEF functionHeader block ) );
*/
- (void) declaration
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:18:5: ( variable | ^( FUNC_DECL functionHeader ) | ^( FUNC_DEF functionHeader block ) ) //ruleblock
NSInteger alt2=3;
-        switch ([input LA:1]) {
+        unichar charLA2 = [input LA:1];
+        switch (charLA2) {
case VAR_DEF: ;
{
alt2=1;
@@ -380,57 +370,70 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
break;

default: ;
-            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:2 state:0 stream:input];
+            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:2 state:0 stream:input];
+            nvae.c = charLA2;
@throw nvae;
+
}

switch (alt2) {
case 1 : ;
// SimpleCTP.g:18:9: variable // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_variable_in_declaration76];
[self variable];
+
[self popFollow];

-                  /* element() */
-                 /* elements */
+
+
}
break;
case 2 : ;
// SimpleCTP.g:19:9: ^( FUNC_DECL functionHeader ) // alt
{
-                [self match:input TokenType:FUNC_DECL Follow:FOLLOW_FUNC_DECL_in_declaration87];   /* element() */
+                [self match:input TokenType:FUNC_DECL Follow:FOLLOW_FUNC_DECL_in_declaration87];

-                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+                    [self match:input TokenType:DOWN Follow:nil];
+                    /* ruleRef */
[self pushFollow:FOLLOW_functionHeader_in_declaration89];
[self functionHeader];
+
[self popFollow];

-                      /* element() */

-                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-                 /* elements */
+
+                    [self match:input TokenType:UP Follow:nil];
+
+
}
break;
case 3 : ;
// SimpleCTP.g:20:9: ^( FUNC_DEF functionHeader block ) // alt
{
-                [self match:input TokenType:FUNC_DEF Follow:FOLLOW_FUNC_DEF_in_declaration101];   /* element() */
+                [self match:input TokenType:FUNC_DEF Follow:FOLLOW_FUNC_DEF_in_declaration101];

-                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+                    [self match:input TokenType:DOWN Follow:nil];
+                    /* ruleRef */
[self pushFollow:FOLLOW_functionHeader_in_declaration103];
[self functionHeader];
+
[self popFollow];

-                      /* element() */
+
+
+                    /* ruleRef */
[self pushFollow:FOLLOW_block_in_declaration105];
[self block];
+
[self popFollow];

-                      /* element() */

-                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-                 /* elements */
+
+                    [self match:input TokenType:UP Follow:nil];
+
+
}
break;

@@ -441,39 +444,51 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end declaration */
+
/*
* $ANTLR start variable
* SimpleCTP.g:23:1: variable : ^( VAR_DEF type declarator ) ;
*/
- (void) variable
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:24:5: ( ^( VAR_DEF type declarator ) ) // ruleBlockSingleAlt
// SimpleCTP.g:24:9: ^( VAR_DEF type declarator ) // alt
{
-        [self match:input TokenType:VAR_DEF Follow:FOLLOW_VAR_DEF_in_variable126];   /* element() */
+        [self match:input TokenType:VAR_DEF Follow:FOLLOW_VAR_DEF_in_variable126];

-            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+            [self match:input TokenType:DOWN Follow:nil];
+            /* ruleRef */
[self pushFollow:FOLLOW_type_in_variable128];
[self type];
+
[self popFollow];

-              /* element() */
+
+
+            /* ruleRef */
[self pushFollow:FOLLOW_declarator_in_variable130];
[self declarator];
+
[self popFollow];

-              /* element() */

-            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-         /* elements */
+
+            [self match:input TokenType:UP Follow:nil];
+
+
}

// token+rule list labels
@@ -482,25 +497,31 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end variable */
+
/*
* $ANTLR start declarator
* SimpleCTP.g:27:1: declarator : K_ID ;
*/
- (void) declarator
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:28:5: ( K_ID ) // ruleBlockSingleAlt
// SimpleCTP.g:28:9: K_ID // alt
{
-        [self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_declarator150];   /* element() */
-         /* elements */
+        [self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_declarator150];
+
}

// token+rule list labels
@@ -509,36 +530,46 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end declarator */
+
/*
* $ANTLR start functionHeader
* SimpleCTP.g:31:1: functionHeader : ^( FUNC_HDR type K_ID ( formalParameter )+ ) ;
*/
- (void) functionHeader
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:32:5: ( ^( FUNC_HDR type K_ID ( formalParameter )+ ) ) // ruleBlockSingleAlt
// SimpleCTP.g:32:9: ^( FUNC_HDR type K_ID ( formalParameter )+ ) // alt
{
-        [self match:input TokenType:FUNC_HDR Follow:FOLLOW_FUNC_HDR_in_functionHeader171];   /* element() */
+        [self match:input TokenType:FUNC_HDR Follow:FOLLOW_FUNC_HDR_in_functionHeader171];

-            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+            [self match:input TokenType:DOWN Follow:nil];
+            /* ruleRef */
[self pushFollow:FOLLOW_type_in_functionHeader173];
[self type];
+
[self popFollow];

-              /* element() */
-            [self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_functionHeader175];   /* element() */
+
+
+            [self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_functionHeader175];
+
// SimpleCTP.g:32:30: ( formalParameter )+ // positiveClosureBlock
-            NSInteger cnt3=0;
+            NSInteger cnt3 = 0;
do {
-                NSInteger alt3=2;
+                NSInteger alt3 = 2;
NSInteger LA3_0 = [input LA:1];
if ( (LA3_0==ARG_DEF) ) {
alt3=1;
@@ -549,28 +580,32 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
case 1 : ;
// SimpleCTP.g:32:30: formalParameter // alt
{
+                        /* ruleRef */
[self pushFollow:FOLLOW_formalParameter_in_functionHeader177];
[self formalParameter];
+
[self popFollow];

-                          /* element() */
-                         /* elements */
+
+
}
break;

default :
if ( cnt3 >= 1 )
goto loop3;
-                        ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:3];
+                        ANTLREarlyExitException *eee =
+                            [ANTLREarlyExitException newException:input decisionNumber:3];
@throw eee;
}
cnt3++;
} while (YES);
loop3: ;
-              /* element() */

-            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-         /* elements */
+
+            [self match:input TokenType:UP Follow:nil];
+
+
}

// token+rule list labels
@@ -579,39 +614,51 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end functionHeader */
+
/*
* $ANTLR start formalParameter
* SimpleCTP.g:35:1: formalParameter : ^( ARG_DEF type declarator ) ;
*/
- (void) formalParameter
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:36:5: ( ^( ARG_DEF type declarator ) ) // ruleBlockSingleAlt
// SimpleCTP.g:36:9: ^( ARG_DEF type declarator ) // alt
{
-        [self match:input TokenType:ARG_DEF Follow:FOLLOW_ARG_DEF_in_formalParameter199];   /* element() */
+        [self match:input TokenType:ARG_DEF Follow:FOLLOW_ARG_DEF_in_formalParameter199];

-            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+            [self match:input TokenType:DOWN Follow:nil];
+            /* ruleRef */
[self pushFollow:FOLLOW_type_in_formalParameter201];
[self type];
+
[self popFollow];

-              /* element() */
+
+
+            /* ruleRef */
[self pushFollow:FOLLOW_declarator_in_formalParameter203];
[self declarator];
+
[self popFollow];

-              /* element() */

-            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-         /* elements */
+
+            [self match:input TokenType:UP Follow:nil];
+
+
}

// token+rule list labels
@@ -620,32 +667,38 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end formalParameter */
+
/*
* $ANTLR start type
* SimpleCTP.g:39:1: type : ( K_INT_TYPE | K_CHAR | K_VOID | K_ID );
*/
- (void) type
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:40:5: ( K_INT_TYPE | K_CHAR | K_VOID | K_ID ) // ruleBlockSingleAlt
// SimpleCTP.g: // alt
{
-        if ([input LA:1] == K_ID||(([input LA:1] >= K_INT_TYPE) && ([input LA:1] <= K_VOID))) {
+        if ([input LA:1] == K_CHAR||[input LA:1] == K_ID||[input LA:1] == K_INT_TYPE||[input LA:1] == K_VOID) {
[input consume];
[state setIsErrorRecovery:NO];
} else {
-            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
@throw mse;
}
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels
@@ -654,27 +707,33 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end type */
+
/*
* $ANTLR start block
* SimpleCTP.g:46:1: block : ^( BLOCK ( variable )* ( stat )* ) ;
*/
- (void) block
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:47:5: ( ^( BLOCK ( variable )* ( stat )* ) ) // ruleBlockSingleAlt
// SimpleCTP.g:47:9: ^( BLOCK ( variable )* ( stat )* ) // alt
{
-        [self match:input TokenType:BLOCK Follow:FOLLOW_BLOCK_in_block283];   /* element() */
+        [self match:input TokenType:BLOCK Follow:FOLLOW_BLOCK_in_block283];

-        if ( [input LA:1] == ANTLRTokenTypeDOWN ) {
-            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+        if ( [input LA:1] == DOWN ) {
+            [self match:input TokenType:DOWN Follow:nil];
do {
NSInteger alt4=2;
NSInteger LA4_0 = [input LA:1];
@@ -687,12 +746,14 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
case 1 : ;
// SimpleCTP.g:47:17: variable // alt
{
+                        /* ruleRef */
[self pushFollow:FOLLOW_variable_in_block285];
[self variable];
+
[self popFollow];

-                          /* element() */
-                         /* elements */
+
+
}
break;

@@ -701,11 +762,12 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
}
} while (YES);
loop4: ;
-              /* element() */
+
+
do {
NSInteger alt5=2;
NSInteger LA5_0 = [input LA:1];
-                if ( (LA5_0==BLOCK||LA5_0==K_ID||(LA5_0>=K_FOR && LA5_0<=K_INT)) ) {
+                if ( (LA5_0==BLOCK||(LA5_0 >= K_EQ && LA5_0 <= K_INT)||(LA5_0 >= K_LT && LA5_0 <= K_PLUS)) ) {
alt5=1;
}

@@ -714,12 +776,14 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
case 1 : ;
// SimpleCTP.g:47:27: stat // alt
{
+                        /* ruleRef */
[self pushFollow:FOLLOW_stat_in_block288];
[self stat];
+
[self popFollow];

-                          /* element() */
-                         /* elements */
+
+
}
break;

@@ -728,11 +792,12 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
}
} while (YES);
loop5: ;
-              /* element() */

-            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];
-        }  /* element() */
-         /* elements */
+
+            [self match:input TokenType:UP Follow:nil];
+        }
+
+
}

// token+rule list labels
@@ -741,34 +806,41 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end block */
+
/*
* $ANTLR start stat
* SimpleCTP.g:50:1: stat : ( forStat | expr | block );
*/
- (void) stat
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:50:5: ( forStat | expr | block ) //ruleblock
NSInteger alt6=3;
-        switch ([input LA:1]) {
+        unichar charLA6 = [input LA:1];
+        switch (charLA6) {
case K_FOR: ;
{
alt6=1;
}
break;
-            case K_ID: ;
case K_EQ: ;
case K_EQEQ: ;
+            case K_ID: ;
+            case K_INT: ;
case K_LT: ;
case K_PLUS: ;
-            case K_INT: ;
{
alt6=2;
}
@@ -780,42 +852,50 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
break;

default: ;
-            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:6 state:0 stream:input];
+            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:6 state:0 stream:input];
+            nvae.c = charLA6;
@throw nvae;
+
}

switch (alt6) {
case 1 : ;
// SimpleCTP.g:50:7: forStat // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_forStat_in_stat302];
[self forStat];
+
[self popFollow];

-                  /* element() */
-                 /* elements */
+
+
}
break;
case 2 : ;
// SimpleCTP.g:51:7: expr // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_expr_in_stat310];
[self expr];
+
[self popFollow];

-                  /* element() */
-                 /* elements */
+
+
}
break;
case 3 : ;
// SimpleCTP.g:52:7: block // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_block_in_stat318];
[self block];
+
[self popFollow];

-                  /* element() */
-                 /* elements */
+
+
}
break;

@@ -826,49 +906,67 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end stat */
+
/*
* $ANTLR start forStat
* SimpleCTP.g:55:1: forStat : ^( K_FOR expr expr expr block ) ;
*/
- (void) forStat
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:56:5: ( ^( K_FOR expr expr expr block ) ) // ruleBlockSingleAlt
// SimpleCTP.g:56:9: ^( K_FOR expr expr expr block ) // alt
{
-        [self match:input TokenType:K_FOR Follow:FOLLOW_K_FOR_in_forStat338];   /* element() */
+        [self match:input TokenType:K_FOR Follow:FOLLOW_K_FOR_in_forStat338];

-            [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+            [self match:input TokenType:DOWN Follow:nil];
+            /* ruleRef */
[self pushFollow:FOLLOW_expr_in_forStat340];
[self expr];
+
[self popFollow];

-              /* element() */
+
+
+            /* ruleRef */
[self pushFollow:FOLLOW_expr_in_forStat342];
[self expr];
+
[self popFollow];

-              /* element() */
+
+
+            /* ruleRef */
[self pushFollow:FOLLOW_expr_in_forStat344];
[self expr];
+
[self popFollow];

-              /* element() */
+
+
+            /* ruleRef */
[self pushFollow:FOLLOW_block_in_forStat346];
[self block];
+
[self popFollow];

-              /* element() */

-            [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-         /* elements */
+
+            [self match:input TokenType:UP Follow:nil];
+
+
}

// token+rule list labels
@@ -877,30 +975,38 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end forStat */
+
/*
* $ANTLR start expr
* SimpleCTP.g:59:1: expr : ( ^( K_EQEQ expr expr ) | ^( K_LT expr expr ) | ^( K_PLUS expr expr ) | ^( K_EQ K_ID e= expr ) | atom );
*/
- (SimpleCTP_expr_return *) expr
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

SimpleCTP_expr_return * retval = [SimpleCTP_expr_return newSimpleCTP_expr_return];
[retval setStart:[input LT:1]];

+
@try {
ANTLRCommonTree *K_ID1 = nil;
-        SimpleCTP_expr_return * e = nil;
-
+         SimpleCTP_expr_return * e = nil ;
+

// SimpleCTP.g:59:5: ( ^( K_EQEQ expr expr ) | ^( K_LT expr expr ) | ^( K_PLUS expr expr ) | ^( K_EQ K_ID e= expr ) | atom ) //ruleblock
NSInteger alt7=5;
-        switch ([input LA:1]) {
+        unichar charLA7 = [input LA:1];
+        switch (charLA7) {
case K_EQEQ: ;
{
alt7=1;
@@ -929,102 +1035,129 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
break;

default: ;
-            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:7 state:0 stream:input];
+            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:7 state:0 stream:input];
+            nvae.c = charLA7;
@throw nvae;
+
}

switch (alt7) {
case 1 : ;
// SimpleCTP.g:59:9: ^( K_EQEQ expr expr ) // alt
{
-                [self match:input TokenType:K_EQEQ Follow:FOLLOW_K_EQEQ_in_expr362];   /* element() */
+                [self match:input TokenType:K_EQEQ Follow:FOLLOW_K_EQEQ_in_expr362];

-                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+                    [self match:input TokenType:DOWN Follow:nil];
+                    /* ruleRef */
[self pushFollow:FOLLOW_expr_in_expr364];
[self expr];
+
[self popFollow];

-                      /* element() */
+
+
+                    /* ruleRef */
[self pushFollow:FOLLOW_expr_in_expr366];
[self expr];
+
[self popFollow];

-                      /* element() */

-                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-                 /* elements */
+
+                    [self match:input TokenType:UP Follow:nil];
+
+
}
break;
case 2 : ;
// SimpleCTP.g:60:9: ^( K_LT expr expr ) // alt
{
-                [self match:input TokenType:K_LT Follow:FOLLOW_K_LT_in_expr378];   /* element() */
+                [self match:input TokenType:K_LT Follow:FOLLOW_K_LT_in_expr378];

-                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+                    [self match:input TokenType:DOWN Follow:nil];
+                    /* ruleRef */
[self pushFollow:FOLLOW_expr_in_expr380];
[self expr];
+
[self popFollow];

-                      /* element() */
+
+
+                    /* ruleRef */
[self pushFollow:FOLLOW_expr_in_expr382];
[self expr];
+
[self popFollow];

-                      /* element() */

-                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-                 /* elements */
+
+                    [self match:input TokenType:UP Follow:nil];
+
+
}
break;
case 3 : ;
// SimpleCTP.g:61:9: ^( K_PLUS expr expr ) // alt
{
-                [self match:input TokenType:K_PLUS Follow:FOLLOW_K_PLUS_in_expr394];   /* element() */
+                [self match:input TokenType:K_PLUS Follow:FOLLOW_K_PLUS_in_expr394];

-                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
+                    [self match:input TokenType:DOWN Follow:nil];
+                    /* ruleRef */
[self pushFollow:FOLLOW_expr_in_expr396];
[self expr];
+
[self popFollow];

-                      /* element() */
+
+
+                    /* ruleRef */
[self pushFollow:FOLLOW_expr_in_expr398];
[self expr];
+
[self popFollow];

-                      /* element() */

-                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-                 /* elements */
+
+                    [self match:input TokenType:UP Follow:nil];
+
+
}
break;
case 4 : ;
// SimpleCTP.g:62:9: ^( K_EQ K_ID e= expr ) // alt
{
-                [self match:input TokenType:K_EQ Follow:FOLLOW_K_EQ_in_expr410];   /* element() */
+                [self match:input TokenType:K_EQ Follow:FOLLOW_K_EQ_in_expr410];

-                    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil];
-                    K_ID1=(ANTLRCommonTree *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_expr412];   /* element() */
+                    [self match:input TokenType:DOWN Follow:nil];
+                    K_ID1=(ANTLRCommonTree *)[self match:input TokenType:K_ID Follow:FOLLOW_K_ID_in_expr412];
+
+                    /* ruleRef */
[self pushFollow:FOLLOW_expr_in_expr416];
e = [self expr];
+
[self popFollow];

-                      /* element() */

-                    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil];   /* element() */
-                 NSLog(@"assigning %@ to variable %@", (e!=nil?[[input getTokenStream] toStringFromStart:[[input getTreeAdaptor] getTokenStartIndex:[e getStart]]
-                         ToEnd:[[input getTreeAdaptor] getTokenStopIndex:[e getStart]]]:nil), (K_ID1!=nil?[K_ID1 getText]:0));   /* element() */
-                 /* elements */
+
+                    [self match:input TokenType:UP Follow:nil];
+
+
+                 NSLog(@"assigning %@ to variable %@", (e!=nil?[[input getTokenStream] toStringFromStart:[[input getTreeAdaptor] getTokenStartIndex:[e getStart]]ToEnd:[[input getTreeAdaptor] getTokenStopIndex:[e getStart]]]:0), (K_ID1!=nil?K_ID1.text:nil));
+
+
}
break;
case 5 : ;
// SimpleCTP.g:63:9: atom // alt
{
+                /* ruleRef */
[self pushFollow:FOLLOW_atom_in_expr429];
[self atom];
+
[self popFollow];

-                  /* element() */
-                 /* elements */
+
+
}
break;

@@ -1035,32 +1168,38 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return retval;
}
/* $ANTLR end expr */
+
/*
* $ANTLR start atom
* SimpleCTP.g:66:1: atom : ( K_ID | K_INT );
*/
- (void) atom
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
// SimpleCTP.g:67:5: ( K_ID | K_INT ) // ruleBlockSingleAlt
// SimpleCTP.g: // alt
{
-        if ([input LA:1] == K_ID||[input LA:1] == K_INT) {
+        if ((([input LA:1] >= K_ID) && ([input LA:1] <= K_INT))) {
[input consume];
[state setIsErrorRecovery:NO];
} else {
-            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
+            ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
@throw mse;
}
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels
@@ -1069,15 +1208,15 @@ static const unsigned long long FOLLOW_set_in_atom0_data[] = { 0x000000000000000
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
-    }    @finally {
+    }
+
+    @finally {
+        /* Terence's stuff */
+
}
return ;
}
/* $ANTLR end atom */
+/* ObjC end rules */

@end /* end of SimpleCTP implementation line 692 */
-
-
-/* End of code
- * =============================================================================
- */
diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.tokens b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.tokens
index ea94deb..965ef1f 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.tokens
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/SimpleCTP.tokens
@@ -1,23 +1,23 @@
-K_ID=11
-K_RCURLY=19
-K_RCURVE=14
-K_INT=25
-K_EQEQ=22
-K_FOR=20
-FUNC_HDR=6
-FUNC_DEF=8
-K_SEMICOLON=10
-K_INT_TYPE=15
-FUNC_DECL=7
-K_COMMA=13
-ARG_DEF=5
-K_LCURLY=18
+ARG_DEF=4
+BLOCK=5
+FUNC_DECL=6
+FUNC_DEF=7
+FUNC_HDR=8
+K_CHAR=9
+K_COMMA=10
+K_EQ=11
+K_EQEQ=12
+K_FOR=13
+K_ID=14
+K_INT=15
+K_INT_TYPE=16
+K_LCURLY=17
+K_LCURVE=18
+K_LT=19
+K_PLUS=20
+K_RCURLY=21
+K_RCURVE=22
+K_SEMICOLON=23
+K_VOID=24
+VAR_DEF=25
WS=26
-K_EQ=21
-BLOCK=9
-K_LCURVE=12
-K_LT=23
-K_CHAR=16
-K_VOID=17
-VAR_DEF=4
-K_PLUS=24
diff --git a/runtime/ObjC/Framework/examples/simplecTreeParser/main.m b/runtime/ObjC/Framework/examples/simplecTreeParser/main.m
index 2181536..f735ac3 100644
--- a/runtime/ObjC/Framework/examples/simplecTreeParser/main.m
+++ b/runtime/ObjC/Framework/examples/simplecTreeParser/main.m
@@ -9,7 +9,7 @@
int main(int argc, const char * argv[]) {
NSError *anError;
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
-    char *inp = "../../examples/simplecTreeParser/input";
+    char *inp = "/Users/acondit/source/antlr3/acondit_localhost/code/antlr/antlr3-main/runtime/ObjC/Framework/examples/simplecTreeParser/input";

/*
if (argc < 2) {

