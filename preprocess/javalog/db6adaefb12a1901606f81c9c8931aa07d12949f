commit db6adaefb12a1901606f81c9c8931aa07d12949f
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Oct 27 10:44:34 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Oct 27 10:44:34 2011 -0800

v3: Fix labels in synpreds

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 9219]

diff --git a/tool/CHANGES.txt b/tool/CHANGES.txt
index 5f00e69..73162b6 100644
--- a/tool/CHANGES.txt
+++ b/tool/CHANGES.txt
@@ -10,6 +10,9 @@ CHANGES
October 25, 2011

* (Sam) Rule.setOption didn't do memoize option right.
+* (Sam) Fix labels in synpreds
+* (Sam) Fix input index for NoViableAltException during inline prediction
+* (Sam) Fix label aliasing errors in cases like (x=y|x=z)

August 10, 2011

diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g b/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g
index 2f0c605..7f3b397 100644
--- a/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g
@@ -410,7 +410,7 @@ rule returns [ST code=null]
// For syn preds, we don't want any AST code etc... in there.
// Save old templates ptr and restore later.  Base templates include Dbg.
STGroup saveGroup = templates;
-	if ( ruleDescr.isSynPred )
+	if ( ruleDescr.isSynPred && generator.target.useBaseTemplatesForSynPredFragments() )
{
templates = generator.getBaseTemplates();
}
diff --git a/tool/src/main/java/org/antlr/codegen/CSharp3Target.java b/tool/src/main/java/org/antlr/codegen/CSharp3Target.java
index f5fef65..9eea465 100644
--- a/tool/src/main/java/org/antlr/codegen/CSharp3Target.java
+++ b/tool/src/main/java/org/antlr/codegen/CSharp3Target.java
@@ -69,6 +69,11 @@ public class CSharp3Target extends Target {
}};

@Override
+    public boolean useBaseTemplatesForSynPredFragments() {
+        return false;
+    }
+
+    @Override
public String encodeIntAsCharEscape(int v) {
return "\\x" + Integer.toHexString(v).toUpperCase();
}
diff --git a/tool/src/main/java/org/antlr/codegen/JavaTarget.java b/tool/src/main/java/org/antlr/codegen/JavaTarget.java
index 3ec7a86..fdc4068 100644
--- a/tool/src/main/java/org/antlr/codegen/JavaTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/JavaTarget.java
@@ -35,6 +35,11 @@ import org.stringtemplate.v4.ST;
import java.util.Set;

public class JavaTarget extends Target {
+    @Override
+    public boolean useBaseTemplatesForSynPredFragments() {
+        return false;
+    }
+
protected ST chooseWhereCyclicDFAsGo(Tool tool,
CodeGenerator generator,
Grammar grammar,
diff --git a/tool/src/main/java/org/antlr/codegen/Target.java b/tool/src/main/java/org/antlr/codegen/Target.java
index 848dd7f..682f376 100644
--- a/tool/src/main/java/org/antlr/codegen/Target.java
+++ b/tool/src/main/java/org/antlr/codegen/Target.java
@@ -83,6 +83,10 @@ public class Target {
targetCharValueEscape['"'] = "\\\"";
}

+    public boolean useBaseTemplatesForSynPredFragments() {
+        return true;
+    }
+
protected void genRecognizerFile(Tool tool,
CodeGenerator generator,
Grammar grammar,
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
index 5b41343..22095ac 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
@@ -63,6 +63,7 @@ ruleDeclarations() ::= <<

ruleLabelDefs() ::= <<
<super.ruleLabelDefs()>
+<if(!ruleDescriptor.isSynPred)>
<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,
ruleDescriptor.wildcardTreeListLabels]:{it | <ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
<ruleDescriptor.tokenListLabels:{it | <ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
@@ -77,6 +78,7 @@ ruleLabelDefs() ::= <<
<ruleDescriptor.allRuleRefsInAltsWithRewrites
:{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
<endif>
+<endif>
>>

/** When doing auto AST construction, we must define some variables;
@@ -87,7 +89,7 @@ ruleLabelDefs() ::= <<
@alt.declarations() ::= <<
<if(autoAST)>
<if(outerAlt)>
-<if(!rewriteMode)>
+<if(!rewriteMode && !ruleDescriptor.isSynPred)>
root_0 = (<ASTLabelType>)adaptor.nil();<\n>
<endif>
<endif>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
index fd12288..497f042 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
@@ -48,10 +48,12 @@ retval.tree = (<ASTLabelType>)adaptor.errorNode(input, retval.start, input.LT(-1
/** ID and output=AST */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
<super.tokenRef(...)>
+<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<label>_tree = <createNodeFromToken(...)>;
adaptor.addChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
+<endif>
>>

/** ID! and output=AST (same as plain tokenRef) */
@@ -60,10 +62,12 @@ tokenRefBang(token,label,elementIndex,terminalOptions) ::= "<super.tokenRef(...)
/** ID^ and output=AST */
tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
<super.tokenRef(...)>
+<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<label>_tree = <createNodeFromToken(...)>;
root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
+<endif>
>>

/** ids+=ID! and output=AST */
@@ -98,7 +102,7 @@ tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
// I have more time.

matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <%
-<super.matchSet(postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.addChild(root_0, <createNodeFromToken(...)>);}, ...)>
+<super.matchSet(postmatchCode={<if(!ruleDescriptor.isSynPred)><if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.addChild(root_0, <createNodeFromToken(...)>);<endif>}, ...)>
%>

matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
@@ -114,7 +118,7 @@ matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
-<super.matchSet(postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.becomeRoot(<createNodeFromToken(...)>, root_0);},...)>
+<super.matchSet(postmatchCode={<if(!ruleDescriptor.isSynPred)><if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.becomeRoot(<createNodeFromToken(...)>, root_0);<endif>},...)>
>>

// RULE REF AST
@@ -122,7 +126,9 @@ matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
/** rule when output=AST */
ruleRef(rule,label,elementIndex,args,scope) ::= <<
<super.ruleRef(...)>
+<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.addChild(root_0, <label>.getTree());
+<endif>
>>

/** rule! is same as normal rule ref */
@@ -156,20 +162,24 @@ ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<

wildcard(token,label,elementIndex,terminalOptions) ::= <<
<super.wildcard(...)>
+<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.create(<label>);
adaptor.addChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
+<endif>
>>

wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"

wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
<super.wildcard(...)>
+<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.create(<label>);
root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
+<endif>
>>

createNodeFromToken(label,terminalOptions) ::= <<
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
index 305dca4..c8db8d5 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
@@ -41,14 +41,17 @@
/** Add a variable to track last element matched */
ruleDeclarations() ::= <<
<super.ruleDeclarations()>
+<if(!ruleDescriptor.isSynPred)>
<ASTLabelType> _first_0 = null;
<ASTLabelType> _last = null;<\n>
+<endif>
>>

/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
noRewrite(rewriteBlockLevel, treeLevel) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(rewriteMode)>
retval.tree = (<ASTLabelType>)_first_0;
@@ -56,6 +59,7 @@ if ( adaptor.getParent(retval.tree)!=null && adaptor.isNil( adaptor.getParent(re
retval.tree = (<ASTLabelType>)adaptor.getParent(retval.tree);
<endif>
<if(backtracking)>}<endif>
+<endif>
>>

/** match ^(root children) in tree parser; override here to
@@ -63,6 +67,7 @@ if ( adaptor.getParent(retval.tree)!=null && adaptor.isNil( adaptor.getParent(re
*/
tree(root, actionsAfterRoot, children, nullableChildList,
enclosingTreeLevel, treeLevel) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
{
<ASTLabelType> _save_last_<treeLevel> = _last;
@@ -96,6 +101,9 @@ adaptor.addChild(root_<enclosingTreeLevel>, root_<treeLevel>);
<endif>
_last = _save_last_<treeLevel>;
}<\n>
+<else>
+<super.tree(...)>
+<endif>
>>

// TOKEN AST STUFF
@@ -104,12 +112,17 @@ _last = _save_last_<treeLevel>;
*  setting of _last
*/
tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
+<else>
+<super.tokenRefBang(...)>
+<endif>
>>

/** ID auto construct */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
@@ -125,16 +138,24 @@ adaptor.addChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;
<endif>
+<else>
+<super.tokenRef(...)>
+<endif>
>>

/** label+=TOKEN auto construct */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<tokenRef(...)>
<listLabel(elem=label,...)>
+<else>
+<super.tokenRefAndListLabel(...)>
+<endif>
>>

/** ^(ID ...) auto construct */
tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
@@ -147,16 +168,24 @@ _last = (<ASTLabelType>)input.LT(1);
root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_<treeLevel>);
<if(backtracking)>}<endif>
<endif>
+<else>
+<super.tokenRefRuleRoot(...)>
+<endif>
>>

/** Match ^(label+=TOKEN ...) auto construct */
tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<tokenRefRuleRoot(...)>
<listLabel(elem=label,...)>
+<else>
+<super.tokenRefRuleRootAndListLabel(...)>
+<endif>
>>

/** Match . wildcard and auto dup the node/subtree */
wildcard(token,label,elementIndex,terminalOptions) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.wildcard(...)>
<if(!rewriteMode)>
@@ -168,11 +197,15 @@ adaptor.addChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;
<endif>
+<else>
+<super.wildcard(...)>
+<endif>
>>

// SET AST

matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(postmatchCode={
<if(!rewriteMode)>
@@ -187,19 +220,31 @@ adaptor.addChild(root_<treeLevel>, <label>_tree);
<endif>
}, ...
)>
+<else>
+<super.matchSet(...)>
+<endif>
>>

matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
+<if(!ruleDescriptor.isSynPred)>
<matchSet(...)>
<noRewrite(...)> <! set return tree !>
+<else>
+<super.matchRuleBlockSet(...)>
+<endif>
>>

matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(...)>
+<else>
+<super.matchSetBang(...)>
+<endif>
>>

matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<super.matchSet(postmatchCode={
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
@@ -213,12 +258,16 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_<treeLe
<endif>
}, ...
)>
+<else>
+<super.matchSetRuleRoot(...)>
+<endif>
>>

// RULE REF AST

/** rule auto construct */
ruleRef(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>
@@ -227,27 +276,42 @@ adaptor.addChild(root_<treeLevel>, <label>.getTree());
<else> <! rewrite mode !>
if ( _first_<treeLevel>==null ) _first_<treeLevel> = (<ASTLabelType>)<label>.getTree();
<endif>
+<else>
+<super.ruleRef(...)>
+<endif>
>>

/** x+=rule auto construct */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<ruleRef(...)>
<listLabel(label, {<label>.getTree()})>
+<else>
+<super.ruleRefAndListLabel(...)>
+<endif>
>>

/** ^(rule ...) auto construct */
ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>.getTree(), root_<treeLevel>);
<endif>
+<else>
+<super.ruleRefRuleRoot(...)>
+<endif>
>>

/** ^(x+=rule ...) auto construct */
ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
<ruleRefRuleRoot(...)>
<listLabel(label, {<label>.getTree()})>
+<else>
+<super.ruleRefRuleRootAndListLabel(...)>
+<endif>
>>

/** rule when output=AST and tracking for rewrite */
@@ -258,20 +322,32 @@ _last = (<ASTLabelType>)input.LT(1);

/** x+=rule when output=AST and tracking for rewrite */
ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefTrackAndListLabel(...)>
+<else>
+<super.ruleRefTrackAndListLabel(...)>
+<endif>
>>

/** ^(rule ...) rewrite */
ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefRootTrack(...)>
+<else>
+<super.ruleRefRootTrack(...)>
+<endif>
>>

/** ^(x+=rule ...) rewrite */
ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
+<if(!ruleDescriptor.isSynPred)>
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRefRuleRootTrackAndListLabel(...)>
+<else>
+<super.ruleRefRuleRootTrackAndListLabel(...)>
+<endif>
>>

/** Streams for token refs are tree nodes now; override to
@@ -287,9 +363,11 @@ stream_<token>.nextNode()

ruleCleanUp() ::= <<
<super.ruleCleanUp()>
+<if(!ruleDescriptor.isSynPred)>
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<\n><endif>
retval.tree = (<ASTLabelType>)adaptor.rulePostProcessing(root_0);
<if(backtracking)>}<endif>
<endif>
+<endif>
>>

