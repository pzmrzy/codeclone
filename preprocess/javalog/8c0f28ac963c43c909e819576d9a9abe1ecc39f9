commit 8c0f28ac963c43c909e819576d9a9abe1ecc39f9
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Wed Feb 22 10:36:58 2012 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Wed Feb 22 12:26:03 2012 -0600

Remove unnecessary explicit boxing/unboxing

diff --git a/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java b/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
index 60313c9..fc8e7d4 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
@@ -795,11 +795,11 @@ public abstract class BaseRecognizer {
state.ruleMemo[ruleIndex] = new HashMap<Integer, Integer>();
}
Integer stopIndexI =
-			state.ruleMemo[ruleIndex].get(new Integer(ruleStartIndex));
+			state.ruleMemo[ruleIndex].get(ruleStartIndex);
if ( stopIndexI==null ) {
return MEMO_RULE_UNKNOWN;
}
-		return stopIndexI.intValue();
+		return stopIndexI;
}

/** Has this rule already parsed input at the current index in the
@@ -842,9 +842,7 @@ public abstract class BaseRecognizer {
System.err.println("!!!!!!!!! memo size is "+state.ruleMemo.length+", but rule index is "+ruleIndex);
}
if ( state.ruleMemo[ruleIndex]!=null ) {
-			state.ruleMemo[ruleIndex].put(
-				new Integer(ruleStartIndex), new Integer(stopTokenIndex)
-			);
+			state.ruleMemo[ruleIndex].put(ruleStartIndex, stopTokenIndex);
}
}

diff --git a/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java b/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java
index 3ca8a1a..176f2da 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java
@@ -101,7 +101,7 @@ public class LegacyCommonTokenStream implements TokenStream {
if ( channelOverrideMap!=null ) {
Integer channelI = channelOverrideMap.get(t.getType());
if ( channelI!=null ) {
-					t.setChannel(channelI.intValue());
+					t.setChannel(channelI);
}
}
if ( discardSet!=null &&
@@ -167,14 +167,14 @@ public class LegacyCommonTokenStream implements TokenStream {
if ( channelOverrideMap==null ) {
channelOverrideMap = new HashMap<Integer, Integer>();
}
-        channelOverrideMap.put(new Integer(ttype), new Integer(channel));
+        channelOverrideMap.put(ttype, channel);
}

public void discardTokenType(int ttype) {
if ( discardSet==null ) {
discardSet = new HashSet<Integer>();
}
-        discardSet.add(new Integer(ttype));
+        discardSet.add(ttype);
}

public void discardOffChannelTokens(boolean discardOffChannelTokens) {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java b/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java
index f7e46b3..7b21446 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java
@@ -314,11 +314,11 @@ public class TokenRewriteStream extends CommonTokenStream {
if ( I==null ) {
return -1;
}
-		return I.intValue();
+		return I;
}

protected void setLastRewriteTokenIndex(String programName, int i) {
-		lastRewriteTokenIndexes.put(programName, new Integer(i));
+		lastRewriteTokenIndexes.put(programName, i);
}

protected List<RewriteOperation> getProgram(String name) {
@@ -382,8 +382,8 @@ public class TokenRewriteStream extends CommonTokenStream {
// Walk buffer, executing instructions and emitting tokens
int i = start;
while ( i <= end && i < tokens.size() ) {
-			RewriteOperation op = indexToOp.get(new Integer(i));
-			indexToOp.remove(new Integer(i)); // remove so any left have index size-1
+			RewriteOperation op = indexToOp.get(i);
+			indexToOp.remove(i); // remove so any left have index size-1
Token t = tokens.get(i);
if ( op==null ) {
// no operation at that index, just dump token
@@ -551,10 +551,10 @@ public class TokenRewriteStream extends CommonTokenStream {
for (int i = 0; i < rewrites.size(); i++) {
RewriteOperation op = rewrites.get(i);
if ( op==null ) continue; // ignore deleted ops
-			if ( m.get(new Integer(op.index))!=null ) {
+			if ( m.get(op.index)!=null ) {
throw new Error("should only be one op per index");
}
-			m.put(new Integer(op.index), op);
+			m.put(op.index, op);
}
//System.out.println("index to op: "+m);
return m;
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java b/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java
index e8fa264..28e80bc 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java
@@ -715,7 +715,7 @@ public class Profiler extends BlankDebugEventListener {
int[] x = new int[a.size()];
for (int i = 0; i < a.size(); i++) {
Integer I = a.get(i);
-			x[i] = I.intValue();
+			x[i] = I;
}
return x;
}
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java b/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java
index 1c9d311..a04fd04 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java
@@ -390,7 +390,7 @@ public class RemoteDebugEventSocketListener implements Runnable {
Boolean result = Boolean.valueOf(elements[1]);
String predicateText = elements[2];
predicateText = unEscapeNewlines(predicateText);
-			listener.semanticPredicate(result.booleanValue(),
+			listener.semanticPredicate(result,
predicateText);
}
else if ( elements[0].equals("consumeNode") ) {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/debug/Tracer.java b/runtime/Java/src/main/java/org/antlr/runtime/debug/Tracer.java
index c2c73da..f9da2a1 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/debug/Tracer.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/debug/Tracer.java
@@ -58,7 +58,7 @@ public class Tracer extends BlankDebugEventListener {
if ( input instanceof TokenStream ) {
return ((TokenStream)input).LT(k);
}
-		return new Character((char)input.LA(k));
+		return (char) input.LA(k);
}
}

diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java
index 3b9e366..9bd079d 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java
@@ -260,10 +260,10 @@ public abstract class BaseTreeAdaptor implements TreeAdaptor {
}
Integer prevID = treeToUniqueIDMap.get(node);
if ( prevID!=null ) {
-			return prevID.intValue();
+			return prevID;
}
int ID = uniqueNodeID;
-		treeToUniqueIDMap.put(node, new Integer(ID));
+		treeToUniqueIDMap.put(node, ID);
uniqueNodeID++;
return ID;
// GC makes these nonunique:
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
index 8b0e315..5188f68 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
@@ -194,10 +194,10 @@ public class DOTTreeGenerator {
protected int getNodeNumber(Object t) {
Integer nI = nodeToNumberMap.get(t);
if ( nI!=null ) {
-			return nI.intValue();
+			return nI;
}
else {
-			nodeToNumberMap.put(t, new Integer(nodeNumber));
+			nodeToNumberMap.put(t, nodeNumber);
nodeNumber++;
return nodeNumber-1;
}
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java
index d77d763..27e72f2 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java
@@ -150,7 +150,7 @@ public class TreeWizard {
}
for (int ttype = Token.MIN_TOKEN_TYPE; ttype < tokenNames.length; ttype++) {
String name = tokenNames[ttype];
-			m.put(name, new Integer(ttype));
+			m.put(name, ttype);
}
return m;
}
@@ -162,7 +162,7 @@ public class TreeWizard {
}
Integer ttypeI = tokenNameToTypeMap.get(tokenName);
if ( ttypeI!=null ) {
-			return ttypeI.intValue();
+			return ttypeI;
}
return Token.INVALID_TOKEN_TYPE;
}
@@ -186,10 +186,10 @@ public class TreeWizard {
return;
}
int ttype = adaptor.getType(t);
-		List<Object> elements = m.get(new Integer(ttype));
+		List<Object> elements = m.get(ttype);
if ( elements==null ) {
elements = new ArrayList<Object>();
-			m.put(new Integer(ttype), elements);
+			m.put(ttype, elements);
}
elements.add(t);
int n = adaptor.getChildCount(t);
diff --git a/tool/src/main/java/org/antlr/analysis/DFA.java b/tool/src/main/java/org/antlr/analysis/DFA.java
index 69c194b..df48d02 100644
--- a/tool/src/main/java/org/antlr/analysis/DFA.java
+++ b/tool/src/main/java/org/antlr/analysis/DFA.java
@@ -545,8 +545,8 @@ public class DFA {
System.out.println("createTransitionTableEntryForState s"+s.stateNumber+
" dec "+s.dfa.decisionNumber+" cyclic="+s.dfa.isCyclic());
*/
-		int smax = max.get(s.stateNumber).intValue();
-		int smin = min.get(s.stateNumber).intValue();
+		int smax = max.get(s.stateNumber);
+		int smin = min.get(s.stateNumber);

Vector<Integer> stateTransitions = new Vector<Integer>(smax-smin+1);
stateTransitions.setSize(smax-smin+1);
@@ -637,8 +637,8 @@ public class DFA {
}
}
// if has pred or too big for table, make it special
-		int smax = max.get(s.stateNumber).intValue();
-		int smin = min.get(s.stateNumber).intValue();
+		int smax = max.get(s.stateNumber);
+		int smin = min.get(s.stateNumber);
if ( hasSemPred || smax-smin>MAX_STATE_TRANSITIONS_FOR_TABLE ) {
special.set(s.stateNumber,
Utils.integer(uniqueCompressedSpecialStateNum));
diff --git a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
index c510c7d..ef36901 100644
--- a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
+++ b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
@@ -512,7 +512,7 @@ public class DecisionProbe {
lastAltAST = (GrammarAST)blockAST.getChild(lastAlt.intValue());
}
else {
-			lastAltAST = (GrammarAST)blockAST.getChild(lastAlt.intValue()-1);
+			lastAltAST = (GrammarAST)blockAST.getChild(lastAlt -1);
}
//System.out.println("last alt is "+lastAltAST.toStringTree());
// if last alt looks like ( ALT . <end-of-alt> ) then wildcard
@@ -557,7 +557,7 @@ public class DecisionProbe {
DFAState sampleBadState = altToDFAState.get(altI);
ErrorManager.recursionOverflow(this,
sampleBadState,
-										   altI.intValue(),
+										   altI,
targetRules,
callSiteStates);
}
@@ -594,7 +594,7 @@ public class DecisionProbe {
callSites.add(ruleInvocationState);
// track one problem DFA state per alt
if ( altToDFAState.get(altI)==null ) {
-					DFAState sampleBadState = dfa.getState(stateI.intValue());
+					DFAState sampleBadState = dfa.getState(stateI);
altToDFAState.put(altI, sampleBadState);
}
}
@@ -605,7 +605,7 @@ public class DecisionProbe {
Set<Integer> dfaStatesUnaliased = new HashSet<Integer>();
for (Iterator<Integer> it = dfaStatesWithRecursionProblems.iterator(); it.hasNext();) {
Integer stateI = it.next();
-			DFAState d = dfa.getState(stateI.intValue());
+			DFAState d = dfa.getState(stateI);
dfaStatesUnaliased.add(Utils.integer(d.stateNumber));
}
return dfaStatesUnaliased;
diff --git a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
index 01965c4..4490a16 100644
--- a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
+++ b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
@@ -1313,7 +1313,7 @@ public class NFAToDFAConverter {
protected static int getMinAlt(Set<Integer> nondeterministicAlts) {
int min = Integer.MAX_VALUE;
for (Integer altI : nondeterministicAlts) {
-			int alt = altI.intValue();
+			int alt = altI;
if ( alt < min ) {
min = alt;
}
@@ -1725,11 +1725,11 @@ public class NFAToDFAConverter {
i++;
Integer I = it.next();
if ( i==1 ) { // init m with first value
-				m = I.intValue();
+				m = I;
continue;
}
-			if ( I.intValue()>m ) {
-				m = I.intValue();
+			if ( I>m ) {
+				m = I;
}
}
return m;
diff --git a/tool/src/main/java/org/antlr/codegen/ACyclicDFACodeGenerator.java b/tool/src/main/java/org/antlr/codegen/ACyclicDFACodeGenerator.java
index 26f303f..93adb61 100644
--- a/tool/src/main/java/org/antlr/codegen/ACyclicDFACodeGenerator.java
+++ b/tool/src/main/java/org/antlr/codegen/ACyclicDFACodeGenerator.java
@@ -83,8 +83,7 @@ public class ACyclicDFACodeGenerator {
}
dfaST.add("k", Utils.integer(k));
dfaST.add("stateNumber", Utils.integer(s.stateNumber));
-		dfaST.add("semPredState",
-						   Boolean.valueOf(s.isResolvedWithPredicates()));
+		dfaST.add("semPredState", s.isResolvedWithPredicates());
/*
String description = dfa.getNFADecisionStartState().getDescription();
description = parentGenerator.target.getTargetStringLiteralFromString(description);
@@ -119,7 +118,7 @@ public class ACyclicDFACodeGenerator {
for (int j = 0; j < labels.size(); j++) {
Integer vI = labels.get(j);
String label =
-						parentGenerator.getTokenTypeAsTargetLabel(vI.intValue());
+						parentGenerator.getTokenTypeAsTargetLabel(vI);
targetLabels.add(label); // rewrite List element to be name
}
edgeST.add("labels", targetLabels);
diff --git a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
index c3d5f38..81e2c18 100644
--- a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
+++ b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
@@ -349,52 +349,52 @@ public class CodeGenerator {
headerFileST.add("buildAST", grammar.buildAST());
outputFileST.add("buildAST", grammar.buildAST());

-		outputFileST.add("rewriteMode", Boolean.valueOf(grammar.rewriteMode()));
-		headerFileST.add("rewriteMode", Boolean.valueOf(grammar.rewriteMode()));
+		outputFileST.add("rewriteMode", grammar.rewriteMode());
+		headerFileST.add("rewriteMode", grammar.rewriteMode());

-		outputFileST.add("backtracking", Boolean.valueOf(canBacktrack));
-		headerFileST.add("backtracking", Boolean.valueOf(canBacktrack));
+		outputFileST.add("backtracking", canBacktrack);
+		headerFileST.add("backtracking", canBacktrack);
// turn on memoize attribute at grammar level so we can create ruleMemo.
// each rule has memoize attr that hides this one, indicating whether
// it needs to save results
String memoize = (String)grammar.getOption("memoize");
outputFileST.add("memoize",
(grammar.atLeastOneRuleMemoizes ||
-						  Boolean.valueOf(memoize != null && memoize.equals("true")) &&
+						  memoize != null && memoize.equals("true") &&
canBacktrack));
headerFileST.add("memoize",
(grammar.atLeastOneRuleMemoizes ||
-						  Boolean.valueOf(memoize != null && memoize.equals("true")) &&
+						  memoize != null && memoize.equals("true") &&
canBacktrack));


-		outputFileST.add("trace", Boolean.valueOf(trace));
-		headerFileST.add("trace", Boolean.valueOf(trace));
+		outputFileST.add("trace", trace);
+		headerFileST.add("trace", trace);

-		outputFileST.add("profile", Boolean.valueOf(profile));
-		headerFileST.add("profile", Boolean.valueOf(profile));
+		outputFileST.add("profile", profile);
+		headerFileST.add("profile", profile);

// RECOGNIZER
if ( grammar.type==Grammar.LEXER ) {
recognizerST = templates.getInstanceOf("lexer");
-			outputFileST.add("LEXER", Boolean.valueOf(true));
-			headerFileST.add("LEXER", Boolean.valueOf(true));
+			outputFileST.add("LEXER", true);
+			headerFileST.add("LEXER", true);
recognizerST.add("filterMode",
-							 Boolean.valueOf(filterMode));
+							 filterMode);
}
else if ( grammar.type==Grammar.PARSER ||
grammar.type==Grammar.COMBINED )
{
recognizerST = templates.getInstanceOf("parser");
-			outputFileST.add("PARSER", Boolean.valueOf(true));
-			headerFileST.add("PARSER", Boolean.valueOf(true));
+			outputFileST.add("PARSER", true);
+			headerFileST.add("PARSER", true);
}
else {
recognizerST = templates.getInstanceOf("treeParser");
-			outputFileST.add("TREE_PARSER", Boolean.valueOf(true));
-			headerFileST.add("TREE_PARSER", Boolean.valueOf(true));
+			outputFileST.add("TREE_PARSER", true);
+			headerFileST.add("TREE_PARSER", true);
recognizerST.add("filterMode",
-							 Boolean.valueOf(filterMode));
+							 filterMode);
}
outputFileST.add("recognizer", recognizerST);
headerFileST.add("recognizer", recognizerST);
@@ -666,9 +666,9 @@ public class CodeGenerator {
public ST generateSpecialState(DFAState s) {
ST stateST;
stateST = templates.getInstanceOf("cyclicDFAState");
-		stateST.add("needErrorClause", Boolean.valueOf(true));
+		stateST.add("needErrorClause", true);
stateST.add("semPredState",
-					Boolean.valueOf(s.isResolvedWithPredicates()));
+					s.isResolvedWithPredicates());
stateST.add("stateNumber", s.stateNumber);
stateST.add("decisionNumber", s.dfa.decisionNumber);

diff --git a/tool/src/main/java/org/antlr/misc/Utils.java b/tool/src/main/java/org/antlr/misc/Utils.java
index 3207577..1e3939d 100644
--- a/tool/src/main/java/org/antlr/misc/Utils.java
+++ b/tool/src/main/java/org/antlr/misc/Utils.java
@@ -38,10 +38,10 @@ public class Utils {
*/
public static Integer integer(int x) {
if ( x<0 || x>INTEGER_POOL_MAX_VALUE ) {
-			return new Integer(x);
+			return x;
}
if ( ints[x]==null ) {
-			ints[x] = new Integer(x);
+			ints[x] = x;
}
return ints[x];
}
diff --git a/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java b/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
index 616b78a..1dfe794 100644
--- a/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
+++ b/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
@@ -250,13 +250,13 @@ protected void defineStringLiteralsFromDelegates() {
for (Iterator<String> it = s.iterator(); it.hasNext();) {
String lit = it.next();
Integer oldTypeI = stringLiterals.get(lit);
-			int oldType = oldTypeI.intValue();
+			int oldType = oldTypeI;
if ( oldType<Label.MIN_TOKEN_TYPE ) {
Integer typeI = Utils.integer(root.getNewTokenType());
stringLiterals.put(lit, typeI);
// if string referenced in combined grammar parser rule,
// automatically define in the generated lexer
-				root.defineLexerRuleForStringLiteral(lit, typeI.intValue());
+				root.defineLexerRuleForStringLiteral(lit, typeI);
}
}
}
@@ -277,7 +277,7 @@ protected void defineStringLiteralsFromDelegates() {
// an alias still means you need a lexer rule for it
Integer typeI = tokens.get(tokenID);
if ( !tokenRuleDefs.contains(tokenID) ) {
-					root.defineLexerRuleForAliasedStringLiteral(tokenID, literal, typeI.intValue());
+					root.defineLexerRuleForAliasedStringLiteral(tokenID, literal, typeI);
}
}
}
@@ -300,13 +300,13 @@ protected void defineStringLiteralsFromDelegates() {
Set<String> s = tokens.keySet();
for (Iterator<String> it = s.iterator(); it.hasNext();) {
String tokenID = it.next();
-			int ttype = tokens.get(tokenID).intValue();
+			int ttype = tokens.get(tokenID);
root.defineToken(tokenID, ttype);
}
s = stringLiterals.keySet();
for (Iterator<String> it = s.iterator(); it.hasNext();) {
String lit = it.next();
-			int ttype = stringLiterals.get(lit).intValue();
+			int ttype = stringLiterals.get(lit);
root.defineToken(lit, ttype);
}
}
diff --git a/tool/src/main/java/org/antlr/tool/DOTGenerator.java b/tool/src/main/java/org/antlr/tool/DOTGenerator.java
index 0de37a6..f623bf7 100644
--- a/tool/src/main/java/org/antlr/tool/DOTGenerator.java
+++ b/tool/src/main/java/org/antlr/tool/DOTGenerator.java
@@ -76,7 +76,7 @@ public class DOTGenerator {
dot.add("startState",
Utils.integer(startState.stateNumber));
dot.add("useBox",
-					Boolean.valueOf(Tool.internalOption_ShowNFAConfigsInDFA));
+					Tool.internalOption_ShowNFAConfigsInDFA);
walkCreatingDFADOT(dot, (DFAState)startState);
}
else {
@@ -333,7 +333,7 @@ public class DOTGenerator {
Set<NFAConfiguration> configurations = ((DFAState) s).nfaConfigurations;
for (int altIndex = 0; altIndex < altList.size(); altIndex++) {
Integer altI = altList.get(altIndex);
-						int alt = altI.intValue();
+						int alt = altI;
if ( altIndex>0 ) {
buf.append("\\n");
}
diff --git a/tool/src/main/java/org/antlr/tool/FASerializer.java b/tool/src/main/java/org/antlr/tool/FASerializer.java
index ede0df4..39b0e4a 100644
--- a/tool/src/main/java/org/antlr/tool/FASerializer.java
+++ b/tool/src/main/java/org/antlr/tool/FASerializer.java
@@ -142,7 +142,7 @@ public class FASerializer {
int normalizedStateNumber = s.stateNumber;
if ( stateNumberTranslator!=null ) {
Integer normalizedStateNumberI = stateNumberTranslator.get(s);
-			normalizedStateNumber = normalizedStateNumberI.intValue();
+			normalizedStateNumber = normalizedStateNumberI;
}

String stateStr = getStateString(normalizedStateNumber, s);
@@ -181,7 +181,7 @@ public class FASerializer {
if ( stateNumberTranslator!=null ) {
Integer normalizedTargetStateNumberI =
stateNumberTranslator.get(edge.target);
-				normalizedTargetStateNumber = normalizedTargetStateNumberI.intValue();
+				normalizedTargetStateNumber = normalizedTargetStateNumberI;
}
buf.append(getStateString(normalizedTargetStateNumber, edge.target));
buf.append("\n");
diff --git a/tool/src/main/java/org/antlr/tool/Grammar.java b/tool/src/main/java/org/antlr/tool/Grammar.java
index a8eb596..0c0444d 100644
--- a/tool/src/main/java/org/antlr/tool/Grammar.java
+++ b/tool/src/main/java/org/antlr/tool/Grammar.java
@@ -2083,7 +2083,7 @@ outer:
else { // must be a label like ID
I = composite.tokenIDToTypeMap.get(tokenName);
}
-		int i = (I!=null)?I.intValue():Label.INVALID;
+		int i = (I!=null)? I :Label.INVALID;
//System.out.println("grammar type "+type+" "+tokenName+"->"+i);
return i;
}
@@ -2463,7 +2463,7 @@ outer:
}
else if (k instanceof Integer) {
Integer kI = (Integer)k;
-			global_k = kI.intValue();
+			global_k = kI;
}
else {
// must be String "*"
@@ -2563,7 +2563,7 @@ outer:
}
if (k instanceof Integer) {
Integer kI = (Integer)k;
-			user_k = kI.intValue();
+			user_k = kI;
}
else {
// must be String "*"
diff --git a/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java b/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
index f87319f..61887d6 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
@@ -77,7 +77,7 @@ public class GrammarNonDeterminismMessage extends Message {
for (Iterator<Integer> it = disabledAlts.iterator(); it.hasNext();) {
Integer altI = it.next();
String tokenName =
-					probe.getTokenNameForTokensRuleAlt(altI.intValue());
+					probe.getTokenNameForTokensRuleAlt(altI);
// reset the line/col to the token definition (pick last one)
NFAState ruleStart =
probe.dfa.nfa.grammar.getRuleStartState(tokenName);
@@ -99,7 +99,7 @@ public class GrammarNonDeterminismMessage extends Message {
Integer displayAltI = iter.next();
if ( DecisionProbe.verbose ) {
int tracePathAlt =
-						nfaStart.translateDisplayAltToWalkAlt(displayAltI.intValue());
+						nfaStart.translateDisplayAltToWalkAlt(displayAltI);
if ( firstAlt == 0 ) {
firstAlt = tracePathAlt;
}
@@ -113,7 +113,7 @@ public class GrammarNonDeterminismMessage extends Message {
if ( probe.dfa.isTokensRuleDecision() ) {
// alts are token rules, convert to the names instead of numbers
String tokenName =
-							probe.getTokenNameForTokensRuleAlt(displayAltI.intValue());
+							probe.getTokenNameForTokensRuleAlt(displayAltI);
st.add("conflictingTokens", tokenName);
}
else {
diff --git a/tool/src/main/java/org/antlr/tool/GrammarSanity.java b/tool/src/main/java/org/antlr/tool/GrammarSanity.java
index 8af477f..a3d612a 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSanity.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSanity.java
@@ -272,7 +272,7 @@ public class GrammarSanity {
ErrorManager.grammarWarning(ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
grammar,
next.token,
-											new Integer(outerAltNum));
+											outerAltNum);
}
return;
}
@@ -296,7 +296,7 @@ public class GrammarSanity {
ErrorManager.grammarWarning(ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,
grammar,
elementAST.token,
-									new Integer(outerAltNum));
+									outerAltNum);
}

protected boolean isValidSimpleElementNode(Tree t) {
diff --git a/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java b/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
index 89ff1d1..30ed750 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
@@ -69,7 +69,7 @@ public class GrammarUnreachableAltsMessage extends Message {
for (int i = 0; i < alts.size(); i++) {
Integer altI = alts.get(i);
String tokenName =
-					probe.getTokenNameForTokensRuleAlt(altI.intValue());
+					probe.getTokenNameForTokensRuleAlt(altI);
// reset the line/col to the token definition
NFAState ruleStart =
probe.dfa.nfa.grammar.getRuleStartState(tokenName);
diff --git a/tool/src/main/java/org/antlr/tool/RandomPhrase.java b/tool/src/main/java/org/antlr/tool/RandomPhrase.java
index c6095ea..bf154f3 100644
--- a/tool/src/main/java/org/antlr/tool/RandomPhrase.java
+++ b/tool/src/main/java/org/antlr/tool/RandomPhrase.java
@@ -199,7 +199,7 @@ public class RandomPhrase {
System.out.println("token types="+tokenTypes);
for (int i = 0; i < tokenTypes.size(); i++) {
Integer ttypeI = tokenTypes.get(i);
-				int ttype = ttypeI.intValue();
+				int ttype = ttypeI;
String ttypeDisplayName = parser.getTokenDisplayName(ttype);
if ( Character.isUpperCase(ttypeDisplayName.charAt(0)) ) {
List<Integer> charsInToken = new ArrayList<Integer>(10);
diff --git a/tool/src/test/java/org/antlr/test/TestAttributes.java b/tool/src/test/java/org/antlr/test/TestAttributes.java
index cebd6b6..b34301d 100644
--- a/tool/src/test/java/org/antlr/test/TestAttributes.java
+++ b/tool/src/test/java/org/antlr/test/TestAttributes.java
@@ -3112,7 +3112,7 @@ public class TestAttributes extends BaseTest {
messageExpected.add(i, Boolean.FALSE);
}
for (int i = 0; i < equeue.errors.size(); i++) {
-			assertTrue("unexpected error:" + equeue.errors.get(i), messageExpected.get(i).booleanValue());
+			assertTrue("unexpected error:" + equeue.errors.get(i), messageExpected.get(i));
}
}
}
diff --git a/tool/src/test/java/org/antlr/test/TestIntervalSet.java b/tool/src/test/java/org/antlr/test/TestIntervalSet.java
index ee8a8c0..caf5c07 100644
--- a/tool/src/test/java/org/antlr/test/TestIntervalSet.java
+++ b/tool/src/test/java/org/antlr/test/TestIntervalSet.java
@@ -214,13 +214,13 @@ public class TestIntervalSet extends BaseTest {
@Test public void testSimpleEquals() throws Exception {
IntervalSet s = IntervalSet.of(10,20);
IntervalSet s2 = IntervalSet.of(10,20);
-        Boolean expecting = new Boolean(true);
-        Boolean result = new Boolean(s.equals(s2));
+        Boolean expecting = true;
+        Boolean result = s.equals(s2);
assertEquals(result, expecting);

IntervalSet s3 = IntervalSet.of(15,55);
-        expecting = new Boolean(false);
-        result = new Boolean(s.equals(s3));
+        expecting = false;
+        result = s.equals(s3);
assertEquals(result, expecting);
}

@@ -231,14 +231,14 @@ public class TestIntervalSet extends BaseTest {
IntervalSet s2 = IntervalSet.of(10,20);
s2.add(2);
s2.add(499,501);
-        Boolean expecting = new Boolean(true);
-        Boolean result = new Boolean(s.equals(s2));
+        Boolean expecting = true;
+        Boolean result = s.equals(s2);
assertEquals(result, expecting);

IntervalSet s3 = IntervalSet.of(10,20);
s3.add(2);
-        expecting = new Boolean(false);
-        result = new Boolean(s.equals(s3));
+        expecting = false;
+        result = s.equals(s3);
assertEquals(result, expecting);
}


