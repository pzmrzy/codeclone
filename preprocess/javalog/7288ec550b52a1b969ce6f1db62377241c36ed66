commit 7288ec550b52a1b969ce6f1db62377241c36ed66
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Mon Mar 28 15:33:44 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Mon Mar 28 15:33:44 2011 -0800

Convert all Tool grammars to ANTLR v3. The only remaining dependency on v2 is the StringTemplate 3.2's use of the v2 runtime

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 7950]

diff --git a/tool/pom.xml b/tool/pom.xml
index b46678f..a38ec60 100644
--- a/tool/pom.xml
+++ b/tool/pom.xml
@@ -73,23 +73,6 @@
</executions>

</plugin>
-
-            <plugin>
-                <groupId>org.codehaus.mojo</groupId>
-                <artifactId>antlr-maven-plugin</artifactId>
-                <version>2.2</version>
-                <configuration>
-                    <sourceDirectory>src/main/antlr2/org/antlr/grammar/v2</sourceDirectory>
-                    <grammars>antlr.g codegen.g, antlr.print.g, assign.types.g, buildnfa.g, left.recur.rules.g define.g</grammars>
-                </configuration>
-                <executions>
-                    <execution>
-                        <goals>
-                            <goal>generate</goal>
-                        </goals>
-                    </execution>
-                </executions>
-            </plugin>

<plugin>
<artifactId>maven-compiler-plugin</artifactId>
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLR.g b/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLR.g
new file mode 100644
index 0000000..6b4e60b
--- /dev/null
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLR.g
@@ -0,0 +1,1353 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2005-2011 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3:
+ Copyright (c) 2011 Sam Harwell
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Read in an ANTLR grammar and build an AST.  Try not to do
+ *  any actions, just build the tree.
+ *
+ *  The phases are:
+ *
+ *		antlr.g (this file)
+ *		assign.types.g
+ *		define.g
+ *		buildnfa.g
+ *		antlr.print.g (optional)
+ *		codegen.g
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  2005
+ */
+
+grammar ANTLR;
+
+options
+{
+	output=AST;
+	ASTLabelType=GrammarAST;
+}
+
+tokens
+{
+	//OPTIONS='options';
+	//TOKENS='tokens';
+	LEXER='lexer';
+	PARSER='parser';
+	CATCH='catch';
+	FINALLY='finally';
+	GRAMMAR='grammar';
+	PRIVATE='private';
+	PROTECTED='protected';
+	PUBLIC='public';
+	RETURNS='returns';
+	THROWS='throws';
+	TREE='tree';
+
+	RULE;
+	PREC_RULE;
+	RECURSIVE_RULE_REF; // flip recursive RULE_REF to RECURSIVE_RULE_REF in prec rules
+	BLOCK;
+	OPTIONAL;
+	CLOSURE;
+	POSITIVE_CLOSURE;
+	SYNPRED;
+	RANGE;
+	CHAR_RANGE;
+	EPSILON;
+	ALT;
+	EOR;
+	EOB;
+	EOA; // end of alt
+	ID;
+	ARG;
+	ARGLIST;
+	RET;
+	LEXER_GRAMMAR;
+	PARSER_GRAMMAR;
+	TREE_GRAMMAR;
+	COMBINED_GRAMMAR;
+	INITACTION;
+	FORCED_ACTION; // {{...}} always exec even during syn preds
+	LABEL; // $x used in rewrite rules
+	TEMPLATE;
+	SCOPE='scope';
+	IMPORT='import';
+	GATED_SEMPRED; // {p}? =>
+	SYN_SEMPRED; // (...) =>   it's a manually-specified synpred converted to sempred
+	BACKTRACK_SEMPRED; // auto backtracking mode syn pred converted to sempred
+	FRAGMENT='fragment';
+	DOT;
+	REWRITES;
+}
+
+@lexer::header {
+package org.antlr.grammar.v3;
+import org.antlr.tool.ErrorManager;
+import org.antlr.tool.Grammar;
+}
+
+@parser::header {
+package org.antlr.grammar.v3;
+import org.antlr.tool.ErrorManager;
+import org.antlr.tool.Grammar;
+import org.antlr.tool.GrammarAST;
+import org.antlr.misc.IntSet;
+import org.antlr.tool.Rule;
+}
+
+@lexer::members {
+public boolean hasASTOperator = false;
+private String fileName;
+
+public String getFileName() {
+    return fileName;
+}
+
+public void setFileName(String value) {
+    fileName = value;
+}
+}
+
+@parser::members {
+protected String currentRuleName = null;
+protected GrammarAST currentBlockAST = null;
+protected boolean atTreeRoot; // are we matching a tree root in tree grammar?
+
+public static ANTLRParser createParser(TokenStream input) {
+    ANTLRParser parser = new ANTLRParser(input);
+    parser.adaptor = new grammar_Adaptor(parser);
+    return parser;
+}
+
+private static class GrammarASTErrorNode extends GrammarAST {
+    public IntStream input;
+    public Token start;
+    public Token stop;
+    public RecognitionException trappedException;
+
+    public GrammarASTErrorNode(TokenStream input, Token start, Token stop, RecognitionException e) {
+        super(stop);
+        //Console.Out.WriteLine( "start: " + start + ", stop: " + stop );
+        if ( stop == null ||
+             ( stop.getTokenIndex() < start.getTokenIndex() &&
+              stop.getType() != Token.EOF) ) {
+            // sometimes resync does not consume a token (when LT(1) is
+            // in follow set.  So, stop will be 1 to left to start. adjust.
+            // Also handle case where start is the first token and no token
+            // is consumed during recovery; LT(-1) will return null.
+            stop = start;
+        }
+        this.input = input;
+        this.start = start;
+        this.stop = stop;
+        this.trappedException = e;
+    }
+
+    @Override
+    public boolean isNil() { return false; }
+
+    @Override
+    public String getText()
+    {
+        String badText = null;
+        if (start instanceof Token) {
+            int i = ((Token)start).getTokenIndex();
+            int j = ((Token)stop).getTokenIndex();
+            if (((Token)stop).getType() == Token.EOF) {
+                j = ((TokenStream)input).size();
+            }
+            badText = ((TokenStream)input).toString(i, j);
+        } else if (start instanceof Tree) {
+            badText = ((TreeNodeStream)input).toString(start, stop);
+        } else {
+            // people should subclass if they alter the tree type so this
+            // next one is for sure correct.
+            badText = "<unknown>";
+        }
+        return badText;
+    }
+
+    @Override
+    public void setText(String value) { }
+
+    @Override
+    public int getType() { return Token.INVALID_TOKEN_TYPE; }
+
+    @Override
+    public void setType(int value) { }
+
+    @Override
+    public String toString()
+    {
+        if (trappedException instanceof MissingTokenException)
+        {
+            return "<missing type: " +
+                   ( (MissingTokenException)trappedException ).getMissingType() +
+                   ">";
+        } else if (trappedException instanceof UnwantedTokenException) {
+            return "<extraneous: " +
+                   ( (UnwantedTokenException)trappedException ).getUnexpectedToken() +
+                   ", resync=" + getText() + ">";
+        } else if (trappedException instanceof MismatchedTokenException) {
+            return "<mismatched token: " + trappedException.token + ", resync=" + getText() + ">";
+        } else if (trappedException instanceof NoViableAltException) {
+            return "<unexpected: " + trappedException.token +
+                   ", resync=" + getText() + ">";
+        }
+        return "<error: " + getText() + ">";
+    }
+}
+
+static class grammar_Adaptor extends CommonTreeAdaptor {
+    ANTLRParser _outer;
+
+    public grammar_Adaptor(ANTLRParser outer) {
+        _outer = outer;
+    }
+
+    @Override
+    public Object create(Token payload) {
+        GrammarAST t = new GrammarAST( payload );
+        if (_outer != null)
+            t.enclosingRuleName = _outer.currentRuleName;
+        return t;
+    }
+
+    @Override
+    public Object errorNode(TokenStream input, Token start, Token stop, RecognitionException e) {
+        GrammarAST t = new GrammarASTErrorNode(input, start, stop, e);
+        if (_outer != null)
+            t.enclosingRuleName = _outer.currentRuleName;
+        return t;
+    }
+}
+
+private Grammar grammar;
+private int grammarType;
+private String fileName;
+
+public Grammar getGrammar() {
+    return grammar;
+}
+
+public void setGrammar(Grammar value) {
+    grammar = value;
+}
+
+public int getGrammarType() {
+    return grammarType;
+}
+
+public void setGrammarType(int value) {
+    grammarType = value;
+}
+
+public String getFileName() {
+    return fileName;
+}
+
+public void setFileName(String value) {
+    fileName = value;
+}
+
+private final int LA(int i) { return input.LA( i ); }
+
+private final Token LT(int k) { return input.LT( k ); }
+
+/*partial void createTreeAdaptor(ref ITreeAdaptor adaptor)
+{
+    adaptor = new grammar_Adaptor(this);
+}*/
+
+protected GrammarAST setToBlockWithSet(GrammarAST b) {
+    /*
+     * alt = ^(ALT["ALT"] {b} EOA["EOA"])
+     * prefixWithSynpred( alt )
+     * return ^(BLOCK["BLOCK"] {alt} EOB["<end-of-block>"])
+     */
+    GrammarAST alt = (GrammarAST)adaptor.create(ALT, "ALT");
+    adaptor.addChild(alt, b);
+    adaptor.addChild(alt, adaptor.create(EOA, "<end-of-alt>"));
+
+    prefixWithSynPred(alt);
+
+    GrammarAST block = (GrammarAST)adaptor.create(BLOCK, b.getToken(), "BLOCK");
+    adaptor.addChild(block, alt);
+    adaptor.addChild(alt, adaptor.create(EOB, "<end-of-block>"));
+
+    return block;
+}
+
+/** Create a copy of the alt and make it into a BLOCK; all actions,
+ *  labels, tree operators, rewrites are removed.
+ */
+protected GrammarAST createBlockFromDupAlt(GrammarAST alt) {
+    /*
+     * ^(BLOCK["BLOCK"] {GrammarAST.dupTreeNoActions(alt)} EOB["<end-of-block>"])
+     */
+    GrammarAST nalt = GrammarAST.dupTreeNoActions(alt, null);
+
+    GrammarAST block = (GrammarAST)adaptor.create(BLOCK, alt.getToken(), "BLOCK");
+    adaptor.addChild( block, nalt );
+    adaptor.addChild( block, adaptor.create( EOB, "<end-of-block>" ) );
+
+    return block;
+}
+
+/** Rewrite alt to have a synpred as first element;
+ *  (xxx)=>xxx
+ *  but only if they didn't specify one manually.
+ */
+protected void prefixWithSynPred( GrammarAST alt ) {
+    // if they want backtracking and it's not a lexer rule in combined grammar
+    String autoBacktrack = (String)grammar.getBlockOption( currentBlockAST, "backtrack" );
+    if ( autoBacktrack == null )
+    {
+        autoBacktrack = (String)grammar.getOption( "backtrack" );
+    }
+    if ( autoBacktrack != null && autoBacktrack.equals( "true" ) &&
+         !( grammarType == Grammar.COMBINED &&
+         Rule.getRuleType(currentRuleName) == Grammar.LEXER) &&
+         alt.getChild( 0 ).getType() != SYN_SEMPRED )
+    {
+        // duplicate alt and make a synpred block around that dup'd alt
+        GrammarAST synpredBlockAST = createBlockFromDupAlt( alt );
+
+        // Create a BACKTRACK_SEMPRED node as if user had typed this in
+        // Effectively we replace (xxx)=>xxx with {synpredxxx}? xxx
+        GrammarAST synpredAST = createSynSemPredFromBlock( synpredBlockAST,
+                                                          BACKTRACK_SEMPRED );
+
+        // insert BACKTRACK_SEMPRED as first element of alt
+        //synpredAST.getLastSibling().setNextSibling( alt.getFirstChild() );
+        //synpredAST.addChild( alt.getFirstChild() );
+        //alt.setFirstChild( synpredAST );
+        GrammarAST[] children = alt.getChildrenAsArray();
+        adaptor.setChild( alt, 0, synpredAST );
+        for ( int i = 0; i < children.length; i++ )
+        {
+            if ( i < children.length - 1 )
+                adaptor.setChild( alt, i + 1, children[i] );
+            else
+                adaptor.addChild( alt, children[i] );
+        }
+    }
+}
+
+protected GrammarAST createSynSemPredFromBlock( GrammarAST synpredBlockAST, int synpredTokenType ) {
+    // add grammar fragment to a list so we can make fake rules for them later.
+    String predName = grammar.defineSyntacticPredicate( synpredBlockAST, currentRuleName );
+    // convert (alpha)=> into {synpredN}? where N is some pred count
+    // during code gen we convert to function call with templates
+    String synpredinvoke = predName;
+    GrammarAST p = (GrammarAST)adaptor.create( synpredTokenType, synpredinvoke );
+    // track how many decisions have synpreds
+    grammar.blocksWithSynPreds.add( currentBlockAST );
+    return p;
+}
+
+public static GrammarAST createSimpleRuleAST( String name, GrammarAST block, boolean fragment ) {
+    TreeAdaptor adaptor = new grammar_Adaptor(null);
+
+    GrammarAST modifier = null;
+    if ( fragment )
+    {
+        modifier = (GrammarAST)adaptor.create( FRAGMENT, "fragment" );
+    }
+
+    /*
+     * EOBAST = block.getLastChild()
+     * ^(RULE[block,"rule"] ID["name"] {modifier} ARG["ARG"] RET["RET"] SCOPE["scope"] {block} EOR[EOBAST,"<end-of-rule>"])
+     */
+    GrammarAST rule = (GrammarAST)adaptor.create( RULE, block.getToken(), "rule" );
+
+    adaptor.addChild( rule, adaptor.create( ID, name ) );
+    if ( modifier != null )
+        adaptor.addChild( rule, modifier );
+    adaptor.addChild( rule, adaptor.create( ARG, "ARG" ) );
+    adaptor.addChild( rule, adaptor.create( RET, "RET" ) );
+    adaptor.addChild( rule, adaptor.create( SCOPE, "scope" ) );
+    adaptor.addChild( rule, block );
+    adaptor.addChild( rule, adaptor.create( EOR, block.getLastChild().getToken(), "<end-of-rule>" ) );
+
+    return rule;
+}
+
+@Override
+public void reportError(RecognitionException ex)
+{
+    //Token token = null;
+    //try
+    //{
+    //    token = LT( 1 );
+    //}
+    //catch ( TokenStreamException tse )
+    //{
+    //    ErrorManager.internalError( "can't get token???", tse );
+    //}
+    Token token = ex.token;
+    ErrorManager.syntaxError(
+        ErrorManager.MSG_SYNTAX_ERROR,
+        grammar,
+        token,
+        "antlr: " + ex.toString(),
+        ex );
+}
+
+public void cleanup( GrammarAST root )
+{
+    if ( grammarType == Grammar.LEXER )
+    {
+        String filter = (String)grammar.getOption( "filter" );
+        GrammarAST tokensRuleAST =
+            grammar.addArtificialMatchTokensRule(
+                root,
+                grammar.lexerRuleNamesInCombined,
+                grammar.getDelegateNames(),
+                filter != null && filter.equals( "true" ) );
+    }
+}
+}
+
+public
+grammar_![Grammar g]
+@init
+{
+	this.grammar = g;
+	Map<String, Object> opts;
+}
+@after
+{
+	cleanup( $tree );
+}
+	:	//hdr:headerSpec
+		( ACTION )?
+		( cmt=DOC_COMMENT  )?
+		gr=grammarType gid=id {grammar.setName($gid.text);} SEMI
+		(	optionsSpec {opts = $optionsSpec.opts; grammar.setOptions(opts, $optionsSpec.start);}
+		)?
+		(ig=delegateGrammars)?
+		(ts=tokensSpec)?
+		scopes=attrScopes
+		(a=actions)?
+		r=rules
+		EOF
+		-> ^($gr $gid $cmt? optionsSpec? $ig? $ts? $scopes? $a? $r)
+	;
+
+grammarType
+	:	(	'lexer'  gr='grammar' {grammarType=Grammar.LEXER; grammar.type = Grammar.LEXER;}       // pure lexer
+			-> LEXER_GRAMMAR[$gr]
+		|	'parser' gr='grammar' {grammarType=Grammar.PARSER; grammar.type = Grammar.PARSER;}     // pure parser
+			-> PARSER_GRAMMAR[$gr]
+		|	'tree'   gr='grammar' {grammarType=Grammar.TREE_PARSER; grammar.type = Grammar.TREE_PARSER;}  // a tree parser
+			-> TREE_GRAMMAR[$gr]
+		|			 gr='grammar' {grammarType=Grammar.COMBINED; grammar.type = Grammar.COMBINED;} // merged parser/lexer
+			-> COMBINED_GRAMMAR[$gr]
+		)
+	;
+
+actions
+	:	(action)+
+	;
+
+/** Match stuff like @parser::members {int i;} */
+action
+	:	AMPERSAND^ (actionScopeName COLON! COLON!)? id ACTION
+	;
+
+/** Sometimes the scope names will collide with keywords; allow them as
+ *  ids for action scopes.
+ */
+actionScopeName
+	:	id
+	|	l='lexer'
+		-> ID[$l]
+	|	p='parser'
+		-> ID[$p]
+	;
+
+optionsSpec returns [Map<String, Object> opts=new HashMap<String, Object>()]
+	:	OPTIONS^ (option[$opts] SEMI!)+ RCURLY!
+	;
+
+option[Map<String, Object> opts]
+	:	id ASSIGN^ optionValue
+		{
+			$opts.put($id.text, $optionValue.value);
+		}
+	;
+
+optionValue returns [Object value = null]
+	:	x=id			 {$value = $x.text;}
+	|	s=STRING_LITERAL {String vs = $s.text;
+						  // remove the quotes:
+						  $value=vs.substring(1,vs.length()-1);}
+	|	c=CHAR_LITERAL   {String vs = $c.text;
+						  // remove the quotes:
+						  $value=vs.substring(1,vs.length()-1);}
+	|	i=INT            {$value = Integer.parseInt($i.text);}
+	|	ss=STAR			 {$value = "*";} // used for k=*
+		-> STRING_LITERAL[$ss]
+//	|	cs:charSet       {value = #cs;} // return set AST in this case
+	;
+
+delegateGrammars
+	:	'import'^ delegateGrammar (COMMA! delegateGrammar)* SEMI!
+	;
+
+delegateGrammar
+	:	lab=id ASSIGN^ g=id {grammar.importGrammar($g.tree, $lab.text);}
+	|	g2=id               {grammar.importGrammar($g2.tree,null);}
+	;
+
+tokensSpec
+	:	TOKENS^
+			tokenSpec*
+		RCURLY!
+	;
+
+tokenSpec
+	:	TOKEN_REF ( ASSIGN^ (STRING_LITERAL|CHAR_LITERAL) )? SEMI!
+	;
+
+attrScopes
+	:	(attrScope)*
+	;
+
+attrScope
+	:	'scope'^ id ruleActions? ACTION
+	;
+
+rules
+	:	(	rule
+		)+
+	;
+
+public
+rule
+@init
+{
+	GrammarAST eob=null;
+	CommonToken start = (CommonToken)LT(1);
+	int startLine = LT(1).getLine();
+}
+	:
+	(	(	d=DOC_COMMENT
+		)?
+		(	p1='protected'	//{modifier=$p1.tree;}
+		|	p2='public'		//{modifier=$p2.tree;}
+		|	p3='private'	//{modifier=$p3.tree;}
+		|	p4='fragment'	//{modifier=$p4.tree;}
+		)?
+		ruleName=id
+		{
+			currentRuleName=$ruleName.text;
+			if ( grammarType==Grammar.LEXER && $p4==null )
+				grammar.lexerRuleNamesInCombined.add(currentRuleName);
+		}
+		( BANG )?
+		( aa=ARG_ACTION )?
+		( 'returns' rt=ARG_ACTION  )?
+		( throwsSpec )?
+		( optionsSpec )?
+		scopes=ruleScopeSpec
+		(ruleActions)?
+		COLON
+		ruleAltList[$optionsSpec.opts]
+		SEMI
+		( ex=exceptionGroup )?
+		->	^(	RULE[$ruleName.start, "rule"]
+				$ruleName
+				// the modifier will be 0 or one of the modifiers:
+				$p1? $p2? $p3? $p4?
+				^(ARG["ARG"] $aa?)
+				^(RET["RET"] $rt?)
+				throwsSpec?
+				optionsSpec?
+				$scopes
+				ruleActions?
+				ruleAltList
+				$ex?
+				EOR[$SEMI,"<end-of-rule>"])
+	)
+	{
+		$tree.setTreeEnclosingRuleNameDeeply(currentRuleName);
+		((GrammarAST)$tree.getChild(0)).setBlockOptions($optionsSpec.opts);
+	}
+	;
+
+ruleActions
+	:	(ruleAction)+
+	;
+
+/** Match stuff like @init {int i;} */
+ruleAction
+	:	AMPERSAND^ id ACTION
+	;
+
+throwsSpec
+	:	'throws'^ id ( COMMA! id )*
+	;
+
+ruleScopeSpec
+	:	( 'scope' ruleActions? ACTION )?
+		( 'scope' idList SEMI )*
+		-> ^(SCOPE[$start,"scope"] ruleActions? ACTION? idList*)
+	;
+
+ruleAltList[Map<String, Object> opts]
+@init
+{
+	GrammarAST blkRoot = null;
+	GrammarAST save = currentBlockAST;
+}
+	:	( -> BLOCK[input.LT(-1),"BLOCK"] )
+		{
+			blkRoot = (GrammarAST)$tree.getChild(0);
+			blkRoot.setBlockOptions($opts);
+			currentBlockAST = blkRoot;
+		}
+		(	a1=alternative r1=rewrite
+			{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred($a1.tree);}
+			-> $a1 $r1?
+		)
+		(	(	OR a2=alternative r2=rewrite
+				{if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR)) prefixWithSynPred($a2.tree);}
+				-> $ruleAltList $a2 $r2?
+			)+
+		|
+		)
+		-> ^({blkRoot} $ruleAltList EOB["<end-of-block>"])
+	;
+finally { currentBlockAST = save; }
+
+/** Build #(BLOCK ( #(ALT ...) EOB )+ ) */
+block
+@init
+{
+	GrammarAST save = currentBlockAST;
+}
+	:	(	lp=LPAREN
+			-> BLOCK[$lp,"BLOCK"]
+		)
+		{currentBlockAST = (GrammarAST)$tree.getChild(0);}
+		(
+			// 2nd alt and optional branch ambig due to
+			// linear approx LL(2) issue.  COLON ACTION
+			// matched correctly in 2nd alt.
+			(optionsSpec {((GrammarAST)$tree.getChild(0)).setOptions(grammar,$optionsSpec.opts);})?
+			( ruleActions )?
+			COLON
+		|	ACTION COLON
+		)?
+
+		a=alternative r=rewrite
+		{
+			stream_alternative.add( $r.tree );
+			if ( LA(1)==OR || (LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR) )
+				prefixWithSynPred($a.tree);
+		}
+		(	OR a=alternative r=rewrite
+			{
+				stream_alternative.add( $r.tree );
+				if (LA(1)==OR||(LA(2)==QUESTION||LA(2)==PLUS||LA(2)==STAR))
+					prefixWithSynPred($a.tree);
+			}
+		)*
+
+		rp=RPAREN
+		-> ^($block optionsSpec? ruleActions? ACTION? alternative+ EOB[$rp,"<end-of-block>"])
+	;
+finally { currentBlockAST = save; }
+
+// ALT and EOA have indexes tracking start/stop of entire alt
+alternative
+	:	element+
+		-> ^(ALT[$start,"ALT"] element+ EOA[input.LT(-1),"<end-of-alt>"])
+	|	// epsilon alt
+		-> ^(ALT[$start,"ALT"] EPSILON[input.LT(-1),"epsilon"] EOA[input.LT(-1),"<end-of-alt>"])
+	;
+
+exceptionGroup
+	:	exceptionHandler+ finallyClause?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:	'catch'^ ARG_ACTION ACTION
+	;
+
+finallyClause
+	:	'finally'^ ACTION
+	;
+
+element
+	:	elementNoOptionSpec
+	;
+
+elementNoOptionSpec
+@init
+{
+	IntSet elements=null;
+}
+	:	(	(	id (ASSIGN^|PLUS_ASSIGN^) (atom|block)
+			)
+			(	sub=ebnfSuffix[root_0,false]! {root_0 = $sub.tree;}
+			)?
+		|	a=atom
+			(	sub2=ebnfSuffix[$a.tree,false]! {root_0=$sub2.tree;}
+			)?
+		|	ebnf
+		|	FORCED_ACTION
+		|	ACTION
+		|	p=SEMPRED ( IMPLIES! {$p.setType(GATED_SEMPRED);} )?
+			{
+			grammar.blocksWithSemPreds.add(currentBlockAST);
+			}
+		|	t3=tree_
+		)
+	;
+
+atom
+	:	range (ROOT^|BANG^)?
+	|	(
+			// grammar.rule but ensure no spaces. "A . B" is not a qualified ref
+			// We do here rather than lexer so we can build a tree
+			({LT(1).getCharPositionInLine()+LT(1).getText().length()==LT(2).getCharPositionInLine()&&
+			 LT(2).getCharPositionInLine()+1==LT(3).getCharPositionInLine()}? id WILDCARD (terminal|ruleref)) =>
+			id w=WILDCARD^ (terminal|ruleref) {$w.setType(DOT);}
+		|	terminal
+		|	ruleref
+		)
+	|	notSet (ROOT^|BANG^)?
+	;
+
+ruleref
+	:	RULE_REF^ ARG_ACTION? (ROOT^|BANG^)?
+	;
+
+notSet
+	:	NOT^
+		(	notTerminal
+		|	block
+		)
+	;
+
+treeRoot
+@init{atTreeRoot=true;}
+@after{atTreeRoot=false;}
+	:	id (ASSIGN^|PLUS_ASSIGN^) (atom|block)
+	|	atom
+	|	block
+	;
+
+tree_
+	:	TREE_BEGIN^
+		treeRoot element+
+		RPAREN!
+	;
+
+/** matches ENBF blocks (and sets via block rule) */
+ebnf
+	:	block
+		(	QUESTION
+			-> ^(OPTIONAL[$start,"?"] block)
+		|	STAR
+			-> ^(CLOSURE[$start,"*"] block)
+		|	PLUS
+			-> ^(POSITIVE_CLOSURE[$start,"+"] block)
+		|	IMPLIES // syntactic predicate
+			// ignore for lexer rules in combined
+			-> {grammarType == Grammar.COMBINED && Rule.getRuleType(currentRuleName) == Grammar.LEXER}? ^(SYNPRED[$start,"=>"] block)
+			// create manually specified (...)=> predicate; convert to sempred
+			-> {createSynSemPredFromBlock($block.tree, SYN_SEMPRED)}
+		|	ROOT
+			-> ^(ROOT block)
+		|	BANG
+			-> ^(BANG block)
+		|
+			-> block
+		)
+	;
+
+range
+	:	c1=CHAR_LITERAL RANGE c2=CHAR_LITERAL
+		-> ^(CHAR_RANGE[$c1,".."] $c1 $c2)
+	;
+
+terminal
+	:	cl=CHAR_LITERAL^ ( elementOptions[$cl.tree]! )? (ROOT^|BANG^)?
+
+	|	tr=TOKEN_REF^
+		( elementOptions[$tr.tree]! )?
+		( ARG_ACTION )? // Args are only valid for lexer rules
+		(ROOT^|BANG^)?
+
+	|	sl=STRING_LITERAL^ ( elementOptions[$sl.tree]! )? (ROOT^|BANG^)?
+
+	|	wi=WILDCARD (ROOT^|BANG^)?
+		{
+			if ( atTreeRoot )
+			{
+				ErrorManager.syntaxError(
+					ErrorManager.MSG_WILDCARD_AS_ROOT,grammar,$wi,null,null);
+			}
+		}
+	;
+
+elementOptions[GrammarAST terminalAST]
+	:	OPEN_ELEMENT_OPTION^ defaultNodeOption[terminalAST] CLOSE_ELEMENT_OPTION!
+	|	OPEN_ELEMENT_OPTION^ elementOption[terminalAST] (SEMI! elementOption[terminalAST])* CLOSE_ELEMENT_OPTION!
+	;
+
+defaultNodeOption[GrammarAST terminalAST]
+	:	elementOptionId
+		{terminalAST.setTerminalOption(grammar,Grammar.defaultTokenOption,$elementOptionId.qid);}
+	;
+
+elementOption[GrammarAST terminalAST]
+	:	id ASSIGN^
+		(	elementOptionId
+			{terminalAST.setTerminalOption(grammar,$id.text,$elementOptionId.qid);}
+		|	(t=STRING_LITERAL|t=DOUBLE_QUOTE_STRING_LITERAL|t=DOUBLE_ANGLE_STRING_LITERAL)
+			{terminalAST.setTerminalOption(grammar,$id.text,$t.text);}
+		)
+	;
+
+elementOptionId returns [String qid]
+@init{StringBuffer buf = new StringBuffer();}
+	:	i=id {buf.append($i.text);} ('.' i=id {buf.append("." + $i.text);})*
+		{$qid = buf.toString();}
+	;
+
+ebnfSuffix[GrammarAST elemAST, boolean inRewrite]
+@init
+{
+GrammarAST blkRoot=null;
+GrammarAST alt=null;
+GrammarAST save = currentBlockAST;
+}
+@after
+{
+currentBlockAST = save;
+}
+	:	(	-> BLOCK[$elemAST.getToken(), "BLOCK"]
+		)
+		{ blkRoot = (GrammarAST)$tree.getChild(0); currentBlockAST = blkRoot; }
+		(	// create alt
+			-> ^(ALT[$elemAST.getToken(), "ALT"] {$elemAST} EOA["<end-of-alt>"])
+		)
+		{
+			alt = (GrammarAST)$tree.getChild(0);
+			if ( !inRewrite )
+				prefixWithSynPred(alt);
+		}
+		(	QUESTION
+			-> OPTIONAL[$elemAST.getToken(),"?"]
+		|	STAR
+			-> CLOSURE[$elemAST.getToken(),"*"]
+		|	PLUS
+			-> POSITIVE_CLOSURE[$elemAST.getToken(),"+"]
+		)
+		-> ^($ebnfSuffix ^({blkRoot} {alt} EOB[$elemAST.getToken(), "<end-of-block>"]))
+	;
+
+notTerminal
+	:	CHAR_LITERAL
+	|	TOKEN_REF
+	|	STRING_LITERAL
+	;
+
+idList
+	:	id (COMMA! id)*
+	;
+
+id
+	:	TOKEN_REF
+		-> ID[$TOKEN_REF]
+	|	RULE_REF
+		-> ID[$RULE_REF]
+	;
+
+// R E W R I T E  S Y N T A X
+
+rewrite
+	:	rewrite_with_sempred*
+		REWRITE rewrite_alternative
+		-> ^(REWRITES rewrite_with_sempred* ^(REWRITE rewrite_alternative))
+	|
+	;
+
+rewrite_with_sempred
+	:	REWRITE^ SEMPRED rewrite_alternative
+	;
+
+rewrite_block
+	:	LPAREN
+		rewrite_alternative
+		RPAREN
+		-> ^(BLOCK[$LPAREN,"BLOCK"] rewrite_alternative EOB[$RPAREN,"<end-of-block>"])
+	;
+
+rewrite_alternative
+options{k=1;}
+	:	{grammar.buildTemplate()}? => rewrite_template
+
+	|	{grammar.buildAST()}? => ( rewrite_element )+
+		-> {!stream_rewrite_element.hasNext()}? ^(ALT[LT(1),"ALT"] EPSILON["epsilon"] EOA["<end-of-alt>"])
+		-> ^(ALT[LT(1),"ALT"] rewrite_element+ EOA["<end-of-alt>"])
+
+	|
+		-> ^(ALT[LT(1),"ALT"] EPSILON["epsilon"] EOA["<end-of-alt>"])
+	|	{grammar.buildAST()}? ETC
+	;
+
+rewrite_element
+	:	(	t=rewrite_atom
+			-> $t
+		)
+		(	subrule=ebnfSuffix[$t.tree,true]
+			-> $subrule
+		)?
+	|	rewrite_ebnf
+	|	(	tr=rewrite_tree
+			-> $tr
+		)
+		(	subrule=ebnfSuffix[$tr.tree,true]
+			-> $subrule
+		)?
+	;
+
+rewrite_atom
+	:	tr=TOKEN_REF^ elementOptions[$tr.tree]!? ARG_ACTION? // for imaginary nodes
+	|	RULE_REF
+	|	cl=CHAR_LITERAL elementOptions[$cl.tree]!?
+	|	sl=STRING_LITERAL elementOptions[$sl.tree]!?
+	|	DOLLAR! label // reference to a label in a rewrite rule
+	|	ACTION
+	;
+
+label
+	:	TOKEN_REF -> LABEL[$TOKEN_REF]
+	|	RULE_REF -> LABEL[$RULE_REF]
+	;
+
+rewrite_ebnf
+	:	b=rewrite_block
+		(	QUESTION
+			-> ^(OPTIONAL[$b.start,"?"] $b)
+		|	STAR
+			-> ^(CLOSURE[$b.start,"*"] $b)
+		|	PLUS
+			-> ^(POSITIVE_CLOSURE[$b.start,"+"] $b)
+		)
+	;
+
+rewrite_tree
+	:	TREE_BEGIN^
+			rewrite_atom rewrite_element*
+		RPAREN!
+	;
+
+/** Build a tree for a template rewrite:
+	  ^(TEMPLATE (ID|ACTION) ^(ARGLIST ^(ARG ID ACTION) ...) )
+	where ARGLIST is always there even if no args exist.
+	ID can be "template" keyword.  If first child is ACTION then it's
+	an indirect template ref
+
+	-> foo(a={...}, b={...})
+	-> ({string-e})(a={...}, b={...})  // e evaluates to template name
+	-> {%{$ID.text}} // create literal template from string (done in ActionTranslator)
+	-> {st-expr} // st-expr evaluates to ST
+ */
+public
+rewrite_template
+options{k=1;}
+	:	// -> template(a={...},...) "..."
+		{LT(1).getText().equals("template")}? => // inline
+		(	rewrite_template_head
+			-> rewrite_template_head
+		)
+		( st=DOUBLE_QUOTE_STRING_LITERAL | st=DOUBLE_ANGLE_STRING_LITERAL )
+		{ adaptor.addChild( $tree.getChild(0), adaptor.create($st) ); }
+
+	|	// -> foo(a={...}, ...)
+		rewrite_template_head
+
+	|	// -> ({expr})(a={...}, ...)
+		rewrite_indirect_template_head
+
+	|	// -> {...}
+		ACTION
+	;
+
+/** -> foo(a={...}, ...) */
+rewrite_template_head
+	:	id lp=LPAREN
+		rewrite_template_args
+		RPAREN
+		-> ^(TEMPLATE[$lp,"TEMPLATE"] id rewrite_template_args)
+	;
+
+/** -> ({expr})(a={...}, ...) */
+rewrite_indirect_template_head
+	:	lp=LPAREN
+		ACTION
+		RPAREN
+		LPAREN rewrite_template_args RPAREN
+		-> ^(TEMPLATE[$lp,"TEMPLATE"] ACTION rewrite_template_args)
+	;
+
+rewrite_template_args
+	:	rewrite_template_arg (COMMA rewrite_template_arg)*
+		-> ^(ARGLIST["ARGLIST"] rewrite_template_arg+)
+	|
+		-> ARGLIST["ARGLIST"]
+	;
+
+rewrite_template_arg
+	:	id a=ASSIGN ACTION
+		-> ^(ARG[$a,"ARG"] id ACTION)
+	;
+
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////
+// L E X E R
+
+// get rid of warnings:
+fragment STRING_LITERAL : ;
+fragment FORCED_ACTION : ;
+fragment DOC_COMMENT : ;
+fragment SEMPRED : ;
+
+WS
+	:	(	' '
+		|	'\t'
+		|	('\r')? '\n'
+		)
+		{ $channel = HIDDEN; }
+	;
+
+COMMENT
+@init{List<Integer> type = new ArrayList<Integer>() {{ add(0); }};}
+	:	( SL_COMMENT | ML_COMMENT[type] {$type = type.get(0);} )
+		{
+			if ( $type != DOC_COMMENT )
+				$channel = HIDDEN;
+		}
+	;
+
+fragment
+SL_COMMENT
+	:	'//'
+		(	(' $ANTLR') => ' $ANTLR ' SRC (('\r')? '\n')? // src directive
+		|	~('\r'|'\n')* (('\r')? '\n')?
+		)
+	;
+
+fragment
+ML_COMMENT[List<Integer> type]
+	:	'/*'
+		{$type.set(0, (input.LA(1) == '*' && input.LA(2) != '/') ? DOC_COMMENT : ML_COMMENT);}
+		.*
+		'*/'
+	;
+
+OPEN_ELEMENT_OPTION
+	:	'<'
+	;
+
+CLOSE_ELEMENT_OPTION
+	:	'>'
+	;
+
+AMPERSAND : '@';
+
+COMMA : ',';
+
+QUESTION :	'?' ;
+
+TREE_BEGIN : '^(' ;
+
+LPAREN:	'(' ;
+
+RPAREN:	')' ;
+
+COLON :	':' ;
+
+STAR:	'*' ;
+
+PLUS:	'+' ;
+
+ASSIGN : '=' ;
+
+PLUS_ASSIGN : '+=' ;
+
+IMPLIES : '=>' ;
+
+REWRITE : '->' ;
+
+SEMI:	';' ;
+
+ROOT : '^' {hasASTOperator=true;} ;
+
+BANG : '!' {hasASTOperator=true;} ;
+
+OR	:	'|' ;
+
+WILDCARD : '.' ;
+
+ETC : '...' ;
+
+RANGE : '..' ;
+
+NOT :	'~' ;
+
+RCURLY:	'}'	;
+
+DOLLAR : '$' ;
+
+STRAY_BRACKET
+	:	']'
+		{
+			ErrorManager.syntaxError(
+				ErrorManager.MSG_SYNTAX_ERROR,
+				null,
+				state.token,
+				"antlr: dangling ']'? make sure to escape with \\]",
+				null);
+		}
+	;
+
+CHAR_LITERAL
+	:	'\''
+		(	ESC
+		|	~('\\'|'\'')
+		)*
+		'\''
+		{
+			StringBuffer s = Grammar.getUnescapedStringFromGrammarStringLiteral($text);
+			if ( s.length() > 1 )
+			{
+				$type = STRING_LITERAL;
+			}
+		}
+	;
+
+DOUBLE_QUOTE_STRING_LITERAL
+@init
+{
+	StringBuilder builder = new StringBuilder();
+}
+	:	'"'							{builder.append('"');}
+		(	('\\\"') => '\\' '"'	{builder.append('"');}
+		|	'\\' c=~'"'				{builder.append("\\" + (char)$c);}
+		|	c=~('\\'|'"')			{builder.append((char)$c);}
+		)*
+		'"'							{builder.append('"');}
+		{
+			setText(builder.toString());
+		}
+	;
+
+DOUBLE_ANGLE_STRING_LITERAL
+	:	'<<' .* '>>'
+	;
+
+fragment
+ESC
+	:	'\\'
+		(	// due to the way ESC is used, we don't need to handle the following character in different ways
+			/*'n'
+		|	'r'
+		|	't'
+		|	'b'
+		|	'f'
+		|	'"'
+		|	'\''
+		|	'\\'
+		|	'>'
+		|	'u' XDIGIT XDIGIT XDIGIT XDIGIT
+		|*/	. // unknown, leave as it is
+		)
+	;
+
+fragment
+DIGIT
+	:	'0'..'9'
+	;
+
+fragment
+XDIGIT
+	:	'0' .. '9'
+	|	'a' .. 'f'
+	|	'A' .. 'F'
+	;
+
+INT
+	:	('0'..'9')+
+	;
+
+ARG_ACTION
+@init {
+	List<String> text = new ArrayList<String>() {{ add(null); }};
+}
+	:	'['
+		NESTED_ARG_ACTION[text]
+		']'
+		{setText(text.get(0));}
+	;
+
+fragment
+NESTED_ARG_ACTION[List<String> text]
+@init {
+	$text.set(0, "");
+	StringBuilder builder = new StringBuilder();
+}
+	:	(	('\\]') => '\\' ']'		{builder.append("]");}
+		|	'\\' c=~(']')			{builder.append("\\" + (char)$c);}
+		|	ACTION_STRING_LITERAL	{builder.append($ACTION_STRING_LITERAL.text);}
+		|	ACTION_CHAR_LITERAL		{builder.append($ACTION_CHAR_LITERAL.text);}
+		|	c=~('\\'|'"'|'\''|']')	{builder.append((char)$c);}
+		)*
+		{
+			$text.set(0, builder.toString());
+		}
+	;
+
+ACTION
+@init
+{
+	int actionLine = getLine();
+	int actionColumn = getCharPositionInLine();
+}
+	:	NESTED_ACTION
+		('?' {$type = SEMPRED;})?
+		{
+			String action = $text;
+			int n = 1; // num delimiter chars
+			if ( action.startsWith("{{") && action.endsWith("}}") )
+			{
+				$type = FORCED_ACTION;
+				n = 2;
+			}
+			action = action.substring(n,action.length()-n - ($type==SEMPRED ? 1 : 0));
+			setText(action);
+		}
+	;
+
+fragment
+NESTED_ACTION
+	:	'{'
+		(	NESTED_ACTION
+		|	ACTION_CHAR_LITERAL
+		|	('//' | '/*') => COMMENT
+		|	ACTION_STRING_LITERAL
+		|	ACTION_ESC
+		|	~('{'|'\''|'"'|'\\'|'}')
+		)*
+		'}'
+	;
+
+fragment
+ACTION_CHAR_LITERAL
+	:	'\''
+		(	ACTION_ESC
+		|	~('\\'|'\'')
+		)*
+		'\''
+	;
+
+fragment
+ACTION_STRING_LITERAL
+	:	'"'
+		(	ACTION_ESC
+		|	~('\\'|'"')
+		)*
+		'"'
+	;
+
+fragment
+ACTION_ESC
+	:	'\\\''
+	|	'\\\"'
+	|	'\\' ~('\''|'"')
+	;
+
+TOKEN_REF
+	:	'A'..'Z'
+		(	'a'..'z'|'A'..'Z'|'_'|'0'..'9'
+		)*
+	;
+
+TOKENS
+	:	'tokens' WS_LOOP '{'
+	;
+
+OPTIONS
+	:	'options' WS_LOOP '{'
+	;
+
+// we get a warning here when looking for options '{', but it works right
+RULE_REF
+@init
+{
+	int t=0;
+}
+	:	'a'..'z' ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*
+	;
+
+fragment
+WS_LOOP
+	:	(	WS
+		|	COMMENT
+		)*
+	;
+
+fragment
+WS_OPT
+	:	(WS)?
+	;
+
+/** Reset the file and line information; useful when the grammar
+ *  has been generated so that errors are shown relative to the
+ *  original file like the old C preprocessor used to do.
+ */
+fragment
+SRC
+	:	'src' ' ' file=ACTION_STRING_LITERAL ' ' line=INT
+		{
+			setFileName($file.text.substring(1,$file.text.length()-1));
+			input.setLine(Integer.parseInt($line.text) - 1);  // -1 because SL_COMMENT will increment the line no. KR
+		}
+	;
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLRTreePrinter.g b/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLRTreePrinter.g
new file mode 100644
index 0000000..d809407
--- /dev/null
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLRTreePrinter.g
@@ -0,0 +1,457 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2005-2011 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3:
+ Copyright (c) 2011 Sam Harwell
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Print out a grammar (no pretty printing).
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  August 19, 2003
+ */
+tree grammar ANTLRTreePrinter;
+
+options
+{
+	tokenVocab = ANTLR;
+	ASTLabelType = GrammarAST;
+}
+
+@header {
+package org.antlr.grammar.v3;
+import org.antlr.tool.*;
+import java.util.StringTokenizer;
+}
+
+@members {
+protected Grammar grammar;
+protected boolean showActions;
+protected StringBuilder buf = new StringBuilder(300);
+
+private ANTLRTreePrinter.block_return block(GrammarAST t, boolean forceParens) throws RecognitionException {
+    ANTLRTreePrinter other = new ANTLRTreePrinter(new CommonTreeNodeStream(t));
+    other.buf = buf;
+    return other.block(forceParens);
+}
+
+public final int countAltsForBlock(GrammarAST t) {
+    int n = 0;
+    for ( int i = 0; i < t.getChildCount(); i++ )
+    {
+        if ( t.getChild(i).getType() == ALT )
+            n++;
+    }
+
+    return n;
+}
+
+public void out(String s) {
+    buf.append(s);
+}
+
+@Override
+public void reportError(RecognitionException ex) {
+    Token token = null;
+    if (ex instanceof MismatchedTokenException) {
+        token = ((MismatchedTokenException)ex).token;
+    } else if (ex instanceof NoViableAltException) {
+        token = ((NoViableAltException)ex).token;
+    }
+
+    ErrorManager.syntaxError(
+        ErrorManager.MSG_SYNTAX_ERROR,
+        grammar,
+        token,
+        "antlr.print: " + ex.toString(),
+        ex );
+}
+
+/** Normalize a grammar print out by removing all double spaces
+ *  and trailing/beginning stuff.  FOr example, convert
+ *
+ *  ( A  |  B  |  C )*
+ *
+ *  to
+ *
+ *  ( A | B | C )*
+ */
+public static String normalize(String g) {
+    StringTokenizer st = new StringTokenizer(g, " ", false);
+    StringBuffer buf = new StringBuffer();
+    while ( st.hasMoreTokens() ) {
+        String w = st.nextToken();
+        buf.append(w);
+        buf.append(" ");
+    }
+    return buf.toString().trim();
+}
+}
+
+/** Call this to figure out how to print */
+public
+toString[Grammar g, boolean showActions] returns [String s=null]
+@init {
+	grammar = g;
+	this.showActions = showActions;
+}
+	:	(	grammar_
+		|	rule
+		|	alternative
+		|	element
+		|	single_rewrite
+		|	rewrite
+		|	EOR //{s="EOR";}
+		)
+		{return normalize(buf.toString());}
+	;
+
+// --------------
+
+grammar_
+	:	^( LEXER_GRAMMAR grammarSpec["lexer " ] )
+	|	^( PARSER_GRAMMAR grammarSpec["parser "] )
+	|	^( TREE_GRAMMAR grammarSpec["tree "] )
+	|	^( COMBINED_GRAMMAR grammarSpec[""] )
+	;
+
+attrScope
+	:	^( 'scope' ID ruleAction* ACTION )
+	;
+
+grammarSpec[String gtype]
+	:	id=ID {out(gtype+"grammar "+$id.text);}
+		(cmt=DOC_COMMENT {out($cmt.text+"\n");} )?
+		(optionsSpec)? {out(";\n");}
+		(delegateGrammars)?
+		(tokensSpec)?
+		(attrScope)*
+		(actions)?
+		rules
+	;
+
+actions
+	:	( action )+
+	;
+
+action
+@init {
+	String scope=null, name=null;
+	String action=null;
+}
+	:	^(	AMPERSAND id1=ID
+			(	id2=ID a1=ACTION
+				{scope=$id1.text; name=$a1.text; action=$a1.text;}
+			|	a2=ACTION
+				{scope=null; name=$id1.text; action=$a2.text;}
+			)
+		)
+		{
+			if ( showActions )
+			{
+				out("@"+(scope!=null?scope+"::":"")+name+action);
+			}
+		}
+	;
+
+optionsSpec
+	:	^(	OPTIONS {out(" options {");}
+			(option {out("; ");})+
+			{out("} ");}
+		)
+	;
+
+option
+	:	^( ASSIGN id=ID {out($id.text+"=");} optionValue )
+	;
+
+optionValue
+	:	id=ID            {out($id.text);}
+	|	s=STRING_LITERAL {out($s.text);}
+	|	c=CHAR_LITERAL   {out($c.text);}
+	|	i=INT            {out($i.text);}
+//	|   charSet
+	;
+
+/*
+charSet
+	:   #( CHARSET charSetElement )
+	;
+
+charSetElement
+	:   c:CHAR_LITERAL {out(#c.getText());}
+	|   #( OR c1:CHAR_LITERAL c2:CHAR_LITERAL )
+	|   #( RANGE c3:CHAR_LITERAL c4:CHAR_LITERAL )
+	;
+*/
+
+delegateGrammars
+	:	^( 'import' ( ^(ASSIGN ID ID) | ID )+ )
+	;
+
+tokensSpec
+	:	^(TOKENS tokenSpec*)
+	;
+
+tokenSpec
+	:	TOKEN_REF
+	|	^( ASSIGN TOKEN_REF (STRING_LITERAL|CHAR_LITERAL) )
+	;
+
+rules
+	:	( rule | precRule )+
+	;
+
+rule
+	:	^(	RULE id=ID
+			(modifier)?
+			{out($id.text);}
+			^(ARG (arg=ARG_ACTION {out("["+$arg.text+"]");} )? )
+			^(RET (ret=ARG_ACTION {out(" returns ["+$ret.text+"]");} )? )
+			(throwsSpec)?
+			(optionsSpec)?
+			(ruleScopeSpec)?
+			(ruleAction)*
+			{out(" :");}
+			{
+				if ( input.LA(5) == NOT || input.LA(5) == ASSIGN )
+					out(" ");
+			}
+			b=block[false]
+			(exceptionGroup)?
+			EOR {out(";\n");}
+		)
+	;
+
+precRule
+	:	^(	PREC_RULE id=ID
+			(modifier)?
+			{out($id.text);}
+			^(ARG (arg=ARG_ACTION {out("["+$arg.text+"]");} )? )
+			^(RET (ret=ARG_ACTION {out(" returns ["+$ret.text+"]");} )? )
+			(throwsSpec)?
+			(optionsSpec)?
+			(ruleScopeSpec)?
+			(ruleAction)*
+			{out(" :");}
+			{
+				if ( input.LA(5) == NOT || input.LA(5) == ASSIGN )
+					out(" ");
+			}
+			b=block[false]
+			(exceptionGroup)?
+			EOR {out(";\n");}
+		)
+	;
+
+ruleAction
+	:	^(AMPERSAND id=ID a=ACTION )
+		{if ( showActions ) out("@"+$id.text+"{"+$a.text+"}");}
+	;
+
+modifier
+@init
+{out($modifier.start.getText()); out(" ");}
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec
+	:	^('throws' ID+)
+	;
+
+ruleScopeSpec
+	:	^( 'scope' ruleAction* (ACTION)? ( ID )* )
+	;
+
+block[boolean forceParens]
+@init
+{
+int numAlts = countAltsForBlock($start);
+}
+	:	^(	BLOCK
+			{
+				if ( forceParens||numAlts>1 )
+				{
+					//for ( Antlr.Runtime.Tree.Tree parent = $start.getParent(); parent != null && parent.getType() != RULE; parent = parent.getParent() )
+					//{
+					//	if ( parent.getType() == BLOCK && countAltsForBlock((GrammarAST)parent) > 1 )
+					//	{
+					//		out(" ");
+					//		break;
+					//	}
+					//}
+					out(" (");
+				}
+			}
+			(optionsSpec {out(" :");} )?
+			alternative rewrite ( {out("|");} alternative rewrite )*
+			EOB   {if ( forceParens||numAlts>1 ) out(")");}
+		 )
+	;
+
+alternative
+	:	^( ALT element* EOA )
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ (finallyClause)?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:	^('catch' ARG_ACTION ACTION)
+	;
+
+finallyClause
+	:	^('finally' ACTION)
+	;
+
+rewrite
+	:	^(REWRITES single_rewrite+)
+	|
+	;
+
+single_rewrite
+	:	^(	REWRITE {out(" ->");}
+			(	SEMPRED {out(" {"+$SEMPRED.text+"}?");}
+			)?
+			(	alternative
+			|	rewrite_template
+			|	ETC {out("...");}
+			|	ACTION {out(" {"+$ACTION.text+"}");}
+			)
+		)
+	;
+
+rewrite_template
+	:	^(	TEMPLATE
+			(	id=ID {out(" "+$id.text);}
+			|	ind=ACTION {out(" ({"+$ind.text+"})");}
+			)
+			^(	ARGLIST
+				{out("(");}
+				(	^(	ARG arg=ID {out($arg.text+"=");}
+						a=ACTION   {out($a.text);}
+					)
+				)*
+				{out(")");}
+			)
+			(	DOUBLE_QUOTE_STRING_LITERAL {out(" "+$DOUBLE_QUOTE_STRING_LITERAL.text);}
+			|	DOUBLE_ANGLE_STRING_LITERAL {out(" "+$DOUBLE_ANGLE_STRING_LITERAL.text);}
+			)?
+		)
+	;
+
+element
+	:	^(ROOT element) {out("^");}
+	|	^(BANG element) {out("!");}
+	|	atom
+	|	^(NOT {out("~");} element)
+	|	^(RANGE atom {out("..");} atom)
+	|	^(CHAR_RANGE atom {out("..");} atom)
+	|	^(ASSIGN id=ID {out($id.text+"=");} element)
+	|	^(PLUS_ASSIGN id2=ID {out($id2.text+"+=");} element)
+	|	ebnf
+	|	tree_
+	|	^( SYNPRED block[true] ) {out("=>");}
+	|	a=ACTION  {if ( showActions ) {out("{"); out($a.text); out("}");}}
+	|	a2=FORCED_ACTION  {if ( showActions ) {out("{{"); out($a2.text); out("}}");}}
+	|	pred=SEMPRED
+		{
+			if ( showActions )
+			{
+				out("{");
+				out($pred.text);
+				out("}?");
+			}
+			else
+			{
+				out("{...}?");
+			}
+		}
+	|	spred=SYN_SEMPRED
+		{
+			String name = $spred.text;
+			GrammarAST predAST=grammar.getSyntacticPredicate(name);
+			block(predAST, true);
+			out("=>");
+		}
+	|	^(BACKTRACK_SEMPRED .*) // don't print anything (auto backtrack stuff)
+	|	gpred=GATED_SEMPRED
+		{
+		if ( showActions ) {out("{"); out($gpred.text); out("}? =>");}
+		else {out("{...}? =>");}
+		}
+	|	EPSILON
+	;
+
+ebnf
+	:	block[true] {out(" ");}
+	|	^( OPTIONAL block[true] ) {out("? ");}
+	|	^( CLOSURE block[true] )  {out("* ");}
+	|	^( POSITIVE_CLOSURE block[true] ) {out("+ ");}
+	;
+
+tree_
+	:	^(TREE_BEGIN {out(" ^(");} element (element)* {out(") ");} )
+	;
+
+atom
+@init
+{out(" ");}
+	:	(	^(	RULE_REF		{out($start.toString());}
+				(rarg=ARG_ACTION	{out("["+$rarg.toString()+"]");})?
+				(ast_suffix)?
+			)
+		|	^(	TOKEN_REF		{out($start.toString());}
+				(targ=ARG_ACTION	{out("["+$targ.toString()+"]");} )?
+				(ast_suffix)?
+			)
+		|	^(	CHAR_LITERAL	{out($start.toString());}
+				(ast_suffix)?
+			)
+		|	^(	STRING_LITERAL	{out($start.toString());}
+				(ast_suffix)?
+			)
+		|	^(	WILDCARD		{out($start.toString());}
+				(ast_suffix)?
+			)
+		)
+		{out(" ");}
+	|	LABEL {out(" $"+$LABEL.text);} // used in -> rewrites
+	|	^(DOT ID {out($ID.text+".");} atom) // scope override on rule
+	;
+
+ast_suffix
+	:	ROOT {out("^");}
+	|	BANG  {out("!");}
+	;
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/ActionAnalysis.g b/tool/src/main/antlr3/org/antlr/grammar/v3/ActionAnalysis.g
index 8e55c15..ed8bb21 100644
--- a/tool/src/main/antlr3/org/antlr/grammar/v3/ActionAnalysis.g
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/ActionAnalysis.g
@@ -47,7 +47,7 @@ import org.antlr.tool.*;
@members {
Rule enclosingRule;
Grammar grammar;
-antlr.Token actionToken;
+Token actionToken;
int outerAltNum = 0;

public ActionAnalysis(Grammar grammar, String ruleName, GrammarAST actionAST)
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/ActionTranslator.g b/tool/src/main/antlr3/org/antlr/grammar/v3/ActionTranslator.g
index d739ddb..52a9a50 100644
--- a/tool/src/main/antlr3/org/antlr/grammar/v3/ActionTranslator.g
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/ActionTranslator.g
@@ -41,7 +41,7 @@ import org.antlr.codegen.*;
import org.antlr.runtime.*;
import java.util.List;
import java.util.ArrayList;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;

}

@@ -51,7 +51,7 @@ Rule enclosingRule;
int outerAltNum;
Grammar grammar;
CodeGenerator generator;
-antlr.Token actionToken;
+Token actionToken;

public ActionTranslator(CodeGenerator generator,
String ruleName,
@@ -67,7 +67,7 @@ antlr.Token actionToken;

public ActionTranslator(CodeGenerator generator,
String ruleName,
-								 antlr.Token actionToken,
+								 Token actionToken,
int outerAltNum)
{
this(new ANTLRStringStream(actionToken.getText()));
@@ -110,7 +110,7 @@ public List translateAction(String action) {
ActionTranslator translator =
new ActionTranslator(generator,
rname,
-								  new antlr.CommonToken(ANTLRParser.ACTION,action),outerAltNum);
+								  new CommonToken(ANTLRParser.ACTION,action),outerAltNum);
return translator.translateToChunks();
}

diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/AssignTokenTypesWalker.g b/tool/src/main/antlr3/org/antlr/grammar/v3/AssignTokenTypesWalker.g
new file mode 100644
index 0000000..4d35c64
--- /dev/null
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/AssignTokenTypesWalker.g
@@ -0,0 +1,402 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2005-2011 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3:
+ Copyright (c) 2011 Sam Harwell
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** [Warning: TJP says that this is probably out of date as of 11/19/2005,
+ *   but since it's probably still useful, I'll leave in.  Don't have energy
+ *   to update at the moment.]
+ *
+ *  Compute the token types for all literals and rules etc..  There are
+ *  a few different cases to consider for grammar types and a few situations
+ *  within.
+ *
+ *  CASE 1 : pure parser grammar
+ *	a) Any reference to a token gets a token type.
+ *  b) The tokens section may alias a token name to a string or char
+ *
+ *  CASE 2 : pure lexer grammar
+ *  a) Import token vocabulary if available. Set token types for any new tokens
+ *     to values above last imported token type
+ *  b) token rule definitions get token types if not already defined
+ *  c) literals do NOT get token types
+ *
+ *  CASE 3 : merged parser / lexer grammar
+ *	a) Any char or string literal gets a token type in a parser rule
+ *  b) Any reference to a token gets a token type if not referencing
+ *     a fragment lexer rule
+ *  c) The tokens section may alias a token name to a string or char
+ *     which must add a rule to the lexer
+ *  d) token rule definitions get token types if not already defined
+ *  e) token rule definitions may also alias a token name to a literal.
+ *     E.g., Rule 'FOR : "for";' will alias FOR to "for" in the sense that
+ *     references to either in the parser grammar will yield the token type
+ *
+ *  What this pass does:
+ *
+ *  0. Collects basic info about the grammar like grammar name and type;
+ *     Oh, I have go get the options in case they affect the token types.
+ *     E.g., tokenVocab option.
+ *     Imports any token vocab name/type pairs into a local hashtable.
+ *  1. Finds a list of all literals and token names.
+ *  2. Finds a list of all token name rule definitions;
+ *     no token rules implies pure parser.
+ *  3. Finds a list of all simple token rule defs of form "<NAME> : <literal>;"
+ *     and aliases them.
+ *  4. Walks token names table and assign types to any unassigned
+ *  5. Walks aliases and assign types to referenced literals
+ *  6. Walks literals, assigning types if untyped
+ *  4. Informs the Grammar object of the type definitions such as:
+ *     g.defineToken(<charliteral>, ttype);
+ *     g.defineToken(<stringliteral>, ttype);
+ *     g.defineToken(<tokenID>, ttype);
+ *     where some of the ttype values will be the same for aliases tokens.
+ */
+tree grammar AssignTokenTypesWalker;
+
+options
+{
+	tokenVocab = ANTLR;
+	ASTLabelType = GrammarAST;
+}
+
+@header {
+package org.antlr.grammar.v3;
+
+import java.util.*;
+import org.antlr.analysis.*;
+import org.antlr.misc.*;
+import org.antlr.tool.*;
+
+import org.antlr.runtime.BitSet;
+}
+
+@members {
+protected Grammar grammar;
+protected String currentRuleName;
+
+protected static GrammarAST stringAlias;
+protected static GrammarAST charAlias;
+protected static GrammarAST stringAlias2;
+protected static GrammarAST charAlias2;
+
+@Override
+public void reportError(RecognitionException ex)
+{
+    Token token = null;
+    if (ex instanceof MismatchedTokenException) {
+        token = ((MismatchedTokenException)ex).token;
+    } else if (ex instanceof NoViableAltException) {
+        token = ((NoViableAltException)ex).token;
+    }
+
+    ErrorManager.syntaxError(
+        ErrorManager.MSG_SYNTAX_ERROR,
+        grammar,
+        token,
+        "assign.types: " + ex.toString(),
+        ex);
+}
+
+protected void initASTPatterns()
+{
+    TreeAdaptor adaptor = new ANTLRParser.grammar_Adaptor(null);
+
+    /*
+     * stringAlias = ^(BLOCK[] ^(ALT[] STRING_LITERAL[] EOA[]) EOB[])
+     */
+    stringAlias = (GrammarAST)adaptor.create( BLOCK, "BLOCK" );
+    {
+        GrammarAST alt = (GrammarAST)adaptor.create( ALT, "ALT" );
+        adaptor.addChild( alt, adaptor.create( STRING_LITERAL, "STRING_LITERAL" ) );
+        adaptor.addChild( alt, adaptor.create( EOA, "EOA" ) );
+        adaptor.addChild( stringAlias, alt );
+    }
+    adaptor.addChild( stringAlias, adaptor.create( EOB, "EOB" ) );
+
+    /*
+     * charAlias = ^(BLOCK[] ^(ALT[] CHAR_LITERAL[] EOA[]) EOB[])
+     */
+    charAlias = (GrammarAST)adaptor.create( BLOCK, "BLOCK" );
+    {
+        GrammarAST alt = (GrammarAST)adaptor.create( ALT, "ALT" );
+        adaptor.addChild( alt, adaptor.create( CHAR_LITERAL, "CHAR_LITERAL" ) );
+        adaptor.addChild( alt, adaptor.create( EOA, "EOA" ) );
+        adaptor.addChild( charAlias, alt );
+    }
+    adaptor.addChild( charAlias, adaptor.create( EOB, "EOB" ) );
+
+    /*
+     * stringAlias2 = ^(BLOCK[] ^(ALT[] STRING_LITERAL[] ACTION[] EOA[]) EOB[])
+     */
+    stringAlias2 = (GrammarAST)adaptor.create( BLOCK, "BLOCK" );
+    {
+        GrammarAST alt = (GrammarAST)adaptor.create( ALT, "ALT" );
+        adaptor.addChild( alt, adaptor.create( STRING_LITERAL, "STRING_LITERAL" ) );
+        adaptor.addChild( alt, adaptor.create( ACTION, "ACTION" ) );
+        adaptor.addChild( alt, adaptor.create( EOA, "EOA" ) );
+        adaptor.addChild( stringAlias2, alt );
+    }
+    adaptor.addChild( stringAlias2, adaptor.create( EOB, "EOB" ) );
+
+    /*
+     * charAlias = ^(BLOCK[] ^(ALT[] CHAR_LITERAL[] ACTION[] EOA[]) EOB[])
+     */
+    charAlias2 = (GrammarAST)adaptor.create( BLOCK, "BLOCK" );
+    {
+        GrammarAST alt = (GrammarAST)adaptor.create( ALT, "ALT" );
+        adaptor.addChild( alt, adaptor.create( CHAR_LITERAL, "CHAR_LITERAL" ) );
+        adaptor.addChild( alt, adaptor.create( ACTION, "ACTION" ) );
+        adaptor.addChild( alt, adaptor.create( EOA, "EOA" ) );
+        adaptor.addChild( charAlias2, alt );
+    }
+    adaptor.addChild( charAlias2, adaptor.create( EOB, "EOB" ) );
+}
+
+// Behavior moved to AssignTokenTypesBehavior
+protected void trackString(GrammarAST t) {}
+protected void trackToken( GrammarAST t ) {}
+protected void trackTokenRule( GrammarAST t, GrammarAST modifier, GrammarAST block ) {}
+protected void alias( GrammarAST t, GrammarAST s ) {}
+public void defineTokens( Grammar root ) {}
+protected void defineStringLiteralsFromDelegates() {}
+protected void assignStringTypes( Grammar root ) {}
+protected void aliasTokenIDsAndLiterals( Grammar root ) {}
+protected void assignTokenIDTypes( Grammar root ) {}
+protected void defineTokenNamesAndLiteralsInGrammar( Grammar root ) {}
+protected void init( Grammar root ) {}
+}
+
+public
+grammar_[Grammar g]
+@init
+{
+	if ( state.backtracking == 0 )
+		init($g);
+}
+	:	(	^( LEXER_GRAMMAR 	  grammarSpec )
+		|	^( PARSER_GRAMMAR   grammarSpec )
+		|	^( TREE_GRAMMAR     grammarSpec )
+		|	^( COMBINED_GRAMMAR grammarSpec )
+		)
+	;
+
+grammarSpec
+	:	id=ID
+		(cmt=DOC_COMMENT)?
+		(optionsSpec)?
+		(delegateGrammars)?
+		(tokensSpec)?
+		(attrScope)*
+		( ^(AMPERSAND .*) )* // skip actions
+		rules
+	;
+
+attrScope
+	:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
+	;
+
+optionsSpec returns [Map<Object, Object> opts = new HashMap<Object, Object>()]
+	:	^( OPTIONS (option[$opts])+ )
+	;
+
+option[Map<Object, Object> opts]
+	:	^( ASSIGN ID optionValue )
+		{
+			String key = $ID.text;
+			$opts.put(key, $optionValue.value);
+			// check for grammar-level option to import vocabulary
+			if ( currentRuleName==null && key.equals("tokenVocab") )
+			{
+				grammar.importTokenVocabulary($ID,(String)$optionValue.value);
+			}
+		}
+	;
+
+optionValue returns [Object value=null]
+@init
+{
+	if ( state.backtracking == 0 )
+		$value = $start.getText();
+}
+	:	ID
+	|	STRING_LITERAL
+	|	CHAR_LITERAL
+	|	INT
+		{$value = Integer.parseInt($INT.text);}
+//  |   cs=charSet       {$value = $cs;} // return set AST in this case
+	;
+
+charSet
+	:	^( CHARSET charSetElement )
+	;
+
+charSetElement
+	:	CHAR_LITERAL
+	|	^( OR CHAR_LITERAL CHAR_LITERAL )
+	|	^( RANGE CHAR_LITERAL CHAR_LITERAL )
+	;
+
+delegateGrammars
+	:	^(	'import'
+			(	^(ASSIGN ID ID)
+			|	ID
+			)+
+		)
+	;
+
+tokensSpec
+	:	^(TOKENS tokenSpec*)
+	;
+
+tokenSpec
+	:	t=TOKEN_REF            {trackToken($t);}
+	|	^(	ASSIGN
+			t2=TOKEN_REF       {trackToken($t2);}
+			( s=STRING_LITERAL {trackString($s); alias($t2,$s);}
+			| c=CHAR_LITERAL   {trackString($c); alias($t2,$c);}
+			)
+		)
+	;
+
+rules
+	:	rule+
+	;
+
+rule
+	:	^(RULE ruleBody)
+	|	^(PREC_RULE ruleBody)
+	;
+
+ruleBody
+	:	id=ID {currentRuleName=$id.text;}
+		(m=modifier)?
+		^(ARG (ARG_ACTION)?)
+		^(RET (ARG_ACTION)?)
+		(throwsSpec)?
+		(optionsSpec)?
+		(ruleScopeSpec)?
+		( ^(AMPERSAND .*) )*
+		b=block
+		(exceptionGroup)?
+		EOR
+		{trackTokenRule($id,$m.start,$b.start);}
+	;
+
+modifier
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec
+	:	^('throws' ID+)
+	;
+
+ruleScopeSpec
+	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
+	;
+
+block
+	:	^(	BLOCK
+			(optionsSpec)?
+			( alternative rewrite )+
+			EOB
+		)
+	;
+
+alternative
+	:	^( ALT (element)+ EOA )
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ (finallyClause)?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:	^('catch' ARG_ACTION ACTION)
+	;
+
+finallyClause
+	:	^('finally' ACTION)
+	;
+
+rewrite
+	:	^(REWRITES ( ^(REWRITE .*) )* )
+	|
+	;
+
+element
+	:	^(ROOT element)
+	|	^(BANG element)
+	|	atom
+	|	^(NOT element)
+	|	^(RANGE atom atom)
+	|	^(CHAR_RANGE atom atom)
+	|	^(ASSIGN ID element)
+	|	^(PLUS_ASSIGN ID element)
+	|	ebnf
+	|	tree_
+	|	^( SYNPRED block )
+	|	FORCED_ACTION
+	|	ACTION
+	|	SEMPRED
+	|	SYN_SEMPRED
+	|	^(BACKTRACK_SEMPRED .*)
+	|	GATED_SEMPRED
+	|	EPSILON
+	;
+
+ebnf
+	:	block
+	|	^( OPTIONAL block )
+	|	^( CLOSURE block )
+	|	^( POSITIVE_CLOSURE block )
+	;
+
+tree_
+	:	^(TREE_BEGIN element+)
+	;
+
+atom
+	:	^( RULE_REF (ARG_ACTION)? )
+	|	^( t=TOKEN_REF (ARG_ACTION )? ) {trackToken($t);}
+	|	c=CHAR_LITERAL   {trackString($c);}
+	|	s=STRING_LITERAL {trackString($s);}
+	|	WILDCARD
+	|	^(DOT ID atom) // scope override on rule
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g b/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g
new file mode 100644
index 0000000..2ca9116
--- /dev/null
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g
@@ -0,0 +1,1603 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2011 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3:
+ Copyright (c) 2011 Sam Harwell
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Walk a grammar and generate code by gradually building up
+ *  a bigger and bigger StringTemplate.
+ *
+ *  Terence Parr
+ *  University of San Francisco
+ *  June 15, 2004
+ */
+tree grammar CodeGenTreeWalker;
+
+options {
+	tokenVocab = ANTLR;
+	ASTLabelType=GrammarAST;
+}
+
+@header {
+package org.antlr.grammar.v3;
+
+import org.antlr.analysis.*;
+import org.antlr.misc.*;
+import org.antlr.tool.*;
+import org.antlr.codegen.*;
+
+import java.util.HashSet;
+import java.util.Set;
+import java.util.Collection;
+import org.antlr.runtime.BitSet;
+import org.antlr.runtime.DFA;
+import org.antlr.stringtemplate.StringTemplate;
+import org.antlr.stringtemplate.StringTemplateGroup;
+}
+
+@members {
+protected static final int RULE_BLOCK_NESTING_LEVEL = 0;
+protected static final int OUTER_REWRITE_NESTING_LEVEL = 0;
+
+private String currentRuleName = null;
+protected int blockNestingLevel = 0;
+protected int rewriteBlockNestingLevel = 0;
+private int outerAltNum = 0;
+protected StringTemplate currentBlockST = null;
+protected boolean currentAltHasASTRewrite = false;
+protected int rewriteTreeNestingLevel = 0;
+protected HashSet<Object> rewriteRuleRefs = null;
+
+public String getCurrentRuleName() {
+    return currentRuleName;
+}
+
+public void setCurrentRuleName(String value) {
+    currentRuleName = value;
+}
+
+public int getOuterAltNum() {
+    return outerAltNum;
+}
+
+public void setOuterAltNum(int value) {
+    outerAltNum = value;
+}
+
+@Override
+public void reportError(RecognitionException ex) {
+    Token token = null;
+    if (ex instanceof MismatchedTokenException) {
+        token = ((MismatchedTokenException)ex).token;
+    } else if (ex instanceof NoViableAltException) {
+        token = ((NoViableAltException)ex).token;
+    }
+
+    ErrorManager.syntaxError(
+        ErrorManager.MSG_SYNTAX_ERROR,
+        grammar,
+        token,
+        "codegen: " + ex.toString(),
+        ex );
+}
+
+public final void reportError(String s) {
+    System.out.println("codegen: error: " + s);
+}
+
+protected CodeGenerator generator;
+protected Grammar grammar;
+protected StringTemplateGroup templates;
+
+/** The overall lexer/parser template; simulate dynamically scoped
+ *  attributes by making this an instance var of the walker.
+ */
+protected StringTemplate recognizerST;
+
+protected StringTemplate outputFileST;
+protected StringTemplate headerFileST;
+
+protected String outputOption = "";
+
+protected final StringTemplate getWildcardST(GrammarAST elementAST, GrammarAST ast_suffix, String label) {
+    String name = "wildcard";
+    if (grammar.type == Grammar.LEXER) {
+        name = "wildcardChar";
+    }
+    return getTokenElementST(name, name, elementAST, ast_suffix, label);
+}
+
+protected final StringTemplate getRuleElementST( String name,
+                                          String ruleTargetName,
+                                          GrammarAST elementAST,
+                                          GrammarAST ast_suffix,
+                                          String label ) {
+    String suffix = getSTSuffix( elementAST, ast_suffix, label );
+    name += suffix;
+    // if we're building trees and there is no label, gen a label
+    // unless we're in a synpred rule.
+    Rule r = grammar.getRule( currentRuleName );
+    if ( ( grammar.buildAST() || suffix.length() > 0 ) && label == null &&
+         ( r == null || !r.isSynPred ) ) {
+        // we will need a label to do the AST or tracking, make one
+        label = generator.createUniqueLabel( ruleTargetName );
+        CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
+        grammar.defineRuleRefLabel( currentRuleName, labelTok, elementAST );
+    }
+
+    StringTemplate elementST = templates.getInstanceOf( name );
+    if ( label != null ) {
+        elementST.setAttribute( "label", label );
+    }
+
+    return elementST;
+}
+
+protected final StringTemplate getTokenElementST( String name,
+                                           String elementName,
+                                           GrammarAST elementAST,
+                                           GrammarAST ast_suffix,
+                                           String label ) {
+    boolean tryUnchecked = false;
+    if (name == "matchSet" && elementAST.enclosingRuleName != null && elementAST.enclosingRuleName.length() > 0 && Rule.getRuleType(elementAST.enclosingRuleName) == Grammar.LEXER)
+    {
+        if ( ( elementAST.getParent().getType() == ANTLRLexer.ALT && elementAST.getParent().getParent().getParent().getType() == RULE && elementAST.getParent().getParent().getChildCount() == 2 )
+            || ( elementAST.getParent().getType() == ANTLRLexer.NOT && elementAST.getParent().getParent().getParent().getParent().getType() == RULE && elementAST.getParent().getParent().getParent().getChildCount() == 2 ) ) {
+            // single alt at the start of the rule needs to be checked
+        } else {
+            tryUnchecked = true;
+        }
+    }
+
+    String suffix = getSTSuffix( elementAST, ast_suffix, label );
+    // if we're building trees and there is no label, gen a label
+    // unless we're in a synpred rule.
+    Rule r = grammar.getRule( currentRuleName );
+    if ( ( grammar.buildAST() || suffix.length() > 0 ) && label == null &&
+         ( r == null || !r.isSynPred ) )
+    {
+        label = generator.createUniqueLabel( elementName );
+        CommonToken labelTok = new CommonToken( ANTLRParser.ID, label );
+        grammar.defineTokenRefLabel( currentRuleName, labelTok, elementAST );
+    }
+
+    StringTemplate elementST = null;
+    if ( tryUnchecked && templates.isDefined( name + "Unchecked" + suffix ) )
+        elementST = templates.getInstanceOf( name + "Unchecked" + suffix );
+    if ( elementST == null )
+        elementST = templates.getInstanceOf( name + suffix );
+
+    if ( label != null )
+    {
+        elementST.setAttribute( "label", label );
+    }
+    return elementST;
+}
+
+public final boolean isListLabel(String label) {
+    boolean hasListLabel = false;
+    if ( label != null ) {
+        Rule r = grammar.getRule( currentRuleName );
+        //String stName = null;
+        if ( r != null )
+        {
+            Grammar.LabelElementPair pair = r.getLabel( label );
+            if ( pair != null &&
+                 ( pair.type == Grammar.TOKEN_LIST_LABEL ||
+                  pair.type == Grammar.RULE_LIST_LABEL ||
+                  pair.type == Grammar.WILDCARD_TREE_LIST_LABEL ) )
+            {
+                hasListLabel = true;
+            }
+        }
+    }
+    return hasListLabel;
+}
+
+/** Return a non-empty template name suffix if the token is to be
+ *  tracked, added to a tree, or both.
+ */
+protected final String getSTSuffix(GrammarAST elementAST, GrammarAST ast_suffix, String label) {
+    if ( grammar.type == Grammar.LEXER )
+    {
+        return "";
+    }
+    // handle list label stuff; make element use "Track"
+
+    String operatorPart = "";
+    String rewritePart = "";
+    String listLabelPart = "";
+    Rule ruleDescr = grammar.getRule( currentRuleName );
+    if ( ast_suffix != null && !ruleDescr.isSynPred )
+    {
+        if ( ast_suffix.getType() == ANTLRParser.ROOT )
+        {
+            operatorPart = "RuleRoot";
+        }
+        else if ( ast_suffix.getType() == ANTLRParser.BANG )
+        {
+            operatorPart = "Bang";
+        }
+    }
+    if ( currentAltHasASTRewrite && elementAST.getType() != WILDCARD )
+    {
+        rewritePart = "Track";
+    }
+    if ( isListLabel( label ) )
+    {
+        listLabelPart = "AndListLabel";
+    }
+    String STsuffix = operatorPart + rewritePart + listLabelPart;
+    //JSystem.@out.println("suffix = "+STsuffix);
+
+    return STsuffix;
+}
+
+/** Convert rewrite AST lists to target labels list */
+protected final List<String> getTokenTypesAsTargetLabels(Collection<GrammarAST> refs)
+{
+    if ( refs == null || refs.size() == 0 )
+        return null;
+
+    List<String> labels = new ArrayList<String>( refs.size() );
+    for ( GrammarAST t : refs )
+    {
+        String label;
+        if ( t.getType() == ANTLRParser.RULE_REF || t.getType() == ANTLRParser.TOKEN_REF || t.getType() == ANTLRParser.LABEL)
+        {
+            label = t.getText();
+        }
+        else
+        {
+            // must be char or String literal
+            label = generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.getText()));
+        }
+        labels.add( label );
+    }
+    return labels;
+}
+
+public final void init( Grammar g ) {
+    this.grammar = g;
+    this.generator = grammar.getCodeGenerator();
+    this.templates = generator.getTemplates();
+}
+}
+
+public
+grammar_[Grammar g,
+		StringTemplate recognizerST,
+		StringTemplate outputFileST,
+		StringTemplate headerFileST]
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		init(g);
+		this.recognizerST = recognizerST;
+		this.outputFileST = outputFileST;
+		this.headerFileST = headerFileST;
+		String superClass = (String)g.getOption("superClass");
+		outputOption = (String)g.getOption("output");
+		recognizerST.setAttribute("superClass", superClass);
+		if ( g.type!=Grammar.LEXER ) {
+			recognizerST.setAttribute("ASTLabelType", g.getOption("ASTLabelType"));
+		}
+		if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
+			ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
+									   g,
+									   null,
+									   g.name);
+		}
+		if ( g.type!=Grammar.TREE_PARSER ) {
+			recognizerST.setAttribute("labelType", g.getOption("TokenLabelType"));
+		}
+		$recognizerST.setAttribute("numRules", grammar.getRules().size());
+		$outputFileST.setAttribute("numRules", grammar.getRules().size());
+		$headerFileST.setAttribute("numRules", grammar.getRules().size());
+	}
+}
+	:	(	^( LEXER_GRAMMAR grammarSpec )
+		|	^( PARSER_GRAMMAR grammarSpec )
+		|	^( TREE_GRAMMAR grammarSpec )
+		|	^( COMBINED_GRAMMAR grammarSpec )
+		)
+	;
+
+attrScope
+	:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
+	;
+
+grammarSpec
+	:   name=ID
+		(	cmt=DOC_COMMENT
+			{
+				outputFileST.setAttribute("docComment", $cmt.text);
+				headerFileST.setAttribute("docComment", $cmt.text);
+			}
+		)?
+		{
+			recognizerST.setAttribute("name", grammar.getRecognizerName());
+			outputFileST.setAttribute("name", grammar.getRecognizerName());
+			headerFileST.setAttribute("name", grammar.getRecognizerName());
+			recognizerST.setAttribute("scopes", grammar.getGlobalScopes());
+			headerFileST.setAttribute("scopes", grammar.getGlobalScopes());
+		}
+		( ^(OPTIONS .*) )?
+		( ^(IMPORT .*) )?
+		( ^(TOKENS .*) )?
+		(attrScope)*
+		( ^(AMPERSAND .*) )*
+		rules[recognizerST]
+	;
+
+rules[StringTemplate recognizerST]
+@init
+{
+	String ruleName = ((GrammarAST)input.LT(1)).getChild(0).getText();
+	boolean generated = grammar.generateMethodForRule(ruleName);
+}
+	:	(	(	options {k=1;} :
+				{generated}? =>
+				rST=rule
+				{
+					if ( $rST.code != null )
+					{
+						recognizerST.setAttribute("rules", $rST.code);
+						outputFileST.setAttribute("rules", $rST.code);
+						headerFileST.setAttribute("rules", $rST.code);
+					}
+				}
+			|	^(RULE .*)
+			|	^(PREC_RULE .*) // ignore
+			)
+			{{
+				if ( input.LA(1) == RULE )
+				{
+					ruleName = ((GrammarAST)input.LT(1)).getChild(0).getText();
+					//System.Diagnostics.Debug.Assert( ruleName == ((GrammarAST)input.LT(1)).enclosingRuleName );
+					generated = grammar.generateMethodForRule(ruleName);
+				}
+			}}
+		)+
+	;
+
+rule returns [StringTemplate code=null]
+@init
+{
+	String initAction = null;
+	// get the dfa for the BLOCK
+	GrammarAST block2=(GrammarAST)$start.getFirstChildWithType(BLOCK);
+	org.antlr.analysis.DFA dfa = block2.getLookaheadDFA();
+	// init blockNestingLevel so it's block level RULE_BLOCK_NESTING_LEVEL
+	// for alts of rule
+	blockNestingLevel = RULE_BLOCK_NESTING_LEVEL-1;
+	Rule ruleDescr = grammar.getRule($start.getChild(0).getText());
+	currentRuleName = $start.getChild(0).getText();
+
+	// For syn preds, we don't want any AST code etc... in there.
+	// Save old templates ptr and restore later.  Base templates include Dbg.
+	StringTemplateGroup saveGroup = templates;
+	if ( ruleDescr.isSynPred )
+	{
+		templates = generator.getBaseTemplates();
+	}
+
+	String description = "";
+}
+	:	^(	RULE id=ID
+			{assert currentRuleName == $id.text;}
+			(mod=modifier)?
+			^(ARG (ARG_ACTION)?)
+			^(RET (ARG_ACTION)?)
+			(throwsSpec)?
+			( ^(OPTIONS .*) )?
+			(ruleScopeSpec)?
+			( ^(AMPERSAND .*) )*
+			b=block["ruleBlock", dfa]
+			{
+				description =
+					grammar.grammarTreeToString((GrammarAST)$start.getFirstChildWithType(BLOCK),
+												false);
+				description =
+					generator.target.getTargetStringLiteralFromString(description);
+				$b.code.setAttribute("description", description);
+				// do not generate lexer rules in combined grammar
+				String stName = null;
+				if ( ruleDescr.isSynPred )
+				{
+					stName = "synpredRule";
+				}
+				else if ( grammar.type==Grammar.LEXER )
+				{
+					if ( currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) )
+					{
+						stName = "tokensRule";
+					}
+					else
+					{
+						stName = "lexerRule";
+					}
+				}
+				else
+				{
+					if ( !(grammar.type==Grammar.COMBINED &&
+						 Rule.getRuleType(currentRuleName) == Grammar.LEXER) )
+					{
+						stName = "rule";
+					}
+				}
+				$code = templates.getInstanceOf(stName);
+				if ( $code.getName().equals("rule") )
+				{
+					$code.setAttribute("emptyRule", grammar.isEmptyRule(block2));
+				}
+				$code.setAttribute("ruleDescriptor", ruleDescr);
+				String memo = (String)grammar.getBlockOption($start,"memoize");
+				if ( memo==null )
+				{
+					memo = (String)grammar.getOption("memoize");
+				}
+				if ( memo!=null && memo.equals("true") &&
+					 (stName.equals("rule")||stName.equals("lexerRule")) )
+				{
+					$code.setAttribute("memoize", memo!=null && memo.equals("true"));
+				}
+			}
+
+			(exceptionGroup[$code])?
+			EOR
+		)
+		{
+			if ( $code!=null )
+			{
+				if ( grammar.type==Grammar.LEXER )
+				{
+					boolean naked =
+						currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
+						($mod.start!=null&&$mod.start.getText().equals(Grammar.FRAGMENT_RULE_MODIFIER));
+					$code.setAttribute("nakedBlock", naked);
+				}
+				else
+				{
+					description = grammar.grammarTreeToString($start,false);
+					description = generator.target.getTargetStringLiteralFromString(description);
+					$code.setAttribute("description", description);
+				}
+				Rule theRule = grammar.getRule(currentRuleName);
+				generator.translateActionAttributeReferencesForSingleScope(
+					theRule,
+					theRule.getActions()
+				);
+				$code.setAttribute("ruleName", currentRuleName);
+				$code.setAttribute("block", $b.code);
+				if ( initAction!=null )
+				{
+					$code.setAttribute("initAction", initAction);
+				}
+			}
+		}
+	;
+finally { templates = saveGroup; }
+
+modifier
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec
+	:	^('throws' ID+)
+	;
+
+ruleScopeSpec
+	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
+	;
+
+block[String blockTemplateName, org.antlr.analysis.DFA dfa]
+	 returns [StringTemplate code=null]
+options { k=1; }
+@init
+{
+	int altNum = 0;
+
+	blockNestingLevel++;
+	if ( state.backtracking == 0 )
+	{
+		StringTemplate decision = null;
+		if ( $dfa != null )
+		{
+			$code = templates.getInstanceOf($blockTemplateName);
+			decision = generator.genLookaheadDecision(recognizerST,$dfa);
+			$code.setAttribute("decision", decision);
+			$code.setAttribute("decisionNumber", $dfa.getDecisionNumber());
+			$code.setAttribute("maxK",$dfa.getMaxLookaheadDepth());
+			$code.setAttribute("maxAlt",$dfa.getNumberOfAlts());
+		}
+		else
+		{
+			$code = templates.getInstanceOf($blockTemplateName+"SingleAlt");
+		}
+		$code.setAttribute("blockLevel", blockNestingLevel);
+		$code.setAttribute("enclosingBlockLevel", blockNestingLevel-1);
+		altNum = 1;
+		if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
+			this.outerAltNum=1;
+		}
+	}
+}
+	:	{$start.getSetValue()!=null}? => setBlock
+		{
+			$code.setAttribute("alts",$setBlock.code);
+		}
+
+	|	^(  BLOCK
+			( ^(OPTIONS .*) )? // ignore
+			( alt=alternative rew=rewrite
+				{
+					if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
+					{
+						this.outerAltNum++;
+					}
+					// add the rewrite code as just another element in the alt :)
+					// (unless it's a " -> ..." rewrite
+					// ( -> ... )
+					GrammarAST firstRewriteAST = (GrammarAST)$rew.start.findFirstType(REWRITE);
+					boolean etc =
+						$rew.start.getType()==REWRITES &&
+						firstRewriteAST.getChild(0)!=null &&
+						firstRewriteAST.getChild(0).getType()==ETC;
+					if ( $rew.code!=null && !etc )
+					{
+						$alt.code.setAttribute("rew", $rew.code);
+					}
+					// add this alt to the list of alts for this block
+					$code.setAttribute("alts",$alt.code);
+					$alt.code.setAttribute("altNum", altNum);
+					$alt.code.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+					altNum++;
+				}
+			)+
+			EOB
+		 )
+	;
+finally { blockNestingLevel--; }
+
+setBlock returns [StringTemplate code=null]
+@init
+{
+	StringTemplate setcode = null;
+	if ( state.backtracking == 0 )
+	{
+		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.buildAST() )
+		{
+			Rule r = grammar.getRule(currentRuleName);
+			currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+			if ( currentAltHasASTRewrite )
+			{
+				r.trackTokenReferenceInAlt($start, outerAltNum);
+			}
+		}
+	}
+}
+	:	^(s=BLOCK .*)
+		{
+			int i = ((CommonToken)$s.getToken()).getTokenIndex();
+			if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL )
+			{
+				setcode = getTokenElementST("matchRuleBlockSet", "set", $s, null, null);
+			}
+			else
+			{
+				setcode = getTokenElementST("matchSet", "set", $s, null, null);
+			}
+			setcode.setAttribute("elementIndex", i);
+			//if ( grammar.type!=Grammar.LEXER )
+			//{
+			//	generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
+			//}
+			setcode.setAttribute("s",
+				generator.genSetExpr(templates,$s.getSetValue(),1,false));
+			StringTemplate altcode=templates.getInstanceOf("alt");
+			altcode.setAttribute("elements.{el,line,pos}",
+								 setcode,
+								 $s.getLine(),
+								 $s.getCharPositionInLine() + 1
+								);
+			altcode.setAttribute("altNum", 1);
+			altcode.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+			if ( !currentAltHasASTRewrite && grammar.buildAST() )
+			{
+				altcode.setAttribute("autoAST", true);
+			}
+			altcode.setAttribute("treeLevel", rewriteTreeNestingLevel);
+			$code = altcode;
+		}
+	;
+
+setAlternative
+	:	^(ALT setElement+ EOA)
+	;
+
+exceptionGroup[StringTemplate ruleST]
+	:	( exceptionHandler[$ruleST] )+ (finallyClause[$ruleST])?
+	|	finallyClause[$ruleST]
+	;
+
+exceptionHandler[StringTemplate ruleST]
+	:	^('catch' ARG_ACTION ACTION)
+		{
+			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			$ruleST.setAttribute("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
+		}
+	;
+
+finallyClause[StringTemplate ruleST]
+	:	^('finally' ACTION)
+		{
+			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			$ruleST.setAttribute("finally",chunks);
+		}
+	;
+
+alternative returns [StringTemplate code]
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		$code = templates.getInstanceOf("alt");
+		if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.buildAST() )
+		{
+			Rule r = grammar.getRule(currentRuleName);
+			currentAltHasASTRewrite = r.hasRewrite(outerAltNum);
+		}
+		String description = grammar.grammarTreeToString($start, false);
+		description = generator.target.getTargetStringLiteralFromString(description);
+		$code.setAttribute("description", description);
+		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+		if ( !currentAltHasASTRewrite && grammar.buildAST() )
+		{
+			$code.setAttribute("autoAST", true);
+		}
+	}
+}
+	:	^(	a=ALT
+			(
+				e=element[null,null]
+				{
+					if (e != null && e.code != null)
+					{
+						$code.setAttribute("elements.{el,line,pos}",
+										  $e.code,
+										  $e.start.getLine(),
+										  $e.start.getCharPositionInLine() + 1
+										 );
+					}
+				}
+			)+
+			EOA
+		)
+	;
+
+element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+options { k=1; }
+@init
+{
+	IntSet elements=null;
+	GrammarAST ast = null;
+}
+	:	^(ROOT e=element[label,$ROOT])
+		{ $code = $e.code; }
+
+	|	^(BANG e=element[label,$BANG])
+		{ $code = $e.code; }
+
+	|	^( n=NOT notElement[$n, $label, $astSuffix] )
+		{ $code = $notElement.code; }
+
+	|	^( ASSIGN alabel=ID e=element[$alabel,$astSuffix] )
+		{ $code = $e.code; }
+
+	|	^( PLUS_ASSIGN label2=ID e=element[$label2,$astSuffix] )
+		{ $code = $e.code; }
+
+	|	^(CHAR_RANGE a=CHAR_LITERAL b=CHAR_LITERAL)
+		{
+			$code = templates.getInstanceOf("charRangeRef");
+			String low = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
+			String high = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
+			$code.setAttribute("a", low);
+			$code.setAttribute("b", high);
+			if ( label!=null )
+			{
+				$code.setAttribute("label", $label.getText());
+			}
+		}
+
+	|	({((GrammarAST)input.LT(1)).getSetValue()==null}? (BLOCK|OPTIONAL|CLOSURE|POSITIVE_CLOSURE)) => /*{$start.getSetValue()==null}?*/ ebnf
+		{ $code = $ebnf.code; }
+
+	|	atom[null, $label, $astSuffix]
+		{ $code = $atom.code; }
+
+	|	tree_
+		{ $code = $tree_.code; }
+
+	|	element_action
+		{ $code = $element_action.code; }
+
+	|   (sp=SEMPRED|sp=GATED_SEMPRED)
+		{
+			$code = templates.getInstanceOf("validateSemanticPredicate");
+			$code.setAttribute("pred", generator.translateAction(currentRuleName,$sp));
+			String description = generator.target.getTargetStringLiteralFromString($sp.text);
+			$code.setAttribute("description", description);
+		}
+
+	|	SYN_SEMPRED // used only in lookahead; don't generate validating pred
+
+	|	^(SYNPRED .*)
+
+	|	^(BACKTRACK_SEMPRED .*)
+
+	|   EPSILON
+	;
+
+element_action returns [StringTemplate code=null]
+	:	act=ACTION
+		{
+			$code = templates.getInstanceOf("execAction");
+			$code.setAttribute("action", generator.translateAction(currentRuleName,$act));
+		}
+	|	act2=FORCED_ACTION
+		{
+			$code = templates.getInstanceOf("execForcedAction");
+			$code.setAttribute("action", generator.translateAction(currentRuleName,$act2));
+		}
+	;
+
+notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+@init
+{
+	IntSet elements=null;
+	String labelText = null;
+	if ( label!=null )
+	{
+		labelText = label.getText();
+	}
+}
+	:	(	assign_c=CHAR_LITERAL
+			{
+				int ttype=0;
+				if ( grammar.type==Grammar.LEXER )
+				{
+					ttype = Grammar.getCharValueFromGrammarCharLiteral($assign_c.text);
+				}
+				else
+				{
+					ttype = grammar.getTokenType($assign_c.text);
+				}
+				elements = grammar.complement(ttype);
+			}
+		|	assign_s=STRING_LITERAL
+			{
+				int ttype=0;
+				if ( grammar.type==Grammar.LEXER )
+				{
+					// TODO: error!
+				}
+				else
+				{
+					ttype = grammar.getTokenType($assign_s.text);
+				}
+				elements = grammar.complement(ttype);
+			}
+		|	assign_t=TOKEN_REF
+			{
+				int ttype = grammar.getTokenType($assign_t.text);
+				elements = grammar.complement(ttype);
+			}
+		|	^(assign_st=BLOCK .*)
+			{
+				elements = $assign_st.getSetValue();
+				elements = grammar.complement(elements);
+			}
+		)
+		{
+			$code = getTokenElementST("matchSet",
+									 "set",
+									 (GrammarAST)$n.getChild(0),
+									 astSuffix,
+									 labelText);
+			$code.setAttribute("s",generator.genSetExpr(templates,elements,1,false));
+			int i = ((CommonToken)n.getToken()).getTokenIndex();
+			$code.setAttribute("elementIndex", i);
+			if ( grammar.type!=Grammar.LEXER )
+			{
+				generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
+			}
+		}
+	;
+
+ebnf returns [StringTemplate code=null]
+@init
+{
+	org.antlr.analysis.DFA dfa=null;
+	GrammarAST b = (GrammarAST)$start.getChild(0);
+	GrammarAST eob = (GrammarAST)b.getLastChild(); // loops will use EOB DFA
+}
+	:	(	{ dfa = $start.getLookaheadDFA(); }
+			blk=block["block", dfa]
+			{ $code = $blk.code; }
+		|	{ dfa = $start.getLookaheadDFA(); }
+			^( OPTIONAL blk=block["optionalBlock", dfa] )
+			{ $code = $blk.code; }
+		|	{ dfa = eob.getLookaheadDFA(); }
+			^( CLOSURE blk=block["closureBlock", dfa] )
+			{ $code = $blk.code; }
+		|	{ dfa = eob.getLookaheadDFA(); }
+			^( POSITIVE_CLOSURE blk=block["positiveClosureBlock", dfa] )
+			{ $code = $blk.code; }
+		)
+		{
+			String description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	;
+
+tree_ returns [StringTemplate code]
+@init
+{
+	rewriteTreeNestingLevel++;
+	GrammarAST rootSuffix = null;
+	if ( state.backtracking == 0 )
+	{
+		$code = templates.getInstanceOf("tree");
+		NFAState afterDOWN = (NFAState)$start.NFATreeDownState.transition(0).target;
+		LookaheadSet s = grammar.LOOK(afterDOWN);
+		if ( s.member(Label.UP) ) {
+			// nullable child list if we can see the UP as the next token
+			// we need an "if ( input.LA(1)==Token.DOWN )" gate around
+			// the child list.
+			$code.setAttribute("nullableChildList", "true");
+		}
+		$code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+		Rule r = grammar.getRule(currentRuleName);
+		if ( grammar.buildAST() && !r.hasRewrite(outerAltNum) ) {
+			rootSuffix = new GrammarAST(ROOT,"ROOT");
+		}
+	}
+}
+	:	^(	TREE_BEGIN
+			el=element[null,rootSuffix]
+			{
+				$code.setAttribute("root.{el,line,pos}",
+								  $el.code,
+								  $el.start.getLine(),
+								  $el.start.getCharPositionInLine() + 1
+								  );
+			}
+			// push all the immediately-following actions out before children
+			// so actions aren't guarded by the "if (input.LA(1)==Token.DOWN)"
+			// guard in generated code.
+			(	(element_action) =>
+				act=element_action
+				{
+					$code.setAttribute("actionsAfterRoot.{el,line,pos}",
+									  $act.code,
+									  $act.start.getLine(),
+									  $act.start.getCharPositionInLine() + 1
+									);
+				}
+			)*
+			(	 el=element[null,null]
+				 {
+				 $code.setAttribute("children.{el,line,pos}",
+								  $el.code,
+								  $el.start.getLine(),
+								  $el.start.getCharPositionInLine() + 1
+								  );
+				 }
+			)*
+		)
+	;
+finally { rewriteTreeNestingLevel--; }
+
+atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
+	returns [StringTemplate code=null]
+@init
+{
+	String labelText=null;
+	if ( state.backtracking == 0 )
+	{
+		if ( label!=null )
+		{
+			labelText = label.getText();
+		}
+		if ( grammar.type!=Grammar.LEXER &&
+			 ($start.getType()==RULE_REF||$start.getType()==TOKEN_REF||
+			  $start.getType()==CHAR_LITERAL||$start.getType()==STRING_LITERAL) )
+		{
+			Rule encRule = grammar.getRule(((GrammarAST)$start).enclosingRuleName);
+			if ( encRule!=null && encRule.hasRewrite(outerAltNum) && astSuffix!=null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_AST_OP_IN_ALT_WITH_REWRITE,
+										  grammar,
+										  ((GrammarAST)$start).getToken(),
+										  ((GrammarAST)$start).enclosingRuleName,
+										  outerAltNum);
+				astSuffix = null;
+			}
+		}
+	}
+}
+	:   ^( r=RULE_REF (rarg=ARG_ACTION)? )
+		{
+			grammar.checkRuleReference(scope, $r, $rarg, currentRuleName);
+			String scopeName = null;
+			if ( scope!=null ) {
+				scopeName = scope.getText();
+			}
+			Rule rdef = grammar.getRule(scopeName, $r.text);
+			// don't insert label=r() if $label.attr not used, no ret value, ...
+			if ( !rdef.getHasReturnValue() ) {
+				labelText = null;
+			}
+			$code = getRuleElementST("ruleRef", $r.text, $r, astSuffix, labelText);
+			$code.setAttribute("rule", rdef);
+			if ( scope!=null ) { // scoped rule ref
+				Grammar scopeG = grammar.composite.getGrammar(scope.getText());
+				$code.setAttribute("scope", scopeG);
+			}
+			else if ( rdef.grammar != this.grammar ) { // nonlocal
+				// if rule definition is not in this grammar, it's nonlocal
+				List<Grammar> rdefDelegates = rdef.grammar.getDelegates();
+				if ( rdefDelegates.contains(this.grammar) ) {
+					$code.setAttribute("scope", rdef.grammar);
+				}
+				else {
+					// defining grammar is not a delegate, scope all the
+					// back to root, which has delegate methods for all
+					// rules.  Don't use scope if we are root.
+					if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
+						$code.setAttribute("scope",
+										  rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
+					}
+				}
+			}
+
+			if ( $rarg!=null ) {
+				List args = generator.translateAction(currentRuleName,$rarg);
+				$code.setAttribute("args", args);
+			}
+			int i = ((CommonToken)r.getToken()).getTokenIndex();
+			$code.setAttribute("elementIndex", i);
+			generator.generateLocalFOLLOW($r,$r.text,currentRuleName,i);
+			$r.code = $code;
+		}
+
+	|	^( t=TOKEN_REF (targ=ARG_ACTION)? )
+		{
+			if ( currentAltHasASTRewrite && $t.terminalOptions!=null &&
+				$t.terminalOptions.get(Grammar.defaultTokenOption)!=null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_HETERO_ILLEGAL_IN_REWRITE_ALT,
+										grammar,
+										((GrammarAST)($t)).getToken(),
+										$t.text);
+			}
+			grammar.checkRuleReference(scope, $t, $targ, currentRuleName);
+			if ( grammar.type==Grammar.LEXER )
+			{
+				if ( grammar.getTokenType($t.text)==Label.EOF )
+				{
+					$code = templates.getInstanceOf("lexerMatchEOF");
+				}
+				else
+				{
+					$code = templates.getInstanceOf("lexerRuleRef");
+					if ( isListLabel(labelText) )
+					{
+						$code = templates.getInstanceOf("lexerRuleRefAndListLabel");
+					}
+					String scopeName = null;
+					if ( scope!=null )
+					{
+						scopeName = scope.getText();
+					}
+					Rule rdef2 = grammar.getRule(scopeName, $t.text);
+					$code.setAttribute("rule", rdef2);
+					if ( scope!=null )
+					{ // scoped rule ref
+						Grammar scopeG = grammar.composite.getGrammar(scope.getText());
+						$code.setAttribute("scope", scopeG);
+					}
+					else if ( rdef2.grammar != this.grammar )
+					{ // nonlocal
+						// if rule definition is not in this grammar, it's nonlocal
+						$code.setAttribute("scope", rdef2.grammar);
+					}
+					if ( $targ!=null )
+					{
+						List args = generator.translateAction(currentRuleName,$targ);
+						$code.setAttribute("args", args);
+					}
+				}
+				int i = ((CommonToken)$t.getToken()).getTokenIndex();
+				$code.setAttribute("elementIndex", i);
+				if ( label!=null )
+					$code.setAttribute("label", labelText);
+			}
+			else
+			{
+				$code = getTokenElementST("tokenRef", $t.text, $t, astSuffix, labelText);
+				String tokenLabel =
+					generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.getText()));
+				$code.setAttribute("token",tokenLabel);
+				if ( !currentAltHasASTRewrite && $t.terminalOptions!=null )
+				{
+					$code.setAttribute("terminalOptions", $t.terminalOptions);
+				}
+				int i = ((CommonToken)$t.getToken()).getTokenIndex();
+				$code.setAttribute("elementIndex", i);
+				generator.generateLocalFOLLOW($t,tokenLabel,currentRuleName,i);
+			}
+			$t.code = $code;
+		}
+
+	|	c=CHAR_LITERAL
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				$code = templates.getInstanceOf("charRef");
+				$code.setAttribute("char",
+				   generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
+				if ( label!=null )
+				{
+					$code.setAttribute("label", labelText);
+				}
+			}
+			else { // else it's a token type reference
+				$code = getTokenElementST("tokenRef", "char_literal", $c, astSuffix, labelText);
+				String tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType($c.text));
+				$code.setAttribute("token",tokenLabel);
+				if ( $c.terminalOptions!=null ) {
+					$code.setAttribute("terminalOptions",$c.terminalOptions);
+				}
+				int i = ((CommonToken)$c.getToken()).getTokenIndex();
+				$code.setAttribute("elementIndex", i);
+				generator.generateLocalFOLLOW($c,tokenLabel,currentRuleName,i);
+			}
+		}
+
+	|	s=STRING_LITERAL
+		{
+			int i = ((CommonToken)$s.getToken()).getTokenIndex();
+			if ( grammar.type==Grammar.LEXER )
+			{
+				$code = templates.getInstanceOf("lexerStringRef");
+				$code.setAttribute("string",
+					generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
+				$code.setAttribute("elementIndex", i);
+				if ( label!=null )
+				{
+					$code.setAttribute("label", labelText);
+				}
+			}
+			else
+			{
+				// else it's a token type reference
+				$code = getTokenElementST("tokenRef", "string_literal", $s, astSuffix, labelText);
+				String tokenLabel =
+					generator.getTokenTypeAsTargetLabel(grammar.getTokenType($s.text));
+				$code.setAttribute("token",tokenLabel);
+				if ( $s.terminalOptions!=null )
+				{
+					$code.setAttribute("terminalOptions",$s.terminalOptions);
+				}
+				$code.setAttribute("elementIndex", i);
+				generator.generateLocalFOLLOW($s,tokenLabel,currentRuleName,i);
+			}
+		}
+
+	|	w=WILDCARD
+		{
+			$code = getWildcardST($w,astSuffix,labelText);
+			$code.setAttribute("elementIndex", ((CommonToken)$w.getToken()).getTokenIndex());
+		}
+
+	|	^(DOT ID a=atom[$ID, label, astSuffix]) // scope override on rule or token
+		{ $code = $a.code; }
+
+	|	set[label,astSuffix]
+		{ $code = $set.code; }
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
+
+set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+@init
+{
+	String labelText=null;
+	if ( $label!=null )
+	{
+		labelText = $label.getText();
+	}
+}
+	:	^(s=BLOCK .*) // only care that it's a BLOCK with setValue!=null
+		{
+			$code = getTokenElementST("matchSet", "set", $s, astSuffix, labelText);
+			int i = ((CommonToken)$s.getToken()).getTokenIndex();
+			$code.setAttribute("elementIndex", i);
+			if ( grammar.type!=Grammar.LEXER )
+			{
+				generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
+			}
+			$code.setAttribute("s", generator.genSetExpr(templates,$s.getSetValue(),1,false));
+		}
+	;
+
+setElement
+	:	CHAR_LITERAL
+	|	TOKEN_REF
+	|	STRING_LITERAL
+	|	^(CHAR_RANGE CHAR_LITERAL CHAR_LITERAL)
+	;
+
+// REWRITE stuff
+
+rewrite returns [StringTemplate code=null]
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		if ( $start.getType()==REWRITES )
+		{
+			if ( generator.grammar.buildTemplate() )
+			{
+				$code = templates.getInstanceOf("rewriteTemplate");
+			}
+			else
+			{
+				$code = templates.getInstanceOf("rewriteCode");
+				$code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.setAttribute("referencedElementsDeep",
+								  getTokenTypesAsTargetLabels($start.rewriteRefsDeep));
+				Set<String> tokenLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LABEL);
+				Set<String> tokenListLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LIST_LABEL);
+				Set<String> ruleLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.RULE_LABEL);
+				Set<String> ruleListLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.RULE_LIST_LABEL);
+				Set<String> wildcardLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LABEL);
+				Set<String> wildcardListLabels =
+					grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
+				// just in case they ref $r for "previous value", make a stream
+				// from retval.tree
+				StringTemplate retvalST = templates.getInstanceOf("prevRuleRootRef");
+				ruleLabels.add(retvalST.toString());
+				$code.setAttribute("referencedTokenLabels", tokenLabels);
+				$code.setAttribute("referencedTokenListLabels", tokenListLabels);
+				$code.setAttribute("referencedRuleLabels", ruleLabels);
+				$code.setAttribute("referencedRuleListLabels", ruleListLabels);
+				$code.setAttribute("referencedWildcardLabels", wildcardLabels);
+				$code.setAttribute("referencedWildcardListLabels", wildcardListLabels);
+			}
+		}
+		else
+		{
+				$code = templates.getInstanceOf("noRewrite");
+				$code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+		}
+	}
+}
+	:	^(	REWRITES
+			(
+				{rewriteRuleRefs = new HashSet<Object>();}
+				^( r=REWRITE (pred=SEMPRED)? alt=rewrite_alternative)
+				{
+					rewriteBlockNestingLevel = OUTER_REWRITE_NESTING_LEVEL;
+					List predChunks = null;
+					if ( $pred!=null )
+					{
+						//predText = #pred.getText();
+						predChunks = generator.translateAction(currentRuleName,$pred);
+					}
+					String description =
+						grammar.grammarTreeToString($r,false);
+					description = generator.target.getTargetStringLiteralFromString(description);
+					$code.setAttribute("alts.{pred,alt,description}",
+									  predChunks,
+									  alt,
+									  description);
+					pred=null;
+				}
+			)*
+		)
+	|
+	;
+
+rewrite_block[String blockTemplateName] returns [StringTemplate code=null]
+@init
+{
+	rewriteBlockNestingLevel++;
+	StringTemplate save_currentBlockST = currentBlockST;
+	if ( state.backtracking == 0 )
+	{
+		$code = templates.getInstanceOf(blockTemplateName);
+		currentBlockST = $code;
+		$code.setAttribute("rewriteBlockLevel", rewriteBlockNestingLevel);
+	}
+}
+	:	^(	BLOCK
+			{
+				currentBlockST.setAttribute("referencedElementsDeep",
+					getTokenTypesAsTargetLabels($BLOCK.rewriteRefsDeep));
+				currentBlockST.setAttribute("referencedElements",
+					getTokenTypesAsTargetLabels($BLOCK.rewriteRefsShallow));
+			}
+			alt=rewrite_alternative
+			EOB
+		)
+		{
+			$code.setAttribute("alt", $alt.code);
+		}
+	;
+finally { rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST; }
+
+rewrite_alternative returns [StringTemplate code=null]
+	:	{generator.grammar.buildAST()}?
+		^(	a=ALT {$code=templates.getInstanceOf("rewriteElementList");}
+			(	(
+					el=rewrite_element
+					{$code.setAttribute("elements.{el,line,pos}",
+										$el.code,
+										$el.start.getLine(),
+										$el.start.getCharPositionInLine() + 1
+										);
+					}
+				)+
+			|	EPSILON
+				{$code.setAttribute("elements.{el,line,pos}",
+								   templates.getInstanceOf("rewriteEmptyAlt"),
+								   $a.getLine(),
+								   $a.getCharPositionInLine() + 1
+								   );
+				}
+			)
+			EOA
+		 )
+
+	|	{generator.grammar.buildTemplate()}? rewrite_template
+		{ $code = $rewrite_template.code; }
+
+	|	// reproduce same input (only AST at moment)
+		ETC
+	;
+
+rewrite_element returns [StringTemplate code=null]
+@init
+{
+	IntSet elements=null;
+	GrammarAST ast = null;
+}
+	:	rewrite_atom[false]
+		{ $code = $rewrite_atom.code; }
+	|	rewrite_ebnf
+		{ $code = $rewrite_ebnf.code; }
+	|	rewrite_tree
+		{ $code = $rewrite_tree.code; }
+	;
+
+rewrite_ebnf returns [StringTemplate code=null]
+	:	^( OPTIONAL rewrite_block["rewriteOptionalBlock"] )
+		{ $code = $rewrite_block.code; }
+		{
+			String description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	|	^( CLOSURE rewrite_block["rewriteClosureBlock"] )
+		{ $code = $rewrite_block.code; }
+		{
+			String description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	|	^( POSITIVE_CLOSURE rewrite_block["rewritePositiveClosureBlock"] )
+		{ $code = $rewrite_block.code; }
+		{
+			String description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	;
+
+rewrite_tree returns [StringTemplate code]
+@init
+{
+	rewriteTreeNestingLevel++;
+	if ( state.backtracking == 0 )
+	{
+		$code = templates.getInstanceOf("rewriteTree");
+		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+		$code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+	}
+}
+	:	^(	TREE_BEGIN
+			r=rewrite_atom[true]
+			{
+				$code.setAttribute("root.{el,line,pos}",
+								   $r.code,
+								   $r.start.getLine(),
+								   $r.start.getCharPositionInLine() + 1
+								  );
+			}
+			(
+			  el=rewrite_element
+			  {
+				$code.setAttribute("children.{el,line,pos}",
+									$el.code,
+									$el.start.getLine(),
+									$el.start.getCharPositionInLine() + 1
+									);
+			  }
+			)*
+		)
+		{
+			String description = grammar.grammarTreeToString($start, false);
+			description = generator.target.getTargetStringLiteralFromString(description);
+			$code.setAttribute("description", description);
+		}
+	;
+finally { rewriteTreeNestingLevel--; }
+
+rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
+	:   r=RULE_REF
+		{
+			String ruleRefName = $r.text;
+			String stName = "rewriteRuleRef";
+			if ( isRoot )
+			{
+				stName += "Root";
+			}
+			$code = templates.getInstanceOf(stName);
+			$code.setAttribute("rule", ruleRefName);
+			if ( grammar.getRule(ruleRefName)==null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
+										  grammar,
+										  ((GrammarAST)($r)).getToken(),
+										  ruleRefName);
+				$code = new StringTemplate(); // blank; no code gen
+			}
+			else if ( grammar.getRule(currentRuleName)
+						 .getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_REWRITE_ELEMENT_NOT_PRESENT_ON_LHS,
+										  grammar,
+										  ((GrammarAST)($r)).getToken(),
+										  ruleRefName);
+				$code = new StringTemplate(); // blank; no code gen
+			}
+			else
+			{
+				// track all rule refs as we must copy 2nd ref to rule and beyond
+				if ( !rewriteRuleRefs.contains(ruleRefName) )
+				{
+					rewriteRuleRefs.add(ruleRefName);
+				}
+			}
+		}
+
+	|
+		(	^(tk=TOKEN_REF (arg=ARG_ACTION)?)
+		|	cl=CHAR_LITERAL
+		|	sl=STRING_LITERAL
+		)
+		{
+			GrammarAST term = $tk;
+			if (term == null) term = $cl;
+			if (term == null) term = $sl;
+			String tokenName = $start.getToken().getText();
+			String stName = "rewriteTokenRef";
+			Rule rule = grammar.getRule(currentRuleName);
+			Collection<String> tokenRefsInAlt = rule.getTokenRefsInAlt(outerAltNum);
+			boolean createNewNode = !tokenRefsInAlt.contains(tokenName) || $arg!=null;
+			if ( createNewNode )
+			{
+				stName = "rewriteImaginaryTokenRef";
+			}
+			if ( isRoot )
+			{
+				stName += "Root";
+			}
+			$code = templates.getInstanceOf(stName);
+			$code.setAttribute("terminalOptions",term.terminalOptions);
+			if ( $arg!=null )
+			{
+				List args = generator.translateAction(currentRuleName,$arg);
+				$code.setAttribute("args", args);
+			}
+			$code.setAttribute("elementIndex", ((CommonToken)$start.getToken()).getTokenIndex());
+			int ttype = grammar.getTokenType(tokenName);
+			String tok = generator.getTokenTypeAsTargetLabel(ttype);
+			$code.setAttribute("token", tok);
+			if ( grammar.getTokenType(tokenName)==Label.INVALID )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
+										  grammar,
+										  ((GrammarAST)($start)).getToken(),
+										  tokenName);
+				$code = new StringTemplate(); // blank; no code gen
+			}
+		}
+
+	|	LABEL
+		{
+			String labelName = $LABEL.text;
+			Rule rule = grammar.getRule(currentRuleName);
+			Grammar.LabelElementPair pair = rule.getLabel(labelName);
+			if ( labelName.equals(currentRuleName) )
+			{
+				// special case; ref to old value via $ rule
+				if ( rule.hasRewrite(outerAltNum) &&
+					 rule.getRuleRefsInAlt(outerAltNum).contains(labelName) )
+				{
+					ErrorManager.grammarError(ErrorManager.MSG_RULE_REF_AMBIG_WITH_RULE_IN_ALT,
+											  grammar,
+											  ((GrammarAST)($LABEL)).getToken(),
+											  labelName);
+				}
+				StringTemplate labelST = templates.getInstanceOf("prevRuleRootRef");
+				$code = templates.getInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
+				$code.setAttribute("label", labelST);
+			}
+			else if ( pair==null )
+			{
+				ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_LABEL_REF_IN_REWRITE,
+										  grammar,
+										  ((GrammarAST)($LABEL)).getToken(),
+										  labelName);
+				$code = new StringTemplate();
+			}
+			else
+			{
+				String stName = null;
+				switch ( pair.type )
+				{
+				case Grammar.TOKEN_LABEL :
+					stName = "rewriteTokenLabelRef";
+					break;
+				case Grammar.WILDCARD_TREE_LABEL :
+					stName = "rewriteWildcardLabelRef";
+					break;
+				case Grammar.WILDCARD_TREE_LIST_LABEL:
+					stName = "rewriteRuleListLabelRef"; // acts like rule ref list for ref
+					break;
+				case Grammar.RULE_LABEL :
+					stName = "rewriteRuleLabelRef";
+					break;
+				case Grammar.TOKEN_LIST_LABEL :
+					stName = "rewriteTokenListLabelRef";
+					break;
+				case Grammar.RULE_LIST_LABEL :
+					stName = "rewriteRuleListLabelRef";
+					break;
+				}
+				if ( isRoot )
+				{
+					stName += "Root";
+				}
+				$code = templates.getInstanceOf(stName);
+				$code.setAttribute("label", labelName);
+			}
+		}
+
+	|	ACTION
+		{
+			// actions in rewrite rules yield a tree object
+			String actText = $ACTION.text;
+			List chunks = generator.translateAction(currentRuleName,$ACTION);
+			$code = templates.getInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
+			$code.setAttribute("action", chunks);
+		}
+	;
+
+public
+rewrite_template returns [StringTemplate code=null]
+	:	^( ALT EPSILON EOA ) {$code=templates.getInstanceOf("rewriteEmptyTemplate");}
+	|	^(	TEMPLATE (id=ID|ind=ACTION)
+			{
+				if ( $id!=null && $id.text.equals("template") )
+				{
+						$code = templates.getInstanceOf("rewriteInlineTemplate");
+				}
+				else if ( $id!=null )
+				{
+						$code = templates.getInstanceOf("rewriteExternalTemplate");
+						$code.setAttribute("name", $id.text);
+				}
+				else if ( $ind!=null )
+				{ // must be \%({expr})(args)
+					$code = templates.getInstanceOf("rewriteIndirectTemplate");
+					List chunks=generator.translateAction(currentRuleName,$ind);
+					$code.setAttribute("expr", chunks);
+				}
+			}
+			^(	ARGLIST
+				(	^( ARG arg=ID a=ACTION
+					{
+						// must set alt num here rather than in define.g
+						// because actions like \%foo(name={\$ID.text}) aren't
+						// broken up yet into trees.
+						$a.outerAltNum = this.outerAltNum;
+						List chunks = generator.translateAction(currentRuleName,$a);
+						$code.setAttribute("args.{name,value}", $arg.text, chunks);
+					}
+					)
+				)*
+			)
+			(	DOUBLE_QUOTE_STRING_LITERAL
+				{
+					String sl = $DOUBLE_QUOTE_STRING_LITERAL.text;
+					String t = sl.substring( 1, sl.length() - 1 ); // strip quotes
+					t = generator.target.getTargetStringLiteralFromString(t);
+					$code.setAttribute("template",t);
+				}
+			|	DOUBLE_ANGLE_STRING_LITERAL
+				{
+					String sl = $DOUBLE_ANGLE_STRING_LITERAL.text;
+					String t = sl.substring( 2, sl.length() - 2 ); // strip double angle quotes
+					t = generator.target.getTargetStringLiteralFromString(t);
+					$code.setAttribute("template",t);
+				}
+			)?
+		)
+
+	|	act=ACTION
+		{
+			// set alt num for same reason as ARGLIST above
+			$act.outerAltNum = this.outerAltNum;
+			$code=templates.getInstanceOf("rewriteAction");
+			$code.setAttribute("action",
+							  generator.translateAction(currentRuleName,$act));
+		}
+	;
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/DefineGrammarItemsWalker.g b/tool/src/main/antlr3/org/antlr/grammar/v3/DefineGrammarItemsWalker.g
new file mode 100644
index 0000000..a47ba8b
--- /dev/null
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/DefineGrammarItemsWalker.g
@@ -0,0 +1,700 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2005-2011 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3:
+ Copyright (c) 2011 Sam Harwell
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+tree grammar DefineGrammarItemsWalker;
+
+options {
+	tokenVocab = ANTLR;
+	ASTLabelType = GrammarAST;
+}
+
+scope AttributeScopeActions {
+	HashMap<GrammarAST, GrammarAST> actions;
+}
+
+@header {
+package org.antlr.grammar.v3;
+import org.antlr.tool.*;
+import java.util.HashSet;
+import java.util.Set;
+}
+
+@members {
+protected Grammar grammar;
+protected GrammarAST root;
+protected String currentRuleName;
+protected GrammarAST currentRewriteBlock;
+protected GrammarAST currentRewriteRule;
+protected int outerAltNum = 0;
+protected int blockLevel = 0;
+
+public final int countAltsForRule( CommonTree t ) {
+    CommonTree block = (CommonTree)t.getFirstChildWithType(BLOCK);
+    int altCount = 0;
+    for (int i = 0; i < block.getChildCount(); i++) {
+        if (block.getChild(i).getType() == ALT)
+            altCount++;
+    }
+    return altCount;
+}
+
+protected final void finish() {
+    trimGrammar();
+}
+
+/** Remove any lexer rules from a COMBINED; already passed to lexer */
+protected final void trimGrammar() {
+    if ( grammar.type != Grammar.COMBINED ) {
+        return;
+    }
+    // form is (header ... ) ( grammar ID (scope ...) ... ( rule ... ) ( rule ... ) ... )
+    GrammarAST p = root;
+    // find the grammar spec
+    while ( !p.getText().equals( "grammar" ) ) {
+        p = (GrammarAST)p.getNextSibling();
+    }
+    for ( int i = 0; i < p.getChildCount(); i++ ) {
+        if ( p.getChild( i ).getType() != RULE )
+            continue;
+
+        String ruleName = p.getChild(i).getChild(0).getText();
+        //Console.Out.WriteLine( "rule " + ruleName + " prev=" + prev.getText() );
+        if (Rule.getRuleType(ruleName) == Grammar.LEXER) {
+            // remove lexer rule
+            p.deleteChild( i );
+            i--;
+        }
+    }
+    //Console.Out.WriteLine( "root after removal is: " + root.ToStringList() );
+}
+
+protected final void trackInlineAction( GrammarAST actionAST ) {
+    Rule r = grammar.getRule( currentRuleName );
+    if ( r != null ) {
+        r.trackInlineAction( actionAST );
+    }
+}
+}
+
+public
+grammar_[Grammar g]
+@init
+{
+grammar = $g;
+root = $start;
+}
+@after
+{
+finish();
+}
+	:	^( LEXER_GRAMMAR	{grammar.type = Grammar.LEXER;} 		grammarSpec )
+	|	^( PARSER_GRAMMAR	{grammar.type = Grammar.PARSER;}		grammarSpec )
+	|	^( TREE_GRAMMAR		{grammar.type = Grammar.TREE_PARSER;}	grammarSpec )
+	|	^( COMBINED_GRAMMAR	{grammar.type = Grammar.COMBINED;}		grammarSpec )
+	;
+
+attrScope
+scope AttributeScopeActions;
+@init
+{
+	$AttributeScopeActions::actions = new HashMap<GrammarAST, GrammarAST>();
+}
+	:	^( 'scope' name=ID attrScopeAction* attrs=ACTION )
+		{
+			AttributeScope scope = grammar.defineGlobalScope($name.text,$attrs.getToken());
+			scope.isDynamicGlobalScope = true;
+			scope.addAttributes($attrs.text, ';');
+			for (GrammarAST action : $AttributeScopeActions::actions.keySet())
+				scope.defineNamedAction(action, $AttributeScopeActions::actions.get(action));
+		}
+	;
+
+attrScopeAction
+	:	^(AMPERSAND ID ACTION)
+		{
+			$AttributeScopeActions::actions.put( $ID, $ACTION );
+		}
+	;
+
+grammarSpec
+	:	id=ID
+		(cmt=DOC_COMMENT)?
+		( optionsSpec )?
+		(delegateGrammars)?
+		(tokensSpec)?
+		(attrScope)*
+		(actions)?
+		rules
+	;
+
+actions
+	:	( action )+
+	;
+
+action
+@init
+{
+	String scope=null;
+	GrammarAST nameAST=null, actionAST=null;
+}
+	:	^(amp=AMPERSAND id1=ID
+			( id2=ID a1=ACTION
+			  {scope=$id1.text; nameAST=$id2; actionAST=$a1;}
+			| a2=ACTION
+			  {scope=null; nameAST=$id1; actionAST=$a2;}
+			)
+		 )
+		 {
+		 grammar.defineNamedAction($amp,scope,nameAST,actionAST);
+		 }
+	;
+
+optionsSpec
+	:	^(OPTIONS .*)
+	;
+
+delegateGrammars
+	:	^( 'import' ( ^(ASSIGN ID ID) | ID )+ )
+	;
+
+tokensSpec
+	:	^(TOKENS tokenSpec*)
+	;
+
+tokenSpec
+	:	t=TOKEN_REF
+	|	^(	ASSIGN
+			TOKEN_REF
+			(	STRING_LITERAL
+			|	CHAR_LITERAL
+			)
+		 )
+	;
+
+rules
+	:	(rule | ^(PREC_RULE .*))+
+	;
+
+rule
+@init
+{
+	String name=null;
+	Map<String, Object> opts=null;
+	Rule r = null;
+}
+	:		^( RULE id=ID {opts = $RULE.getBlockOptions();}
+			(modifier)?
+			^( ARG (args=ARG_ACTION)? )
+			^( RET (ret=ARG_ACTION)? )
+			(throwsSpec)?
+			(optionsSpec)?
+			{
+				name = $id.text;
+				currentRuleName = name;
+				if ( Rule.getRuleType(name) == Grammar.LEXER && grammar.type==Grammar.COMBINED )
+				{
+					// a merged grammar spec, track lexer rules and send to another grammar
+					grammar.defineLexerRuleFoundInParser($id.getToken(), $start);
+				}
+				else
+				{
+					int numAlts = countAltsForRule($start);
+					grammar.defineRule($id.getToken(), $modifier.mod, opts, $start, $args, numAlts);
+					r = grammar.getRule(name);
+					if ( $args!=null )
+					{
+						r.parameterScope = grammar.createParameterScope(name,$args.getToken());
+						r.parameterScope.addAttributes($args.text, ',');
+					}
+					if ( $ret!=null )
+					{
+						r.returnScope = grammar.createReturnScope(name,$ret.getToken());
+						r.returnScope.addAttributes($ret.text, ',');
+					}
+					if ( $throwsSpec.exceptions != null )
+					{
+						for (String exception : $throwsSpec.exceptions)
+							r.throwsSpec.add( exception );
+					}
+				}
+			}
+			(ruleScopeSpec[r])?
+			(ruleAction[r])*
+			{ this.blockLevel=0; }
+			b=block
+			(exceptionGroup)?
+			EOR
+			{
+				// copy rule options into the block AST, which is where
+				// the analysis will look for k option etc...
+				$b.start.setBlockOptions(opts);
+			}
+		)
+	;
+
+ruleAction[Rule r]
+	:	^(amp=AMPERSAND id=ID a=ACTION ) {if (r!=null) r.defineNamedAction($amp,$id,$a);}
+	;
+
+modifier returns [String mod]
+@init
+{
+	$mod = $start.getToken().getText();
+}
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec returns [HashSet<String> exceptions]
+@init
+{
+	$exceptions = new HashSet<String>();
+}
+	:	^('throws' (ID {$exceptions.add($ID.text);})+ )
+	;
+
+ruleScopeSpec[Rule r]
+scope AttributeScopeActions;
+@init
+{
+	$AttributeScopeActions::actions = new HashMap<GrammarAST, GrammarAST>();
+}
+	:	^(	'scope'
+			(	attrScopeAction* attrs=ACTION
+				{
+					r.ruleScope = grammar.createRuleScope(r.name,$attrs.getToken());
+					r.ruleScope.isDynamicRuleScope = true;
+					r.ruleScope.addAttributes($attrs.text, ';');
+					for (GrammarAST action : $AttributeScopeActions::actions.keySet())
+						r.ruleScope.defineNamedAction(action, $AttributeScopeActions::actions.get(action));
+				}
+			)?
+			(	uses=ID
+				{
+					if ( grammar.getGlobalScope($uses.text)==null ) {
+					ErrorManager.grammarError(ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE,
+					grammar,
+					$uses.getToken(),
+					$uses.text);
+					}
+					else {
+					if ( r.useScopes==null ) {r.useScopes=new ArrayList<String>();}
+					r.useScopes.add($uses.text);
+					}
+				}
+			)*
+		)
+	;
+
+block
+@init
+{
+	// must run during backtracking
+	this.blockLevel++;
+	if ( blockLevel == 1 )
+		this.outerAltNum=1;
+}
+	:	^(	BLOCK
+			(optionsSpec)?
+			(blockAction)*
+			(	alternative rewrite
+				{{
+					if ( this.blockLevel == 1 )
+						this.outerAltNum++;
+				}}
+			)+
+			EOB
+		 )
+	;
+finally { blockLevel--; }
+
+// TODO: this does nothing now! subrules cannot have init actions. :(
+blockAction
+	:	^(amp=AMPERSAND id=ID a=ACTION ) // {r.defineAction(#amp,#id,#a);}
+	;
+
+alternative
+//@init
+//{
+//	if ( state.backtracking == 0 )
+//	{
+//		if ( grammar.type!=Grammar.LEXER && grammar.GetOption("output")!=null && blockLevel==1 )
+//		{
+//			GrammarAST aRewriteNode = $start.FindFirstType(REWRITE); // alt itself has rewrite?
+//			GrammarAST rewriteAST = (GrammarAST)$start.Parent.getChild($start.ChildIndex + 1);
+//			// we have a rewrite if alt uses it inside subrule or this alt has one
+//			// but don't count -> ... rewrites, which mean "do default auto construction"
+//			if ( aRewriteNode!=null||
+//				 (firstRewriteAST!=null &&
+//				  firstRewriteAST.getType()==REWRITE &&
+//				  firstRewriteAST.getChild(0)!=null &&
+//				  firstRewriteAST.getChild(0).getType()!=ETC) )
+//			{
+//				Rule r = grammar.getRule(currentRuleName);
+//				r.TrackAltsWithRewrites($start,this.outerAltNum);
+//			}
+//		}
+//	}
+//}
+	:	^( ALT (element)+ EOA )
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ (finallyClause)?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:   ^('catch' ARG_ACTION ACTION) {trackInlineAction($ACTION);}
+	;
+
+finallyClause
+	:    ^('finally' ACTION) {trackInlineAction($ACTION);}
+	;
+
+element
+	:   ^(ROOT element)
+	|   ^(BANG element)
+	|   atom[null]
+	|   ^(NOT element)
+	|   ^(RANGE atom[null] atom[null])
+	|   ^(CHAR_RANGE atom[null] atom[null])
+	|	^(	ASSIGN id=ID el=element)
+			{
+				GrammarAST e = $el.start;
+				if ( e.getType()==ANTLRParser.ROOT || e.getType()==ANTLRParser.BANG )
+				{
+					e = (GrammarAST)e.getChild(0);
+				}
+				if ( e.getType()==RULE_REF)
+				{
+					grammar.defineRuleRefLabel(currentRuleName,$id.getToken(),e);
+				}
+				else if ( e.getType()==WILDCARD && grammar.type==Grammar.TREE_PARSER )
+				{
+					grammar.defineWildcardTreeLabel(currentRuleName,$id.getToken(),e);
+				}
+				else
+				{
+					grammar.defineTokenRefLabel(currentRuleName,$id.getToken(),e);
+				}
+			}
+	|	^(	PLUS_ASSIGN id2=ID a2=element
+			{
+				GrammarAST a = $a2.start;
+				if ( a.getType()==ANTLRParser.ROOT || a.getType()==ANTLRParser.BANG )
+				{
+					a = (GrammarAST)a.getChild(0);
+				}
+				if ( a.getType()==RULE_REF )
+				{
+					grammar.defineRuleListLabel(currentRuleName,$id2.getToken(),a);
+				}
+				else if ( a.getType() == WILDCARD && grammar.type == Grammar.TREE_PARSER )
+				{
+					grammar.defineWildcardTreeListLabel( currentRuleName, $id2.getToken(), a );
+				}
+				else
+				{
+					grammar.defineTokenListLabel(currentRuleName,$id2.getToken(),a);
+				}
+			}
+		 )
+	|   ebnf
+	|   tree_
+	|   ^( SYNPRED block )
+	|   act=ACTION
+		{
+			$act.outerAltNum = this.outerAltNum;
+			trackInlineAction($act);
+		}
+	|   act2=FORCED_ACTION
+		{
+			$act2.outerAltNum = this.outerAltNum;
+			trackInlineAction($act2);
+		}
+	|   SEMPRED
+		{
+			$SEMPRED.outerAltNum = this.outerAltNum;
+			trackInlineAction($SEMPRED);
+		}
+	|   SYN_SEMPRED
+	|   ^(BACKTRACK_SEMPRED .*)
+	|   GATED_SEMPRED
+		{
+			$GATED_SEMPRED.outerAltNum = this.outerAltNum;
+			trackInlineAction($GATED_SEMPRED);
+		}
+	|   EPSILON
+	;
+
+ebnf
+	:	(dotLoop) => dotLoop // .* or .+
+	|	block
+	|	^( OPTIONAL block )
+	|	^( CLOSURE block )
+	|	^( POSITIVE_CLOSURE block )
+	;
+
+/** Track the .* and .+ idioms and make them nongreedy by default.
+ */
+dotLoop
+	:	(	^( CLOSURE dotBlock )
+		|	^( POSITIVE_CLOSURE dotBlock )
+		)
+		{
+			GrammarAST block = (GrammarAST)$start.getChild(0);
+			Map<String, Object> opts = new HashMap<String, Object>();
+			opts.put("greedy", "false");
+			if ( grammar.type!=Grammar.LEXER )
+			{
+				// parser grammars assume k=1 for .* loops
+				// otherwise they (analysis?) look til EOF!
+				opts.put("k", 1);
+			}
+			block.setOptions(grammar,opts);
+		}
+	;
+
+dotBlock
+	:	^( BLOCK ^( ALT WILDCARD EOA ) EOB )
+	;
+
+tree_
+	:	^(TREE_BEGIN element+)
+	;
+
+atom[GrammarAST scope_]
+	:	^( rr=RULE_REF (rarg=ARG_ACTION)? )
+		{
+			grammar.altReferencesRule( currentRuleName, $scope_, $rr, this.outerAltNum );
+			if ( $rarg != null )
+			{
+				$rarg.outerAltNum = this.outerAltNum;
+				trackInlineAction($rarg);
+			}
+		}
+	|	^( t=TOKEN_REF (targ=ARG_ACTION )? )
+		{
+			if ( $targ != null )
+			{
+				$targ.outerAltNum = this.outerAltNum;
+				trackInlineAction($targ);
+			}
+			if ( grammar.type == Grammar.LEXER )
+			{
+				grammar.altReferencesRule( currentRuleName, $scope_, $t, this.outerAltNum );
+			}
+			else
+			{
+				grammar.altReferencesTokenID( currentRuleName, $t, this.outerAltNum );
+			}
+		}
+	|	c=CHAR_LITERAL
+		{
+			if ( grammar.type != Grammar.LEXER )
+			{
+				Rule rule = grammar.getRule(currentRuleName);
+				if ( rule != null )
+					rule.trackTokenReferenceInAlt($c, outerAltNum);
+			}
+		}
+	|	s=STRING_LITERAL
+		{
+			if ( grammar.type != Grammar.LEXER )
+			{
+				Rule rule = grammar.getRule(currentRuleName);
+				if ( rule!=null )
+					rule.trackTokenReferenceInAlt($s, outerAltNum);
+			}
+		}
+	|	WILDCARD
+	|	^(DOT ID atom[$ID]) // scope override on rule
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
+
+rewrite
+@init
+{
+	// track top level REWRITES node, store stuff there
+	currentRewriteRule = $start; // has to execute during backtracking
+	if ( state.backtracking == 0 )
+	{
+		if ( grammar.buildAST() )
+			currentRewriteRule.rewriteRefsDeep = new HashSet<GrammarAST>();
+	}
+}
+	:	^(	REWRITES
+			(	^( REWRITE (pred=SEMPRED)? rewrite_alternative )
+				{
+					if ( $pred != null )
+					{
+						$pred.outerAltNum = this.outerAltNum;
+						trackInlineAction($pred);
+					}
+				}
+			)*
+		)
+		//{System.out.println("-> refs = "+currentRewriteRule.rewriteRefsDeep);}
+	|
+	;
+
+rewrite_block
+@init
+{
+	GrammarAST enclosingBlock = currentRewriteBlock;
+	if ( state.backtracking == 0 )
+	{
+		// don't do if guessing
+		currentRewriteBlock=$start; // pts to BLOCK node
+		currentRewriteBlock.rewriteRefsShallow = new HashSet<GrammarAST>();
+		currentRewriteBlock.rewriteRefsDeep = new HashSet<GrammarAST>();
+	}
+}
+	:   ^( BLOCK rewrite_alternative EOB )
+		//{System.out.println("atoms="+currentRewriteBlock.rewriteRefs);}
+		{
+			// copy the element refs in this block to the surrounding block
+			if ( enclosingBlock != null )
+			{
+				for (GrammarAST item : currentRewriteBlock.rewriteRefsShallow)
+					enclosingBlock.rewriteRefsDeep.add( item );
+			}
+			//currentRewriteBlock = enclosingBlock; // restore old BLOCK ptr
+		}
+	;
+finally { currentRewriteBlock = enclosingBlock; }
+
+rewrite_alternative
+	:	{grammar.buildAST()}? => ^( a=ALT ( ( rewrite_element )+ | EPSILON ) EOA )
+	|	{grammar.buildTemplate()}? => rewrite_template
+	|	ETC {this.blockLevel==1}? // only valid as outermost rewrite
+	;
+
+rewrite_element
+	:	rewrite_atom
+	|	rewrite_ebnf
+	|	rewrite_tree
+	;
+
+rewrite_ebnf
+	:	^( OPTIONAL rewrite_block )
+	|	^( CLOSURE rewrite_block )
+	|	^( POSITIVE_CLOSURE rewrite_block )
+	;
+
+rewrite_tree
+	:   ^(	TREE_BEGIN rewrite_atom ( rewrite_element )* )
+	;
+
+rewrite_atom
+@init
+{
+	if ( state.backtracking == 0 )
+	{
+		Rule r = grammar.getRule(currentRuleName);
+		Set tokenRefsInAlt = r.getTokenRefsInAlt(outerAltNum);
+		boolean imaginary =
+			$start.getType()==TOKEN_REF &&
+			!tokenRefsInAlt.contains($start.getText());
+		if ( !imaginary && grammar.buildAST() &&
+			 ($start.getType()==RULE_REF ||
+			  $start.getType()==LABEL ||
+			  $start.getType()==TOKEN_REF ||
+			  $start.getType()==CHAR_LITERAL ||
+			  $start.getType()==STRING_LITERAL) )
+		{
+			// track per block and for entire rewrite rule
+			if ( currentRewriteBlock!=null )
+			{
+				currentRewriteBlock.rewriteRefsShallow.add($start);
+				currentRewriteBlock.rewriteRefsDeep.add($start);
+			}
+
+			//System.out.println("adding "+$start.getText()+" to "+currentRewriteRule.getText());
+			currentRewriteRule.rewriteRefsDeep.add($start);
+		}
+	}
+}
+	:	RULE_REF
+	|	(	^(	TOKEN_REF
+				(	ARG_ACTION
+					{
+						$ARG_ACTION.outerAltNum = this.outerAltNum;
+						trackInlineAction($ARG_ACTION);
+					}
+				)?
+			)
+		|	CHAR_LITERAL
+		|	STRING_LITERAL
+		)
+	|	LABEL
+	|	ACTION
+		{
+			$ACTION.outerAltNum = this.outerAltNum;
+			trackInlineAction($ACTION);
+		}
+	;
+
+rewrite_template
+	:	^(	ALT EPSILON EOA )
+	|	^(	TEMPLATE (id=ID|ind=ACTION)
+			^( ARGLIST
+				(	^( ARG arg=ID a=ACTION )
+					{
+						$a.outerAltNum = this.outerAltNum;
+						trackInlineAction($a);
+					}
+				)*
+			)
+			{
+				if ( $ind!=null )
+				{
+					$ind.outerAltNum = this.outerAltNum;
+					trackInlineAction($ind);
+				}
+			}
+			(	DOUBLE_QUOTE_STRING_LITERAL
+			|	DOUBLE_ANGLE_STRING_LITERAL
+			)?
+		)
+	|	act=ACTION
+		{
+			$act.outerAltNum = this.outerAltNum;
+			trackInlineAction($act);
+		}
+	;
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/LeftRecursiveRuleWalker.g b/tool/src/main/antlr3/org/antlr/grammar/v3/LeftRecursiveRuleWalker.g
new file mode 100644
index 0000000..537bd12
--- /dev/null
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/LeftRecursiveRuleWalker.g
@@ -0,0 +1,284 @@
+/*
+ * [The "BSD license"]
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Grammar conversion to ANTLR v3:
+ * Copyright (c) 2011 Sam Harwell
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** Find left-recursive rules */
+tree grammar LeftRecursiveRuleWalker;
+
+options {
+	tokenVocab=ANTLR;
+    ASTLabelType=GrammarAST;
+}
+
+@header {
+package org.antlr.grammar.v3;
+
+import org.antlr.analysis.*;
+import org.antlr.misc.*;
+import org.antlr.tool.*;
+
+import org.antlr.runtime.BitSet;
+import org.antlr.runtime.DFA;
+}
+
+@members {
+protected Grammar grammar;
+private String ruleName;
+private int outerAlt; // which outer alt of rule?
+public int numAlts;  // how many alts for this rule total?
+
+@Override
+public void reportError(RecognitionException ex)
+{
+    Token token = null;
+    if (ex instanceof MismatchedTokenException)
+    {
+        token = ((MismatchedTokenException)ex).token;
+    }
+    else if (ex instanceof NoViableAltException)
+    {
+        token = ((NoViableAltException)ex).token;
+    }
+
+    ErrorManager.syntaxError(
+        ErrorManager.MSG_SYNTAX_ERROR,
+        grammar,
+        token,
+        "assign.types: " + ex.toString(),
+        ex);
+}
+
+public void setTokenPrec(GrammarAST t, int alt) {}
+public void binaryAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+public void ternaryAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+public void prefixAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+public void suffixAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+public void otherAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {}
+public void setReturnValues(GrammarAST t) {}
+}
+
+optionsSpec
+	:	^(OPTIONS option+)
+	;
+
+option
+	:	^(ASSIGN ID optionValue)
+	;
+
+optionValue
+	:	ID
+	|	STRING_LITERAL
+	|	CHAR_LITERAL
+	|	INT
+	;
+
+charSetElement
+	:	CHAR_LITERAL
+	|	^(OR CHAR_LITERAL CHAR_LITERAL)
+	|	^(RANGE CHAR_LITERAL CHAR_LITERAL)
+	;
+
+public
+rec_rule[Grammar g] returns [boolean isLeftRec]
+@init
+{
+	grammar = g;
+	outerAlt = 1;
+}
+	:	^(	r=RULE id=ID {ruleName=$id.getText();}
+			modifier?
+			^(ARG ARG_ACTION?)
+			^(RET ARG_ACTION?)
+			optionsSpec?
+			ruleScopeSpec?
+			(^(AMPERSAND .*))*
+			ruleBlock {$isLeftRec = $ruleBlock.isLeftRec;}
+			exceptionGroup?
+			EOR
+		)
+		{if ($ruleBlock.isLeftRec) $r.setType(PREC_RULE);}
+	;
+
+modifier
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+ruleScopeSpec
+ 	:	^('scope' ACTION? ID*)
+ 	;
+
+ruleBlock returns [boolean isLeftRec]
+@init{boolean lr=false; this.numAlts = $start.getChildCount();}
+	:	^(	BLOCK
+			optionsSpec?
+			(	outerAlternative
+				{if ($outerAlternative.isLeftRec) $isLeftRec = true;}
+				rewrite?
+				{outerAlt++;}
+			)+
+			EOB
+		)
+	;
+
+block
+    :   ^(  BLOCK
+            optionsSpec?
+            ( ^(ALT element+ EOA) rewrite? )+
+            EOB
+         )
+    ;
+
+/** An alt is either prefix, suffix, binary, or ternary operation or "other" */
+outerAlternative returns [boolean isLeftRec]
+@init
+{
+GrammarAST rew=(GrammarAST)$start.getNextSibling();
+if (rew.getType() != REWRITES)
+	rew = null;
+}
+    :   (binaryMultipleOp)=> binaryMultipleOp
+                             {binaryAlt($start, rew, outerAlt); $isLeftRec=true;}
+    |   (binary)=>           binary
+                             {binaryAlt($start, rew, outerAlt); $isLeftRec=true;}
+    |   (ternary)=>          ternary
+                             {ternaryAlt($start, rew, outerAlt); $isLeftRec=true;}
+    |   (prefix)=>           prefix
+                             {prefixAlt($start, rew, outerAlt);}
+    |   (suffix)=>           suffix
+                             {suffixAlt($start, rew, outerAlt); $isLeftRec=true;}
+    |   ^(ALT element+ EOA) // "other" case
+                             {otherAlt($start, rew, outerAlt);}
+    ;
+
+binary
+	:	^( ALT (^(BACKTRACK_SEMPRED .*))? recurseNoLabel op=token recurse EOA ) {setTokenPrec($op.t, outerAlt);}
+	;
+
+binaryMultipleOp
+	:	^( ALT (^(BACKTRACK_SEMPRED .*))? recurseNoLabel ^( BLOCK ( ^( ALT op=token EOA {setTokenPrec($op.t, outerAlt);} ) )+ EOB ) recurse EOA )
+	;
+
+ternary
+	:	^( ALT (^(BACKTRACK_SEMPRED .*))? recurseNoLabel op=token recurse token recurse EOA ) {setTokenPrec($op.t, outerAlt);}
+	;
+
+prefix : ^( ALT (^(BACKTRACK_SEMPRED .*))? {setTokenPrec((GrammarAST)input.LT(1), outerAlt);} ({!((CommonTree)input.LT(1)).getText().equals(ruleName)}? element)+ recurse EOA ) ;
+
+suffix : ^( ALT (^(BACKTRACK_SEMPRED .*))? recurseNoLabel {setTokenPrec((GrammarAST)input.LT(1), outerAlt);} element+  EOA ) ;
+
+recurse
+	:	^(ASSIGN ID recurseNoLabel)
+	|	^(PLUS_ASSIGN ID recurseNoLabel)
+	|	recurseNoLabel
+	;
+
+recurseNoLabel : {((CommonTree)input.LT(1)).getText().equals(ruleName)}? RULE_REF;
+
+/*
+elementNotRecursiveRule
+    :   {_t.findFirstType(RULE_REF)!=null && _t.findFirstType(RULE_REF).getText().equals(ruleName)}?
+        e:element
+    ;
+*/
+
+token returns [GrammarAST t=null]
+	:	^(ASSIGN ID s=token {$t = $s.t;})
+	|	^(PLUS_ASSIGN ID s=token {$t = $s.t;})
+	|	^(ROOT s=token {$t = $s.t;})
+	|	^(BANG s=token {$t = $s.t;})
+	|	a=CHAR_LITERAL      {$t = $a;}
+	|	b=STRING_LITERAL    {$t = $b;}
+	|	c=TOKEN_REF         {$t = $c;}
+	;
+
+exceptionGroup
+	:	exceptionHandler+ finallyClause?
+	|	finallyClause
+    ;
+
+exceptionHandler
+	:	^('catch' ARG_ACTION ACTION)
+	;
+
+finallyClause
+	:	^('finally' ACTION)
+	;
+
+rewrite
+	:	^(REWRITES ( ^( REWRITE SEMPRED? (^(ALT .*)|^(TEMPLATE .*)|ACTION|ETC) ) )* )
+	;
+
+element
+	:	^(ROOT element)
+	|	^(BANG element)
+	|	atom
+	|	^(NOT element)
+	|	^(RANGE atom atom)
+	|	^(ASSIGN ID element)
+	|	^(PLUS_ASSIGN ID element)
+	|	ebnf
+	|	tree_
+	|	^(SYNPRED block)
+	|	FORCED_ACTION
+	|	ACTION
+	|	SEMPRED
+	|	SYN_SEMPRED
+	|	BACKTRACK_SEMPRED
+	|	GATED_SEMPRED
+	|	EPSILON
+	;
+
+ebnf:   block
+    |   ^( OPTIONAL block )
+    |   ^( CLOSURE block )
+    |   ^( POSITIVE_CLOSURE block )
+    ;
+
+tree_
+	:	^(TREE_BEGIN element+)
+	;
+
+atom
+	:	^(RULE_REF ARG_ACTION?)
+	|	^(TOKEN_REF ARG_ACTION?)
+	|	CHAR_LITERAL
+	|	STRING_LITERAL
+	|	WILDCARD
+	|	^(DOT ID atom) // scope override on rule
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/TreeToNFAConverter.g b/tool/src/main/antlr3/org/antlr/grammar/v3/TreeToNFAConverter.g
new file mode 100644
index 0000000..ab206ef
--- /dev/null
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/TreeToNFAConverter.g
@@ -0,0 +1,855 @@
+/*
+ [The "BSD license"]
+ Copyright (c) 2005-2011 Terence Parr
+ All rights reserved.
+
+ Grammar conversion to ANTLR v3:
+ Copyright (c) 2011 Sam Harwell
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without
+ modification, are permitted provided that the following conditions
+ are met:
+ 1. Redistributions of source code must retain the above copyright
+	notice, this list of conditions and the following disclaimer.
+ 2. Redistributions in binary form must reproduce the above copyright
+	notice, this list of conditions and the following disclaimer in the
+	documentation and/or other materials provided with the distribution.
+ 3. The name of the author may not be used to endorse or promote products
+	derived from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** Build an NFA from a tree representing an ANTLR grammar. */
+tree grammar TreeToNFAConverter;
+
+options {
+	tokenVocab = ANTLR;
+	ASTLabelType = GrammarAST;
+}
+
+@header {
+package org.antlr.grammar.v3;
+
+import org.antlr.analysis.*;
+import org.antlr.misc.*;
+import org.antlr.tool.*;
+
+import org.antlr.runtime.BitSet;
+import org.antlr.runtime.DFA;
+}
+
+@members {
+/** Factory used to create nodes and submachines */
+protected NFAFactory factory = null;
+
+/** Which NFA object are we filling in? */
+protected NFA nfa = null;
+
+/** Which grammar are we converting an NFA for? */
+protected Grammar grammar = null;
+
+protected String currentRuleName = null;
+
+protected int outerAltNum = 0;
+protected int blockLevel = 0;
+
+protected int inTest = 0;
+
+public TreeToNFAConverter(TreeNodeStream input, Grammar g, NFA nfa, NFAFactory factory) {
+    this(input);
+    this.grammar = g;
+    this.nfa = nfa;
+    this.factory = factory;
+}
+
+public final IntSet setRule(GrammarAST t) throws RecognitionException {
+    TreeToNFAConverter other = new TreeToNFAConverter( new CommonTreeNodeStream( t ), grammar, nfa, factory );
+
+    other.currentRuleName = currentRuleName;
+    other.outerAltNum = outerAltNum;
+    other.blockLevel = blockLevel;
+
+    return other.setRule();
+}
+
+public final int testBlockAsSet( GrammarAST t ) throws RecognitionException {
+    Rule r = grammar.getLocallyDefinedRule( currentRuleName );
+    if ( r.hasRewrite( outerAltNum ) )
+        return -1;
+
+    TreeToNFAConverter other = new TreeToNFAConverter( new CommonTreeNodeStream( t ), grammar, nfa, factory );
+
+    other.state.backtracking++;
+    other.currentRuleName = currentRuleName;
+    other.outerAltNum = outerAltNum;
+    other.blockLevel = blockLevel;
+
+    int result = other.testBlockAsSet();
+    if ( other.state.failed )
+        return -1;
+
+    return result;
+}
+
+public final int testSetRule( GrammarAST t ) throws RecognitionException {
+    TreeToNFAConverter other = new TreeToNFAConverter( new CommonTreeNodeStream( t ), grammar, nfa, factory );
+
+    other.state.backtracking++;
+    other.currentRuleName = currentRuleName;
+    other.outerAltNum = outerAltNum;
+    other.blockLevel = blockLevel;
+
+    int result = other.testSetRule();
+    if ( other.state.failed )
+        state.failed = true;
+
+    return result;
+}
+
+protected void addFollowTransition( String ruleName, NFAState following ) {
+    //System.Console.Out.WriteLine( "adding follow link to rule " + ruleName );
+    // find last link in FOLLOW chain emanating from rule
+    Rule r = grammar.getRule( ruleName );
+    NFAState end = r.stopState;
+    while ( end.transition( 1 ) != null )
+    {
+        end = (NFAState)end.transition( 1 ).target;
+    }
+    if ( end.transition( 0 ) != null )
+    {
+        // already points to a following node
+        // gotta add another node to keep edges to a max of 2
+        NFAState n = factory.newState();
+        Transition e = new Transition( Label.EPSILON, n );
+        end.addTransition( e );
+        end = n;
+    }
+    Transition followEdge = new Transition( Label.EPSILON, following );
+    end.addTransition( followEdge );
+}
+
+protected void finish() {
+    int numEntryPoints = factory.build_EOFStates( grammar.getRules() );
+    if ( numEntryPoints == 0 )
+    {
+        ErrorManager.grammarWarning( ErrorManager.MSG_NO_GRAMMAR_START_RULE,
+                                   grammar,
+                                   null,
+                                   grammar.name );
+    }
+}
+
+@Override
+public void reportError(RecognitionException ex) {
+    if ( inTest > 0 )
+        throw new IllegalStateException(ex);
+
+    Token token = null;
+    if ( ex instanceof MismatchedTokenException )
+    {
+        token = ( (MismatchedTokenException)ex ).token;
+    }
+    else if ( ex instanceof NoViableAltException )
+    {
+        token = ( (NoViableAltException)ex ).token;
+    }
+
+    ErrorManager.syntaxError(
+        ErrorManager.MSG_SYNTAX_ERROR,
+        grammar,
+        token,
+        "buildnfa: " + ex.toString(),
+        ex );
+}
+
+private boolean hasElementOptions(GrammarAST node) {
+    if (node == null)
+        throw new NullPointerException("node");
+    return node.terminalOptions != null && node.terminalOptions.size() > 0;
+}
+}
+
+public
+grammar_
+@after
+{
+	finish();
+}
+	:	(	^( LEXER_GRAMMAR grammarSpec )
+		|	^( PARSER_GRAMMAR grammarSpec )
+		|	^( TREE_GRAMMAR grammarSpec )
+		|	^( COMBINED_GRAMMAR grammarSpec )
+		)
+	;
+
+attrScope
+	:	^( 'scope' ID ( ^(AMPERSAND .*) )* ACTION )
+	;
+
+grammarSpec
+	:	ID
+		(cmt=DOC_COMMENT)?
+		( ^(OPTIONS .*) )?
+		( ^(IMPORT .*) )?
+		( ^(TOKENS .*) )?
+		(attrScope)*
+		( ^(AMPERSAND .*) )* // skip actions
+		rules
+	;
+
+rules
+	:	(rule | ^(PREC_RULE .*))+
+	;
+
+rule
+	:	^(	RULE id=ID
+			{
+				currentRuleName = $id.text;
+				factory.setCurrentRule(grammar.getLocallyDefinedRule(currentRuleName));
+			}
+			(modifier)?
+			^(ARG (ARG_ACTION)?)
+			^(RET (ARG_ACTION)?)
+			(throwsSpec)?
+			( ^(OPTIONS .*) )?
+			( ruleScopeSpec )?
+			( ^(AMPERSAND .*) )*
+			b=block
+			(exceptionGroup)?
+			EOR
+			{
+				StateCluster g = $b.g;
+				if ($b.start.getSetValue() != null)
+				{
+					// if block comes back as a set not BLOCK, make it
+					// a single ALT block
+					g = factory.build_AlternativeBlockFromSet(g);
+				}
+				if (Rule.getRuleType(currentRuleName) == Grammar.PARSER || grammar.type==Grammar.LEXER)
+				{
+					// attach start node to block for this rule
+					Rule thisR = grammar.getLocallyDefinedRule(currentRuleName);
+					NFAState start = thisR.startState;
+					start.associatedASTNode = $id;
+					start.addTransition(new Transition(Label.EPSILON, g.left));
+
+					// track decision if > 1 alts
+					if ( grammar.getNumberOfAltsForDecisionNFA(g.left)>1 )
+					{
+						g.left.setDescription(grammar.grammarTreeToString($start, false));
+						g.left.setDecisionASTNode($b.start);
+						int d = grammar.assignDecisionNumber( g.left );
+						grammar.setDecisionNFA( d, g.left );
+						grammar.setDecisionBlockAST(d, $b.start);
+					}
+
+					// hook to end of rule node
+					NFAState end = thisR.stopState;
+					g.right.addTransition(new Transition(Label.EPSILON,end));
+				}
+			}
+		)
+	;
+
+modifier
+	:	'protected'
+	|	'public'
+	|	'private'
+	|	'fragment'
+	;
+
+throwsSpec
+	:	^('throws' ID+)
+	;
+
+ruleScopeSpec
+	:	^( 'scope' ( ^(AMPERSAND .*) )* (ACTION)? ( ID )* )
+	;
+
+block returns [StateCluster g = null]
+@init
+{
+	List<StateCluster> alts = new ArrayList<StateCluster>();
+	this.blockLevel++;
+	if ( this.blockLevel==1 )
+		this.outerAltNum=1;
+}
+	:	{grammar.isValidSet(this,$start) &&
+		 !currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME)}? =>
+		set {$g = $set.g;}
+
+	|	^(	BLOCK ( ^(OPTIONS .*) )?
+			(	a=alternative rewrite
+				{
+					alts.add($a.g);
+				}
+				{{
+					if ( blockLevel == 1 )
+						outerAltNum++;
+				}}
+			)+
+			EOB
+		)
+		{$g = factory.build_AlternativeBlock(alts);}
+	;
+finally { blockLevel--; }
+
+alternative returns [StateCluster g=null]
+	:	^( ALT (e=element {$g = factory.build_AB($g,$e.g);} )+ EOA )
+		{
+			if ($g==null) { // if alt was a list of actions or whatever
+				$g = factory.build_Epsilon();
+			}
+			else {
+				factory.optimizeAlternative($g);
+			}
+		}
+	;
+
+exceptionGroup
+	:	( exceptionHandler )+ (finallyClause)?
+	|	finallyClause
+	;
+
+exceptionHandler
+	:    ^('catch' ARG_ACTION ACTION)
+	;
+
+finallyClause
+	:    ^('finally' ACTION)
+	;
+
+rewrite
+	:	^(	REWRITES
+			(
+				{
+					if ( grammar.getOption("output")==null )
+					{
+						ErrorManager.grammarError(ErrorManager.MSG_REWRITE_OR_OP_WITH_NO_OUTPUT_OPTION,
+												  grammar, $start.getToken(), currentRuleName);
+					}
+				}
+				^(REWRITE .*)
+			)*
+		)
+	|
+	;
+
+element returns [StateCluster g=null]
+	:   ^(ROOT e=element {$g = $e.g;})
+	|   ^(BANG e=element {$g = $e.g;})
+	|	^(ASSIGN ID e=element {$g = $e.g;})
+	|	^(PLUS_ASSIGN ID e=element {$g = $e.g;})
+	|   ^(RANGE a=atom[null] b=atom[null])
+		{$g = factory.build_Range(grammar.getTokenType($a.text),
+								 grammar.getTokenType($b.text));}
+	|   ^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
+		{
+		if ( grammar.type==Grammar.LEXER ) {
+			$g = factory.build_CharRange($c1.text, $c2.text);
+		}
+		}
+	|   atom_or_notatom {$g = $atom_or_notatom.g;}
+	|   ebnf {$g = $ebnf.g;}
+	|   tree_ {$g = $tree_.g;}
+	|   ^( SYNPRED block )
+	|   ACTION {$g = factory.build_Action($ACTION);}
+	|   FORCED_ACTION {$g = factory.build_Action($FORCED_ACTION);}
+	|   pred=SEMPRED {$g = factory.build_SemanticPredicate($pred);}
+	|   spred=SYN_SEMPRED {$g = factory.build_SemanticPredicate($spred);}
+	|   ^(bpred=BACKTRACK_SEMPRED .*) {$g = factory.build_SemanticPredicate($bpred);}
+	|   gpred=GATED_SEMPRED {$g = factory.build_SemanticPredicate($gpred);}
+	|   EPSILON {$g = factory.build_Epsilon();}
+	;
+
+ebnf returns [StateCluster g=null]
+@init
+{
+	GrammarAST blk = $start;
+	if (blk.getType() != BLOCK) {
+		blk = (GrammarAST)blk.getChild(0);
+	}
+	GrammarAST eob = blk.getLastChild();
+}
+	:	{grammar.isValidSet(this,$start)}? => set {$g = $set.g;}
+
+	|	b=block
+		{
+			// track decision if > 1 alts
+			if ( grammar.getNumberOfAltsForDecisionNFA($b.g.left)>1 )
+			{
+				$b.g.left.setDescription(grammar.grammarTreeToString(blk, false));
+				$b.g.left.setDecisionASTNode(blk);
+				int d = grammar.assignDecisionNumber( $b.g.left );
+				grammar.setDecisionNFA( d, $b.g.left );
+				grammar.setDecisionBlockAST(d, blk);
+			}
+			$g = $b.g;
+		}
+	|	^( OPTIONAL b=block )
+		{
+			StateCluster bg = $b.g;
+			if ( blk.getSetValue()!=null )
+			{
+				// if block comes back SET not BLOCK, make it
+				// a single ALT block
+				bg = factory.build_AlternativeBlockFromSet(bg);
+			}
+			$g = factory.build_Aoptional(bg);
+			$g.left.setDescription(grammar.grammarTreeToString($start, false));
+			// there is always at least one alt even if block has just 1 alt
+			int d = grammar.assignDecisionNumber( $g.left );
+			grammar.setDecisionNFA(d, $g.left);
+			grammar.setDecisionBlockAST(d, blk);
+			$g.left.setDecisionASTNode($start);
+		}
+	|	^( CLOSURE b=block )
+		{
+			StateCluster bg = $b.g;
+			if ( blk.getSetValue()!=null )
+			{
+				bg = factory.build_AlternativeBlockFromSet(bg);
+			}
+			$g = factory.build_Astar(bg);
+			// track the loop back / exit decision point
+			bg.right.setDescription("()* loopback of "+grammar.grammarTreeToString($start, false));
+			int d = grammar.assignDecisionNumber( bg.right );
+			grammar.setDecisionNFA(d, bg.right);
+			grammar.setDecisionBlockAST(d, blk);
+			bg.right.setDecisionASTNode(eob);
+			// make block entry state also have same decision for interpreting grammar
+			NFAState altBlockState = (NFAState)$g.left.transition(0).target;
+			altBlockState.setDecisionASTNode($start);
+			altBlockState.setDecisionNumber(d);
+			$g.left.setDecisionNumber(d); // this is the bypass decision (2 alts)
+			$g.left.setDecisionASTNode($start);
+		}
+	|	^( POSITIVE_CLOSURE b=block )
+		{
+			StateCluster bg = $b.g;
+			if ( blk.getSetValue()!=null )
+			{
+				bg = factory.build_AlternativeBlockFromSet(bg);
+			}
+			$g = factory.build_Aplus(bg);
+			// don't make a decision on left edge, can reuse loop end decision
+			// track the loop back / exit decision point
+			bg.right.setDescription("()+ loopback of "+grammar.grammarTreeToString($start, false));
+			int d = grammar.assignDecisionNumber( bg.right );
+			grammar.setDecisionNFA(d, bg.right);
+			grammar.setDecisionBlockAST(d, blk);
+			bg.right.setDecisionASTNode(eob);
+			// make block entry state also have same decision for interpreting grammar
+			NFAState altBlockState = (NFAState)$g.left.transition(0).target;
+			altBlockState.setDecisionASTNode($start);
+			altBlockState.setDecisionNumber(d);
+		}
+	;
+
+tree_ returns [StateCluster g=null]
+@init
+{
+	StateCluster down=null, up=null;
+}
+	:	^(	TREE_BEGIN
+			e=element { $g = $e.g; }
+			{
+				down = factory.build_Atom(Label.DOWN, $e.start);
+				// TODO set following states for imaginary nodes?
+				//el.followingNFAState = down.right;
+				$g = factory.build_AB($g,down);
+			}
+			( e=element {$g = factory.build_AB($g,$e.g);} )*
+			{
+				up = factory.build_Atom(Label.UP, $e.start);
+				//el.followingNFAState = up.right;
+				$g = factory.build_AB($g,up);
+				// tree roots point at right edge of DOWN for LOOK computation later
+				$start.NFATreeDownState = down.left;
+			}
+		)
+	;
+
+atom_or_notatom returns [StateCluster g=null]
+	:	atom[null] {$g = $atom.g;}
+	|	^(	n=NOT
+			(	c=CHAR_LITERAL (ast1=ast_suffix)?
+				{
+					int ttype=0;
+					if ( grammar.type==Grammar.LEXER )
+					{
+						ttype = Grammar.getCharValueFromGrammarCharLiteral($c.text);
+					}
+					else
+					{
+						ttype = grammar.getTokenType($c.text);
+					}
+					IntSet notAtom = grammar.complement(ttype);
+					if ( notAtom.isNil() )
+					{
+						ErrorManager.grammarError(
+							ErrorManager.MSG_EMPTY_COMPLEMENT,
+							grammar,
+							$c.getToken(),
+							$c.text);
+					}
+					$g=factory.build_Set(notAtom,$n);
+				}
+			|	t=TOKEN_REF (ast3=ast_suffix)?
+				{
+					int ttype=0;
+					IntSet notAtom = null;
+					if ( grammar.type==Grammar.LEXER )
+					{
+						notAtom = grammar.getSetFromRule(this,$t.text);
+						if ( notAtom==null )
+						{
+							ErrorManager.grammarError(
+								ErrorManager.MSG_RULE_INVALID_SET,
+								grammar,
+								$t.getToken(),
+								$t.text);
+						}
+						else
+						{
+							notAtom = grammar.complement(notAtom);
+						}
+					}
+					else
+					{
+						ttype = grammar.getTokenType($t.text);
+						notAtom = grammar.complement(ttype);
+					}
+					if ( notAtom==null || notAtom.isNil() )
+					{
+						ErrorManager.grammarError(
+							ErrorManager.MSG_EMPTY_COMPLEMENT,
+							grammar,
+							$t.getToken(),
+							$t.text);
+					}
+					$g=factory.build_Set(notAtom,$n);
+				}
+			|	set {$g = $set.g;}
+				{
+					GrammarAST stNode = (GrammarAST)$n.getChild(0);
+					//IntSet notSet = grammar.complement(stNode.getSetValue());
+					// let code generator complement the sets
+					IntSet s = stNode.getSetValue();
+					stNode.setSetValue(s);
+					// let code gen do the complement again; here we compute
+					// for NFA construction
+					s = grammar.complement(s);
+					if ( s.isNil() )
+					{
+						ErrorManager.grammarError(
+							ErrorManager.MSG_EMPTY_COMPLEMENT,
+							grammar,
+							$n.getToken());
+					}
+					$g=factory.build_Set(s,$n);
+				}
+			)
+			{$n.followingNFAState = $g.right;}
+		)
+	;
+
+atom[String scopeName] returns [StateCluster g=null]
+	:	^( r=RULE_REF (rarg=ARG_ACTION)? (as1=ast_suffix)? )
+		{
+			NFAState start = grammar.getRuleStartState(scopeName,$r.text);
+			if ( start!=null )
+			{
+				Rule rr = grammar.getRule(scopeName,$r.text);
+				$g = factory.build_RuleRef(rr, start);
+				r.followingNFAState = $g.right;
+				r.NFAStartState = $g.left;
+				if ( $g.left.transition(0) instanceof RuleClosureTransition
+					&& grammar.type!=Grammar.LEXER )
+				{
+					addFollowTransition($r.text, $g.right);
+				}
+				// else rule ref got inlined to a set
+			}
+		}
+
+	|	^( t=TOKEN_REF  (targ=ARG_ACTION)? (as2=ast_suffix)? )
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				NFAState start = grammar.getRuleStartState(scopeName,$t.text);
+				if ( start!=null )
+				{
+					Rule rr = grammar.getRule(scopeName,t.getText());
+					$g = factory.build_RuleRef(rr, start);
+					t.NFAStartState = $g.left;
+					// don't add FOLLOW transitions in the lexer;
+					// only exact context should be used.
+				}
+			}
+			else
+			{
+				$g = factory.build_Atom(t);
+				t.followingNFAState = $g.right;
+			}
+		}
+
+	|	^( c=CHAR_LITERAL  (as3=ast_suffix)? )
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				$g = factory.build_CharLiteralAtom(c);
+			}
+			else
+			{
+				$g = factory.build_Atom(c);
+				c.followingNFAState = $g.right;
+			}
+		}
+
+	|	^( s=STRING_LITERAL  (as4=ast_suffix)? )
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				$g = factory.build_StringLiteralAtom(s);
+			}
+			else
+			{
+				$g = factory.build_Atom(s);
+				s.followingNFAState = $g.right;
+			}
+		}
+
+	|	^(	w=WILDCARD (as5=ast_suffix)? )
+			{
+				if ( nfa.grammar.type == Grammar.TREE_PARSER
+					&& (w.getChildIndex() > 0 || w.getParent().getChild(1).getType() == EOA) )
+				{
+					$g = factory.build_WildcardTree( $w );
+				}
+				else
+				{
+					$g = factory.build_Wildcard( $w );
+				}
+			}
+
+	|	^( DOT scope_=ID a=atom[$scope_.text] {$g = $a.g;} ) // scope override
+	;
+
+ast_suffix
+	:	ROOT
+	|	BANG
+	;
+
+set returns [StateCluster g=null]
+@init
+{
+	IntSet elements=new IntervalSet();
+	if ( state.backtracking == 0 )
+		$start.setSetValue(elements); // track set for use by code gen
+}
+	:	^( b=BLOCK
+		   (^(ALT ( ^(BACKTRACK_SEMPRED .*) )? setElement[elements] EOA))+
+		   EOB
+		 )
+		{
+		$g = factory.build_Set(elements,$b);
+		$b.followingNFAState = $g.right;
+		$b.setSetValue(elements); // track set value of this block
+		}
+		//{System.out.println("set elements="+elements.toString(grammar));}
+	;
+
+setRule returns [IntSet elements=new IntervalSet()]
+@init
+{
+	IntSet s=null;
+}
+	:	^( RULE id=ID (modifier)? ARG RET ( ^(OPTIONS .*) )? ( ruleScopeSpec )?
+			( ^(AMPERSAND .*) )*
+			^( BLOCK ( ^(OPTIONS .*) )?
+			   ( ^(ALT (BACKTRACK_SEMPRED)? setElement[elements] EOA) )+
+			   EOB
+			 )
+			(exceptionGroup)?
+			EOR
+		 )
+	;
+catch[RecognitionException re] { throw re; }
+
+setElement[IntSet elements]
+@init
+{
+	int ttype;
+	IntSet ns=null;
+}
+	:	c=CHAR_LITERAL
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				ttype = Grammar.getCharValueFromGrammarCharLiteral($c.text);
+			}
+			else
+			{
+				ttype = grammar.getTokenType($c.text);
+			}
+			if ( elements.member(ttype) )
+			{
+				ErrorManager.grammarError(
+					ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+					grammar,
+					$c.getToken(),
+					$c.text);
+			}
+			elements.add(ttype);
+		}
+	|	t=TOKEN_REF
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				// recursively will invoke this rule to match elements in target rule ref
+				IntSet ruleSet = grammar.getSetFromRule(this,$t.text);
+				if ( ruleSet==null )
+				{
+					ErrorManager.grammarError(
+						ErrorManager.MSG_RULE_INVALID_SET,
+						grammar,
+						$t.getToken(),
+						$t.text);
+				}
+				else
+				{
+					elements.addAll(ruleSet);
+				}
+			}
+			else
+			{
+				ttype = grammar.getTokenType($t.text);
+				if ( elements.member(ttype) )
+				{
+					ErrorManager.grammarError(
+						ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+						grammar,
+						$t.getToken(),
+						$t.text);
+				}
+				elements.add(ttype);
+			}
+		}
+
+	|	s=STRING_LITERAL
+		{
+			ttype = grammar.getTokenType($s.text);
+			if ( elements.member(ttype) )
+			{
+				ErrorManager.grammarError(
+					ErrorManager.MSG_DUPLICATE_SET_ENTRY,
+					grammar,
+					$s.getToken(),
+					$s.text);
+			}
+			elements.add(ttype);
+		}
+	|	^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
+		{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				int a = Grammar.getCharValueFromGrammarCharLiteral($c1.text);
+				int b = Grammar.getCharValueFromGrammarCharLiteral($c2.text);
+				elements.addAll(IntervalSet.of(a,b));
+			}
+		}
+
+	|	gset=set
+		{
+			Transition setTrans = $gset.g.left.transition(0);
+			elements.addAll(setTrans.label.getSet());
+		}
+
+	|	^(	NOT {ns=new IntervalSet();}
+			setElement[ns]
+			{
+				IntSet not = grammar.complement(ns);
+				elements.addAll(not);
+			}
+		)
+	;
+
+/** Check to see if this block can be a set.  Can't have actions
+ *  etc...  Also can't be in a rule with a rewrite as we need
+ *  to track what's inside set for use in rewrite.
+ *
+ *  This should only be called from the helper function in TreeToNFAConverterHelper.cs
+ *  and from the rule testSetElement below.
+ */
+testBlockAsSet returns [int alts=0]
+options { backtrack = true; }
+@init
+{
+	inTest++;
+}
+	:	^(	BLOCK
+			(	^(ALT (BACKTRACK_SEMPRED)? testSetElement {{$alts += $testSetElement.alts;}} EOA)
+			)+
+			EOB
+		)
+	;
+catch[RecognitionException re] { throw re; }
+finally { inTest--; }
+
+testSetRule returns [int alts=0]
+@init
+{
+	inTest++;
+}
+	:	^(	RULE id=ID (modifier)? ARG RET ( ^(OPTIONS .*) )? ( ruleScopeSpec )?
+			( ^(AMPERSAND .*) )*
+			^(	BLOCK
+				(	^(ALT (BACKTRACK_SEMPRED)? testSetElement {{$alts += $testSetElement.alts;}} EOA)
+				)+
+				EOB
+			)
+			(exceptionGroup)?
+			EOR
+		)
+	;
+catch[RecognitionException re] { throw re; }
+finally { inTest--; }
+
+/** Match just an element; no ast suffix etc.. */
+testSetElement returns [int alts=1]
+	:	c=CHAR_LITERAL {!hasElementOptions($c)}?
+	|	t=TOKEN_REF {!hasElementOptions($t)}?
+		{{
+			if ( grammar.type==Grammar.LEXER )
+			{
+				Rule rule = grammar.getRule($t.text);
+				if ( rule==null )
+				{
+					//throw new RecognitionException("invalid rule");
+					throw new RecognitionException();
+				}
+				// recursively will invoke this rule to match elements in target rule ref
+				$alts += testSetRule(rule.tree);
+			}
+		}}
+	|   {grammar.type!=Grammar.LEXER}? => s=STRING_LITERAL
+	|	^(CHAR_RANGE c1=CHAR_LITERAL c2=CHAR_LITERAL)
+		{{ $alts = IntervalSet.of( Grammar.getCharValueFromGrammarCharLiteral($c1.text), Grammar.getCharValueFromGrammarCharLiteral($c2.text) ).size(); }}
+	|   testBlockAsSet
+		{{ $alts = $testBlockAsSet.alts; }}
+	|   ^( NOT tse=testSetElement )
+		{{ $alts = grammar.getTokenTypes().size() - $tse.alts; }}
+	;
+catch[RecognitionException re] { throw re; }
diff --git a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
index a81bf70..0e4d393 100644
--- a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
+++ b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
@@ -27,10 +27,10 @@
*/
package org.antlr.analysis;

-import antlr.Token;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.misc.MultiMap;
import org.antlr.misc.Utils;
+import org.antlr.runtime.Token;
import org.antlr.tool.ErrorManager;
import org.antlr.tool.Grammar;
import org.antlr.tool.GrammarAST;
@@ -472,16 +472,16 @@ public class DecisionProbe {
if ( dfa.isTokensRuleDecision() ) {
for (Integer altI : unreachableAlts) {
GrammarAST decAST = dfa.getDecisionASTNode();
-						GrammarAST altAST = decAST.getChild(altI-1);
+						GrammarAST altAST = (GrammarAST)decAST.getChild(altI-1);
GrammarAST delegatedTokensAlt =
-							altAST.getFirstChildWithType(ANTLRParser.DOT);
+							(GrammarAST)altAST.getFirstChildWithType(ANTLRParser.DOT);
if ( delegatedTokensAlt !=null ) {
isInheritedTokensRule = true;
ErrorManager.grammarWarning(ErrorManager.MSG_IMPORTED_TOKENS_RULE_EMPTY,
dfa.nfa.grammar,
null,
dfa.nfa.grammar.name,
-														delegatedTokensAlt.getFirstChild().getText());
+														delegatedTokensAlt.getChild(0).getText());
}
}
}
@@ -509,10 +509,10 @@ public class DecisionProbe {
GrammarAST lastAltAST = null;
if ( blockAST.getChild(0).getType()==ANTLRParser.OPTIONS ) {
// if options, skip first child: ( options { ( = greedy false ) )
-			lastAltAST = blockAST.getChild(lastAlt.intValue());
+			lastAltAST = (GrammarAST)blockAST.getChild(lastAlt.intValue());
}
else {
-			lastAltAST = blockAST.getChild(lastAlt.intValue()-1);
+			lastAltAST = (GrammarAST)blockAST.getChild(lastAlt.intValue()-1);
}
//System.out.println("last alt is "+lastAltAST.toStringTree());
// if last alt looks like ( ALT . <end-of-alt> ) then wildcard
diff --git a/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java b/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java
index ecd284a..c3f4432 100644
--- a/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java
+++ b/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java
@@ -27,7 +27,7 @@
*/
package org.antlr.analysis;

-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.misc.IntSet;
import org.antlr.misc.IntervalSet;
import org.antlr.tool.Grammar;
diff --git a/tool/src/main/java/org/antlr/analysis/LL1DFA.java b/tool/src/main/java/org/antlr/analysis/LL1DFA.java
index bdd744c..d8f6759 100644
--- a/tool/src/main/java/org/antlr/analysis/LL1DFA.java
+++ b/tool/src/main/java/org/antlr/analysis/LL1DFA.java
@@ -27,7 +27,7 @@
*/
package org.antlr.analysis;

-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.misc.IntervalSet;
import org.antlr.misc.MultiMap;

diff --git a/tool/src/main/java/org/antlr/analysis/MachineProbe.java b/tool/src/main/java/org/antlr/analysis/MachineProbe.java
index 31c288f..e5da266 100644
--- a/tool/src/main/java/org/antlr/analysis/MachineProbe.java
+++ b/tool/src/main/java/org/antlr/analysis/MachineProbe.java
@@ -28,9 +28,9 @@

package org.antlr.analysis;

-import antlr.CommonToken;
-import antlr.Token;
import org.antlr.misc.IntSet;
+import org.antlr.runtime.CommonToken;
+import org.antlr.runtime.Token;
import org.antlr.tool.Grammar;

import java.util.ArrayList;
@@ -129,11 +129,11 @@ public class MachineProbe {
if (!t.isEpsilon() && !t.label.getSet().and(label).isNil()
&& next.contains(t.target)) {
if (p.associatedASTNode != null) {
-							antlr.Token oldtoken = p.associatedASTNode.token;
+							Token oldtoken = p.associatedASTNode.token;
CommonToken token = new CommonToken(oldtoken
.getType(), oldtoken.getText());
token.setLine(oldtoken.getLine());
-							token.setColumn(oldtoken.getColumn());
+							token.setCharPositionInLine(oldtoken.getCharPositionInLine());
tokens.add(token);
break nfaConfigLoop; // found path, move to next
// NFAState set
diff --git a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
index 27e680a..543ab2b 100644
--- a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
+++ b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
@@ -27,9 +27,9 @@
*/
package org.antlr.analysis;

-import antlr.Token;
import org.antlr.misc.OrderedHashSet;
import org.antlr.misc.Utils;
+import org.antlr.runtime.Token;
import org.antlr.tool.ErrorManager;

import java.util.*;
diff --git a/tool/src/main/java/org/antlr/analysis/SemanticContext.java b/tool/src/main/java/org/antlr/analysis/SemanticContext.java
index a006965..838902b 100644
--- a/tool/src/main/java/org/antlr/analysis/SemanticContext.java
+++ b/tool/src/main/java/org/antlr/analysis/SemanticContext.java
@@ -28,7 +28,7 @@
package org.antlr.analysis;

import org.antlr.codegen.CodeGenerator;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.stringtemplate.StringTemplate;
import org.antlr.stringtemplate.StringTemplateGroup;
import org.antlr.tool.Grammar;
diff --git a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
index ecbd3dc..085ee5d 100644
--- a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
+++ b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
@@ -28,16 +28,19 @@
package org.antlr.codegen;


-import antlr.RecognitionException;
import antlr.TokenStreamRewriteEngine;
-import antlr.collections.AST;
import org.antlr.Tool;
import org.antlr.analysis.*;
-import org.antlr.grammar.v2.ANTLRParser;
-import org.antlr.grammar.v2.CodeGenTreeWalker;
+import org.antlr.analysis.DFA;
+import org.antlr.grammar.v3.ANTLRLexer;
+import org.antlr.grammar.v3.ANTLRParser;
+import org.antlr.grammar.v3.CodeGenTreeWalker;
import org.antlr.grammar.v3.ActionTranslator;
import org.antlr.misc.BitSet;
import org.antlr.misc.*;
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.CommonTreeNodeStream;
+import org.antlr.runtime.tree.Tree;
import org.antlr.stringtemplate.*;
import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
import org.antlr.tool.*;
@@ -424,9 +427,9 @@ public class CodeGenerator {
// Walk the AST holding the input grammar, this time generating code
// Decisions are generated by using the precomputed DFAs
// Fill in the various templates with data
-		CodeGenTreeWalker gen = new CodeGenTreeWalker();
+		CodeGenTreeWalker gen = new CodeGenTreeWalker(new CommonTreeNodeStream(grammar.getGrammarTree()));
try {
-			gen.grammar((AST)grammar.getGrammarTree(),
+			gen.grammar_(
grammar,
recognizerST,
outputFileST,
@@ -917,8 +920,8 @@ public class CodeGenerator {
List<StringTemplate> translatedArgs = new ArrayList<StringTemplate>();
for (String arg : args) {
if ( arg!=null ) {
-				antlr.Token actionToken =
-					new antlr.CommonToken(ANTLRParser.ACTION,arg);
+				Token actionToken =
+					new CommonToken(ANTLRParser.ACTION,arg);
ActionTranslator translator =
new ActionTranslator(this,ruleName,
actionToken,
@@ -1041,24 +1044,18 @@ public class CodeGenerator {
*/
public StringTemplate translateTemplateConstructor(String ruleName,
int outerAltNum,
-													   antlr.Token actionToken,
+													   Token actionToken,
String templateActionText)
{
// first, parse with antlr.g
//System.out.println("translate template: "+templateActionText);
-		org.antlr.grammar.v2.ANTLRLexer lexer = new org.antlr.grammar.v2.ANTLRLexer(new StringReader(templateActionText));
-		lexer.setFilename(grammar.getFileName());
-		lexer.setTokenObjectClass("antlr.TokenWithIndex");
-		TokenStreamRewriteEngine tokenBuffer = new ANTLRTokenStream(lexer);
-		tokenBuffer.discard(ANTLRParser.WS);
-		tokenBuffer.discard(ANTLRParser.ML_COMMENT);
-		tokenBuffer.discard(ANTLRParser.COMMENT);
-		tokenBuffer.discard(ANTLRParser.SL_COMMENT);
-		ANTLRParser parser = new ANTLRParser(tokenBuffer);
-		parser.setFilename(grammar.getFileName());
-		parser.setASTNodeClass("org.antlr.tool.GrammarAST");
+		ANTLRLexer lexer = new ANTLRLexer(new ANTLRStringStream(templateActionText));
+		lexer.setFileName(grammar.getFileName());
+		ANTLRParser parser = ANTLRParser.createParser(new CommonTokenStream(lexer));
+		parser.setFileName(grammar.getFileName());
+		ANTLRParser.rewrite_template_return parseResult = null;
try {
-			parser.rewrite_template();
+			parseResult = parser.rewrite_template();
}
catch (RecognitionException re) {
ErrorManager.grammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,
@@ -1069,16 +1066,16 @@ public class CodeGenerator {
catch (Exception tse) {
ErrorManager.internalError("can't parse template action",tse);
}
-		GrammarAST rewriteTree = (GrammarAST)parser.getAST();
+		GrammarAST rewriteTree = (GrammarAST)parseResult.getTree();

// then translate via codegen.g
-		CodeGenTreeWalker gen = new CodeGenTreeWalker();
+		CodeGenTreeWalker gen = new CodeGenTreeWalker(new CommonTreeNodeStream(rewriteTree));
gen.init(grammar);
gen.setCurrentRuleName(ruleName);
gen.setOuterAltNum(outerAltNum);
StringTemplate st = null;
try {
-			st = gen.rewrite_template((AST)rewriteTree);
+			st = gen.rewrite_template();
}
catch (RecognitionException re) {
ErrorManager.error(ErrorManager.MSG_BAD_AST_STRUCTURE,
@@ -1091,7 +1088,7 @@ public class CodeGenerator {
public void issueInvalidScopeError(String x,
String y,
Rule enclosingRule,
-									   antlr.Token actionToken,
+									   Token actionToken,
int outerAltNum)
{
//System.out.println("error $"+x+"::"+y);
@@ -1120,7 +1117,7 @@ public class CodeGenerator {
public void issueInvalidAttributeError(String x,
String y,
Rule enclosingRule,
-										   antlr.Token actionToken,
+										   Token actionToken,
int outerAltNum)
{
//System.out.println("error $"+x+"."+y);
@@ -1172,7 +1169,7 @@ public class CodeGenerator {

public void issueInvalidAttributeError(String x,
Rule enclosingRule,
-										   antlr.Token actionToken,
+										   Token actionToken,
int outerAltNum)
{
//System.out.println("error $"+x);
diff --git a/tool/src/main/java/org/antlr/codegen/Target.java b/tool/src/main/java/org/antlr/codegen/Target.java
index 92f3dcc..9687bec 100644
--- a/tool/src/main/java/org/antlr/codegen/Target.java
+++ b/tool/src/main/java/org/antlr/codegen/Target.java
@@ -29,6 +29,7 @@ package org.antlr.codegen;

import org.antlr.Tool;
import org.antlr.analysis.Label;
+import org.antlr.runtime.Token;
import org.antlr.stringtemplate.StringTemplate;
import org.antlr.tool.Grammar;

@@ -352,7 +353,7 @@ public class Target {
/** Give target a chance to do some postprocessing on actions.
*  Python for example will have to fix the indention.
*/
-	public List postProcessAction(List chunks, antlr.Token actionToken) {
+	public List postProcessAction(List chunks, Token actionToken) {
return chunks;
}

diff --git a/tool/src/main/java/org/antlr/tool/ANTLRTokenStream.java b/tool/src/main/java/org/antlr/tool/ANTLRTokenStream.java
deleted file mode 100644
index d8110c0..0000000
--- a/tool/src/main/java/org/antlr/tool/ANTLRTokenStream.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.antlr.tool;
-
-import antlr.TokenStream;
-import antlr.TokenStreamRewriteEngine;
-import org.antlr.grammar.v2.ANTLRParser;
-
-/** A rewrite stream that flips BLOCK back to '(' when we want original string. */
-public class ANTLRTokenStream extends TokenStreamRewriteEngine {
-	public ANTLRTokenStream(TokenStream upstream) {
-		super(upstream);
-	}
-
-	@Override
-	public String toOriginalString(int start, int end) {
-		StringBuffer buf = new StringBuffer();
-		for (int i=start; i>=MIN_TOKEN_INDEX && i<=end && i<tokens.size(); i++) {
-			String s = getToken(i).getText();
-			if ( getToken(i).getType()== ANTLRParser.BLOCK ) s = "(";
-			buf.append(s);
-		}
-		return buf.toString();
-	}
-}
diff --git a/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java b/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
index aa9f23a..4a88981 100644
--- a/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
+++ b/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
@@ -28,8 +28,9 @@
package org.antlr.tool;

import org.antlr.analysis.Label;
-import org.antlr.grammar.v2.AssignTokenTypesWalker;
+import org.antlr.grammar.v3.AssignTokenTypesWalker;
import org.antlr.misc.Utils;
+import org.antlr.runtime.tree.TreeNodeStream;

import java.util.*;

@@ -48,6 +49,10 @@ public class AssignTokenTypesBehavior extends AssignTokenTypesWalker {
*/
protected Set<String> tokenRuleDefs = new HashSet();

+	public AssignTokenTypesBehavior() {
+		super(null);
+	}
+
@Override
protected void init(Grammar g) {
this.grammar = g;
@@ -146,7 +151,7 @@ public class AssignTokenTypesBehavior extends AssignTokenTypesWalker {
*/
if ( grammar.type==Grammar.COMBINED || grammar.type==Grammar.LEXER ) {
// only call this rule an alias if combined or lexer
-					alias(t, (GrammarAST)block.getFirstChild().getFirstChild());
+					alias(t, (GrammarAST)block.getChild(0).getChild(0));
}
}
}
diff --git a/tool/src/main/java/org/antlr/tool/AttributeScope.java b/tool/src/main/java/org/antlr/tool/AttributeScope.java
index aef1634..c2641da 100644
--- a/tool/src/main/java/org/antlr/tool/AttributeScope.java
+++ b/tool/src/main/java/org/antlr/tool/AttributeScope.java
@@ -28,8 +28,8 @@

package org.antlr.tool;

-import antlr.Token;
import org.antlr.codegen.CodeGenerator;
+import org.antlr.runtime.Token;

import java.util.*;

@@ -138,6 +138,23 @@ public class AttributeScope {
attributes.put(name, new Attribute(name,decl));
}

+	/** Given @scope::name {action} define it for this attribute scope. Later,
+	 *  the code generator will ask for the actions table.
+	 */
+	public final void defineNamedAction(GrammarAST nameAST, GrammarAST actionAST)
+	{
+		String actionName = nameAST.getText();
+		GrammarAST a = actions.get(actionName);
+		if (a != null) {
+			ErrorManager.grammarError(ErrorManager.MSG_ACTION_REDEFINITION,
+									  grammar,
+									  nameAST.getToken(),
+									  nameAST.getText());
+		} else {
+			actions.put(actionName, actionAST);
+		}
+	}
+
public Attribute getAttribute(String name) {
return (Attribute)attributes.get(name);
}
diff --git a/tool/src/main/java/org/antlr/tool/CompositeGrammar.java b/tool/src/main/java/org/antlr/tool/CompositeGrammar.java
index a9d3712..b9ef82f 100644
--- a/tool/src/main/java/org/antlr/tool/CompositeGrammar.java
+++ b/tool/src/main/java/org/antlr/tool/CompositeGrammar.java
@@ -26,12 +26,13 @@
*  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/package org.antlr.tool;

-import antlr.RecognitionException;
import org.antlr.analysis.Label;
import org.antlr.analysis.NFAState;
-import org.antlr.grammar.v2.ANTLRParser;
-import org.antlr.grammar.v2.AssignTokenTypesWalker;
+import org.antlr.grammar.v3.ANTLRParser;
+import org.antlr.grammar.v3.AssignTokenTypesWalker;
import org.antlr.misc.Utils;
+import org.antlr.runtime.RecognitionException;
+import org.antlr.runtime.tree.CommonTreeNodeStream;

import java.util.*;

@@ -323,17 +324,17 @@ public class CompositeGrammar {
return (NFAState)numberToStateList.get(s);
}

-	public void assignTokenTypes() throws antlr.RecognitionException {
+	public void assignTokenTypes() throws RecognitionException {
// ASSIGN TOKEN TYPES for all delegates (same walker)
//System.out.println("### assign types");
AssignTokenTypesWalker ttypesWalker = new AssignTokenTypesBehavior();
-		ttypesWalker.setASTNodeClass("org.antlr.tool.GrammarAST");
List<Grammar> grammars = delegateGrammarTreeRoot.getPostOrderedGrammarList();
for (int i = 0; grammars!=null && i < grammars.size(); i++) {
Grammar g = (Grammar)grammars.get(i);
+			ttypesWalker.setTreeNodeStream(new CommonTreeNodeStream(g.getGrammarTree()));
try {
//System.out.println("    walking "+g.name);
-				ttypesWalker.grammar(g.getGrammarTree(), g);
+				ttypesWalker.grammar_(g);
}
catch (RecognitionException re) {
ErrorManager.error(ErrorManager.MSG_BAD_AST_STRUCTURE,
@@ -351,7 +352,7 @@ public class CompositeGrammar {
Grammar g = grammars.get(i);
if ( !(g.type==Grammar.PARSER || g.type==Grammar.COMBINED) ) continue;
for (GrammarAST r : g.grammarTree.findAllType(ANTLRParser.RULE)) {
-				if ( !Character.isUpperCase(r.getFirstChild().getText().charAt(0)) ) {
+				if ( !Character.isUpperCase(r.getChild(0).getText().charAt(0)) ) {
if ( LeftRecursiveRuleAnalyzer.hasImmediateRecursiveRuleRefs(r, r.enclosingRuleName) ) {
g.translateLeftRecursiveRule(r);
}
diff --git a/tool/src/main/java/org/antlr/tool/DOTGenerator.java b/tool/src/main/java/org/antlr/tool/DOTGenerator.java
index 2b93a1f..14462a7 100644
--- a/tool/src/main/java/org/antlr/tool/DOTGenerator.java
+++ b/tool/src/main/java/org/antlr/tool/DOTGenerator.java
@@ -29,7 +29,7 @@ package org.antlr.tool;

import org.antlr.Tool;
import org.antlr.analysis.*;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.misc.Utils;
import org.antlr.stringtemplate.StringTemplate;
import org.antlr.stringtemplate.StringTemplateGroup;
diff --git a/tool/src/main/java/org/antlr/tool/ErrorManager.java b/tool/src/main/java/org/antlr/tool/ErrorManager.java
index e68e0de..5999b64 100644
--- a/tool/src/main/java/org/antlr/tool/ErrorManager.java
+++ b/tool/src/main/java/org/antlr/tool/ErrorManager.java
@@ -27,11 +27,12 @@
*/
package org.antlr.tool;

-import antlr.Token;
import org.antlr.Tool;
import org.antlr.analysis.DFAState;
import org.antlr.analysis.DecisionProbe;
import org.antlr.misc.BitSet;
+import org.antlr.runtime.RecognitionException;
+import org.antlr.runtime.Token;
import org.antlr.stringtemplate.StringTemplate;
import org.antlr.stringtemplate.StringTemplateErrorListener;
import org.antlr.stringtemplate.StringTemplateGroup;
@@ -797,7 +798,7 @@ public class ErrorManager {
Grammar grammar,
Token token,
Object arg,
-								   antlr.RecognitionException re)
+								   RecognitionException re)
{
getErrorState().errors++;
getErrorState().errorMsgIDs.add(msgID);
diff --git a/tool/src/main/java/org/antlr/tool/Grammar.java b/tool/src/main/java/org/antlr/tool/Grammar.java
index d715c16..9af0145 100644
--- a/tool/src/main/java/org/antlr/tool/Grammar.java
+++ b/tool/src/main/java/org/antlr/tool/Grammar.java
@@ -27,18 +27,16 @@
*/
package org.antlr.tool;

-import antlr.*;
-import antlr.collections.AST;
import org.antlr.Tool;
import org.antlr.analysis.*;
+import org.antlr.analysis.DFA;
import org.antlr.codegen.CodeGenerator;
import org.antlr.codegen.*;
-import org.antlr.grammar.v2.ANTLRLexer;
-import org.antlr.grammar.v2.ANTLRParser;
-import org.antlr.grammar.v2.*;
-import org.antlr.grammar.v3.ActionAnalysis;
+import org.antlr.grammar.v3.*;
import org.antlr.misc.*;
import org.antlr.misc.Utils;
+import org.antlr.runtime.*;
+import org.antlr.runtime.tree.CommonTreeNodeStream;
import org.antlr.stringtemplate.StringTemplate;
import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;

@@ -148,7 +146,7 @@ public class Grammar {
*  including whitespace tokens etc...  I use this to extract
*  lexer rules from combined grammars.
*/
-	public TokenStreamRewriteEngine tokenBuffer;
+	public CommonTokenStream tokenBuffer;
public static final String IGNORE_STRING_IN_GRAMMAR_FILE_NAME = "__";
public static final String AUTO_GENERATED_TOKEN_NAME_PREFIX = "T__";

@@ -161,7 +159,7 @@ public class Grammar {
}

public class LabelElementPair {
-		public antlr.Token label;
+		public Token label;
public GrammarAST elementRef;
public String referencedRuleName;
/** Has an action referenced the label?  Set by ActionAnalysis.g
@@ -169,7 +167,7 @@ public class Grammar {
*/
public boolean actionReferencesLabel;
public int type; // in {RULE_LABEL,TOKEN_LABEL,RULE_LIST_LABEL,TOKEN_LIST_LABEL}
-		public LabelElementPair(antlr.Token label, GrammarAST elementRef) {
+		public LabelElementPair(Token label, GrammarAST elementRef) {
this.label = label;
this.elementRef = elementRef;
this.referencedRuleName = elementRef.getText();
@@ -331,7 +329,7 @@ public class Grammar {
protected Set<GrammarAST> scopedRuleRefs = new HashSet();

/** The unique set of all token ID references in any rule */
-	protected Set<antlr.Token> tokenIDRefs = new HashSet<antlr.Token>();
+	protected Set<Token> tokenIDRefs = new HashSet<Token>();

/** Be able to assign a number to every decision in grammar;
*  decisions in 1..n
@@ -538,7 +536,7 @@ public class Grammar {

/** Used for testing; only useful on noncomposite grammars.*/
public Grammar(String grammarString)
-			throws antlr.RecognitionException, antlr.TokenStreamException
+			throws RecognitionException
{
this(null, grammarString);
}
@@ -547,14 +545,17 @@ public class Grammar {
*  noncomposite grammars.
*/
public Grammar(Tool tool, String grammarString)
-		throws antlr.RecognitionException
+		throws RecognitionException
{
this(tool);
setFileName("<string>");
StringReader r = new StringReader(grammarString);
parseAndBuildAST(r);
composite.assignTokenTypes();
-		defineGrammarSymbols();
+		//composite.translateLeftRecursiveRules();
+		addRulesForSyntacticPredicates();
+		composite.defineGrammarSymbols();
+		//composite.createNFAs();
checkNameSpaceAndActions();
}

@@ -621,24 +622,21 @@ public class Grammar {

public void parseAndBuildAST(Reader r) {
// BUILD AST FROM GRAMMAR
-		ANTLRLexer lexer = new ANTLRLexer(r);
-		lexer.setFilename(this.getFileName());
-		// use the rewrite engine because we want to buffer up all tokens
-		// in case they have a merged lexer/parser, send lexer rules to
-		// new grammar.
-		lexer.setTokenObjectClass("antlr.TokenWithIndex");
-		tokenBuffer = new ANTLRTokenStream(lexer);
-		tokenBuffer.discard(ANTLRParser.WS);
-		tokenBuffer.discard(ANTLRParser.ML_COMMENT);
-		tokenBuffer.discard(ANTLRParser.COMMENT);
-		tokenBuffer.discard(ANTLRParser.SL_COMMENT);
-		ANTLRParser parser = new ANTLRParser(tokenBuffer);
-		parser.setFilename(this.getFileName());
+		ANTLRLexer lexer;
try {
-			parser.grammar(this);
+			lexer = new ANTLRLexer(new ANTLRReaderStream(r));
+		} catch (IOException e) {
+			ErrorManager.internalError("unexpected stream error from parsing "+fileName, e);
+			return;
}
-		catch (TokenStreamException tse) {
-			ErrorManager.internalError("unexpected stream error from parsing "+fileName, tse);
+
+		lexer.setFileName(this.getFileName());
+		tokenBuffer = new CommonTokenStream(lexer);
+		ANTLRParser parser = ANTLRParser.createParser(tokenBuffer);
+		parser.setFileName(this.getFileName());
+		ANTLRParser.grammar__return result = null;
+		try {
+			result = parser.grammar_(this);
}
catch (RecognitionException re) {
ErrorManager.internalError("unexpected parser recognition error from "+fileName, re);
@@ -659,13 +657,13 @@ public class Grammar {
}
}

-		grammarTree = (GrammarAST)parser.getAST();
+		setGrammarTree((GrammarAST)result.getTree());

//if ( grammarTree!=null ) System.out.println("grammar tree: "+grammarTree.toStringTree());

grammarTree.setUnknownTokenBoundaries();

-		setFileName(lexer.getFilename()); // the lexer #src might change name
+		setFileName(lexer.getFileName()); // the lexer #src might change name
if ( grammarTree==null || grammarTree.findFirstType(ANTLRParser.RULE)==null ) {
ErrorManager.error(ErrorManager.MSG_NO_RULES, getFileName());
return;
@@ -708,13 +706,13 @@ public class Grammar {

public void translateLeftRecursiveRule(GrammarAST ruleAST) {
//System.out.println(ruleAST.toStringTree());
+		CommonTreeNodeStream input = new CommonTreeNodeStream(ruleAST);
LeftRecursiveRuleAnalyzer leftRecursiveRuleWalker =
-			new LeftRecursiveRuleAnalyzer(this, ruleAST.enclosingRuleName);
-		leftRecursiveRuleWalker.setASTNodeClass("org.antlr.tool.GrammarAST");
+			new LeftRecursiveRuleAnalyzer(input, this, ruleAST.enclosingRuleName);
boolean isLeftRec = false;
try {
//System.out.println("TESTING "+ruleAST.enclosingRuleName);
-			isLeftRec = leftRecursiveRuleWalker.rec_rule(ruleAST, this);
+			isLeftRec = leftRecursiveRuleWalker.rec_rule(this);
}
catch (RecognitionException re) {
ErrorManager.error(ErrorManager.MSG_BAD_AST_STRUCTURE, re);
@@ -740,10 +738,9 @@ public class Grammar {

// DEFINE RULES
//System.out.println("### define "+name+" rules");
-		DefineGrammarItemsWalker defineItemsWalker = new DefineGrammarItemsWalker();
-		defineItemsWalker.setASTNodeClass("org.antlr.tool.GrammarAST");
+		DefineGrammarItemsWalker defineItemsWalker = new DefineGrammarItemsWalker(new CommonTreeNodeStream(getGrammarTree()));
try {
-			defineItemsWalker.grammar(grammarTree, this);
+			defineItemsWalker.grammar_(this);
}
catch (RecognitionException re) {
ErrorManager.error(ErrorManager.MSG_BAD_AST_STRUCTURE,
@@ -903,35 +900,33 @@ public class Grammar {
}

public GrammarAST parseArtificialRule(String ruleText) {
-		ANTLRLexer lexer = new ANTLRLexer(new StringReader(ruleText));
-		lexer.setTokenObjectClass("antlr.TokenWithIndex");
-		TokenStreamRewriteEngine tokbuf = new ANTLRTokenStream(lexer);
-		tokbuf.discard(ANTLRParser.WS);
-		tokbuf.discard(ANTLRParser.ML_COMMENT);
-		tokbuf.discard(ANTLRParser.COMMENT);
-		tokbuf.discard(ANTLRParser.SL_COMMENT);
-		ANTLRParser parser = new ANTLRParser(tokbuf);
+		ANTLRLexer lexer = new ANTLRLexer(new ANTLRStringStream(ruleText));
+		ANTLRParser parser = ANTLRParser.createParser(new CommonTokenStream(lexer));
parser.setGrammar(this);
-		parser.setGtype(this.type);
-		parser.setASTNodeClass("org.antlr.tool.GrammarAST");
-		try { parser.rule(); }
+		parser.setGrammarType(this.type);
+		try {
+			ANTLRParser.rule_return result = parser.rule();
+			return (GrammarAST)result.getTree();
+		}
catch (Exception e) {
ErrorManager.error(ErrorManager.MSG_ERROR_CREATING_ARTIFICIAL_RULE,
e);
+			return null;
}
-		return (GrammarAST)parser.getAST();
}

-
public void addRule(GrammarAST grammarTree, GrammarAST t) {
-		GrammarAST p = (GrammarAST)grammarTree.getFirstChild();
-		while ( p!=null &&
-				p.getType()!=ANTLRParser.RULE &&
-			    p.getType()!=ANTLRParser.PREC_RULE )
-		{
-			p = (GrammarAST)p.getNextSibling();
+		GrammarAST p = null;
+		for (int i = 0; i < grammarTree.getChildCount(); i++ ) {
+			p = (GrammarAST)grammarTree.getChild(i);
+			if (p == null || p.getType() == ANTLRParser.RULE || p.getType() == ANTLRParser.PREC_RULE) {
+				break;
+			}
+		}
+
+		if (p != null) {
+			grammarTree.addChild(t);
}
-		if ( p!=null ) grammarTree.addChild(t);
}

/** for any syntactic predicates, we need to define rules for them; they will get
@@ -1025,9 +1020,10 @@ public class Grammar {
return;
}

-		TreeToNFAConverter nfaBuilder = new TreeToNFAConverter(this, nfa, factory);
+		CommonTreeNodeStream input = new CommonTreeNodeStream(getGrammarTree());
+		TreeToNFAConverter nfaBuilder = new TreeToNFAConverter(input, this, nfa, factory);
try {
-			nfaBuilder.grammar(grammarTree);
+			nfaBuilder.grammar_();
}
catch (RecognitionException re) {
ErrorManager.error(ErrorManager.MSG_BAD_AST_STRUCTURE,
@@ -1262,7 +1258,7 @@ outer:
private void updateLineColumnToLookaheadDFAMap(DFA lookaheadDFA) {
GrammarAST decisionAST = nfa.grammar.getDecisionBlockAST(lookaheadDFA.decisionNumber);
int line = decisionAST.getLine();
-		int col = decisionAST.getColumn();
+		int col = decisionAST.getCharPositionInLine();
lineColumnToLookaheadDFAMap.put(new StringBuffer().append(line + ":")
.append(col).toString(), lookaheadDFA);
}
@@ -1432,7 +1428,7 @@ outer:
/** Define a new rule.  A new rule index is created by incrementing
*  ruleIndex.
*/
-	public void defineRule(antlr.Token ruleToken,
+	public void defineRule(Token ruleToken,
String modifier,
Map options,
GrammarAST tree,
@@ -1587,7 +1583,7 @@ outer:
return null;
}

-	public void defineLexerRuleFoundInParser(antlr.Token ruleToken,
+	public void defineLexerRuleFoundInParser(Token ruleToken,
GrammarAST ruleAST)
{
//		System.out.println("rule tree is:\n"+ruleAST.toStringTree());
@@ -1602,11 +1598,11 @@ outer:
buf.append("\" ");
buf.append(ruleAST.getLine());
buf.append("\n");
-		for (int i=ruleAST.startIndex;
-			 i<=ruleAST.stopIndex && i<tokenBuffer.size();
+		for (int i=ruleAST.getTokenStartIndex();
+			 i<=ruleAST.getTokenStopIndex() && i<tokenBuffer.size();
i++)
{
-			TokenWithIndex t = (TokenWithIndex)tokenBuffer.getToken(i);
+			CommonToken t = (CommonToken)tokenBuffer.get(i);
// undo the text deletions done by the lexer (ugh)
if ( t.getType()==ANTLRParser.BLOCK ) {
buf.append("(");
@@ -1779,7 +1775,7 @@ outer:
/** Define a label defined in a rule r; check the validity then ask the
*  Rule object to actually define it.
*/
-	protected void defineLabel(Rule r, antlr.Token label, GrammarAST element, int type) {
+	protected void defineLabel(Rule r, Token label, GrammarAST element, int type) {
boolean err = nameSpaceChecker.checkForLabelTypeMismatch(r, label, type);
if ( err ) {
return;
@@ -1788,7 +1784,7 @@ outer:
}

public void defineTokenRefLabel(String ruleName,
-									antlr.Token label,
+									Token label,
GrammarAST tokenRef)
{
Rule r = getLocallyDefinedRule(ruleName);
@@ -1809,7 +1805,7 @@ outer:
}

public void defineWildcardTreeLabel(String ruleName,
-                                           antlr.Token label,
+                                           Token label,
GrammarAST tokenRef)
{
Rule r = getLocallyDefinedRule(ruleName);
@@ -1819,7 +1815,7 @@ outer:
}

public void defineWildcardTreeListLabel(String ruleName,
-                                           antlr.Token label,
+                                           Token label,
GrammarAST tokenRef)
{
Rule r = getLocallyDefinedRule(ruleName);
@@ -1829,7 +1825,7 @@ outer:
}

public void defineRuleRefLabel(String ruleName,
-								   antlr.Token label,
+								   Token label,
GrammarAST ruleRef)
{
Rule r = getLocallyDefinedRule(ruleName);
@@ -1839,7 +1835,7 @@ outer:
}

public void defineTokenListLabel(String ruleName,
-									 antlr.Token label,
+									 Token label,
GrammarAST element)
{
Rule r = getLocallyDefinedRule(ruleName);
@@ -1849,7 +1845,7 @@ outer:
}

public void defineRuleListLabel(String ruleName,
-									antlr.Token label,
+									Token label,
GrammarAST element)
{
Rule r = getLocallyDefinedRule(ruleName);
@@ -1995,7 +1991,7 @@ outer:
return; // no error here; see NameSpaceChecker
}
r.trackRuleReferenceInAlt(refAST, outerAltNum);
-		antlr.Token refToken = refAST.getToken();
+		Token refToken = refAST.getToken();
if ( !ruleRefs.contains(refAST) ) {
ruleRefs.add(refAST);
}
@@ -2272,6 +2268,7 @@ outer:
addDelegateGrammar(delegateGrammar);

delegateGrammar.parseAndBuildAST(br);
+			delegateGrammar.addRulesForSyntacticPredicates();
if ( !validImport(delegateGrammar) ) {
ErrorManager.grammarError(ErrorManager.MSG_INVALID_IMPORT,
this,
@@ -2499,7 +2496,7 @@ outer:
/** Save the option key/value pair and process it; return the key
*  or null if invalid option.
*/
-	public String setOption(String key, Object value, antlr.Token optionsStartToken) {
+	public String setOption(String key, Object value, Token optionsStartToken) {
if ( legalOption(key) ) {
ErrorManager.grammarError(ErrorManager.MSG_ILLEGAL_OPTION,
this,
@@ -2533,7 +2530,7 @@ outer:
}
}

-	public void setOptions(Map options, antlr.Token optionsStartToken) {
+	public void setOptions(Map options, Token optionsStartToken) {
if ( options==null ) {
this.options = null;
return;
@@ -3021,7 +3018,8 @@ outer:
boolean valid = true;
try {
//System.out.println("parse BLOCK as set tree: "+t.toStringTree());
-			nfabuilder.testBlockAsSet(t);
+			int alts = nfabuilder.testBlockAsSet(t);
+			valid = alts > 1;
}
catch (RecognitionException re) {
// The rule did not parse as a set, return null; ignore exception
@@ -3138,6 +3136,10 @@ outer:
return grammarTree;
}

+	public void setGrammarTree(GrammarAST value) {
+		grammarTree = value;
+	}
+
public Tool getTool() {
return tool;
}
@@ -3155,8 +3157,8 @@ outer:
}

public String toString() {
-		return "FFFFFFFFFFFFFF";
-	//	return grammarTreeToString(grammarTree);
+	//	return "FFFFFFFFFFFFFF";
+		return grammarTreeToString(grammarTree);
}

public String grammarTreeToString(GrammarAST t) {
@@ -3166,8 +3168,8 @@ outer:
public String grammarTreeToString(GrammarAST t, boolean showActions) {
String s = null;
try {
-			s = t.getLine()+":"+t.getColumn()+": ";
-			s += new ANTLRTreePrinter().toString((AST)t, this, showActions);
+			s = t.getLine()+":"+(t.getCharPositionInLine()+1)+": ";
+			s += new ANTLRTreePrinter(new CommonTreeNodeStream(t)).toString(this, showActions);
}
catch (Exception e) {
s = "<invalid or missing tree structure>";
@@ -3176,10 +3178,9 @@ outer:
}

public void printGrammar(PrintStream output) {
-		ANTLRTreePrinter printer = new ANTLRTreePrinter();
-		printer.setASTNodeClass("org.antlr.tool.GrammarAST");
+		ANTLRTreePrinter printer = new ANTLRTreePrinter(new CommonTreeNodeStream(getGrammarTree()));
try {
-			String g = printer.toString(grammarTree, this, false);
+			String g = printer.toString(this, false);
output.println(g);
}
catch (RecognitionException re) {
diff --git a/tool/src/main/java/org/antlr/tool/GrammarAST.java b/tool/src/main/java/org/antlr/tool/GrammarAST.java
index 97b3e78..258f40a 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarAST.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarAST.java
@@ -27,16 +27,19 @@
*/
package org.antlr.tool;

-import antlr.BaseAST;
-import antlr.Token;
-import antlr.TokenWithIndex;
-import antlr.collections.AST;
import org.antlr.analysis.DFA;
import org.antlr.analysis.NFAState;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.misc.IntSet;
import org.antlr.misc.Interval;
+import org.antlr.runtime.CommonToken;
+import org.antlr.runtime.Token;
+import org.antlr.runtime.TokenSource;
+import org.antlr.runtime.tree.CommonTree;
+import org.antlr.runtime.tree.Tree;
+import org.antlr.runtime.tree.TreeAdaptor;
import org.antlr.stringtemplate.StringTemplate;
+import org.omg.PortableInterceptor.ORBInitInfoPackage.DuplicateName;

import java.util.*;

@@ -54,20 +57,12 @@ import java.util.*;
*  have all sorts of extra work to do.  Ick.  Anyway, I'm doing all this
*  on purpose, not out of ignorance. ;)
*/
-public class GrammarAST extends BaseAST {
+public class GrammarAST extends CommonTree {
static int count = 0;

public int ID = ++count;

-	/** This AST node was created from what token? */
-    public TokenWithIndex token = null;
-
-	public String textOverride;
-
-	/** What token indexes bracket all tokens associated with this node
-	 *  and below?
-	 */
-	public int startIndex=-1, stopIndex=-1;
+	private String textOverride;

public String enclosingRuleName;

@@ -153,12 +148,16 @@ public class GrammarAST extends BaseAST {
initialize(t,txt);
}

+	public GrammarAST(Token token) {
+		initialize(token);
+	}
+
public void initialize(int i, String s) {
-        token = new TokenWithIndex(i,s);
-		token.setIndex(-1);
+        token = new CommonToken(i,s);
+		token.setTokenIndex(-1);
}

-    public void initialize(AST ast) {
+    public void initialize(Tree ast) {
GrammarAST t = ((GrammarAST)ast);
this.startIndex = t.startIndex;
this.stopIndex = t.stopIndex;
@@ -170,9 +169,9 @@ public class GrammarAST extends BaseAST {
}

public void initialize(Token token) {
-        this.token = (TokenWithIndex)token;
+        this.token = token;
if ( token!=null ) {
-			startIndex = ((TokenWithIndex) token).getIndex();
+			startIndex = token.getTokenIndex();
stopIndex = startIndex;
}
}
@@ -185,10 +184,6 @@ public class GrammarAST extends BaseAST {
this.lookaheadDFA = lookaheadDFA;
}

-	public Token getToken() {
-		return token;
-	}
-
public NFAState getNFAStartState() {
return NFAStartState;
}
@@ -251,16 +246,16 @@ public class GrammarAST extends BaseAST {
this.blockOptions = null;
return;
}
-		Set keys = options.keySet();
-		for (Iterator it = keys.iterator(); it.hasNext();) {
-			String optionName = (String) it.next();
+		String[] keys = (String[])options.keySet().toArray(new String[options.size()]);
+		for (String optionName : keys) {
String stored= setBlockOption(grammar, optionName, options.get(optionName));
if ( stored==null ) {
-				it.remove();
+				options.remove(optionName);
}
}
}

+    @Override
public String getText() {
if ( textOverride!=null ) return textOverride;
if ( token!=null ) {
@@ -277,6 +272,7 @@ public class GrammarAST extends BaseAST {
textOverride = text; // don't alt tokens as others might see
}

+    @Override
public int getType() {
if ( token!=null ) {
return token.getType();
@@ -284,13 +280,14 @@ public class GrammarAST extends BaseAST {
return -1;
}

+    @Override
public int getLine() {
int line=0;
if ( token!=null ) {
line = token.getLine();
}
if ( line==0 ) {
-			AST child = getFirstChild();
+			Tree child = getChild(0);
if ( child!=null ) {
line = child.getLine();
}
@@ -298,28 +295,27 @@ public class GrammarAST extends BaseAST {
return line;
}

-    public int getColumn() {
+    @Override
+    public int getCharPositionInLine(){
int col=0;
if ( token!=null ) {
-            col = token.getColumn();
+            col = token.getCharPositionInLine();
}
if ( col==0 ) {
-			AST child = getFirstChild();
+			Tree child = getChild(0);
if ( child!=null ) {
-				col = child.getColumn();
+				col = child.getCharPositionInLine();
}
}
return col;
}

-	public int getCharPositionInLine() { return getColumn()-1; }
-
public void setLine(int line) {
token.setLine(line);
}

-    public void setColumn(int col) {
-        token.setColumn(col);
+    public void setCharPositionInLine(int value){
+        token.setCharPositionInLine(value);
}

public IntSet getSetValue() {
@@ -331,73 +327,73 @@ public class GrammarAST extends BaseAST {
}

public GrammarAST getLastChild() {
-        return ((GrammarAST)getFirstChild()).getLastSibling();
+        if (getChildCount() == 0)
+            return null;
+        return (GrammarAST)getChild(getChildCount() - 1);
+    }
+
+    public GrammarAST getNextSibling() {
+        return (GrammarAST)getParent().getChild(getChildIndex() + 1);
}

public GrammarAST getLastSibling() {
-        GrammarAST t = this;
-        GrammarAST last = null;
-        while ( t!=null ) {
-            last = t;
-            t = (GrammarAST)t.getNextSibling();
+        Tree parent = getParent();
+        if ( parent==null ) {
+            return null;
}
-        return last;
+        return (GrammarAST)parent.getChild(parent.getChildCount() - 1);
}

-    /** Get the ith child from 0 */
-	public GrammarAST getChild(int i) {
-		int n = 0;
-		AST t = getFirstChild();
-		while ( t!=null ) {
-			if ( n==i ) {
-				return (GrammarAST)t;
-			}
-			n++;
-			t = (GrammarAST)t.getNextSibling();
-		}
-		return null;
-	}
-
-	public GrammarAST getFirstChildWithType(int ttype) {
-		AST t = getFirstChild();
-		while ( t!=null ) {
-			if ( t.getType()==ttype ) {
-				return (GrammarAST)t;
-			}
-			t = (GrammarAST)t.getNextSibling();
-		}
-		return null;
-	}

public GrammarAST[] getChildrenAsArray() {
-        AST t = getFirstChild();
-        GrammarAST[] array = new GrammarAST[getNumberOfChildren()];
-        int i = 0;
-        while ( t!=null ) {
-            array[i] = (GrammarAST)t;
-            t = t.getNextSibling();
-            i++;
+        return (GrammarAST[])getChildren().toArray(new GrammarAST[getChildCount()]);
+    }
+
+    private static final GrammarAST DescendantDownNode = new GrammarAST(Token.DOWN, "DOWN");
+    private static final GrammarAST DescendantUpNode = new GrammarAST(Token.UP, "UP");
+
+    public static List<Tree> descendants(Tree root){
+        return descendants(root, false);
+    }
+
+    public static List<Tree> descendants(Tree root, boolean insertDownUpNodes){
+        List<Tree> result = new ArrayList<Tree>();
+        int count = root.getChildCount();
+
+        if (insertDownUpNodes){
+            result.add(root);
+            result.add(DescendantDownNode);
+
+            for (int i = 0 ; i < count ; i++){
+                Tree child = root.getChild(i);
+                for (Tree subchild : descendants(child, true))
+                    result.add(subchild);
+            }
+
+            result.add(DescendantUpNode);
+        }else{
+            result.add(root);
+            for (int i = 0 ; i < count ; i++){
+                Tree child = root.getChild(i);
+                for (Tree subchild : descendants(child, false))
+                    result.add(subchild);
+            }
}
-        return array;
+
+        return result;
}

-	/** Return a reference to the first node (depth-first) that has
-	 *  token type ttype.  Assume 'this' is a root node; don't visit siblings
-	 *  of root.  Return null if no node found with ttype.
-	 */
public GrammarAST findFirstType(int ttype) {
// check this node (the root) first
if ( this.getType()==ttype ) {
return this;
}
// else check children
-		GrammarAST child = (GrammarAST)this.getFirstChild();
-		while ( child!=null ) {
-			GrammarAST result = child.findFirstType(ttype);
-			if ( result!=null ) {
-				return result;
+		Iterable<Tree> descendants = descendants(this);
+		for (Tree child : descendants) {
+			if ( child.getType()==ttype ) {
+				return (GrammarAST)child;
}
-			child = (GrammarAST)child.getNextSibling();
}
return null;
}
@@ -412,89 +408,56 @@ public class GrammarAST extends BaseAST {
// check this node (the root) first
if ( this.getType()==ttype ) nodes.add(this);
// check children
-		GrammarAST child = (GrammarAST)this.getFirstChild();
-		while ( child!=null ) {
+		for (int i = 0; i < getChildCount(); i++){
+			GrammarAST child = (GrammarAST)getChild(i);
child._findAllType(ttype, nodes);
-			child = (GrammarAST)child.getNextSibling();
}
}

-    public int getNumberOfChildrenWithType(int ttype) {
-        AST p = this.getFirstChild();
-        int n = 0;
-        while ( p!=null ) {
-            if ( p.getType()==ttype ) n++;
-            p = p.getNextSibling();
-        }
-        return n;
-    }
-
/** Make nodes unique based upon Token so we can add them to a Set; if
*  not a GrammarAST, check type.
*/
+	@Override
public boolean equals(Object ast) {
if ( this == ast ) {
return true;
}
if ( !(ast instanceof GrammarAST) ) {
-			return this.getType() == ((AST)ast).getType();
+			return this.getType() == ((Tree)ast).getType();
}
GrammarAST t = (GrammarAST)ast;
return token.getLine() == t.getLine() &&
-			   token.getColumn() == t.getColumn();
+			   token.getCharPositionInLine() == t.getCharPositionInLine();
}

+    /** Make nodes unique based upon Token so we can add them to a Set; if
+	 *  not a GrammarAST, check type.
+	 */
+    @Override
+    public int hashCode(){
+        if (token == null)
+            return 0;
+
+        return token.hashCode();
+    }
+
/** See if tree has exact token types and structure; no text */
-	public boolean hasSameTreeStructure(AST t) {
+	public boolean hasSameTreeStructure(Tree other) {
// check roots first.
-		if (this.getType() != t.getType()) return false;
+		if (this.getType() != other.getType()) return false;
// if roots match, do full list match test on children.
-		if (this.getFirstChild() != null) {
-			if (!(((GrammarAST)this.getFirstChild()).hasSameListStructure(t.getFirstChild()))) return false;
-		}
-		// sibling has no kids, make sure t doesn't either
-		else if (t.getFirstChild() != null) {
-			return false;
-		}
-		return true;
-	}
-
-	public boolean hasSameListStructure(AST t) {
-		AST sibling;
-
-		// the empty tree is not a match of any non-null tree.
-		if (t == null) {
-			return false;
-		}
-
-		// Otherwise, start walking sibling lists.  First mismatch, return false.
-		for (sibling = this;
-			 sibling != null && t != null;
-			 sibling = sibling.getNextSibling(), t = t.getNextSibling())
-		{
-			// as a quick optimization, check roots first.
-			if (sibling.getType()!=t.getType()) {
+		Iterator<Tree> thisDescendants = descendants(this, true).iterator();
+		Iterator<Tree> otherDescendants = descendants(other, true).iterator();
+		while (thisDescendants.hasNext()) {
+			if (!otherDescendants.hasNext())
return false;
-			}
-			// if roots match, do full list match test on children.
-			if (sibling.getFirstChild() != null) {
-				if (!((GrammarAST)sibling.getFirstChild()).hasSameListStructure(t.getFirstChild())) {
-					return false;
-				}
-			}
-			// sibling has no kids, make sure t doesn't either
-			else if (t.getFirstChild() != null) {
+			if (thisDescendants.next().getType() != otherDescendants.next().getType())
return false;
-			}
-		}
-		if (sibling == null && t == null) {
-			return true;
}
-		// one sibling list has more than the other
-		return false;
+		return !otherDescendants.hasNext();
}

-	public static GrammarAST dup(AST t) {
+	public static GrammarAST dup(Tree t) {
if ( t==null ) {
return null;
}
@@ -503,25 +466,29 @@ public class GrammarAST extends BaseAST {
return dup_t;
}

-	/** Duplicate tree including siblings of root. */
-	public static GrammarAST dupListNoActions(GrammarAST t, GrammarAST parent) {
-		GrammarAST result = dupTreeNoActions(t, parent);            // if t == null, then result==null
-		GrammarAST nt = result;
-		while (t != null) {						// for each sibling of the root
-			t = (GrammarAST)t.getNextSibling();
-			if ( t!=null && t.getType()==ANTLRParser.ACTION ) {
-				continue;
-			}
-			GrammarAST d = dupTreeNoActions(t, parent);
-			if ( d!=null ) {
-				if ( nt!=null ) {
-					nt.setNextSibling(d);	// dup each subtree, building new tree
-				}
-				nt = d;
-			}
-		}
-		return result;
-	}
+    @Override
+    public Tree dupNode(){
+        return dup(this);
+    }
+
+    private static List<GrammarAST> getChildrenForDupTree(GrammarAST t) {
+        List<GrammarAST> result = new ArrayList<GrammarAST>();
+        for (int i = 0; i < t.getChildCount(); i++){
+            GrammarAST child = (GrammarAST)t.getChild(i);
+            int ttype = child.getType();
+            if (ttype == ANTLRParser.REWRITE)
+                continue;
+
+            if (ttype == ANTLRParser.BANG || ttype == ANTLRParser.ROOT) {
+                for (GrammarAST subchild : getChildrenForDupTree(child))
+                    result.add(subchild);
+            } else {
+                result.add(child);
+            }
+        }
+
+        return result;
+    }

/**Duplicate a tree, assuming this is a root node of a tree--
* duplicate that node and what's below; ignore siblings of root node.
@@ -530,25 +497,9 @@ public class GrammarAST extends BaseAST {
if ( t==null ) {
return null;
}
-		int ttype = t.getType();
-		if ( ttype==ANTLRParser.REWRITE ) {
-			return null;
-		}
-		if ( ttype==ANTLRParser.BANG || ttype==ANTLRParser.ROOT ) {
-			// return x from ^(ROOT x)
-			return (GrammarAST)dupListNoActions((GrammarAST)t.getFirstChild(), t);
-		}
-        /* DOH!  Must allow labels for sem preds
-        if ( (ttype==ANTLRParser.ASSIGN||ttype==ANTLRParser.PLUS_ASSIGN) &&
-			 (parent==null||parent.getType()!=ANTLRParser.OPTIONS) )
-		{
-			return dupTreeNoActions(t.getChild(1), t); // return x from ^(ASSIGN label x)
-		}
-		*/
-		GrammarAST result = dup(t);		// make copy of root
-		// copy all children of root.
-		GrammarAST kids = dupListNoActions((GrammarAST)t.getFirstChild(), t);
-		result.setFirstChild(kids);
+		GrammarAST result = (GrammarAST)t.dupNode();
+		for (GrammarAST subchild : getChildrenForDupTree(t))
+			result.addChild(dupTreeNoActions(subchild, result));
return result;
}

@@ -558,80 +509,50 @@ public class GrammarAST extends BaseAST {
}
GrammarAST root = dup(t);		// make copy of root
// copy all children of root.
-		t = (GrammarAST)t.getFirstChild();
-		while (t != null) {						// for each sibling of the root
-			GrammarAST d = dupTree(t);
-			root.addChild(d);
-			t = (GrammarAST)t.getNextSibling();
+		for (int i= 0; i < t.getChildCount(); i++) {
+			GrammarAST child = (GrammarAST)t.getChild(i);
+			root.addChild(dupTree(child));
}
return root;
}

public void setTreeEnclosingRuleNameDeeply(String rname) {
-		GrammarAST t = this;
-		t.enclosingRuleName = rname;
-		t = t.getChild(0);
-		while (t != null) {						// for each sibling of the root
-			t.setTreeEnclosingRuleNameDeeply(rname);
-			t = (GrammarAST)t.getNextSibling();
+		enclosingRuleName = rname;
+		if (getChildCount() == 0) return;
+		for (Object child : getChildren()) {
+			if (!(child instanceof GrammarAST)) {
+				continue;
+			}
+			GrammarAST grammarAST = (GrammarAST)child;
+			grammarAST.setTreeEnclosingRuleNameDeeply(rname);
}
}

+	String toStringList() {
+		return "";
+	}
+
/** Track start/stop token for subtree root created for a rule.
*  Only works with Tree nodes.  For rules that match nothing,
*  seems like this will yield start=i and stop=i-1 in a nil node.
*  Might be useful info so I'll not force to be i..i.
*/
public void setTokenBoundaries(Token startToken, Token stopToken) {
-		if ( startToken!=null ) startIndex = ((TokenWithIndex)startToken).getIndex();
-		if ( stopToken!=null ) stopIndex = ((TokenWithIndex)stopToken).getIndex();
-	}
-
-	/** For every node in this subtree, make sure it's start/stop token's
-	 *  are set.  Walk depth first, visit bottom up.  Only updates nodes
-	 *  with at least one token index < 0.
-	 */
-	public Interval setUnknownTokenBoundaries() {
-//		System.out.println(getText()+": START");
-		if ( getNumberOfChildren()==0 ) {
-			if ( startIndex<0 || stopIndex<0 ) {
-				startIndex = stopIndex = token.getIndex();
-				//System.out.println(getText()+": STOP "+startIndex);
-			}
-			return new Interval(startIndex, stopIndex);
-		}
-		GrammarAST t = (GrammarAST)this.getFirstChild();
-		int min = token.getIndex()>=0 ? token.getIndex() : Integer.MAX_VALUE;
-		int max = -1;
-		while (t != null) {
-			Interval I = t.setUnknownTokenBoundaries();
-			if ( I.a!=-1 ) min = Math.min(min, I.a);
-			max = Math.max(max, I.b);
-			t = (GrammarAST)t.getNextSibling();
-		}
-		if ( startIndex<0 || min < startIndex ) startIndex = min;
-		if ( stopIndex<0 || max > stopIndex ) stopIndex = max;
-		//System.out.println(getText()+": STOP "+startIndex+".."+stopIndex);
-		return new Interval(startIndex, stopIndex);
+		if ( startToken!=null ) startIndex = startToken.getTokenIndex();
+		if ( stopToken!=null ) stopIndex = stopToken.getTokenIndex();
}

public GrammarAST getBlockALT(int i) {
if ( this.getType()!=ANTLRParser.BLOCK ) return null;
-		GrammarAST t = (GrammarAST)getFirstChild();
-		int j = 0;
-		while ( t!=null ) {
-			if ( t.getType()==ANTLRParser.ALT ) {
-				j++;
-				if ( j==i ) return t;
+		int alts = 0;
+		for (int j =0 ; j < getChildCount(); j++) {
+			if (getChild(j).getType() == ANTLRParser.ALT) {
+				alts++;
+			}
+			if (alts == i) {
+				return (GrammarAST)getChild(j);
}
-			t = (GrammarAST)t.getNextSibling();
}
return null;
}
-
-//	@Override
-//	public String toString() {
-//		if ( startIndex==-1 && stopIndex==-1 ) return getText();
-//		return getText()+":"+startIndex+".."+stopIndex;
-//	}
}
diff --git a/tool/src/main/java/org/antlr/tool/GrammarAnalysisAbortedMessage.java b/tool/src/main/java/org/antlr/tool/GrammarAnalysisAbortedMessage.java
index afe4ab3..a099568 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarAnalysisAbortedMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarAnalysisAbortedMessage.java
@@ -44,7 +44,7 @@ public class GrammarAnalysisAbortedMessage extends Message {
public String toString() {
GrammarAST decisionASTNode = probe.dfa.getDecisionASTNode();
line = decisionASTNode.getLine();
-		column = decisionASTNode.getColumn();
+		column = decisionASTNode.getCharPositionInLine();
String fileName = probe.dfa.nfa.grammar.getFileName();
if ( fileName!=null ) {
file = fileName;
diff --git a/tool/src/main/java/org/antlr/tool/GrammarDanglingStateMessage.java b/tool/src/main/java/org/antlr/tool/GrammarDanglingStateMessage.java
index b5a4abc..19f50da 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarDanglingStateMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarDanglingStateMessage.java
@@ -53,7 +53,7 @@ public class GrammarDanglingStateMessage extends Message {
public String toString() {
GrammarAST decisionASTNode = probe.dfa.getDecisionASTNode();
line = decisionASTNode.getLine();
-		column = decisionASTNode.getColumn();
+		column = decisionASTNode.getCharPositionInLine();
String fileName = probe.dfa.nfa.grammar.getFileName();
if ( fileName!=null ) {
file = fileName;
diff --git a/tool/src/main/java/org/antlr/tool/GrammarInsufficientPredicatesMessage.java b/tool/src/main/java/org/antlr/tool/GrammarInsufficientPredicatesMessage.java
index ccaf21a..494851d 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarInsufficientPredicatesMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarInsufficientPredicatesMessage.java
@@ -27,10 +27,10 @@
*/
package org.antlr.tool;

-import antlr.Token;
import org.antlr.analysis.DFAState;
import org.antlr.analysis.DecisionProbe;
import org.antlr.analysis.Label;
+import org.antlr.runtime.Token;
import org.antlr.stringtemplate.StringTemplate;

import java.util.*;
@@ -53,7 +53,7 @@ public class GrammarInsufficientPredicatesMessage extends Message {
public String toString() {
GrammarAST decisionASTNode = probe.dfa.getDecisionASTNode();
line = decisionASTNode.getLine();
-		column = decisionASTNode.getColumn();
+		column = decisionASTNode.getCharPositionInLine();
String fileName = probe.dfa.nfa.grammar.getFileName();
if ( fileName!=null ) {
file = fileName;
diff --git a/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java b/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
index 135b067..2922fd9 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
@@ -58,7 +58,7 @@ public class GrammarNonDeterminismMessage extends Message {
public String toString() {
GrammarAST decisionASTNode = probe.dfa.getDecisionASTNode();
line = decisionASTNode.getLine();
-		column = decisionASTNode.getColumn();
+		column = decisionASTNode.getCharPositionInLine();
String fileName = probe.dfa.nfa.grammar.getFileName();
if ( fileName!=null ) {
file = fileName;
@@ -80,7 +80,7 @@ public class GrammarNonDeterminismMessage extends Message {
NFAState ruleStart =
probe.dfa.nfa.grammar.getRuleStartState(tokenName);
line = ruleStart.associatedASTNode.getLine();
-				column = ruleStart.associatedASTNode.getColumn();
+				column = ruleStart.associatedASTNode.getCharPositionInLine();
st.setAttribute("disabled", tokenName);
}
}
diff --git a/tool/src/main/java/org/antlr/tool/GrammarReport.java b/tool/src/main/java/org/antlr/tool/GrammarReport.java
index b8dfcbf..e0462a3 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarReport.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarReport.java
@@ -28,7 +28,7 @@
package org.antlr.tool;

import org.antlr.analysis.DFA;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.misc.Utils;
import org.antlr.runtime.misc.Stats;

@@ -307,7 +307,7 @@ public class GrammarReport {
dfa.decisionNFAStartState.associatedASTNode;
buf.append(decisionAST.getLine());
buf.append(":");
-			buf.append(decisionAST.getColumn());
+			buf.append(decisionAST.getCharPositionInLine());
buf.append(newline);
}
return buf.toString();
diff --git a/tool/src/main/java/org/antlr/tool/GrammarReport2.java b/tool/src/main/java/org/antlr/tool/GrammarReport2.java
index b6111db..bc57891 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarReport2.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarReport2.java
@@ -70,7 +70,7 @@ public class GrammarReport2 {
d.dfa.decisionNFAStartState.associatedASTNode;
buf.append(decisionAST.getLine());
buf.append(":");
-			buf.append(decisionAST.getColumn());
+			buf.append(decisionAST.getCharPositionInLine());
buf.append(" decision "+decision+":");

if ( d.dfa.isCyclic() ) buf.append(" cyclic");
diff --git a/tool/src/main/java/org/antlr/tool/GrammarSanity.java b/tool/src/main/java/org/antlr/tool/GrammarSanity.java
index abf4d02..bcfabfb 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSanity.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSanity.java
@@ -30,7 +30,8 @@ package org.antlr.tool;
import org.antlr.analysis.NFAState;
import org.antlr.analysis.RuleClosureTransition;
import org.antlr.analysis.Transition;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
+import org.antlr.runtime.tree.Tree;

import java.util.ArrayList;
import java.util.HashSet;
@@ -298,7 +299,7 @@ public class GrammarSanity {
new Integer(outerAltNum));
}

-	protected boolean isValidSimpleElementNode(GrammarAST t) {
+	protected boolean isValidSimpleElementNode(Tree t) {
switch ( t.getType() ) {
case ANTLRParser.TREE_BEGIN :
case ANTLRParser.TOKEN_REF :
diff --git a/tool/src/main/java/org/antlr/tool/GrammarSemanticsMessage.java b/tool/src/main/java/org/antlr/tool/GrammarSemanticsMessage.java
index 8674f25..a5b79fe 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSemanticsMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSemanticsMessage.java
@@ -27,7 +27,7 @@
*/
package org.antlr.tool;

-import antlr.Token;
+import org.antlr.runtime.Token;
import org.antlr.stringtemplate.StringTemplate;

/** A problem with the symbols and/or meaning of a grammar such as rule
@@ -71,7 +71,7 @@ public class GrammarSemanticsMessage extends Message {
column = 0;
if ( offendingToken!=null ) {
line = offendingToken.getLine();
-			column = offendingToken.getColumn();
+			column = offendingToken.getCharPositionInLine();
}
if ( g!=null ) {
file = g.getFileName();
diff --git a/tool/src/main/java/org/antlr/tool/GrammarSyntaxMessage.java b/tool/src/main/java/org/antlr/tool/GrammarSyntaxMessage.java
index ef06115..45730d1 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSyntaxMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSyntaxMessage.java
@@ -27,7 +27,8 @@
*/
package org.antlr.tool;

-import antlr.Token;
+import org.antlr.runtime.RecognitionException;
+import org.antlr.runtime.Token;
import org.antlr.stringtemplate.StringTemplate;

/** A problem with the syntax of your antlr grammar such as
@@ -37,12 +38,12 @@ public class GrammarSyntaxMessage extends Message {
public Grammar g;
/** Most of the time, we'll have a token and so this will be set. */
public Token offendingToken;
-	public antlr.RecognitionException exception;
+	public RecognitionException exception;

public GrammarSyntaxMessage(int msgID,
Grammar grammar,
Token offendingToken,
-								antlr.RecognitionException exception)
+								RecognitionException exception)
{
this(msgID,grammar,offendingToken,null,exception);
}
@@ -51,7 +52,7 @@ public class GrammarSyntaxMessage extends Message {
Grammar grammar,
Token offendingToken,
Object arg,
-								antlr.RecognitionException exception)
+								RecognitionException exception)
{
super(msgID, arg, null);
this.offendingToken = offendingToken;
@@ -64,7 +65,7 @@ public class GrammarSyntaxMessage extends Message {
column = 0;
if ( offendingToken!=null ) {
line = offendingToken.getLine();
-			column = offendingToken.getColumn();
+			column = offendingToken.getCharPositionInLine();
}
// TODO: actually set the right Grammar instance to get the filename
// TODO: have to update all v2 grammar files for this. or use errormanager and tool to get the current grammar
diff --git a/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java b/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
index 2a7ec3b..d13d773 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
@@ -55,7 +55,7 @@ public class GrammarUnreachableAltsMessage extends Message {
public String toString() {
GrammarAST decisionASTNode = probe.dfa.getDecisionASTNode();
line = decisionASTNode.getLine();
-		column = decisionASTNode.getColumn();
+		column = decisionASTNode.getCharPositionInLine();
String fileName = probe.dfa.nfa.grammar.getFileName();
if ( fileName!=null ) {
file = fileName;
@@ -73,7 +73,7 @@ public class GrammarUnreachableAltsMessage extends Message {
NFAState ruleStart =
probe.dfa.nfa.grammar.getRuleStartState(tokenName);
line = ruleStart.associatedASTNode.getLine();
-				column = ruleStart.associatedASTNode.getColumn();
+				column = ruleStart.associatedASTNode.getCharPositionInLine();
st.setAttribute("tokens", tokenName);
}
}
diff --git a/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java b/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
index 032cbdf..b01743e 100644
--- a/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
+++ b/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
@@ -1,8 +1,10 @@
package org.antlr.tool;

-import antlr.Token;
import org.antlr.codegen.CodeGenerator;
-import org.antlr.grammar.v2.*;
+import org.antlr.grammar.v3.*;
+import org.antlr.runtime.Token;
+import org.antlr.runtime.tree.CommonTreeNodeStream;
+import org.antlr.runtime.tree.TreeNodeStream;
import org.antlr.stringtemplate.*;
import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;

@@ -29,7 +31,8 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {

public Map<Integer, ASSOC> altAssociativity = new HashMap<Integer, ASSOC>();

-	public LeftRecursiveRuleAnalyzer(Grammar g, String ruleName) {
+	public LeftRecursiveRuleAnalyzer(TreeNodeStream input, Grammar g, String ruleName) {
+		super(input);
this.g = g;
this.ruleName = ruleName;
language = (String)g.getOption("language");
@@ -278,32 +281,32 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {
}

public void stripSynPred(GrammarAST altAST) {
-		GrammarAST t = (GrammarAST)altAST.getFirstChild();
+		GrammarAST t = (GrammarAST)altAST.getChild(0);
if ( t.getType()==ANTLRParser.BACKTRACK_SEMPRED ||
t.getType()==ANTLRParser.SYNPRED ||
t.getType()==ANTLRParser.SYN_SEMPRED )
{
-			altAST.setFirstChild(t.getNextSibling()); // kill it
+			altAST.deleteChild(0); // kill it
}
}

public void stripLeftRecursion(GrammarAST altAST) {
-		GrammarAST rref = (GrammarAST)altAST.getFirstChild();
+		GrammarAST rref = (GrammarAST)altAST.getChild(0);
if ( rref.getType()== ANTLRParser.RULE_REF &&
rref.getText().equals(ruleName))
{
// remove rule ref
-			altAST.setFirstChild(rref.getNextSibling());
+			altAST.deleteChild(0);
// reset index so it prints properly
-			GrammarAST newFirstChild = (GrammarAST) altAST.getFirstChild();
-			altAST.startIndex = newFirstChild.startIndex;
+			GrammarAST newFirstChild = (GrammarAST) altAST.getChild(0);
+			altAST.setTokenStartIndex(newFirstChild.getTokenStartIndex());
}
}

public String text(GrammarAST t) {
if ( t==null ) return null;
try {
-			return new ANTLRTreePrinter().toString(t, grammar, true);
+			return new ANTLRTreePrinter(new CommonTreeNodeStream(t)).toString(grammar, true);
}
catch (Exception e) {
ErrorManager.error(ErrorManager.MSG_BAD_AST_STRUCTURE, e);
diff --git a/tool/src/main/java/org/antlr/tool/Message.java b/tool/src/main/java/org/antlr/tool/Message.java
index 8cd5e2e..5792360 100644
--- a/tool/src/main/java/org/antlr/tool/Message.java
+++ b/tool/src/main/java/org/antlr/tool/Message.java
@@ -106,7 +106,7 @@ public abstract class Message {
locationValid = true;
}
if (column != -1) {
-			locationST.setAttribute("column", column);
+			locationST.setAttribute("column", column+1);
locationValid = true;
}
if (file != null) {
diff --git a/tool/src/main/java/org/antlr/tool/NFAFactory.java b/tool/src/main/java/org/antlr/tool/NFAFactory.java
index b3c108c..de52287 100644
--- a/tool/src/main/java/org/antlr/tool/NFAFactory.java
+++ b/tool/src/main/java/org/antlr/tool/NFAFactory.java
@@ -32,6 +32,7 @@ import org.antlr.misc.IntSet;
import org.antlr.misc.IntervalSet;

import java.util.ArrayList;
+import java.util.Collection;
import java.util.Iterator;
import java.util.List;

@@ -290,7 +291,7 @@ public class NFAFactory {
*  not invoked by another rule (they can only be invoked from outside).
*  These are the start rules.
*/
-    public int build_EOFStates(List rules) {
+    public int build_EOFStates(Collection rules) {
int numberUnInvokedRules = 0;
for (Iterator iterator = rules.iterator(); iterator.hasNext();) {
Rule r = (Rule) iterator.next();
diff --git a/tool/src/main/java/org/antlr/tool/NameSpaceChecker.java b/tool/src/main/java/org/antlr/tool/NameSpaceChecker.java
index f0d2ad7..6c6dbb5 100644
--- a/tool/src/main/java/org/antlr/tool/NameSpaceChecker.java
+++ b/tool/src/main/java/org/antlr/tool/NameSpaceChecker.java
@@ -27,8 +27,8 @@
*/
package org.antlr.tool;

-import antlr.Token;
import org.antlr.analysis.Label;
+import org.antlr.runtime.Token;

import java.util.Iterator;
import java.util.List;
@@ -95,7 +95,7 @@ public class NameSpaceChecker {

protected void checkForRuleDefinitionProblems(Rule r) {
String ruleName = r.name;
-		antlr.Token ruleToken = r.tree.getToken();
+		Token ruleToken = r.tree.getToken();
int msgID = 0;
if ( (grammar.type==Grammar.PARSER||grammar.type==Grammar.TREE_PARSER) &&
Character.isUpperCase(ruleName.charAt(0)) )
@@ -162,7 +162,7 @@ public class NameSpaceChecker {
for (Iterator it = grammar.scopedRuleRefs.iterator(); it.hasNext();) {
GrammarAST scopeAST = (GrammarAST)it.next(); // ^(DOT ID atom)
Grammar scopeG = grammar.composite.getGrammar(scopeAST.getText());
-			GrammarAST refAST = scopeAST.getChild(1);
+			GrammarAST refAST = (GrammarAST)scopeAST.getChild(1);
String ruleName = refAST.getText();
if ( scopeG==null ) {
ErrorManager.grammarError(ErrorManager.MSG_NO_SUCH_GRAMMAR_SCOPE,
@@ -218,7 +218,7 @@ public class NameSpaceChecker {
*  return values, parameters, and rule-scope dynamic attributes
*  defined in surrounding rule.
*/
-	protected void checkForLabelConflict(Rule r, antlr.Token label) {
+	protected void checkForLabelConflict(Rule r, Token label) {
int msgID = 0;
Object arg2 = null;
if ( grammar.getGlobalScope(label.getText())!=null ) {
@@ -247,7 +247,7 @@ public class NameSpaceChecker {

/** If type of previous label differs from new label's type, that's an error.
*/
-	public boolean checkForLabelTypeMismatch(Rule r, antlr.Token label, int type) {
+	public boolean checkForLabelTypeMismatch(Rule r, Token label, int type) {
Grammar.LabelElementPair prevLabelPair =
(Grammar.LabelElementPair)r.labelNameSpace.get(label.getText());
if ( prevLabelPair!=null ) {
diff --git a/tool/src/main/java/org/antlr/tool/NonRegularDecisionMessage.java b/tool/src/main/java/org/antlr/tool/NonRegularDecisionMessage.java
index cdb58ec..1afc50a 100644
--- a/tool/src/main/java/org/antlr/tool/NonRegularDecisionMessage.java
+++ b/tool/src/main/java/org/antlr/tool/NonRegularDecisionMessage.java
@@ -49,7 +49,7 @@ public class NonRegularDecisionMessage extends Message {
public String toString() {
GrammarAST decisionASTNode = probe.dfa.getDecisionASTNode();
line = decisionASTNode.getLine();
-		column = decisionASTNode.getColumn();
+		column = decisionASTNode.getCharPositionInLine();
String fileName = probe.dfa.nfa.grammar.getFileName();
if ( fileName!=null ) {
file = fileName;
diff --git a/tool/src/main/java/org/antlr/tool/RecursionOverflowMessage.java b/tool/src/main/java/org/antlr/tool/RecursionOverflowMessage.java
index 02ffb7f..1f0718e 100644
--- a/tool/src/main/java/org/antlr/tool/RecursionOverflowMessage.java
+++ b/tool/src/main/java/org/antlr/tool/RecursionOverflowMessage.java
@@ -61,7 +61,7 @@ public class RecursionOverflowMessage extends Message {
public String toString() {
GrammarAST decisionASTNode = probe.dfa.getDecisionASTNode();
line = decisionASTNode.getLine();
-		column = decisionASTNode.getColumn();
+		column = decisionASTNode.getCharPositionInLine();
String fileName = probe.dfa.nfa.grammar.getFileName();
if ( fileName!=null ) {
file = fileName;
diff --git a/tool/src/main/java/org/antlr/tool/Rule.java b/tool/src/main/java/org/antlr/tool/Rule.java
index 09ecf9b..4a1bfed 100644
--- a/tool/src/main/java/org/antlr/tool/Rule.java
+++ b/tool/src/main/java/org/antlr/tool/Rule.java
@@ -27,10 +27,11 @@
*/
package org.antlr.tool;

-import antlr.CommonToken;
import org.antlr.analysis.NFAState;
import org.antlr.codegen.CodeGenerator;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
+import org.antlr.runtime.CommonToken;
+import org.antlr.runtime.Token;

import java.util.*;

@@ -75,6 +76,9 @@ public class Rule {
/** A list of scope names (String) used by this rule */
public List useScopes;

+    /** Exceptions that this rule can throw */
+    public Set<String> throwsSpec;
+
/** A list of all LabelElementPair attached to tokens like id=ID */
public LinkedHashMap tokenLabels;

@@ -162,6 +166,7 @@ public class Rule {
this.index = ruleIndex;
this.numberOfAlts = numberOfAlts;
this.grammar = grammar;
+		throwsSpec = new HashSet<String>();
altToTokenRefMap = new Map[numberOfAlts+1];
altToRuleRefMap = new Map[numberOfAlts+1];
for (int alt=1; alt<=numberOfAlts; alt++) {
@@ -170,7 +175,13 @@ public class Rule {
}
}

-	public void defineLabel(antlr.Token label, GrammarAST elementRef, int type) {
+	public static int getRuleType(String ruleName){
+		if (ruleName == null || ruleName.length() == 0)
+			throw new IllegalArgumentException("The specified rule name is not valid.");
+		return Character.isUpperCase(ruleName.charAt(0)) ? Grammar.LEXER : Grammar.PARSER;
+	}
+
+	public void defineLabel(Token label, GrammarAST elementRef, int type) {
Grammar.LabelElementPair pair = grammar.new LabelElementPair(label,elementRef);
pair.type = type;
labelNameSpace.put(label.getText(), pair);
@@ -512,7 +523,7 @@ public class Rule {
/** Save the option key/value pair and process it; return the key
*  or null if invalid option.
*/
-	public String setOption(String key, Object value, antlr.Token optionsStartToken) {
+	public String setOption(String key, Object value, Token optionsStartToken) {
if ( !legalOptions.contains(key) ) {
ErrorManager.grammarError(ErrorManager.MSG_ILLEGAL_OPTION,
grammar,
@@ -536,7 +547,7 @@ public class Rule {
return key;
}

-	public void setOptions(Map options, antlr.Token optionsStartToken) {
+	public void setOptions(Map options, Token optionsStartToken) {
if ( options==null ) {
this.options = null;
return;
diff --git a/tool/src/main/java/org/antlr/tool/RuleLabelScope.java b/tool/src/main/java/org/antlr/tool/RuleLabelScope.java
index c1811a8..265d245 100644
--- a/tool/src/main/java/org/antlr/tool/RuleLabelScope.java
+++ b/tool/src/main/java/org/antlr/tool/RuleLabelScope.java
@@ -27,7 +27,7 @@
*/
package org.antlr.tool;

-import antlr.Token;
+import org.antlr.runtime.Token;

public class RuleLabelScope extends AttributeScope {
/** Rules have a predefined set of attributes as well as
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
index ee49dd9..d5274bc 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
@@ -161,11 +161,11 @@ catch (IOException ioe) {
try { dbg.enterRule(getGrammarFileName(), "<ruleName>");
if ( getRuleLevel()==0 ) {dbg.commence();}
incRuleLevel();
-dbg.location(<ruleDescriptor.tree.line>, <ruleDescriptor.tree.column>);<\n>
+dbg.location(<ruleDescriptor.tree.line>, <ruleDescriptor.tree.charPositionInLine>);<\n>
>>

@rule.postamble() ::= <<
-dbg.location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.column>);<\n>
+dbg.location(<ruleDescriptor.EORNode.line>, <ruleDescriptor.EORNode.charPositionInLine>);<\n>
}
finally {
dbg.exitRule(getGrammarFileName(), "<ruleName>");
diff --git a/tool/src/test/java/org/antlr/test/BaseTest.java b/tool/src/test/java/org/antlr/test/BaseTest.java
index b9bad17..896a996 100644
--- a/tool/src/test/java/org/antlr/test/BaseTest.java
+++ b/tool/src/test/java/org/antlr/test/BaseTest.java
@@ -48,6 +48,7 @@ import java.util.*;


public abstract class BaseTest {
+	public static final String newline = System.getProperty("line.separator");

public static final String jikes = null;//"/usr/bin/jikes";
public static final String pathSep = System.getProperty("path.separator");
@@ -119,10 +120,11 @@ public abstract class BaseTest {
classpathOption = "-bootclasspath";
}

+		String inputFile = tmpdir + File.separator + fileName;
String[] args = new String[] {
compiler, "-d", tmpdir,
classpathOption, tmpdir+pathSep+CLASSPATH,
-					tmpdir+"/"+fileName
+					inputFile
};
String cmdLine = compiler+" -d "+tmpdir+" "+classpathOption+" "+tmpdir+pathSep+CLASSPATH+" "+fileName;
//System.out.println("compile: "+cmdLine);
@@ -130,8 +132,8 @@ public abstract class BaseTest {
try {
Process process =
Runtime.getRuntime().exec(args, null, outputDir);
-			StreamVacuum stdout = new StreamVacuum(process.getInputStream());
-			StreamVacuum stderr = new StreamVacuum(process.getErrorStream());
+			StreamVacuum stdout = new StreamVacuum(process.getInputStream(), inputFile);
+			StreamVacuum stderr = new StreamVacuum(process.getErrorStream(), inputFile);
stdout.start();
stderr.start();
process.waitFor();
@@ -372,16 +374,17 @@ public abstract class BaseTest {

public String execRecognizer() {
try {
+			String inputFile = new File(tmpdir, "input").getAbsolutePath();
String[] args = new String[] {
"java", "-classpath", tmpdir+pathSep+CLASSPATH,
-				"Test", new File(tmpdir, "input").getAbsolutePath()
+				"Test", inputFile
};
//String cmdLine = "java -classpath "+CLASSPATH+pathSep+tmpdir+" Test " + new File(tmpdir, "input").getAbsolutePath();
//System.out.println("execParser: "+cmdLine);
Process process =
Runtime.getRuntime().exec(args, null, new File(tmpdir));
-			StreamVacuum stdoutVacuum = new StreamVacuum(process.getInputStream());
-			StreamVacuum stderrVacuum = new StreamVacuum(process.getErrorStream());
+			StreamVacuum stdoutVacuum = new StreamVacuum(process.getInputStream(), inputFile);
+			StreamVacuum stderrVacuum = new StreamVacuum(process.getErrorStream(), inputFile);
stdoutVacuum.start();
stderrVacuum.start();
process.waitFor();
@@ -509,8 +512,10 @@ public abstract class BaseTest {
StringBuffer buf = new StringBuffer();
BufferedReader in;
Thread sucker;
-		public StreamVacuum(InputStream in) {
+		String inputFile;
+		public StreamVacuum(InputStream in, String inputFile) {
this.in = new BufferedReader( new InputStreamReader(in) );
+			this.inputFile = inputFile;
}
public void start() {
sucker = new Thread(this);
@@ -520,6 +525,8 @@ public abstract class BaseTest {
try {
String line = in.readLine();
while (line!=null) {
+					if (line.startsWith(inputFile))
+						line = line.substring(inputFile.length()+1);
buf.append(line);
buf.append('\n');
line = in.readLine();
diff --git a/tool/src/test/java/org/antlr/test/TestASTConstruction.java b/tool/src/test/java/org/antlr/test/TestASTConstruction.java
index 069f456..794b681 100644
--- a/tool/src/test/java/org/antlr/test/TestASTConstruction.java
+++ b/tool/src/test/java/org/antlr/test/TestASTConstruction.java
@@ -41,7 +41,7 @@ public class TestASTConstruction extends BaseTest {
"parser grammar P;\n"+
"a : A;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT A <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT A <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -52,7 +52,7 @@ public class TestASTConstruction extends BaseTest {
"A : B+;\n" +
"B : 'a';");
String expecting =
-			" ( rule A ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT B <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule A ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT B <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("A").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -63,7 +63,7 @@ public class TestASTConstruction extends BaseTest {
"a : (b)+;\n" +
"b : B;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT b <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -74,7 +74,7 @@ public class TestASTConstruction extends BaseTest {
"a : b+;\n" +
"b : B;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT b <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -85,7 +85,7 @@ public class TestASTConstruction extends BaseTest {
"a : (b)?;\n" +
"b : B;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( ? ( BLOCK ( ALT b <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -96,7 +96,7 @@ public class TestASTConstruction extends BaseTest {
"a : b?;\n" +
"b : B;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( ? ( BLOCK ( ALT b <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -107,7 +107,7 @@ public class TestASTConstruction extends BaseTest {
"a : (b)*;\n" +
"b : B;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT b <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -118,7 +118,7 @@ public class TestASTConstruction extends BaseTest {
"a : b*;\n" +
"b : B;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT b <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT b <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -128,7 +128,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : 'a'*;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT 'a' <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -138,7 +138,7 @@ public class TestASTConstruction extends BaseTest {
"lexer grammar P;\n"+
"B : 'b'*;");
String expecting =
-			" ( rule B ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT 'b' <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule B ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("B").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -148,7 +148,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : 'while'*;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT 'while' <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'while' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -158,7 +158,7 @@ public class TestASTConstruction extends BaseTest {
"lexer grammar P;\n"+
"B : 'while'*;");
String expecting =
-			" ( rule B ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT 'while' <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule B ARG RET scope (BLOCK (ALT (* (BLOCK (ALT 'while' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("B").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -168,7 +168,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : 'a'+;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT 'a' <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -178,7 +178,7 @@ public class TestASTConstruction extends BaseTest {
"lexer grammar P;\n"+
"B : 'b'+;");
String expecting =
-			" ( rule B ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT 'b' <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule B ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("B").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -188,7 +188,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : 'a'?;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( ? ( BLOCK ( ALT 'a' <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT 'a' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -198,7 +198,7 @@ public class TestASTConstruction extends BaseTest {
"lexer grammar P;\n"+
"B : 'b'?;");
String expecting =
-			" ( rule B ARG RET scope ( BLOCK ( ALT ( ? ( BLOCK ( ALT 'b' <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule B ARG RET scope (BLOCK (ALT (? (BLOCK (ALT 'b' <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("B").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -208,7 +208,7 @@ public class TestASTConstruction extends BaseTest {
"lexer grammar P;\n"+
"ID : 'a'..'z'+;");
String expecting =
-			" ( rule ID ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT ( .. 'a' 'z' ) <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule ID ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (.. 'a' 'z') <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("ID").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -218,7 +218,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x=ID;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( = x ID ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -228,7 +228,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x=ID?;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( ? ( BLOCK ( ALT ( = x ID ) <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (? (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -238,7 +238,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x=ID*;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT ( = x ID ) <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -249,7 +249,7 @@ public class TestASTConstruction extends BaseTest {
"a : x=b;\n" +
"b : ID;\n");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( = x b ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (= x b) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -259,7 +259,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x=(A|B);\n");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( = x ( BLOCK ( ALT A <end-of-alt> ) ( ALT B <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (= x (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -269,7 +269,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x=~(A|B);\n");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( = x ( ~ ( BLOCK ( ALT A <end-of-alt> ) ( ALT B <end-of-alt> ) <end-of-block> ) ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -279,7 +279,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x+=~(A|B);\n");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( += x ( ~ ( BLOCK ( ALT A <end-of-alt> ) ( ALT B <end-of-alt> ) <end-of-block> ) ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (+= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -289,7 +289,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x+=~(A|B)+;\n");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT ( += x ( ~ ( BLOCK ( ALT A <end-of-alt> ) ( ALT B <end-of-alt> ) <end-of-block> ) ) ) <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (+= x (~ (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) <end-of-block>))) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -300,7 +300,7 @@ public class TestASTConstruction extends BaseTest {
"a : x=b+;\n" +
"b : ID;\n");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT ( = x b ) <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (= x b) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -310,7 +310,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x+=ID*;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT ( += x ID ) <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (+= x ID) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -320,7 +320,7 @@ public class TestASTConstruction extends BaseTest {
"grammar P;\n"+
"a : x+='int'*;");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( * ( BLOCK ( ALT ( += x 'int' ) <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (* (BLOCK (ALT (+= x 'int') <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -332,7 +332,7 @@ public class TestASTConstruction extends BaseTest {
"a : x+=b+;\n" +
"b : ID;\n");
String expecting =
-			" ( rule a ARG RET scope ( BLOCK ( ALT ( + ( BLOCK ( ALT ( += x b ) <end-of-alt> ) <end-of-block> ) ) <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule a ARG RET scope (BLOCK (ALT (+ (BLOCK (ALT (+= x b) <end-of-alt>) <end-of-block>)) <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("a").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -340,10 +340,10 @@ public class TestASTConstruction extends BaseTest {
@Test public void testRootTokenInStarLoop() throws Exception {
Grammar g = new Grammar(
"grammar Expr;\n" +
-				"options { backtrack=true; }\n" +
+				"options { output=AST; backtrack=true; }\n" +
"a : ('*'^)* ;\n");  // bug: the synpred had nothing in it
String expecting =
-			" ( rule synpred1_Expr ARG RET scope ( BLOCK ( ALT '*' <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule synpred1_Expr ARG RET scope (BLOCK (ALT '*' <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("synpred1_Expr").tree.toStringTree();
assertEquals(expecting, found);
}
@@ -354,7 +354,7 @@ public class TestASTConstruction extends BaseTest {
"options { backtrack=true; }\n" +
"a : ({blort} 'x')* ;\n");  // bug: the synpred had nothing in it
String expecting =
-			" ( rule synpred1_Expr ARG RET scope ( BLOCK ( ALT blort 'x' <end-of-alt> ) <end-of-block> ) <end-of-rule> )";
+			"(rule synpred1_Expr ARG RET scope (BLOCK (ALT blort 'x' <end-of-alt>) <end-of-block>) <end-of-rule>)";
String found = g.getRule("synpred1_Expr").tree.toStringTree();
assertEquals(expecting, found);
}
diff --git a/tool/src/test/java/org/antlr/test/TestAttributes.java b/tool/src/test/java/org/antlr/test/TestAttributes.java
index eb7f08a..d4cacde 100644
--- a/tool/src/test/java/org/antlr/test/TestAttributes.java
+++ b/tool/src/test/java/org/antlr/test/TestAttributes.java
@@ -29,8 +29,9 @@ package org.antlr.test;

import org.antlr.Tool;
import org.antlr.codegen.CodeGenerator;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.grammar.v3.ActionTranslator;
+import org.antlr.runtime.CommonToken;
import org.antlr.stringtemplate.StringTemplate;
import org.antlr.stringtemplate.StringTemplateGroup;
import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
@@ -57,7 +58,7 @@ public class TestAttributes extends BaseTest {
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
String action = "i<3; '<xmltag>'";
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),0);
+																	 new CommonToken(ANTLRParser.ACTION,action),0);
String expecting = action;
String rawTranslation =
translator.translate();
@@ -85,7 +86,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),0);
+									  new CommonToken(ANTLRParser.ACTION,action),0);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -111,7 +112,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -142,7 +143,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =	translator.translate();
assertEquals(expecting, rawTranslation);

@@ -195,7 +196,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =	translator.translate();
assertEquals(expecting, rawTranslation);

@@ -231,7 +232,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =	translator.translate();
assertEquals(expecting, rawTranslation);

@@ -256,7 +257,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
assertEquals(expecting, rawTranslation);
@@ -287,7 +288,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -331,7 +332,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -378,7 +379,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -411,7 +412,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -452,7 +453,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -480,7 +481,7 @@ public class TestAttributes extends BaseTest {
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator,
"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -515,7 +516,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"b",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -546,7 +547,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"b",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -574,7 +575,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -616,7 +617,7 @@ public class TestAttributes extends BaseTest {
String expecting = expecting1;
do {
ActionTranslator translator = new ActionTranslator(generator,"rule1",
-																		 new antlr.CommonToken(ANTLRParser.ACTION,action),i+1);
+																		 new CommonToken(ANTLRParser.ACTION,action),i+1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -644,7 +645,7 @@ public class TestAttributes extends BaseTest {
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -677,7 +678,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -691,8 +692,8 @@ public class TestAttributes extends BaseTest {

@Test public void testRuleLabels() throws Exception {
String action = "$r.x; $r.start;\n $r.stop;\n $r.tree; $a.x; $a.stop;";
-		String expecting = "(r!=null?r.x:0); (r!=null?((Token)r.start):null);\n" +
-						   "             (r!=null?((Token)r.stop):null);\n" +
+		String expecting = "(r!=null?r.x:0); (r!=null?((Token)r.start):null);" + newline +
+						   "             (r!=null?((Token)r.stop):null);" + newline +
"             (r!=null?((Object)r.tree):null); (r!=null?r.x:0); (r!=null?((Token)r.stop):null);";

ErrorQueue equeue = new ErrorQueue();
@@ -803,7 +804,7 @@ public class TestAttributes extends BaseTest {
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -837,7 +838,7 @@ public class TestAttributes extends BaseTest {
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -870,7 +871,7 @@ public class TestAttributes extends BaseTest {
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -903,7 +904,7 @@ public class TestAttributes extends BaseTest {
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -930,7 +931,7 @@ public class TestAttributes extends BaseTest {
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -955,7 +956,7 @@ public class TestAttributes extends BaseTest {
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator,
null,
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),0);
+																	 new CommonToken(ANTLRParser.ACTION,action),0);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -985,7 +986,7 @@ public class TestAttributes extends BaseTest {
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator,
null,
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),0);
+																	 new CommonToken(ANTLRParser.ACTION,action),0);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1024,7 +1025,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1051,7 +1052,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);

assertEquals("unexpected errors: "+equeue, 2, equeue.errors.size());

@@ -1083,7 +1084,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1116,7 +1117,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1147,7 +1148,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1176,7 +1177,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1212,7 +1213,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1244,7 +1245,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1275,7 +1276,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
null,
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),0);
+																	 new CommonToken(ANTLRParser.ACTION,action),0);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1305,7 +1306,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1363,7 +1364,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1394,7 +1395,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1429,7 +1430,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1461,7 +1462,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1488,7 +1489,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1515,7 +1516,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1542,7 +1543,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1616,7 +1617,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-															   new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+															   new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1643,7 +1644,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-														   new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+														   new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1671,7 +1672,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1729,7 +1730,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1757,7 +1758,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1807,7 +1808,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
StringTemplate codeST = generator.getRecognizerST();
String code = codeST.toString();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
@@ -1836,7 +1837,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1848,7 +1849,7 @@ public class TestAttributes extends BaseTest {
assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
translator = new ActionTranslator(generator,
"a",
-											   new antlr.CommonToken(ANTLRParser.ACTION,action2),2);
+											   new CommonToken(ANTLRParser.ACTION,action2),2);
rawTranslation =
translator.translate();
templates =
@@ -1910,7 +1911,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1947,7 +1948,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -1984,7 +1985,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"b",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2083,7 +2084,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2112,7 +2113,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2141,7 +2142,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2168,7 +2169,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
String rawTranslation =
@@ -2199,7 +2200,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
String rawTranslation =
@@ -2303,7 +2304,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer();

ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2332,7 +2333,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer();

ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2374,7 +2375,7 @@ public class TestAttributes extends BaseTest {
"s : x+=a x+=b {System.out.println($x);} ;" +
"a : 'a';\n"+
"b : 'b';\n"+
-			"WS : (' '|'\n') {skip();};\n";
+			"WS : (' '|'\\n') {skip();};\n";
String expecting = "[a, b]\na b\n";
String found = execParser("T.g", grammar, "TParser", "TLexer",
"s", "a b", false);
@@ -2388,7 +2389,7 @@ public class TestAttributes extends BaseTest {
"s : x+=a x+=b {System.out.println($x);} ;" +
"a : 'a' -> {%{\"hi\"}} ;\n"+
"b : 'b' -> {%{\"mom\"}} ;\n"+
-			"WS : (' '|'\n') {skip();};\n";
+			"WS : (' '|'\\n') {skip();};\n";
String expecting = "[hi, mom]\n";
String found = execParser("T.g", grammar, "TParser", "TLexer",
"s", "a b", false);
@@ -2573,7 +2574,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"R",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2602,7 +2603,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"R",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2631,7 +2632,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"R",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2738,7 +2739,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"R",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2767,7 +2768,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"R",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2795,7 +2796,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"R",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2893,7 +2894,7 @@ public class TestAttributes extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-									  new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+									  new CommonToken(ANTLRParser.ACTION,action),1);
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
String rawTranslation =
@@ -2924,7 +2925,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer();

ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -2998,7 +2999,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"field",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -3026,7 +3027,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"rule",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -3054,7 +3055,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"rule",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -3081,7 +3082,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"rule",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -3109,7 +3110,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"rule",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -3151,7 +3152,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"rule",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -3180,7 +3181,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"rule",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -3239,7 +3240,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer();
ActionTranslator translator = new ActionTranslator(generator,
"RULE",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -3274,7 +3275,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer();
ActionTranslator translator = new ActionTranslator(generator,
"twoIDs",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
// check that we didn't use scopeSetAttributeRef int translation!
@@ -3331,8 +3332,8 @@ public class TestAttributes extends BaseTest {

@Test public void testRefToTextAttributeForCurrentTreeRule() throws Exception {
String action = "$text";
-		String expecting = "input.getTokenStream().toString(\n" +
-						   "              input.getTreeAdaptor().getTokenStartIndex(retval.start),\n" +
+		String expecting = "input.getTokenStream().toString(" + newline +
+						   "              input.getTreeAdaptor().getTokenStartIndex(retval.start)," + newline +
"              input.getTreeAdaptor().getTokenStopIndex(retval.start))";

ErrorQueue equeue = new ErrorQueue();
@@ -3375,7 +3376,7 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
diff --git a/tool/src/test/java/org/antlr/test/TestCompositeGrammars.java b/tool/src/test/java/org/antlr/test/TestCompositeGrammars.java
index 17bf814..c5c59f5 100644
--- a/tool/src/test/java/org/antlr/test/TestCompositeGrammars.java
+++ b/tool/src/test/java/org/antlr/test/TestCompositeGrammars.java
@@ -31,6 +31,8 @@ import org.antlr.Tool;
import org.antlr.tool.*;
import org.junit.Test;

+import java.io.File;
+
public class TestCompositeGrammars extends BaseTest {
protected boolean debug = false;

@@ -735,7 +737,7 @@ public class TestCompositeGrammars extends BaseTest {
assertEquals("unexpected warnings: "+equeue, 1, equeue.warnings.size());

String expectedError =
-			"warning(105): "+tmpdir.toString().replaceFirst("\\-[0-9]+","")+"/M.g:3:5: no lexer rule corresponding to token: ABC";
+			"warning(105): "+tmpdir.toString().replaceFirst("\\-[0-9]+","")+File.separator+"M.g:3:5: no lexer rule corresponding to token: ABC";
assertEquals(expectedError, equeue.warnings.get(0).toString().replaceFirst("\\-[0-9]+",""));
}

diff --git a/tool/src/test/java/org/antlr/test/TestDFAConversion.java b/tool/src/test/java/org/antlr/test/TestDFAConversion.java
index 7aab40c..c5d07ae 100644
--- a/tool/src/test/java/org/antlr/test/TestDFAConversion.java
+++ b/tool/src/test/java/org/antlr/test/TestDFAConversion.java
@@ -1171,7 +1171,7 @@ public class TestDFAConversion extends BaseTest {
"a : A | B | C ;"
);
String expecting = // still looks like block
-			" ( grammar t ( rule a ARG RET scope ( BLOCK ( ALT A <end-of-alt> ) ( ALT B <end-of-alt> ) ( ALT C <end-of-alt> ) <end-of-block> ) <end-of-rule> ) )";
+			"(grammar t (rule a ARG RET scope (BLOCK (ALT A <end-of-alt>) (ALT B <end-of-alt>) (ALT C <end-of-alt>) <end-of-block>) <end-of-rule>))";
assertEquals(expecting, g.getGrammarTree().toStringTree());
}

diff --git a/tool/src/test/java/org/antlr/test/TestMessages.java b/tool/src/test/java/org/antlr/test/TestMessages.java
index 5d0a80b..e135f54 100644
--- a/tool/src/test/java/org/antlr/test/TestMessages.java
+++ b/tool/src/test/java/org/antlr/test/TestMessages.java
@@ -29,8 +29,9 @@ package org.antlr.test;

import org.antlr.Tool;
import org.antlr.codegen.CodeGenerator;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.grammar.v3.ActionTranslator;
+import org.antlr.runtime.CommonToken;
import org.antlr.tool.ErrorManager;
import org.antlr.tool.Grammar;
import org.antlr.tool.GrammarSemanticsMessage;
@@ -61,7 +62,7 @@ public class TestMessages extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"rule",
-																	new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

diff --git a/tool/src/test/java/org/antlr/test/TestNFAConstruction.java b/tool/src/test/java/org/antlr/test/TestNFAConstruction.java
index 3c47da4..2ccf508 100644
--- a/tool/src/test/java/org/antlr/test/TestNFAConstruction.java
+++ b/tool/src/test/java/org/antlr/test/TestNFAConstruction.java
@@ -782,10 +782,10 @@ public class TestNFAConstruction extends BaseTest {
"A : '{' ~('}')* '}';\n");
String result = g.getLexerGrammar();
String expecting =
-			"lexer grammar t;\n" +
-			"\n" +
-			"// $ANTLR src \"<string>\" 2\n"+
-			"A : '{' ~('}')* '}';\n";
+			"lexer grammar t;" +newline +
+			"" +newline +
+			"// $ANTLR src \"<string>\" 2"+newline+
+			"A : '{' ~('}')* '}';";
assertEquals(result, expecting);
}

diff --git a/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java b/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
index 50a32df..279b9a3 100644
--- a/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
+++ b/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
@@ -27,11 +27,11 @@
*/
package org.antlr.test;

-import antlr.Token;
import org.antlr.analysis.DFA;
import org.antlr.analysis.DecisionProbe;
import org.antlr.codegen.CodeGenerator;
import org.antlr.misc.BitSet;
+import org.antlr.runtime.Token;
import org.antlr.tool.*;
import org.junit.Test;

diff --git a/tool/src/test/java/org/antlr/test/TestSymbolDefinitions.java b/tool/src/test/java/org/antlr/test/TestSymbolDefinitions.java
index 09f42b2..9d2c0ad 100644
--- a/tool/src/test/java/org/antlr/test/TestSymbolDefinitions.java
+++ b/tool/src/test/java/org/antlr/test/TestSymbolDefinitions.java
@@ -118,12 +118,12 @@ public class TestSymbolDefinitions extends BaseTest {
assertEquals(literals, foundLiterals);

String implicitLexer =
-			"lexer grammar t;\n" +
-			"\n" +
-			"T__5 : 'x' ;\n" +
-			"\n" +
-			"// $ANTLR src \"<string>\" 3\n" +
-			"E: 'x' '0' ;\n";
+			"lexer grammar t;" + newline +
+			"" + newline +
+			"T__5 : 'x' ;" + newline +
+			"" + newline +
+			"// $ANTLR src \"<string>\" 3" + newline +
+			"E: 'x' '0' ;";
assertEquals(implicitLexer, g.getLexerGrammar());
}

diff --git a/tool/src/test/java/org/antlr/test/TestSyntaxErrors.java b/tool/src/test/java/org/antlr/test/TestSyntaxErrors.java
index 0ea2b32..31ad9f2 100644
--- a/tool/src/test/java/org/antlr/test/TestSyntaxErrors.java
+++ b/tool/src/test/java/org/antlr/test/TestSyntaxErrors.java
@@ -40,8 +40,8 @@ public class TestSyntaxErrors extends BaseTest {
";\n" +
"q : 'e' ;\n";
String found = execParser("T.g", grammar, "TParser", "TLexer", "a", "ae", false);
-		String expecting = "input line 1:1 no viable alternative at input 'e'\n";
-		String result = stderrDuringParse.replaceAll(".*?/input ", "input ");
+		String expecting = "line 1:1 no viable alternative at input 'e'\n";
+		String result = stderrDuringParse;
assertEquals(expecting, result);
}

@@ -54,8 +54,8 @@ public class TestSyntaxErrors extends BaseTest {
"q : 'e' ;\n";
System.out.println(grammar);
String found = execParser("T.g", grammar, "TParser", "TLexer", "a", "abe", false);
-		String expecting = "input line 1:2 no viable alternative at input 'e'\n";
-		String result = stderrDuringParse.replaceAll(".*?/input ", "input ");
+		String expecting = "line 1:2 no viable alternative at input 'e'\n";
+		String result = stderrDuringParse;
assertEquals(expecting, result);
}

@@ -67,8 +67,8 @@ public class TestSyntaxErrors extends BaseTest {
";\n" +
"q : 'e' ;\n";
String found = execParser("T.g", grammar, "TParser", "TLexer", "a", "aaae", false);
-		String expecting = "input line 1:3 no viable alternative at input 'e'\n";
-		String result = stderrDuringParse.replaceAll(".*?/input ", "input ");
+		String expecting = "line 1:3 no viable alternative at input 'e'\n";
+		String result = stderrDuringParse;
assertEquals(expecting, result);
}

@@ -84,8 +84,8 @@ public class TestSyntaxErrors extends BaseTest {
"  ;\n";
System.out.println(grammar);
String found = execParser("T.g", grammar, "TParser", "TLexer", "a", "((i))z", false);
-		String expecting = "input line 1:0 no viable alternative at input '('\n";
-		String result = stderrDuringParse.replaceAll(".*?/input ", "input ");
+		String expecting = "line 1:0 no viable alternative at input '('\n";
+		String result = stderrDuringParse;
assertEquals(expecting, result);
}

diff --git a/tool/src/test/java/org/antlr/test/TestTemplates.java b/tool/src/test/java/org/antlr/test/TestTemplates.java
index 0ee864f..56c7435 100644
--- a/tool/src/test/java/org/antlr/test/TestTemplates.java
+++ b/tool/src/test/java/org/antlr/test/TestTemplates.java
@@ -29,8 +29,9 @@ package org.antlr.test;

import org.antlr.Tool;
import org.antlr.codegen.CodeGenerator;
-import org.antlr.grammar.v2.ANTLRParser;
+import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.grammar.v3.ActionTranslator;
+import org.antlr.runtime.CommonToken;
import org.antlr.stringtemplate.StringTemplate;
import org.antlr.stringtemplate.StringTemplateGroup;
import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
@@ -69,7 +70,7 @@ public class TestTemplates extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-										new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+										new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -106,7 +107,7 @@ public class TestTemplates extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-										new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+										new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -144,7 +145,7 @@ public class TestTemplates extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-										new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+										new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -179,7 +180,7 @@ public class TestTemplates extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -215,7 +216,7 @@ public class TestTemplates extends BaseTest {
ActionTranslator translator =
new ActionTranslator(generator,
"a",
-										new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+										new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
@@ -250,7 +251,7 @@ public class TestTemplates extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
"a",
-																	 new antlr.CommonToken(ANTLRParser.ACTION,action),1);
+																	 new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
StringTemplateGroup templates =
diff --git a/tool/src/test/java/org/antlr/test/TestTreeGrammarRewriteAST.java b/tool/src/test/java/org/antlr/test/TestTreeGrammarRewriteAST.java
index 89c3409..518e48a 100644
--- a/tool/src/test/java/org/antlr/test/TestTreeGrammarRewriteAST.java
+++ b/tool/src/test/java/org/antlr/test/TestTreeGrammarRewriteAST.java
@@ -29,6 +29,7 @@ package org.antlr.test;

import org.antlr.Tool;
import org.antlr.codegen.CodeGenerator;
+import org.antlr.runtime.RecognitionException;
import org.antlr.tool.ErrorManager;
import org.antlr.tool.Grammar;
import org.antlr.tool.GrammarSyntaxMessage;
@@ -248,7 +249,7 @@ public class TestTreeGrammarRewriteAST extends BaseTest {

int expectedMsgID = ErrorManager.MSG_WILDCARD_AS_ROOT;
Object expectedArg = null;
-        antlr.RecognitionException expectedExc = null;
+        RecognitionException expectedExc = null;
GrammarSyntaxMessage expectedMessage =
new GrammarSyntaxMessage(expectedMsgID, g, null, expectedArg, expectedExc);


