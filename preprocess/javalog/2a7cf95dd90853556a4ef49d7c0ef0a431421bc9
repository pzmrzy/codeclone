commit 2a7cf95dd90853556a4ef49d7c0ef0a431421bc9
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Mon Dec 3 11:55:12 2012 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Mon Dec 3 11:55:12 2012 -0600

Fix warnings about use of generics in gUnit

diff --git a/gunit/src/main/java/org/antlr/gunit/JUnitCodeGen.java b/gunit/src/main/java/org/antlr/gunit/JUnitCodeGen.java
index 3e5e21c..ed5282e 100644
--- a/gunit/src/main/java/org/antlr/gunit/JUnitCodeGen.java
+++ b/gunit/src/main/java/org/antlr/gunit/JUnitCodeGen.java
@@ -73,7 +73,7 @@ public class JUnitCodeGen {
this.testsuiteDir = testsuiteDir;
/** Map the name of rules having return value to its return type */
ruleWithReturn = new HashMap<String, String>();
-        Class parserClass = locateParserClass( grammarInfo, classLoader );
+        Class<?> parserClass = locateParserClass( grammarInfo, classLoader );
Method[] methods = parserClass.getDeclaredMethods();
for(Method method : methods) {
if ( !method.getReturnType().getName().equals("void") ) {
@@ -82,7 +82,7 @@ public class JUnitCodeGen {
}
}

-    private Class locateParserClass(GrammarInfo grammarInfo, ClassLoader classLoader) throws ClassNotFoundException {
+    private Class<?> locateParserClass(GrammarInfo grammarInfo, ClassLoader classLoader) throws ClassNotFoundException {
String parserClassName = grammarInfo.getGrammarName() + "Parser";
if ( grammarInfo.getGrammarPackage() != null ) {
parserClassName = grammarInfo.getGrammarPackage()+ "." + parserClassName;
diff --git a/gunit/src/main/java/org/antlr/gunit/gUnitBaseTest.java b/gunit/src/main/java/org/antlr/gunit/gUnitBaseTest.java
index d2520b7..2b3b085 100644
--- a/gunit/src/main/java/org/antlr/gunit/gUnitBaseTest.java
+++ b/gunit/src/main/java/org/antlr/gunit/gUnitBaseTest.java
@@ -70,19 +70,17 @@ public abstract class gUnitBaseTest extends TestCase {
else {
input = new ANTLRStringStream(testInput);
}
-		Class lexer = null;
+		Class<? extends Lexer> lexer;
PrintStream ps = null;		// for redirecting stdout later
PrintStream ps2 = null;		// for redirecting stderr later
try {
/** Use Reflection to create instances of lexer and parser */
-        	lexer = Class.forName(lexerPath);
-            Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
-            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
-            Lexer lexObj = (Lexer)lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
+        	lexer = Class.forName(lexerPath).asSubclass(Lexer.class);
+            Constructor<? extends Lexer> lexConstructor = lexer.getConstructor(CharStream.class);
+            Lexer lexObj = lexConstructor.newInstance(input);				// makes new instance of lexer
input.setLine(line);

-            Method ruleName = lexer.getMethod("m"+testRuleName, new Class[0]);
+            Method ruleName = lexer.getMethod("m"+testRuleName);

/** Start of I/O Redirecting */
ByteArrayOutputStream out = new ByteArrayOutputStream();
@@ -95,7 +93,7 @@ public abstract class gUnitBaseTest extends TestCase {

/** Invoke lexer rule, and get the current index in CharStream */
ruleName.invoke(lexObj, new Object[0]);
-            Method ruleName2 = lexer.getMethod("getCharIndex", new Class[0]);
+            Method ruleName2 = lexer.getMethod("getCharIndex");
int currentIndex = (Integer) ruleName2.invoke(lexObj, new Object[0]);
if ( currentIndex!=input.size() ) {
ps2.println("extra text found, '"+input.substring(currentIndex, input.size()-1)+"'");
@@ -161,33 +159,28 @@ public abstract class gUnitBaseTest extends TestCase {
else {
input = new ANTLRStringStream(testInput);
}
-		Class lexer = null;
-		Class parser = null;
+		Class<? extends Lexer> lexer;
+		Class<? extends Parser> parser;
PrintStream ps = null;		// for redirecting stdout later
PrintStream ps2 = null;		// for redirecting stderr later
ByteArrayOutputStream out = null;
ByteArrayOutputStream err = null;
try {
/** Use Reflection to create instances of lexer and parser */
-			lexer = Class.forName(lexerPath);
-            Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
-            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
-            Lexer lexObj = (Lexer)lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
+			lexer = Class.forName(lexerPath).asSubclass(Lexer.class);
+            Constructor<? extends Lexer> lexConstructor = lexer.getConstructor(CharStream.class);
+            Lexer lexObj = lexConstructor.newInstance(input);				// makes new instance of lexer
input.setLine(line);

CommonTokenStream tokens = new CommonTokenStream(lexObj);
-            parser = Class.forName(parserPath);
-            Class[] parArgTypes = new Class[]{TokenStream.class};				// assign type to parser's args
-            Constructor parConstructor = parser.getConstructor(parArgTypes);
-            Object[] parArgs = new Object[]{tokens};							// assign value to parser's args
-            Parser parObj = (Parser)parConstructor.newInstance(parArgs);				// makes new instance of parser
+            parser = Class.forName(parserPath).asSubclass(Parser.class);
+            Constructor<? extends Parser> parConstructor = parser.getConstructor(TokenStream.class);
+            Parser parObj = parConstructor.newInstance(tokens);				// makes new instance of parser

// set up customized tree adaptor if necessary
if ( treeAdaptorPath!=null ) {
-            	parArgTypes = new Class[]{TreeAdaptor.class};
-            	Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", parArgTypes);
-            	Class _treeAdaptor = Class.forName(treeAdaptorPath);
+            	Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", TreeAdaptor.class);
+            	Class<? extends TreeAdaptor> _treeAdaptor = Class.forName(treeAdaptorPath).asSubclass(TreeAdaptor.class);
_setTreeAdaptor.invoke(parObj, _treeAdaptor.newInstance());
}

@@ -210,7 +203,7 @@ public abstract class gUnitBaseTest extends TestCase {
if ( ruleReturn!=null ) {
if ( ruleReturn.getClass().toString().indexOf(testRuleName+"_return")>0 ) {
try {	// NullPointerException may happen here...
-                		Class _return = Class.forName(parserPath+"$"+testRuleName+"_return");
+                		Class<?> _return = Class.forName(parserPath+"$"+testRuleName+"_return");
Method[] methods = _return.getDeclaredMethods();
for(Method method : methods) {
if ( method.getName().equals("getTree") ) {
@@ -307,34 +300,29 @@ public abstract class gUnitBaseTest extends TestCase {
else {
input = new ANTLRStringStream(testInput);
}
-		Class lexer = null;
-		Class parser = null;
-		Class treeParser = null;
+		Class<? extends Lexer> lexer;
+		Class<? extends Parser> parser;
+		Class<? extends TreeParser> treeParser;
PrintStream ps = null;		// for redirecting stdout later
PrintStream ps2 = null;		// for redirecting stderr later
try {
/** Use Reflection to create instances of lexer and parser */
-        	lexer = Class.forName(lexerPath);
-            Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
-            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
-            Object lexObj = lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
+        	lexer = Class.forName(lexerPath).asSubclass(Lexer.class);
+            Constructor<? extends Lexer> lexConstructor = lexer.getConstructor(CharStream.class);
+            Lexer lexObj = lexConstructor.newInstance(input);				// makes new instance of lexer

-            CommonTokenStream tokens = new CommonTokenStream((Lexer) lexObj);
+            CommonTokenStream tokens = new CommonTokenStream(lexObj);

-            parser = Class.forName(parserPath);
-            Class[] parArgTypes = new Class[]{TokenStream.class};				// assign type to parser's args
-            Constructor parConstructor = parser.getConstructor(parArgTypes);
-            Object[] parArgs = new Object[]{tokens};							// assign value to parser's args
-            Object parObj = parConstructor.newInstance(parArgs);				// makes new instance of parser
+            parser = Class.forName(parserPath).asSubclass(Parser.class);
+            Constructor<? extends Parser> parConstructor = parser.getConstructor(TokenStream.class);
+            Parser parObj = parConstructor.newInstance(tokens);				// makes new instance of parser

// set up customized tree adaptor if necessary
TreeAdaptor customTreeAdaptor = null;
if ( treeAdaptorPath!=null ) {
-            	parArgTypes = new Class[]{TreeAdaptor.class};
-            	Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", parArgTypes);
-            	Class _treeAdaptor = Class.forName(treeAdaptorPath);
-            	customTreeAdaptor = (TreeAdaptor) _treeAdaptor.newInstance();
+            	Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", TreeAdaptor.class);
+            	Class<? extends TreeAdaptor> _treeAdaptor = Class.forName(treeAdaptorPath).asSubclass(TreeAdaptor.class);
+            	customTreeAdaptor = _treeAdaptor.newInstance();
_setTreeAdaptor.invoke(parObj, customTreeAdaptor);
}

@@ -352,7 +340,7 @@ public abstract class gUnitBaseTest extends TestCase {
/** Invoke grammar rule, and get the return value */
Object ruleReturn = ruleName.invoke(parObj);

-            Class _return = Class.forName(parserPath+"$"+testRuleName+"_return");
+            Class<?> _return = Class.forName(parserPath+"$"+testRuleName+"_return");
Method returnName = _return.getMethod("getTree");
CommonTree tree = (CommonTree) returnName.invoke(ruleReturn);

@@ -367,11 +355,9 @@ public abstract class gUnitBaseTest extends TestCase {
// AST nodes have payload that point into token stream
nodes.setTokenStream(tokens);
// Create a tree walker attached to the nodes stream
-        	treeParser = Class.forName(treeParserPath);
-            Class[] treeParArgTypes = new Class[]{TreeNodeStream.class};		// assign type to tree parser's args
-            Constructor treeParConstructor = treeParser.getConstructor(treeParArgTypes);
-            Object[] treeParArgs = new Object[]{nodes};							// assign value to tree parser's args
-            Object treeParObj = treeParConstructor.newInstance(treeParArgs);	// makes new instance of tree parser
+        	treeParser = Class.forName(treeParserPath).asSubclass(TreeParser.class);
+            Constructor<? extends TreeParser> treeParConstructor = treeParser.getConstructor(TreeNodeStream.class);
+            TreeParser treeParObj = treeParConstructor.newInstance(nodes);	// makes new instance of tree parser
// Invoke the tree rule, and store the return value if there is
Method treeRuleName = treeParser.getMethod(testTreeRuleName);
Object treeRuleReturn = treeRuleName.invoke(treeParObj);
@@ -382,7 +368,7 @@ public abstract class gUnitBaseTest extends TestCase {
if ( treeRuleReturn!=null ) {
if ( treeRuleReturn.getClass().toString().indexOf(testTreeRuleName+"_return")>0 ) {
try {	// NullPointerException may happen here...
-                		Class _treeReturn = Class.forName(treeParserPath+"$"+testTreeRuleName+"_return");
+                		Class<?> _treeReturn = Class.forName(treeParserPath+"$"+testTreeRuleName+"_return");
Method[] methods = _treeReturn.getDeclaredMethods();
for(Method method : methods) {
if ( method.getName().equals("getTree") ) {
diff --git a/gunit/src/main/java/org/antlr/gunit/gUnitExecutor.java b/gunit/src/main/java/org/antlr/gunit/gUnitExecutor.java
index e71b0da..ab759c8 100644
--- a/gunit/src/main/java/org/antlr/gunit/gUnitExecutor.java
+++ b/gunit/src/main/java/org/antlr/gunit/gUnitExecutor.java
@@ -48,6 +48,7 @@ import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
+import org.antlr.runtime.tree.TreeParser;

public class gUnitExecutor implements ITestSuite {
public GrammarInfo grammarInfo;
@@ -104,7 +105,7 @@ public class gUnitExecutor implements ITestSuite {
return grammarClassLoader;
}

-	protected final Class classForName(String name) throws ClassNotFoundException {
+	protected final Class<?> classForName(String name) throws ClassNotFoundException {
return getGrammarClassLoader().loadClass( name );
}

@@ -230,7 +231,7 @@ public class gUnitExecutor implements ITestSuite {
// TODO: throw proper exceptions
protected gUnitTestResult runLexer(String lexerName, String testRuleName, gUnitTestInput testInput) throws Exception {
CharStream input;
-		Class lexer = null;
+		Class<? extends Lexer> lexer;
PrintStream ps = null;		// for redirecting stdout later
PrintStream ps2 = null;		// for redirecting stderr later
try {
@@ -238,13 +239,11 @@ public class gUnitExecutor implements ITestSuite {
input = getANTLRInputStream(testInput);

/** Use Reflection to create instances of lexer and parser */
-        	lexer = classForName(lexerName);
-            Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
-            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
-            Object lexObj = lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
+        	lexer = classForName(lexerName).asSubclass(Lexer.class);
+            Constructor<? extends Lexer> lexConstructor = lexer.getConstructor(CharStream.class);
+            Lexer lexObj = lexConstructor.newInstance(input);				// makes new instance of lexer

-            Method ruleName = lexer.getMethod("m"+testRuleName, new Class[0]);
+            Method ruleName = lexer.getMethod("m"+testRuleName);

/** Start of I/O Redirecting */
ByteArrayOutputStream out = new ByteArrayOutputStream();
@@ -256,9 +255,9 @@ public class gUnitExecutor implements ITestSuite {
/** End of redirecting */

/** Invoke lexer rule, and get the current index in CharStream */
-            ruleName.invoke(lexObj, new Object[0]);
-            Method ruleName2 = lexer.getMethod("getCharIndex", new Class[0]);
-            int currentIndex = (Integer) ruleName2.invoke(lexObj, new Object[0]);
+            ruleName.invoke(lexObj);
+            Method ruleName2 = lexer.getMethod("getCharIndex");
+            int currentIndex = (Integer) ruleName2.invoke(lexObj);
if ( currentIndex!=input.size() ) {
ps2.print("extra text found, '"+input.substring(currentIndex, input.size()-1)+"'");
}
@@ -306,8 +305,8 @@ public class gUnitExecutor implements ITestSuite {
// TODO: throw proper exceptions
protected gUnitTestResult runParser(String parserName, String lexerName, String testRuleName, gUnitTestInput testInput) throws Exception {
CharStream input;
-		Class lexer = null;
-		Class parser = null;
+		Class<? extends Lexer> lexer;
+		Class<? extends Parser> parser;
PrintStream ps = null;		// for redirecting stdout later
PrintStream ps2 = null;		// for redirecting stderr later
try {
@@ -315,25 +314,20 @@ public class gUnitExecutor implements ITestSuite {
input = getANTLRInputStream(testInput);

/** Use Reflection to create instances of lexer and parser */
-        	lexer = classForName(lexerName);
-            Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
-            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
-            Object lexObj = lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
+        	lexer = classForName(lexerName).asSubclass(Lexer.class);
+            Constructor<? extends Lexer> lexConstructor = lexer.getConstructor(CharStream.class);
+            Lexer lexObj = lexConstructor.newInstance(input);				// makes new instance of lexer

-            CommonTokenStream tokens = new CommonTokenStream((Lexer) lexObj);
+            CommonTokenStream tokens = new CommonTokenStream(lexObj);

-            parser = classForName(parserName);
-            Class[] parArgTypes = new Class[]{TokenStream.class};				// assign type to parser's args
-            Constructor parConstructor = parser.getConstructor(parArgTypes);
-            Object[] parArgs = new Object[]{tokens};							// assign value to parser's args
-            Object parObj = parConstructor.newInstance(parArgs);				// makes new instance of parser
+            parser = classForName(parserName).asSubclass(Parser.class);
+            Constructor<? extends Parser> parConstructor = parser.getConstructor(TokenStream.class);
+            Parser parObj = parConstructor.newInstance(tokens);				// makes new instance of parser

// set up customized tree adaptor if necessary
if ( grammarInfo.getAdaptor()!=null ) {
-            	parArgTypes = new Class[]{TreeAdaptor.class};
-            	Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", parArgTypes);
-            	Class _treeAdaptor = classForName(grammarInfo.getAdaptor());
+            	Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", TreeAdaptor.class);
+            	Class<? extends TreeAdaptor> _treeAdaptor = classForName(grammarInfo.getAdaptor()).asSubclass(TreeAdaptor.class);
_setTreeAdaptor.invoke(parObj, _treeAdaptor.newInstance());
}

@@ -356,7 +350,7 @@ public class gUnitExecutor implements ITestSuite {
if ( ruleReturn!=null ) {
if ( ruleReturn.getClass().toString().indexOf(testRuleName+"_return")>0 ) {
try {	// NullPointerException may happen here...
-                		Class _return = classForName(parserName+"$"+testRuleName+"_return");
+                		Class<?> _return = classForName(parserName+"$"+testRuleName+"_return");
Method[] methods = _return.getDeclaredMethods();
for(Method method : methods) {
if ( method.getName().equals("getTree") ) {
@@ -434,9 +428,9 @@ public class gUnitExecutor implements ITestSuite {
protected gUnitTestResult runTreeParser(String parserName, String lexerName, String testRuleName, String testTreeRuleName, gUnitTestInput testInput) throws Exception {
CharStream input;
String treeParserPath;
-		Class lexer = null;
-		Class parser = null;
-		Class treeParser = null;
+		Class<? extends Lexer> lexer;
+		Class<? extends Parser> parser;
+		Class<? extends TreeParser> treeParser;
PrintStream ps = null;		// for redirecting stdout later
PrintStream ps2 = null;		// for redirecting stderr later
try {
@@ -452,27 +446,22 @@ public class gUnitExecutor implements ITestSuite {
}

/** Use Reflection to create instances of lexer and parser */
-        	lexer = classForName(lexerName);
-            Class[] lexArgTypes = new Class[]{CharStream.class};				// assign type to lexer's args
-            Constructor lexConstructor = lexer.getConstructor(lexArgTypes);
-            Object[] lexArgs = new Object[]{input};								// assign value to lexer's args
-            Object lexObj = lexConstructor.newInstance(lexArgs);				// makes new instance of lexer
+        	lexer = classForName(lexerName).asSubclass(Lexer.class);
+            Constructor<? extends Lexer> lexConstructor = lexer.getConstructor(CharStream.class);
+            Lexer lexObj = lexConstructor.newInstance(input);				// makes new instance of lexer

-            CommonTokenStream tokens = new CommonTokenStream((Lexer) lexObj);
+            CommonTokenStream tokens = new CommonTokenStream(lexObj);

-            parser = classForName(parserName);
-            Class[] parArgTypes = new Class[]{TokenStream.class};				// assign type to parser's args
-            Constructor parConstructor = parser.getConstructor(parArgTypes);
-            Object[] parArgs = new Object[]{tokens};							// assign value to parser's args
-            Object parObj = parConstructor.newInstance(parArgs);				// makes new instance of parser
+            parser = classForName(parserName).asSubclass(Parser.class);
+            Constructor<? extends Parser> parConstructor = parser.getConstructor(TokenStream.class);
+            Parser parObj = parConstructor.newInstance(tokens);				// makes new instance of parser

// set up customized tree adaptor if necessary
TreeAdaptor customTreeAdaptor = null;
if ( grammarInfo.getAdaptor()!=null ) {
-            	parArgTypes = new Class[]{TreeAdaptor.class};
-            	Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", parArgTypes);
-            	Class _treeAdaptor = classForName(grammarInfo.getAdaptor());
-            	customTreeAdaptor = (TreeAdaptor) _treeAdaptor.newInstance();
+            	Method _setTreeAdaptor = parser.getMethod("setTreeAdaptor", TreeAdaptor.class);
+            	Class<? extends TreeAdaptor> _treeAdaptor = classForName(grammarInfo.getAdaptor()).asSubclass(TreeAdaptor.class);
+            	customTreeAdaptor = _treeAdaptor.newInstance();
_setTreeAdaptor.invoke(parObj, customTreeAdaptor);
}

@@ -490,7 +479,7 @@ public class gUnitExecutor implements ITestSuite {
/** Invoke grammar rule, and get the return value */
Object ruleReturn = ruleName.invoke(parObj);

-            Class _return = classForName(parserName+"$"+testRuleName+"_return");
+            Class<?> _return = classForName(parserName+"$"+testRuleName+"_return");
Method returnName = _return.getMethod("getTree");
CommonTree tree = (CommonTree) returnName.invoke(ruleReturn);

@@ -505,11 +494,9 @@ public class gUnitExecutor implements ITestSuite {
// AST nodes have payload that point into token stream
nodes.setTokenStream(tokens);
// Create a tree walker attached to the nodes stream
-        	treeParser = classForName(treeParserPath);
-            Class[] treeParArgTypes = new Class[]{TreeNodeStream.class};		// assign type to tree parser's args
-            Constructor treeParConstructor = treeParser.getConstructor(treeParArgTypes);
-            Object[] treeParArgs = new Object[]{nodes};							// assign value to tree parser's args
-            Object treeParObj = treeParConstructor.newInstance(treeParArgs);	// makes new instance of tree parser
+        	treeParser = classForName(treeParserPath).asSubclass(TreeParser.class);
+            Constructor<? extends TreeParser> treeParConstructor = treeParser.getConstructor(TreeNodeStream.class);
+            TreeParser treeParObj = treeParConstructor.newInstance(nodes);	// makes new instance of tree parser
// Invoke the tree rule, and store the return value if there is
Method treeRuleName = treeParser.getMethod(testTreeRuleName);
Object treeRuleReturn = treeRuleName.invoke(treeParObj);
@@ -520,7 +507,7 @@ public class gUnitExecutor implements ITestSuite {
if ( treeRuleReturn!=null ) {
if ( treeRuleReturn.getClass().toString().indexOf(testTreeRuleName+"_return")>0 ) {
try {	// NullPointerException may happen here...
-                		Class _treeReturn = classForName(treeParserPath+"$"+testTreeRuleName+"_return");
+                		Class<?> _treeReturn = classForName(treeParserPath+"$"+testTreeRuleName+"_return");
Method[] methods = _treeReturn.getDeclaredMethods();
for(Method method : methods) {
if ( method.getName().equals("getTree") ) {
diff --git a/gunit/src/main/java/org/antlr/gunit/swingui/TestCaseEditController.java b/gunit/src/main/java/org/antlr/gunit/swingui/TestCaseEditController.java
index 30cf0ae..2f15229 100644
--- a/gunit/src/main/java/org/antlr/gunit/swingui/TestCaseEditController.java
+++ b/gunit/src/main/java/org/antlr/gunit/swingui/TestCaseEditController.java
@@ -96,9 +96,9 @@ public class TestCaseEditController implements IController {

/* END OF MODEL*/

-    private static final HashMap<Class, String> TypeNameTable;
+    private static final HashMap<Class<?>, String> TypeNameTable;
static {
-        TypeNameTable = new HashMap<Class, String> ();
+        TypeNameTable = new HashMap<Class<?>, String> ();
TypeNameTable.put(TestCaseInputString.class, IN_TYPE_STRING);
TypeNameTable.put(TestCaseInputMultiString.class, IN_TYPE_MULTI);
TypeNameTable.put(TestCaseInputFile.class, IN_TYPE_FILE);
diff --git a/gunit/src/main/java/org/antlr/gunit/swingui/model/TestSuite.java b/gunit/src/main/java/org/antlr/gunit/swingui/model/TestSuite.java
index 06e5227..1264f30 100644
--- a/gunit/src/main/java/org/antlr/gunit/swingui/model/TestSuite.java
+++ b/gunit/src/main/java/org/antlr/gunit/swingui/model/TestSuite.java
@@ -95,6 +95,6 @@ public class TestSuite {
}

// only for stringtemplate use
-    public List getRulesForStringTemplate() {return rules;}
+    public List<Rule> getRulesForStringTemplate() {return rules;}

}
diff --git a/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java b/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java
index 23f5aa0..dcfdfb3 100644
--- a/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java
+++ b/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java
@@ -36,7 +36,7 @@ import java.util.HashMap;
*/
public class ParserLoader extends ClassLoader {

-    private HashMap<String, Class> classList;
+    private HashMap<String, Class<?>> classList;
private String grammar;

/**
@@ -51,7 +51,7 @@ public class ParserLoader extends ClassLoader {
// load all the class files in the "classDir" related to the grammarName
File dir = new File(classDir);
if(dir.isDirectory()) {
-            classList = new HashMap<String, Class>();
+            classList = new HashMap<String, Class<?>>();
grammar = grammarName;
File[] files = dir.listFiles(new ClassFilenameFilter(grammarName));
for(File f : files) {
@@ -63,7 +63,7 @@ public class ParserLoader extends ClassLoader {
in.close();

// define class
-                final Class newClass = defineClass(null, classData, 0, classData.length);
+                final Class<?> newClass = defineClass(null, classData, 0, classData.length);
assert(newClass != null);
resolveClass(newClass);

@@ -86,7 +86,7 @@ public class ParserLoader extends ClassLoader {


@Override
-    public synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException {
+    public synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
//System.out.print("loading: " + name);
if(name.startsWith(grammar)) {
if(classList.containsKey(name)) {
@@ -98,7 +98,7 @@ public class ParserLoader extends ClassLoader {
}

} else {
-            final Class c = findSystemClass(name);
+            final Class<?> c = findSystemClass(name);
//System.out.println(" .... system found " + c.getName());
return c;
}

