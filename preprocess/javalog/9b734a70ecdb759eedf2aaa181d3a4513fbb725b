commit 9b734a70ecdb759eedf2aaa181d3a4513fbb725b
Author:     acondit <acondit@parrt.spork>
AuthorDate: Sat May 7 07:52:10 2011 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Sat May 7 07:52:10 2011 -0800

Changes for release Antlr3.4

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8404]

diff --git a/runtime/ObjC/Framework/ACBTree.h b/runtime/ObjC/Framework/ACBTree.h
new file mode 100644
index 0000000..ba19527
--- /dev/null
+++ b/runtime/ObjC/Framework/ACBTree.h
@@ -0,0 +1,97 @@
+//
+//  ACBtree.h
+//  ST4
+//
+//  Created by Alan Condit on 4/18/11.
+//  Copyright 2011 Alan Condit. All rights reserved.
+//
+
+typedef enum {
+    BTNODE,
+    LEAF
+} NodeType;
+
+#import <Foundation/Foundation.h>
+
+@class AMutableDictionary;
+
+#define BTNODESIZE 11
+#define BTHNODESIZE ((BTNODESIZE-1)/2)
+#define BTKeySize  38
+#define FAILURE -1
+#define SUCCESS 0
+
+@interface ACBKey : NSObject {
+    NSInteger recnum;               /*  record number                   */
+    __strong NSString *key;         /*  key pointer id                  */
+    char      kstr[BTKeySize];      /*  key entry                       */
+}
+
+@property (assign) NSInteger recnum;
+@property (retain) NSString *key;
+
++ (ACBKey *)newKey;
++ (ACBKey *)newKeyWithKStr:(NSString *)aKey;
+- (id) init;
+- (id) initWithKStr:(NSString *)aKey;
+
+@end
+
+@interface ACBTree : NSObject {
+    __strong AMutableDictionary *dict;  /* The dictionary that this node belongs to */
+    __strong ACBTree *lnode;            /* pointer to left node            */
+    __strong ACBTree *rnode;            /* pointer to right node           */
+    __strong ACBKey  **keys;            /* pointer to keys                 */
+    __strong ACBTree **btNodes;         /* pointers to btNodes             */
+    __strong ACBKey  *keyArray[BTNODESIZE];
+    __strong ACBTree *btNodeArray[BTNODESIZE];
+    NSInteger lnodeid;                  /* nodeid of left node             */
+    NSInteger rnodeid;                  /* nodeid of right node            */
+    NSInteger nodeid;                   /* node id                         */
+    NSInteger nodeType;                 /* 1 = node, 2 = leaf, -1 = unused */
+    NSInteger numkeys;                  /* number of active entries        */
+    NSInteger numrecs;                  /* number of records               */
+    NSInteger updtd;                    /* modified since update flag      */
+    NSInteger keylen;                   /* length of key                   */
+    NSInteger kidx;
+}
+
+@property (retain) AMutableDictionary *dict;
+@property (retain) ACBTree  *lnode;
+@property (retain) ACBTree  *rnode;
+@property (assign) ACBKey   **keys;
+@property (assign) ACBTree  **btNodes;
+@property (assign) NSInteger lnodeid;
+@property (assign) NSInteger rnodeid;
+@property (assign) NSInteger nodeid;
+@property (assign) NSInteger nodeType;
+@property (assign) NSInteger numkeys;
+@property (assign) NSInteger numrecs;
+@property (assign) NSInteger updtd;
+@property (assign) NSInteger keylen;
+@property (assign) NSInteger kidx;
+
++ (ACBTree *) newNodeWithDictionary:(AMutableDictionary *)theDict;
+
+- (id)initWithDictionary:(AMutableDictionary *)theDict;
+
+- (ACBTree *)createnode:(ACBKey *)kp0;
+- (ACBTree *)deletekey:(NSString *)dkey;
+- (ACBTree *)insertkey:(ACBKey *)ikp value:(id)value;
+- (ACBKey *)internaldelete:(ACBKey *)dkp;
+- (ACBTree *) internalinsert:(ACBKey *)key value:(id)value split:(NSInteger *)h;
+- (ACBTree *) insert:(ACBKey *)key value:(id)value index:(NSInteger)hi split:(NSInteger *)h;
+- (NSInteger)delfrmnode:(ACBKey *)ikp;
+- (NSInteger)insinnode:(ACBKey *)key value:(id)value;
+- (void)mergenode:(NSInteger)i;
+- (ACBTree *)splitnode:(NSInteger)idx;
+- (ACBTree *)search:(id)key;
+- (NSInteger)searchnode:(id)key match:(BOOL)match;
+- (void)borrowleft:(NSInteger)i;
+- (void)borrowright:(NSInteger)i;
+- (void)rotateleft:(NSInteger)j;
+- (void)rotateright:(NSInteger)j;
+- (NSInteger) keyWalkLeaves;
+- (NSInteger) objectWalkLeaves;
+- (void)dealloc;
+@end
diff --git a/runtime/ObjC/Framework/ACBTree.m b/runtime/ObjC/Framework/ACBTree.m
new file mode 100644
index 0000000..4aded19
--- /dev/null
+++ b/runtime/ObjC/Framework/ACBTree.m
@@ -0,0 +1,736 @@
+//
+//  ACBTree.m
+//  ST4
+//
+//  Created by Alan Condit on 4/18/11.
+//  Copyright 2011 Alan Condit. All rights reserved.
+//
+
+#import <Cocoa/Cocoa.h>
+#import "ACBTree.h"
+#import "AMutableDictionary.h"
+#import "ANTLRRuntimeException.h"
+
+@class AMutableDictionary;
+
+@implementation ACBKey
+
+static NSInteger RECNUM = 0;
+
+@synthesize recnum;
+@synthesize key;
+
++ (ACBKey *)newKey
+{
+    return [[ACBKey alloc] init];
+}
+
++ (ACBKey *)newKeyWithKStr:(NSString *)aKey
+{
+    return [[ACBKey alloc] initWithKStr:(NSString *)aKey];
+}
+
+- (id) init
+{
+    self =[super init];
+    if ( self != nil ) {
+        recnum = RECNUM++;
+    }
+    return self;
+}
+
+- (id) initWithKStr:(NSString *)aKey
+{
+    self =[super init];
+    if ( self != nil ) {
+        NSInteger len;
+        recnum = RECNUM++;
+        key = aKey;
+        len = [aKey length];
+        if ( len >= BTKeySize ) {
+            len = BTKeySize - 1;
+        }
+        strncpy( kstr, [aKey cStringUsingEncoding:NSASCIIStringEncoding], len);
+        kstr[len] = '\0';
+    }
+    return self;
+}
+
+@end
+
+@implementation ACBTree
+
+@synthesize dict;
+@synthesize lnode;
+@synthesize rnode;
+@synthesize keys;
+@synthesize btNodes;
+@synthesize lnodeid;
+@synthesize rnodeid;
+@synthesize nodeid;
+@synthesize nodeType;
+@synthesize numkeys;
+@synthesize numrecs;
+@synthesize updtd;
+@synthesize keylen;
+@synthesize kidx;
+
++ (ACBTree *) newNodeWithDictionary:(AMutableDictionary *)theDict
+{
+    return [[ACBTree alloc] initWithDictionary:theDict];
+}
+
+- (id)initWithDictionary:(AMutableDictionary *)theDict
+{
+    self = [super init];
+    if (self) {
+        // Initialization code here.
+        dict = theDict;
+        nodeid = theDict.nxt_nodeid++;
+        keys = keyArray;
+        btNodes = btNodeArray;
+        if ( nodeid == 0 ) {
+            numkeys = 0;
+        }
+    }
+
+    return self;
+}
+
+- (ACBTree *)createnode:(ACBKey *)kp
+{
+    ACBTree *tmp;
+
+    tmp = [ACBTree newNodeWithDictionary:dict];
+    tmp.nodeType = nodeType;
+    tmp.lnode = self;
+    tmp.rnode = self.rnode;
+    self.rnode = tmp;
+    //tmp.btNodes[0] = self;
+    //tmp.keys[0] = kp;
+    tmp.updtd = YES;
+    tmp.numrecs = ((nodeType == LEAF)?1:numrecs);
+    updtd = YES;
+    tmp.numkeys = 1;
+    [tmp retain];
+    return(tmp);
+}
+
+- (ACBTree *)deletekey:(NSString *)dkey
+{
+    ACBKey *del, *dkp;
+    ACBTree *told, *sNode;
+
+    if ( [dkey isKindOfClass:[NSString class]] )
+        dkp = [ACBKey newKeyWithKStr:dkey];
+    else if ( [dkey isKindOfClass:[ACBKey class]] )
+        dkp = (ACBKey *)dkey;
+    else
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Don't understand this key:\"%@\"", dkey]];
+    sNode = [self search:dkp.key];
+    if ( sNode == nil || [sNode searchnode:dkp.key match:YES] == FAILURE ) {
+        return(self);
+    }
+    told = dict.root;
+    del = [self internaldelete:dkp];
+
+    /*  check for shrink at the root  */
+    if ( numkeys == 1 && nodeType != LEAF ) {
+        told = btNodes[0];
+        told.nodeid = 1;
+        told.updtd = YES;
+        dict.root = told;
+   }
+#ifdef DONTUSENOMO
+    if (debug == 'd') [self printtree];
+#endif
+    return(told);
+}
+
+/** insertKey is the insertion entry point
+ *  It determines if the key exists in the tree already
+ *  it calls internalInsert to determine if the key already exists in the tree,
+ *  and returns the node to be updated
+ */
+- (ACBTree *)insertkey:(ACBKey *)kp value:(id)value
+{
+    ACBTree *tnew, *q;
+    NSInteger h, nodeNum;
+
+    tnew = self;
+    q = [self internalinsert:kp value:value split:&h];
+    /*  check for growth at the root  */
+    if ( q != nil ) {
+        tnew = [[ACBTree newNodeWithDictionary:dict] retain];
+        tnew.nodeType = BTNODE;
+        nodeNum = tnew.nodeid;
+        tnew.nodeid = 0;
+        self.nodeid = nodeNum;
+        [tnew insert:self.keys[numkeys-1] value:self index:0 split:&h];
+        [tnew insert:q.keys[q.numkeys-1] value:q index:1 split:&h];
+        tnew.numrecs = self.numrecs + q.numrecs;
+        tnew.lnodeid = self.nodeid;
+        tnew.rnodeid = self.rnodeid;
+        self.rnodeid = tnew.nodeid;
+        tnew.lnode = self;
+        tnew.rnode = self.rnode;
+        self.rnode = tnew;
+        /* affected by nodeid swap */
+        // newnode.lnodeid = tnew.btNodes[0].nodeid;
+    }
+    //dict.root = t;
+    //l.reccnt++;
+    return(tnew);
+}
+
+- (ACBTree *)search:(NSString *)kstr
+{
+    NSInteger i, ret;
+    NSInteger srchlvl = 0;
+    ACBTree *t;
+
+    t = self;
+    if ( self.numkeys == 0 && self.nodeType == LEAF )
+        return nil;
+    while (t != nil) {
+        for (i = 0; i < t.numkeys; i++) {
+            ret = [t.keys[i].key compare:kstr];
+            if ( ret >= 0 ) {
+                if ( t.nodeType == LEAF ) {
+                    if ( ret == 0 ) return (t);    /* node containing keyentry found */
+                    else return nil;
+                }
+                else {
+                    break;
+                }
+            }
+        }
+        srchlvl++;
+        if ( t.nodeType == BTNODE ) t = t.btNodes[i];
+        else {
+            t = nil;
+        }
+    }
+    return(nil);          /* entry not found */
+}
+
+/** SEARCHNODE
+ *  calling parameters --
+ *      BKEY PTR for key to search for.
+ *      TYPE for exact match(YES) or position(NO)
+ *  returns -- i
+ *      i == FAILURE when match required but does not exist.
+ *      i == t.numkeys if no existing insertion branch found.
+ *      otherwise i == insertion branch.
+ */
+- (NSInteger)searchnode:(NSString *)kstr match:(BOOL)match
+{
+    NSInteger i, ret;
+#ifdef DONTUSEYET
+    /** binary search routine */
+    NSInteger lo = 0;
+    NSInteger hi = t.numkeys;
+
+    lo = 0;
+    hi = t.numkeys; /* binary array search */
+    do {
+        i = (lo + hi) / 2;
+        ret = [t.keys[i].key compare:kstr];
+        if (ret <= 0) hi = i-1;
+        if (ret >= 0) lo = i+1;
+    } while (hi >= lo);
+    hi = i;
+    if ( ret == 0 ) { /* found */
+        *h = NO;
+        return i;
+    }
+#endif
+    ret = 1;
+    for ( i = 0; i < numkeys; i++ ) {
+        ret = [keys[i].key compare:kstr];
+        if ( ret >= 0 ) {         /* key node found */
+            if ( ret == 0 && match == NO ) {
+                return FAILURE;
+            }
+            else if ( ret > 0 &&  match == YES ) {
+                return FAILURE;
+            }
+            break;
+        }
+    }
+    if ( i == numkeys && match == YES ) {
+        i = FAILURE;
+    }
+    return(i);
+}
+
+- (ACBKey *)internaldelete:(ACBKey *)dkp
+{
+    NSInteger i, nkey;
+    ACBKey *del;
+    ACBTree *tsb;
+    NSInteger srchlvl = 0;
+
+    /* find deletion branch */
+    if ( nodeType != LEAF ) {
+        srchlvl++;
+        /* search for end of tree */
+        i = [self searchnode:dkp.key match:NO];
+        del = [btNodes[i] internaldelete:dkp];
+        srchlvl--;
+        /* if not LEAF propagate back high key    */
+        tsb = btNodes[i];
+        nkey = tsb.numkeys - 1;
+    }
+    /***  the bottom of the tree has been reached       ***/
+    else {                   /* set up deletion ptrs      */
+        if ( [self delfrmnode:dkp] == SUCCESS ) {
+            if ( numkeys < BTHNODESIZE+1 ) {
+                del = dkp;
+            }
+            else {
+                del = nil;
+            }
+            dkp.recnum = nodeid;
+            return(del);
+        }
+    }
+    /***       indicate deletion to be done            ***/
+    if ( del != nil ) {
+        /*** the key in "del" has to be deleted from in present node ***/
+        if ( btNodes[i].numkeys >= BTHNODESIZE+1 ) {
+            /* node does not need balancing */
+            del = nil;
+            self.keys[i] = tsb.keys[nkey];
+        }
+        else {                         /* node requires balancing */
+            if ( i == 0 ) {
+                [self rotateright:0];
+                self.btNodes[0] = tsb;
+            } else if ( i < numkeys-1 ) {     /* look to the right first */
+                if ( self.btNodes[i+1].numkeys > BTHNODESIZE+1 ) {  /* carry from right */
+                    [self borrowright:i];
+                }
+                else {           /* merge present node with right node */
+                    [self mergenode:i];
+                }
+            }
+            else {                      /* look to the left */
+                if ( i > 0 ) {          /* carry or merge with left node */
+                    if ( self.btNodes[i-1].numkeys > BTHNODESIZE+1 ) { /* carry from left */
+                        [self borrowleft:i];
+                    }
+                    else { /*** merge present node with left node ***/
+                        i--;
+                        [self mergenode:i];
+                        tsb = self.btNodes[i];
+                    }
+                }
+            }
+        self.keys[i] = tsb.keys[nkey];
+        }
+    }
+    numrecs--;
+    updtd = TRUE;
+    return(del);
+}
+
+/** Search key kp on B-tree with root t; if found increment counter.
+ *  otherwise insert an item with key kp in tree.  If an ACBKey
+ *  emerges to be passed to a lower level, then assign it to kp;
+ *  h = "tree t has become higher"
+ */
+- (ACBTree *) internalinsert:(ACBKey *)kp value:(id)value split:(NSInteger *)h
+{
+    /* search key ins on node t^; h = false  */
+    NSInteger i, ret;
+    ACBTree *q, *tmp;
+
+    for (i = 0; i < numkeys; i++) {
+        ret = [keys[i].key compare:kp.key];
+        if ( ret >= 0 ) {
+            if ( nodeType == LEAF && ret == 0 ) return (self);    /* node containing keyentry found */
+            break;
+        }
+    }
+    if ( nodeType == LEAF ) { /*  key goes in this node  */
+        q = [self insert:kp value:value index:i split:h];
+    }
+    else  { /* nodeType == BTNODE */
+        /*  key is not on this node  */
+        q = [self.btNodes[i] internalinsert:kp value:value split:h];
+        if ( *h ) {
+            [self insert:kp value:q index:i split:h];
+        }
+        else {
+            self.numrecs++;
+        }
+        tmp = self.btNodes[numkeys-1];
+        keys[numkeys-1] = tmp.keys[tmp.numkeys-1];
+        if ( i != numkeys-1 ) {
+            tmp = self.btNodes[i];
+            keys[i] = tmp.keys[tmp.numkeys-1];
+        }
+        updtd = YES;
+    } /* search */
+    return q;
+}
+
+/** Do the actual insertion or split and insert
+ *  insert key to the right of t.keys[hi]
+ */
+- (ACBTree *) insert:(ACBKey *)kp value:(id)value index:(NSInteger)hi split:(NSInteger *)h
+{
+    ACBTree *b;
+    ACBKey *newitem;
+
+    if ( numkeys < BTNODESIZE ) {
+        *h = NO;
+        [self rotateright:hi];
+        keys[hi] = kp;
+        btNodes[hi] = value;
+        numrecs++;
+        numkeys++;
+        updtd = YES;
+        //[kp retain];
+        return nil;
+    }
+    else { /*  node t is full; split it and assign the emerging ACBKey to olditem  */
+        b = [self splitnode:hi];
+        if ( hi <= BTHNODESIZE ) {              /* insert key in left page */
+            [self rotateright:hi];
+            keys[hi] = kp;
+            btNodes[hi] = value;
+            numrecs++;
+            numkeys++;
+            newitem = keys[numkeys-1];
+        }
+        else {                                  /* insert key in right page */
+            hi -= BTHNODESIZE;
+            if ( b.rnode == nil ) hi--;
+            [b rotateright:hi];
+            b.keys[hi] = kp;
+            b.btNodes[hi] = value;
+            b.numrecs++;
+            b.numkeys++;
+            newitem = keys[b.numkeys-1];
+        }
+        numkeys = b.numkeys = BTHNODESIZE+1;
+        b.updtd = updtd = YES;
+    }
+    return b;
+} /* insert */
+
+- (void)borrowleft:(NSInteger)i
+{
+    ACBTree *t0, *t1;
+    NSInteger nkey;
+
+    t0 = btNodes[i];
+    t1 = btNodes[i-1];
+    nkey = t1.numkeys-1;
+    [t0 insinnode:t1.keys[nkey] value:t1.btNodes[nkey]];
+    [t1 delfrmnode:t1.keys[nkey]];
+    nkey--;
+    keys[i-1] = t1.keys[nkey];
+    keys[i-1].recnum = t1.nodeid;
+}
+
+- (void)borrowright:(NSInteger)i
+{
+    ACBTree *t0, *t1;
+    NSInteger nkey;
+
+    t0 = btNodes[i];
+    t1 = btNodes[i+1];
+    [t0 insinnode:t1.keys[0] value:t1.btNodes[0]];
+    [t1 delfrmnode:t1.keys[0]];
+    nkey = t0.numkeys - 1;
+    keys[i] = t0.keys[nkey];
+    keys[i].recnum = t0.nodeid;
+}
+
+- (NSInteger)delfrmnode:(ACBKey *)ikp
+{
+    NSInteger j;
+
+    j = [self searchnode:ikp.key match:YES];
+    if (j == FAILURE) {
+        return(FAILURE);
+    }
+    ACBKey *k0 = nil;
+    ACBTree *n0 = nil;
+    if ( self.nodeType == LEAF ) {
+        k0 = self.keys[j];
+        n0 = self.btNodes[j];
+    }
+    [self rotateleft:j];
+    self.numkeys--;
+    numrecs -= ((self.nodeType == LEAF)?1:btNodes[j].numrecs);
+    if ( k0 ) [k0 release];
+    if ( n0 ) [n0 release];
+    updtd = TRUE;
+    return(SUCCESS);
+}
+
+- (NSInteger)insinnode:(ACBKey *)ikp value:(id)value
+{
+    NSInteger j;
+
+    j = [self searchnode:ikp.key match:NO];
+    [self rotateright:j];
+    keys[j] = ikp;
+    btNodes[j] = value;
+    numkeys++;
+    if ( nodeType == LEAF ) {
+        numrecs++;
+    }
+    else {
+        numrecs += btNodes[j].numrecs;
+    }
+    updtd = TRUE;
+    return(j);
+}
+
+- (void)mergenode:(NSInteger)i
+{
+    ACBTree *t0, *t1, *tr;
+    NSInteger j, k, nkeys;
+
+    t0 = btNodes[i];
+    t1 = btNodes[i+1];
+    /*** move keys and pointers from
+     t1 node to t0 node           ***/
+    for (j=t0.numkeys, k=0; j < BTNODESIZE && k < t1.numkeys; j++, k++) {
+        t0.keys[j] = t1.keys[k];
+        t0.btNodes[j] = t1.btNodes[k];
+        t0.numkeys++;
+    }
+    t0.numrecs += t1.numrecs;
+    t0.rnode = t1.rnode;
+    t0.rnodeid = t1.rnodeid;
+    t0.updtd = YES;
+    nkeys = t0.numkeys - 1;
+    keys[i] = t0.keys[nkeys]; /* update key to point to new high key */
+    [self rotateleft:i+1]; /* copy over the keys and nodes */
+
+    t1.nodeType = -1;
+    if (t1.rnodeid != 0xffff && i < numkeys - 2) {
+        tr = btNodes[i+1];
+        tr.lnodeid = t0.nodeid;
+        tr.lnode = t0;
+        tr.updtd = YES;
+    }
+    self.numkeys--;
+    updtd = YES;
+}
+
+- (ACBTree *)splitnode:(NSInteger)idx
+{
+    ACBTree *t1;
+    NSInteger j, k;
+
+    k = (idx <= BTHNODESIZE) ? BTHNODESIZE : BTHNODESIZE+1;
+    /*** create new node ***/
+    // checknode(l, t, k);
+    t1 = [ACBTree newNodeWithDictionary:dict];
+    t1.nodeType = nodeType;
+    t1.rnode = self.rnode;
+    self.rnode = t1;
+    t1.lnode = self;
+    self.updtd = t1.updtd = YES;
+    /*** move keys and pointers ***/
+    NSInteger i = 0;
+    for (j = k; j < BTNODESIZE; j++, i++ ) {
+        t1.keys[i] = keys[j];
+        t1.btNodes[i] = btNodes[j];
+        t1.numrecs += ((nodeType == LEAF) ? 1 : btNodes[j].numrecs);
+        numrecs     -= ((nodeType == LEAF) ? 1 : btNodes[j].numrecs);
+        keys[j] = nil;
+        btNodes[j] = nil;
+    }
+    t1.numkeys  = BTNODESIZE-k;
+    self.numkeys = k;
+    return(t1);
+}
+
+#ifdef DONTUSENOMO
+freetree(l, t)
+FIDB *l;
+ACBTree *t;
+{
+    ACBTree *tmp;
+    NSInteger i;
+
+    if (dict.root == nil) return(SUCCESS);
+    if (t.nodeid == 1) {
+        srchlvl = 0;
+    }
+    else srchlvl++;
+    for (i = 0; i < t.numkeys; i++) {
+        tmp = t.btNodes[i];
+        if (tmp != nil) {
+            if (tmp.nodeType == LEAF) {
+                free(tmp);    /* free the leaf */
+                if (tmp == l.rrnode) {
+                    l.rrnode = nil;
+                }
+                t.btNodes[i] = nil;
+                l.chknode.nods_inuse--;
+                /*              putpage(l, l.chknode, 0);
+                 */
+            }
+            else {
+                freetree(l, tmp); /* continue up the tree */
+                srchlvl--;        /* decrement the srchlvl on return */
+            }
+        }
+    }
+    free(t); /* free the node entered with */
+    if (t == l.rrnode) {
+        l.rrnode = nil;
+    }
+    l.chknode.nods_inuse--;
+    /*     putpage(l, l.chknode, 0);
+     */
+    t = nil;
+}
+
+- (void) notfound:(ACBKey *)kp
+{
+    /* error routine to perform if entry was expected and not found */
+}
+
+- (void)printtree:(ACBTree *)t
+{
+    BYTE *str;
+    NSInteger i, j;
+    NSUInteger *pdate, *ptime;
+
+    syslst = stdprn;
+    if ( t.nodeid == 1 ) {
+        srchlvl = 0;
+    }
+    else srchlvl++;
+    for (j = 0; j < t.numkeys; j++) {
+        checknode(l, t, j);
+        if ( t.btNodes[j] != nil ) [self printtree:t.btNodes[j]];
+    }
+    NSLog(@"Nodeid = %d, nodeType = %s, numkeys = %d, numrecs = %d\n",
+          t.nodeid, (t.nodeType == BTNODE)?@"NODE":@"LEAF", t.numkeys, t.numrecs);
+    NSLog(@"Left nodeid = %d, Right nodeid = %d\n", t.lnodeid, t.rnodeid);
+    for (i = 0; i < t.numkeys; i++) {
+        NSLog(@"     t.keys[%d] recnum = %d, keyval = %@",
+              i, t.keys[i].recnum, t.keys[i]);
+        str = t.keys[i].kstr;
+        pdate = (NSUInteger *) (str + 6);
+        ptime = (NSUInteger *) (str + 8);
+        NSLog(@" date = %04.4x,  time = %04.4x\n",
+              *pdate, *ptime);
+    }
+}
+
+- (BOOL)puttree:(ACBTree *)t
+{
+    NSInteger i;
+    if (t.nodeType != LEAF) {
+        for (i = 0; i < t.numkeys; i++) {
+            if ( t.btNodes[i] != nil ) puttree(l, t.btNodes[i]);
+        }
+    }
+    if ( t.updtd ) {
+        putnode(l, t, t.nodeid);
+        return(YES);
+    }
+    return(NO);
+}
+
+#endif
+
+/** ROTATELEFT -- rotate keys from right to the left
+ *  starting at position j
+ */
+- (void)rotateleft:(NSInteger)j
+{
+    while ( j+1 < numkeys ) {
+        keys[j] = keys[j+1];
+        btNodes[j] = btNodes[j+1];
+        j++;
+    }
+}
+
+/** ROTATERIGHT -- rotate keys to the right by 1 position
+ *  starting at the last key down to position j.
+ */
+- (void)rotateright:(NSInteger)j
+{
+    NSInteger k;
+
+    for ( k = numkeys; k > j; k-- ) {
+        keys[k] = keys[k-1];
+        btNodes[k] = btNodes[k-1];
+    }
+    keys[j] = nil;
+    btNodes[j] = nil;
+}
+
+- (NSInteger) keyWalkLeaves
+{
+    NSInteger i, idx = 0;
+    NSInteger keycnt;
+    ACBTree *t;
+
+    if ( self != dict.root ) {
+        return 0; // maybe I need to throw an exception here
+    }
+    t = self;
+    self.dict.data = [NSMutableData dataWithLength:(numkeys * sizeof(id))];
+    self.dict.ptrBuffer = [self.dict.data mutableBytes];
+    while ( t != nil && t.nodeType != LEAF ) {
+        t = t.btNodes[0];
+    }
+    do {
+        keycnt = ((t.rnode != nil) ? t.numkeys : t.numkeys-1);
+        for ( i = 0; i < keycnt; i++ ) {
+            if ( t.btNodes[i] != nil ) {
+                dict.ptrBuffer[idx++] = (id) t.keys[i].key;
+            }
+        }
+        t = t.rnode;
+    } while ( t != nil );
+    return( idx );
+}
+
+- (NSInteger) objectWalkLeaves
+{
+    NSInteger i, idx = 0;
+    NSInteger keycnt;
+    ACBTree *t;
+
+    if ( self != dict.root ) {
+        return 0; // maybe I need to throw an exception here
+    }
+    t = self;
+    self.dict.data = [NSMutableData dataWithLength:(numrecs * sizeof(id))];
+    self.dict.ptrBuffer = [self.dict.data mutableBytes];
+    while ( t != nil && t.nodeType != LEAF ) {
+        t = t.btNodes[0];
+    }
+    do {
+        keycnt = ((t.rnode != nil) ? t.numkeys : t.numkeys-1);
+        for ( i = 0; i < keycnt; i++ ) {
+            if ( t.btNodes[i] != nil ) {
+                dict.ptrBuffer[idx++] = (id) t.btNodes[i];
+            }
+        }
+        t = t.rnode;
+    } while ( t != nil );
+    return( idx );
+}
+
+- (void)dealloc
+{
+    [super dealloc];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/AMutableArray.h b/runtime/ObjC/Framework/AMutableArray.h
new file mode 100644
index 0000000..28d0797
--- /dev/null
+++ b/runtime/ObjC/Framework/AMutableArray.h
@@ -0,0 +1,50 @@
+//
+//  AMutableArray.h
+//  a_ST4
+//
+//  Created by Alan Condit on 3/12/11.
+//  Copyright 2011 Alan's MachineWorks. All rights reserved.
+//
+
+#import <Cocoa/Cocoa.h>
+#import "ArrayIterator.h"
+
+@class ArrayIterator;
+
+@interface AMutableArray : NSMutableArray {
+    NSInteger BuffSize;
+    NSInteger count;
+    __strong NSMutableData *buffer;
+    __strong id *ptrBuffer;
+}
+
++ (id) newArray;
++ (id) arrayWithCapacity:(NSInteger)size;
+
+- (id) init;
+- (id) initWithCapacity:(NSInteger)size;
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (void) addObject:(id)anObject;
+- (void) addObjectsFromArray:(NSArray *)anArray;
+- (id) objectAtIndex:(NSInteger)anIdx;
+- (void) insertObject:(id)anObject atIndex:(NSInteger)anIdx;
+- (void) removeAllObjects;
+- (void) removeLastObject;
+- (void) removeObjectAtIndex:(NSInteger)idx;
+- (void) replaceObjectAtIndex:(NSInteger)idx withObject:(id)obj;
+- (NSInteger) count;
+- (void)setCount:(NSInteger)cnt;
+//- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id *)stackbuf count:(NSUInteger)len;
+- (NSArray *) allObjects;
+- (ArrayIterator *) objectEnumerator;
+- (void) ensureCapacity:(NSInteger) index;
+- (NSString *) description;
+- (NSString *) toString;
+
+@property (assign) NSInteger BuffSize;
+@property (assign, getter=count, setter=setCount:) NSInteger count;
+@property (retain) NSMutableData *buffer;
+@property (assign) id *ptrBuffer;
+
+@end
diff --git a/runtime/ObjC/Framework/AMutableArray.m b/runtime/ObjC/Framework/AMutableArray.m
new file mode 100644
index 0000000..7f49c71
--- /dev/null
+++ b/runtime/ObjC/Framework/AMutableArray.m
@@ -0,0 +1,289 @@
+//
+//  AMutableArray.m
+//  a_ST4
+//
+//  Created by Alan Condit on 3/12/11.
+//  Copyright 2011 Alan's MachineWorks. All rights reserved.
+//
+#import "AMutableArray.h"
+#import "ArrayIterator.h"
+
+#define BUFFSIZE 101
+
+@implementation AMutableArray
+
+@synthesize BuffSize;
+@synthesize buffer;
+@synthesize ptrBuffer;
+//@synthesize count;
+
+
++ (id) newArray
+{
+    return [[AMutableArray alloc] init];
+}
+
++ (id) arrayWithCapacity:(NSInteger)size
+{
+    return [[AMutableArray alloc] initWithCapacity:size];
+}
+
+- (id) init
+{
+    self=[super init];
+    if ( self != nil ) {
+        BuffSize  = BUFFSIZE;
+        buffer = [NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)];
+        ptrBuffer = (id *)[buffer mutableBytes];
+        for( int idx = 0; idx < BuffSize; idx++ ) {
+            ptrBuffer[idx] = nil;
+        }
+    }
+    return self;
+}
+
+- (id) initWithCapacity:(NSInteger)len
+{
+    self=[super init];
+    if ( self != nil ) {
+        BuffSize  = ((len>=25)?len:25);
+        buffer = [NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)];
+        ptrBuffer = (id *)[buffer mutableBytes];
+        for( int idx = 0; idx < BuffSize; idx++ ) {
+            ptrBuffer[idx] = nil;
+        }
+    }
+    return self;
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    AMutableArray *copy;
+
+    copy = [[[self class] allocWithZone:aZone] init];
+    if ( buffer ) {
+        copy.buffer = [buffer copyWithZone:aZone];
+    }
+    copy.ptrBuffer = [copy.buffer mutableBytes];
+    copy.count = count;
+    copy.BuffSize = BuffSize;
+    return copy;
+}
+
+- (void) addObject:(id)anObject
+{
+    if ( anObject == nil ) anObject = [NSNull null];
+    [anObject retain];
+	[self ensureCapacity:count];
+	ptrBuffer[count++] = anObject;
+}
+
+- (void) addObjectsFromArray:(NSArray *)otherArray
+{
+    NSInteger cnt, i;
+    cnt = [otherArray count];
+    [self ensureCapacity:count+cnt];
+    for( i = 0; i < cnt; i++) {
+        [self addObject:[otherArray objectAtIndex:i]];
+    }
+    return;
+}
+
+- (id) objectAtIndex:(NSInteger)anIdx
+{
+    id obj;
+    if ( anIdx < 0 || anIdx >= count ) {
+        @throw [NSException exceptionWithName:NSRangeException
+                                       reason:[NSString stringWithFormat:@"Attempt to retrieve objectAtIndex %d past end", anIdx]
+                                     userInfo:nil];
+        return nil;
+    }
+    ptrBuffer = [buffer mutableBytes];
+    obj = ptrBuffer[anIdx];
+    if ( obj == [NSNull null] ) obj = nil;
+    return obj;
+}
+
+- (void) insertObject:(id)anObject atIndex:(NSInteger)anIdx
+{
+    if ( anObject == nil ) anObject = [NSNull null];
+    if ( anObject == nil ) {
+        @throw [NSException exceptionWithName:NSInvalidArgumentException reason:@"Attempt to insert nil objectAtIndex" userInfo:nil];
+    }
+    if ( anIdx < 0 || anIdx > count ) {
+        @throw [NSException exceptionWithName:NSRangeException reason:@"Attempt to insertObjectAtIndex past end" userInfo:nil];
+    }
+    if ( count == BuffSize ) {
+        [self ensureCapacity:count];
+    }
+    if ( anIdx < count ) {
+        for (int i = count; i > anIdx; i--) {
+            ptrBuffer[i] = ptrBuffer[i-1];
+        }
+    }
+    ptrBuffer[anIdx] = [anObject retain];
+    count++;
+}
+
+- (void) removeObjectAtIndex:(NSInteger)idx;
+{
+    id tmp;
+    if (idx < 0 || idx >= count) {
+        @throw [NSException exceptionWithName:NSRangeException reason:@"Attempt to insert removeObjectAtIndex past end" userInfo:nil];
+    }
+    else if (count) {
+        tmp = ptrBuffer[idx];
+        if ( tmp ) [tmp release];
+        for (int i = idx; i < count; i++) {
+            ptrBuffer[i] = ptrBuffer[i+1];
+        }
+        count--;
+    }
+}
+
+- (void) removeLastObject
+{
+    id tmp;
+    if (count == 0) {
+        @throw [NSException exceptionWithName:NSRangeException reason:@"Attempt to removeLastObject from 0" userInfo:nil];
+    }
+    count--;
+    tmp = ptrBuffer[count];
+    if ( tmp ) [tmp release];
+    ptrBuffer[count] = nil;
+}
+
+- (void)removeAllObjects
+{
+    id tmp;
+    if (count == 0) {
+        @throw [NSException exceptionWithName:NSRangeException reason:@"Attempt to removeAllObjects from 0" userInfo:nil];
+    }
+    int i;
+    for ( i = 0; i < BuffSize; i++ ) {
+        if (i < count) {
+            tmp = ptrBuffer[i];
+            if ( tmp ) [tmp release];
+        }
+        ptrBuffer[i] = nil;
+    }
+    count = 0;
+}
+
+- (void) replaceObjectAtIndex:(NSInteger)idx withObject:(id)obj
+{
+    id tmp;
+    if ( obj == nil ) obj = [NSNull null];
+    if ( idx < 0 || idx >= count ) {
+        @throw [NSException exceptionWithName:NSRangeException reason:@"Attempt to replace object past end" userInfo:nil];
+   }
+    if ( count ) {
+        [obj retain];
+        tmp = ptrBuffer[idx];
+        if ( tmp ) [tmp release];
+        ptrBuffer[idx] = obj;
+    }
+}
+
+- (NSInteger) count
+{
+    return count;
+}
+
+- (void) setCount:(NSInteger)cnt
+{
+    count = cnt;
+}
+
+- (NSArray *) allObjects
+{
+    return [NSArray arrayWithObjects:ptrBuffer count:count];
+}
+
+- (ArrayIterator *) objectEnumerator
+{
+    return [ArrayIterator newIterator:[self allObjects]];
+}
+
+// This is where all the magic happens.
+// You have two choices when implementing this method:
+// 1) Use the stack based array provided by stackbuf. If you do this, then you must respect the value of 'len'.
+// 2) Return your own array of objects. If you do this, return the full length of the array returned until you run out of objects, then return 0. For example, a linked-array implementation may return each array in order until you iterate through all arrays.
+// In either case, state->itemsPtr MUST be a valid array (non-nil). This sample takes approach #1, using stackbuf to store results.
+- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id *)stackbuf count:(NSUInteger)len
+{
+    NSUInteger cnt = 0;
+    // This is the initialization condition, so we'll do one-time setup here.
+    // Ensure that you never set state->state back to 0, or use another method to detect initialization
+    // (such as using one of the values of state->extra).
+    if (state->state == 0) {
+        // We are not tracking mutations, so we'll set state->mutationsPtr to point into one of our extra values,
+        // since these values are not otherwise used by the protocol.
+        // If your class was mutable, you may choose to use an internal variable that is updated when the class is mutated.
+        // state->mutationsPtr MUST NOT be NULL.
+        state->mutationsPtr = &state->extra[0];
+    }
+    // Now we provide items, which we track with state->state, and determine if we have finished iterating.
+    if (state->state < self.count) {
+        // Set state->itemsPtr to the provided buffer.
+        // Alternate implementations may set state->itemsPtr to an internal C array of objects.
+        // state->itemsPtr MUST NOT be NULL.
+        state->itemsPtr = stackbuf;
+        // Fill in the stack array, either until we've provided all items from the list
+        // or until we've provided as many items as the stack based buffer will hold.
+        while((state->state < self.count) && (cnt < len)) {
+            // For this sample, we generate the contents on the fly.
+            // A real implementation would likely just be copying objects from internal storage.
+            stackbuf[cnt++] = ptrBuffer[state->state++];
+        }
+        // state->state = ((cnt < len)? cnt : len);
+    }
+    else
+    {
+        // We've already provided all our items, so we signal we are done by returning 0.
+        cnt = 0;
+    }
+    return cnt;
+}
+
+- (NSString *) description
+{
+    NSMutableString *str;
+    NSInteger idx, cnt;
+    cnt = [self count];
+    str = [NSMutableString stringWithCapacity:30];
+    [str appendString:@"["];
+    for (idx = 0; idx < cnt; idx++ ) {
+        [str appendString:[[self objectAtIndex:idx] toString]];
+    }
+    [str appendString:@"]"];
+    return str;
+}
+
+- (NSString *) toString
+{
+    return [self description];
+}
+
+- (void) ensureCapacity:(NSInteger) index
+{
+	if ((index * sizeof(id)) >= [buffer length])
+	{
+		NSInteger newSize = ([buffer length] / sizeof(id)) * 2;
+		if (index > newSize) {
+			newSize = index + 1;
+		}
+        BuffSize = newSize;
+		[buffer setLength:(BuffSize * sizeof(id))];
+        ptrBuffer = [buffer mutableBytes];
+	}
+}
+
+- (void) dealloc
+{
+    if ( count ) [self removeAllObjects];
+    if ( buffer ) [buffer release];
+    [super dealloc];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/AMutableDictionary.h b/runtime/ObjC/Framework/AMutableDictionary.h
new file mode 100644
index 0000000..5bc8e46
--- /dev/null
+++ b/runtime/ObjC/Framework/AMutableDictionary.h
@@ -0,0 +1,59 @@
+//
+//  AMutableDictionary.h
+//  ST4
+//
+//  Created by Alan Condit on 4/18/11.
+//  Copyright 2011 Alan Condit. All rights reserved.
+//
+
+#import <Foundation/Foundation.h>
+#import "ACBTree.h"
+#import "ArrayIterator.h"
+
+@class ACBTree;
+@class ArrayIterator;
+
+@interface AMutableDictionary : NSMutableDictionary {
+
+    __strong ACBTree  *root;
+    NSInteger nodes_av;
+    NSInteger nodes_inuse;
+    NSInteger nxt_nodeid;
+    NSUInteger count;
+    __strong NSMutableData *data;
+    __strong id       *ptrBuffer;
+}
+
+@property (retain) ACBTree  *root;
+@property (assign) NSInteger nodes_av;
+@property (assign) NSInteger nodes_inuse;
+@property (assign) NSInteger nxt_nodeid;
+@property (assign, readonly, getter=count) NSUInteger count;
+@property (assign) NSMutableData *data;
+@property (assign) id       *ptrBuffer;
+
++ (AMutableDictionary *) newDictionary;
++ (AMutableDictionary *) dictionaryWithCapacity;
+
+- (id) init;
+- (id) initWithCapacity:(NSUInteger)numItems;
+
+- (BOOL) isEqual:(id)object;
+- (id) objectForKey:(id)aKey;
+- (void) setObject:(id)obj forKey:(id)aKey;
+- (void) removeObjectForKey:(id)aKey;
+
+- (NSUInteger) count;
+
+- (NSArray *) allKeys;
+- (NSArray *) allValues;
+- (ArrayIterator *) keyEnumerator;
+- (ArrayIterator *) objectEnumerator;
+
+- (void) clear;
+- (void) removeAllObjects;
+- (NSInteger) nextNodeId;
+- (NSArray *) toKeyArray;
+- (NSArray *) toValueArray;
+
+@end
diff --git a/runtime/ObjC/Framework/AMutableDictionary.m b/runtime/ObjC/Framework/AMutableDictionary.m
new file mode 100644
index 0000000..c349994
--- /dev/null
+++ b/runtime/ObjC/Framework/AMutableDictionary.m
@@ -0,0 +1,257 @@
+//
+//  AMutableDictionary.m
+//  ST4
+//
+//  Created by Alan Condit on 4/18/11.
+//  Copyright 2011 Alan Condit. All rights reserved.
+//
+
+#import <Cocoa/Cocoa.h>
+#import "AMutableDictionary.h"
+#import "ACBTree.h"
+
+@implementation AMutableDictionary
+
+@synthesize root;
+@synthesize nodes_av;
+@synthesize nodes_inuse;
+@synthesize nxt_nodeid;
+//@synthesize count;
+@synthesize data;
+@synthesize ptrBuffer;
+
++ (AMutableDictionary *) newDictionary
+{
+    return [[AMutableDictionary alloc] init];
+}
+
+/** dictionaryWithCapacity
+ *  capacity is meaningless to ACBTree because
+ *  capacity is automatically increased
+ */
++ (AMutableDictionary *) dictionaryWithCapacity
+{
+    return [[AMutableDictionary alloc] init];
+}
+
+- (id)init
+{
+    self = [super init];
+    if (self) {
+        // Initialization code here.
+        nxt_nodeid = 0;
+        count = 0;
+        root = [ACBTree newNodeWithDictionary:self];
+        root.nodeType = LEAF;
+        root.numrecs = 0;
+        root.updtd = NO;
+        root.lnodeid = 1;
+        root.lnode = nil;
+        root.rnodeid = 0xffff;
+        root.rnode = nil;
+    }
+    return self;
+}
+
+/** initWithCapacity
+ *  capacity is meaningless to ACBTree because
+ *  capacity is automatically increased
+ */
+- (id) initWithCapacity:(NSUInteger)numItems
+{
+    self = [super init];
+    if (self) {
+        // Initialization code here.
+        nxt_nodeid = 0;
+        count = 0;
+        root = [ACBTree newNodeWithDictionary:self];
+        root.nodeType = LEAF;
+        root.numrecs = 0;
+        root.updtd = NO;
+        root.lnodeid = 1;
+        root.lnode = nil;
+        root.rnodeid = 0xffff;
+        root.rnode = nil;
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+    if ( root ) [root release];
+    [super dealloc];
+}
+
+- (id) objectForKey:(id)aKey
+{
+    id obj = nil;
+    ACBTree *node;
+    ACBKey *kp;
+    NSInteger ret;
+    BOOL mustRelease = NO;
+
+    if ( [aKey isKindOfClass:[NSString class]] ) {
+        kp = [ACBKey newKeyWithKStr:aKey];
+        mustRelease = YES;
+    }
+    else if ( [aKey isKindOfClass:[ACBKey class]] ) {
+        kp = aKey;
+        //ACBKey *akey = [ACBKey newKey:aKey];
+    }
+    else {
+        @throw [NSException exceptionWithName:NSInvalidArgumentException
+                                       reason:[NSString stringWithFormat:@"What kind of key is this? %@", aKey]
+                                     userInfo:nil];
+        return nil; // not a key that I know how to deal with
+    }
+    node = [root search:kp.key];
+    if ( node != nil ) {
+        ret = [node searchnode:kp.key match:YES];
+        if ( ret >= 0 && ret < node.numkeys ) {
+            obj = node.btNodes[ret];
+            if ( obj == [NSNull null] )
+                obj = nil;
+        }
+    }
+    if ( mustRelease ) [kp release];
+    return obj;
+}
+
+- (void) setObject:(id)obj forKey:(id)aKey
+{
+    ACBKey *kp;
+    BOOL mustRelease = NO;
+    if ( [aKey isKindOfClass:[NSString class]] ) {
+        kp = [ACBKey newKeyWithKStr:aKey];
+        mustRelease = YES;
+    }
+    else if ( [aKey isKindOfClass:[ACBKey class]] ) {
+        kp = (ACBKey *)aKey;
+    }
+    else {
+        @throw [NSException exceptionWithName:NSInvalidArgumentException
+                                       reason:[NSString stringWithFormat:@"What kind of key is this? %@", aKey]
+                                     userInfo:nil];
+    }
+    if ( [root search:kp.key] == nil ) {
+        if ( obj == nil ) obj = [NSNull null];
+        root = [root insertkey:kp value:obj];
+        [kp retain];
+        [obj retain];
+        kp.recnum = count++;
+    }
+    else {
+        @throw [NSException exceptionWithName:NSInvalidArgumentException reason:@"key alreadyExists" userInfo:nil];
+    }
+    if ( mustRelease ) [kp release];
+    return;
+}
+
+- (BOOL) isEqual:(id)object
+{
+    return [super isEqual:object];
+}
+
+- (void) removeObjectForKey:(id)aKey
+{
+    if ( [root deletekey:aKey] == SUCCESS )
+        count--;
+}
+
+- (NSUInteger) count
+{
+    return count;
+}
+
+- (NSArray *) allKeys
+{
+    NSUInteger cnt = [root keyWalkLeaves];
+    return [NSArray arrayWithObjects:ptrBuffer count:cnt];
+}
+
+- (NSArray *) allValues
+{
+    NSUInteger cnt = [root objectWalkLeaves];
+    return [NSArray arrayWithObjects:ptrBuffer count:cnt];
+}
+
+- (ArrayIterator *) keyEnumerator
+{
+    return [ArrayIterator newIterator:[self allKeys]];
+}
+
+- (ArrayIterator *) objectEnumerator
+{
+    return [ArrayIterator newIterator:[self allValues]];
+}
+
+// This is where all the magic happens.
+// You have two choices when implementing this method:
+// 1) Use the stack based array provided by stackbuf. If you do this, then you must respect the value of 'len'.
+// 2) Return your own array of objects. If you do this, return the full length of the array returned until you run out of objects, then return 0. For example, a linked-array implementation may return each array in order until you iterate through all arrays.
+// In either case, state->itemsPtr MUST be a valid array (non-nil). This sample takes approach #1, using stackbuf to store results.
+- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id *)stackbuf count:(NSUInteger)len
+{
+    NSUInteger cnt = 0;
+    // This is the initialization condition, so we'll do one-time setup here.
+    // Ensure that you never set state->state back to 0, or use another method to detect initialization
+    // (such as using one of the values of state->extra).
+    if (state->state == 0) {
+        // We are not tracking mutations, so we'll set state->mutationsPtr to point into one of our extra values,
+        // since these values are not otherwise used by the protocol.
+        // If your class was mutable, you may choose to use an internal variable that is updated when the class is mutated.
+        // state->mutationsPtr MUST NOT be NULL.
+        state->mutationsPtr = &state->extra[0];
+        [self.root objectWalkLeaves];
+    }
+    // Now we provide items, which we track with state->state, and determine if we have finished iterating.
+    if (state->state < self.count) {
+        // Set state->itemsPtr to the provided buffer.
+        // Alternate implementations may set state->itemsPtr to an internal C array of objects.
+        // state->itemsPtr MUST NOT be NULL.
+        state->itemsPtr = stackbuf;
+        // Fill in the stack array, either until we've provided all items from the list
+        // or until we've provided as many items as the stack based buffer will hold.
+        while((state->state < self.count) && (cnt < len)) {
+            // For this sample, we generate the contents on the fly.
+            // A real implementation would likely just be copying objects from internal storage.
+            stackbuf[cnt++] = ptrBuffer[state->state++];
+        }
+        // state->state = ((cnt < len)? cnt : len);
+    }
+    else
+    {
+        // We've already provided all our items, so we signal we are done by returning 0.
+        cnt = 0;
+    }
+    return cnt;
+}
+
+- (void) clear
+{
+    if ( count ) [self removeAllObjects];
+}
+
+- (void) removeAllObjects
+{
+    root = [ACBTree newNodeWithDictionary:self];
+    root.nodeid = 0;
+    nxt_nodeid = 1;
+}
+
+- (NSInteger) nextNodeId
+{
+    return nxt_nodeid++;
+}
+
+- (NSArray *) toKeyArray
+{
+    return nil;
+}
+
+- (NSArray *) toValueArray
+{
+    return nil;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/ANTLR.h b/runtime/ObjC/Framework/ANTLR.h
index 0e6e37f..3dbc9e2 100644
--- a/runtime/ObjC/Framework/ANTLR.h
+++ b/runtime/ObjC/Framework/ANTLR.h
@@ -1,5 +1,5 @@
// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
+// Copyright (c) 2006-2007 Kay Roepke (c) 2011 Alan Condit
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
@@ -24,6 +24,9 @@
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

+#import <ANTLR/ACBTree.h>
+#import <ANTLR/AMutableArray.h>
+#import <ANTLR/AMutableDictionary.h>
#import <ANTLR/ANTLRBaseMapElement.h>
#import <ANTLR/ANTLRBaseRecognizer.h>
#import <ANTLR/ANTLRBaseStack.h>
@@ -107,3 +110,4 @@
//#import <ANTLR/ANTLRUnbufferedCommonTreeNodeStreamState.h>
#import <ANTLR/ANTLRUniqueIDMap.h>
#import <ANTLR/ANTLRUnwantedTokenException.h>
+#import <ANTLR/ArrayIterator.h>
diff --git a/runtime/ObjC/Framework/ANTLRBaseMapElement.h b/runtime/ObjC/Framework/ANTLRBaseMapElement.h
index b9100ac..0815165 100644
--- a/runtime/ObjC/Framework/ANTLRBaseMapElement.h
+++ b/runtime/ObjC/Framework/ANTLRBaseMapElement.h
@@ -36,7 +36,7 @@
NSNumber *index;
}

-@property (retain, getter=getIndex, setter=setIndex:) NSNumber *index;
+@property (retain) NSNumber *index;

+ (id) newANTLRBaseMapElement;
+ (id) newANTLRBaseMapElementWithIndex:(NSNumber *)anIdx;
@@ -45,9 +45,6 @@

- (id) copyWithZone:(NSZone *)aZone;

-- (NSNumber *)getIndex;
-- (void)setIndex:(NSNumber *)anIdx;
-
- (NSInteger)count;
- (NSInteger)size;

diff --git a/runtime/ObjC/Framework/ANTLRBaseMapElement.m b/runtime/ObjC/Framework/ANTLRBaseMapElement.m
index cacc24d..4ce706a 100644
--- a/runtime/ObjC/Framework/ANTLRBaseMapElement.m
+++ b/runtime/ObjC/Framework/ANTLRBaseMapElement.m
@@ -72,17 +72,6 @@
return( copy );
}

-- (id)getIndex
-{
-    return index;
-}
-
-- (void)setIndex:(id)anIdx
-{
-    [anIdx retain];
-    index = anIdx;
-}
-
- (NSInteger)count
{
return 1;
diff --git a/runtime/ObjC/Framework/ANTLRBaseRecognizer.h b/runtime/ObjC/Framework/ANTLRBaseRecognizer.h
index 669bec8..19d5dd7 100644
--- a/runtime/ObjC/Framework/ANTLRBaseRecognizer.h
+++ b/runtime/ObjC/Framework/ANTLRBaseRecognizer.h
@@ -29,6 +29,7 @@
#import <Foundation/Foundation.h>

#import "ANTLRIntStream.h"
+#import "AMutableArray.h"

// This is an abstract superclass for lexers and parsers.

@@ -52,10 +53,10 @@
#import "ANTLRFailedPredicateException.h"

@interface ANTLRBaseRecognizer : NSObject {
-	ANTLRRecognizerSharedState *state;	// the state of this recognizer. Might be shared with other recognizers, e.g. in grammar import scenarios.
-	NSString *grammarFileName;			// where did the grammar come from. filled in by codegeneration
+    ANTLRRecognizerSharedState *state;  // the state of this recognizer. Might be shared with other recognizers, e.g. in grammar import scenarios.
+    NSString *grammarFileName;          // where did the grammar come from. filled in by codegeneration
NSString *sourceName;
-    NSMutableArray *tokenNames;
+    AMutableArray *tokenNames;
}

+ (void) initialize;
@@ -64,7 +65,7 @@
+ (ANTLRBaseRecognizer *) newANTLRBaseRecognizerWithRuleLen:(NSInteger)aLen;
+ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer:(ANTLRRecognizerSharedState *)aState;

-+ (NSMutableArray *)getTokenNames;
++ (AMutableArray *)getTokenNames;
+ (void)setTokenNames:(NSArray *)aTokNamArray;
+ (void)setGrammarFileName:(NSString *)aFileName;

@@ -108,8 +109,8 @@

// error reporting and recovery
- (void) reportError:(ANTLRRecognitionException *)e;
-- (void) displayRecognitionError:(NSMutableArray *)theTokNams Exception:(ANTLRRecognitionException *)e;
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(NSMutableArray *)theTokNams;
+- (void) displayRecognitionError:(AMutableArray *)theTokNams Exception:(ANTLRRecognitionException *)e;
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)theTokNams;
- (NSInteger) getNumberOfSyntaxErrors;
- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e;
- (NSString *)getTokenErrorDisplay:(id<ANTLRToken>)t;
@@ -147,20 +148,20 @@
- (ANTLRBitSet *)popFollow;

// to be used by the debugger to do reporting. maybe hook in incremental stuff here, too.
-- (NSMutableArray *) getRuleInvocationStack;
-- (NSMutableArray *) getRuleInvocationStack:(ANTLRRecognitionException *)exception
-					             Recognizer:(NSString *)recognizerClassName;
+- (AMutableArray *) getRuleInvocationStack;
+- (AMutableArray *) getRuleInvocationStack:(ANTLRRecognitionException *)exception
+                                 Recognizer:(NSString *)recognizerClassName;

-- (NSMutableArray *) getTokenNames;
+- (AMutableArray *) getTokenNames;
- (NSString *)getGrammarFileName;
- (NSString *)getSourceName;
-- (NSMutableArray *) toStrings:(NSArray *)tokens;
+- (AMutableArray *) toStrings:(NSArray *)tokens;
// support for memoization
- (NSInteger) getRuleMemoization:(NSInteger)ruleIndex StartIndex:(NSInteger)ruleStartIndex;
- (BOOL) alreadyParsedRule:(id<ANTLRIntStream>)anInput RuleIndex:(NSInteger)ruleIndex;
- (void) memoize:(id<ANTLRIntStream>)anInput
-	     RuleIndex:(NSInteger)ruleIndex
-	    StartIndex:(NSInteger)ruleStartIndex;
+         RuleIndex:(NSInteger)ruleIndex
+        StartIndex:(NSInteger)ruleStartIndex;
- (NSInteger) getRuleMemoizationCacheSize;
- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol;
- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol;
@@ -174,6 +175,6 @@
@property (retain) ANTLRRecognizerSharedState *state;
@property (retain) NSString *grammarFileName;
@property (retain) NSString *sourceName;
-@property (retain) NSMutableArray *tokenNames;
+@property (retain) AMutableArray *tokenNames;

@end
diff --git a/runtime/ObjC/Framework/ANTLRBaseRecognizer.m b/runtime/ObjC/Framework/ANTLRBaseRecognizer.m
index fc20cdf..09a1528 100644
--- a/runtime/ObjC/Framework/ANTLRBaseRecognizer.m
+++ b/runtime/ObjC/Framework/ANTLRBaseRecognizer.m
@@ -39,7 +39,7 @@ extern NSInteger debug;

@implementation ANTLRBaseRecognizer

-static NSMutableArray *_tokenNames;
+static AMutableArray *_tokenNames;
static NSString *_grammarFileName;
static NSString *NEXT_TOKEN_RULE_NAME;

@@ -71,12 +71,12 @@ static NSString *NEXT_TOKEN_RULE_NAME;
return [[ANTLRBaseRecognizer alloc] initWithState:aState];
}

-+ (NSMutableArray *)getTokenNames
++ (AMutableArray *)getTokenNames
{
return _tokenNames;
}

-+ (void)setTokenNames:(NSMutableArray *)theTokNams
++ (void)setTokenNames:(AMutableArray *)theTokNams
{
_tokenNames = theTokNams;
[_tokenNames retain];
@@ -159,8 +159,10 @@ static NSString *NEXT_TOKEN_RULE_NAME;
{
if ( state == nil )
return;
-    if ( state.following != nil )
-        [state.following removeAllObjects];
+    if ( state.following != nil ) {
+        if ( [state.following count] )
+            [state.following removeAllObjects];
+    }
state._fsp = -1;
state.errorRecovery = NO;		// are we recovering?
state.lastErrorIndex = -1;
@@ -168,8 +170,10 @@ static NSString *NEXT_TOKEN_RULE_NAME;
state.syntaxErrors = 0;
state.backtracking = 0;			// the level of backtracking
state.tokenStartCharIndex = -1;
-    if ( state.ruleMemo != nil )
-        [state.ruleMemo removeAllObjects];
+    if ( state.ruleMemo != nil ) {
+        if ( [state.ruleMemo count] )
+            [state.ruleMemo removeAllObjects];
+    }
}

- (BOOL) getFailed
@@ -190,9 +194,9 @@ static NSString *NEXT_TOKEN_RULE_NAME;
- (void) setState:(ANTLRRecognizerSharedState *) theState
{
if (state != theState) {
-		[state release];
-		[theState retain];
+		if ( state ) [state release];
state = theState;
+		[state retain];
}
}

@@ -296,7 +300,7 @@ static NSString *NEXT_TOKEN_RULE_NAME;
[self displayRecognitionError:[self getTokenNames] Exception:e];
}

--(void) displayRecognitionError:(NSMutableArray *)theTokNams Exception:(ANTLRRecognitionException *)e
+-(void) displayRecognitionError:(AMutableArray *)theTokNams Exception:(ANTLRRecognitionException *)e
{
NSString *hdr = [self getErrorHeader:e];
NSString *msg = [self getErrorMessage:e TokenNames:theTokNams];
@@ -325,7 +329,7 @@ static NSString *NEXT_TOKEN_RULE_NAME;
*  Override this to change the message generated for one or more
*  exception types.
*/
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(NSMutableArray *)theTokNams
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)theTokNams
{
NSString *msg = [e getMessage];
if ( [e isKindOfClass:[ANTLRUnwantedTokenException class]] ) {
@@ -466,14 +470,14 @@ static NSString *NEXT_TOKEN_RULE_NAME;
*/
- (void)recover:(id<ANTLRIntStream>)anInput Exception:(ANTLRRecognitionException *)re
{
-    if ( state.lastErrorIndex == [anInput getIndex] ) {
+    if ( state.lastErrorIndex == anInput.index ) {
// uh oh, another error at same token index; must be a case
// where LT(1) is in the recovery token set so nothing is
// consumed; consume a single token so at least to prevent
// an infinite loop; this is a failsafe.
[anInput consume];
}
-    state.lastErrorIndex = [anInput getIndex];
+    state.lastErrorIndex = anInput.index;
ANTLRBitSet *followSet = [self computeErrorRecoverySet];
[self beginResync];
[self consumeUntilFollow:anInput Follow:followSet];
@@ -821,7 +825,7 @@ static NSString *NEXT_TOKEN_RULE_NAME;
- (void)pushFollow:(ANTLRBitSet *)fset
{
if ( (state._fsp +1) >= [state.following count] ) {
-        //        NSMutableArray *f = [NSMutableArray arrayWithCapacity:[[state.following] count]*2];
+        //        AMutableArray *f = [AMutableArray arrayWithCapacity:[[state.following] count]*2];
//        System.arraycopy(state.following, 0, f, 0, state.following.length);
//        state.following = f;
[state.following addObject:fset];
@@ -857,7 +861,7 @@ static NSString *NEXT_TOKEN_RULE_NAME;
*  This is very useful for error messages and for context-sensitive
*  error recovery.
*/
-- (NSMutableArray *)getRuleInvocationStack
+- (AMutableArray *)getRuleInvocationStack
{
NSString *parserClassName = [[self className] retain];
return [self getRuleInvocationStack:[ANTLRRecognitionException newException] Recognizer:parserClassName];
@@ -870,11 +874,11 @@ static NSString *NEXT_TOKEN_RULE_NAME;
*
*  TODO: move to a utility class or something; weird having lexer call this
*/
-- (NSMutableArray *)getRuleInvocationStack:(ANTLRRecognitionException *)e
+- (AMutableArray *)getRuleInvocationStack:(ANTLRRecognitionException *)e
Recognizer:(NSString *)recognizerClassName
{
// char *name;
-    NSMutableArray *rules = [[NSMutableArray arrayWithCapacity:20] retain];
+    AMutableArray *rules = [[AMutableArray arrayWithCapacity:20] retain];
NSArray *stack = [e callStackSymbols];
int i = 0;
for (i = [stack count]-1; i >= 0; i--) {
@@ -951,15 +955,15 @@ static NSString *NEXT_TOKEN_RULE_NAME;
/** A convenience method for use most often with template rewrites.
*  Convert a List<Token> to List<String>
*/
-- (NSMutableArray *)toStrings:(NSMutableArray *)tokens
+- (AMutableArray *)toStrings:(AMutableArray *)tokens
{
if ( tokens == nil )
return nil;
-    NSMutableArray *strings = [[NSMutableArray arrayWithCapacity:[tokens count]] retain];
+    AMutableArray *strings = [[AMutableArray arrayWithCapacity:[tokens count]] retain];
id object;
NSInteger i = 0;
for (object in tokens) {
-        [strings addObject:[[object getText] retain]];
+        [strings addObject:[[object text] retain]];
i++;
}
return strings;
@@ -1001,7 +1005,7 @@ static NSString *NEXT_TOKEN_RULE_NAME;
*/
- (BOOL)alreadyParsedRule:(id<ANTLRIntStream>)anInput RuleIndex:(NSInteger)ruleIndex
{
-    NSInteger aStopIndex = [self getRuleMemoization:ruleIndex StartIndex:[anInput getIndex]];
+    NSInteger aStopIndex = [self getRuleMemoization:ruleIndex StartIndex:anInput.index];
if ( aStopIndex == ANTLR_MEMO_RULE_UNKNOWN ) {
// NSLog(@"rule %d not yet encountered\n", ruleIndex);
return NO;
@@ -1028,7 +1032,7 @@ static NSString *NEXT_TOKEN_RULE_NAME;
NSInteger stopTokenIndex;

aRuleStack = state.ruleMemo;
-    stopTokenIndex = (state.failed ? ANTLR_MEMO_RULE_FAILED : ([anInput getIndex]-1));
+    stopTokenIndex = (state.failed ? ANTLR_MEMO_RULE_FAILED : (anInput.index-1));
if ( aRuleStack == nil ) {
if (debug) NSLog(@"!!!!!!!!! memo array is nil for %@", [self getGrammarFileName]);
return;
diff --git a/runtime/ObjC/Framework/ANTLRBaseStack.h b/runtime/ObjC/Framework/ANTLRBaseStack.h
index 5a4e566..2356178 100644
--- a/runtime/ObjC/Framework/ANTLRBaseStack.h
+++ b/runtime/ObjC/Framework/ANTLRBaseStack.h
@@ -56,8 +56,8 @@
// Instance Methods
- (id) copyWithZone:(NSZone *)aZone;

-- (NSInteger)count;
-- (NSInteger)size;
+- (NSUInteger)count;
+- (NSUInteger)size;
/* clear -- reinitialize the maplist array */

- (NSInteger)getLastHash;
diff --git a/runtime/ObjC/Framework/ANTLRBaseStack.m b/runtime/ObjC/Framework/ANTLRBaseStack.m
index 77eb77a..ba11bb7 100644
--- a/runtime/ObjC/Framework/ANTLRBaseStack.m
+++ b/runtime/ObjC/Framework/ANTLRBaseStack.m
@@ -79,9 +79,9 @@
return copy;
}

-- (NSInteger)count
+- (NSUInteger)count
{
-    NSInteger aCnt = 0;
+    NSUInteger aCnt = 0;

for (int i = 0; i < BuffSize; i++) {
if (ptrBuffer[i] != nil) {
@@ -91,7 +91,7 @@
return aCnt;
}

-- (NSInteger) size
+- (NSUInteger) size
{
return BuffSize;
}
@@ -107,7 +107,7 @@
while ( tmp ) {
rtmp = tmp;
tmp = [tmp getfNext];
-                [rtmp dealloc];
+                [rtmp release];
}
}
}
diff --git a/runtime/ObjC/Framework/ANTLRBaseTree.h b/runtime/ObjC/Framework/ANTLRBaseTree.h
index 3514bbe..1cc3f5f 100755
--- a/runtime/ObjC/Framework/ANTLRBaseTree.h
+++ b/runtime/ObjC/Framework/ANTLRBaseTree.h
@@ -26,6 +26,7 @@

#import "ANTLRTree.h"
#import "ANTLRCommonToken.h"
+#import "AMutableArray.h"

@protocol ANTLRBaseTree <ANTLRTree>

@@ -38,8 +39,8 @@
- (id<ANTLRBaseTree>) initWith:(id<ANTLRBaseTree>)node;

- (id<ANTLRBaseTree>) getChild:(NSUInteger)i;
-- (NSMutableArray *)getChildren;
-- (void) setChildren:(NSMutableArray *)anArray;
+- (AMutableArray *)getChildren;
+- (void) setChildren:(AMutableArray *)anArray;
- (id<ANTLRBaseTree>)getFirstChildWithType:(NSInteger)type;
- (NSUInteger) getChildCount;

@@ -52,7 +53,7 @@

- (void) setChild:(NSInteger) i With:(id<ANTLRBaseTree>)t;
- (id) deleteChild:(NSInteger) i;
-- (NSMutableArray *) createChildrenList;
+- (AMutableArray *) createChildrenList;
- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
// Indicates the node is a nil node but may still have children, meaning
// the tree is a flat list.
@@ -72,7 +73,7 @@
- (void) setChildIndex:(NSInteger)i;

- (id<ANTLRBaseTree>)getAncestor:(NSInteger)ttype;
-- (NSMutableArray *)getAncestors;
+- (AMutableArray *)getAncestors;

#pragma mark Copying
- (id) copyWithZone:(NSZone *)aZone;	// the children themselves are not copied here!
@@ -81,10 +82,10 @@

#pragma mark Tree Parser support
- (NSInteger) getType;
-- (NSString *) getText;
+- (NSString *) text;
// In case we don't have a token payload, what is the line for errors?
-- (NSInteger) getLine;
-- (NSInteger) getCharPositionInLine;
+- (NSUInteger) line;
+- (NSUInteger) charPositionInLine;


#pragma mark Informational
@@ -94,24 +95,14 @@
- (NSString *) toString;
- (NSString *) toStringTree;

-@property (retain) id<ANTLRToken>token;
-@property (assign) NSInteger startIndex;
-@property (assign) NSInteger stopIndex;
-@property (retain) id<ANTLRBaseTree> parent;
-@property (assign) NSInteger childIndex;
-@property (retain) NSMutableArray *children;
+@property (retain) AMutableArray *children;
@property (retain) NSException *anException;

@end

@interface ANTLRBaseTree : NSObject <ANTLRTree>
{
-	ANTLRCommonToken *token;
-	NSInteger startIndex;
-	NSInteger stopIndex;
-    id<ANTLRBaseTree> parent;
-    NSInteger childIndex;
-	NSMutableArray *children;
+	AMutableArray *children;
NSException *anException;
}

@@ -123,8 +114,8 @@
- (id<ANTLRBaseTree>) initWith:(id<ANTLRBaseTree>)node;

- (id<ANTLRBaseTree>) getChild:(NSUInteger)i;
-- (NSMutableArray *)getChildren;
-- (void) setChildren:(NSMutableArray *)anArray;
+- (AMutableArray *)getChildren;
+- (void) setChildren:(AMutableArray *)anArray;
- (id<ANTLRBaseTree>)getFirstChildWithType:(NSInteger)type;
- (NSUInteger) getChildCount;

@@ -138,7 +129,7 @@

- (void) setChild:(NSUInteger) i With:(id<ANTLRBaseTree>)t;
- (id) deleteChild:(NSUInteger) idx;
-- (NSMutableArray *) createChildrenList;
+- (AMutableArray *) createChildrenList;
- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
// Indicates the node is a nil node but may still have children, meaning
// the tree is a flat list.
@@ -159,7 +150,7 @@

- (BOOL) hasAncestor:(NSInteger) ttype;
- (id<ANTLRBaseTree>)getAncestor:(NSInteger)ttype;
-- (NSMutableArray *)getAncestors;
+- (AMutableArray *)getAncestors;

- (id) copyWithZone:(NSZone *)aZone;
- (id) deepCopy;					// performs a deepCopyWithZone: with the default zone
@@ -167,25 +158,19 @@

// Return a token type; needed for tree parsing
- (NSInteger) getType;
-- (NSString *) getText;
+- (NSString *) text;

// In case we don't have a token payload, what is the line for errors?
-- (NSInteger) getLine;
-- (NSInteger) getCharPositionInLine;
-- (void) setCharPositionInLine:(NSInteger)pos;
+- (NSUInteger) line;
+- (NSUInteger) charPositionInLine;
+- (void) setCharPositionInLine:(NSUInteger)pos;

- (NSString *) treeDescription;
- (NSString *) description;
- (NSString *) toString;
- (NSString *) toStringTree;

-@property (retain) ANTLRCommonToken *token;
-@property (assign) NSInteger startIndex;
-@property (assign) NSInteger stopIndex;
-@property (retain) id<ANTLRBaseTree> parent;
-@property (assign) NSInteger childIndex;
-
-@property (retain) NSMutableArray *children;
+@property (retain) AMutableArray *children;
@property (retain) NSException *anException;

@end
diff --git a/runtime/ObjC/Framework/ANTLRBaseTree.m b/runtime/ObjC/Framework/ANTLRBaseTree.m
index 97c3f03..ae10e76 100755
--- a/runtime/ObjC/Framework/ANTLRBaseTree.m
+++ b/runtime/ObjC/Framework/ANTLRBaseTree.m
@@ -97,7 +97,7 @@ static id<ANTLRBaseTree> invalidNode = nil;

- (void) dealloc
{
-	[children release];
+	if ( children ) [children release];
children = nil;
[super dealloc];
}
@@ -113,12 +113,12 @@ static id<ANTLRBaseTree> invalidNode = nil;
/** Get the children internal List; note that if you directly mess with
*  the list, do so at your own risk.
*/
-- (NSMutableArray *) getChildren
+- (AMutableArray *) getChildren
{
return children; // [[children retain] autorelease];
}

-- (void) setChildren:(NSMutableArray *)anArray
+- (void) setChildren:(AMutableArray *)anArray
{
children = anArray;
}
@@ -184,7 +184,7 @@ static id<ANTLRBaseTree> invalidNode = nil;
}
else { // child is not nil (don't care about children)
if ( children == nil ) {
-            children = [NSMutableArray arrayWithCapacity:5]; // create children list on demand
+            children = [AMutableArray arrayWithCapacity:5]; // create children list on demand
}
[children addObject:t];
[childTree setParent:(id<ANTLRBaseTree>)self];
@@ -194,7 +194,7 @@ static id<ANTLRBaseTree> invalidNode = nil;
}

/** Add all elements of kids list as children of this node */
-- (void) addChildren:(NSMutableArray *) kids
+- (void) addChildren:(AMutableArray *) kids
{
for (NSUInteger i = 0; i < [kids count]; i++) {
id<ANTLRBaseTree> t = (id<ANTLRBaseTree>) [kids objectAtIndex:i];
@@ -211,7 +211,7 @@ static id<ANTLRBaseTree> invalidNode = nil;
@throw [ANTLRIllegalArgumentException newException:@"ANTLRBaseTree Can't set single child to a list"];
}
if ( children == nil ) {
-        children = [NSMutableArray arrayWithCapacity:5];
+        children = [AMutableArray arrayWithCapacity:5];
}
if ([children count] > i ) {
[children replaceObjectAtIndex:i withObject:t];
@@ -253,13 +253,13 @@ static id<ANTLRBaseTree> invalidNode = nil;
int replacingHowMany = stopChildIndex - startChildIndex + 1;
int replacingWithHowMany;
id<ANTLRBaseTree> newTree = (id<ANTLRBaseTree>) t;
-    NSMutableArray *newChildren = nil;
+    AMutableArray *newChildren = nil;
// normalize to a list of children to add: newChildren
if ( [newTree isNil] ) {
newChildren = newTree.children;
}
else {
-        newChildren = [NSMutableArray arrayWithCapacity:5];
+        newChildren = [AMutableArray arrayWithCapacity:5];
[newChildren addObject:newTree];
}
replacingWithHowMany = [newChildren count];
@@ -303,9 +303,9 @@ static id<ANTLRBaseTree> invalidNode = nil;
}

/** Override in a subclass to change the impl of children list */
-- (NSMutableArray *) createChildrenList
+- (AMutableArray *) createChildrenList
{
-    return [NSMutableArray arrayWithCapacity:5];
+    return [AMutableArray arrayWithCapacity:5];
}

- (BOOL) isNil
@@ -336,8 +336,8 @@ static id<ANTLRBaseTree> invalidNode = nil;

- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>)aParent At:(NSInteger) i
{
-    if ( aParent != self.parent ) {
-        @throw [ANTLRIllegalStateException newException:[NSString stringWithFormat:@"parents don't match; expected %s found %s", aParent, self.parent]];
+    if ( aParent != [self getParent] ) {
+        @throw [ANTLRIllegalStateException newException:[NSString stringWithFormat:@"parents don't match; expected %s found %s", aParent, [self getParent]]];
}
if ( i != [self getChildIndex] ) {
@throw [ANTLRIllegalStateException newException:[NSString stringWithFormat:@"child indexes don't match; expected %d found %d", i, [self getChildIndex]]];
@@ -421,11 +421,11 @@ static id<ANTLRBaseTree> invalidNode = nil;
/** Return a list of all ancestors of this node.  The first node of
*  list is the root and the last is the parent of this node.
*/
-- (NSMutableArray *)getAncestors
+- (AMutableArray *)getAncestors
{
if ( [self getParent] == nil )
return nil;
-    NSMutableArray *ancestors = [NSMutableArray arrayWithCapacity:5];
+    AMutableArray *ancestors = [AMutableArray arrayWithCapacity:5];
id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)self;
t = (id<ANTLRBaseTree>)[t getParent];
while ( t != nil ) {
@@ -441,22 +441,22 @@ static id<ANTLRBaseTree> invalidNode = nil;
return ANTLRTokenTypeInvalid;
}

-- (NSString *) getText
+- (NSString *) text
{
return nil;
}

-- (NSInteger) getLine
+- (NSUInteger) line
{
return 0;
}

-- (NSInteger) getCharPositionInLine
+- (NSUInteger) charPositionInLine
{
return 0;
}

-- (void) setCharPositionInLine:(NSInteger) pos
+- (void) setCharPositionInLine:(NSUInteger) pos
{
}

@@ -479,13 +479,14 @@ static id<ANTLRBaseTree> invalidNode = nil;
{
id<ANTLRBaseTree> theCopy = [self copyWithZone:aZone];

-    [theCopy.children removeAllObjects];
-    NSMutableArray *childrenCopy = theCopy.children;
+    if ( [theCopy.children count] )
+        [theCopy.children removeAllObjects];
+    AMutableArray *childrenCopy = theCopy.children;
for (id loopItem in children) {
id<ANTLRBaseTree> childCopy = [loopItem deepCopyWithZone:aZone];
[theCopy addChild:childCopy];
}
-    [childrenCopy release];
+    if ( childrenCopy ) [childrenCopy release];
return theCopy;
}

@@ -530,11 +531,6 @@ static id<ANTLRBaseTree> invalidNode = nil;
return nil;
}

-@synthesize token;
-@synthesize startIndex;
-@synthesize stopIndex;
-@synthesize parent;
-@synthesize childIndex;
@synthesize children;
@synthesize anException;

diff --git a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.h b/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.h
index 65a3d3e..562e16d 100644
--- a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.h
+++ b/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.h
@@ -119,6 +119,8 @@

- (void) setType:(id<ANTLRBaseTree>)aTree Type:(NSInteger)type;

+- (id<ANTLRToken>)getToken:(ANTLRCommonTree *)t;
+
- (NSString *)getText:(id<ANTLRBaseTree>)aTree;

- (void) setText:(id<ANTLRBaseTree>)aTree Text:(NSString *)theText;
@@ -131,6 +133,10 @@

- (NSInteger) getChildCount:(id<ANTLRBaseTree>)aTree;

+- (id<ANTLRBaseTree>) getParent:(id<ANTLRBaseTree>) t;
+
+- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>) parent;
+
- (NSInteger) getUniqueID:(id<ANTLRBaseTree>)node;

#ifdef DONTUSENOMO
diff --git a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m b/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m
index 6f208f4..1701d1f 100644
--- a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m
+++ b/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m
@@ -93,39 +93,39 @@
Exception:e];
}

-- (BOOL) isNil:(id<ANTLRBaseTree>) tree
+- (BOOL) isNil:(id) tree
{
-    return [(id<ANTLRBaseTree>)tree isNil];
+    return [(id)tree isNil];
}

-- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)tree
+- (id)dupTree:(id)tree
{
-    return [self dupTree:(id<ANTLRBaseTree>)tree Parent:nil];
+    return [self dupTree:(id)tree Parent:nil];
}

/** This is generic in the sense that it will work with any kind of
*  tree (not just Tree interface).  It invokes the adaptor routines
*  not the tree node routines to do the construction.
*/
-- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)t Parent:(id<ANTLRBaseTree>)parent
+- (id)dupTree:(id)t Parent:(id)parent
{
if ( t==nil ) {
return nil;
}
-    id<ANTLRBaseTree>newTree = [self dupNode:t];
+    id newTree = [self dupNode:t];
// ensure new subtree root has parent/child index set
[self setChildIndex:newTree With:[self getChildIndex:t]]; // same index in new tree
[self setParent:newTree With:parent];
NSInteger n = [self getChildCount:t];
for (NSInteger i = 0; i < n; i++) {
-        id<ANTLRBaseTree> child = [self getChild:t At:i];
-        id<ANTLRBaseTree> newSubTree = [self dupTree:child Parent:t];
+        id child = [self getChild:t At:i];
+        id newSubTree = [self dupTree:child Parent:t];
[self addChild:newSubTree toTree:newTree];
}
return newTree;
}

-- (id<ANTLRBaseTree>)dupNode:(id<ANTLRBaseTree>)aNode
+- (id)dupNode:(id)aNode
{
return aNode; // override for better results :>)
}
@@ -136,10 +136,10 @@
*  make sure that this is consistent with have the user will build
*  ASTs.
*/
-- (void) addChild:(id<ANTLRBaseTree>)child toTree:(id<ANTLRBaseTree>)t
+- (void) addChild:(id)child toTree:(id)t
{
if ( t != nil && child != nil ) {
-        [(id<ANTLRBaseTree>)t addChild:[(id<ANTLRBaseTree>)child retain]];
+        [(id)t addChild:[(id)child retain]];
}
}

@@ -169,18 +169,18 @@
*  constructing these nodes so we should have this control for
*  efficiency.
*/
-- (id<ANTLRBaseTree>)becomeRoot:(id<ANTLRBaseTree>)newRoot old:(id<ANTLRBaseTree>)oldRoot
+- (id)becomeRoot:(id)newRoot old:(id)oldRoot
{
if ( oldRoot == nil ) {
return newRoot;
}
//System.out.println("becomeroot new "+newRoot.toString()+" old "+oldRoot);
-    id<ANTLRBaseTree> newRootTree = (id<ANTLRBaseTree>)newRoot;
-    id<ANTLRBaseTree> oldRootTree = (id<ANTLRBaseTree>)oldRoot;
+    id newRootTree = (id)newRoot;
+    id oldRootTree = (id)oldRoot;
// handle ^(nil real-node)
if ( [newRootTree isNil] ) {
NSInteger nc = [newRootTree getChildCount];
-        if ( nc == 1 ) newRootTree = [(id<ANTLRBaseTree>)newRootTree getChild:0];
+        if ( nc == 1 ) newRootTree = [(id)newRootTree getChild:0];
else if ( nc > 1 ) {
// TODO: make tree run time exceptions hierarchy
@throw [ANTLRRuntimeException newException:NSStringFromClass([self class]) reason:@"more than one node as root (TODO: make exception hierarchy)"];
@@ -194,16 +194,16 @@
}

/** Transform ^(nil x) to x and nil to null */
-- (id<ANTLRBaseTree>)rulePostProcessing:(id<ANTLRBaseTree>)root
+- (id)rulePostProcessing:(id)root
{
//System.out.println("rulePostProcessing: "+((Tree)root).toStringTree());
-    id<ANTLRBaseTree> r = (id<ANTLRBaseTree>)root;
+    id r = (id)root;
if ( r != nil && [r isNil] ) {
if ( [r getChildCount] == 0 ) {
r = nil;
}
else if ( [r getChildCount] == 1 ) {
-            r = (id<ANTLRBaseTree>)[r getChild:0];
+            r = (id)[r getChild:0];
// whoever invokes rule will set parent and child index
[r setParent:nil];
[r setChildIndex:-1];
@@ -212,84 +212,109 @@
return r;
}

-- (id<ANTLRBaseTree>)becomeRootfromToken:(id<ANTLRToken>)newRoot old:(id<ANTLRBaseTree>)oldRoot
+- (id)becomeRootfromToken:(id<ANTLRToken>)newRoot old:(id)oldRoot
{
-    return [self becomeRoot:(id<ANTLRToken>)[self create:newRoot] old:oldRoot];
+    return [self becomeRoot:(id)[self create:newRoot] old:oldRoot];
}

-- (id<ANTLRBaseTree>) create:(id<ANTLRToken>)aToken
+- (id) create:(id<ANTLRToken>)aToken
{
return [ANTLRCommonTree newTreeWithToken:aToken];
}

-- (id<ANTLRBaseTree>)createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken
+- (id)createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken
{
fromToken = [self createToken:fromToken];
//((ClassicToken)fromToken).setType(tokenType);
[fromToken setType:tokenType];
-    id<ANTLRBaseTree> t = [self create:fromToken];
+    id t = [self create:fromToken];
return t;
}

-- (id<ANTLRBaseTree>)createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text
+- (id)createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text
{
if (fromToken == nil)
return [self createTree:tokenType Text:text];
fromToken = [self createToken:fromToken];
[fromToken setType:tokenType];
[fromToken setText:text];
-    id<ANTLRBaseTree>t = [self create:fromToken];
+    id t = [self create:fromToken];
return t;
}

-- (id<ANTLRBaseTree>)createTree:(NSInteger)tokenType Text:(NSString *)text
+- (id)createTree:(NSInteger)tokenType Text:(NSString *)text
{
id<ANTLRToken> fromToken = [self createToken:tokenType Text:text];
-    id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)[self create:fromToken];
+    id t = (id)[self create:fromToken];
return t;
}

-- (NSInteger) getType:(id<ANTLRBaseTree>) t
+- (NSInteger) getType:(id) t
{
-    return [(id<ANTLRBaseTree>)t getType];
+    return [(id)t getType];
}

-- (void) setType:(id<ANTLRBaseTree>)t Type:(NSInteger)type
+- (void) setType:(id)t Type:(NSInteger)type
{
@throw [ANTLRNoSuchElementException newException:@"don't know enough about Tree node"];
}

-- (NSString *)getText:(id<ANTLRBaseTree>)t
+/** What is the Token associated with this node?  If
+ *  you are not using ANTLRCommonTree, then you must
+ *  override this in your own adaptor.
+ */
+- (id<ANTLRToken>) getToken:(ANTLRCommonTree *) t
+{
+    if ( [t isKindOfClass:[ANTLRCommonTree class]] ) {
+        return [t getToken];
+    }
+    return nil; // no idea what to do
+}
+
+- (NSString *)getText:(id)t
{
-    return [(id<ANTLRBaseTree>)t getText];
+    return [(id)t text];
}

-- (void) setText:(id<ANTLRBaseTree>)t Text:(NSString *)text
+- (void) setText:(id)t Text:(NSString *)text
{
@throw [ANTLRNoSuchElementException newException:@"don't know enough about Tree node"];
}

-- (id<ANTLRBaseTree>) getChild:(id<ANTLRBaseTree>)t At:(NSInteger)index
+- (id) getChild:(id)t At:(NSInteger)index
+{
+    return [(id)t getChild:index ];
+}
+
+- (void) setChild:(id)t At:(NSInteger)index Child:(id)child
+{
+    [(id)t setChild:index With:(id)child];
+}
+
+- (id) deleteChild:(id)t Index:(NSInteger)index
{
-    return [(id<ANTLRBaseTree>)t getChild:index ];
+    return [(id)t deleteChild:index];
}

-- (void) setChild:(id<ANTLRBaseTree>)t At:(NSInteger)index Child:(id<ANTLRBaseTree>)child
+- (NSInteger) getChildCount:(id)t
{
-    [(id<ANTLRBaseTree>)t setChild:index With:(id<ANTLRBaseTree>)child];
+    return [(id)t getChildCount];
}

-- (id<ANTLRBaseTree>) deleteChild:(id<ANTLRBaseTree>)t Index:(NSInteger)index
+- (id<ANTLRBaseTree>) getParent:(id<ANTLRBaseTree>) t
{
-    return [(id<ANTLRBaseTree>)t deleteChild:index];
+    if ( t == nil )
+        return nil;
+    return (id<ANTLRBaseTree>)[t getParent];
}

-- (NSInteger) getChildCount:(id<ANTLRBaseTree>)t
+- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>) parent
{
-    return [(id<ANTLRBaseTree>)t getChildCount];
+    if ( t != nil )
+        [(id<ANTLRBaseTree>) t setParent:(id<ANTLRBaseTree>)parent];
}

-- (NSInteger) getUniqueID:(id<ANTLRBaseTree>)node
+- (NSInteger) getUniqueID:(id)node
{
if ( treeToUniqueIDMap == nil ) {
treeToUniqueIDMap = [ANTLRUniqueIDMap newANTLRUniqueIDMap];
@@ -344,11 +369,21 @@
*  seems like this will yield start=i and stop=i-1 in a nil node.
*  Might be useful info so I'll not force to be i..i.
*/
-- (void) setTokenBoundaries:(id<ANTLRBaseTree>)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken
+- (void) setTokenBoundaries:(id)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken
{
return;
}

+- (NSInteger) getTokenStartIndex:(id)aTree
+{
+    return -1;
+}
+
+- (NSInteger) getTokenStopIndex:(id)aTree
+{
+    return -1;
+}
+
#ifdef DONTUSENOMO
- (NSInteger)getUniqueID
{
diff --git a/runtime/ObjC/Framework/ANTLRBitSet.h b/runtime/ObjC/Framework/ANTLRBitSet.h
index 3a4a51f..a6e8eed 100644
--- a/runtime/ObjC/Framework/ANTLRBitSet.h
+++ b/runtime/ObjC/Framework/ANTLRBitSet.h
@@ -28,6 +28,7 @@
#import <Cocoa/Cocoa.h>
#import <CoreFoundation/CoreFoundation.h>
#import "ANTLRToken.h"
+#import "AMutableArray.h"

#define BITS (sizeof(NSUInteger) * 8)
#define LOG_BITS ((sizeof(NSUInteger)==8)?6:5)
@@ -48,7 +49,7 @@
* @param nbits The size of the ANTLRBitSet in bits
*/
+ (ANTLRBitSet *) newANTLRBitSetWithNBits:(NSUInteger)nbits;
-+ (ANTLRBitSet *) newANTLRBitSetWithArray:(NSMutableArray *)types;
++ (ANTLRBitSet *) newANTLRBitSetWithArray:(AMutableArray *)types;
+ (ANTLRBitSet *) newANTLRBitSetWithBits:(const unsigned long long *)theBits Count:(NSUInteger)longCount;

+ (ANTLRBitSet *) of:(NSUInteger)el;
diff --git a/runtime/ObjC/Framework/ANTLRBitSet.m b/runtime/ObjC/Framework/ANTLRBitSet.m
index 9f1b8f4..00a0fb7 100644
--- a/runtime/ObjC/Framework/ANTLRBitSet.m
+++ b/runtime/ObjC/Framework/ANTLRBitSet.m
@@ -47,7 +47,7 @@
return [[ANTLRBitSet alloc] initWithNBits:nbits];
}

-+ (ANTLRBitSet *) newANTLRBitSetWithArray:(NSMutableArray *)types
++ (ANTLRBitSet *) newANTLRBitSetWithArray:(AMutableArray *)types
{
return [[ANTLRBitSet alloc] initWithArrayOfBits:types];
}
diff --git a/runtime/ObjC/Framework/ANTLRBufferedTokenStream.h b/runtime/ObjC/Framework/ANTLRBufferedTokenStream.h
index 3ef668c..bd1caeb 100644
--- a/runtime/ObjC/Framework/ANTLRBufferedTokenStream.h
+++ b/runtime/ObjC/Framework/ANTLRBufferedTokenStream.h
@@ -28,6 +28,7 @@
#import "ANTLRTokenStream.h"
#import "ANTLRTokenSource.h"
#import "ANTLRBitSet.h"
+#import "AMutableArray.h"

@interface ANTLRBufferedTokenStream : NSObject <ANTLRTokenStream>
{
@@ -38,33 +39,31 @@ id<ANTLRTokenSource> tokenSource;
*  as its moving window moves through the input.  This list captures
*  everything so we can access complete input text.
*/
-NSMutableArray *tokens;
+AMutableArray *tokens;

/** Track the last mark() call result value for use in rewind(). */
NSInteger lastMarker;

/** The index into the tokens list of the current token (next token
-     *  to consume).  tokens[p] should be LT(1).  p=-1 indicates need
+     *  to consume).  tokens[index] should be LT(1).  index=-1 indicates need
*  to initialize with first token.  The ctor doesn't get a token.
-     *  First call to LT(1) or whatever gets the first token and sets p=0;
+     *  First call to LT(1) or whatever gets the first token and sets index=0;
*/
-NSInteger p;
+NSInteger index;

NSInteger range; // how deep have we gone?

}
@property (retain, getter=getTokenSource,setter=setTokenSource:) id<ANTLRTokenSource> tokenSource;
-@property (retain, getter=getTokens,setter=setTokens:) NSMutableArray *tokens;
+@property (retain, getter=getTokens,setter=setTokens:) AMutableArray *tokens;
@property (assign, getter=getLastMarker,setter=setLastMarker:) NSInteger lastMarker;
-@property (assign, getter=getIndex,setter=setIndex:) NSInteger p;
+@property (assign) NSInteger index;
@property (assign, getter=getRange,setter=setRange:) NSInteger range;

+ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStream;
+ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStreamWith:(id<ANTLRTokenSource>)aSource;
- (id) initWithTokenSource:(id<ANTLRTokenSource>)aSource;
- (id) copyWithZone:(NSZone *)aZone;
-- (NSInteger) getIndex;
-- (void) setIndex:(NSInteger)index;
- (NSInteger) getRange;
- (void) setRange:(NSInteger)anInt;
- (NSInteger) mark;
@@ -72,25 +71,25 @@ NSInteger range; // how deep have we gone?
- (void) rewind:(NSInteger) marker;
- (void) rewind;
- (void) reset;
-- (void) seek:(NSInteger) index;
+- (void) seek:(NSInteger) anIndex;
- (NSInteger) size;
- (void) consume;
- (void) sync:(NSInteger) i;
- (void) fetch:(NSInteger) n;
- (id<ANTLRToken>) getToken:(NSInteger) i;
-- (NSMutableArray *)getFrom:(NSInteger)startIndex To:(NSInteger) stopIndex;
+- (AMutableArray *)getFrom:(NSInteger)startIndex To:(NSInteger) stopIndex;
- (NSInteger) LA:(NSInteger)i;
- (id<ANTLRToken>) LB:(NSInteger) k;
- (id<ANTLRToken>) LT:(NSInteger) k;
- (void) setup;
- (id<ANTLRTokenSource>) getTokenSource;
- (void) setTokenSource:(id<ANTLRTokenSource>) aTokenSource;
-- (NSMutableArray *)getTokens;
+- (AMutableArray *)getTokens;
- (NSString *) getSourceName;
-- (NSMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex;
-- (NSMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex With:(ANTLRBitSet *)types;
-- (NSMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithList:(NSMutableArray *)types;
-- (NSMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithType:(NSInteger)ttype;
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex;
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex With:(ANTLRBitSet *)types;
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithList:(AMutableArray *)types;
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithType:(NSInteger)ttype;
- (NSString *) toString;
- (NSString *) toStringFromStart:(NSInteger)startIndex ToEnd:(NSInteger)stopIndex;
- (NSString *) toStringFromToken:(id<ANTLRToken>)startIndex ToToken:(id<ANTLRToken>)stopIndex;
diff --git a/runtime/ObjC/Framework/ANTLRBufferedTokenStream.m b/runtime/ObjC/Framework/ANTLRBufferedTokenStream.m
index 3558c0f..edc4e57 100644
--- a/runtime/ObjC/Framework/ANTLRBufferedTokenStream.m
+++ b/runtime/ObjC/Framework/ANTLRBufferedTokenStream.m
@@ -36,7 +36,7 @@ extern NSInteger debug;
@synthesize tokenSource;
@synthesize tokens;
@synthesize lastMarker;
-@synthesize p;
+@synthesize index;
@synthesize range;

+ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStream
@@ -54,8 +54,8 @@ extern NSInteger debug;
if ((self = [super init]) != nil)
{
tokenSource = nil;
-        tokens = [[NSMutableArray arrayWithCapacity:1000] retain];
-        p = -1;
+        tokens = [[AMutableArray arrayWithCapacity:1000] retain];
+        index = -1;
range = -1;
}
return self;
@@ -66,8 +66,8 @@ extern NSInteger debug;
if ((self = [super init]) != nil)
{
tokenSource = aSource;
-        tokens = [[NSMutableArray arrayWithCapacity:1000] retain];
-        p = -1;
+        tokens = [[AMutableArray arrayWithCapacity:1000] retain];
+        index = -1;
range = -1;
}
return self;
@@ -82,7 +82,7 @@ extern NSInteger debug;
if ( self.tokens )
copy.tokens = [tokens copyWithZone:aZone];
copy.lastMarker = self.lastMarker;
-    copy.p = self.p;
+    copy.index = self.index;
copy.range = self.range;
return copy;
}
@@ -92,16 +92,6 @@ extern NSInteger debug;
return tokenSource;
}

-- (NSInteger) getIndex
-{
-    return p;
-}
-
-- (void) setIndex:(NSInteger) anIndex
-{
-    p = anIndex;
-}
-
- (NSInteger) getRange
{
return range;
@@ -114,11 +104,11 @@ extern NSInteger debug;

- (NSInteger) mark
{
-    if ( p == -1 ) {
+    if ( index == -1 ) {
[self setup];
//        [self fill];
}
-    lastMarker = [self getIndex];
+    lastMarker = self.index;
return lastMarker;
}

@@ -139,13 +129,13 @@ extern NSInteger debug;

- (void) reset
{
-    p = 0;
+    index = 0;
lastMarker = 0;
}

- (void) seek:(NSInteger) anIndex
{
-    p = anIndex;
+    index = anIndex;
}

- (NSInteger) size
@@ -162,12 +152,12 @@ extern NSInteger debug;
*/
- (void) consume
{
-    if ( p == -1 ) {
+    if ( index == -1 ) {
[self setup];
//        [self fill];
}
-    p++;
-    [self sync:p];
+    index++;
+    [self sync:index];
}

/** Make sure index i in tokens has a token. */
@@ -186,7 +176,7 @@ extern NSInteger debug;
for (NSInteger i=1; i <= n; i++) {
id<ANTLRToken> t = [tokenSource nextToken];
[t setTokenIndex:[tokens count]];
-        if (debug > 1) NSLog(@"adding %@ at index %d\n", [t getText], [tokens count]);
+        if (debug > 1) NSLog(@"adding %@ at index %d\n", [t text], [tokens count]);
[tokens addObject:t];
[t retain];
if ( [t getType] == ANTLRTokenTypeEOF )
@@ -203,15 +193,15 @@ extern NSInteger debug;
}

/** Get all tokens from start..stop inclusively */
-- (NSMutableArray *)getFrom:(NSInteger)startIndex To:(NSInteger)stopIndex
+- (AMutableArray *)getFrom:(NSInteger)startIndex To:(NSInteger)stopIndex
{
if ( startIndex < 0 || stopIndex < 0 )
return nil;
-    if ( p == -1 ) {
+    if ( index == -1 ) {
[self setup];
//        [self fill];
}
-    NSMutableArray *subset = [NSMutableArray arrayWithCapacity:5];
+    AMutableArray *subset = [AMutableArray arrayWithCapacity:5];
if ( stopIndex >= [tokens count] )
stopIndex = [tokens count]-1;
for (NSInteger i = startIndex; i <= stopIndex; i++) {
@@ -230,14 +220,14 @@ extern NSInteger debug;

- (id<ANTLRToken>) LB:(NSInteger)k
{
-    if ( (p - k) < 0 )
+    if ( (index - k) < 0 )
return nil;
-    return [tokens objectAtIndex:(p-k)];
+    return [tokens objectAtIndex:(index-k)];
}

- (id<ANTLRToken>) LT:(NSInteger)k
{
-    if ( p == -1 ) {
+    if ( index == -1 ) {
[self setup];
//        [self fill];
}
@@ -246,7 +236,7 @@ extern NSInteger debug;
if ( k < 0 )
return [self LB:-k];

-    NSInteger i = p + k - 1;
+    NSInteger i = index + k - 1;
[self sync:i];
if ( i >= [tokens count] ) { // return EOF token
// EOF must be last token
@@ -260,23 +250,24 @@ extern NSInteger debug;
- (void) setup
{
[self sync:0];
-    p = 0;
+    index = 0;
}

/** Reset this token stream by setting its token source. */
- (void) setTokenSource:(id<ANTLRTokenSource>) aTokenSource
{
tokenSource = aTokenSource;
-    [tokens removeAllObjects];
-    p = -1;
+    if ( [tokens count] )
+        [tokens removeAllObjects];
+    index = -1;
}

-- (NSMutableArray *)getTokens
+- (AMutableArray *)getTokens
{
return tokens;
}

-- (NSMutableArray *)getTokensFrom:(NSInteger) startIndex To:(NSInteger) stopIndex
+- (AMutableArray *)getTokensFrom:(NSInteger) startIndex To:(NSInteger) stopIndex
{
return [self getTokensFrom:startIndex To:stopIndex With:(ANTLRBitSet *)nil];
}
@@ -285,9 +276,9 @@ extern NSInteger debug;
*  the token type BitSet.  Return null if no tokens were found.  This
*  method looks at both on and off channel tokens.
*/
-- (NSMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex With:(ANTLRBitSet *)types
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex With:(ANTLRBitSet *)types
{
-    if ( p == -1 ) {
+    if ( index == -1 ) {
[self setup];
//        [self fill];
}
@@ -299,7 +290,7 @@ extern NSInteger debug;
return nil;

// list = tokens[start:stop]:{Token t, t.getType() in types}
-    NSMutableArray *filteredTokens = [NSMutableArray arrayWithCapacity:5];
+    AMutableArray *filteredTokens = [AMutableArray arrayWithCapacity:5];
for (NSInteger i = startIndex; i <= stopIndex; i++) {
id<ANTLRToken>t = [tokens objectAtIndex:i];
if ( types == nil || [types member:[t getType]] ) {
@@ -313,12 +304,12 @@ extern NSInteger debug;
return filteredTokens;
}

-- (NSMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithType:(NSInteger)ttype
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithType:(NSInteger)ttype
{
return [self getTokensFrom:startIndex To:stopIndex With:[ANTLRBitSet of:ttype]];
}

-- (NSMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithList:(NSMutableArray *)types
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithList:(AMutableArray *)types
{
return [self getTokensFrom:startIndex To:stopIndex With:[ANTLRBitSet newANTLRBitSetWithArray:types]];
}
@@ -331,7 +322,7 @@ extern NSInteger debug;
/** Grab *all* tokens from stream and return string */
- (NSString *) toString
{
-    if ( p == -1 ) {
+    if ( index == -1 ) {
[self setup];
}
[self fill];
@@ -342,7 +333,7 @@ extern NSInteger debug;
{
if ( startIdx < 0 || stopIdx < 0 )
return nil;
-    if ( p == -1 ) {
+    if ( index == -1 ) {
[self setup];
}
if ( stopIdx >= [tokens count] )
@@ -352,7 +343,7 @@ extern NSInteger debug;
id<ANTLRToken>t = [tokens objectAtIndex:i];
if ( [t getType] == ANTLRTokenTypeEOF )
break;
-        [buf appendString:[t getText]];
+        [buf appendString:[t text]];
}
return buf;
}
@@ -368,11 +359,11 @@ extern NSInteger debug;
/** Get all tokens from lexer until EOF */
- (void) fill
{
-    if ( p == -1 ) [self setup];
-    if ( [[tokens objectAtIndex:p] getType] == ANTLRTokenTypeEOF )
+    if ( index == -1 ) [self setup];
+    if ( [[tokens objectAtIndex:index] getType] == ANTLRTokenTypeEOF )
return;

-    NSInteger i = p+1;
+    NSInteger i = index+1;
[self sync:i];
while ( [[tokens objectAtIndex:i] getType] != ANTLRTokenTypeEOF ) {
i++;
@@ -380,15 +371,4 @@ extern NSInteger debug;
}
}

-#ifdef DONTUSENOMO
-- (NSUInteger) getCharPositionInLine
-{
-    return -1;
-}
-
-- (void) setCharPositionInLine:(NSUInteger)thePos
-{
-}
-#endif
-
@end
diff --git a/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.h b/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.h
index 7ac5fa5..507feb2 100644
--- a/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.h
+++ b/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.h
@@ -36,6 +36,7 @@
#import "ANTLRLookaheadStream.h"
#import "ANTLRTreeIterator.h"
#import "ANTLRIntArray.h"
+#import "AMutableArray.h"

#define DEFAULT_INITIAL_BUFFER_SIZE 100
#define INITIAL_CALL_STACK_SIZE 10
@@ -44,8 +45,8 @@
@interface ANTLRStreamIterator : ANTLRTreeIterator
{
NSInteger idx;
-    ANTLRBufferedTreeNodeStream input;
-    NSMutableArray *nodes;
+    ANTLRBufferedTreeNodeStream *input;
+    AMutableArray *nodes;
}

+ (id) newANTLRStreamIterator:(ANTLRBufferedTreeNodeStream *) theStream;
@@ -60,19 +61,19 @@

@interface ANTLRBufferedTreeNodeStream : NSObject <ANTLRTreeNodeStream>
{
-	id<ANTLRBaseTree> up;
-	id<ANTLRBaseTree> down;
-	id<ANTLRBaseTree> eof;
+	id up;
+	id down;
+	id eof;

-	NSMutableArray *nodes;
+	AMutableArray *nodes;

-	id<ANTLRBaseTree> root; // root
+	id root; // root

id<ANTLRTokenStream> tokens;
ANTLRCommonTreeAdaptor *adaptor;

BOOL uniqueNavigationNodes;
-	NSInteger p;
+	NSInteger index;
NSInteger lastMarker;
ANTLRIntArray *calls;

@@ -81,36 +82,36 @@

}

-@property (retain, getter=getUp, setter=setUp:) id<ANTLRBaseTree> up;
-@property (retain, getter=getDown, setter=setDown:) id<ANTLRBaseTree> down;
-@property (retain, getter=getEof, setter=setEof:) id<ANTLRBaseTree> eof;
-@property (retain, getter=getNodes, setter=setNodes:) NSMutableArray *nodes;
-@property (retain, getter=getTreeSource, setter=setTreeSource:) id<ANTLRBaseTree> root;
+@property (retain, getter=getUp, setter=setUp:) id up;
+@property (retain, getter=getDown, setter=setDown:) id down;
+@property (retain, getter=eof, setter=setEof:) id eof;
+@property (retain, getter=getNodes, setter=setNodes:) AMutableArray *nodes;
+@property (retain, getter=getTreeSource, setter=setTreeSource:) id root;
@property (retain, getter=getTokenStream, setter=setTokenStream:) id<ANTLRTokenStream> tokens;
@property (retain, getter=getAdaptor, setter=setAdaptor:) ANTLRCommonTreeAdaptor *adaptor;
@property (assign, getter=getUniqueNavigationNodes, setter=setUniqueNavigationNodes:) BOOL uniqueNavigationNodes;
-@property (assign, getter=getIndex, setter=setIndex:) NSInteger p;
+@property (assign) NSInteger index;
@property (assign, getter=getLastMarker, setter=setLastMarker:) NSInteger lastMarker;
@property (retain, getter=getCalls, setter=setCalls:) ANTLRIntArray *calls;
@property (retain, getter=getEnum, setter=setEnum:) NSEnumerator *e;
@property (retain, getter=getCurrentSymbol, setter=setCurrentSymbol:) id currentSymbol;

-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRBaseTree>)tree;
-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(id<ANTLRBaseTree>)tree;
-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(id<ANTLRBaseTree>)tree withBufferSize:(NSInteger)initialBufferSize;
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(ANTLRCommonTree *)tree;
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)tree;
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)tree withBufferSize:(NSInteger)initialBufferSize;

#pragma mark Constructor
-- (id) initWithTree:(id<ANTLRBaseTree>)tree;
-- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(id<ANTLRBaseTree>)tree;
-- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(id<ANTLRBaseTree>)tree WithBufferSize:(NSInteger)bufferSize;
+- (id) initWithTree:(ANTLRCommonTree *)tree;
+- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)tree;
+- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)tree WithBufferSize:(NSInteger)bufferSize;

- (id) copyWithZone:(NSZone *)aZone;

// protected methods. DO NOT USE
#pragma mark Protected Methods
- (void) fillBuffer;
-- (void) fillBufferWithTree:(id<ANTLRBaseTree>) tree;
-- (NSInteger) getNodeIndex:(id<ANTLRBaseTree>) node;
+- (void) fillBufferWithTree:(ANTLRCommonTree *) tree;
+- (NSInteger) getNodeIndex:(ANTLRCommonTree *) node;
- (void) addNavigationNode:(NSInteger) type;
- (id) getNode:(NSUInteger) i;
- (id) LT:(NSInteger) k;
@@ -131,8 +132,6 @@
- (NSInteger) LA:(NSInteger) i;
- (NSInteger) mark;
- (void) release:(NSInteger) marker;
-- (NSInteger) getIndex;
-- (void) setIndex:(NSInteger) idx;
- (void) rewind:(NSInteger) marker;
- (void) rewind;
- (void) seek:(NSInteger) idx;
@@ -150,7 +149,8 @@
- (NSString *) toStringFromNode:(id)aStart ToNode:(id)aStop;

// getters and setters
-- (NSMutableArray *) getNodes;
-- (id<ANTLRBaseTree>) getEof;
+- (AMutableArray *) getNodes;
+- (id) eof;
+- (void)setEof:(id)anEOF;

@end
diff --git a/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.m
index 6877f03..c3b6e17 100644
--- a/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.m
+++ b/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.m
@@ -83,37 +83,37 @@ extern NSInteger debug;
@synthesize tokens;
@synthesize adaptor;
@synthesize uniqueNavigationNodes;
-@synthesize p;
+@synthesize index;
@synthesize lastMarker;
@synthesize calls;
@synthesize e;
@synthesize currentSymbol;

-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRBaseTree>) aTree
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(ANTLRCommonTree *) aTree
{
-    return [((ANTLRBufferedTreeNodeStream *)[ANTLRBufferedTreeNodeStream alloc]) initWithTree:(id<ANTLRBaseTree>)aTree];
+    return [((ANTLRBufferedTreeNodeStream *)[ANTLRBufferedTreeNodeStream alloc]) initWithTree:(ANTLRCommonTree *)aTree];
}

-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(id<ANTLRBaseTree>)aTree
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)aTree
{
-    return [[ANTLRBufferedTreeNodeStream alloc] initWithTreeAdaptor:adaptor Tree:(id<ANTLRBaseTree>)aTree];
+    return [[ANTLRBufferedTreeNodeStream alloc] initWithTreeAdaptor:adaptor Tree:(ANTLRCommonTree *)aTree];
}

-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(id<ANTLRBaseTree>)aTree withBufferSize:(NSInteger)initialBufferSize
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)aTree withBufferSize:(NSInteger)initialBufferSize
{
-    return [[ANTLRBufferedTreeNodeStream alloc] initWithTreeAdaptor:adaptor Tree:(id<ANTLRBaseTree>)aTree WithBufferSize:initialBufferSize];
+    return [[ANTLRBufferedTreeNodeStream alloc] initWithTreeAdaptor:adaptor Tree:(ANTLRCommonTree *)aTree WithBufferSize:initialBufferSize];
}

-(ANTLRBufferedTreeNodeStream *) init
{
self = [super init];
if (self) {
-		p = -1;
+		index = -1;
uniqueNavigationNodes = NO;
root = [[ANTLRCommonTree alloc] init];
//		tokens = tree;
adaptor = [[ANTLRCommonTreeAdaptor alloc] init];
-        nodes = [NSMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE];
+        nodes = [AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE];
down = [adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"];
up = [adaptor createTree:ANTLRTokenTypeUP Text:@"UP"];
eof = [adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"];
@@ -121,16 +121,16 @@ extern NSInteger debug;
return self;
}

-- (ANTLRBufferedTreeNodeStream *)initWithTree:(id<ANTLRBaseTree>) aTree
+- (ANTLRBufferedTreeNodeStream *)initWithTree:(ANTLRCommonTree *) aTree
{
self = [super init];
if (self) {
-		p = -1;
+		index = -1;
uniqueNavigationNodes = NO;
root = aTree;
//		tokens = aTree;
adaptor = [[ANTLRCommonTreeAdaptor alloc] init];
-        nodes = [NSMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE];
+        nodes = [AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE];
down = [adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"];
up = [adaptor createTree:ANTLRTokenTypeUP Text:@"UP"];
eof = [adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"];
@@ -138,16 +138,16 @@ extern NSInteger debug;
return self;
}

--(ANTLRBufferedTreeNodeStream *) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(id<ANTLRBaseTree>)aTree
+-(ANTLRBufferedTreeNodeStream *) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)aTree
{
self = [super init];
if (self) {
-		p = -1;
+		index = -1;
uniqueNavigationNodes = NO;
root = aTree;
//		tokens = aTree;
adaptor = anAdaptor;
-        nodes = [NSMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE];
+        nodes = [AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE];
down = [adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"];
up = [adaptor createTree:ANTLRTokenTypeUP Text:@"UP"];
eof = [adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"];
@@ -155,19 +155,19 @@ extern NSInteger debug;
return self;
}

--(ANTLRBufferedTreeNodeStream *) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(id<ANTLRBaseTree>)aTree WithBufferSize:(NSInteger)bufferSize
+-(ANTLRBufferedTreeNodeStream *) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)aTree WithBufferSize:(NSInteger)bufferSize
{
self = [super init];
if (self) {
//		down = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"DOWN"];
//		up = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"UP"];
//		eof = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"EOF"];
-		p = -1;
+		index = -1;
uniqueNavigationNodes = NO;
root = aTree;
//		tokens = aTree;
adaptor = anAdaptor;
-        nodes = [NSMutableArray arrayWithCapacity:bufferSize];
+        nodes = [AMutableArray arrayWithCapacity:bufferSize];
down = [adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"];
up = [adaptor createTree:ANTLRTokenTypeUP Text:@"UP"];
eof = [adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"];
@@ -195,7 +195,7 @@ extern NSInteger debug;
if ( adaptor )
copy.adaptor = [adaptor copyWithZone:aZone];
copy.uniqueNavigationNodes = self.uniqueNavigationNodes;
-    copy.p = self.p;
+    copy.index = self.index;
copy.lastMarker = self.lastMarker;
if ( calls )
copy.calls = [calls copyWithZone:aZone];
@@ -208,10 +208,10 @@ extern NSInteger debug;
{
[self fillBufferWithTree:root];
// if (debug > 1) NSLog("revIndex=%@", tokenTypeToStreamIndexesMap);
-	p = 0; // buffer of nodes intialized now
+	index = 0; // buffer of nodes intialized now
}

--(void) fillBufferWithTree:(id<ANTLRBaseTree>) aTree
+-(void) fillBufferWithTree:(ANTLRCommonTree *) aTree
{
BOOL empty = [adaptor isNil:aTree];
if (!empty) {
@@ -230,9 +230,9 @@ extern NSInteger debug;
}
}

--(NSInteger) getNodeIndex:(id<ANTLRBaseTree>) node
+-(NSInteger) getNodeIndex:(ANTLRCommonTree *) node
{
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}
for (NSUInteger i = 0; i < [nodes count]; i++) {
@@ -269,7 +269,7 @@ extern NSInteger debug;

-(id) getNode:(NSUInteger) i
{
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}
return [nodes objectAtIndex:i];
@@ -277,7 +277,7 @@ extern NSInteger debug;

-(id) LT:(NSInteger) k
{
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}
if (k == 0) {
@@ -286,10 +286,10 @@ extern NSInteger debug;
if (k < 0) {
return [self LB:-k];
}
-	if ((p + k - 1) >= [nodes count]) {
+	if ((index + k - 1) >= [nodes count]) {
return eof;
}
-	return [nodes objectAtIndex:(p + k - 1)];
+	return [nodes objectAtIndex:(index + k - 1)];
}

-(id) getCurrentSymbol
@@ -302,13 +302,13 @@ extern NSInteger debug;
if (k == 0) {
return nil;
}
-	if ((p - k) < 0) {
+	if ((index - k) < 0) {
return nil;
}
-	return [nodes objectAtIndex:(p - k)];
+	return [nodes objectAtIndex:(index - k)];
}

-- (id<ANTLRBaseTree>)getTreeSource
+- (ANTLRCommonTree *)getTreeSource
{
return root;
}
@@ -350,10 +350,10 @@ extern NSInteger debug;

-(void) consume
{
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}
-	p++;
+	index++;
}

-(NSInteger) LA:(NSInteger) i
@@ -363,10 +363,10 @@ extern NSInteger debug;

-(NSInteger) mark
{
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}
-	lastMarker = [self getIndex];
+	lastMarker = self.index;
return lastMarker;
}

@@ -375,11 +375,6 @@ extern NSInteger debug;
// do nothing
}

--(NSInteger) index
-{
-	return p;
-}
-
-(void) rewind:(NSInteger) marker
{
[self seek:marker];
@@ -392,10 +387,10 @@ extern NSInteger debug;

-(void) seek:(NSInteger) i
{
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}
-	p = i;
+	index = i;
}

-(void) push:(NSInteger) i
@@ -403,7 +398,7 @@ extern NSInteger debug;
if (calls == nil) {
calls = [ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE];
}
-	[calls push:p];
+	[calls push:index];
[self seek:i];
}

@@ -416,7 +411,7 @@ extern NSInteger debug;

-(void) reset
{
-	p = 0;
+	index = 0;
lastMarker = 0;
if (calls != nil) {
[calls reset];
@@ -425,7 +420,7 @@ extern NSInteger debug;

-(NSUInteger) count
{
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}
return [nodes count];
@@ -444,7 +439,7 @@ extern NSInteger debug;
return e;
}

--(void) replaceChildren:(id<ANTLRBaseTree>) parent From:(NSInteger)startIdx To:(NSInteger)stopIdx With:(id<ANTLRBaseTree>)aTree
+-(void) replaceChildren:(ANTLRCommonTree *) parent From:(NSInteger)startIdx To:(NSInteger)stopIdx With:(ANTLRCommonTree *)aTree
{
if (parent != nil) {
[adaptor replaceChildren:parent From:startIdx To:stopIdx With:aTree];
@@ -453,13 +448,13 @@ extern NSInteger debug;

-(NSString *) toTokenTypeString
{
-	if (p == -1)
+	if (index == -1)
{
[self fillBuffer];
}
NSMutableString *buf = [NSMutableString stringWithCapacity:10];
for (NSUInteger i= 0; i < [nodes count]; i++) {
-		id<ANTLRBaseTree> aTree = (id<ANTLRBaseTree>)[self getNode:i];
+		ANTLRCommonTree * aTree = (ANTLRCommonTree *)[self getNode:i];
[buf appendFormat:@" %d", [adaptor getType:aTree]];
}
return buf;
@@ -467,12 +462,12 @@ extern NSInteger debug;

-(NSString *) toTokenString:(NSInteger)aStart ToEnd:(NSInteger)aStop
{
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}
NSMutableString *buf = [NSMutableString stringWithCapacity:10];
for (NSUInteger i = aStart; i < [nodes count] && i <= aStop; i++) {
-		id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)[self getNode:i];
+		ANTLRCommonTree * t = (ANTLRCommonTree *)[self getNode:i];
[buf appendFormat:@" %d", [adaptor getType:t]];
}
return buf;
@@ -483,7 +478,7 @@ extern NSInteger debug;
if (aStart == nil || aStop == nil) {
return nil;
}
-	if (p == -1) {
+	if (index == -1) {
[self fillBuffer];
}

@@ -501,7 +496,7 @@ extern NSInteger debug;
[tokens toStringFromStart:beginTokenIndex ToEnd:endTokenIndex];
}
// walk nodes looking for aStart
-	id<ANTLRBaseTree> aTree = nil;
+	ANTLRCommonTree * aTree = nil;
NSUInteger i = 0;
for (; i < [nodes count]; i++) {
aTree = [nodes objectAtIndex:i];
@@ -529,13 +524,19 @@ extern NSInteger debug;
}

// getters and setters
-- (NSMutableArray *) getNodes
+- (AMutableArray *) getNodes
{
return nodes;
}

-- (id<ANTLRBaseTree>) getEof
+- (id) eof
{
return eof;
}
+
+- (void) setEof:(id)theEOF
+{
+    eof = theEOF;
+}
+
@end
diff --git a/runtime/ObjC/Framework/ANTLRCharStream.h b/runtime/ObjC/Framework/ANTLRCharStream.h
index 379734b..f7be94b 100644
--- a/runtime/ObjC/Framework/ANTLRCharStream.h
+++ b/runtime/ObjC/Framework/ANTLRCharStream.h
@@ -41,15 +41,9 @@
- (NSInteger)LT:(NSInteger) i;

// ANTLR tracks the line information automatically
-- (NSInteger) getLine;

// Because this stream can rewind, we need to be able to reset the line
-- (void) setLine:(NSInteger) theLine;

// The index of the character relative to the beginning of the line 0..n-1
-- (NSInteger) getCharPositionInLine;
-
-- (void) setCharPositionInLine:(NSInteger) thePos;
-

@end
diff --git a/runtime/ObjC/Framework/ANTLRCharStreamState.h b/runtime/ObjC/Framework/ANTLRCharStreamState.h
index f52edb5..0cf872f 100644
--- a/runtime/ObjC/Framework/ANTLRCharStreamState.h
+++ b/runtime/ObjC/Framework/ANTLRCharStreamState.h
@@ -33,26 +33,17 @@

@interface ANTLRCharStreamState : NSObject
{
-NSInteger p;
-NSInteger line;
-NSInteger charPositionInLine;
+NSInteger index;
+NSUInteger line;
+NSUInteger charPositionInLine;
}

-@property (assign) NSInteger p;
-@property (assign) NSInteger line;
-@property (assign) NSInteger charPositionInLine;
+@property (assign) NSInteger index;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;

+ newANTLRCharStreamState;

- (id) init;

-- (NSInteger) getP;
-- (void) setP: (NSInteger) anIndex;
-
-- (NSInteger) getLine;
-- (void) setLine: (NSInteger) aLine;
-
-- (NSInteger) getCharPositionInLine;
-- (void) setCharPositionInLine:(NSInteger)aCharPositionInLine;
-
@end
diff --git a/runtime/ObjC/Framework/ANTLRCharStreamState.m b/runtime/ObjC/Framework/ANTLRCharStreamState.m
index 6f3a4e3..b2a7e3a 100755
--- a/runtime/ObjC/Framework/ANTLRCharStreamState.m
+++ b/runtime/ObjC/Framework/ANTLRCharStreamState.m
@@ -30,7 +30,7 @@

@implementation ANTLRCharStreamState

-@synthesize p;
+@synthesize index;
@synthesize line;
@synthesize charPositionInLine;

@@ -42,51 +42,11 @@
- (id) init
{
if ((self = [super init]) != nil) {
-        p = 0;
+        index = 0;
line = 1;
charPositionInLine = 0;
}
return self;
}

-//----------------------------------------------------------
-//  index
-//----------------------------------------------------------
-- (NSInteger) getP
-{
-    return p;
-}
-
-- (void) setP: (NSInteger) anIndex
-{
-    p = anIndex;
-}
-
-//----------------------------------------------------------
-//  line
-//----------------------------------------------------------
-- (NSInteger) getLine
-{
-    return line;
-}
-
-- (void) setLine: (NSInteger) aLine
-{
-    line = aLine;
-}
-
-//----------------------------------------------------------
-//  charPositionInLine
-//----------------------------------------------------------
-- (NSInteger) getCharPositionInLine
-{
-    return charPositionInLine;
-}
-
-- (void) setCharPositionInLine: (NSInteger) aCharPositionInLine
-{
-    charPositionInLine = aCharPositionInLine;
-}
-
-
@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonErrorNode.h b/runtime/ObjC/Framework/ANTLRCommonErrorNode.h
index f44641a..0f6d4ec 100644
--- a/runtime/ObjC/Framework/ANTLRCommonErrorNode.h
+++ b/runtime/ObjC/Framework/ANTLRCommonErrorNode.h
@@ -56,7 +56,7 @@ ANTLRRecognitionException *trappedException;

- (NSInteger) getType;

-- (NSString *) getText;
+- (NSString *) text;

- (NSString *) toString;

diff --git a/runtime/ObjC/Framework/ANTLRCommonErrorNode.m b/runtime/ObjC/Framework/ANTLRCommonErrorNode.m
index 353e872..e0035ef 100644
--- a/runtime/ObjC/Framework/ANTLRCommonErrorNode.m
+++ b/runtime/ObjC/Framework/ANTLRCommonErrorNode.m
@@ -86,7 +86,7 @@
return ANTLRTokenTypeInvalid;
}

-- (NSString *)getText
+- (NSString *)text
{
NSString *badText = nil;
if ( [startToken isKindOfClass:[self class]] ) {
@@ -119,18 +119,18 @@
else if ( [trappedException isKindOfClass:[ANTLRUnwantedTokenException class]] ) {
aString = [NSString stringWithFormat:@"<extraneous: %@, resync=%@>",
[trappedException getUnexpectedToken],
-        [self getText]];
+        [self text]];
return aString;
}
else if ( [trappedException isKindOfClass:[ANTLRMismatchedTokenException class]] ) {
-        aString = [NSString stringWithFormat:@"<mismatched token: %@, resync=%@>", trappedException.token, [self getText]];
+        aString = [NSString stringWithFormat:@"<mismatched token: %@, resync=%@>", trappedException.token, [self text]];
return aString;
}
else if ( [trappedException isKindOfClass:[ANTLRNoViableAltException class]] ) {
-        aString = [NSString stringWithFormat:@"<unexpected:  %@, resync=%@>", trappedException.token, [self getText]];
+        aString = [NSString stringWithFormat:@"<unexpected:  %@, resync=%@>", trappedException.token, [self text]];
return aString;
}
-    aString = [NSString stringWithFormat:@"<error: %@>",[self getText]];
+    aString = [NSString stringWithFormat:@"<error: %@>",[self text]];
return aString;
}

diff --git a/runtime/ObjC/Framework/ANTLRCommonToken.h b/runtime/ObjC/Framework/ANTLRCommonToken.h
index e7593a5..946e570 100644
--- a/runtime/ObjC/Framework/ANTLRCommonToken.h
+++ b/runtime/ObjC/Framework/ANTLRCommonToken.h
@@ -79,7 +79,7 @@
//----------------------------------------------------------
//  text
//----------------------------------------------------------
-- (NSString *) getText;
+- (NSString *) text;
- (void) setText: (NSString *) aText;

//----------------------------------------------------------
@@ -89,18 +89,6 @@
- (void) setType: (NSInteger) aType;

//----------------------------------------------------------
-//  line
-//----------------------------------------------------------
-- (NSUInteger) getLine;
-- (void) setLine: (NSUInteger) aLine;
-
-//----------------------------------------------------------
-//  charPositionInLine
-//----------------------------------------------------------
-- (NSUInteger) getCharPositionInLine;
-- (void) setCharPositionInLine: (NSUInteger) aCharPositionInLine;
-
-//----------------------------------------------------------
//  channel
//----------------------------------------------------------
- (NSUInteger) getChannel;
@@ -128,10 +116,10 @@
- (NSString *) description;
- (NSString *) toString;

-@property (retain) NSString *text;
+@property (retain, getter = text, setter = setText:) NSString *text;
@property (assign) NSInteger type;
-@property (assign) NSUInteger line;
-@property (assign) NSUInteger charPositionInLine;
+@property (assign, getter = line, setter = setLine:) NSUInteger line;
+@property (assign, getter=charPositionInLine, setter = setCharPositionInLine:) NSUInteger charPositionInLine;
@property (assign) NSUInteger channel;
@property (assign) NSInteger index;
@property (assign, getter=getStart, setter=setStart:) NSInteger startIndex;
diff --git a/runtime/ObjC/Framework/ANTLRCommonToken.m b/runtime/ObjC/Framework/ANTLRCommonToken.m
index 0e4ae35..46a9754 100644
--- a/runtime/ObjC/Framework/ANTLRCommonToken.m
+++ b/runtime/ObjC/Framework/ANTLRCommonToken.m
@@ -226,9 +226,35 @@ static ANTLRCommonToken *INVALID_TOKEN;


//----------------------------------------------------------
+//  charPositionInLine
+//----------------------------------------------------------
+- (NSUInteger) charPositionInLine
+{
+	return charPositionInLine;
+}
+
+- (void) setCharPositionInLine:(NSUInteger)aCharPositionInLine
+{
+    charPositionInLine = aCharPositionInLine;
+}
+
+//----------------------------------------------------------
+//  line
+//----------------------------------------------------------
+- (NSUInteger) line
+{
+	return line;
+}
+
+- (void) setLine:(NSUInteger)aLine
+{
+    line = aLine;
+}
+
+//----------------------------------------------------------
//  text
//----------------------------------------------------------
-- (NSString *) getText
+- (NSString *) text
{
if (text != nil) {
return text;
@@ -242,9 +268,9 @@ static ANTLRCommonToken *INVALID_TOKEN;
- (void) setText: (NSString *) aText
{
if (text != aText) {
-        [aText retain];
-        [text release];
+        if ( text ) [text release];
text = aText;
+        [text retain];
}
}

@@ -263,32 +289,6 @@ static ANTLRCommonToken *INVALID_TOKEN;
}

//----------------------------------------------------------
-//  line
-//----------------------------------------------------------
-- (NSUInteger) getLine
-{
-    return line;
-}
-
-- (void) setLine: (NSUInteger) aLine
-{
-    line = aLine;
-}
-
-//----------------------------------------------------------
-//  charPositionInLine
-//----------------------------------------------------------
-- (NSUInteger) getCharPositionInLine
-{
-    return charPositionInLine;
-}
-
-- (void) setCharPositionInLine: (NSUInteger) aCharPositionInLine
-{
-    charPositionInLine = aCharPositionInLine;
-}
-
-//----------------------------------------------------------
//  channel
//----------------------------------------------------------
- (NSUInteger) getChannel
@@ -313,9 +313,9 @@ static ANTLRCommonToken *INVALID_TOKEN;
- (void) setInput: (id<ANTLRCharStream>) anInput
{
if (input != anInput) {
-        [anInput retain];
-        [input release];
+        if ( input ) [input release];
input = anInput;
+        [input retain];
}
}

@@ -370,8 +370,8 @@ static ANTLRCommonToken *INVALID_TOKEN;
if ( channel > 0 ) {
channelStr = [NSString stringWithFormat:@",channel=%d\n", channel];
}
-	if ([self getText] != nil) {
-		txtString = [NSMutableString stringWithString:[self getText]];
+	if ([self text] != nil) {
+		txtString = [NSMutableString stringWithString:[self text]];
[txtString replaceOccurrencesOfString:@"\n" withString:@"\\\\n" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
[txtString replaceOccurrencesOfString:@"\r" withString:@"\\\\r" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
[txtString replaceOccurrencesOfString:@"\t" withString:@"\\\\t" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
diff --git a/runtime/ObjC/Framework/ANTLRCommonTokenStream.h b/runtime/ObjC/Framework/ANTLRCommonTokenStream.h
index 534a546..0f19221 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTokenStream.h
+++ b/runtime/ObjC/Framework/ANTLRCommonTokenStream.h
@@ -81,7 +81,6 @@
- (id<ANTLRToken>) getToken:(NSInteger)i;

- (NSInteger) size;
-- (NSInteger) getIndex;
- (void) rewind;
- (void) rewind:(NSInteger)marker;
- (void) seek:(NSInteger)index;
diff --git a/runtime/ObjC/Framework/ANTLRCommonTokenStream.m b/runtime/ObjC/Framework/ANTLRCommonTokenStream.m
index 9eba279..ce391db 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTokenStream.m
+++ b/runtime/ObjC/Framework/ANTLRCommonTokenStream.m
@@ -79,21 +79,21 @@

- (void) dealloc
{
-	[channelOverride release];
-	[tokens release];
+	if ( channelOverride ) [channelOverride release];
+	if ( tokens ) [tokens release];
[self setTokenSource:nil];
[super dealloc];
}

-/** Always leave p on an on-channel token. */
+/** Always leave index on an on-channel token. */
- (void) consume
{
-    if (p == -1) [self setup];
-    p++;
-    [self sync:p];
-    while ( [[tokens objectAtIndex:p] getChannel] != channel ) {
-		p++;
-		[self sync:p];
+    if (index == -1) [self setup];
+    index++;
+    [self sync:index];
+    while ( [[tokens objectAtIndex:index] getChannel] != channel ) {
+		index++;
+		[self sync:index];
}
}

@@ -101,10 +101,10 @@

- (id<ANTLRToken>) LB:(NSInteger)k
{
-	if ( k == 0 || (p-k) < 0 ) {
+	if ( k == 0 || (index-k) < 0 ) {
return nil;
}
-	int i = p;
+	int i = index;
int n = 1;
// find k good tokens looking backwards
while ( n <= k ) {
@@ -119,10 +119,10 @@

- (id<ANTLRToken>) LT:(NSInteger)k
{
-	if ( p == -1 ) [self setup];
+	if ( index == -1 ) [self setup];
if ( k == 0 ) return nil;
if ( k < 0 ) return [self LB:-k];
-	int i = p;
+	int i = index;
int n = 1;
while ( n < k ) {
i = [self skipOffChannelTokens:i+1];
@@ -157,15 +157,15 @@

- (void) setup
{
-    p = 0;
+    index = 0;
[self sync:0];
int i = 0;
while ( [((id<ANTLRToken>)[tokens objectAtIndex:i]) getChannel] != channel ) {
i++;
[self sync:i];
}
-	// leave p pointing at first token on channel
-    p = i;
+	// leave index pointing at first token on channel
+    index = i;
}

- (NSInteger) getNumberOfOnChannelTokens
@@ -240,13 +240,13 @@
{
unsigned int startIndex = aRange.location;
unsigned int stopIndex = aRange.location+aRange.length;
-	if ( p == -1 ) {
+	if ( index == -1 ) {
[self setup];
}
if (stopIndex >= [tokens count]) {
stopIndex = [tokens count] - 1;
}
-	NSMutableArray *filteredTokens = [NSMutableArray arrayWithCapacity:100];
+	AMutableArray *filteredTokens = [AMutableArray arrayWithCapacity:100];
unsigned int i=0;
for (i = startIndex; i<=stopIndex; i++) {
id<ANTLRToken> token = [tokens objectAtIndex:i];
@@ -290,11 +290,6 @@
return [tokens count];
}

-- (NSInteger) getIndex
-{
-	return p;
-}
-
- (void) rewind
{
[self seek:lastMarker];
@@ -305,15 +300,15 @@
[self seek:marker];
}

-- (void) seek:(NSInteger)index
+- (void) seek:(NSInteger)anIndex
{
-	p = index;
+	index = anIndex;
}
#pragma mark toString routines

- (NSString *) toString
{
-	if ( p == -1 ) {
+	if ( index == -1 ) {
[self setup];
}
return [self toStringFromStart:0 ToEnd:[tokens count]];
@@ -327,7 +322,7 @@
if ( startIdx < 0 || stopIdx < 0 ) {
return nil;
}
-    if ( p == -1 ) {
+    if ( index == -1 ) {
[self setup];
}
if ( stopIdx >= [tokens count] ) {
@@ -336,7 +331,7 @@
stringBuffer = [NSMutableString stringWithCapacity:30];
for (int i = startIdx; i <= stopIdx; i++) {
t = (id<ANTLRToken>)[tokens objectAtIndex:i];
-        [stringBuffer appendString:[t getText]];
+        [stringBuffer appendString:[t text]];
}
return stringBuffer;
}
diff --git a/runtime/ObjC/Framework/ANTLRCommonTree.h b/runtime/ObjC/Framework/ANTLRCommonTree.h
index 3598714..d5e382a 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTree.h
+++ b/runtime/ObjC/Framework/ANTLRCommonTree.h
@@ -29,6 +29,11 @@
#import "ANTLRBaseTree.h"

@interface ANTLRCommonTree : ANTLRBaseTree <ANTLRTree> {
+	ANTLRCommonToken *token;
+	NSInteger startIndex;
+	NSInteger stopIndex;
+    ANTLRCommonTree *parent;
+    NSInteger childIndex;
}

+ (ANTLRCommonTree *) invalidNode;
@@ -37,12 +42,6 @@
+ (ANTLRCommonTree *) newTreeWithToken:(ANTLRCommonToken *)aToken;
+ (ANTLRCommonTree *) newTreeWithTokenType:(NSInteger)tokenType;
+ (ANTLRCommonTree *) newTreeWithTokenType:(NSInteger)aTType Text:(NSString *)theText;
-#ifdef DONTUSEYET
-+ (id<ANTLRBaseTree>) newTreeWithTokenType:(NSInteger)tokenType;
-+ (id<ANTLRBaseTree>) newTreeWithToken:(id<ANTLRToken>)fromToken TokenType:(NSInteger)tokenType;
-+ (id<ANTLRBaseTree>) newTreeWithToken:(id<ANTLRToken>)fromToken TokenType:(NSInteger)tokenType Text:(NSString *)tokenText;
-+ (id<ANTLRBaseTree>) newTreeWithToken:(id<ANTLRToken>)fromToken Text:(NSString *)tokenText;
-#endif

- (id) init;
- (id) initWithTreeNode:(ANTLRCommonTree *)aNode;
@@ -56,11 +55,11 @@

- (ANTLRCommonToken *) getToken;
- (void) setToken:(ANTLRCommonToken *)aToken;
-- (id<ANTLRBaseTree>) dupNode;
+- (ANTLRCommonToken *) dupNode;
- (NSInteger) getType;
-- (NSString *) getText;
-- (NSUInteger) getLine;
-- (NSUInteger) getCharPositionInLine;
+- (NSString *) text;
+- (NSUInteger) line;
+- (NSUInteger) charPositionInLine;
- (ANTLRCommonTree *) getParent;
- (void) setParent:(ANTLRCommonTree *) t;

@@ -82,4 +81,10 @@
@property (assign, getter=getChildIndex, setter=setChildIndex:) NSInteger childIndex;
*/

+@property (retain) ANTLRCommonToken *token;
+@property (assign) NSInteger startIndex;
+@property (assign) NSInteger stopIndex;
+@property (retain) ANTLRCommonTree *parent;
+@property (assign) NSInteger childIndex;
+
@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTree.m b/runtime/ObjC/Framework/ANTLRCommonTree.m
index 615a6c1..352c7f7 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTree.m
+++ b/runtime/ObjC/Framework/ANTLRCommonTree.m
@@ -29,46 +29,38 @@

@implementation ANTLRCommonTree

-/*
-@synthesize token;
-@synthesize startIndex;
-@synthesize stopIndex;
-@synthesize parent;
-@synthesize childIndex;
-*/
-
-+ (id<ANTLRBaseTree>)INVALID_NODE
++ (ANTLRCommonTree *)INVALID_NODE
{
return [[ANTLRCommonTree alloc] initWithToken:[ANTLRCommonToken invalidToken]];
}

-+ (id<ANTLRBaseTree>)invalidNode
++ (ANTLRCommonTree *)invalidNode
{
-    // Had to cast to id<ANTLRBaseTree> here, because GCC is dumb.
+    // Had to cast to ANTLRCommonTree * here, because GCC is dumb.
return [[ANTLRCommonTree alloc] initWithToken:ANTLRCommonToken.INVALID_TOKEN];
}

-+ (id<ANTLRBaseTree>)newTree
++ (ANTLRCommonTree *)newTree
{
return [[ANTLRCommonTree alloc] init];
}

-+ (id<ANTLRBaseTree>)newTreeWithTree:(id<ANTLRBaseTree>)aTree
++ (ANTLRCommonTree *)newTreeWithTree:(ANTLRCommonTree *)aTree
{
return [[ANTLRCommonTree alloc] initWithTreeNode:aTree];
}

-+ (id<ANTLRBaseTree>)newTreeWithToken:(id<ANTLRToken>)aToken
++ (ANTLRCommonTree *)newTreeWithToken:(id<ANTLRToken>)aToken
{
return [[ANTLRCommonTree alloc] initWithToken:aToken];
}

-+ (id<ANTLRBaseTree>)newTreeWithTokenType:(NSInteger)aTType
++ (ANTLRCommonTree *)newTreeWithTokenType:(NSInteger)aTType
{
return [[ANTLRCommonTree alloc] initWithTokenType:(NSInteger)aTType];
}

-+ (id<ANTLRBaseTree>)newTreeWithTokenType:(NSInteger)aTType Text:(NSString *)theText
++ (ANTLRCommonTree *)newTreeWithTokenType:(NSInteger)aTType Text:(NSString *)theText
{
return [[ANTLRCommonTree alloc] initWithTokenType:(NSInteger)aTType Text:theText];
}
@@ -83,10 +75,10 @@
parent = nil;
childIndex = -1;
}
-	return (id<ANTLRBaseTree>)self;
+	return (ANTLRCommonTree *)self;
}

-- (id)initWithTreeNode:(id<ANTLRBaseTree>)aNode
+- (id)initWithTreeNode:(ANTLRCommonTree *)aNode
{
self = (ANTLRCommonTree *)[super init];
if ( self != nil ) {
@@ -96,7 +88,7 @@
parent = nil;
childIndex = -1;
}
-	return (id<ANTLRBaseTree>)self;
+	return self;
}

- (id)initWithToken:(id<ANTLRToken>)aToken
@@ -109,7 +101,7 @@
parent = nil;
childIndex = -1;
}
-	return (id<ANTLRBaseTree>)self;
+	return self;
}

- (id)initWithTokenType:(NSInteger)aTokenType
@@ -124,7 +116,7 @@
parent = nil;
childIndex = -1;
}
-	return (id<ANTLRBaseTree>)self;
+	return self;
}

- (id) initWithTokenType:(NSInteger)aTokenType Text:(NSString *)theText
@@ -139,7 +131,7 @@
parent = nil;
childIndex = -1;
}
-	return (id<ANTLRBaseTree>)self;
+	return self;
}

- (void) dealloc
@@ -176,13 +168,13 @@
- (void) setToken:(ANTLRCommonToken *) aToken
{
if (token != aToken) {
-		[aToken retain];
[token release];
token = aToken;
+		[token retain];
}
}

-- (id<ANTLRBaseTree>) dupNode
+- (ANTLRCommonTree *) dupNode
{
return [ANTLRCommonTree newTreeWithTree:self ];
}
@@ -194,31 +186,31 @@
return ANTLRTokenTypeInvalid;
}

-- (NSString *) getText
+- (NSString *) text
{
if (token)
-		return [token getText];
+		return [token text];
return nil;
}

-- (NSUInteger) getLine
+- (NSUInteger) line
{
if (token)
-		return [token getLine];
+		return token.line;
return 0;
}

-- (NSUInteger) getCharPositionInLine
+- (NSUInteger) charPositionInLine
{
if (token)
-		return [token getCharPositionInLine];
+		return token.charPositionInLine;
return 0;
}

- (void) setCharPositionInLine:(int)pos
{
if (token)
-        [token setCharPositionInLine:pos];
+        token.charPositionInLine = pos;
}

- (NSInteger) getTokenStartIndex
@@ -295,14 +287,14 @@
return childIndex;
}

-- (id<ANTLRBaseTree>) getParent
+- (ANTLRCommonTree *) getParent
{
return parent;
}

-- (void) setParent:(id<ANTLRBaseTree>) t
+- (void) setParent:(ANTLRCommonTree *) t
{
-    parent = (id<ANTLRBaseTree>)t;
+    parent = t;
}

- (void) setChildIndex:(NSInteger) anIndex
@@ -326,7 +318,13 @@
if ( token==nil ) {
return nil;
}
-    return [token getText];
+    return token.text;
}

+@synthesize token;
+@synthesize startIndex;
+@synthesize stopIndex;
+@synthesize parent;
+@synthesize childIndex;
+
@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.h b/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.h
index 90f0d49..e79f0ab 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.h
+++ b/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.h
@@ -34,32 +34,32 @@
@interface ANTLRCommonTreeAdaptor : ANTLRBaseTreeAdaptor {
}

-+ (id<ANTLRBaseTree>) newEmptyTree;
++ (ANTLRCommonTree *) newEmptyTree;
+ (ANTLRCommonTreeAdaptor *)newTreeAdaptor;
- (id) init;
-- (id<ANTLRBaseTree>)dupNode:(id<ANTLRBaseTree>)t;
+- (ANTLRCommonTree *)dupNode:(ANTLRCommonTree *)t;

-- (id<ANTLRBaseTree>) create:(id<ANTLRToken>) payload;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType fromToken:(ANTLRCommonToken *)aToken;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType fromToken:(ANTLRCommonToken *)aToken Text:(NSString *)text;
+- (ANTLRCommonTree *) create:(id<ANTLRToken>) payload;
+//- (ANTLRCommonTree *) createTree:(NSInteger)tokenType fromToken:(ANTLRCommonToken *)aToken;
+//- (ANTLRCommonTree *) createTree:(NSInteger)tokenType fromToken:(ANTLRCommonToken *)aToken Text:(NSString *)text;
- (id<ANTLRToken>)createToken:(NSInteger)tokenType Text:(NSString *)text;
- (id<ANTLRToken>)createToken:(id<ANTLRToken>)fromToken;
-- (void) setTokenBoundaries:(id<ANTLRBaseTree>)t From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
-- (NSInteger)getTokenStartIndex:(id<ANTLRBaseTree>)t;
-- (NSInteger)getTokenStopIndex:(id<ANTLRBaseTree>)t;
-- (NSString *)getText:(id<ANTLRBaseTree>)t;
-- (void)setText:(id<ANTLRBaseTree>)t Text:(NSString *)text;
-- (NSInteger)getType:(id<ANTLRBaseTree>)t;
-- (void) setType:(id<ANTLRBaseTree>)t Type:(NSInteger)tokenType;
-- (id<ANTLRToken>)getToken:(id<ANTLRBaseTree>)t;
-- (id<ANTLRBaseTree>)getChild:(id<ANTLRBaseTree>)t At:(NSInteger)i;
-- (void) setChild:(id<ANTLRBaseTree>)t At:(NSInteger)i Child:(id<ANTLRBaseTree>)child;
-- (NSInteger)getChildCount:(id<ANTLRBaseTree>)t;
-- (id<ANTLRBaseTree>)getParent:(id<ANTLRBaseTree>)t;
-- (void)setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>)parent;
-- (NSInteger)getChildIndex:(id<ANTLRBaseTree>)t;
-- (void)setChildIndex:(id<ANTLRBaseTree>)t With:(NSInteger)index;
-- (void)replaceChildren:(id<ANTLRBaseTree>)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id<ANTLRBaseTree>)t;
+- (void) setTokenBoundaries:(ANTLRCommonTree *)t From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
+- (NSInteger)getTokenStartIndex:(ANTLRCommonTree *)t;
+- (NSInteger)getTokenStopIndex:(ANTLRCommonTree *)t;
+- (NSString *)getText:(ANTLRCommonTree *)t;
+- (void)setText:(ANTLRCommonTree *)t Text:(NSString *)text;
+- (NSInteger)getType:(ANTLRCommonTree *)t;
+- (void) setType:(ANTLRCommonTree *)t Type:(NSInteger)tokenType;
+- (id<ANTLRToken>)getToken:(ANTLRCommonTree *)t;
+- (ANTLRCommonTree *)getChild:(ANTLRCommonTree *)t At:(NSInteger)i;
+- (void) setChild:(ANTLRCommonTree *)t At:(NSInteger)i Child:(ANTLRCommonTree *)child;
+- (NSInteger)getChildCount:(ANTLRCommonTree *)t;
+- (ANTLRCommonTree *)getParent:(ANTLRCommonTree *)t;
+- (void)setParent:(ANTLRCommonTree *)t With:(ANTLRCommonTree *)parent;
+- (NSInteger)getChildIndex:(ANTLRCommonTree *)t;
+- (void)setChildIndex:(ANTLRCommonTree *)t With:(NSInteger)index;
+- (void)replaceChildren:(ANTLRCommonTree *)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(ANTLRCommonTree *)t;
- (id)copyWithZone:(NSZone *)zone;

@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m b/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m
index 525758d..e1dd459 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m
+++ b/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m
@@ -139,7 +139,7 @@
{
if ( t == nil )
return nil;
-    return [(id<ANTLRBaseTree>) t getText];
+    return [(id<ANTLRBaseTree>) t text];
}

- (void)setText:(id<ANTLRBaseTree>)t Text:(NSString *)text
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m
index abab0a0..ccb8dde 100644
--- a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m
+++ b/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m
@@ -28,6 +28,7 @@
#import "ANTLRTokenStream.h"
#import "ANTLRIntStream.h"
#import "ANTLRCharStream.h"
+#import "AMutableArray.h"

@implementation ANTLRCommonTreeNodeStream

diff --git a/runtime/ObjC/Framework/ANTLRDFA.m b/runtime/ObjC/Framework/ANTLRDFA.m
index 48aba4c..bf124c2 100644
--- a/runtime/ObjC/Framework/ANTLRDFA.m
+++ b/runtime/ObjC/Framework/ANTLRDFA.m
@@ -242,9 +242,8 @@ NSInteger debug = 0;

- (void)setRecognizer:(ANTLRBaseRecognizer *)aRecognizer
{
-    if (recognizer != aRecognizer) {
-        if (recognizer != nil)
-            [recognizer release];
+    if ( recognizer != aRecognizer ) {
+        if ( recognizer ) [recognizer release];
[aRecognizer retain];
}
recognizer = aRecognizer;
diff --git a/runtime/ObjC/Framework/ANTLRDebugParser.h b/runtime/ObjC/Framework/ANTLRDebugParser.h
index b23ff50..ed403ef 100644
--- a/runtime/ObjC/Framework/ANTLRDebugParser.h
+++ b/runtime/ObjC/Framework/ANTLRDebugParser.h
@@ -33,6 +33,16 @@
id<ANTLRDebugEventListener> debugListener;
}

++ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
+        debugListener:(id<ANTLRDebugEventListener>)debugListener;
+
++ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
+                state:(ANTLRRecognizerSharedState *)state;
+
++ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
+        debugListener:(id<ANTLRDebugEventListener>)debugListener
+                state:(ANTLRRecognizerSharedState *)state;
+
- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream;
- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
debuggerPort:(NSInteger)portNumber;
diff --git a/runtime/ObjC/Framework/ANTLRDebugParser.m b/runtime/ObjC/Framework/ANTLRDebugParser.m
index 91bb0fc..f86a8ba 100644
--- a/runtime/ObjC/Framework/ANTLRDebugParser.m
+++ b/runtime/ObjC/Framework/ANTLRDebugParser.m
@@ -110,21 +110,4 @@
[debugListener endBacktrack:level wasSuccessful:successful];
}

-- (void) recoverFromMismatchedToken:(id<ANTLRIntStream>)inputStream
-						  exception:(NSException *)e
-						  tokenType:(ANTLRTokenType)ttype
-							 follow:(ANTLRBitSet *)follow
-{
-#warning TODO: recoverFromMismatchedToken in debugger
-	[super recoverFromMismatchedToken:inputStream exception:e tokenType:ttype follow:follow];
-}
-
-- (void) recoverFromMismatchedSet:(id<ANTLRIntStream>)inputStream
-						exception:(NSException *)e
-						   follow:(ANTLRBitSet *)follow
-{
-#warning TODO: recoverFromMismatchedSet in debugger
-	[super recoverFromMismatchedSet:inputStream exception:e follow:follow];
-}
-
@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTokenStream.m b/runtime/ObjC/Framework/ANTLRDebugTokenStream.m
index 43fe823..b7ece55 100644
--- a/runtime/ObjC/Framework/ANTLRDebugTokenStream.m
+++ b/runtime/ObjC/Framework/ANTLRDebugTokenStream.m
@@ -72,15 +72,15 @@
- (void) setInput: (id<ANTLRTokenStream>) aTokenStream
{
if (input != aTokenStream) {
-        [aTokenStream retain];
-        [input release];
+        if ( input ) [input release];
input = aTokenStream;
+        [input retain];
}
}

- (void) consumeInitialHiddenTokens
{
-	int firstIdx = [input getIndex];
+	int firstIdx = input.index;
for (int i = 0; i<firstIdx; i++)
[debugListener consumeHiddenToken:[input getToken:i]];
initialStreamState = NO;
@@ -100,10 +100,10 @@
{
if ( initialStreamState )
[self consumeInitialHiddenTokens];
-	int a = [input getIndex];
+	int a = input.index;
id<ANTLRToken> token = [input LT:1];
[input consume];
-	int b = [input getIndex];
+	int b = input.index;
[debugListener consumeToken:token];
if (b > a+1) // must have consumed hidden tokens
for (int i = a+1; i < b; i++)
@@ -152,7 +152,7 @@

- (NSInteger) getIndex
{
-    return [input getIndex];
+    return input.index;
}

- (void) release:(NSInteger) marker
@@ -193,7 +193,7 @@

- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken
{
-    return [input toStringFromStart:[startToken getStartIndex] ToEnd:[stopToken getStopIndex]];
+    return [input toStringFromStart:[startToken getStart] ToEnd:[stopToken getStopToken]];
}

@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m
index dd13bfb..7fad04c 100644
--- a/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m
+++ b/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m
@@ -136,7 +136,7 @@

- (NSUInteger) getIndex
{
-	return [input getIndex];
+	return input.index;
}

- (void) rewind:(NSUInteger) marker
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeParser.h b/runtime/ObjC/Framework/ANTLRDebugTreeParser.h
index cbeac76..171c1e7 100644
--- a/runtime/ObjC/Framework/ANTLRDebugTreeParser.h
+++ b/runtime/ObjC/Framework/ANTLRDebugTreeParser.h
@@ -44,5 +44,9 @@
- (id<ANTLRDebugEventListener>) debugListener;
- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;

+- (void) recoverFromMismatchedToken:(id<ANTLRIntStream>)inputStream
+						  exception:(NSException *)e
+						  tokenType:(ANTLRTokenType)ttype
+							 follow:(ANTLRBitSet *)follow;

@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeParser.m b/runtime/ObjC/Framework/ANTLRDebugTreeParser.m
index 000dbce..543c3dd 100644
--- a/runtime/ObjC/Framework/ANTLRDebugTreeParser.m
+++ b/runtime/ObjC/Framework/ANTLRDebugTreeParser.m
@@ -114,7 +114,7 @@
follow:(ANTLRBitSet *)follow
{
#warning TODO: recoverFromMismatchedToken in debugger
-	[super recoverFromMismatchedToken:inputStream exception:e tokenType:ttype follow:follow];
+	[self recoverFromMismatchedToken:inputStream exception:e follow:follow];
}

- (void) recoverFromMismatchedSet:(id<ANTLRIntStream>)inputStream
@@ -122,7 +122,7 @@
follow:(ANTLRBitSet *)follow
{
#warning TODO: recoverFromMismatchedSet in debugger
-	[super recoverFromMismatchedSet:inputStream exception:e follow:follow];
+	[super recoverFromMismatchedSet:inputStream];
}

@end
diff --git a/runtime/ObjC/Framework/ANTLRDoubleKeyMap.h b/runtime/ObjC/Framework/ANTLRDoubleKeyMap.h
index 7371675..7885879 100644
--- a/runtime/ObjC/Framework/ANTLRDoubleKeyMap.h
+++ b/runtime/ObjC/Framework/ANTLRDoubleKeyMap.h
@@ -1,3 +1,6 @@
+
+#import "AMutableArray.h"
+#import "AMutableDictionary.h"
#import "ANTLRLinkBase.h"
/**
* Sometimes we need to map a key to a value but key is two pieces of data.
@@ -5,19 +8,21 @@
* map; avoids mem creation.
*/

-
+@class AMutableArray;

@interface ANTLRDoubleKeyMap : ANTLRLinkBase {
-    NSMutableDictionary *data;
+    AMutableDictionary *data;
}

- (id) init;
- (id) setObject:(id)v forKey1:(id)k1 forKey2:(NSString *)k2;
- (id) objectForKey1:(id)k1 forKey2:(id)k2;
-- (NSMutableDictionary *) objectForKey:(id)k1;
+- (AMutableDictionary *) objectForKey:(id)k1;
- (NSArray *) valuesForKey:(id)k1;
- (NSArray *) allKeys1;
-- (NSArray *) allKeys2:(id)k1;
-- (NSMutableArray *) values;
-@property (retain) NSMutableDictionary *data;
+- (AMutableArray *) allKeys2:(id)k1;
+- (NSArray *) values;
+
+@property (retain) AMutableDictionary *data;
+
@end
diff --git a/runtime/ObjC/Framework/ANTLRDoubleKeyMap.m b/runtime/ObjC/Framework/ANTLRDoubleKeyMap.m
index 3e30411..f6269f0 100644
--- a/runtime/ObjC/Framework/ANTLRDoubleKeyMap.m
+++ b/runtime/ObjC/Framework/ANTLRDoubleKeyMap.m
@@ -6,17 +6,17 @@
{
self = [super init];
if ( self  != nil ) {
-        data = [NSMutableDictionary dictionaryWithCapacity:30];
+        data = [AMutableDictionary dictionaryWithCapacity:30];
}
return self;
}

- (id) setObject:(id)v forKey1:(id)k1 forKey2:(id)k2
{
-    NSMutableDictionary *data2 = [data objectForKey:k1];
+    AMutableDictionary *data2 = [data objectForKey:k1];
id prev = nil;
if (data2 == nil) {
-        data2 = [[NSMutableDictionary dictionaryWithCapacity:30] retain];
+        data2 = [[AMutableDictionary dictionaryWithCapacity:30] retain];
[data setObject:data2 forKey:k1];
}
else {
@@ -28,13 +28,13 @@

- (id) objectForKey1:(id)k1 forKey2:(id)k2
{
-    NSMutableDictionary *data2 = [data objectForKey:k1];
+    AMutableDictionary *data2 = [data objectForKey:k1];
if (data2 == nil)
return nil;
return [data2 objectForKey:k2];
}

-- (NSMutableDictionary *) objectForKey:(id)k1
+- (AMutableDictionary *) objectForKey:(id)k1
{
return [data objectForKey:k1];
}
@@ -45,7 +45,7 @@
*/
- (NSArray *) valuesForKey:(id)k1
{
-    NSMutableDictionary * data2 = [data objectForKey:k1];
+    AMutableDictionary *data2 = [data objectForKey:k1];
if (data2 == nil)
return nil;
return [data2 allValues];
@@ -66,18 +66,18 @@
*/
- (NSArray *) allKeys2:(id)k1
{
-    NSMutableDictionary * data2 = [data objectForKey:k1];
+    AMutableDictionary * data2 = [data objectForKey:k1];
if (data2 == nil)
return nil;
return [data2 allKeys];
}

-- (NSMutableArray *) values
+- (AMutableArray *) values
{
//    ANTLRHashMap *s = [[ANTLRHashMap newANTLRHashMapWithLen:30];
-    NSMutableArray *s = [NSMutableArray arrayWithCapacity:30];
+    AMutableArray *s = [AMutableArray arrayWithCapacity:30];

-    for (NSMutableDictionary *k2 in [data allValues]) {
+    for (AMutableDictionary *k2 in [data allValues]) {

for ( NSString *v in [k2 allValues]) {
[s addObject:v];
diff --git a/runtime/ObjC/Framework/ANTLRFailedPredicateException.m b/runtime/ObjC/Framework/ANTLRFailedPredicateException.m
index cadba77..fadb5d1 100644
--- a/runtime/ObjC/Framework/ANTLRFailedPredicateException.m
+++ b/runtime/ObjC/Framework/ANTLRFailedPredicateException.m
@@ -29,6 +29,9 @@

@implementation ANTLRFailedPredicateException

+@synthesize predicate;
+@synthesize ruleName;
+
+ (ANTLRFailedPredicateException *) newException:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream
{
return [[ANTLRFailedPredicateException alloc] initWithRuleName:theRuleName predicate:thePredicate stream:theStream];
@@ -67,7 +70,7 @@
{
if (thePredicate != predicate) {
[thePredicate retain];
-		[predicate release];
+		if ( predicate ) [predicate release];
predicate = thePredicate;
}
}
@@ -81,7 +84,7 @@
{
if (theRuleName != ruleName) {
[theRuleName retain];
-		[ruleName release];
+		if ( ruleName ) [ruleName release];
ruleName = theRuleName;
}
}
diff --git a/runtime/ObjC/Framework/ANTLRFastQueue.h b/runtime/ObjC/Framework/ANTLRFastQueue.h
index 81790b8..1b66938 100644
--- a/runtime/ObjC/Framework/ANTLRFastQueue.h
+++ b/runtime/ObjC/Framework/ANTLRFastQueue.h
@@ -30,18 +30,18 @@
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#import <Cocoa/Cocoa.h>
-
+#import "AMutableArray.h"

@interface ANTLRFastQueue : NSObject <NSCopying>
{
//	NSAutoreleasePool *pool;
-	NSMutableArray *data;
+	AMutableArray *data;
NSUInteger p;
NSUInteger range;
}

//@property (retain, getter=getPool, setter=setPool:) NSAutoreleasePool *pool;
-@property (retain) NSMutableArray *data;
+@property (retain) AMutableArray *data;
@property (assign) NSUInteger p;
@property (assign) NSUInteger range;

diff --git a/runtime/ObjC/Framework/ANTLRFastQueue.m b/runtime/ObjC/Framework/ANTLRFastQueue.m
index 8776a2b..6c5ce79 100644
--- a/runtime/ObjC/Framework/ANTLRFastQueue.m
+++ b/runtime/ObjC/Framework/ANTLRFastQueue.m
@@ -42,14 +42,14 @@

+ (id) newANTLRFastQueue
{
-    return [[[ANTLRFastQueue alloc] init] retain];
+    return [[ANTLRFastQueue alloc] init];
}

- (id) init
{
if ((self = [super init]) != nil ) {
//		pool = [NSAutoreleasePool new];
-		data = [[NSMutableArray arrayWithCapacity:100] autorelease];
+		data = [AMutableArray arrayWithCapacity:100];
p = 0;
range = -1;
}
@@ -82,7 +82,8 @@
- (void) clear
{
p = 0;
-	[data removeAllObjects];
+    if ( [data count] )
+        [data removeAllObjects];
}

- (id) remove
@@ -100,7 +101,8 @@

- (void) addObject:(id) o
{
-	[data addObject:o];
+	[o retain];
+    [data addObject:o];
}

- (NSUInteger) count
diff --git a/runtime/ObjC/Framework/ANTLRHashMap.m b/runtime/ObjC/Framework/ANTLRHashMap.m
index 7e07008..489cbfa 100644
--- a/runtime/ObjC/Framework/ANTLRHashMap.m
+++ b/runtime/ObjC/Framework/ANTLRHashMap.m
@@ -56,18 +56,18 @@ static NSInteger itIndex;
{
NSInteger idx;

-	if ((self = [super init]) != nil) {
-		fNext = nil;
+    if ((self = [super init]) != nil) {
+        fNext = nil;
BuffSize = HASHSIZE;
-		Scope = 0;
-		if ( fNext != nil ) {
-			Scope = ((ANTLRHashMap *)fNext)->Scope+1;
-			for( idx = 0; idx < BuffSize; idx++ ) {
-				ptrBuffer[idx] = ((ANTLRHashMap *)fNext)->ptrBuffer[idx];
-			}
-		}
+        Scope = 0;
+        if ( fNext != nil ) {
+            Scope = ((ANTLRHashMap *)fNext)->Scope+1;
+            for( idx = 0; idx < BuffSize; idx++ ) {
+                ptrBuffer[idx] = ((ANTLRHashMap *)fNext)->ptrBuffer[idx];
+            }
+        }
mode = 0;
-	}
+    }
return( self );
}

@@ -75,18 +75,18 @@ static NSInteger itIndex;
{
NSInteger idx;

-	if ((self = [super init]) != nil) {
-		fNext = nil;
+    if ((self = [super init]) != nil) {
+        fNext = nil;
BuffSize = aBuffSize;
-		Scope = 0;
-		if ( fNext != nil ) {
-			Scope = ((ANTLRHashMap *)fNext)->Scope+1;
-			for( idx = 0; idx < BuffSize; idx++ ) {
-				ptrBuffer[idx] = ((ANTLRHashMap *)fNext)->ptrBuffer[idx];
-			}
-		}
+        Scope = 0;
+        if ( fNext != nil ) {
+            Scope = ((ANTLRHashMap *)fNext)->Scope+1;
+            for( idx = 0; idx < BuffSize; idx++ ) {
+                ptrBuffer[idx] = ((ANTLRHashMap *)fNext)->ptrBuffer[idx];
+            }
+        }
mode = 0;
-	}
+    }
return( self );
}

@@ -94,7 +94,7 @@ static NSInteger itIndex;
{
ANTLRMapElement *tmp, *rtmp;
NSInteger idx;
-
+
if ( self.fNext != nil ) {
for( idx = 0; idx < BuffSize; idx++ ) {
tmp = ptrBuffer[idx];
@@ -106,7 +106,7 @@ static NSInteger itIndex;
}
}
}
-	[super dealloc];
+    [super dealloc];
}

- (NSInteger)count
@@ -175,7 +175,7 @@ static NSInteger itIndex;
{
NSInteger idx;
ANTLRMapElement *tmp;
-	ANTLRHashMap *htmp;
+    ANTLRHashMap *htmp;

htmp = *map;
if ( (*map)->fNext != nil ) {
@@ -213,14 +213,14 @@ static NSInteger itIndex;
#endif
-(NSInteger)hash:(NSString *)s       /*    form hash value for string s */
{
-	NSInteger hashval;
-	const char *tmp;
+    NSInteger hashval;
+    const char *tmp;

-	tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
-	for( hashval = 0; *tmp != '\0'; )
+    tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
+    for( hashval = 0; *tmp != '\0'; )
hashval += *tmp++;
-	self->LastHash = hashval % BuffSize;
-	return( self->LastHash );
+    self->LastHash = hashval % BuffSize;
+    return( self->LastHash );
}

#ifdef USERDOC
@@ -330,8 +330,8 @@ static NSInteger itIndex;
-(void)delete_chain:(ANTLRMapElement *)np
{
if ( [np getfNext] != nil )
-		[self delete_chain:[np getfNext]];
-	[np dealloc];
+        [self delete_chain:[np getfNext]];
+    [np dealloc];
}

#ifdef DONTUSEYET
@@ -352,30 +352,30 @@ static NSInteger itIndex;

-(ANTLRMapElement *)getptrBufferEntry:(NSInteger)idx
{
-	return( ptrBuffer[idx] );
+    return( ptrBuffer[idx] );
}

-(ANTLRMapElement **)getptrBuffer
{
-	return( ptrBuffer );
+    return( ptrBuffer );
}

-(void)setptrBuffer:(ANTLRMapElement *)np Index:(NSInteger)idx
{
-	if ( idx < BuffSize ) {
+    if ( idx < BuffSize ) {
[np retain];
-		ptrBuffer[idx] = np;
+        ptrBuffer[idx] = np;
}
}

-(NSInteger)getScope
{
-	return( Scope );
+    return( Scope );
}

-(void)setScopeScope:(NSInteger)i
{
-	Scope = i;
+    Scope = i;
}

- (ANTLRMapElement *)getTType:(NSString *)name
@@ -393,7 +393,7 @@ static NSInteger itIndex;

aTType = ttype % BuffSize;
for( np = self->ptrBuffer[ttype]; np != nil; np = [np getfNext] ) {
-        if ( [np.index integerValue] == ttype ) {
+        if ( [(NSNumber *)np.node integerValue] == ttype ) {
return( np );        /*   found it       */
}
}
@@ -443,8 +443,8 @@ static NSInteger itIndex;
if ( idx >= BuffSize ) {
idx %= BuffSize;
}
-    if (aRule != ptrBuffer[idx]) {
-        if (ptrBuffer[idx] != nil) [ptrBuffer[idx] release];
+    if ( aRule != ptrBuffer[idx] ) {
+        if ( ptrBuffer[idx] != nil ) [ptrBuffer[idx] release];
[aRule retain];
}
ptrBuffer[idx] = aRule;
@@ -465,8 +465,8 @@ static NSInteger itIndex;
if ( idx >= BuffSize ) {
idx %= BuffSize;
}
-    if (aRule != ptrBuffer[idx]) {
-        if (ptrBuffer[idx] != nil) [ptrBuffer[idx] release];
+    if ( aRule != ptrBuffer[idx] ) {
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
[aRule retain];
}
ptrBuffer[idx] = aRule;
@@ -479,7 +479,7 @@ static NSInteger itIndex;
np = [self lookup:name Scope:0 ];
if ( np == nil ) {
np = [ANTLRMapElement newANTLRMapElementWithName:name Node:aNode];
-        if (ptrBuffer[LastHash] != nil)
+        if ( ptrBuffer[LastHash] )
[ptrBuffer[LastHash] release];
[np retain];
np.fNext = ptrBuffer[ LastHash ];
diff --git a/runtime/ObjC/Framework/ANTLRHashRule.m b/runtime/ObjC/Framework/ANTLRHashRule.m
index 6919045..36b6204 100644
--- a/runtime/ObjC/Framework/ANTLRHashRule.m
+++ b/runtime/ObjC/Framework/ANTLRHashRule.m
@@ -52,16 +52,16 @@

-(id)init
{
-	if ((self = [super initWithLen:HASHSIZE]) != nil) {
-	}
+    if ((self = [super initWithLen:HASHSIZE]) != nil) {
+    }
return( self );
}

-(id)initWithLen:(NSInteger)aBuffSize
{
-	if ((self = [super initWithLen:aBuffSize]) != nil) {
+    if ((self = [super initWithLen:aBuffSize]) != nil) {
mode = 0;
-	}
+    }
return( self );
}

@@ -69,7 +69,7 @@
{
ANTLRRuleMemo *tmp, *rtmp;
int Index;
-
+
if ( self.fNext != nil ) {
for( Index = 0; Index < BuffSize; Index++ ) {
tmp = ptrBuffer[Index];
@@ -83,7 +83,7 @@
}
}
}
-	[super dealloc];
+    [super dealloc];
}

- (NSInteger)count
@@ -142,18 +142,18 @@
-(void)delete_chain:(ANTLRRuleMemo *)np
{
if ( np.fNext != nil )
-		[self delete_chain:np.fNext];
-	[np dealloc];
+        [self delete_chain:np.fNext];
+    [np dealloc];
}

-(ANTLRRuleMemo **)getPtrBuffer
{
-	return( ptrBuffer );
+    return( ptrBuffer );
}

-(void)setPtrBuffer:(ANTLRRuleMemo **)np
{
-	ptrBuffer = np;
+    ptrBuffer = np;
}

- (NSNumber *)getRuleMemoStopIndex:(NSInteger)aStartIndex
diff --git a/runtime/ObjC/Framework/ANTLRIntStream.h b/runtime/ObjC/Framework/ANTLRIntStream.h
index 3790cd9..742dc6b 100644
--- a/runtime/ObjC/Framework/ANTLRIntStream.h
+++ b/runtime/ObjC/Framework/ANTLRIntStream.h
@@ -42,7 +42,11 @@
// Return the current input symbol index 0..n where n indicates the
// last symbol has been read.

-- (NSInteger) getIndex;
+- (NSInteger) index;
+
+- (NSUInteger) line;
+
+- (NSUInteger) charPositionInLine;

// Reset the stream so that next call to index would return marker.
// The marker will usually be -index but it doesn't have to be.  It's
@@ -77,7 +81,7 @@
// Currently, this method is only used for efficient backtracking, but
// in the future it may be used for incremental parsing.

-- (void) seek:(NSInteger) index;
+- (void) seek:(NSInteger) anIndex;

/** Only makes sense for streams that buffer everything up probably, but
*  might be useful to display the entire stream or for testing.  This
@@ -90,4 +94,9 @@
*/
- (NSString *)getSourceName;

+//@property (assign) NSInteger index;
+//@property (assign) NSUInteger line;
+//@property (assign) NSUInteger charPositionInLine;
+
+
@end
diff --git a/runtime/ObjC/Framework/ANTLRLexer.h b/runtime/ObjC/Framework/ANTLRLexer.h
index 7576735..5da5fee 100644
--- a/runtime/ObjC/Framework/ANTLRLexer.h
+++ b/runtime/ObjC/Framework/ANTLRLexer.h
@@ -73,15 +73,15 @@
- (void) matchRangeFromChar:(unichar)fromChar to:(unichar)toChar;

#pragma mark Informational
-- (NSUInteger) getLine;
-- (NSUInteger) getCharPositionInLine;
-- (NSInteger) getIndex;
-- (NSString *) getText;
+- (NSUInteger) line;
+- (NSUInteger) charPositionInLine;
+- (NSInteger) index;
+- (NSString *) text;
- (void) setText:(NSString *) theText;

// error handling
- (void) reportError:(ANTLRRecognitionException *)e;
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(NSMutableArray *)tokenNames;
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)tokenNames;
- (NSString *)getCharErrorDisplay:(NSInteger)c;
- (void) recover:(ANTLRRecognitionException *)e;
- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex;
diff --git a/runtime/ObjC/Framework/ANTLRLexer.m b/runtime/ObjC/Framework/ANTLRLexer.m
index 62dc685..67d9cd0 100644
--- a/runtime/ObjC/Framework/ANTLRLexer.m
+++ b/runtime/ObjC/Framework/ANTLRLexer.m
@@ -24,7 +24,7 @@
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

-
+#import <ANTLR/antlr.h>
#import "ANTLRLexer.h"

@implementation ANTLRLexer
@@ -117,20 +117,20 @@
while (YES) {
[self setToken:nil];
state.channel = ANTLRCommonToken.DEFAULT_CHANNEL;
-        state.tokenStartCharIndex = [input getIndex];
-        state.tokenStartCharPositionInLine = [input getCharPositionInLine];
-        state.tokenStartLine = [input getLine];
+        state.tokenStartCharIndex = input.index;
+        state.tokenStartCharPositionInLine = input.charPositionInLine;
+        state.tokenStartLine = input.line;
state.text = nil;

-        // [self setText:[self getText]];
+        // [self setText:[self text]];
if ([input LA:1] == ANTLRCharStreamEOF) {
ANTLRCommonToken *eof = [ANTLRCommonToken newToken:input
Type:ANTLRTokenTypeEOF
Channel:ANTLRCommonToken.DEFAULT_CHANNEL
-                                                         Start:[input getIndex]
-                                                          Stop:[input getIndex]];
-            [eof setLine:[self getLine]];
-            [eof setCharPositionInLine:[self getCharPositionInLine]];
+                                                         Start:input.index
+                                                          Stop:input.index];
+            [eof setLine:input.line];
+            [eof setCharPositionInLine:input.charPositionInLine];
return eof;
}
@try {
@@ -201,10 +201,10 @@
Type:state.type
Channel:state.channel
Start:state.tokenStartCharIndex
-                                                  Stop:[input getIndex]-1];
+                                                  Stop:input.index-1];
[aToken setLine:state.tokenStartLine];
-    aToken.text = [self getText];
-	[aToken setCharPositionInLine:[state getCharPositionInLine]];
+    aToken.text = [self text];
+	[aToken setCharPositionInLine:state.tokenStartCharPositionInLine];
[aToken retain];
[self emit:aToken];
// [aToken release];
@@ -214,15 +214,18 @@
#pragma mark Matching
- (void) matchString:(NSString *)aString
{
+    unichar c;
unsigned int i = 0;
unsigned int stringLength = [aString length];
while ( i < stringLength ) {
-		if ((unichar)[input LA:1] != [aString characterAtIndex:i]) {
+		c = [input LA:1];
+        if ( c != [aString characterAtIndex:i] ) {
if ([state getBacktracking] > 0) {
state.failed = YES;
return;
}
ANTLRMismatchedTokenException *mte = [ANTLRMismatchedTokenException newExceptionChar:[aString characterAtIndex:i] Stream:input];
+            mte.c = c;
[self recover:mte];
@throw mte;
}
@@ -241,12 +244,15 @@
{
// TODO: -LA: is returning an int because it sometimes is used in the generated parser to compare lookahead with a tokentype.
//		 try to change all those occurrences to -LT: if possible (i.e. if ANTLR can be made to generate LA only for lexer code)
-	if ((unichar)[input LA:1] != aChar) {
+    unichar charLA;
+	charLA = [input LA:1];
+	if ( charLA != aChar) {
if ([state getBacktracking] > 0) {
state.failed = YES;
return;
}
ANTLRMismatchedTokenException  *mte = [ANTLRMismatchedTokenException newExceptionChar:aChar Stream:input];
+        mte.c = charLA;
[self recover:mte];
@throw mte;
}
@@ -265,6 +271,7 @@
ANTLRMismatchedRangeException  *mre = [ANTLRMismatchedRangeException
newException:NSMakeRange((NSUInteger)fromChar,(NSUInteger)toChar)
stream:input];
+        mre.c = charLA;
[self recover:mre];
@throw mre;
}
@@ -275,27 +282,27 @@
// info
#pragma mark Informational

-- (NSUInteger) getLine
+- (NSUInteger) line
{
-	return [input getLine];
+	return input.line;
}

-- (NSUInteger) getCharPositionInLine
+- (NSUInteger) charPositionInLine
{
-	return [input getCharPositionInLine];
+	return input.charPositionInLine;
}

-- (NSInteger) getIndex
+- (NSInteger) index
{
-	return [input getIndex];
+    return 0;
}

-- (NSString *) getText
+- (NSString *) text
{
if (state.text != nil) {
return state.text;
}
-	return [input substringWithRange:NSMakeRange(state.tokenStartCharIndex, [input getIndex]-state.tokenStartCharIndex)];
+	return [input substringWithRange:NSMakeRange(state.tokenStartCharIndex, input.index-state.tokenStartCharIndex)];
}

- (void) setText:(NSString *) theText
@@ -320,51 +327,50 @@
[self displayRecognitionError:[self getTokenNames] Exception:e];
}

-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(NSMutableArray *)tokenNames
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)tokenNames
{
-    NSString *msg = [NSString stringWithFormat:@"Gotta fix getErrorMessage in ANTLRLexer.m--%@\n",
+/*    NSString *msg = [NSString stringWithFormat:@"Gotta fix getErrorMessage in ANTLRLexer.m--%@\n",
e.name];
-#ifdef DONTUSEYET
+ */
NSString *msg = nil;
if ( [e isKindOfClass:[ANTLRMismatchedTokenException class]] ) {
ANTLRMismatchedTokenException *mte = (ANTLRMismatchedTokenException *)e;
-        msg = [NSString stringWithFormat:@"mismatched character %@ expecting %@\n",
-               [self getCharErrorDisplay:e.c], [self getCharErrorDisplay:mte.expecting]];
+        msg = [NSString stringWithFormat:@"mismatched character \"%@\" expecting \"%@\"",
+               [self getCharErrorDisplay:mte.c], [self getCharErrorDisplay:mte.expecting]];
}
else if ( [e isKindOfClass:[ANTLRNoViableAltException class]] ) {
ANTLRNoViableAltException *nvae = (ANTLRNoViableAltException *)e;
// for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
// and "(decision="+nvae.decisionNumber+") and
// "state "+nvae.stateNumber
-        msg = [NSString stringWithFormat:@"no viable alternative at character %c\n",
-               [self getCharErrorDisplay:(e.c)]];
+        msg = [NSString stringWithFormat:@"no viable alternative at character \"%@\"",
+               [self getCharErrorDisplay:(nvae.c)]];
}
else if ( [e isKindOfClass:[ANTLREarlyExitException class]] ) {
-        // ANTLREarlyExitException *eee = (ANTLREarlyExitException *)e;
+        ANTLREarlyExitException *eee = (ANTLREarlyExitException *)e;
// for development, can add "(decision="+eee.decisionNumber+")"
-        msg = [NSString stringWithFormat:@"required (...)+ loop did not match anything at character %c",
-               [self getCharErrorDisplay:(e.c)]];
+        msg = [NSString stringWithFormat:@"required (...)+ loop did not match anything at character \"%@\"",
+               [self getCharErrorDisplay:(eee.c)]];
}
else if ( [e isKindOfClass:[ANTLRMismatchedNotSetException class]] ) {
ANTLRMismatchedNotSetException *mse = (ANTLRMismatchedNotSetException *)e;
-        msg = [NSString stringWithFormat:@"mismatched character %c  expecting set %@",
-               [self getCharErrorDisplay:(e.c)], mse.expecting];
+        msg = [NSString stringWithFormat:@"mismatched character \"%@\"  expecting set \"%@\"",
+               [self getCharErrorDisplay:(mse.c)], mse.expecting];
}
else if ( [e isKindOfClass:[ANTLRMismatchedSetException class]] ) {
ANTLRMismatchedSetException *mse = (ANTLRMismatchedSetException *)e;
-        msg = [NSString stringWithFormat:@"mismatched character %c expecting set %@",
-               [self getCharErrorDisplay:(e.c)], mse.expecting];
+        msg = [NSString stringWithFormat:@"mismatched character \"%@\" expecting set \"%@\"",
+               [self getCharErrorDisplay:(mse.c)], mse.expecting];
}
else if ( [e isKindOfClass:[ANTLRMismatchedRangeException class]] ) {
ANTLRMismatchedRangeException *mre = (ANTLRMismatchedRangeException *)e;
-        msg = [NSString stringWithFormat:@"mismatched character %c %@..%@\n",
-               [self getCharErrorDisplay:(e.c)], [self getCharErrorDisplay:(mre.a)],
-               [self getCharErrorDisplay:(mre.b)]];
+        msg = [NSString stringWithFormat:@"mismatched character \"%@\" \"%@..%@\"",
+               [self getCharErrorDisplay:(mre.c)], [self getCharErrorDisplay:(mre.range.location)],
+               [self getCharErrorDisplay:(mre.range.location+mre.range.length-1)]];
}
else {
msg = [super getErrorMessage:e TokenNames:[self getTokenNames]];
}
-#endif
return msg;
}

@@ -385,7 +391,7 @@
s = @"\\r";
break;
default:
-            s = [NSString stringWithFormat:@"%c\n", (char)c];
+            s = [NSString stringWithFormat:@"%c", (char)c];
break;
}
return s;
@@ -405,13 +411,13 @@

- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex
{
-    NSString *inputSymbol = [NSString stringWithFormat:@"%c line=%d:%d\n", [input LT:1], [self getLine], [self getCharPositionInLine]];
+    NSString *inputSymbol = [NSString stringWithFormat:@"%c line=%d:%d\n", [input LT:1], input.line, input.charPositionInLine];
[super traceIn:ruleName Index:ruleIndex Object:inputSymbol];
}

- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex
{
-    NSString *inputSymbol = [NSString stringWithFormat:@"%c line=%d:%d\n", [input LT:1], [self getLine], [self getCharPositionInLine]];
+    NSString *inputSymbol = [NSString stringWithFormat:@"%c line=%d:%d\n", [input LT:1], input.line, input.charPositionInLine];
[super traceOut:ruleName Index:ruleIndex Object:inputSymbol];
}

diff --git a/runtime/ObjC/Framework/ANTLRLexerState.h b/runtime/ObjC/Framework/ANTLRLexerState.h
index e18de12..e91ffbb 100644
--- a/runtime/ObjC/Framework/ANTLRLexerState.h
+++ b/runtime/ObjC/Framework/ANTLRLexerState.h
@@ -51,7 +51,7 @@
- (int) getTokenStartCharIndex;
- (void) setTokenStartCharIndex:(int) theTokenStartCharIndex;

-- (NSString *) getText;
+- (NSString *) text;
- (void) setText:(NSString *) theText;

@end
diff --git a/runtime/ObjC/Framework/ANTLRLexerState.m b/runtime/ObjC/Framework/ANTLRLexerState.m
index 33ed2cb..8ed1f68 100644
--- a/runtime/ObjC/Framework/ANTLRLexerState.m
+++ b/runtime/ObjC/Framework/ANTLRLexerState.m
@@ -64,7 +64,7 @@
- (void) setToken:(id<ANTLRToken>) theToken
{
if (theToken != token) {
-		[token release];
+		if ( token ) [token release];
token = [theToken retain];
}
}
@@ -120,7 +120,7 @@
tokenStartCharIndex = theTokenStartCharIndex;
}

-- (NSString *) getText
+- (NSString *) text
{
return text;
}
@@ -128,7 +128,7 @@
- (void) setText:(NSString *) theText
{
if (text != theText) {
-		[text release];
+		if ( text ) [text release];
text = [theText retain];
}
}
diff --git a/runtime/ObjC/Framework/ANTLRLookaheadStream.h b/runtime/ObjC/Framework/ANTLRLookaheadStream.h
index da7430d..8b625cb 100644
--- a/runtime/ObjC/Framework/ANTLRLookaheadStream.h
+++ b/runtime/ObjC/Framework/ANTLRLookaheadStream.h
@@ -36,7 +36,7 @@

@interface ANTLRLookaheadStream : ANTLRFastQueue
{
-    NSInteger currentElementIndex;
+    NSInteger index;
NSInteger eofElementIndex;
NSInteger lastMarker;
NSInteger markDepth;
@@ -45,7 +45,7 @@
}

@property (readwrite, retain, getter=getEof, setter=setEof:) id eof;
-@property (assign, getter=getIndex, setter=setIndex:) NSInteger currentElementIndex;
+@property (assign) NSInteger index;
@property (assign, getter=getEofElementIndex, setter=setEofElementIndex:) NSInteger eofElementIndex;
@property (assign, getter=getLastMarker, setter=setLastMarker:) NSInteger lastMarker;
@property (assign, getter=getMarkDepth, setter=setMarkDepth:) NSInteger markDepth;
@@ -60,8 +60,6 @@
- (id) LT:(NSInteger) i;
- (id) LB:(NSInteger) i;
- (id) getCurrentSymbol;
-- (NSInteger) getIndex;
-- (void) setIndex:(NSInteger)i;
- (NSInteger) mark;
- (void) release:(NSInteger) marker;
- (void) rewind:(NSInteger) marker;
diff --git a/runtime/ObjC/Framework/ANTLRLookaheadStream.m b/runtime/ObjC/Framework/ANTLRLookaheadStream.m
index 2f7dd5c..48c095f 100644
--- a/runtime/ObjC/Framework/ANTLRLookaheadStream.m
+++ b/runtime/ObjC/Framework/ANTLRLookaheadStream.m
@@ -38,6 +38,7 @@
@implementation ANTLRLookaheadStream

@synthesize eof;
+@synthesize index;
@synthesize eofElementIndex;
@synthesize lastMarker;
@synthesize markDepth;
@@ -49,7 +50,7 @@
eof = [ANTLRCommonToken eofToken];
eofElementIndex = UNITIALIZED_EOF_ELEMENT_INDEX;
markDepth = 0;
-        currentElementIndex = 0;
+        index = 0;
}
return self;
}
@@ -65,7 +66,7 @@
- (void) reset
{
[super reset];
-    currentElementIndex = 0;
+    index = 0;
p = 0;
prevElement = nil;
eofElementIndex = UNITIALIZED_EOF_ELEMENT_INDEX;
@@ -93,7 +94,7 @@
{
[self sync:1];
prevElement = [self remove];
-    currentElementIndex++;
+    index++;
}

-(void) sync:(NSInteger) need
@@ -151,16 +152,6 @@
return [self LT:1];
}

--(NSInteger) getIndex
-{
-	return currentElementIndex;
-}
-
-- (void) setIndex:(NSInteger)i
-{
-    currentElementIndex = i;
-}
-
-(NSInteger) mark
{
markDepth++;
diff --git a/runtime/ObjC/Framework/ANTLRMap.m b/runtime/ObjC/Framework/ANTLRMap.m
index e3f65c1..c8e4727 100644
--- a/runtime/ObjC/Framework/ANTLRMap.m
+++ b/runtime/ObjC/Framework/ANTLRMap.m
@@ -293,7 +293,7 @@

aTType = ttype % HASHSIZE;
for( np = self->ptrBuffer[ttype]; np != nil; np = [np getfNext] ) {
-        if ( [np.index integerValue] == ttype ) {
+        if ( [(NSNumber *)np.node integerValue] == ttype ) {
return( np );        /*   found it       */
}
}
@@ -308,7 +308,7 @@
idx = [(id<ANTLRBaseTree>)aNode getType];
idx %= HASHSIZE;
np = ptrBuffer[idx];
-    return( [(NSNumber *)np.index integerValue] );
+    return( [(NSNumber *)np.node integerValue] );
}

- (ANTLRMapElement *)getTType:(NSString *)name
diff --git a/runtime/ObjC/Framework/ANTLRMapElement.m b/runtime/ObjC/Framework/ANTLRMapElement.m
index 879e150..a6bd10c 100644
--- a/runtime/ObjC/Framework/ANTLRMapElement.m
+++ b/runtime/ObjC/Framework/ANTLRMapElement.m
@@ -151,8 +151,7 @@
- (void)setName:(NSString *)aName
{
if ( aName != name ) {
-        if (name != nil)
-            [name release];
+        if ( name ) [name release];
[aName retain];
}
name = aName;
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.h b/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.h
index 71a4f23..95d191d 100644
--- a/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.h
+++ b/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.h
@@ -35,16 +35,16 @@

@interface ANTLRMismatchedNotSetException : ANTLRRecognitionException
{
-    ANTLRBitSet *expecting;
+    NSString *expecting;
}
-@property (retain, getter=getExpecting, setter=setExpecting:) ANTLRBitSet *expecting;
+@property (retain, getter=getExpecting, setter=setExpecting:) NSString *expecting;

- (ANTLRMismatchedNotSetException *)newException;
- (ANTLRMismatchedNotSetException *)newException:(id<ANTLRIntStream>)anInput
-                                                               Follow:(ANTLRBitSet *)expecting;
+                                                               Follow:(NSString *)expecting;

- (id) init;
-- (id) initWithStream:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *)expecting;
+- (id) initWithStream:(id<ANTLRIntStream>)anInput Follow:(NSString *)expecting;

- (NSString *)toString;

diff --git a/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.m b/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.m
index 3eaaeab..e43e1b1 100644
--- a/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.m
+++ b/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.m
@@ -41,9 +41,9 @@
}

- (ANTLRMismatchedNotSetException *)newException:(id<ANTLRIntStream>)anInput
-                                                               Follow:(ANTLRBitSet *)expected
+                                                               Follow:(NSString *)expected
{
-    return [[ANTLRMismatchedNotSetException alloc] initWithStream:anInput Follow:(ANTLRBitSet *)expected];
+    return [[ANTLRMismatchedNotSetException alloc] initWithStream:anInput Follow:(NSString *)expected];
}

- (id) init
@@ -53,7 +53,7 @@
return(self);
}

-- (id) initWithStream:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *)expected
+- (id) initWithStream:(id<ANTLRIntStream>)anInput Follow:(NSString *)expected
{
if ((self = [super initWithStream:anInput]) != nil ) {
expecting = expected;
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedRangeException.h b/runtime/ObjC/Framework/ANTLRMismatchedRangeException.h
index b5eae7b..678af61 100644
--- a/runtime/ObjC/Framework/ANTLRMismatchedRangeException.h
+++ b/runtime/ObjC/Framework/ANTLRMismatchedRangeException.h
@@ -34,6 +34,8 @@
NSRange range;
}

+@property (assign) NSRange range;
+
+ (id) newException:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput;
- (id) initWithRange:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput;

diff --git a/runtime/ObjC/Framework/ANTLRMismatchedRangeException.m b/runtime/ObjC/Framework/ANTLRMismatchedRangeException.m
index aecd96b..0647254 100644
--- a/runtime/ObjC/Framework/ANTLRMismatchedRangeException.m
+++ b/runtime/ObjC/Framework/ANTLRMismatchedRangeException.m
@@ -30,6 +30,8 @@

@implementation ANTLRMismatchedRangeException

+@synthesize range;
+
+ (id) newException:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput
{
return [[ANTLRMismatchedRangeException alloc] initWithRange:aRange stream:theInput];
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedSetException.h b/runtime/ObjC/Framework/ANTLRMismatchedSetException.h
index 2f00697..0610973 100644
--- a/runtime/ObjC/Framework/ANTLRMismatchedSetException.h
+++ b/runtime/ObjC/Framework/ANTLRMismatchedSetException.h
@@ -29,16 +29,16 @@
#import "ANTLRRecognitionException.h"

@interface ANTLRMismatchedSetException : ANTLRRecognitionException {
-	NSSet *expecting;
+	NSString *expecting;
}

-@property (retain, getter=getExpecting, setter=setExpecting:) NSSet *expecting;
+@property (retain, getter=getExpecting, setter=setExpecting:) NSString *expecting;

-+ (id) newException:(NSSet *) theExpectedSet stream:(id<ANTLRIntStream>) theStream;
-- (id) initWithSet:(NSSet *) theExpectedSet stream:(id<ANTLRIntStream>) theStream;
++ (id) newException:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream;
+- (id) initWithSet:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream;

-- (NSSet *) getExpecting;
-- (void) setExpecting: (NSSet *) anExpectedSet;
+- (NSString *) getExpecting;
+- (void) setExpecting: (NSString *) anExpectedSet;


@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedSetException.m b/runtime/ObjC/Framework/ANTLRMismatchedSetException.m
index b31d545..b5248d2 100644
--- a/runtime/ObjC/Framework/ANTLRMismatchedSetException.m
+++ b/runtime/ObjC/Framework/ANTLRMismatchedSetException.m
@@ -31,12 +31,12 @@

@synthesize expecting;

-+ (id) newException:(NSSet *) theExpectedSet stream:(id<ANTLRIntStream>) theStream
++ (id) newException:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream
{
return [[ANTLRMismatchedSetException alloc] initWithSet:theExpectedSet stream:theStream];
}

-- (id) initWithSet:(NSSet *) theExpectedSet stream:(id<ANTLRIntStream>) theStream
+- (id) initWithSet:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream
{
if ((self = [super initWithStream:theStream]) != nil) {
[self setExpecting:theExpectedSet];
@@ -61,15 +61,15 @@
//----------------------------------------------------------
//  expectedSet
//----------------------------------------------------------
-- (NSSet *) getExpecting
+- (NSString *) getExpecting
{
return expecting;
}

-- (void) setExpecting: (NSSet *) anExpectedSet
+- (void) setExpecting: (NSString *) anExpectedSet
{
-    if (expecting != anExpectedSet) {
-        [expecting release];
+    if ( expecting != anExpectedSet ) {
+        if ( expecting ) [expecting release];
[anExpectedSet retain];
expecting = anExpectedSet;
}
diff --git a/runtime/ObjC/Framework/ANTLRNodeMapElement.m b/runtime/ObjC/Framework/ANTLRNodeMapElement.m
index 8c3618a..06f35cc 100644
--- a/runtime/ObjC/Framework/ANTLRNodeMapElement.m
+++ b/runtime/ObjC/Framework/ANTLRNodeMapElement.m
@@ -63,9 +63,10 @@ static NSInteger _aUniqueID;

- (id) initWithAnIndex:(id)anIndex Node:(id)aNode
{
-    if ((self = [super initWithAnIndex:anIndex]) != nil ) {
+    self = [super initWithAnIndex:anIndex];
+    if ( self ) {
if ( aNode != node ) {
-            if (node  != nil) [node release];
+            if ( node ) [node release];
[aNode retain];
}
node = aNode;
@@ -90,7 +91,7 @@ static NSInteger _aUniqueID;
- (void)setNode:(id<ANTLRBaseTree>)aNode
{
if ( aNode != node ) {
-        if (node  != nil) [node release];
+        if ( node ) [node release];
[aNode retain];
}
node = aNode;
diff --git a/runtime/ObjC/Framework/ANTLRParseTree.h b/runtime/ObjC/Framework/ANTLRParseTree.h
index 38ad35d..7be2738 100644
--- a/runtime/ObjC/Framework/ANTLRParseTree.h
+++ b/runtime/ObjC/Framework/ANTLRParseTree.h
@@ -32,10 +32,11 @@
#import <Cocoa/Cocoa.h>
#import "ANTLRBaseTree.h"
#import "ANTLRCommonToken.h"
+#import "AMutableArray.h"

@interface ANTLRParseTree : ANTLRBaseTree <ANTLRBaseTree> {
id<ANTLRToken> payload;
-	NSMutableArray *hiddenTokens;
+	AMutableArray *hiddenTokens;
}
/** A record of the rules used to match a token sequence.  The tokens
*  end up as the leaves of this tree and rule nodes are the interior nodes.
@@ -47,7 +48,7 @@

- (id<ANTLRBaseTree>)dupNode;
- (NSInteger)getType;
-- (NSString *)getText;
+- (NSString *)text;
- (NSInteger)getTokenStartIndex;
- (void)setTokenStartIndex:(NSInteger)index;
- (NSInteger)getTokenStopIndex;
@@ -58,5 +59,5 @@
- (void)_toStringLeaves:(NSMutableString *)buf;

@property (retain) id<ANTLRToken> payload;
-@property (retain) NSMutableArray *hiddenTokens;
+@property (retain) AMutableArray *hiddenTokens;
@end
diff --git a/runtime/ObjC/Framework/ANTLRParseTree.m b/runtime/ObjC/Framework/ANTLRParseTree.m
index f5e1d0c..14ba209 100644
--- a/runtime/ObjC/Framework/ANTLRParseTree.m
+++ b/runtime/ObjC/Framework/ANTLRParseTree.m
@@ -60,7 +60,7 @@
return 0;
}

-- (NSString *)getText
+- (NSString *)text
{
return [self toString];
}
@@ -90,7 +90,7 @@
if ( [t getType] == ANTLRTokenTypeEOF ) {
return @"<EOF>";
}
-        return [t getText];
+        return [t text];
}
return [payload toString];
}
@@ -104,7 +104,7 @@
if ( hiddenTokens!=nil ) {
for (NSUInteger i = 0; i < [hiddenTokens count]; i++) {
id<ANTLRToken>  hidden = (id<ANTLRToken> ) [hiddenTokens objectAtIndex:i];
-            [buf appendString:[hidden getText]];
+            [buf appendString:[hidden text]];
}
}
NSString *nodeText = [self toString];
diff --git a/runtime/ObjC/Framework/ANTLRParser.m b/runtime/ObjC/Framework/ANTLRParser.m
index 2bcb7c7..5cb4601 100644
--- a/runtime/ObjC/Framework/ANTLRParser.m
+++ b/runtime/ObjC/Framework/ANTLRParser.m
@@ -81,7 +81,7 @@
{
if (input != anInput) {
[anInput retain];
-        [input release];
+        if ( input ) [input release];
input = anInput;
}
}
@@ -107,8 +107,8 @@
if ( [current getType] == ANTLRTokenTypeEOF ) {
current = [anInput LT:-1];
}
-    t.line = [current getLine];
-    t.charPositionInLine = [current getCharPositionInLine];
+    t.line = current.line;
+    t.charPositionInLine = current.charPositionInLine;
t.channel = ANTLRTokenChannelDefault;
return t;
}
diff --git a/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.h b/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.h
index aef3dd0..d788c21 100644
--- a/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.h
+++ b/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.h
@@ -29,10 +29,10 @@
#import "ANTLRRuleReturnScope.h"

@interface ANTLRParserRuleReturnScope : ANTLRRuleReturnScope {
-	id<ANTLRToken> startToken;
+	id<ANTLRToken> start;
id<ANTLRToken> stopToken;
}
-@property (retain, getter=getStart, setter=setStart:) id<ANTLRToken> startToken;
+@property (retain, getter=getStart, setter=setStart:) id<ANTLRToken> start;
@property (retain, getter=getStop, setter=setStop:)   id<ANTLRToken> stopToken;

- (id<ANTLRToken>) getStart;
diff --git a/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.m b/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.m
index 39855b2..2bc2392 100644
--- a/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.m
+++ b/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.m
@@ -29,7 +29,7 @@

@implementation ANTLRParserRuleReturnScope

-@synthesize startToken;
+@synthesize start;
@synthesize stopToken;

- (void) dealloc
@@ -41,15 +41,15 @@

- (id<ANTLRToken>) getStart
{
-    return startToken;
+    return start;
}

- (void) setStart: (id<ANTLRToken>) aStart
{
-    if (startToken != aStart) {
+    if (start != aStart) {
[aStart retain];
-        [startToken release];
-        startToken = aStart;
+        if ( start ) [start release];
+        start = aStart;
}
}

@@ -62,7 +62,7 @@
{
if (stopToken != aStop) {
[aStop retain];
-        [stopToken release];
+        if ( stopToken ) [stopToken release];
stopToken = aStop;
}
}
@@ -72,7 +72,7 @@
- (id) copyWithZone:(NSZone *)theZone
{
ANTLRParserRuleReturnScope *copy = [super copyWithZone:theZone];
-    copy.startToken = startToken;
+    copy.start = start;
copy.stopToken = stopToken;
return copy;
}
diff --git a/runtime/ObjC/Framework/ANTLRPtrBuffer.h b/runtime/ObjC/Framework/ANTLRPtrBuffer.h
index 40903b7..8d2d866 100644
--- a/runtime/ObjC/Framework/ANTLRPtrBuffer.h
+++ b/runtime/ObjC/Framework/ANTLRPtrBuffer.h
@@ -37,7 +37,6 @@
#define BUFFSIZE         101

@interface ANTLRPtrBuffer : ANTLRLinkBase {
-	//ANTLRPtrBuffer *fNext;
NSUInteger BuffSize;
NSUInteger count;
NSUInteger ptr;
diff --git a/runtime/ObjC/Framework/ANTLRPtrBuffer.m b/runtime/ObjC/Framework/ANTLRPtrBuffer.m
index f803263..d86654d 100644
--- a/runtime/ObjC/Framework/ANTLRPtrBuffer.m
+++ b/runtime/ObjC/Framework/ANTLRPtrBuffer.m
@@ -60,8 +60,8 @@
{
NSUInteger idx;

-	self = [super init];
-	if ( self != nil ) {
+    self = [super init];
+    if ( self != nil ) {
BuffSize  = BUFFSIZE;
ptr = 0;
buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
@@ -69,7 +69,8 @@
for( idx = 0; idx < BuffSize; idx++ ) {
ptrBuffer[idx] = nil;
}
-	}
+        count = 0;
+    }
return( self );
}

@@ -77,8 +78,8 @@
{
NSUInteger idx;

-	self = [super init];
-	if ( self != nil ) {
+    self = [super init];
+    if ( self != nil ) {
BuffSize  = cnt;
ptr = 0;
buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
@@ -86,7 +87,8 @@
for( idx = 0; idx < BuffSize; idx++ ) {
ptrBuffer[idx] = nil;
}
-	}
+        count = 0;
+    }
return( self );
}

@@ -94,7 +96,7 @@
{
ANTLRLinkBase *tmp, *rtmp;
NSInteger idx;
-
+
if ( self.fNext != nil ) {
for( idx = 0; idx < BuffSize; idx++ ) {
tmp = ptrBuffer[idx];
@@ -109,7 +111,7 @@
}
}
[buffer release];
-	[super dealloc];
+    [super dealloc];
}

- (id) copyWithZone:(NSZone *)aZone
@@ -141,11 +143,12 @@
}
ptrBuffer[idx] = nil;
}
+    count = 0;
}

- (NSMutableData *)getBuffer
{
-	return( buffer );
+    return( buffer );
}

- (void)setBuffer:(NSMutableData *)np
@@ -155,7 +158,7 @@

- (NSUInteger)getCount
{
-	return( count );
+    return( count );
}

- (void)setCount:(NSUInteger)aCount
@@ -165,7 +168,7 @@

- (id *)getPtrBuffer
{
-	return( ptrBuffer );
+    return( ptrBuffer );
}

- (void)setPtrBuffer:(id *)np
@@ -175,7 +178,7 @@

- (NSUInteger)getPtr
{
-	return( ptr );
+    return( ptr );
}

- (void)setPtr:(NSUInteger)aPtr
@@ -185,9 +188,9 @@

- (void) addObject:(id) v
{
-	[self ensureCapacity:ptr];
-    [v retain];
-	ptrBuffer[ptr++] = v;
+    [self ensureCapacity:ptr];
+    if ( v ) [v retain];
+    ptrBuffer[ptr++] = v;
count++;
}

@@ -196,34 +199,35 @@
if ( ptr >= BuffSize - 1 ) {
[self ensureCapacity:ptr];
}
-    [v retain];
+    if ( v ) [v retain];
ptrBuffer[ptr++] = v;
count++;
}

- (id) pop
{
-	id v = nil;
+    id v = nil;
if ( ptr > 0 ) {
v = ptrBuffer[--ptr];
ptrBuffer[ptr] = nil;
}
count--;
-    [v release];
-	return v;
+    if ( v ) [v release];
+    return v;
}

- (id) peek
{
-	id v = nil;
+    id v = nil;
if ( ptr > 0 ) {
v = ptrBuffer[ptr-1];
}
-	return v;
+    return v;
}

- (NSUInteger)count
{
+#ifdef DONTUSENOMO
int cnt = 0;

for (NSInteger i = 0; i < BuffSize; i++ ) {
@@ -231,8 +235,9 @@
cnt++;
}
}
-    if (cnt != count) count = cnt;
-    return cnt;
+    if ( cnt != count ) count = cnt;
+#endif
+    return count;
}

- (NSUInteger)length
@@ -257,10 +262,11 @@
[self ensureCapacity:idx];
}
if ( aRule != ptrBuffer[idx] ) {
-        if ( ptrBuffer[idx] != nil ) [ptrBuffer[idx] release];
-        [aRule retain];
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
+        if ( aRule ) [aRule retain];
}
ptrBuffer[idx] = aRule;
+    count++;
}

- (id)objectAtIndex:(NSUInteger)idx
@@ -277,10 +283,10 @@
cnt = [anArray count];
for( i = 0; i < cnt; i++) {
id tmp = [anArray objectAtIndex:i];
-        if (tmp != nil)
-            [tmp retain];
+        if ( tmp ) [tmp retain];
[self insertObject:tmp atIndex:i];
}
+    count += cnt;
return;
}

@@ -288,7 +294,7 @@
{
int i;
for ( i = 0; i < BuffSize; i++ ) {
-        if ( ptrBuffer[i] != nil ) [ptrBuffer[i] release];
+        if ( ptrBuffer[i] ) [ptrBuffer[i] release];
ptrBuffer[i] = nil;
}
count = 0;
@@ -299,7 +305,7 @@
{
int i;
if ( idx >= 0 && idx < count ) {
-        if ( ptrBuffer[idx] != nil ) [ptrBuffer[idx] release];
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
for ( i = idx; i < count-1; i++ ) {
ptrBuffer[i] = ptrBuffer[i+1];
}
@@ -310,16 +316,16 @@

- (void) ensureCapacity:(NSUInteger) anIndex
{
-	if ((anIndex * sizeof(id)) >= [buffer length])
-	{
-		NSInteger newSize = ([buffer length] / sizeof(id)) * 2;
-		if (anIndex > newSize) {
-			newSize = anIndex + 1;
-		}
+    if ((anIndex * sizeof(id)) >= [buffer length])
+    {
+        NSInteger newSize = ([buffer length] / sizeof(id)) * 2;
+        if (anIndex > newSize) {
+            newSize = anIndex + 1;
+        }
BuffSize = newSize;
-		[buffer setLength:(BuffSize * sizeof(id))];
+        [buffer setLength:(BuffSize * sizeof(id))];
ptrBuffer = [buffer mutableBytes];
-	}
+    }
}

- (NSString *) description
@@ -330,7 +336,7 @@
str = [NSMutableString stringWithCapacity:30];
[str appendString:@"["];
for (idx = 0; idx < cnt; idx++ ) {
-        [str appendString:[[self objectAtIndex:idx] toString]];
+        [str appendString:[[self objectAtIndex:idx] description]];
}
[str appendString:@"]"];
return str;
diff --git a/runtime/ObjC/Framework/ANTLRRecognitionException.h b/runtime/ObjC/Framework/ANTLRRecognitionException.h
index c46d215..9bd799d 100644
--- a/runtime/ObjC/Framework/ANTLRRecognitionException.h
+++ b/runtime/ObjC/Framework/ANTLRRecognitionException.h
@@ -37,15 +37,17 @@
id<ANTLRToken> token;
id<ANTLRBaseTree> node;
unichar c;
-	NSInteger line;
-	NSInteger charPositionInLine;
+	NSUInteger line;
+	NSUInteger charPositionInLine;
}

@property (retain, getter=getStream, setter=setStream:) id<ANTLRIntStream> input;
+@property (assign) NSInteger index;
@property (retain, getter=getToken, setter=setToken:) id<ANTLRToken>token;
@property (retain, getter=getNode, setter=setNode:) id<ANTLRBaseTree>node;
-@property (getter=getLine, setter=setLine:) NSInteger line;
-@property (getter=getCharPositionInLine, setter=setCharPositionInLine:) NSInteger charPositionInLine;
+@property (assign) unichar c;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;

+ (id) newException;
+ (id) newException:(id<ANTLRIntStream>) anInputStream;
@@ -68,9 +70,5 @@

- (NSString *)getMessage;

-- (NSInteger)getCharPositionInLine;
-- (void)setCharPositionInLine:(NSInteger)aPos;

-@property NSInteger index;
-@property unichar c;
@end
diff --git a/runtime/ObjC/Framework/ANTLRRecognitionException.m b/runtime/ObjC/Framework/ANTLRRecognitionException.m
index 09814f6..326313d 100644
--- a/runtime/ObjC/Framework/ANTLRRecognitionException.m
+++ b/runtime/ObjC/Framework/ANTLRRecognitionException.m
@@ -62,21 +62,21 @@
{
if ((self = [super initWithName:NSStringFromClass([self class]) reason:aReason userInfo:nil]) != nil) {
[self setStream:anInputStream];
-		index = [anInputStream getIndex];
+		index = input.index;

Class inputClass = [input class];
if ([inputClass conformsToProtocol:@protocol(ANTLRTokenStream)]) {
[self setToken:[(id<ANTLRTokenStream>)input LT:1]];
-			line = [token getLine];
-			charPositionInLine = [token getCharPositionInLine];
+			line = token.line;
+			charPositionInLine = token.charPositionInLine;
} else if ([inputClass conformsToProtocol:@protocol(ANTLRCharStream)]) {
c = (unichar)[input LA:1];
-			line = [(id<ANTLRCharStream>)input getLine];
-			charPositionInLine = [(id<ANTLRCharStream>)input getCharPositionInLine];
+			line = (id<ANTLRCharStream>)input.line;
+			charPositionInLine = (id<ANTLRCharStream>)input.charPositionInLine;
} else if ([inputClass conformsToProtocol:@protocol(ANTLRTreeNodeStream)]) {
[self setNode:[(id<ANTLRTreeNodeStream>)input LT:1]];
-			line = [node getLine];
-			charPositionInLine = [node getCharPositionInLine];
+			line = [node line];
+			charPositionInLine = [node charPositionInLine];
} else {
c = (unichar)[input LA:1];
}
@@ -148,7 +148,7 @@
{
if (input != aStream) {
[aStream retain];
-        [input release];
+        if ( input ) [input release];
input = aStream;
}
}
@@ -165,7 +165,7 @@
{
if (token != aToken) {
[aToken retain];
-        [token release];
+        if ( token ) [token release];
token = aToken;
}
}
@@ -182,7 +182,7 @@
{
if (node != aNode) {
[aNode retain];
-        [node release];
+        if ( node ) [node release];
node = aNode;
}
}
@@ -192,12 +192,12 @@
return @"Fix getMessage in ANTLRRecognitionException";
}

-- (NSInteger)getCharPositionInLine
+- (NSUInteger)charPositionInLine
{
return charPositionInLine;
}

-- (void)setCharPositionInLine:(NSInteger)aPos
+- (void)setCharPositionInLine:(NSUInteger)aPos
{
charPositionInLine = aPos;
}
diff --git a/runtime/ObjC/Framework/ANTLRRecognizerSharedState.h b/runtime/ObjC/Framework/ANTLRRecognizerSharedState.h
index fa03dc1..1d936b6 100755
--- a/runtime/ObjC/Framework/ANTLRRecognizerSharedState.h
+++ b/runtime/ObjC/Framework/ANTLRRecognizerSharedState.h
@@ -28,9 +28,10 @@
#import "ANTLRToken.h"
#import "ANTLRBitSet.h"
#import "ANTLRRuleStack.h"
+#import "AMutableArray.h"

@interface ANTLRRecognizerSharedState : NSObject {
-	NSMutableArray *following;          // a stack of FOLLOW bitsets used for context sensitive prediction and recovery
+	AMutableArray *following;          // a stack of FOLLOW bitsets used for context sensitive prediction and recovery
NSInteger _fsp;                     // Follow stack pointer
BOOL errorRecovery;                 // are we recovering?
NSInteger lastErrorIndex;
@@ -48,7 +49,7 @@
NSString   *text;
}

-@property (retain, getter=getFollowing, setter=setFollowing:) NSMutableArray *following;
+@property (retain, getter=getFollowing, setter=setFollowing:) AMutableArray *following;
@property (assign) NSInteger _fsp;
@property (assign) BOOL errorRecovery;
@property (assign) NSInteger lastErrorIndex;
@@ -60,9 +61,9 @@
@property (getter=getType,setter=setType:) NSUInteger type;
@property (getter=getChannel,setter=setChannel:) NSUInteger channel;
@property (getter=getTokenStartLine,setter=setTokenStartLine:) NSUInteger tokenStartLine;
-@property (getter=getCharPositionInLine,setter=setCharPositionInLine:) NSUInteger tokenStartCharPositionInLine;
+@property (getter=charPositionInLine,setter=setCharPositionInLine:) NSUInteger tokenStartCharPositionInLine;
@property (getter=getTokenStartCharIndex,setter=setTokenStartCharIndex:) NSInteger tokenStartCharIndex;
-@property (retain, getter=getText, setter=setText:) NSString *text;
+@property (retain, getter=text, setter=setText:) NSString *text;

+ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState;
+ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedStateWithRuleLen:(NSInteger)aLen;
@@ -84,18 +85,18 @@
- (NSUInteger) getTokenStartLine;
- (void) setTokenStartLine:(NSUInteger) theTokenStartLine;

-- (NSUInteger) getCharPositionInLine;
+- (NSUInteger) charPositionInLine;
- (void) setCharPositionInLine:(NSUInteger) theCharPosition;

- (NSInteger) getTokenStartCharIndex;
- (void) setTokenStartCharIndex:(NSInteger) theTokenStartCharIndex;

-- (NSString *) getText;
+- (NSString *) text;
- (void) setText:(NSString *) theText;


-- (NSMutableArray *) getFollowing;
-- (void)setFollowing:(NSMutableArray *)aFollow;
+- (AMutableArray *) getFollowing;
+- (void)setFollowing:(AMutableArray *)aFollow;
- (ANTLRRuleStack *) getRuleMemo;
- (void)setRuleMemo:(ANTLRRuleStack *)aRuleMemo;
- (BOOL) isErrorRecovery;
diff --git a/runtime/ObjC/Framework/ANTLRRecognizerSharedState.m b/runtime/ObjC/Framework/ANTLRRecognizerSharedState.m
index e663e6e..2332ad6 100755
--- a/runtime/ObjC/Framework/ANTLRRecognizerSharedState.m
+++ b/runtime/ObjC/Framework/ANTLRRecognizerSharedState.m
@@ -67,7 +67,7 @@
{
ANTLRHashRule *aHashRule;
if ((self = [super init]) != nil ) {
-        following = [NSMutableArray arrayWithCapacity:10];
+        following = [AMutableArray arrayWithCapacity:10];
_fsp = -1;
errorRecovery = NO;			// are we recovering?
lastErrorIndex = -1;
@@ -98,7 +98,7 @@
{
ANTLRHashRule *aHashRule;
if ((self = [super init]) != nil ) {
-        following = [NSMutableArray arrayWithCapacity:10];
+        following = [AMutableArray arrayWithCapacity:10];
_fsp = -1;
errorRecovery = NO;			// are we recovering?
lastErrorIndex = -1;
@@ -169,8 +169,8 @@

- (void) dealloc
{
-	[following release];
-	[ruleMemo release];
+	if ( following ) [following release];
+	if ( ruleMemo ) [ruleMemo release];
[super dealloc];
}

@@ -186,7 +186,7 @@
{
if (token != aToken) {
[aToken retain];
-        [token release];
+        if ( token ) [token release];
token = aToken;
}
}
@@ -211,7 +211,7 @@
tokenStartLine = theTokenStartLine;
}

-- (NSUInteger) getCharPositionInLine
+- (NSUInteger) charPositionInLine
{
return tokenStartCharPositionInLine;
}
@@ -237,12 +237,12 @@
NSLog(@"%@", e.name);
}

-- (NSMutableArray *) getFollowing
+- (AMutableArray *) getFollowing
{
return following;
}

-- (void)setFollowing:(NSMutableArray *)aFollow
+- (void)setFollowing:(AMutableArray *)aFollow
{
following = aFollow;
}
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.h b/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.h
index c3130ae..69efe70 100644
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.h
+++ b/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.h
@@ -33,7 +33,7 @@
BOOL dirty;        ///< indicates whether the stream should return copies of its elements, set to true after a call to -reset
BOOL isSingleElement;
id singleElement;
-    NSMutableArray *elements;
+    AMutableArray *elements;

NSString *elementDescription;
id<ANTLRTreeAdaptor> treeAdaptor;
@@ -43,7 +43,7 @@
@property (assign) BOOL dirty;
@property (assign) BOOL isSingleElement;
@property (assign) id singleElement;
-@property (assign) NSMutableArray *elements;
+@property (assign) AMutableArray *elements;
@property (assign) NSString *elementDescription;
@property (retain) id<ANTLRTreeAdaptor> treeAdaptor;

diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.m b/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.m
index 59da529..46c1307 100644
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.m
+++ b/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.m
@@ -103,17 +103,15 @@
dirty = NO;
singleElement = nil;
isSingleElement = NO;
-        elements = [[NSMutableArray alloc] initWithArray:theElements];
+        elements = [[AMutableArray arrayWithArray:theElements] retain];
}
return self;
}

- (void) dealloc
{
-    if (isSingleElement)
-        [singleElement release];
-    else
-        [elements release];
+    if ( singleElement && isSingleElement ) [singleElement release];
+    else if ( elements && !isSingleElement ) [elements release];
[self setDescription:nil];
[self setTreeAdaptor:nil];
[super dealloc];
@@ -133,9 +131,9 @@
- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor
{
if (treeAdaptor != aTreeAdaptor) {
-        [treeAdaptor release];
-        [treeAdaptor retain];
+        if ( treeAdaptor ) [treeAdaptor release];
treeAdaptor = aTreeAdaptor;
+        [treeAdaptor retain];
}
}

@@ -153,7 +151,7 @@
return;
}
isSingleElement = NO;
-    elements = [[NSMutableArray arrayWithCapacity:5] retain];
+    elements = [[AMutableArray arrayWithCapacity:5] retain];
[elements addObject:singleElement];
singleElement = nil;  // balance previous retain in initializer/addElement
[elements addObject:anElement];
@@ -173,7 +171,7 @@
return;
}
isSingleElement = NO;
-    elements = [[NSMutableArray arrayWithCapacity:5] retain];
+    elements = [[AMutableArray arrayWithCapacity:5] retain];
[elements addObject:singleElement];
singleElement = nil;  // balance previous retain in initializer/addElement
[elements addObject:anElement];
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.h b/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.h
index f644c55..620a0bd 100644
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.h
+++ b/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.h
@@ -41,7 +41,7 @@
/** Create a stream, but feed off an existing list */
+ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
description:(NSString *)elementDescription
-                             elements:(NSMutableArray *)elements;
+                             elements:(AMutableArray *)elements;

- (id) init;
- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
@@ -51,7 +51,7 @@
element:(id)element;
- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
description:(NSString *)aDescription
-                  elements:(NSMutableArray *)elements;
+                  elements:(AMutableArray *)elements;

/** Get next token from stream and make a node for it */
- (id) nextNode;
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.m b/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.m
index f31f961..5aea3f8 100644
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.m
+++ b/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.m
@@ -56,7 +56,7 @@
/** Create a stream, but feed off an existing list */
+ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
description:(NSString *)elementDescription
-                             elements:(NSMutableArray *)elements
+                             elements:(AMutableArray *)elements
{
return [[ANTLRRewriteRuleTokenStream alloc] initWithTreeAdaptor:adaptor
description:elementDescription
@@ -92,7 +92,7 @@

- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
description:(NSString *)aDescription
-                  elements:(NSMutableArray *)elementList
+                  elements:(AMutableArray *)elementList
{
if ((self = [super initWithTreeAdaptor:anAdaptor
description:aDescription
diff --git a/runtime/ObjC/Framework/ANTLRRuleMapElement.m b/runtime/ObjC/Framework/ANTLRRuleMapElement.m
index 906f2df..0e8c463 100644
--- a/runtime/ObjC/Framework/ANTLRRuleMapElement.m
+++ b/runtime/ObjC/Framework/ANTLRRuleMapElement.m
@@ -93,9 +93,8 @@

- (void)setRuleNum:(id)aRuleNum
{
-    if (aRuleNum != ruleNum) {
-        if (ruleNum != nil)
-            [ruleNum release];
+    if ( aRuleNum != ruleNum ) {
+        if ( ruleNum ) [ruleNum release];
[aRuleNum retain];
}
ruleNum = aRuleNum;
diff --git a/runtime/ObjC/Framework/ANTLRRuleMemo.m b/runtime/ObjC/Framework/ANTLRRuleMemo.m
index b53fdce..836d355 100644
--- a/runtime/ObjC/Framework/ANTLRRuleMemo.m
+++ b/runtime/ObjC/Framework/ANTLRRuleMemo.m
@@ -134,8 +134,8 @@

- (void)setStartIndex:(NSNumber *)aStartIndex
{
-    if (aStartIndex != startIndex) {
-        if (startIndex != nil) [startIndex release];
+    if ( aStartIndex != startIndex ) {
+        if ( startIndex ) [startIndex release];
[aStartIndex retain];
}
startIndex = aStartIndex;
@@ -148,8 +148,8 @@

- (void)setStopIndex:(NSNumber *)aStopIndex
{
-    if (aStopIndex != stopIndex) {
-        if (stopIndex != nil) [stopIndex release];
+    if ( aStopIndex != stopIndex ) {
+        if ( stopIndex ) [stopIndex release];
[aStopIndex retain];
}
stopIndex = aStopIndex;
diff --git a/runtime/ObjC/Framework/ANTLRRuleReturnScope.h b/runtime/ObjC/Framework/ANTLRRuleReturnScope.h
index 4750c16..b9313ed 100644
--- a/runtime/ObjC/Framework/ANTLRRuleReturnScope.h
+++ b/runtime/ObjC/Framework/ANTLRRuleReturnScope.h
@@ -43,7 +43,7 @@
- (id<ANTLRToken>) getStop;

/** Has a value potentially if output=AST; */
-- (id) getNode;
+- (id) getTree;

/** Has a value potentially if output=template; Don't use StringTemplate
*  type as it then causes a dependency with ST lib.
diff --git a/runtime/ObjC/Framework/ANTLRRuleReturnScope.m b/runtime/ObjC/Framework/ANTLRRuleReturnScope.m
index 59f60b7..70878a3 100644
--- a/runtime/ObjC/Framework/ANTLRRuleReturnScope.m
+++ b/runtime/ObjC/Framework/ANTLRRuleReturnScope.m
@@ -47,7 +47,7 @@
}

/** Has a value potentially if output=AST; */
-- (id) getNode
+- (id) getTree
{
return nil;
}
diff --git a/runtime/ObjC/Framework/ANTLRRuleStack.m b/runtime/ObjC/Framework/ANTLRRuleStack.m
index ac58f57..c59924a 100644
--- a/runtime/ObjC/Framework/ANTLRRuleStack.m
+++ b/runtime/ObjC/Framework/ANTLRRuleStack.m
@@ -111,7 +111,7 @@ extern NSInteger debug;
[self ensureCapacity:idx];
}
if ( aRule != ptrBuffer[idx] ) {
-        if (ptrBuffer[idx] != nil) [ptrBuffer[idx] release];
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
[aRule retain];
}
ptrBuffer[idx] = aRule;
diff --git a/runtime/ObjC/Framework/ANTLRRuntimeException.h b/runtime/ObjC/Framework/ANTLRRuntimeException.h
index b0bf69b..47834d2 100644
--- a/runtime/ObjC/Framework/ANTLRRuntimeException.h
+++ b/runtime/ObjC/Framework/ANTLRRuntimeException.h
@@ -98,3 +98,14 @@
- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;

@end
+
+@interface ANTLRUnsupportedOperationException : ANTLRRuntimeException {
+}
+
++ (id) newException:(NSString *)aReason;
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason;
+- (id) initWithName:(NSString *)aMsg reason:(NSString *)aCause userInfo:(NSDictionary *)userInfo;
+
+@end
+
diff --git a/runtime/ObjC/Framework/ANTLRRuntimeException.m b/runtime/ObjC/Framework/ANTLRRuntimeException.m
index b1f14e6..77373eb 100644
--- a/runtime/ObjC/Framework/ANTLRRuntimeException.m
+++ b/runtime/ObjC/Framework/ANTLRRuntimeException.m
@@ -249,3 +249,25 @@
}

@end
+
+@implementation ANTLRUnsupportedOperationException
+
++ (id) newException:(NSString *)aReason
+{
+    return [[ANTLRRuntimeException alloc] initWithName:@"Unsupported Operation Exception" reason:aReason userInfo:nil];
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason
+{
+    self=[super initWithName:aName reason:aReason userInfo:nil];
+    return self;
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)userInfo
+{
+    self=[super initWithName:aName reason:aReason userInfo:userInfo];
+    return self;
+}
+
+@end
+
diff --git a/runtime/ObjC/Framework/ANTLRStreamEnumerator.h b/runtime/ObjC/Framework/ANTLRStreamEnumerator.h
index b848cde..9462ccd 100644
--- a/runtime/ObjC/Framework/ANTLRStreamEnumerator.h
+++ b/runtime/ObjC/Framework/ANTLRStreamEnumerator.h
@@ -30,19 +30,19 @@
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#import <Cocoa/Cocoa.h>
-
+#import "AMutableArray.h"

@interface ANTLRStreamEnumerator : NSEnumerator
{
NSInteger i;
id eof;
-	NSMutableArray *nodes;
+	AMutableArray *nodes;
}

--(id) initWithNodes:(NSMutableArray *) n andEOF:(id) o;
+-(id) initWithNodes:(AMutableArray *) n andEOF:(id) o;
-(BOOL) hasNext;

@property NSInteger i;
@property (retain) id eof;
-@property (retain) NSMutableArray *nodes;
+@property (retain) AMutableArray *nodes;
@end
diff --git a/runtime/ObjC/Framework/ANTLRStreamEnumerator.m b/runtime/ObjC/Framework/ANTLRStreamEnumerator.m
index 4436de2..e1a426f 100644
--- a/runtime/ObjC/Framework/ANTLRStreamEnumerator.m
+++ b/runtime/ObjC/Framework/ANTLRStreamEnumerator.m
@@ -44,7 +44,7 @@
return self;
}

--(id) initWithNodes:(NSMutableArray *) n andEOF:(id) o
+-(id) initWithNodes:(AMutableArray *) n andEOF:(id) o
{
self = [self init];
if (self)
diff --git a/runtime/ObjC/Framework/ANTLRStringStream.h b/runtime/ObjC/Framework/ANTLRStringStream.h
index d2342ef..e004a15 100644
--- a/runtime/ObjC/Framework/ANTLRStringStream.h
+++ b/runtime/ObjC/Framework/ANTLRStringStream.h
@@ -33,9 +33,9 @@
@interface ANTLRStringStream : NSObject < ANTLRCharStream > {
NSString *data;
NSInteger n;
-	NSInteger p;
-	NSInteger line;
-	NSInteger charPositionInLine;
+	NSInteger index;
+	NSUInteger line;
+	NSUInteger charPositionInLine;
NSInteger markDepth;
ANTLRPtrBuffer *markers;
NSInteger lastMarker;
@@ -72,8 +72,6 @@
- (NSInteger) LA:(NSInteger) i;
- (NSInteger) LT:(NSInteger) i;

-// returns the position of the current input symbol
-- (NSInteger) getIndex;
// total length of the input data
- (NSInteger) size;

@@ -88,18 +86,6 @@
- (NSString *) substring:(NSInteger)startIndex To:(NSInteger)stopIndex;
- (NSString *) substringWithRange:(NSRange) theRange;

-// used for tracking the current position in the input stream
-- (NSInteger) getLine;
-- (void) setLine:(NSInteger) theLine;
-- (NSInteger) getCharPositionInLine;
-- (void) setCharPositionInLine:(NSInteger) thePos;
-
-- (NSInteger) getN;
-- (void) setN:(NSInteger)num;
-
-- (NSInteger) getP;
-- (void) setP:(NSInteger)num;
-
- (ANTLRPtrBuffer *)getMarkers;
- (void) setMarkers:(ANTLRPtrBuffer *)aMarkerList;

@@ -110,10 +96,10 @@
// accessors to the raw data of this stream

@property (retain) NSString *data;
-@property (assign) NSInteger p;
+@property (assign) NSInteger index;
@property (assign) NSInteger n;
-@property (assign) NSInteger line;
-@property (assign) NSInteger charPositionInLine;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;
@property (assign) NSInteger markDepth;
@property (retain) ANTLRPtrBuffer *markers;
@property (assign) NSInteger lastMarker;
diff --git a/runtime/ObjC/Framework/ANTLRStringStream.m b/runtime/ObjC/Framework/ANTLRStringStream.m
index 74092d9..191cfb8 100644
--- a/runtime/ObjC/Framework/ANTLRStringStream.m
+++ b/runtime/ObjC/Framework/ANTLRStringStream.m
@@ -33,7 +33,7 @@ extern NSInteger debug;

@synthesize data;
@synthesize n;
-@synthesize p;
+@synthesize index;
@synthesize line;
@synthesize charPositionInLine;
@synthesize markDepth;
@@ -63,7 +63,7 @@ extern NSInteger debug;
{
if ((self = [super init]) != nil) {
n = 0;
-        p = 0;
+        index = 0;
line = 1;
charPositionInLine = 0;
markDepth = 0;
@@ -81,7 +81,7 @@ extern NSInteger debug;
//[self setData:[NSString stringWithString:theString]];
data = [theString retain];
n = [data length];
-        p = 0;
+        index = 0;
line = 1;
charPositionInLine = 0;
markDepth = 0;
@@ -98,7 +98,7 @@ extern NSInteger debug;
//[self setData:theString];
data = [theString retain];
n = [data length];
-        p = 0;
+        index = 0;
line = 1;
charPositionInLine = 0;
markDepth = 0;
@@ -115,7 +115,7 @@ extern NSInteger debug;
if ((self = [super init]) != nil) {
data = [NSString stringWithCString:myData encoding:NSASCIIStringEncoding];
n = numBytes;
-        p = 0;
+        index = 0;
line = 1;
charPositionInLine = 0;
markDepth = 0;
@@ -129,13 +129,15 @@ extern NSInteger debug;

- (void) dealloc
{
-    if (markers != nil) {
+    if ( markers && [markers count] ) {
[markers removeAllObjects];
[markers release];
+        markers = nil;
+    }
+    if ( data ) {
+        [data release];
+        data = nil;
}
-    if (data != nil) [data release];
-	markers = nil;
-    data = nil;
[super dealloc];
}

@@ -148,7 +150,7 @@ extern NSInteger debug;
if ( data != nil )
copy.data = [self.data copyWithZone:aZone];
copy.n = n;
-    copy.p = p;
+    copy.index = index;
copy.line = line;
copy.charPositionInLine = charPositionInLine;
copy.markDepth = markDepth;
@@ -164,13 +166,14 @@ extern NSInteger debug;
// the streams content is not reset!
- (void) reset
{
-	p = 0;
+	index = 0;
line = 1;
charPositionInLine = 0;
markDepth = 0;
-	[markers removeAllObjects];
-    [markers addObject:[NSNull null]]; // ANTLR generates code that assumes markers to be 1-based,
-											// thus the initial null in the array!
+    if ( markers && [markers count] )
+        [markers removeAllObjects];
+    [markers addObject:[NSNull null]];  // ANTLR generates code that assumes markers to be 1-based,
+                                        // thus the initial null in the array!
}

// read one character off the stream, tracking line numbers and character positions
@@ -179,13 +182,13 @@ extern NSInteger debug;
// handling. Do not call super in that case.
- (void) consume
{
-	if ( p < n ) {
+	if ( index < n ) {
charPositionInLine++;
-		if ( [data characterAtIndex:p] == '\n' ) {
+		if ( [data characterAtIndex:index] == '\n' ) {
line++;
charPositionInLine=0;
}
-		p++;
+		index++;
}
}

@@ -197,14 +200,14 @@ extern NSInteger debug;
return 0; // undefined
if ( i < 0 ) {
i++;
-        if ( p+i-1 < 0 ) {
+        if ( index+i-1 < 0 ) {
return ANTLRCharStreamEOF;
}
}
-    if ( (p+i-1) >= n ) {
+    if ( (index+i-1) >= n ) {
return ANTLRCharStreamEOF;
}
-    c = [data characterAtIndex:p+i-1];
+    c = [data characterAtIndex:index+i-1];
return (NSInteger)c;
}

@@ -213,12 +216,6 @@ extern NSInteger debug;
return [self LA:i];
}

-// current input position
-- (NSInteger) getIndex
-{
-	return p;
-}
-
- (NSInteger) size
{
return n;
@@ -245,38 +242,38 @@ extern NSInteger debug;
if ( markDepth == 1 )
State = charState;
[markers insertObject:State atIndex:markDepth];
-        if (debug > 1) NSLog(@"mark save State %x at %d, p=%d, line=%d, charPositionInLine=%d\n", State, markDepth, State.p, State.line, State.charPositionInLine);
+        if (debug > 1) NSLog(@"mark save State %x at %d, index=%d, line=%d, charPositionInLine=%d\n", (NSUInteger)State, markDepth, State.index, State.line, State.charPositionInLine);
}
else {
-        if (debug > 1) NSLog(@"mark retrieve markers=%x markDepth=%d\n", markers, markDepth);
+        if (debug > 1) NSLog(@"mark retrieve markers=%x markDepth=%d\n", (NSUInteger)markers, markDepth);
State = [markers objectAtIndex:markDepth];
[State retain];
State = (ANTLRCharStreamState *)[markers objectAtIndex:markDepth];
-        if (debug > 1) NSLog(@"mark retrieve charState %x from %d, p=%d, line=%d, charPositionInLine=%d\n", State, markDepth, State.p, State.line, State.charPositionInLine);
+        if (debug > 1) NSLog(@"mark retrieve charState %x from %d, index=%d, line=%d, charPositionInLine=%d\n", (NSUInteger)State, markDepth, State.index, State.line, State.charPositionInLine);
}
-    State.p = p;
+    State.index = index;
State.line = line;
State.charPositionInLine = charPositionInLine;
lastMarker = markDepth;
-    if (debug > 1) NSLog(@"mark exit -- markers=%x, charState=%x, p=%d, line=%d, charPositionInLine=%d\n", markers, State, State.p, State.line, State.charPositionInLine);
+    if (debug > 1) NSLog(@"mark exit -- markers=%x, charState=%x, index=%d, line=%d, charPositionInLine=%d\n", (NSUInteger)markers, (NSUInteger)State, State.index, State.line, State.charPositionInLine);
return markDepth;
}

- (void) rewind:(NSInteger) marker
{
ANTLRCharStreamState *State;
-    if (debug > 1) NSLog(@"rewind entry -- markers=%x marker=%d\n", markers, marker);
+    if (debug > 1) NSLog(@"rewind entry -- markers=%x marker=%d\n", (NSUInteger)markers, marker);
if ( marker == 1 )
State = charState;
else
State = (ANTLRCharStreamState *)[markers objectAtIndex:marker];
-    if (debug > 1) NSLog(@"rewind entry -- marker=%d charState=%x, p=%d, line=%d, charPositionInLine=%d\n", marker, charState, charState.p, charState.line, charState.charPositionInLine);
+    if (debug > 1) NSLog(@"rewind entry -- marker=%d charState=%x, index=%d, line=%d, charPositionInLine=%d\n", marker, (NSUInteger)charState, charState.index, charState.line, charState.charPositionInLine);
// restore stream charState
-	[self seek:State.p];
+	[self seek:State.index];
line = State.line;
charPositionInLine = charState.charPositionInLine;
[self release:marker];
-    if (debug > 1) NSLog(@"rewind exit -- marker=%d charState=%x, p=%d, line=%d, charPositionInLine=%d\n", marker, charState, charState.p, charState.line, charState.charPositionInLine);
+    if (debug > 1) NSLog(@"rewind exit -- marker=%d charState=%x, index=%d, line=%d, charPositionInLine=%d\n", marker, (NSUInteger)charState, charState.index, charState.line, charState.charPositionInLine);
}

- (void) rewind
@@ -300,17 +297,17 @@ extern NSInteger debug;
// so we just take it from there.
- (void) seek:(NSInteger) anIndex
{
-    if (debug > 1) NSLog(@"seek entry -- index=%d p=%d\n", anIndex, p);
-	if ( anIndex <= p ) {
-		p = anIndex; // just jump; don't update stream charState (line, ...)
-        if (debug > 1) NSLog(@"seek exit return -- index=%d p=%d\n", anIndex, p);
+    if (debug > 1) NSLog(@"seek entry -- seekIndex=%d index=%d\n", anIndex, index);
+	if ( anIndex <= index ) {
+		index = anIndex; // just jump; don't update stream charState (line, ...)
+        if (debug > 1) NSLog(@"seek exit return -- index=%d index=%d\n", anIndex, index);
return;
}
-	// seek forward, consume until p hits anIndex
-	while ( p < anIndex ) {
+	// seek forward, consume until index hits anIndex
+	while ( index < anIndex ) {
[self consume];
}
-    if (debug > 1) NSLog(@"seek exit end -- index=%d p=%d\n", anIndex, p);
+    if (debug > 1) NSLog(@"seek exit end -- index=%d index=%d\n", anIndex, index);
}

// get a substring from our raw data.
@@ -327,46 +324,6 @@ extern NSInteger debug;
}


-- (NSInteger) getP
-{
-    return p;
-}
-
-- (void) setP:(NSInteger)num
-{
-    p = num;
-}
-
-- (NSInteger) getN
-{
-    return n;
-}
-
-- (void) setN:(NSInteger)num
-{
-    n = num;
-}
-
-- (NSInteger) getLine
-{
-	return line;
-}
-
-- (void) setLine:(NSInteger) theLine
-{
-	line = theLine;
-}
-
-- (NSInteger) getCharPositionInLine
-{
-	return charPositionInLine;
-}
-
-- (void) setCharPositionInLine:(NSInteger) thePos
-{
-	charPositionInLine = thePos;
-}
-
- (ANTLRPtrBuffer *)getMarkers
{
return markers;
diff --git a/runtime/ObjC/Framework/ANTLRStringStreamState.h b/runtime/ObjC/Framework/ANTLRStringStreamState.h
index 29d4765..eda483b 100644
--- a/runtime/ObjC/Framework/ANTLRStringStreamState.h
+++ b/runtime/ObjC/Framework/ANTLRStringStreamState.h
@@ -51,6 +51,8 @@
- (void) setCharPositionInLine: (NSUInteger) aCharPositionInLine;


-
+@property (assign) NSUInteger index;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;

@end
diff --git a/runtime/ObjC/Framework/ANTLRSymbolStack.m b/runtime/ObjC/Framework/ANTLRSymbolStack.m
index 48e45ca..2443e5d 100644
--- a/runtime/ObjC/Framework/ANTLRSymbolStack.m
+++ b/runtime/ObjC/Framework/ANTLRSymbolStack.m
@@ -108,8 +108,8 @@

- (void) insertObject:(ANTLRSymbolsScope *)aRule atIndex:(NSInteger)idx
{
-    if (aRule != ptrBuffer[idx]) {
-        if (ptrBuffer[idx] != nil) [ptrBuffer[idx] release];
+    if ( aRule != ptrBuffer[idx] ) {
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
[aRule retain];
}
ptrBuffer[idx] = aRule;
diff --git a/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.m b/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.m
index 2158771..b512da8 100644
--- a/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.m
+++ b/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.m
@@ -52,8 +52,8 @@
[self getTokenIndex],
[self getType],
[self getChannel],
-		[self getLine],
-		[self getCharPositionInLine],
+		[self line],
+		[self charPositionInLine],
escapedText
];
}
diff --git a/runtime/ObjC/Framework/ANTLRToken.h b/runtime/ObjC/Framework/ANTLRToken.h
index df5f33f..98d1d9b 100644
--- a/runtime/ObjC/Framework/ANTLRToken.h
+++ b/runtime/ObjC/Framework/ANTLRToken.h
@@ -45,8 +45,10 @@ typedef enum {

@protocol ANTLRToken < NSObject, NSCopying >

-@property (retain) NSString *text;
+@property (retain, getter = text, setter = setText:) NSString *text;
@property (assign) NSInteger type;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;

// The singleton eofToken instance.
+ (id<ANTLRToken>) eofToken;
@@ -54,19 +56,19 @@ typedef enum {
+ (ANTLRTokenChannel) defaultChannel;

// provide hooks to explicitely set the text as opposed to use the indices into the CharStream
-- (NSString *) getText;
-- (void) setText:(NSString *) theText;
+- (NSString *) text;
+- (void) setText:(NSString *)theText;

- (NSInteger) getType;
- (void) setType: (NSInteger) aType;

// ANTLR v3 provides automatic line and position tracking. Subclasses do not need to
// override these, if they do not want to store line/pos tracking information
-- (NSUInteger) getLine;
+- (NSUInteger) line;
- (void) setLine: (NSUInteger) aLine;

-- (NSUInteger) getCharPositionInLine;
-- (void) setCharPositionInLine: (NSUInteger) aCharPositionInLine;
+- (NSUInteger) charPositionInLine;
+- (void) setCharPositionInLine:(NSUInteger)aCharPositionInLine;

// explicitely change the channel this Token is on. The default parser implementation
// just sees the defaultChannel
diff --git a/runtime/ObjC/Framework/ANTLRTokenRewriteStream.h b/runtime/ObjC/Framework/ANTLRTokenRewriteStream.h
index 0d8681f..7b97168 100644
--- a/runtime/ObjC/Framework/ANTLRTokenRewriteStream.h
+++ b/runtime/ObjC/Framework/ANTLRTokenRewriteStream.h
@@ -40,23 +40,23 @@

@interface ANTLRRewriteOperation : ANTLRCommonTokenStream
{
-/** What index into rewrites List are we? */
+/** What rwIndex into rewrites List are we? */
NSInteger instructionIndex;
-/** Token buffer index. */
-NSInteger index;
+/** Token buffer rwIndex. */
+NSInteger rwIndex;
NSString *text;
}

@property (getter=getInstructionIndex, setter=setInstructionIndex:) NSInteger instructionIndex;
-@property (getter=getIndex, setter=setIndex:) NSInteger index;
-@property (retain, getter=getText, setter=setText:) NSString *text;
+@property (assign) NSInteger rwIndex;
+@property (retain, getter=text, setter=setText:) NSString *text;

-+ (ANTLRRewriteOperation *) newANTLRRewriteOperation:(NSInteger)index Text:(NSString *)text;
++ (ANTLRRewriteOperation *) newANTLRRewriteOperation:(NSInteger)anIndex Text:(NSString *)text;

- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText;

/** Execute the rewrite operation by possibly adding to the buffer.
- *  Return the index of the next token to operate on.
+ *  Return the rwIndex of the next token to operate on.
*/
- (NSInteger) execute:(NSString *)buf;

@@ -79,7 +79,7 @@ NSString *text;
NSInteger lastIndex;
}

-@property (getter=getLastIndex, setter=setLastIndex:) NSInteger lastIndex;
+@property (assign) NSInteger lastIndex;

+ (ANTLRReplaceOp *) newANTLRReplaceOp:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString*)theText;
- (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText;
@@ -107,7 +107,7 @@ NSString *text;
*/
ANTLRHashMap *programs;

-/** Map String (program name) -> Integer index */
+/** Map String (program name) -> Integer rwIndex */
ANTLRHashMap *lastRewriteTokenIndexes;
}

@@ -136,7 +136,7 @@ ANTLRHashMap *lastRewriteTokenIndexes;

- (void) insertBeforeToken:(id<ANTLRToken>)t Text:(NSString *)theText;
- (void) insertBeforeIndex:(NSInteger)anIndex Text:(NSString *)theText;
-- (void) insertBeforeProgName:(NSString *)programName Index:(NSInteger)index Text:(NSString *)theText;
+- (void) insertBeforeProgName:(NSString *)programName Index:(NSInteger)anIndex Text:(NSString *)theText;
- (void) replaceFromIndex:(NSInteger)anIndex Text:(NSString *)theText;
- (void) replaceFromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText;
- (void) replaceFromToken:(id<ANTLRToken>)indexT Text:(NSString *)theText;
diff --git a/runtime/ObjC/Framework/ANTLRTokenRewriteStream.m b/runtime/ObjC/Framework/ANTLRTokenRewriteStream.m
index 878b0d2..7e3f74d 100644
--- a/runtime/ObjC/Framework/ANTLRTokenRewriteStream.m
+++ b/runtime/ObjC/Framework/ANTLRTokenRewriteStream.m
@@ -43,7 +43,7 @@ extern NSInteger debug;
@implementation ANTLRRewriteOperation

@synthesize instructionIndex;
-@synthesize index;
+@synthesize rwIndex;
@synthesize text;

+ (ANTLRRewriteOperation *) newANTLRRewriteOperation:(NSInteger)anIndex Text:(NSString *)theText
@@ -54,18 +54,18 @@ extern NSInteger debug;
- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText
{
if ((self = [super init]) != nil) {
-        index = anIndex;
+        rwIndex = anIndex;
text = theText;
}
return self;
}

/** Execute the rewrite operation by possibly adding to the buffer.
- *  Return the index of the next token to operate on.
+ *  Return the rwIndex of the next token to operate on.
*/
- (NSInteger) execute:(NSString *)buf
{
-    return index;
+    return rwIndex;
}

- (NSString *)toString
@@ -73,7 +73,7 @@ extern NSInteger debug;
NSString *opName = [self className];
int $index = [self indexOf:'$' inString:opName];
opName = [opName substringWithRange:NSMakeRange($index+1, [opName length])];
-    return [NSString stringWithFormat:@"<%@%d:\"%@\">", opName, index, opName];
+    return [NSString stringWithFormat:@"<%@%d:\"%@\">", opName, rwIndex, opName];
}

- (NSInteger) indexOf:(char)aChar inString:(NSString *)aString
@@ -101,7 +101,7 @@ extern NSInteger debug;
- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText
{
if ((self = [super initWithIndex:anIndex Text:theText]) != nil) {
-        index = anIndex;
+        rwIndex = anIndex;
text = theText;
}
return self;
@@ -111,10 +111,10 @@ extern NSInteger debug;
- (NSInteger) execute:(NSMutableString *)buf
{
[buf appendString:text];
-    if ( [[tokens objectAtIndex:index] getType] != ANTLRTokenTypeEOF ) {
-        [buf appendString:[[tokens objectAtIndex:index] getText]];
+    if ( [[tokens objectAtIndex:rwIndex] getType] != ANTLRTokenTypeEOF ) {
+        [buf appendString:[[tokens objectAtIndex:rwIndex] text]];
}
-    return index+1;
+    return rwIndex+1;
}

@end
@@ -124,6 +124,8 @@ extern NSInteger debug;
*/
@implementation ANTLRReplaceOp

+@synthesize lastIndex;
+
+ (ANTLRReplaceOp *) newANTLRReplaceOp:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString*)theText
{
return [[ANTLRReplaceOp alloc] initWithIndex:from ToIndex:to Text:theText];
@@ -148,7 +150,7 @@ extern NSInteger debug;

- (NSString *)toString
{
-    return [NSString stringWithFormat:@"<ANTLRReplaceOp@ %d..%d :>%@\n", index, lastIndex, text];
+    return [NSString stringWithFormat:@"<ANTLRReplaceOp@ %d..%d :>%@\n", rwIndex, lastIndex, text];
}

@end
@@ -171,7 +173,7 @@ extern NSInteger debug;

- (NSString *)toString
{
-    return [NSString stringWithFormat:@"<DeleteOp@ %d..%d\n",  index, lastIndex];
+    return [NSString stringWithFormat:@"<DeleteOp@ %d..%d\n",  rwIndex, lastIndex];
}

@end
@@ -254,7 +256,7 @@ extern NSInteger debug;
id object;
ANTLRHashMap *is;

-    //    NSMutableArray *is = [programs get(programName)];
+    //    AMutableArray *is = [programs get(programName)];
is = [self getPrograms];
object = [is getName:programName];
if ( is != nil ) {
@@ -286,9 +288,9 @@ extern NSInteger debug;

- (void) insertAfterProgNam:(NSString *)programName Index:(NSInteger)anIndex Text:(NSString *)theText
{
-    // to insert after, just insert before next index (even if past end)
+    // to insert after, just insert before next rwIndex (even if past end)
[self insertBeforeProgName:programName Index:anIndex+1 Text:theText];
-    //addToSortedRewriteList(programName, new InsertAfterOp(index,text));
+    //addToSortedRewriteList(programName, new InsertAfterOp(rwIndex,text));
}


@@ -309,10 +311,10 @@ extern NSInteger debug;
[self insertBeforeProgName:DEFAULT_PROGRAM_NAME Index:anIndex Text:theText];
}

-- (void) insertBeforeProgName:(NSString *)programName Index:(NSInteger)index Text:(NSString *)theText
+- (void) insertBeforeProgName:(NSString *)programName Index:(NSInteger)rwIndex Text:(NSString *)theText
{
-    //addToSortedRewriteList(programName, new ANTLRInsertBeforeOp(index,text));
-    ANTLRRewriteOperation *op = [ANTLRInsertBeforeOp newANTLRInsertBeforeOp:index Text:theText];
+    //addToSortedRewriteList(programName, new ANTLRInsertBeforeOp(rwIndex,text));
+    ANTLRRewriteOperation *op = [ANTLRInsertBeforeOp newANTLRInsertBeforeOp:rwIndex Text:theText];
ANTLRHashMap *rewrites = [self getProgram:programName];
op.instructionIndex = [rewrites count];
[rewrites addObject:op];
@@ -432,7 +434,7 @@ extern NSInteger debug;
NSMutableString *buf = [NSMutableString stringWithCapacity:100];
for (int i = start; i >= MIN_TOKEN_INDEX && i <= end && i< [tokens count]; i++) {
if ( [[lastRewriteTokenIndexes objectAtIndex:i] getType] != ANTLRTokenTypeEOF )
-            [buf appendString:[[tokens objectAtIndex:i] getText]];
+            [buf appendString:[[tokens objectAtIndex:i] text]];
}
return [NSString stringWithString:buf];
}
@@ -475,12 +477,12 @@ extern NSInteger debug;
int i = start;
while ( i <= end && i < [tokens count] ) {
ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[indexToOp objectAtIndex:i];
-        [indexToOp setObject:nil atIndex:i]; // remove so any left have index size-1
+        [indexToOp setObject:nil atIndex:i]; // remove so any left have rwIndex size-1
id<ANTLRToken>t = (id<ANTLRToken>) [tokens objectAtIndex:i];
if ( op == nil ) {
-            // no operation at that index, just dump token
+            // no operation at that rwIndex, just dump token
if ( [t getType] != ANTLRTokenTypeEOF )
-                [buf appendString:[t getText]];
+                [buf appendString:[t text]];
i++; // move to next token
}
else {
@@ -488,7 +490,7 @@ extern NSInteger debug;
}
}

-    // include stuff after end if it's last index in buffer
+    // include stuff after end if it's last rwIndex in buffer
// So, if they did an insertAfter(lastValidIndex, "foo"), include
// foo if end==lastValidIndex.
//if ( end == [tokens size]-1 ) {
@@ -498,7 +500,7 @@ extern NSInteger debug;
int i2 = 0;
while ( i2 < [indexToOp count] - 1 ) {
ANTLRRewriteOperation *op = [indexToOp objectAtIndex:i2];
-            if ( op.index >= [tokens count]-1 ) {
+            if ( op.rwIndex >= [tokens count]-1 ) {
[buf appendString:op.text];
}
}
@@ -508,7 +510,7 @@ extern NSInteger debug;

/** We need to combine operations and report invalid operations (like
*  overlapping replaces that are not completed nested).  Inserts to
- *  same index need to be combined etc...   Here are the cases:
+ *  same rwIndex need to be combined etc...   Here are the cases:
*
*  I.i.u I.j.v								leave alone, nonoverlapping
*  I.i.u I.i.v								combine: Iivu
@@ -524,7 +526,7 @@ extern NSInteger debug;
*  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
*  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
*
- *  I.i.u = insert u before op @ index i
+ *  I.i.u = insert u before op @ rwIndex i
*  R.x-y.u = replace x-y indexed tokens with u
*
*  First we need to examine replaces.  For any replace op:
@@ -536,20 +538,20 @@ extern NSInteger debug;
*
*  Then we can deal with inserts:
*
- * 		1. for any inserts to same index, combine even if not adjacent.
+ * 		1. for any inserts to same rwIndex, combine even if not adjacent.
* 		2. for any prior replace with same left boundary, combine this
*         insert with replace and delete this replace.
- * 		3. throw exception if index in same range as previous replace
+ * 		3. throw exception if rwIndex in same range as previous replace
*
*  Don't actually delete; make op null in list. Easier to walk list.
- *  Later we can throw as we add to index -> op map.
+ *  Later we can throw as we add to rwIndex -> op map.
*
*  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
*  inserted stuff would be before the replace range.  But, if you
*  add tokens in front of a method body '{' and then delete the method
*  body, I think the stuff before the '{' you added should disappear too.
*
- *  Return a map from token index to operation.
+ *  Return a map from token rwIndex to operation.
*/
- (ANTLRHashMap *)reduceToSingleOperationPerIndex:(ANTLRHashMap *)rewrites
{
@@ -568,7 +570,7 @@ extern NSInteger debug;
ANTLRHashMap *inserts = [self getKindOfOps:rewrites KindOfClass:[ANTLRInsertBeforeOp class] Index:i];
for (int j = 0; j < [inserts size]; j++) {
ANTLRInsertBeforeOp *iop = (ANTLRInsertBeforeOp *)[inserts objectAtIndex:j];
-            if ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {
+            if ( iop.rwIndex >= rop.rwIndex && iop.rwIndex <= rop.lastIndex ) {
// delete insert as it's a no-op.
[rewrites insertObject:nil atIndex:iop.instructionIndex];
}
@@ -577,14 +579,14 @@ extern NSInteger debug;
ANTLRHashMap *prevReplaces = [self getKindOfOps:rewrites KindOfClass:[ANTLRReplaceOp class] Index:i];
for (int j = 0; j < [prevReplaces count]; j++) {
ANTLRReplaceOp *prevRop = (ANTLRReplaceOp *) [prevReplaces objectAtIndex:j];
-            if ( prevRop.index>=rop.index && prevRop.lastIndex <= rop.lastIndex ) {
+            if ( prevRop.rwIndex>=rop.rwIndex && prevRop.lastIndex <= rop.lastIndex ) {
// delete replace as it's a no-op.
[rewrites setObject:nil atIndex:prevRop.instructionIndex];
continue;
}
// throw exception unless disjoint or identical
-            BOOL disjoint = prevRop.lastIndex<rop.index || prevRop.index > rop.lastIndex;
-            BOOL same = prevRop.index==rop.index && prevRop.lastIndex==rop.lastIndex;
+            BOOL disjoint = prevRop.lastIndex<rop.rwIndex || prevRop.rwIndex > rop.lastIndex;
+            BOOL same = prevRop.rwIndex==rop.rwIndex && prevRop.lastIndex==rop.lastIndex;
if ( !disjoint && !same ) {
@throw [ANTLRIllegalArgumentException newException:
[NSString stringWithFormat:@"replace op boundaries of %@, overlap with previous %@\n", rop, prevRop]];
@@ -600,11 +602,11 @@ extern NSInteger debug;
if ( !([[op class] isKindOfClass:[ANTLRInsertBeforeOp class]]) )
continue;
ANTLRInsertBeforeOp *iop = (ANTLRInsertBeforeOp *)[rewrites objectAtIndex:i];
-        // combine current insert with prior if any at same index
+        // combine current insert with prior if any at same rwIndex
ANTLRHashMap *prevInserts = (ANTLRHashMap *)[self getKindOfOps:rewrites KindOfClass:[ANTLRInsertBeforeOp class] Index:i];
for (int j = 0; j < [prevInserts count]; j++) {
ANTLRInsertBeforeOp *prevIop = (ANTLRInsertBeforeOp *) [prevInserts objectAtIndex:j];
-            if ( prevIop.index == iop.index ) { // combine objects
+            if ( prevIop.rwIndex == iop.rwIndex ) { // combine objects
// convert to strings...we're in process of toString'ing
// whole token buffer so no lazy eval issue with any templates
iop.text = [self catOpText:iop.text PrevText:prevIop.text];
@@ -612,16 +614,16 @@ extern NSInteger debug;
[rewrites setObject:nil atIndex:prevIop.instructionIndex];
}
}
-        // look for replaces where iop.index is in range; error
+        // look for replaces where iop.rwIndex is in range; error
ANTLRHashMap *prevReplaces = (ANTLRHashMap *)[self getKindOfOps:rewrites KindOfClass:[ANTLRReplaceOp class] Index:i];
for (int j = 0; j < [prevReplaces count]; j++) {
ANTLRReplaceOp *rop = (ANTLRReplaceOp *) [prevReplaces objectAtIndex:j];
-            if ( iop.index == rop.index ) {
+            if ( iop.rwIndex == rop.rwIndex ) {
rop.text = [self catOpText:iop.text PrevText:rop.text];
[rewrites setObject:nil atIndex:i];  // delete current insert
continue;
}
-            if ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {
+            if ( iop.rwIndex >= rop.rwIndex && iop.rwIndex <= rop.lastIndex ) {
@throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"insert op %d within boundaries of previous %d", iop, rop]];
}
}
@@ -632,14 +634,14 @@ extern NSInteger debug;
ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
if ( op == nil )
continue; // ignore deleted ops
-        if ( [m objectAtIndex:op.index] != nil ) {
-            @throw [ANTLRRuntimeException newException:@"should only be one op per index\n"];
+        if ( [m objectAtIndex:op.rwIndex] != nil ) {
+            @throw [ANTLRRuntimeException newException:@"should only be one op per rwIndex\n"];
}
-        //[m put(new Integer(op.index), op);
-        [m setObject:op atIndex:op.index];
+        //[m put(new Integer(op.rwIndex), op);
+        [m setObject:op atIndex:op.rwIndex];
}
-    //System.out.println("index to op: "+m);
-    if (debug > 1) NSLog(@"index to  op %d\n", m);
+    //System.out.println("rwIndex to op: "+m);
+    if (debug > 1) NSLog(@"rwIndex to  op %d\n", m);
return m;
}

@@ -659,7 +661,7 @@ extern NSInteger debug;
return [self getKindOfOps:rewrites KindOfClass:kind Index:[rewrites count]];
}

-/** Get all operations before an index of a particular kind */
+/** Get all operations before an rwIndex of a particular kind */
- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind Index:(NSInteger)before
{
ANTLRHashMap *ops = [ANTLRHashMap newANTLRHashMapWithLen:15];
@@ -682,7 +684,7 @@ extern NSInteger debug;
{
NSMutableString *buf = [NSMutableString stringWithCapacity:100];
for (int i = start; i >= MIN_TOKEN_INDEX && i <= end && i < [tokens count]; i++) {
-        [buf appendString:[[tokens objectAtIndex:i] getText]];
+        [buf appendString:[[tokens objectAtIndex:i] text]];
}
return [NSString stringWithString:buf];
}
diff --git a/runtime/ObjC/Framework/ANTLRTree.h b/runtime/ObjC/Framework/ANTLRTree.h
index f269b2d..ecb798d 100644
--- a/runtime/ObjC/Framework/ANTLRTree.h
+++ b/runtime/ObjC/Framework/ANTLRTree.h
@@ -24,6 +24,8 @@
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

+#import "AMutableArray.h"
+
@protocol ANTLRTree < NSObject, NSCopying >

//+ (id<ANTLRTree>) invalidNode;
@@ -46,7 +48,7 @@
/** Return a list of all ancestors of this node.  The first node of
*  list is the root and the last is the parent of this node.
*/
-- (NSMutableArray *) getAncestors;
+- (AMutableArray *) getAncestors;

/** This node is what child index? 0..n-1 */
- (NSInteger) getChildIndex;
@@ -109,11 +111,11 @@

#pragma mark Tree Parser support
- (NSInteger) getType;
-- (NSString *) getText;
+- (NSString *) text;
// In case we don't have a token payload, what is the line for errors?
-- (NSInteger) getLine;
-- (NSInteger) getCharPositionInLine;
-- (void) setCharPositionInLine:(NSInteger)pos;
+- (NSUInteger) line;
+- (NSUInteger) charPositionInLine;
+- (void) setCharPositionInLine:(NSUInteger)pos;

#pragma mark Informational
- (NSString *) treeDescription;
diff --git a/runtime/ObjC/Framework/ANTLRTreeAdaptor.h b/runtime/ObjC/Framework/ANTLRTreeAdaptor.h
index a2bab1f..e0d94e0 100644
--- a/runtime/ObjC/Framework/ANTLRTreeAdaptor.h
+++ b/runtime/ObjC/Framework/ANTLRTreeAdaptor.h
@@ -35,8 +35,8 @@
#pragma mark Construction

#pragma mark ANTLRTreeAdaptor implementation
-- (id<ANTLRBaseTree>)dupNode:(id<ANTLRBaseTree>)aNode;	// copies just the node
-- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)aTree;	// copies the entire subtree, recursively
+- (id)dupNode:(id)aNode;	// copies just the node
+- (id)dupTree:(id)aTree;	// copies the entire subtree, recursively

/** Return a nil node (an empty but non-null node) that can hold
*  a list of element as the children.  If you want a flat tree (a list)
@@ -64,10 +64,10 @@
Exception:(NSException *) e;

/** Is tree considered a nil node used to make lists of child nodes? */
-- (BOOL) isNil:(id<ANTLRBaseTree>)aTree;
+- (BOOL) isNil:(id)aTree;


-- (void) addChild:(id<ANTLRBaseTree>)child toTree:(id<ANTLRBaseTree>)aTree;
+- (void) addChild:(id)child toTree:(id)aTree;

/** If oldRoot is a nil root, just copy or move the children to newRoot.
*  If not a nil root, make oldRoot a child of newRoot.
@@ -95,198 +95,63 @@
*  constructing these nodes so we should have this control for
*  efficiency.
*/
-- (id) becomeRoot:(id<ANTLRBaseTree>)newRoot old:(id<ANTLRBaseTree>)oldRoot;
+- (id) becomeRoot:(id)newRoot old:(id)oldRoot;

-- (id) rulePostProcessing:(id<ANTLRBaseTree>)root;
+- (id) rulePostProcessing:(id)root;

#pragma mark Rewrite Rules

-- (NSUInteger) getUniqueID:(id<ANTLRBaseTree>)aNode;
+- (NSUInteger) getUniqueID:(id)aNode;

-- (id<ANTLRBaseTree>) create:(id<ANTLRToken>)payload;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType Text:(NSString *)text;
+- (id) create:(id<ANTLRToken>)payload;
+- (id) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken;
+- (id) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text;
+- (id) createTree:(NSInteger)tokenType Text:(NSString *)text;

#pragma mark Content

-- (id<ANTLRBaseTree>)dupNode:(id<ANTLRBaseTree>)aNode;
-- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)aTree;
+- (id)dupNode:(id)aNode;
+- (id)dupTree:(id)aTree;

-- (NSInteger) getType:(id<ANTLRBaseTree>)aNode;
-- (void) setType:(id<ANTLRBaseTree>)aNode Type:(NSInteger)tokenType;
+- (NSInteger) getType:(id)aNode;
+- (void) setType:(id)aNode Type:(NSInteger)tokenType;

-- (NSString *) getText:(id<ANTLRBaseTree>)aNode;
-- (void) setText:(id<ANTLRBaseTree>)aNode Text:(NSString *)tokenText;
+- (NSString *) getText:(id)aNode;
+- (void) setText:(id)aNode Text:(NSString *)tokenText;

-- (id<ANTLRToken>) getToken:(id<ANTLRBaseTree>)t;
+//- (id<ANTLRToken>) getToken:(id)t;

-- (void) setTokenBoundaries:(id<ANTLRBaseTree>)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
-- (NSInteger) getTokenStartIndex:(id<ANTLRBaseTree>)aTree;
-- (NSInteger) getTokenStopIndex:(id<ANTLRBaseTree>)aTree;
+- (void) setTokenBoundaries:(id)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
+- (NSInteger) getTokenStartIndex:(id)aTree;
+- (NSInteger) getTokenStopIndex:(id)aTree;

#pragma mark Navigation / Tree Parsing

/** Get a child 0..n-1 node */
-- (id<ANTLRBaseTree>) getChild:(id<ANTLRBaseTree>)aNode At:(NSInteger) i;
+- (id) getChild:(id)aNode At:(NSInteger) i;
/** Set ith child (0..n-1) to t; t must be non-null and non-nil node */
-- (void) setChild:(id<ANTLRBaseTree>)aTree At:(NSInteger)index Child:(id<ANTLRBaseTree>)child;
+- (void) setChild:(id)aTree At:(NSInteger)index Child:(id)child;
/** Remove ith child and shift children down from right. */
-- (id<ANTLRBaseTree>) deleteChild:(id<ANTLRBaseTree>)t Index:(NSInteger)index;
+- (id) deleteChild:(id)t Index:(NSInteger)index;

/** How many children?  If 0, then this is a leaf node */
-- (NSInteger) getChildCount:(id<ANTLRBaseTree>) aTree;
+- (NSInteger) getChildCount:(id) aTree;

/** Who is the parent node of this node; if null, implies node is root.
*  If your node type doesn't handle this, it's ok but the tree rewrites
*  in tree parsers need this functionality.
*/
-- (id<ANTLRBaseTree>)getParent:(id<ANTLRBaseTree>)t;
-- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>)parent;
+- (id)getParent:(id)t;
+- (void) setParent:(id)t With:(id)parent;

/** What index is this node in the child list? Range: 0..n-1
*  If your node type doesn't handle this, it's ok but the tree rewrites
*  in tree parsers need this functionality.
*/
-- (NSInteger) getChildIndex:(id<ANTLRBaseTree>)t;
-- (void) setChildIndex:(id<ANTLRBaseTree>)t With:(NSInteger)index;
+- (NSInteger) getChildIndex:(id)t;
+- (void) setChildIndex:(id)t With:(NSInteger)index;

-- (void) replaceChildren:(id<ANTLRBaseTree>)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id<ANTLRBaseTree>)t;
+- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t;

@end

-#ifdef DONTUSENOMO
-@interface ANTLRTreeAdaptor : NSObject {
-
-}
-
-+ (id) newAdaptor;
-- (id) init;
-
-#pragma mark Construction
-
-+ (id<ANTLRBaseTree>) newEmptyTree;
-
-- (id<ANTLRBaseTree>) createTree:(id<ANTLRToken>)payload;
-
-#pragma mark ANTLRTreeAdaptor implementation
-- (id<ANTLRBaseTree>)dupNode:(id<ANTLRBaseTree>)aNode;	// copies just the node
-- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)aTree;	// copies the entire subtree, recursively
-
-/** Return a nil node (an empty but non-null node) that can hold
- *  a list of element as the children.  If you want a flat tree (a list)
- *  use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
- */
-- (id) emptyNode;
-
-/** Return a tree node representing an error.  This node records the
- *  tokens consumed during error recovery.  The start token indicates the
- *  input symbol at which the error was detected.  The stop token indicates
- *  the last symbol consumed during recovery.
- *
- *  You must specify the input stream so that the erroneous text can
- *  be packaged up in the error node.  The exception could be useful
- *  to some applications; default implementation stores ptr to it in
- *  the CommonErrorNode.
- *
- *  This only makes sense during token parsing, not tree parsing.
- *  Tree parsing should happen only when parsing and tree construction
- *  succeed.
- */
-- (id) errorNode:(id<ANTLRTokenStream>)anInput
-            From:(id<ANTLRToken>)aStartToken
-              To:(id<ANTLRToken>)aStopToken
-       Exception:(NSException *) e;
-
-/** Is tree considered a nil node used to make lists of child nodes? */
-- (BOOL) isNil:(id<ANTLRBaseTree>)aTree;
-
-
-- (void) addChild:(id<ANTLRBaseTree>)child toTree:(id<ANTLRBaseTree>)aTree;
-
-/** If oldRoot is a nil root, just copy or move the children to newRoot.
- *  If not a nil root, make oldRoot a child of newRoot.
- *
- *    old=^(nil a b c), new=r yields ^(r a b c)
- *    old=^(a b c), new=r yields ^(r ^(a b c))
- *
- *  If newRoot is a nil-rooted single child tree, use the single
- *  child as the new root node.
- *
- *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
- *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
- *
- *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
- *
- *    old=null, new=r yields r
- *    old=null, new=^(nil r) yields ^(nil r)
- *
- *  Return newRoot.  Throw an exception if newRoot is not a
- *  simple node or nil root with a single child node--it must be a root
- *  node.  If newRoot is ^(nil x) return x as newRoot.
- *
- *  Be advised that it's ok for newRoot to point at oldRoot's
- *  children; i.e., you don't have to copy the list.  We are
- *  constructing these nodes so we should have this control for
- *  efficiency.
- */
-- (id) becomeRoot:(id<ANTLRBaseTree>)newRoot old:(id<ANTLRBaseTree>)oldRoot;
-
-- (id) rulePostProcessing:(id<ANTLRBaseTree>)root;
-
-#pragma mark Rewrite Rules
-
-- (NSUInteger) getUniqueID:(id<ANTLRBaseTree>)aNode;
-
-- (id<ANTLRBaseTree>) create:(id<ANTLRToken>)payload;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType Text:(NSString *)text;
-
-#pragma mark Content
-
-- (id<ANTLRBaseTree>)dupNode:(id<ANTLRBaseTree>)aNode;
-- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)aTree;
-
-- (NSInteger) getType:(id<ANTLRBaseTree>)aNode;
-- (void) setType:(id<ANTLRBaseTree>)aNode Type:(NSInteger)tokenType;
-
-- (NSString *) getText:(id<ANTLRBaseTree>)aNode;
-- (void) setText:(id<ANTLRBaseTree>)aNode Text:(NSString *)tokenText;
-
-- (id<ANTLRToken>) getToken:(id<ANTLRBaseTree>)t;
-
-- (void) setTokenBoundaries:(id<ANTLRBaseTree>)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
-- (NSInteger) getTokenStartIndex:(id<ANTLRBaseTree>)aTree;
-- (NSInteger) getTokenStopIndex:(id<ANTLRBaseTree>)aTree;
-
-#pragma mark Navigation / Tree Parsing
-
-/** Get a child 0..n-1 node */
-- (id<ANTLRBaseTree>) getChild:(id<ANTLRBaseTree>)aNode At:(NSInteger) i;
-/** Set ith child (0..n-1) to t; t must be non-null and non-nil node */
-- (void) setChild:(id<ANTLRBaseTree>)aTree At:(NSInteger)index Child:(id<ANTLRBaseTree>)child;
-/** Remove ith child and shift children down from right. */
-- (id<ANTLRBaseTree>) deleteChild:(id<ANTLRBaseTree>)t Index:(NSInteger)index;
-
-/** How many children?  If 0, then this is a leaf node */
-- (NSInteger) getChildCount:(id<ANTLRBaseTree>) aTree;
-
-/** Who is the parent node of this node; if null, implies node is root.
- *  If your node type doesn't handle this, it's ok but the tree rewrites
- *  in tree parsers need this functionality.
- */
-- (id<ANTLRBaseTree>)getParent:(id<ANTLRBaseTree>)t;
-- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>)parent;
-
-/** What index is this node in the child list? Range: 0..n-1
- *  If your node type doesn't handle this, it's ok but the tree rewrites
- *  in tree parsers need this functionality.
- */
-- (NSInteger) getChildIndex:(id<ANTLRBaseTree>)t;
-- (void) setChildIndex:(id<ANTLRBaseTree>)t With:(NSInteger)index;
-
-- (void) replaceChildren:(id<ANTLRBaseTree>)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id<ANTLRBaseTree>)t;
-
-@end
-#endif
diff --git a/runtime/ObjC/Framework/ANTLRTreeException.m b/runtime/ObjC/Framework/ANTLRTreeException.m
index 8d78e7f..40af57e 100644
--- a/runtime/ObjC/Framework/ANTLRTreeException.m
+++ b/runtime/ObjC/Framework/ANTLRTreeException.m
@@ -60,7 +60,7 @@
{
if (newRoot != aTree) {
[aTree retain];
-		[newRoot release];
+		if ( newRoot ) [newRoot release];
newRoot = aTree;
}
}
@@ -69,7 +69,7 @@
{
if (oldRoot != aTree) {
[aTree retain];
-		[oldRoot release];
+		if ( oldRoot ) [oldRoot release];
oldRoot = aTree;
}
}
diff --git a/runtime/ObjC/Framework/ANTLRTreeIterator.m b/runtime/ObjC/Framework/ANTLRTreeIterator.m
index 083e75c..2a4e1b3 100644
--- a/runtime/ObjC/Framework/ANTLRTreeIterator.m
+++ b/runtime/ObjC/Framework/ANTLRTreeIterator.m
@@ -149,7 +149,7 @@

-(NSArray *) allObjects
{
-	NSMutableArray *array = [NSMutableArray arrayWithCapacity:10];
+	AMutableArray *array = [AMutableArray arrayWithCapacity:10];
while ([self hasNext]) {
[array addObject:[self nextObject]];
}
diff --git a/runtime/ObjC/Framework/ANTLRTreeNodeStream.h b/runtime/ObjC/Framework/ANTLRTreeNodeStream.h
index d14be70..8d10aaa 100644
--- a/runtime/ObjC/Framework/ANTLRTreeNodeStream.h
+++ b/runtime/ObjC/Framework/ANTLRTreeNodeStream.h
@@ -36,7 +36,7 @@

- (id) initWithTree:(ANTLRCommonTree *)theTree;

-- (id) getNode:(NSInteger) idx;
+- (id) getTree:(NSInteger) idx;
- (id) LT:(NSInteger)k;
- (id) getTreeSource;
- (id<ANTLRTokenStream>) getTokenStream;
diff --git a/runtime/ObjC/Framework/ANTLRTreeParser.h b/runtime/ObjC/Framework/ANTLRTreeParser.h
index 981bc3c..7fa7472 100644
--- a/runtime/ObjC/Framework/ANTLRTreeParser.h
+++ b/runtime/ObjC/Framework/ANTLRTreeParser.h
@@ -79,11 +79,9 @@
*/
- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e;

-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(NSMutableArray *) tokenNames;
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *) tokenNames;

- (void) traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex;
- (void) traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex;

-
-
@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeParser.m b/runtime/ObjC/Framework/ANTLRTreeParser.m
index 34fab50..81a4db3 100644
--- a/runtime/ObjC/Framework/ANTLRTreeParser.m
+++ b/runtime/ObjC/Framework/ANTLRTreeParser.m
@@ -162,7 +162,7 @@
/** Tree parsers parse nodes they usually have a token object as
*  payload. Set the exception token and do the default behavior.
*/
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e  TokenNames:(NSMutableArray *) theTokNams
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e  TokenNames:(AMutableArray *) theTokNams
{
if ( [self isKindOfClass:[ANTLRTreeParser class]] ) {
id<ANTLRTreeAdaptor> adaptor = (id<ANTLRTreeAdaptor>)[((id<ANTLRTreeNodeStream>)e.input) getTreeAdaptor];
diff --git a/runtime/ObjC/Framework/ANTLRTreeRewriter.m b/runtime/ObjC/Framework/ANTLRTreeRewriter.m
index 6acf1d8..d965831 100644
--- a/runtime/ObjC/Framework/ANTLRTreeRewriter.m
+++ b/runtime/ObjC/Framework/ANTLRTreeRewriter.m
@@ -56,7 +56,7 @@
if ( [actor respondsToSelector:ruleSEL] )
return [actor performSelector:ruleSEL];
else
-        @throw [ANTLRRecognitionException newException:@"Unknown Rewrite exception"];
+        @throw [ANTLRRuntimeException newException:@"Unknown Rewrite exception"];
return nil;
}

diff --git a/runtime/ObjC/Framework/ANTLRTreeWizard.h b/runtime/ObjC/Framework/ANTLRTreeWizard.h
index e748cb6..0575bd8 100644
--- a/runtime/ObjC/Framework/ANTLRTreeWizard.h
+++ b/runtime/ObjC/Framework/ANTLRTreeWizard.h
@@ -34,6 +34,7 @@
#import "ANTLRCommonTree.h"
#import "ANTLRMapElement.h"
#import "ANTLRMap.h"
+#import "AMutableArray.h"

@class ANTLRVisitor;

@@ -116,7 +117,7 @@
- (NSInteger)getTokenType:(NSString *)tokenName;
- (ANTLRMap *)index:(id<ANTLRBaseTree>)t;
- (void) _index:(id<ANTLRBaseTree>)t Map:(ANTLRMap *)m;
-- (NSMutableArray *)find:(id<ANTLRBaseTree>) t Pattern:(NSString *)pattern;
+- (AMutableArray *)find:(id<ANTLRBaseTree>) t Pattern:(NSString *)pattern;
- (ANTLRTreeWizard *)findFirst:(id<ANTLRBaseTree>) t Type:(NSInteger)ttype;
- (ANTLRTreeWizard *)findFirst:(id<ANTLRBaseTree>) t Pattern:(NSString *)pattern;
- (void) visit:(id<ANTLRBaseTree>)t Type:(NSInteger)ttype Visitor:(ANTLRVisitor *)visitor;
diff --git a/runtime/ObjC/Framework/ANTLRTreeWizard.m b/runtime/ObjC/Framework/ANTLRTreeWizard.m
index 4faeed8..2e8f1a1 100644
--- a/runtime/ObjC/Framework/ANTLRTreeWizard.m
+++ b/runtime/ObjC/Framework/ANTLRTreeWizard.m
@@ -63,7 +63,7 @@
break;
case 1:
if ( [(ANTLRTreeWizard *)actor _parse:t Pattern:object1/* tpattern */ Map:nil] ) {
-                [(NSMutableArray *)object2/* subtrees */ addObject:t];
+                [(AMutableArray *)object2/* subtrees */ addObject:t];
}
break;
}
@@ -322,7 +322,7 @@
}

/** Return a List of tree nodes with token type ttype */
-- (NSMutableArray *)find:(id<ANTLRBaseTree>)t Type:(NSInteger)ttype
+- (AMutableArray *)find:(id<ANTLRBaseTree>)t Type:(NSInteger)ttype
{
#ifdef DONTUSENOMO
final List nodes = new ArrayList();
@@ -332,16 +332,16 @@
}
} );
#endif
-    NSMutableArray *nodes = [NSMutableArray arrayWithCapacity:100];
+    AMutableArray *nodes = [AMutableArray arrayWithCapacity:100];
ANTLRVisitor *contextVisitor = [ANTLRVisitor newANTLRVisitor:3 Actor:self Object:(id)nodes Object:nil];
[self visit:t Type:ttype Visitor:contextVisitor];
return nodes;
}

/** Return a List of subtrees matching pattern. */
-- (NSMutableArray *)find:(id<ANTLRBaseTree>)t Pattern:(NSString *)pattern
+- (AMutableArray *)find:(id<ANTLRBaseTree>)t Pattern:(NSString *)pattern
{
-    NSMutableArray *subtrees = [NSMutableArray arrayWithCapacity:100];
+    AMutableArray *subtrees = [AMutableArray arrayWithCapacity:100];
// Create a TreePattern from the pattern
ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
ANTLRTreePatternParser *parser = [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer
@@ -511,7 +511,7 @@
if ( [adaptor getType:t1] != [tpattern getType] )
return NO;
// if pattern has text, check node text
-        if ( tpattern.hasTextArg && ![[adaptor getText:t1] isEqualToString:[tpattern getText]] ) {
+        if ( tpattern.hasTextArg && ![[adaptor getText:t1] isEqualToString:[tpattern text]] ) {
return NO;
}
}
@@ -642,9 +642,9 @@
return; // tokenType not of interest
}
NSInteger streamIndexI = streamIndex;
-    NSMutableArray *indexes = (NSMutableArray *)[tokenTypeToStreamIndexesMap objectAtIndex:tokenTypeI];
+    AMutableArray *indexes = (AMutableArray *)[tokenTypeToStreamIndexesMap objectAtIndex:tokenTypeI];
if ( indexes==nil ) {
-        indexes = [NSMutableArray arrayWithCapacity:100]; // no list yet for this token type
+        indexes = [AMutableArray arrayWithCapacity:100]; // no list yet for this token type
indexes.add(streamIndexI); // not there yet, add
[tokenTypeToStreamIndexesMap put:tokenTypeI Idexes:indexes];
}
diff --git a/runtime/ObjC/Framework/ANTLRUniqueIDMap.m b/runtime/ObjC/Framework/ANTLRUniqueIDMap.m
index 4230120..e5c2998 100644
--- a/runtime/ObjC/Framework/ANTLRUniqueIDMap.m
+++ b/runtime/ObjC/Framework/ANTLRUniqueIDMap.m
@@ -100,7 +100,7 @@
while ( tmp ) {
rtmp = tmp;
tmp = tmp.fNext;
-                [rtmp dealloc];
+                [rtmp release];
}
}
}
@@ -116,7 +116,7 @@
while ( tmp ) {
rtmp = tmp;
tmp = [tmp getfNext];
-            [rtmp dealloc];
+            [rtmp release];
}
ptrBuffer[idx] = nil;
}
diff --git a/runtime/ObjC/Framework/ArrayIterator.h b/runtime/ObjC/Framework/ArrayIterator.h
new file mode 100644
index 0000000..280f03f
--- /dev/null
+++ b/runtime/ObjC/Framework/ArrayIterator.h
@@ -0,0 +1,79 @@
+/*
+ * [The "BSD license"]
+ *  Copyright (c) 2011 Terence Parr and Alan Condit
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#import <Cocoa/Cocoa.h>
+#import <Foundation/Foundation.h>
+
+/**
+ * Iterator for an array so I don't have to copy the array to a List
+ * just to make it iteratable.
+ */
+
+/*
+ * this is the state structure for FastEnumeration
+ typedef struct {
+ unsigned long state;
+ id *itemsPtr;
+ unsigned long *mutationsPtr;
+ unsigned long extra[5];
+ } NSFastEnumerationState;
+ */
+
+@interface ArrayIterator : NSObject {
+
+    __strong id peekObj;
+    /**
+     * NSArrays are fixed size; precompute count.
+     */
+    NSInteger count;
+    NSInteger index;
+    __strong NSArray *anArray;
+
+}
+
++ (ArrayIterator *) newIterator:(NSArray *)array;
++ (ArrayIterator *) newIteratorForDictKey:(NSDictionary *)dict;
++ (ArrayIterator *) newIteratorForDictObj:(NSDictionary *)dict;
+
+- (id) initWithArray:(NSArray *)array;
+- (id) initWithDictKey:(NSDictionary *)dict;
+- (id) initWithDictObj:(NSDictionary *)dict;
+
+- (BOOL) hasNext;
+- (id) nextObject;
+- (NSArray *)allObjects;
+- (void) removeObjectAtIndex:(NSInteger)idx;
+- (NSInteger) count;
+- (void) setCount:(NSInteger)cnt;
+- (void) dealloc;
+
+@property (retain) id peekObj;
+@property (assign, getter=count, setter=setCount:) NSInteger count;
+@property (assign) NSInteger index;
+@property (retain) NSArray *anArray;
+
+@end
diff --git a/runtime/ObjC/Framework/ArrayIterator.m b/runtime/ObjC/Framework/ArrayIterator.m
new file mode 100644
index 0000000..4bb449f
--- /dev/null
+++ b/runtime/ObjC/Framework/ArrayIterator.m
@@ -0,0 +1,179 @@
+/*
+ * [The "BSD license"]
+ *  Copyright (c) 2011 Terence Parr and Alan Condit
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in the
+ *     documentation and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *     derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#import "ArrayIterator.h"
+#import "ANTLRRuntimeException.h"
+
+@class AMutableArray;
+
+@implementation ArrayIterator
+
+@synthesize peekObj;
+//@synthesize count;
+@synthesize index;
+@synthesize anArray;
+
+
++ (ArrayIterator *) newIterator:(NSArray *)array
+{
+    return [[ArrayIterator alloc] initWithArray:array];
+}
+
++ (ArrayIterator *) newIteratorForDictKey:(NSDictionary *)dict
+{
+    return [[ArrayIterator alloc] initWithDictKey:dict];
+}
+
++ (ArrayIterator *) newIteratorForDictObj:(NSDictionary *)dict
+{
+    return [[ArrayIterator alloc] initWithDictObj:dict];
+}
+
+- (id) initWithArray:(NSArray *)array
+{
+    self=[super init];
+    if ( self != nil ) {
+        if (![array isKindOfClass:[NSArray class]]) {
+                @throw [NSException exceptionWithName:NSInvalidArgumentException
+                                               reason:[NSString stringWithFormat:@"ArrayIterator expecting NSArray class but got %@", [array className]]
+                                             userInfo:nil];
+        }
+        anArray = [array retain];
+#ifdef DONTUSENOMO
+        for (int i = 0; i < [array count]; i++) {
+            [anArray addObject:[array objectAtIndex:i]];
+            count++;
+        }
+#endif
+        peekObj = nil;
+        count = [anArray count];
+        index = 0;
+    }
+    return self;
+}
+
+- (id) initWithDictKey:(NSDictionary *)dict
+{
+    self=[super init];
+    if ( self != nil ) {
+        if (![dict isKindOfClass:[NSDictionary class]]) {
+            @throw [NSException exceptionWithName:NSInvalidArgumentException
+                                           reason:[NSString stringWithFormat:@"ArrayIterator expecting NSDictionary class but got %@", [dict className]]
+                                         userInfo:nil];
+        }
+        anArray = [[[dict keyEnumerator] allObjects] retain];
+        peekObj = nil;
+        count = [anArray count];
+        index = 0;
+    }
+    return self;
+}
+
+- (id) initWithDictObj:(NSDictionary *)dict
+{
+    self=[super init];
+    if ( self != nil ) {
+        if (![dict isKindOfClass:[NSDictionary class]]) {
+            @throw [NSException exceptionWithName:NSInvalidArgumentException
+                                           reason:[NSString stringWithFormat:@"ArrayIterator expecting NSDictionary class but got %@", [dict className]]
+                                         userInfo:nil];
+        }
+        anArray = [[[dict objectEnumerator] allObjects] retain];
+        peekObj = nil;
+        count = [anArray count];
+        index = 0;
+    }
+    return self;
+}
+
+- (BOOL) hasNext
+{
+    if ( peekObj == nil ) {
+        peekObj = [self nextObject];
+    }
+    return ((peekObj) ? YES : NO);
+}
+
+- (NSObject *) nextObject
+{
+    id obj = nil;
+    if ( peekObj ) {
+        obj = peekObj;
+        peekObj = nil;
+        return obj;
+    }
+    if ( index >= count ) {
+        return nil;
+    }
+    if ( anArray ) {
+        obj = [anArray objectAtIndex:index++];
+        if ( index >= count ) {
+            [anArray release];
+            anArray = nil;
+            index = 0;
+            count = 0;
+        }
+    }
+    return obj;
+}
+
+- (NSArray *) allObjects
+{
+    if ( (count <= 0 || index >= count) && peekObj == nil ) return nil;
+    AMutableArray *theArray = [AMutableArray arrayWithCapacity:count];
+    if (peekObj) {
+        [theArray addObject:peekObj];
+        peekObj = nil;
+    }
+    for (int i = index; i < count; i++) {
+        [theArray addObject:[anArray objectAtIndex:i]];
+    }
+    return [NSArray arrayWithArray:(NSArray *)theArray];
+}
+
+- (void) removeObjectAtIndex:(NSInteger)idx
+{
+    @throw [[ANTLRUnsupportedOperationException newException:@"Cant remove object from ArrayIterator"] autorelease];
+}
+
+- (NSInteger) count
+{
+    return (index - count);
+}
+
+- (void) setCount:(NSInteger)cnt
+{
+    count = cnt;
+}
+
+- (void) dealloc
+{
+    if ( anArray ) [anArray release];
+    [super dealloc];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/antlr3.h b/runtime/ObjC/Framework/antlr3.h
index b76ce93..6fdc5b5 100644
--- a/runtime/ObjC/Framework/antlr3.h
+++ b/runtime/ObjC/Framework/antlr3.h
@@ -24,6 +24,9 @@
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

+#import <ANTLR/ACBTree.h>
+#import <ANTLR/AMutableArray.h>
+#import <ANTLR/AMutableDictionary.h>
#import <ANTLR/ANTLRBaseMapElement.h>
#import <ANTLR/ANTLRBaseRecognizer.h>
#import <ANTLR/ANTLRBaseStack.h>
@@ -107,3 +110,4 @@
//#import <ANTLR/ANTLRUnbufferedCommonTreeNodeStreamState.h>
#import <ANTLR/ANTLRUniqueIDMap.h>
#import <ANTLR/ANTLRUnwantedTokenException.h>
+#import <ANTLR/ArrayIterator.h>

