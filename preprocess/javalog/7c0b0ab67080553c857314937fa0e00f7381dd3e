commit 7c0b0ab67080553c857314937fa0e00f7381dd3e
Author:     parrt <parrt@antlr.org>
AuthorDate: Mon Apr 11 10:00:30 2011 -0800
Commit:     parrt <parrt@antlr.org>
CommitDate: Mon Apr 11 10:00:30 2011 -0800

oops; needed to get more code back in for -Xconversiontimeout. still doesn't seem quite right.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8166]

diff --git a/tool/src/main/java/org/antlr/Tool.java b/tool/src/main/java/org/antlr/Tool.java
index 4d7a168..48367ac 100644
--- a/tool/src/main/java/org/antlr/Tool.java
+++ b/tool/src/main/java/org/antlr/Tool.java
@@ -755,7 +755,7 @@ public class Tool {
System.err.println("  -Xnoprune               test lookahead against EBNF block exit branches");
System.err.println("  -Xnocollapse            collapse incident edges into DFA states");
System.err.println("  -Xdbgconversion         dump lots of info during NFA conversion");
-		System.err.println("  -Xconversiontimeout     use to restrict NFA conversion exponentiality");
+		System.err.println("  -Xconversiontimeout t   set NFA conversion timeout (ms) for each decision          [" + DFA.MAX_TIME_PER_DFA_CREATION + "]");
System.err.println("  -Xmultithreaded         run the analysis in 2 threads");
System.err.println("  -Xnomergestopstates     do not merge stop states");
System.err.println("  -Xdfaverbose            generate DFA states in DOT with NFA configs");
diff --git a/tool/src/main/java/org/antlr/analysis/DFA.java b/tool/src/main/java/org/antlr/analysis/DFA.java
index 896acc7..c26bb6f 100644
--- a/tool/src/main/java/org/antlr/analysis/DFA.java
+++ b/tool/src/main/java/org/antlr/analysis/DFA.java
@@ -50,7 +50,7 @@ public class DFA {
public static final int CYCLIC_UNKNOWN = -2;
public static final int CYCLIC_BUSY = -1; // in process of computing
public static final int CYCLIC_DONE = 0;
-
+
/** Prevent explosion of DFA states during conversion. The max number
*  of states per alt in a single decision's DFA.
public static final int MAX_STATES_PER_ALT_IN_DFA = 450;
@@ -166,7 +166,7 @@ public class DFA {
*  if it takes too long, then terminate.  Assume bugs are in the
*  analysis engine.
*/
-	//protected long conversionStartTime;
+	protected long conversionStartTime;

/** Map an edge transition table to a unique set number; ordered so
*  we can push into the output template as an ordered list of sets
@@ -251,12 +251,12 @@ public class DFA {
//long stop = System.currentTimeMillis();
//System.out.println("verify cost: "+(int)(stop-start)+" ms");
}
-//		catch (AnalysisTimeoutException at) {
-//			probe.reportAnalysisTimeout();
-//			if ( !okToRetryDFAWithK1() ) {
-//				probe.issueWarnings();
-//			}
-//		}
+		catch (AnalysisTimeoutException at) {
+			probe.reportAnalysisTimeout();
+			if ( !okToRetryDFAWithK1() ) {
+				probe.issueWarnings();
+			}
+		}
catch (NonLLStarDecisionException nonLL) {
probe.reportNonLLStarDecision(this);
// >1 alt recurses, k=* and no auto backtrack nor manual sem/syn
@@ -807,7 +807,7 @@ public class DFA {
*     ;
*
*  gives
-	 *
+	 *
* .s0-X->.s1
* .s0-Y&&{synpred1_t}?->:s2=>1
* .s1-{synpred1_t}?->:s2=>1
@@ -824,7 +824,7 @@ public class DFA {
return has;
}

-	public boolean getHasSynPred() { return hasSynPred(); } // for ST
+	public boolean getHasSynPred() { return hasSynPred(); } // for ST

boolean _hasSynPred(DFAState d, Set<DFAState> busy) {
busy.add(d);
@@ -1030,7 +1030,7 @@ public class DFA {
(probe.isNonLLStarDecision()||probe.analysisOverflowed()) &&
predicateVisible; // auto backtrack or manual sem/syn
return getUserMaxLookahead()!=1 &&
-			 nonLLStarOrOverflowAndPredicateVisible;
+			 (analysisTimedOut() || nonLLStarOrOverflowAndPredicateVisible);
}

public String getReasonForFailure() {
@@ -1047,6 +1047,14 @@ public class DFA {
buf.append(" && predicate visible");
}
}
+		if ( analysisTimedOut() ) {
+			if ( buf.length()>0 ) {
+				buf.append(" && ");
+			}
+			buf.append("timed out (>");
+			buf.append(DFA.MAX_TIME_PER_DFA_CREATION);
+			buf.append("ms)");
+		}
buf.append("\n");
return buf.toString();
}
@@ -1090,9 +1098,9 @@ public class DFA {
return nAlts;
}

-//	public boolean analysisTimedOut() {
-//		return probe.analysisTimedOut();
-//	}
+	public boolean analysisTimedOut() {
+		return probe.analysisTimedOut();
+	}

protected void initAltRelatedInfo() {
unreachableAlts = new LinkedList();
diff --git a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
index 0e4d393..185c057 100644
--- a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
+++ b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
@@ -213,9 +213,9 @@ public class DecisionProbe {
}

/** Did the analysis complete it's work? */
-//	public boolean analysisTimedOut() {
-//		return timedOut;
-//	}
+	public boolean analysisTimedOut() {
+		return timedOut;
+	}

/** Took too long to analyze a DFA */
public boolean analysisOverflowed() {
@@ -621,10 +621,10 @@ public class DecisionProbe {
danglingStates.add(d);
}

-//	public void reportAnalysisTimeout() {
-//		timedOut = true;
+	public void reportAnalysisTimeout() {
+		timedOut = true;
//		dfa.nfa.grammar.setOfDFAWhoseAnalysisTimedOut.add(dfa);
-//	}
+	}

/** Report that at least 2 alts have recursive constructs.  There is
*  no way to build a DFA so we terminated.
@@ -896,7 +896,7 @@ public class DecisionProbe {

/** From an alt number associated with artificial Tokens rule, return
*  the name of the token that is associated with that alt.
-	 */
+	 */
public String getTokenNameForTokensRuleAlt(int alt) {
NFAState decisionState = dfa.getNFADecisionStartState();
NFAState altState =
diff --git a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
index 543ab2b..dd1d56c 100644
--- a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
+++ b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
@@ -74,7 +74,7 @@ public class NFAToDFAConverter {
}

public void convert() {
-		//dfa.conversionStartTime = System.currentTimeMillis();
+		dfa.conversionStartTime = System.currentTimeMillis();

// create the DFA start state
dfa.startState = computeStartState();
@@ -601,13 +601,13 @@ public class NFAToDFAConverter {
);
}

-//		if ( DFA.MAX_TIME_PER_DFA_CREATION>0 &&
-//			 System.currentTimeMillis() - d.dfa.conversionStartTime >=
-//			 DFA.MAX_TIME_PER_DFA_CREATION )
-//		{
-//			// bail way out; we've blown up somehow
-//			throw new AnalysisTimeoutException(d.dfa);
-//		}
+		if ( DFA.MAX_TIME_PER_DFA_CREATION>0 &&
+			 System.currentTimeMillis() - d.dfa.conversionStartTime >=
+			 DFA.MAX_TIME_PER_DFA_CREATION )
+		{
+			// bail way out; we've blown up somehow
+			throw new AnalysisTimeoutException(d.dfa);
+		}

NFAConfiguration proposedNFAConfiguration =
new NFAConfiguration(p.stateNumber,
diff --git a/tool/src/main/java/org/antlr/tool/Grammar.java b/tool/src/main/java/org/antlr/tool/Grammar.java
index 2d4ef6e..912f7f1 100644
--- a/tool/src/main/java/org/antlr/tool/Grammar.java
+++ b/tool/src/main/java/org/antlr/tool/Grammar.java
@@ -1315,6 +1315,7 @@ outer:
// Retry to create a simpler DFA if analysis failed (non-LL(*),
// recursion overflow, or time out).
boolean failed =
+			lookaheadDFA.analysisTimedOut() ||
lookaheadDFA.probe.isNonLLStarDecision() ||
lookaheadDFA.probe.analysisOverflowed();
if ( failed && lookaheadDFA.okToRetryDFAWithK1() ) {
@@ -1331,6 +1332,11 @@ outer:
lookaheadDFA = null; // make sure other memory is "free" before redoing
lookaheadDFA = new DFA(decision, decisionStartState);
}
+		if ( lookaheadDFA.analysisTimedOut() ) { // did analysis bug out?
+			ErrorManager.internalError("could not even do k=1 for decision "+
+									   decision+"; reason: "+
+									   lookaheadDFA.getReasonForFailure());
+		}

setLookaheadDFA(decision, lookaheadDFA);


