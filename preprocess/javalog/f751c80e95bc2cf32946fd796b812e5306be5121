commit f751c80e95bc2cf32946fd796b812e5306be5121
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Thu Dec 13 14:04:25 2012 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Thu Dec 13 14:04:25 2012 -0600

Updated documentation for stream interfaces and classes

diff --git a/runtime/Java/src/main/java/org/antlr/runtime/misc/FastQueue.java b/runtime/Java/src/main/java/org/antlr/runtime/misc/FastQueue.java
index e5b146b..aec154d 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/misc/FastQueue.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/misc/FastQueue.java
@@ -71,9 +71,10 @@ public class FastQueue<T> {

public T head() { return elementAt(0); }

-    /** Return element i elements ahead of current element.  i==0 gets
-     *  current element.  This is not an absolute index into the data list
-     *  since p defines the start of the real list.
+    /**
+     * Return element {@code i} elements ahead of current element. {@code i==0}
+     * gets current element. This is not an absolute index into {@link #data}
+     * since {@code p} defines the start of the real list.
*/
public T elementAt(int i) {
int absIndex = p + i;
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java b/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java
index 205d125..580316d 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java
@@ -29,19 +29,23 @@ package org.antlr.runtime.misc;

import java.util.NoSuchElementException;

-/** A lookahead queue that knows how to mark/release locations
- *  in the buffer for backtracking purposes. Any markers force the FastQueue
- *  superclass to keep all tokens until no more markers; then can reset
- *  to avoid growing a huge buffer.
+/**
+ * A lookahead queue that knows how to mark/release locations in the buffer for
+ * backtracking purposes. Any markers force the {@link FastQueue} superclass to
+ * keep all elements until no more markers; then can reset to avoid growing a
+ * huge buffer.
*/
public abstract class LookaheadStream<T> extends FastQueue<T> {
public static final int UNINITIALIZED_EOF_ELEMENT_INDEX = Integer.MAX_VALUE;

/** Absolute token index. It's the index of the symbol about to be
-	 *  read via LT(1). Goes from 0 to numtokens.
+	 *  read via {@code LT(1)}. Goes from 0 to numtokens.
*/
protected int currentElementIndex = 0;

+    /**
+     * This is the {@code LT(-1)} element for the first element in {@link #data}.
+     */
protected T prevElement;

/** Track object returned by nextElement upon end of stream;
@@ -60,18 +64,21 @@ public abstract class LookaheadStream<T> extends FastQueue<T> {
super.reset();
currentElementIndex = 0;
p = 0;
-        prevElement=null;
+        prevElement = null;
}

/** Implement nextElement to supply a stream of elements to this
-     *  lookahead buffer.  Return eof upon end of the stream we're pulling from.
+     *  lookahead buffer.  Return EOF upon end of the stream we're pulling from.
+     *
+     * @see #isEOF
*/
public abstract T nextElement();

public abstract boolean isEOF(T o);

-    /** Get and remove first element in queue; override FastQueue.remove();
-     *  it's the same, just checks for backtracking.
+    /**
+     * Get and remove first element in queue; override
+     * {@link FastQueue#remove()}; it's the same, just checks for backtracking.
*/
@Override
public T remove() {
@@ -79,7 +86,7 @@ public abstract class LookaheadStream<T> extends FastQueue<T> {
p++;
// have we hit end of buffer and not backtracking?
if ( p == data.size() && markDepth==0 ) {
-          prevElement = o;
+            prevElement = o;
// if so, it's an opportunity to start filling at index 0 again
clear(); // size goes to 0, but retains memory
}
@@ -111,7 +118,7 @@ public abstract class LookaheadStream<T> extends FastQueue<T> {
}
}

-    /** Size of entire stream is unknown; we only know buffer size from FastQueue */
+    /** Size of entire stream is unknown; we only know buffer size from FastQueue. */
@Override
public int size() { throw new UnsupportedOperationException("streams are of unknown size"); }

@@ -152,11 +159,10 @@ public abstract class LookaheadStream<T> extends FastQueue<T> {
p = lastMarker;
}

-    /** Seek to a 0-indexed position within data buffer.  Can't handle
-     *  case where you seek beyond end of existing buffer.  Normally used
-     *  to seek backwards in the buffer. Does not force loading of nodes.
-     *  Doesn't see to absolute position in input stream since this stream
-     *  is unbuffered. Seeks only into our moving window of elements.
+    /**
+     * Seek to a 0-indexed absolute token index. This method can only be used to
+     * seek within the current data buffer. Normally used to seek backwards in
+     * the buffer. Does not force loading of nodes.
*/
public void seek(int index) {
int delta = currentElementIndex - index;
@@ -178,4 +184,4 @@ public abstract class LookaheadStream<T> extends FastQueue<T> {
}
throw new NoSuchElementException("can't look backwards past the beginning of this stream's buffer");
}
-}
\ No newline at end of file
+}
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java
index c55f6b1..f6c0c14 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java
@@ -39,19 +39,19 @@ public class CommonTreeNodeStream extends LookaheadStream<Object> implements Tre
/** Pull nodes from which tree? */
protected Object root;

-	/** If this tree (root) was created from a token stream, track it. */
+	/** If this tree (root) was created from a {@link TokenStream}, track it. */
protected TokenStream tokens;

-	/** What tree adaptor was used to build these trees */
+	/** What {@link TreeAdaptor} was used to build these trees */
TreeAdaptor adaptor;

-    /** The tree iterator we using */
+    /** The {@link TreeIterator} we using. */
protected TreeIterator it;

-    /** Stack of indexes used for push/pop calls */
+    /** Stack of indexes used for push/pop calls. */
protected IntArray calls;

-    /** Tree (nil A B C) trees like flat A B C streams */
+    /** Tree {@code (nil A B C)} trees like flat {@code A B C} streams */
protected boolean hasNilRoot = false;

/** Tracks tree depth.  Level=0 means we're at root node level. */
@@ -138,7 +138,7 @@ public class CommonTreeNodeStream extends LookaheadStream<Object> implements Tre
seek(index);
}

-    /** Seek back to previous index saved during last push() call.
+    /** Seek back to previous index saved during last {@link #push} call.
*  Return top of stack (return index).
*/
public int pop() {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java
index df0ad34..bde9ef5 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java
@@ -28,26 +28,28 @@
package org.antlr.runtime.tree;

import org.antlr.runtime.IntStream;
+import org.antlr.runtime.Token;
import org.antlr.runtime.TokenStream;

/** A stream of tree nodes, accessing nodes from a tree of some kind */
public interface TreeNodeStream extends IntStream {
-	/** Get a tree node at an absolute index i; 0..n-1.
+	/** Get a tree node at an absolute index {@code i}; 0..n-1.
*  If you don't want to buffer up nodes, then this method makes no
*  sense for you.
*/
public Object get(int i);

-	/** Get tree node at current input pointer + i ahead where i=1 is next node.
-	 *  i<0 indicates nodes in the past.  So LT(-1) is previous node, but
-	 *  implementations are not required to provide results for k < -1.
-	 *  LT(0) is undefined.  For i>=n, return null.
-	 *  Return null for LT(0) and any index that results in an absolute address
-	 *  that is negative.
-	 *
-	 *  This is analogus to the LT() method of the TokenStream, but this
-	 *  returns a tree node instead of a token.  Makes code gen identical
-	 *  for both parser and tree grammars. :)
+	/**
+	 * Get tree node at current input pointer + {@code k} ahead where
+	 * {@code k==1} is next node. {@code k<0} indicates nodes in the past. So
+	 * {@code LT(-1)} is previous node, but implementations are not required to
+	 * provide results for {@code k < -1}. {@code LT(0)} is undefined. For
+	 * {@code k<=n}, return {@code null}. Return {@code null} for {@code LT(0)}
+	 * and any index that results in an absolute address that is negative.
+	 * <p/>
+	 * This is analogous to {@link TokenStream#LT}, but this returns a tree node
+	 * instead of a {@link Token}. Makes code generation identical for both
+	 * parser and tree grammars.
*/
public Object LT(int k);

@@ -56,10 +58,12 @@ public interface TreeNodeStream extends IntStream {
*/
public Object getTreeSource();

-	/** If the tree associated with this stream was created from a TokenStream,
-	 *  you can specify it here.  Used to do rule $text attribute in tree
-	 *  parser.  Optional unless you use tree parser rule text attribute
-	 *  or output=template and rewrite=true options.
+	/**
+	 * If the tree associated with this stream was created from a
+	 * {@link TokenStream}, you can specify it here. Used to do rule
+	 * {@code $text} attribute in tree parser. Optional unless you use tree
+	 * parser rule {@code $text} attribute or {@code output=template} and
+	 * {@code rewrite=true} options.
*/
public TokenStream getTokenStream();

@@ -68,11 +72,12 @@ public interface TreeNodeStream extends IntStream {
*/
public TreeAdaptor getTreeAdaptor();

-	/** As we flatten the tree, we use UP, DOWN nodes to represent
-	 *  the tree structure.  When debugging we need unique nodes
-	 *  so we have to instantiate new ones.  When doing normal tree
-	 *  parsing, it's slow and a waste of memory to create unique
-	 *  navigation nodes.  Default should be false;
+	/**
+	 * As we flatten the tree, we use {@link Token#UP}, {@link Token#DOWN} nodes
+	 * to represent the tree structure. When debugging we need unique nodes so
+	 * we have to instantiate new ones. When doing normal tree parsing, it's
+	 * slow and a waste of memory to create unique navigation nodes. Default
+	 * should be {@code false}.
*/
public void setUniqueNavigationNodes(boolean uniqueNavigationNodes);

@@ -81,26 +86,28 @@ public interface TreeNodeStream extends IntStream {
*/
public void reset();

-	/** Return the text of all nodes from start to stop, inclusive.
-	 *  If the stream does not buffer all the nodes then it can still
-	 *  walk recursively from start until stop.  You can always return
-	 *  null or "" too, but users should not access $ruleLabel.text in
-	 *  an action of course in that case.
+	/**
+	 * Return the text of all nodes from {@code start} to {@code stop},
+	 * inclusive. If the stream does not buffer all the nodes then it can still
+	 * walk recursively from start until stop. You can always return
+	 * {@code null} or {@code ""} too, but users should not access
+	 * {@code $ruleLabel.text} in an action of course in that case.
*/
public String toString(Object start, Object stop);

-
// REWRITING TREES (used by tree parser)

-	/** Replace from start to stop child index of parent with t, which might
-	 *  be a list.  Number of children may be different
-	 *  after this call.  The stream is notified because it is walking the
-	 *  tree and might need to know you are monkeying with the underlying
-	 *  tree.  Also, it might be able to modify the node stream to avoid
-	 *  restreaming for future phases.
-	 *
-	 *  If parent is null, don't do anything; must be at root of overall tree.
-	 *  Can't replace whatever points to the parent externally.  Do nothing.
+	/**
+	 * Replace children of {@code parent} from index {@code startChildIndex} to
+	 * {@code stopChildIndex} with {@code t}, which might be a list. Number of
+	 * children may be different after this call. The stream is notified because
+	 * it is walking the tree and might need to know you are monkeying with the
+	 * underlying tree. Also, it might be able to modify the node stream to
+	 * avoid restreaming for future phases.
+	 * <p/>
+	 * If {@code parent} is {@code null}, don't do anything; must be at root of
+	 * overall tree. Can't replace whatever points to the parent externally. Do
+	 * nothing.
*/
public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t);
}

