commit 0cbef226ba32b1b4aafd76f4e4834139a2e12640
Author:     acondit <acondit@parrt.spork>
AuthorDate: Wed Jan 25 21:43:05 2012 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Wed Jan 25 21:43:05 2012 -0800

Deleting old versions of files

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 9899]

diff --git a/runtime/ObjC/Framework/FastQueue.h b/runtime/ObjC/Framework/FastQueue.h
deleted file mode 100644
index 25f34d6..0000000
--- a/runtime/ObjC/Framework/FastQueue.h
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.antlr.runtime.misc;
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.NoSuchElementException;
-
-/** A queue that can dequeue and get(i) in O(1) and grow arbitrarily large.
- *  A linked list is fast at dequeue but slow at get(i).  An array is
- *  the reverse.  This is O(1) for both operations.
- *
- *  List grows until you dequeue last element at end of buffer. Then
- *  it resets to start filling at 0 again.  If adds/removes are balanced, the
- *  buffer will not grow too large.
- *
- *  No iterator stuff as that's not how we'll use it.
- */
-public class FastQueue<T> {
-    /** dynamically-sized buffer of elements */
-    protected List<T> data = new ArrayList<T>();
-    /** index of next element to fill */
-    protected int p = 0;
-
-    public void reset() { p = 0; data.clear(); }
-
-    /** Get and remove first element in queue */
-    public T remove() {
-        T o = get(0);
-        p++;
-        // have we hit end of buffer?
-        if ( p == data.size() ) {
-            // if so, it's an opportunity to start filling at index 0 again
-            clear(); // size goes to 0, but retains memory
-        }
-        return o;
-    }
-
-    public void add(T o) { data.add(o); }
-
-    public int size() { return data.size() - p; }
-
-    public T head() { return get(0); }
-
-    /** Return element i elements ahead of current element.  i==0 gets
-     *  current element.  This is not an absolute index into the data list
-     *  since p defines the start of the real list.
-     */
-    public T get(int i) {
-        if ( p+i >= data.size() ) {
-            throw new NoSuchElementException("queue index "+(p+i)+" > size "+data.size());
-        }
-        return data.get(p+i);
-    }
-
-    public void clear() { p = 0; data.clear(); }
-
-    /** Return string of current buffer contents; non-destructive */
-    public String toString() {
-        StringBuffer buf = new StringBuffer();
-        int n = size();
-        for (int i=0; i<n; i++) {
-            buf.append(get(i));
-            if ( (i+1)<n ) buf.append(" ");
-        }
-        return buf.toString();
-    }
-}
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/FastQueue.m b/runtime/ObjC/Framework/FastQueue.m
deleted file mode 100644
index 25f34d6..0000000
--- a/runtime/ObjC/Framework/FastQueue.m
+++ /dev/null
@@ -1,93 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.antlr.runtime.misc;
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.NoSuchElementException;
-
-/** A queue that can dequeue and get(i) in O(1) and grow arbitrarily large.
- *  A linked list is fast at dequeue but slow at get(i).  An array is
- *  the reverse.  This is O(1) for both operations.
- *
- *  List grows until you dequeue last element at end of buffer. Then
- *  it resets to start filling at 0 again.  If adds/removes are balanced, the
- *  buffer will not grow too large.
- *
- *  No iterator stuff as that's not how we'll use it.
- */
-public class FastQueue<T> {
-    /** dynamically-sized buffer of elements */
-    protected List<T> data = new ArrayList<T>();
-    /** index of next element to fill */
-    protected int p = 0;
-
-    public void reset() { p = 0; data.clear(); }
-
-    /** Get and remove first element in queue */
-    public T remove() {
-        T o = get(0);
-        p++;
-        // have we hit end of buffer?
-        if ( p == data.size() ) {
-            // if so, it's an opportunity to start filling at index 0 again
-            clear(); // size goes to 0, but retains memory
-        }
-        return o;
-    }
-
-    public void add(T o) { data.add(o); }
-
-    public int size() { return data.size() - p; }
-
-    public T head() { return get(0); }
-
-    /** Return element i elements ahead of current element.  i==0 gets
-     *  current element.  This is not an absolute index into the data list
-     *  since p defines the start of the real list.
-     */
-    public T get(int i) {
-        if ( p+i >= data.size() ) {
-            throw new NoSuchElementException("queue index "+(p+i)+" > size "+data.size());
-        }
-        return data.get(p+i);
-    }
-
-    public void clear() { p = 0; data.clear(); }
-
-    /** Return string of current buffer contents; non-destructive */
-    public String toString() {
-        StringBuffer buf = new StringBuffer();
-        int n = size();
-        for (int i=0; i<n; i++) {
-            buf.append(get(i));
-            if ( (i+1)<n ) buf.append(" ");
-        }
-        return buf.toString();
-    }
-}
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/IntArray.h b/runtime/ObjC/Framework/IntArray.h
deleted file mode 100644
index a075770..0000000
--- a/runtime/ObjC/Framework/IntArray.h
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.antlr.runtime.misc;
-
-/** A dynamic array that uses int not Integer objects. In principle this
- *  is more efficient in time, but certainly in space.
- *
- *  This is simple enough that you can access the data array directly,
- *  but make sure that you append elements only with add() so that you
- *  get dynamic sizing.  Make sure to call ensureCapacity() when you are
- *  manually adding new elements.
- *
- *  Doesn't impl List because it doesn't return objects and I mean this
- *  really as just an array not a List per se.  Manipulate the elements
- *  at will.  This has stack methods too.
- *
- *  When runtime can be 1.5, I'll make this generic.
- */
-public class IntArray {
-	public static final int INITIAL_SIZE = 10;
-	public int[] data;
-	protected int p = -1;
-
-	public void add(int v) {
-		ensureCapacity(p+1);
-		data[++p] = v;
-	}
-
-	public void push(int v) {
-		add(v);
-	}
-
-	public int pop() {
-		int v = data[p];
-		p--;
-		return v;
-	}
-
-	/** This only tracks elements added via push/add. */
-	public int size() {
-		return p;
-	}
-
-    public void clear() {
-        p = -1;
-    }
-
-    public void ensureCapacity(int index) {
-		if ( data==null ) {
-			data = new int[INITIAL_SIZE];
-		}
-		else if ( (index+1)>=data.length ) {
-			int newSize = data.length*2;
-			if ( index>newSize ) {
-				newSize = index+1;
-			}
-			int[] newData = new int[newSize];
-			System.arraycopy(data, 0, newData, 0, data.length);
-			data = newData;
-		}
-	}
-}
diff --git a/runtime/ObjC/Framework/IntArray.m b/runtime/ObjC/Framework/IntArray.m
deleted file mode 100644
index a075770..0000000
--- a/runtime/ObjC/Framework/IntArray.m
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- [The "BSD licence"]
- Copyright (c) 2005-2008 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.antlr.runtime.misc;
-
-/** A dynamic array that uses int not Integer objects. In principle this
- *  is more efficient in time, but certainly in space.
- *
- *  This is simple enough that you can access the data array directly,
- *  but make sure that you append elements only with add() so that you
- *  get dynamic sizing.  Make sure to call ensureCapacity() when you are
- *  manually adding new elements.
- *
- *  Doesn't impl List because it doesn't return objects and I mean this
- *  really as just an array not a List per se.  Manipulate the elements
- *  at will.  This has stack methods too.
- *
- *  When runtime can be 1.5, I'll make this generic.
- */
-public class IntArray {
-	public static final int INITIAL_SIZE = 10;
-	public int[] data;
-	protected int p = -1;
-
-	public void add(int v) {
-		ensureCapacity(p+1);
-		data[++p] = v;
-	}
-
-	public void push(int v) {
-		add(v);
-	}
-
-	public int pop() {
-		int v = data[p];
-		p--;
-		return v;
-	}
-
-	/** This only tracks elements added via push/add. */
-	public int size() {
-		return p;
-	}
-
-    public void clear() {
-        p = -1;
-    }
-
-    public void ensureCapacity(int index) {
-		if ( data==null ) {
-			data = new int[INITIAL_SIZE];
-		}
-		else if ( (index+1)>=data.length ) {
-			int newSize = data.length*2;
-			if ( index>newSize ) {
-				newSize = index+1;
-			}
-			int[] newData = new int[newSize];
-			System.arraycopy(data, 0, newData, 0, data.length);
-			data = newData;
-		}
-	}
-}
diff --git a/runtime/ObjC/Framework/LookaheadStream.h b/runtime/ObjC/Framework/LookaheadStream.h
deleted file mode 100644
index 097d7a9..0000000
--- a/runtime/ObjC/Framework/LookaheadStream.h
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.antlr.runtime.misc;
-
-import java.util.List;
-import java.util.ArrayList;
-
-/** A lookahead queue that knows how to mark/release locations
- *  in the buffer for backtracking purposes. Any markers force the FastQueue
- *  superclass to keep all tokens until no more markers; then can reset
- *  to avoid growing a huge buffer.
- */
-public abstract class LookaheadStream<T> extends FastQueue<T> {
-    public static final int UNINITIALIZED_EOF_ELEMENT_INDEX = Integer.MAX_VALUE;
-
-    /** Set to buffer index of eof when nextElement returns eof */
-    protected int eofElementIndex = UNINITIALIZED_EOF_ELEMENT_INDEX;
-
-    /** Returned by nextElement upon end of stream; we add to buffer also */
-    public T eof = null;
-
-    /** Track the last mark() call result value for use in rewind(). */
-    protected int lastMarker;
-
-    /** tracks how deep mark() calls are nested */
-    protected int markDepth = 0;
-
-    public LookaheadStream(T eof) {
-        this.eof = eof;
-    }
-
-    public void reset() {
-        eofElementIndex = UNINITIALIZED_EOF_ELEMENT_INDEX;
-        super.reset();
-    }
-
-    /** Implement nextElement to supply a stream of elements to this
-     *  lookahead buffer.  Return eof upon end of the stream we're pulling from.
-     */
-    public abstract T nextElement();
-
-    /** Get and remove first element in queue; override FastQueue.remove() */
-    public T remove() {
-        T o = get(0);
-        p++;
-        // have we hit end of buffer and not backtracking?
-        if ( p == data.size() && markDepth==0 ) {
-            // if so, it's an opportunity to start filling at index 0 again
-            clear(); // size goes to 0, but retains memory
-        }
-        return o;
-    }
-
-    /** Make sure we have at least one element to remove, even if EOF */
-    public void consume() { sync(1); remove(); }
-
-    /** Make sure we have 'need' elements from current position p. Last valid
-     *  p index is data.size()-1.  p+need-1 is the data index 'need' elements
-     *  ahead.  If we need 1 element, (p+1-1)==p must be < data.size().
-     */
-    public void sync(int need) {
-        int n = (p+need-1) - data.size() + 1; // how many more elements we need?
-        if ( n > 0 ) fill(n);                 // out of elements?
-    }
-
-    /** add n elements to buffer */
-    public void fill(int n) {
-        for (int i=1; i<=n; i++) {
-            T o = nextElement();
-            if ( o==eof ) {
-                data.add(eof);
-                eofElementIndex = data.size()-1;
-            }
-            else data.add(o);
-        }
-    }
-
-    //public boolean hasNext() { return eofElementIndex!=UNINITIALIZED_EOF_ELEMENT_INDEX; }
-
-    /** Size of entire stream is unknown; we only know buffer size from FastQueue */
-    public int size() { throw new UnsupportedOperationException("streams are of unknown size"); }
-
-    public Object LT(int k) {
-		if ( k==0 ) {
-			return null;
-		}
-		if ( k<0 ) {
-			return LB(-k);
-		}
-		//System.out.print("LT(p="+p+","+k+")=");
-		if ( (p+k-1) >= eofElementIndex ) { // move to super.LT
-			return eof;
-		}
-        sync(k);
-        return get(k-1);
-	}
-
-	/** Look backwards k nodes */
-	protected Object LB(int k) {
-		if ( k==0 ) {
-			return null;
-		}
-		if ( (p-k)<0 ) {
-			return null;
-		}
-		return get(-k);
-	}
-
-    public Object getCurrentSymbol() { return LT(1); }
-
-    public int index() { return p; }
-
-	public int mark() {
-        markDepth++;
-        lastMarker = index();
-        return lastMarker;
-	}
-
-	public void release(int marker) {
-		// no resources to release
-	}
-
-	public void rewind(int marker) {
-        markDepth--;
-        seek(marker); // assume marker is top
-        // release(marker); // waste of call; it does nothing in this class
-    }
-
-	public void rewind() {
-        seek(lastMarker); // rewind but do not release marker
-    }
-
-    /** Seek to a 0-indexed position within data buffer.  Can't handle
-     *  case where you seek beyond end of existing buffer.  Normally used
-     *  to seek backwards in the buffer. Does not force loading of nodes.
-     */
-    public void seek(int index) { p = index; }
-}
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/LookaheadStream.m b/runtime/ObjC/Framework/LookaheadStream.m
deleted file mode 100644
index 097d7a9..0000000
--- a/runtime/ObjC/Framework/LookaheadStream.m
+++ /dev/null
@@ -1,163 +0,0 @@
-/*
-[The "BSD licence"]
-Copyright (c) 2005-2008 Terence Parr
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without
-modification, are permitted provided that the following conditions
-are met:
-1. Redistributions of source code must retain the above copyright
-notice, this list of conditions and the following disclaimer.
-2. Redistributions in binary form must reproduce the above copyright
-notice, this list of conditions and the following disclaimer in the
-documentation and/or other materials provided with the distribution.
-3. The name of the author may not be used to endorse or promote products
-derived from this software without specific prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-package org.antlr.runtime.misc;
-
-import java.util.List;
-import java.util.ArrayList;
-
-/** A lookahead queue that knows how to mark/release locations
- *  in the buffer for backtracking purposes. Any markers force the FastQueue
- *  superclass to keep all tokens until no more markers; then can reset
- *  to avoid growing a huge buffer.
- */
-public abstract class LookaheadStream<T> extends FastQueue<T> {
-    public static final int UNINITIALIZED_EOF_ELEMENT_INDEX = Integer.MAX_VALUE;
-
-    /** Set to buffer index of eof when nextElement returns eof */
-    protected int eofElementIndex = UNINITIALIZED_EOF_ELEMENT_INDEX;
-
-    /** Returned by nextElement upon end of stream; we add to buffer also */
-    public T eof = null;
-
-    /** Track the last mark() call result value for use in rewind(). */
-    protected int lastMarker;
-
-    /** tracks how deep mark() calls are nested */
-    protected int markDepth = 0;
-
-    public LookaheadStream(T eof) {
-        this.eof = eof;
-    }
-
-    public void reset() {
-        eofElementIndex = UNINITIALIZED_EOF_ELEMENT_INDEX;
-        super.reset();
-    }
-
-    /** Implement nextElement to supply a stream of elements to this
-     *  lookahead buffer.  Return eof upon end of the stream we're pulling from.
-     */
-    public abstract T nextElement();
-
-    /** Get and remove first element in queue; override FastQueue.remove() */
-    public T remove() {
-        T o = get(0);
-        p++;
-        // have we hit end of buffer and not backtracking?
-        if ( p == data.size() && markDepth==0 ) {
-            // if so, it's an opportunity to start filling at index 0 again
-            clear(); // size goes to 0, but retains memory
-        }
-        return o;
-    }
-
-    /** Make sure we have at least one element to remove, even if EOF */
-    public void consume() { sync(1); remove(); }
-
-    /** Make sure we have 'need' elements from current position p. Last valid
-     *  p index is data.size()-1.  p+need-1 is the data index 'need' elements
-     *  ahead.  If we need 1 element, (p+1-1)==p must be < data.size().
-     */
-    public void sync(int need) {
-        int n = (p+need-1) - data.size() + 1; // how many more elements we need?
-        if ( n > 0 ) fill(n);                 // out of elements?
-    }
-
-    /** add n elements to buffer */
-    public void fill(int n) {
-        for (int i=1; i<=n; i++) {
-            T o = nextElement();
-            if ( o==eof ) {
-                data.add(eof);
-                eofElementIndex = data.size()-1;
-            }
-            else data.add(o);
-        }
-    }
-
-    //public boolean hasNext() { return eofElementIndex!=UNINITIALIZED_EOF_ELEMENT_INDEX; }
-
-    /** Size of entire stream is unknown; we only know buffer size from FastQueue */
-    public int size() { throw new UnsupportedOperationException("streams are of unknown size"); }
-
-    public Object LT(int k) {
-		if ( k==0 ) {
-			return null;
-		}
-		if ( k<0 ) {
-			return LB(-k);
-		}
-		//System.out.print("LT(p="+p+","+k+")=");
-		if ( (p+k-1) >= eofElementIndex ) { // move to super.LT
-			return eof;
-		}
-        sync(k);
-        return get(k-1);
-	}
-
-	/** Look backwards k nodes */
-	protected Object LB(int k) {
-		if ( k==0 ) {
-			return null;
-		}
-		if ( (p-k)<0 ) {
-			return null;
-		}
-		return get(-k);
-	}
-
-    public Object getCurrentSymbol() { return LT(1); }
-
-    public int index() { return p; }
-
-	public int mark() {
-        markDepth++;
-        lastMarker = index();
-        return lastMarker;
-	}
-
-	public void release(int marker) {
-		// no resources to release
-	}
-
-	public void rewind(int marker) {
-        markDepth--;
-        seek(marker); // assume marker is top
-        // release(marker); // waste of call; it does nothing in this class
-    }
-
-	public void rewind() {
-        seek(lastMarker); // rewind but do not release marker
-    }
-
-    /** Seek to a 0-indexed position within data buffer.  Can't handle
-     *  case where you seek beyond end of existing buffer.  Normally used
-     *  to seek backwards in the buffer. Does not force loading of nodes.
-     */
-    public void seek(int index) { p = index; }
-}
\ No newline at end of file

