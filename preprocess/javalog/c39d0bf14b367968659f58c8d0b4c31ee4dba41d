commit c39d0bf14b367968659f58c8d0b4c31ee4dba41d
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Wed Dec 12 01:40:02 2012 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Wed Dec 12 01:41:17 2012 -0600

Add a new error type for errors reported by StringTemplate. Missing attributes or properties are warnings, others are errors.

diff --git a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
index f783bae..f7524d5 100644
--- a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
+++ b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
@@ -183,35 +183,29 @@ public class CodeGenerator {
/** load the main language.stg template group file */
public void loadTemplates(String language) {
String langDir = classpathTemplateRootDirectoryName+"/"+language;
-		STGroup coreTemplates = new STGroupFile(langDir+"/"+language+".stg");
-
+		STGroup coreTemplates = new ToolSTGroupFile(langDir+"/"+language+".stg");
baseTemplates = coreTemplates;
-		if ( coreTemplates ==null ) {
-			ErrorManager.error(ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES,
-							   language);
-			return;
-		}

// dynamically add subgroups that act like filters to apply to
// their supergroup.  E.g., Java:Dbg:AST:ASTParser::ASTDbg.
String outputOption = (String)grammar.getOption("output");
if ( outputOption!=null && outputOption.equals("AST") ) {
if ( debug && grammar.type!=Grammar.LEXER ) {
-				STGroup dbgTemplates = new STGroupFile(langDir+"/Dbg.stg");
+				STGroup dbgTemplates = new ToolSTGroupFile(langDir+"/Dbg.stg");
dbgTemplates.importTemplates(coreTemplates);
baseTemplates = dbgTemplates;
-				STGroup astTemplates = new STGroupFile(langDir+"/AST.stg");
+				STGroup astTemplates = new ToolSTGroupFile(langDir+"/AST.stg");
astTemplates.importTemplates(dbgTemplates);
STGroup astParserTemplates;
if ( grammar.type==Grammar.TREE_PARSER ) {
-					astParserTemplates = new STGroupFile(langDir+"/ASTTreeParser.stg");
+					astParserTemplates = new ToolSTGroupFile(langDir+"/ASTTreeParser.stg");
astParserTemplates.importTemplates(astTemplates);
}
else {
-					astParserTemplates = new STGroupFile(langDir+"/ASTParser.stg");
+					astParserTemplates = new ToolSTGroupFile(langDir+"/ASTParser.stg");
astParserTemplates.importTemplates(astTemplates);
}
-				STGroup astDbgTemplates = new STGroupFile(langDir+"/ASTDbg.stg");
+				STGroup astDbgTemplates = new ToolSTGroupFile(langDir+"/ASTDbg.stg");
astDbgTemplates.importTemplates(astParserTemplates);
templates = astDbgTemplates;
dbgTemplates.iterateAcrossValues = true; // ST v3 compatibility with Maps
@@ -219,15 +213,15 @@ public class CodeGenerator {
astParserTemplates.iterateAcrossValues = true;
}
else {
-				STGroup astTemplates = new STGroupFile(langDir+"/AST.stg");
+				STGroup astTemplates = new ToolSTGroupFile(langDir+"/AST.stg");
astTemplates.importTemplates(coreTemplates);
STGroup astParserTemplates;
if ( grammar.type==Grammar.TREE_PARSER ) {
-					astParserTemplates = new STGroupFile(langDir+"/ASTTreeParser.stg");
+					astParserTemplates = new ToolSTGroupFile(langDir+"/ASTTreeParser.stg");
astParserTemplates.importTemplates(astTemplates);
}
else {
-					astParserTemplates = new STGroupFile(langDir+"/ASTParser.stg");
+					astParserTemplates = new ToolSTGroupFile(langDir+"/ASTParser.stg");
astParserTemplates.importTemplates(astTemplates);
}
templates = astParserTemplates;
@@ -237,23 +231,23 @@ public class CodeGenerator {
}
else if ( outputOption!=null && outputOption.equals("template") ) {
if ( debug && grammar.type!=Grammar.LEXER ) {
-				STGroup dbgTemplates = new STGroupFile(langDir+"/Dbg.stg");
+				STGroup dbgTemplates = new ToolSTGroupFile(langDir+"/Dbg.stg");
dbgTemplates.importTemplates(coreTemplates);
baseTemplates = dbgTemplates;
-				STGroup stTemplates = new STGroupFile(langDir+"/ST.stg");
+				STGroup stTemplates = new ToolSTGroupFile(langDir+"/ST.stg");
stTemplates.importTemplates(dbgTemplates);
templates = stTemplates;
dbgTemplates.iterateAcrossValues = true;
}
else {
-				STGroup stTemplates = new STGroupFile(langDir+"/ST.stg");
+				STGroup stTemplates = new ToolSTGroupFile(langDir+"/ST.stg");
stTemplates.importTemplates(coreTemplates);
templates = stTemplates;
}
templates.iterateAcrossValues = true; // ST v3 compatibility with Maps
}
else if ( debug && grammar.type!=Grammar.LEXER ) {
-			STGroup dbgTemplates = new STGroupFile(langDir+"/Dbg.stg");
+			STGroup dbgTemplates = new ToolSTGroupFile(langDir+"/Dbg.stg");
dbgTemplates.importTemplates(coreTemplates);
templates = dbgTemplates;
baseTemplates = templates;
diff --git a/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java b/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java
index fcb0d64..5c0fdbd 100644
--- a/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java
+++ b/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java
@@ -211,7 +211,7 @@ public class BuildDependencyGenerator {
public void loadDependencyTemplates() {
if (templates != null) return;
String fileName = "org/antlr/tool/templates/depend.stg";
-        templates = new STGroupFile(fileName);
+        templates = new ToolSTGroupFile(fileName);
}

public String getTokenVocab() {
diff --git a/tool/src/main/java/org/antlr/tool/ErrorManager.java b/tool/src/main/java/org/antlr/tool/ErrorManager.java
index e3e9eba..2e7737c 100644
--- a/tool/src/main/java/org/antlr/tool/ErrorManager.java
+++ b/tool/src/main/java/org/antlr/tool/ErrorManager.java
@@ -38,6 +38,7 @@ import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STErrorListener;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupFile;
+import org.stringtemplate.v4.misc.ErrorType;
import org.stringtemplate.v4.misc.STMessage;

import java.lang.reflect.Field;
@@ -117,6 +118,7 @@ public class ErrorManager {
public static final int MSG_CODE_GEN_TEMPLATES_INCOMPLETE = 22;
public static final int MSG_CANNOT_CREATE_TARGET_GENERATOR = 23;
//public static final int MSG_CANNOT_COMPUTE_SAMPLE_INPUT_SEQ = 24;
+	public static final int MSG_STRING_TEMPLATE_ERROR = 24;

// GRAMMAR ERRORS
public static final int MSG_SYNTAX_ERROR = 100;
@@ -376,22 +378,32 @@ public class ErrorManager {
new STErrorListener() {
@Override
public void compileTimeError(STMessage msg) {
-				ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, msg.toString(), msg.cause);
+				ErrorManager.error(ErrorManager.MSG_STRING_TEMPLATE_ERROR, msg.toString(), msg.cause);
}

@Override
public void runTimeError(STMessage msg) {
-				ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, msg.toString(), msg.cause);
+				switch (msg.error) {
+				case NO_SUCH_ATTRIBUTE:
+				case NO_SUCH_ATTRIBUTE_PASS_THROUGH:
+				case NO_SUCH_PROPERTY:
+					ErrorManager.warning(ErrorManager.MSG_STRING_TEMPLATE_ERROR, msg.toString());
+					return;
+
+				default:
+					ErrorManager.error(ErrorManager.MSG_STRING_TEMPLATE_ERROR, msg.toString(), msg.cause);
+					return;
+				}
}

@Override
public void IOError(STMessage msg) {
-				ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, msg.toString(), msg.cause);
+				ErrorManager.error(ErrorManager.MSG_STRING_TEMPLATE_ERROR, msg.toString(), msg.cause);
}

@Override
public void internalError(STMessage msg) {
-				ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, msg.toString(), msg.cause);
+				ErrorManager.error(ErrorManager.MSG_STRING_TEMPLATE_ERROR, msg.toString(), msg.cause);
}
};

diff --git a/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java b/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
index b4e579f..7422de2 100644
--- a/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
+++ b/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
@@ -42,7 +42,7 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {

public void loadPrecRuleTemplates() {
recRuleTemplates =
-			new STGroupFile(CodeGenerator.classpathTemplateRootDirectoryName+
+			new ToolSTGroupFile(CodeGenerator.classpathTemplateRootDirectoryName+
"/LeftRecursiveRules.stg");
if ( !recRuleTemplates.isDefined("recRuleName") ) {
ErrorManager.error(ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES,
diff --git a/tool/src/main/java/org/antlr/tool/ToolSTGroupFile.java b/tool/src/main/java/org/antlr/tool/ToolSTGroupFile.java
new file mode 100644
index 0000000..d20f813
--- /dev/null
+++ b/tool/src/main/java/org/antlr/tool/ToolSTGroupFile.java
@@ -0,0 +1,47 @@
+/*
+ * [The "BSD license"]
+ *  Copyright (c) 2012 Terence Parr
+ *  Copyright (c) 2012 Sam Harwell
+ *  All rights reserved.
+ *
+ *  Redistribution and use in source and binary forms, with or without
+ *  modification, are permitted provided that the following conditions
+ *  are met:
+ *  1. Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *  2. Redistributions in binary form must reproduce the above copyright
+ *      notice, this list of conditions and the following disclaimer in the
+ *      documentation and/or other materials provided with the distribution.
+ *  3. The name of the author may not be used to endorse or promote products
+ *      derived from this software without specific prior written permission.
+ *
+ *  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ *  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ *  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+package org.antlr.tool;
+
+import org.stringtemplate.v4.STErrorListener;
+import org.stringtemplate.v4.STGroupFile;
+
+/**
+ * This extension of {@link STGroupFile} automatically sets the group's
+ * {@link STErrorListener} to {@link ErrorManager#getSTErrorListener()}.
+ *
+ * @author Sam Harwell
+ */
+public class ToolSTGroupFile extends STGroupFile {
+
+	public ToolSTGroupFile(String fileName) {
+		super(fileName);
+		setListener(ErrorManager.getSTErrorListener());
+	}
+
+}
diff --git a/tool/src/main/resources/org/antlr/tool/templates/messages/languages/en.stg b/tool/src/main/resources/org/antlr/tool/templates/messages/languages/en.stg
index 7376ae8..b5e42d5 100644
--- a/tool/src/main/resources/org/antlr/tool/templates/messages/languages/en.stg
+++ b/tool/src/main/resources/org/antlr/tool/templates/messages/languages/en.stg
@@ -83,6 +83,8 @@ CODE_GEN_TEMPLATES_INCOMPLETE(arg) ::=
"at least one code generation template missing for language <arg>"
CANNOT_CREATE_TARGET_GENERATOR(arg,exception,stackTrace) ::=
"cannot create target <arg> code generator: <exception>"
+STRING_TEMPLATE_ERROR(arg,exception,stackTrace) ::=
+	"template error: <arg>"
CANNOT_COMPUTE_SAMPLE_INPUT_SEQ() ::=
"cannot generate a sample input sequence from lookahead DFA"


