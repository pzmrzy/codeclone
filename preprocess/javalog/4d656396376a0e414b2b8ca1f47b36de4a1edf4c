commit 4d656396376a0e414b2b8ca1f47b36de4a1edf4c
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Thu Dec 13 17:30:10 2012 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Thu Dec 13 18:00:43 2012 -0600

Clean up newlines and whitespace in templates

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
index b77f3f1..74aeba5 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
@@ -40,7 +40,8 @@ import org.antlr.runtime.tree.*;<\n>

/** Add an adaptor property that knows how to build trees */
parserMembers() ::= <<
-protected TreeAdaptor adaptor = new CommonTreeAdaptor();<\n>
+protected TreeAdaptor adaptor = new CommonTreeAdaptor();
+
public void setTreeAdaptor(TreeAdaptor adaptor) {
this.adaptor = adaptor;
<grammar.directDelegates:{g|<g:delegateName()>.setTreeAdaptor(this.adaptor);}>
@@ -170,7 +171,7 @@ rewriteCode(
// rule list labels: <referencedRuleListLabels; separator=", ">
// wildcard labels: <[referencedWildcardLabels,referencedWildcardListLabels]; separator=", ">
<if(backtracking)>
-if ( <actions.(actionScope).synpredgate> ) {<\n>
+if ( <actions.(actionScope).synpredgate> ) {
<endif>
<prevRuleRootRef()>.tree = root_0;
<rewriteCodeLabels()>
@@ -305,22 +306,22 @@ rewriteElement(e) ::= <<

/** Gen ID or ID[args] */
rewriteTokenRef(token,elementIndex,args,terminalOptions={}) ::= <<
-adaptor.addChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
+adaptor.addChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);
>>

/** Gen $label ... where defined via label=ID */
rewriteTokenLabelRef(label,elementIndex) ::= <<
-adaptor.addChild(root_<treeLevel>, stream_<label>.nextNode());<\n>
+adaptor.addChild(root_<treeLevel>, stream_<label>.nextNode());
>>

/** Gen $label ... where defined via label+=ID */
rewriteTokenListLabelRef(label,elementIndex) ::= <<
-adaptor.addChild(root_<treeLevel>, stream_<label>.nextNode());<\n>
+adaptor.addChild(root_<treeLevel>, stream_<label>.nextNode());
>>

/** Gen ^($label ...) */
rewriteTokenLabelRefRoot(label,elementIndex) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(stream_<label>.nextNode(), root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(stream_<label>.nextNode(), root_<treeLevel>);
>>

/** Gen ^($label ...) where label+=... */
@@ -328,20 +329,20 @@ rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot

/** Gen ^(ID ...) or ^(ID[args] ...) */
rewriteTokenRefRoot(token,elementIndex,args,terminalOptions={}) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);
>>

rewriteImaginaryTokenRef(args,token,elementIndex,terminalOptions={}) ::= <<
-adaptor.addChild(root_<treeLevel>, <createImaginaryNode(token,args,terminalOptions)>);<\n>
+adaptor.addChild(root_<treeLevel>, <createImaginaryNode(token,args,terminalOptions)>);
>>

rewriteImaginaryTokenRefRoot(args,token,elementIndex,terminalOptions={}) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<createImaginaryNode(token,args,terminalOptions)>, root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<createImaginaryNode(token,args,terminalOptions)>, root_<treeLevel>);
>>

/** plain -> {foo} action */
rewriteAction(action) ::= <<
-root_0 = <action>;<\n>
+root_0 = <action>;
>>

/** What is the name of the previous value of this rule's root tree?  This
@@ -352,56 +353,56 @@ root_0 = <action>;<\n>
prevRuleRootRef() ::= "retval"

rewriteRuleRef(rule) ::= <<
-adaptor.addChild(root_<treeLevel>, stream_<rule>.nextTree());<\n>
+adaptor.addChild(root_<treeLevel>, stream_<rule>.nextTree());
>>

rewriteRuleRefRoot(rule) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(stream_<rule>.nextNode(), root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(stream_<rule>.nextNode(), root_<treeLevel>);
>>

rewriteNodeAction(action) ::= <<
-adaptor.addChild(root_<treeLevel>, <action>);<\n>
+adaptor.addChild(root_<treeLevel>, <action>);
>>

rewriteNodeActionRoot(action) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<action>, root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<action>, root_<treeLevel>);
>>

/** Gen $ruleLabel ... where defined via ruleLabel=rule */
rewriteRuleLabelRef(label) ::= <<
-adaptor.addChild(root_<treeLevel>, stream_<label>.nextTree());<\n>
+adaptor.addChild(root_<treeLevel>, stream_<label>.nextTree());
>>

/** Gen $ruleLabel ... where defined via ruleLabel+=rule */
rewriteRuleListLabelRef(label) ::= <<
-adaptor.addChild(root_<treeLevel>, stream_<label>.nextTree());<\n>
+adaptor.addChild(root_<treeLevel>, stream_<label>.nextTree());
>>

/** Gen ^($ruleLabel ...) where ruleLabel=rule */
rewriteRuleLabelRefRoot(label) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(stream_<label>.nextNode(), root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(stream_<label>.nextNode(), root_<treeLevel>);
>>

/** Gen ^($ruleLabel ...) where ruleLabel+=rule */
rewriteRuleListLabelRefRoot(label) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(stream_<label>.nextNode(), root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(stream_<label>.nextNode(), root_<treeLevel>);
>>

rewriteWildcardLabelRef(label) ::= <<
-adaptor.addChild(root_<treeLevel>, stream_<label>.nextTree());<\n>
+adaptor.addChild(root_<treeLevel>, stream_<label>.nextTree());
>>


-createImaginaryNode(tokenType,args,terminalOptions={}) ::= <<
+createImaginaryNode(tokenType,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
<! new MethodNode(IDLabel, args) !>
new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
<else>
(<ASTLabelType>)adaptor.create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
<endif>
->>
+%>

-createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <<
+createRewriteNodeFromElement(token,args,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(stream_<token>.nextToken()<if(args)>, <args; separator=", "><endif>)
<else>
@@ -411,4 +412,4 @@ adaptor.create(<token>, <args; separator=", ">)
stream_<token>.nextNode()
<endif>
<endif>
->>
+%>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
index 1c322b5..470b966 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
@@ -182,13 +182,13 @@ root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_0);
<endif>
>>

-createNodeFromToken(label,terminalOptions={}) ::= <<
+createNodeFromToken(label,terminalOptions={}) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(<label>) <! new MethodNode(IDLabel) !>
<else>
(<ASTLabelType>)adaptor.create(<label>)
<endif>
->>
+%>

ruleCleanUp() ::= <<
<super.ruleCleanUp()>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
index 9e4575e..d7446a6 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
@@ -37,7 +37,7 @@ import java.io.IOException;
@genericParser.members() ::= <<
<if(grammar.grammarIsRoot)>
public static final String[] ruleNames = new String[] {
-		"invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n    ", separator=", ">
+		"invalidRule", <grammar.allImportedRules:{rST | "<rST.name>"}; wrap="\n\t\t", separator=", ">
};<\n>
<endif>
public static final boolean[] decisionCanBacktrack = new boolean[] {
@@ -55,7 +55,7 @@ import java.io.IOException;
<ctorForRootGrammar()>
<endif>
<ctorForPredefinedListener()>
-<else> <! imported grammar !>
+<else><! imported grammar !>
public int getRuleLevel() { return <grammar.delegators:{g| <g:delegateName()>}>.getRuleLevel(); }
public void incRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.incRuleLevel(); }
public void decRuleLevel() { <grammar.delegators:{g| <g:delegateName()>}>.decRuleLevel(); }
@@ -66,7 +66,8 @@ import java.io.IOException;
int stopIndex = getRuleMemoization(ruleIndex, input.index());
((Profiler)dbg).examineRuleMemoization(input, ruleIndex, stopIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames[ruleIndex]);
return super.alreadyParsedRule(input, ruleIndex);
-	}<\n>
+	}
+
public void memoize(IntStream input,
int ruleIndex,
int ruleStartIndex)
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
index 8146760..49b7982 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
@@ -108,7 +108,7 @@ public class <grammar.recognizerName> extends <@superClassName><superClass><@end
super(input,state);
<if(memoize)>
<if(grammar.grammarIsRoot)>
-		state.ruleMemo = new HashMap[<numRules>+1];<\n> <! index from 1..n !>
+		state.ruleMemo = new HashMap[<numRules>+1];<\n><! index from 1..n !>
<endif>
<endif>
<grammar.directDelegates:
@@ -205,8 +205,8 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
public class <grammar.recognizerName> extends <@superClassName><superClass><@end> {
<if(grammar.grammarIsRoot)>
public static final String[] tokenNames = new String[] {
-		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
-	};<\n>
+		"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ", wrap="\n\t\t">
+	};
<endif>
<tokens:{it |public static final int <it.name>=<it.type>;}; separator="\n">

@@ -264,7 +264,7 @@ public class <grammar.recognizerName> extends <@superClassName><superClass><@end
parserCtorBody() ::= <<
<if(memoize)>
<if(grammar.grammarIsRoot)>
-this.state.ruleMemo = new HashMap[<length(grammar.allImportedRules)>+1];<\n> <! index from 1..n !>
+this.state.ruleMemo = new HashMap[<length(grammar.allImportedRules)>+1];<\n><! index from 1..n !>
<endif>
<endif>
<grammar.delegators:
@@ -606,10 +606,9 @@ do {
default :
if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
<ruleBacktrackFailure()>
-			EarlyExitException eee =
-				new EarlyExitException(<decisionNumber>, input);
-			<@earlyExitException()>
-			throw eee;
+		EarlyExitException eee = new EarlyExitException(<decisionNumber>, input);
+		<@earlyExitException()>
+		throw eee;
}
cnt<decisionNumber>++;
} while (true);
@@ -930,8 +929,9 @@ try {
wrapNvaExceptionForKN(exceptionCode) ::= <<
int nvaeMark = input.mark();
try {
-	for (int nvaeConsume = 0; nvaeConsume \< <k> - 1; nvaeConsume++)
+	for (int nvaeConsume = 0; nvaeConsume \< <k> - 1; nvaeConsume++) {
input.consume();
+	}
<exceptionCode>
} finally {
input.rewind(nvaeMark);

