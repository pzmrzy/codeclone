commit 4b88abfaa4f8cd1fe6b4ec5f919ae7f7b999f62b
Author:     parrt <parrt@antlr.org>
AuthorDate: Thu Apr 14 14:39:47 2011 -0800
Commit:     parrt <parrt@antlr.org>
CommitDate: Thu Apr 14 14:39:47 2011 -0800

push to edit at home

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8232]

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Ruby/Ruby.stg b/tool/src/main/resources/org/antlr/codegen/templates/Ruby/Ruby.stg
index 1e515b4..dd26c0b 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Ruby/Ruby.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Ruby/Ruby.stg
@@ -1,9 +1,17 @@
-group Ruby;
-
/******************************************************************************
*********************  M A J O R   C O M P O N E N T S  **********************
******************************************************************************/

+// System.Boolean.ToString() returns "True" and "False", but the proper C# literals are "true" and "false"
+// The Java version of Boolean returns "true" and "false", so they map to themselves here.
+booleanLiteral ::= [
+	"True":"true",
+	"False":"false",
+	"true":"true",
+	"false":"false",
+	default:"false"
+]
+
/** The overall file structure of a recognizer; stores methods
* for rules and cyclic DFAs plus support code.
*/
@@ -99,7 +107,7 @@ module TokenData
<if(tokens)>

# define the token constants
-  define_tokens( <tokens:{:<it.name> => <it.type>}; anchor, wrap="\n", separator=", "> )
+  define_tokens( <tokens:{it | :<it.name> => <it.type>}; anchor, wrap="\n", separator=", "> )

<endif>
<if(tokenNames)>
@@ -110,7 +118,7 @@ module TokenData
# this is necessary because anonymous tokens, which are
# created from literal values in the grammar, do not
# have descriptive names
-  register_names( <tokenNames:{<it>}; separator=", ", anchor, wrap="\n"> )
+  register_names( <tokenNames:{it | <it>}; separator=", ", anchor, wrap="\n"> )

<endif>

@@ -174,7 +182,7 @@ at_exit { <if(grammar.grammarIsRoot)>Parser<else><grammar.name><endif>.main( ARG
/** How to generate a tree parser; same as parser except the
* input stream is a different type.
*/
-treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules, numRules, bitsets, labelType={<ASTLabelType>}, ASTLabelType="Object", superClass="ANTLR3::TreeParser", members={<actions.treeparser.members>}, filterMode) ::= <<
+treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules, numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="Object", superClass="ANTLR3::TreeParser", members={<actions.treeparser.members>}) ::= <<
<if(grammar.grammarIsRoot)><autoloadDelegates()><endif>

class <if(grammar.grammarIsRoot)>TreeParser<else><grammar.name><endif> \< <superClass>
@@ -186,15 +194,15 @@ at_exit { <if(grammar.grammarIsRoot)>TreeParser<else><grammar.name><endif>.main(
<endif>
>>

-parserBody(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets, inputStreamType, superClass, filterMode, ASTLabelType="Object", labelType, members, rewriteElementType, actionScope) ::= <<
+parserBody(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets, inputStreamType, superClass, filterMode, labelType, members, rewriteElementType, actionScope, ASTLabelType="Object") ::= <<
@grammar_home = <grammar.name>
<if(!grammar.grammarIsRoot)><autoloadDelegates()><\n><endif>
<@mixins()>

RULE_METHODS = [ <rules:{r|:<r.ruleName>}; separator=", ", wrap="\n", anchor> ].freeze

-<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeClass(scope=it)><\n><endif>}>
-<rules:{<ruleAttributeScopeClass(scope=it.ruleDescriptor.ruleScope)>}>
+<scopes:{it | <if(it.isDynamicGlobalScope)><globalAttributeScopeClass()><\n><endif>}>
+<rules:{it | <ruleAttributeScopeClass(.ruleDescriptor.ruleScope)>}>
<if(grammar.delegators)>
masters( <grammar.delegators:{d|:<d.name>}; separator=", "> )<\n>
<endif>
@@ -218,7 +226,7 @@ include <grammar.composite.rootGrammar.name>::TokenData<\n><\n>
<@additionalMembers()>
<members>
# - - - - - - - - - - - - Rules - - - - - - - - - - - - -
-<rules:{<it><\n>}>
+<rules:{it | <it><\n>}>

<if(grammar.delegatedRules)>
# - - - - - - - - - - Delegated Rules - - - - - - - - - - -
@@ -226,17 +234,17 @@ include <grammar.composite.rootGrammar.name>::TokenData<\n><\n>
<endif>
<if(cyclicDFAs)>
# - - - - - - - - - - DFA definitions - - - - - - - - - - -
-<cyclicDFAs:{<cyclicDFA(it)>}>
+<cyclicDFAs:{it | <cyclicDFA(it)>}>

private

def initialize_dfas
super rescue nil
-  <cyclicDFAs:{<cyclicDFAInit(it)>}>
+  <cyclicDFAs:{it | <cyclicDFAInit(it)>}>
end

<endif>
-<bitsets:{TOKENS_FOLLOWING_<it.name>_IN_<it.inName>_<it.tokenIndex> = Set[ <it.tokenTypes:{<it>}; separator=", "> ]<\n>}>
+<bitsets:{it | TOKENS_FOLLOWING_<it.name>_IN_<it.inName>_<it.tokenIndex> = Set[ <it.tokenTypes:{it | <it>}; separator=", "> ]<\n>}>
>>

parserConstructor() ::= <<
@@ -245,7 +253,7 @@ def initialize( <grammar.delegators:{g|<g:delegateName()>, }>input, options = {}
<if(memoize)><if(grammar.grammarIsRoot)>
@state.rule_memory = {}
<endif><endif>
-  <scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeStack(scope=it)><\n><endif>}><rules:{<ruleAttributeScopeStack(scope=it.ruleDescriptor.ruleScope)>}>
+  <scopes:{it | <if(it.isDynamicGlobalScope)><globalAttributeScopeStack()><\n><endif>}><rules:{it | <ruleAttributeScopeStack(.ruleDescriptor.ruleScope)>}>
<placeAction(scope=actionScope,name="init")>
<grammar.delegators:{g|@<g:delegateName()> = <g:delegateName()><\n>}><grammar.directDelegates:{g|@<g:delegateName()> = <newDelegate(g)><\n>}><last(grammar.delegators):{g|@parent = @<g:delegateName()><\n>}><@init()>
end
@@ -272,7 +280,7 @@ synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::= <<
# This is an imaginary rule inserted by ANTLR to
# implement a syntactic predicate decision
#
-def <ruleName><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope(scope=it)> )<endif>
+def <ruleName><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope()> )<endif>
<traceIn()><ruleLabelDefs()>
<block>
ensure
@@ -293,7 +301,7 @@ rule(ruleName, ruleDescriptor, block, emptyRule, description, exceptions, finall
# (in <fileName>)
# <description>
#
-def <ruleName><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope(scope=it)> )<endif>
+def <ruleName><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope()> )<endif>
<traceIn()><ruleScopeSetUp()><ruleDeclarations()><ruleLabelDefs()><action(name="init", code=ruleDescriptor.actions.init)>
<@body><ruleBody()><@end>

@@ -307,8 +315,8 @@ end

delegateRule(ruleDescriptor) ::= <<
# delegated rule <ruleDescriptor.name>
-def <ruleDescriptor.name><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope(scope=it)> )<endif>
-  <methodCall(del=ruleDescriptor.grammar, n=ruleDescriptor.name, args={<ruleDescriptor.parameterScope.attributes:{<it.name>}>})>
+def <ruleDescriptor.name><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope()> )<endif>
+  <methodCall(del=ruleDescriptor.grammar, n=ruleDescriptor.name, args={<ruleDescriptor.parameterScope.attributes:{it | <it.name>}>})>
end
>>
// HELPERS
@@ -327,16 +335,16 @@ initializeDelegator() ::= <<
@<g:delegateName()> = <g:delegateName()>
>>

-altSwitchCase() ::= <<
-when <i>
+altSwitchCase(altNum,alt) ::= <<
+when <altNum>
<@prealt()>
-  <it>
+  <alt>
>>

blockBody() ::= <<
<@decision><decision><@end>
case alt_<decisionNumber>
-<alts:altSwitchCase(); separator="\n">
+<alts:{a | <altSwitchCase(i,a)>}; separator="\n">
end
>>

@@ -351,25 +359,25 @@ while true # decision <decisionNumber>
alt_<decisionNumber> = <maxAlt>
<@decisionBody><decision><@end>
case alt_<decisionNumber>
-  <alts:altSwitchCase(); separator="\n">
+  <alts:{a | <altSwitchCase(i,a)>}; separator="\n">
else
break # out of loop for decision <decisionNumber>
end
end # loop for decision <decisionNumber>
>>

-delegateName() ::= <<
-<if(it.label)><it.label; format="label"><else><it.name; format="snakecase"><endif>
+delegateName(d) ::= <<
+<if(d.label)><d.label; format="label"><else><d.name; format="snakecase"><endif>
>>

-element() ::= <<
-<it.el><\n>
+element(e) ::= <<
+<e.el><\n>
>>

execForcedAction(action) ::= "<action>"

globalAttributeScopeClass(scope) ::= <<
-<if(scope.attributes)>@@<scope.name> = Scope( <scope.attributes:{<it.decl; format="rubyString">}; separator=", "> )<\n><endif>
+<if(scope.attributes)>@@<scope.name> = Scope( <scope.attributes:{it | <it.decl; format="rubyString">}; separator=", "> )<\n><endif>
>>

globalAttributeScopeStack(scope) ::= <<
@@ -379,7 +387,7 @@ globalAttributeScopeStack(scope) ::= <<
noRewrite(rewriteBlockLevel, treeLevel) ::= ""

parameterScope(scope) ::= <<
-<scope.attributes:{<it.decl>}; separator=", ">
+<scope.attributes:{it | <it.decl>}; separator=", ">
>>

positiveClosureBlockLoop() ::= <<
@@ -388,7 +396,7 @@ while true
alt_<decisionNumber> = <maxAlt>
<@decisionBody><decision><@end>
case alt_<decisionNumber>
-  <alts:altSwitchCase(); separator="\n">
+  <alts:{a | <altSwitchCase(i,a)>}; separator="\n">
else
match_count_<decisionNumber> > 0 and break
<ruleBacktrackFailure()>
@@ -402,7 +410,7 @@ end<\n>

returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-<ruleDescriptor:returnStructName(r=it)> = define_return_scope <scope.attributes:{:<it.decl>}; separator=", ">
+<ruleDescriptor:returnStructName(r=it)> = define_return_scope <scope.attributes:{it | :<it.decl>}; separator=", ">
<endif>
>>

@@ -448,7 +456,7 @@ ensure
end
>>

-ruleReturnValue() ::= <<
+ruleReturnValue() ::= <%
<if(!ruleDescriptor.isSynPred)>
<if(ruleDescriptor.hasReturnValue)>
<if(ruleDescriptor.hasSingleReturnValue)>
@@ -458,7 +466,7 @@ return_value
<endif>
<endif>
<endif>
->>
+%>


ruleDeclarations() ::= <<
@@ -539,11 +547,11 @@ end<\n>


ruleScopeSetUp() ::= <<
-<ruleDescriptor.useScopes:{@<it>_stack.push( @@<it>.new )<\n>}><ruleDescriptor.ruleScope:{@<it.name>_stack.push( @@<it.name>.new )<\n>}>
+<ruleDescriptor.useScopes:{it | @<it>_stack.push( @@<it>.new )<\n>}><ruleDescriptor.ruleScope:{it | @<it.name>_stack.push( @@<it.name>.new )<\n>}>
>>

ruleScopeCleanUp() ::= <<
-<ruleDescriptor.useScopes:{@<it>_stack.pop<\n>}><ruleDescriptor.ruleScope:{@<it.name>_stack.pop<\n>}>
+<ruleDescriptor.useScopes:{it | @<it>_stack.pop<\n>}><ruleDescriptor.ruleScope:{it | @<it.name>_stack.pop<\n>}>
>>

memoize() ::= <<
@@ -576,7 +584,7 @@ alt_<decisionNumber> = <maxAlt>
<decls>
<@decision><decision><@end>
case alt_<decisionNumber>
-<alts:altSwitchCase(); separator="\n">
+<alts:{a | <altSwitchCase(i,a)>}; separator="\n">
end
>>

@@ -655,7 +663,7 @@ list_of_<label; format="label"> \<\< <elem><\n>
listLabel ::= addToList

/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,elementIndex,postmatchCode) ::= <<
+matchSet(s,label,elementIndex,terminalOptions,postmatchCode) ::= <<
<if(label)>
<label; format="label"> = @input.look<\n>
<endif>
@@ -687,7 +695,7 @@ matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<

matchRuleBlockSet ::= matchSet

-wildcard(label,elementIndex) ::= <<
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
<if(label)>
<label; format="label"> = @input.look<\n>
<endif>
@@ -700,7 +708,7 @@ wildcard(label,elementIndex) ::= <<
>>
*/

-wildcardAndListLabel(label,elementIndex) ::= <<
+wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<wildcard(...)>
<addToList(elem={<label; format="label">},...)>
>>
@@ -857,7 +865,7 @@ end
>>

dfaEdgeSwitch(labels, targetState) ::= <<
-when <labels:{<it>}; separator=", "> then <targetState>
+when <labels:{it | <it>}; separator=", "> then <targetState>
>>

/** The code to initiate execution of a cyclic DFA; this is used
@@ -995,7 +1003,7 @@ notPredicate(pred) ::= "not ( <pred> )"
evalPredicate(pred,description) ::= "( <pred> )"

evalSynPredicate(pred,description) ::= <<
-syntactic_predicate?( :<pred:{<it>}> )
+syntactic_predicate?( :<pred:{it | <it>}> )
>>

lookaheadTest(atom, k, atomAsInt) ::= "look_<decisionNumber>_<stateNumber> == <atom>"
@@ -1132,7 +1140,7 @@ class <if(grammar.delegator)><grammar.name><else>Lexer<endif> \< <superClass>
<if(filterMode)>
include ANTLR3::FilterMode<\n>
<endif>
-  <scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeClass(scope=it)><\n><endif>}>
+  <scopes:{it | <if(it.isDynamicGlobalScope)><globalAttributeScopeClass()><\n><endif>}>

begin
generated_using( "<fileName>", "<ANTLRVersion>", "<runtimeLibraryVersion()>" )
@@ -1163,7 +1171,7 @@ class <if(grammar.delegator)><grammar.name><else>Lexer<endif> \< <superClass>
<placeAction(scope="lexer",name="members")>

# - - - - - - - - - - - lexer rules - - - - - - - - - - - -
-  <rules:{<it><\n>}>
+  <rules:{it | <it><\n>}>
<if(grammar.delegatedRules)>

# - - - - - - - - - - delegated rules - - - - - - - - - - -
@@ -1193,8 +1201,8 @@ at_exit { <if(grammar.delegator)><grammar.name><else>Lexer<endif>.main( ARGV ) }
lexerRuleLabelDefs() ::= <<
<if([ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.ruleLabels,ruleDescriptor.charLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels])>
# - - - - label initialization - - - -
-<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.ruleLabels,ruleDescriptor.charLabels]:{<it.label.text; format="label"> = nil<\n>}>
-<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]:{list_of_<it.label.text; format="label"> = [] unless defined?(list_of_<it.label.text; format="label">)<\n>}>
+<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.ruleLabels,ruleDescriptor.charLabels]:{it | <it.label.text; format="label"> = nil<\n>}>
+<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]:{it | list_of_<it.label.text; format="label"> = [] unless defined?(list_of_<it.label.text; format="label">)<\n>}>
<endif>
>>

@@ -1205,7 +1213,7 @@ lexerRuleLabelDefs() ::= <<
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
# lexer rule <ruleName; format="lexerRule"> (<ruleName>)
# (in <fileName>)
-def <ruleName; format="lexerRule"><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope(scope=it)> )<endif>
+def <ruleName; format="lexerRule"><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope()> )<endif>
<traceIn()><ruleScopeSetUp()><ruleDeclarations()><if(memoize)>
<if(backtracking)>

@@ -1432,13 +1440,13 @@ action(name, code) ::= <<

autoloadDelegates() ::= <<
<if(grammar.directDelegates)>
-<grammar.directDelegates:{autoload :<it.name>, "<it.recognizerName>"<\n>}>
+<grammar.directDelegates:{it | autoload :<it.name>, "<it.recognizerName>"<\n>}>
<endif>
>>

delegateLexerRule(ruleDescriptor) ::= <<
# delegated lexer rule <ruleDescriptor.name; format="lexerRule"> (<ruleDescriptor.name> in the grammar)
-def <ruleDescriptor.name; format="lexerRule"><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope(scope=it)> )<endif>
+def <ruleDescriptor.name; format="lexerRule"><if(ruleDescriptor.parameterScope)>( <ruleDescriptor.parameterScope:parameterScope()> )<endif>
<methodCall(del=ruleDescriptor.grammar, n={<ruleDescriptor.name; format="lexerRule">}, args=ruleDescriptor.parameterScope.attributes)>
end
>>
@@ -1466,4 +1474,4 @@ placeAction(scope, name) ::= <<
<endif>
>>

-runtimeLibraryVersion() ::= "1.8.1"
\ No newline at end of file
+runtimeLibraryVersion() ::= "1.8.1"

