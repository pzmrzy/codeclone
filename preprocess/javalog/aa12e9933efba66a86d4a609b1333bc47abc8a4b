commit aa12e9933efba66a86d4a609b1333bc47abc8a4b
Author:     acondit <acondit@parrt.spork>
AuthorDate: Wed Jan 25 21:41:19 2012 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Wed Jan 25 21:41:19 2012 -0800

Renaming Files to Match Java src names

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 9898]

diff --git a/runtime/ObjC/Framework/ANTLRBaseMapElement.h b/runtime/ObjC/Framework/ANTLRBaseMapElement.h
deleted file mode 100644
index 0815165..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseMapElement.h
+++ /dev/null
@@ -1,51 +0,0 @@
-//
-//  ANTLRBaseMapElement.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRLinkBase.h"
-
-@interface ANTLRBaseMapElement : ANTLRLinkBase {
-    NSNumber *index;
-}
-
-@property (retain) NSNumber *index;
-
-+ (id) newANTLRBaseMapElement;
-+ (id) newANTLRBaseMapElementWithIndex:(NSNumber *)anIdx;
-- (id) init;
-- (id) initWithAnIndex:(NSNumber *)anIdx;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (NSInteger)count;
-- (NSInteger)size;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBaseMapElement.m b/runtime/ObjC/Framework/ANTLRBaseMapElement.m
deleted file mode 100644
index 7197799..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseMapElement.m
+++ /dev/null
@@ -1,95 +0,0 @@
-//
-//  ANTLRBaseMapElement.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRBaseMapElement.h"
-
-
-@implementation ANTLRBaseMapElement
-
-@synthesize index;
-
-+ (ANTLRBaseMapElement *)newANTLRBaseMapElement
-{
-    return [[ANTLRBaseMapElement alloc] init];
-}
-
-+ (ANTLRBaseMapElement *)newANTLRBaseMapElementWithIndex:(NSNumber *)aNumber
-{
-    return [[ANTLRBaseMapElement alloc] initWithAnIndex:(NSNumber *)aNumber];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil ) {
-        index = nil;
-    }
-    return (self);
-}
-
-- (id) initWithAnIndex:(NSNumber *)aNumber
-{
-    if ((self = [super init]) != nil ) {
-        index = aNumber;
-        if ( index ) [index retain];
-    }
-    return (self);
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRBaseMapElement" );
-#endif
-    if ( index ) [index release];
-    [super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRBaseMapElement *copy;
-
-    copy = [super copyWithZone:aZone];
-    copy.index = index;
-    return( copy );
-}
-
-- (NSInteger)count
-{
-    return 1;
-}
-
-
-- (NSInteger)size
-{
-    return(  sizeof(index) );
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBaseRecognizer.h b/runtime/ObjC/Framework/ANTLRBaseRecognizer.h
deleted file mode 100644
index 346a857..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseRecognizer.h
+++ /dev/null
@@ -1,180 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import <Foundation/Foundation.h>
-
-#import "ANTLRIntStream.h"
-#import "AMutableArray.h"
-
-// This is an abstract superclass for lexers and parsers.
-
-#define ANTLR_MEMO_RULE_FAILED -2
-#define ANTLR_MEMO_RULE_UNKNOWN -1
-#define ANTLR_INITIAL_FOLLOW_STACK_SIZE 100
-
-#import "ANTLRMapElement.h"
-#import "ANTLRBitSet.h"
-#import "ANTLRToken.h"
-#import "ANTLRRecognizerSharedState.h"
-#import "ANTLRRecognitionException.h"
-#import "ANTLRMissingTokenException.h"
-#import "ANTLRMismatchedTokenException.h"
-#import "ANTLRMismatchedTreeNodeException.h"
-#import "ANTLRUnwantedTokenException.h"
-#import "ANTLRNoViableAltException.h"
-#import "ANTLREarlyExitException.h"
-#import "ANTLRMismatchedSetException.h"
-#import "ANTLRMismatchedNotSetException.h"
-#import "ANTLRFailedPredicateException.h"
-
-@interface ANTLRBaseRecognizer : NSObject {
-    __strong ANTLRRecognizerSharedState *state;  // the state of this recognizer. Might be shared with other recognizers, e.g. in grammar import scenarios.
-    __strong NSString *grammarFileName;          // where did the grammar come from. filled in by codegeneration
-    __strong NSString *sourceName;
-    __strong AMutableArray *tokenNames;
-}
-
-+ (void) initialize;
-
-+ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer;
-+ (ANTLRBaseRecognizer *) newANTLRBaseRecognizerWithRuleLen:(NSInteger)aLen;
-+ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer:(ANTLRRecognizerSharedState *)aState;
-
-+ (AMutableArray *)getTokenNames;
-+ (void)setTokenNames:(NSArray *)aTokNamArray;
-+ (void)setGrammarFileName:(NSString *)aFileName;
-
-- (id) init;
-- (id) initWithLen:(NSInteger)aLen;
-- (id) initWithState:(ANTLRRecognizerSharedState *)aState;
-
-- (void) dealloc;
-
-// simple accessors
-- (NSInteger) getBacktrackingLevel;
-- (void) setBacktrackingLevel:(NSInteger) level;
-
-- (BOOL) getFailed;
-- (void) setFailed: (BOOL) flag;
-
-- (ANTLRRecognizerSharedState *) getState;
-- (void) setState:(ANTLRRecognizerSharedState *) theState;
-
-// reset this recognizer - might be extended by codegeneration/grammar
-- (void) reset;
-
-/** Match needs to return the current input symbol, which gets put
- *  into the label for the associated token ref; e.g., x=ID.  Token
- *  and tree parsers need to return different objects. Rather than test
- *  for input stream type or change the IntStream interface, I use
- *  a simple method to ask the recognizer to tell me what the current
- *  input symbol is.
- *
- *  This is ignored for lexers.
- */
-- (id) input;
-
-- (void)skip;
-
-// do actual matching of tokens/characters
-- (id) match:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)ttype Follow:(ANTLRBitSet *)follow;
-- (void) matchAny:(id<ANTLRIntStream>)anInput;
-- (BOOL) mismatchIsUnwantedToken:(id<ANTLRIntStream>)anInput TokenType:(NSInteger) ttype;
-- (BOOL) mismatchIsMissingToken:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *)follow;
-
-// error reporting and recovery
-- (void) reportError:(ANTLRRecognitionException *)e;
-- (void) displayRecognitionError:(AMutableArray *)theTokNams Exception:(ANTLRRecognitionException *)e;
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)theTokNams;
-- (NSInteger) getNumberOfSyntaxErrors;
-- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e;
-- (NSString *)getTokenErrorDisplay:(id<ANTLRToken>)t;
-- (void) emitErrorMessage:(NSString *)msg;
-- (void) recover:(id<ANTLRIntStream>)anInput Exception:(ANTLRRecognitionException *)e;
-
-// begin hooks for debugger
-- (void) beginResync;
-- (void) endResync;
-// end hooks for debugger
-
-// compute the bitsets necessary to do matching and recovery
-- (ANTLRBitSet *)computeErrorRecoverySet;
-- (ANTLRBitSet *)computeContextSensitiveRuleFOLLOW;
-- (ANTLRBitSet *)combineFollows:(BOOL) exact;
-
-- (id<ANTLRToken>) recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput
-                                    TokenType:(NSInteger)ttype
-                                       Follow:(ANTLRBitSet *)follow;
-
-- (id<ANTLRToken>)recoverFromMismatchedSet:(id<ANTLRIntStream>)anInput
-                                    Exception:(ANTLRRecognitionException *)e
-                                    Follow:(ANTLRBitSet *)follow;
-
-- (id) getCurrentInputSymbol:(id<ANTLRIntStream>)anInput;
-- (id) getMissingSymbol:(id<ANTLRIntStream>)anInput
-              Exception:(ANTLRRecognitionException *)e
-              TokenType:(NSInteger) expectedTokenType
-                Follow:(ANTLRBitSet *)follow;
-
-// helper methods for recovery. try to resync somewhere
-- (void) consumeUntilTType:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)ttype;
-- (void) consumeUntilFollow:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *)bitSet;
-- (void) pushFollow:(ANTLRBitSet *)fset;
-- (ANTLRBitSet *)popFollow;
-
-// to be used by the debugger to do reporting. maybe hook in incremental stuff here, too.
-- (AMutableArray *) getRuleInvocationStack;
-- (AMutableArray *) getRuleInvocationStack:(ANTLRRecognitionException *)exception
-                                 Recognizer:(NSString *)recognizerClassName;
-
-- (AMutableArray *) getTokenNames;
-- (NSString *)getGrammarFileName;
-- (NSString *)getSourceName;
-- (AMutableArray *) toStrings:(NSArray *)tokens;
-// support for memoization
-- (NSInteger) getRuleMemoization:(NSInteger)ruleIndex StartIndex:(NSInteger)ruleStartIndex;
-- (BOOL) alreadyParsedRule:(id<ANTLRIntStream>)anInput RuleIndex:(NSInteger)ruleIndex;
-- (void) memoize:(id<ANTLRIntStream>)anInput
-         RuleIndex:(NSInteger)ruleIndex
-        StartIndex:(NSInteger)ruleStartIndex;
-- (NSInteger) getRuleMemoizationCacheSize;
-- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol;
-- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol;
-
-
-// support for syntactic predicates. these are called indirectly to support funky stuff in grammars,
-// like supplying selectors instead of writing code directly into the actions of the grammar.
-- (BOOL) evaluateSyntacticPredicate:(SEL)synpredFragment;
-// stream:(id<ANTLRIntStream>)anInput;
-
-@property (retain) ANTLRRecognizerSharedState *state;
-@property (retain) NSString *grammarFileName;
-@property (retain) NSString *sourceName;
-@property (retain) AMutableArray *tokenNames;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBaseRecognizer.m b/runtime/ObjC/Framework/ANTLRBaseRecognizer.m
deleted file mode 100644
index 573e0dc..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseRecognizer.m
+++ /dev/null
@@ -1,1129 +0,0 @@
-//
-//  ANTLRBaseRecognizer.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRBaseRecognizer.h"
-#import "ANTLRHashRule.h"
-#import "ANTLRRuleMemo.h"
-#import "ANTLRCommonToken.h"
-#import "ANTLRMap.h"
-
-extern NSInteger debug;
-
-@implementation ANTLRBaseRecognizer
-
-static AMutableArray *_tokenNames;
-static NSString *_grammarFileName;
-static NSString *NEXT_TOKEN_RULE_NAME;
-
-@synthesize state;
-@synthesize grammarFileName;
-//@synthesize failed;
-@synthesize sourceName;
-//@synthesize numberOfSyntaxErrors;
-@synthesize tokenNames;
-
-+ (void) initialize
-{
-    NEXT_TOKEN_RULE_NAME = [NSString stringWithString:@"nextToken"];
-    [NEXT_TOKEN_RULE_NAME retain];
-}
-
-+ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer
-{
-    return [[ANTLRBaseRecognizer alloc] init];
-}
-
-+ (ANTLRBaseRecognizer *) newANTLRBaseRecognizerWithRuleLen:(NSInteger)aLen
-{
-    return [[ANTLRBaseRecognizer alloc] initWithLen:aLen];
-}
-
-+ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer:(ANTLRRecognizerSharedState *)aState
-{
-	return [[ANTLRBaseRecognizer alloc] initWithState:aState];
-}
-
-+ (AMutableArray *)getTokenNames
-{
-    return _tokenNames;
-}
-
-+ (void)setTokenNames:(AMutableArray *)theTokNams
-{
-    if ( _tokenNames != theTokNams ) {
-        if ( _tokenNames ) [_tokenNames release];
-        [theTokNams retain];
-    }
-    _tokenNames = theTokNams;
-}
-
-+ (void)setGrammarFileName:(NSString *)aFileName
-{
-    if ( _grammarFileName != aFileName ) {
-        if ( _grammarFileName ) [_grammarFileName release];
-        [aFileName retain];
-    }
-    [_grammarFileName retain];
-}
-
-- (id) init
-{
-	if ((self = [super init]) != nil) {
-        if (state == nil) {
-            state = [[ANTLRRecognizerSharedState newANTLRRecognizerSharedState] retain];
-        }
-        tokenNames = _tokenNames;
-        if ( tokenNames ) [tokenNames retain];
-        grammarFileName = _grammarFileName;
-        if ( grammarFileName ) [grammarFileName retain];
-        state._fsp = -1;
-        state.errorRecovery = NO;		// are we recovering?
-        state.lastErrorIndex = -1;
-        state.failed = NO;				// indicate that some match failed
-        state.syntaxErrors = 0;
-        state.backtracking = 0;			// the level of backtracking
-        state.tokenStartCharIndex = -1;
-	}
-	return self;
-}
-
-- (id) initWithLen:(NSInteger)aLen
-{
-	if ((self = [super init]) != nil) {
-        if (state == nil) {
-            state = [[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:aLen] retain];
-        }
-        tokenNames = _tokenNames;
-        if ( tokenNames ) [tokenNames retain];
-        grammarFileName = _grammarFileName;
-        if ( grammarFileName ) [grammarFileName retain];
-        state._fsp = -1;
-        state.errorRecovery = NO;		// are we recovering?
-        state.lastErrorIndex = -1;
-        state.failed = NO;				// indicate that some match failed
-        state.syntaxErrors = 0;
-        state.backtracking = 0;			// the level of backtracking
-        state.tokenStartCharIndex = -1;
-	}
-	return self;
-}
-
-- (id) initWithState:(ANTLRRecognizerSharedState *)aState
-{
-	if ((self = [super init]) != nil) {
-		state = aState;
-        if (state == nil) {
-            state = [ANTLRRecognizerSharedState newANTLRRecognizerSharedState];
-        }
-        [state retain];
-        tokenNames = _tokenNames;
-        if ( tokenNames ) [tokenNames retain];
-        grammarFileName = _grammarFileName;
-        if ( grammarFileName ) [grammarFileName retain];
-        state._fsp = -1;
-        state.errorRecovery = NO;		// are we recovering?
-        state.lastErrorIndex = -1;
-        state.failed = NO;				// indicate that some match failed
-        state.syntaxErrors = 0;
-        state.backtracking = 0;			// the level of backtracking
-        state.tokenStartCharIndex = -1;
-	}
-	return self;
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRBaseRecognizer" );
-#endif
-	if ( grammarFileName ) [grammarFileName release];
-	if ( tokenNames ) [tokenNames release];
-	if ( state ) [state release];
-	[super dealloc];
-}
-
-// reset the recognizer to the initial state. does not touch the token source!
-// this can be extended by the grammar writer to reset custom ivars
-- (void) reset
-{
-    if ( state == nil )
-        return;
-    if ( state.following != nil ) {
-        if ( [state.following count] )
-            [state.following removeAllObjects];
-    }
-    state._fsp = -1;
-    state.errorRecovery = NO;		// are we recovering?
-    state.lastErrorIndex = -1;
-    state.failed = NO;				// indicate that some match failed
-    state.syntaxErrors = 0;
-    state.backtracking = 0;			// the level of backtracking
-    state.tokenStartCharIndex = -1;
-    if ( state.ruleMemo != nil ) {
-        if ( [state.ruleMemo count] )
-            [state.ruleMemo removeAllObjects];
-    }
-}
-
-- (BOOL) getFailed
-{
-	return [state getFailed];
-}
-
-- (void) setFailed:(BOOL)flag
-{
-	[state setFailed:flag];
-}
-
-- (ANTLRRecognizerSharedState *) getState
-{
-	return state;
-}
-
-- (void) setState:(ANTLRRecognizerSharedState *) theState
-{
-	if (state != theState) {
-		if ( state ) [state release];
-		state = theState;
-		[state retain];
-	}
-}
-
-- (id)input
-{
-    return nil; // Must be overriden in inheriting class
-}
-
-- (void)skip // override in inheriting class
-{
-    return;
-}
-
--(id) match:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)ttype Follow:(ANTLRBitSet *)follow
-{
-	id matchedSymbol = [self getCurrentInputSymbol:anInput];
-	if ([anInput LA:1] == ttype) {
-		[anInput consume];
-		state.errorRecovery = NO;
-		state.failed = NO;
-		return matchedSymbol;
-	}
-	if (state.backtracking > 0) {
-		state.failed = YES;
-		return matchedSymbol;
-	}
-	matchedSymbol = [self recoverFromMismatchedToken:anInput TokenType:ttype Follow:follow];
-	return matchedSymbol;
-}
-
--(void) matchAny:(id<ANTLRIntStream>)anInput
-{
-    state.errorRecovery = NO;
-    state.failed = NO;
-    [anInput consume];
-}
-
--(BOOL) mismatchIsUnwantedToken:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)ttype
-{
-    return [anInput LA:2] == ttype;
-}
-
--(BOOL) mismatchIsMissingToken:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *) follow
-{
-    if ( follow == nil ) {
-        // we have no information about the follow; we can only consume
-        // a single token and hope for the best
-        return NO;
-    }
-    // compute what can follow this grammar element reference
-    if ( [follow member:ANTLRTokenTypeEOR] ) {
-        ANTLRBitSet *viableTokensFollowingThisRule = [self computeContextSensitiveRuleFOLLOW];
-        follow = [follow or:viableTokensFollowingThisRule];
-        if ( state._fsp >= 0 ) { // remove EOR if we're not the start symbol
-            [follow remove:(ANTLRTokenTypeEOR)];
-        }
-    }
-    // if current token is consistent with what could come after set
-    // then we know we're missing a token; error recovery is free to
-    // "insert" the missing token
-
-    //System.out.println("viable tokens="+follow.toString(getTokenNames()));
-    //System.out.println("LT(1)="+((TokenStream)input).LT(1));
-
-    // BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
-    // in follow set to indicate that the fall of the start symbol is
-    // in the set (EOF can follow).
-    if ( [follow member:[anInput LA:1]] || [follow member:ANTLRTokenTypeEOR] ) {
-        //System.out.println("LT(1)=="+((TokenStream)input).LT(1)+" is consistent with what follows; inserting...");
-        return YES;
-    }
-    return NO;
-}
-
-/** Report a recognition problem.
- *
- *  This method sets errorRecovery to indicate the parser is recovering
- *  not parsing.  Once in recovery mode, no errors are generated.
- *  To get out of recovery mode, the parser must successfully match
- *  a token (after a resync).  So it will go:
- *
- * 		1. error occurs
- * 		2. enter recovery mode, report error
- * 		3. consume until token found in resynch set
- * 		4. try to resume parsing
- * 		5. next match() will reset errorRecovery mode
- *
- *  If you override, make sure to update syntaxErrors if you care about that.
- */
--(void) reportError:(ANTLRRecognitionException *) e
-{
-    // if we've already reported an error and have not matched a token
-    // yet successfully, don't report any errors.
-    if ( state.errorRecovery ) {
-        //System.err.print("[SPURIOUS] ");
-        return;
-    }
-    state.syntaxErrors++; // don't count spurious
-    state.errorRecovery = YES;
-
-    [self displayRecognitionError:[self getTokenNames] Exception:e];
-}
-
--(void) displayRecognitionError:(AMutableArray *)theTokNams Exception:(ANTLRRecognitionException *)e
-{
-    NSString *hdr = [self getErrorHeader:e];
-    NSString *msg = [self getErrorMessage:e TokenNames:theTokNams];
-    [self emitErrorMessage:[NSString stringWithFormat:@" %@ %@", hdr, msg]];
-}
-
-/** What error message should be generated for the various
- *  exception types?
- *
- *  Not very object-oriented code, but I like having all error message
- *  generation within one method rather than spread among all of the
- *  exception classes. This also makes it much easier for the exception
- *  handling because the exception classes do not have to have pointers back
- *  to this object to access utility routines and so on. Also, changing
- *  the message for an exception type would be difficult because you
- *  would have to subclassing exception, but then somehow get ANTLR
- *  to make those kinds of exception objects instead of the default.
- *  This looks weird, but trust me--it makes the most sense in terms
- *  of flexibility.
- *
- *  For grammar debugging, you will want to override this to add
- *  more information such as the stack frame with
- *  getRuleInvocationStack(e, this.getClass().getName()) and,
- *  for no viable alts, the decision description and state etc...
- *
- *  Override this to change the message generated for one or more
- *  exception types.
- */
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)theTokNams
-{
-    // NSString *msg = [e getMessage];
-    NSString *msg;
-    if ( [e isKindOfClass:[ANTLRUnwantedTokenException class]] ) {
-        ANTLRUnwantedTokenException *ute = (ANTLRUnwantedTokenException *)e;
-        NSString *tokenName=@"<unknown>";
-        if ( ute.expecting == ANTLRTokenTypeEOF ) {
-            tokenName = @"EOF";
-        }
-        else {
-            tokenName = (NSString *)[theTokNams objectAtIndex:ute.expecting];
-        }
-        msg = [NSString stringWithFormat:@"extraneous input %@ expecting %@", [self getTokenErrorDisplay:[ute getUnexpectedToken]],
-               tokenName];
-    }
-    else if ( [e isKindOfClass:[ANTLRMissingTokenException class] ] ) {
-        ANTLRMissingTokenException *mte = (ANTLRMissingTokenException *)e;
-        NSString *tokenName=@"<unknown>";
-        if ( mte.expecting== ANTLRTokenTypeEOF ) {
-            tokenName = @"EOF";
-        }
-        else {
-            tokenName = [theTokNams objectAtIndex:mte.expecting];
-        }
-        msg = [NSString stringWithFormat:@"missing %@ at %@", tokenName, [self getTokenErrorDisplay:(e.token)] ];
-    }
-    else if ( [e isKindOfClass:[ANTLRMismatchedTokenException class]] ) {
-        ANTLRMismatchedTokenException *mte = (ANTLRMismatchedTokenException *)e;
-        NSString *tokenName=@"<unknown>";
-        if ( mte.expecting== ANTLRTokenTypeEOF ) {
-            tokenName = @"EOF";
-        }
-        else {
-            tokenName = [theTokNams objectAtIndex:mte.expecting];
-        }
-        msg = [NSString stringWithFormat:@"mismatched input %@ expecting %@",[self getTokenErrorDisplay:(e.token)], tokenName];
-    }
-    else if ( [e isKindOfClass:[ANTLRMismatchedTreeNodeException class]] ) {
-        ANTLRMismatchedTreeNodeException *mtne = (ANTLRMismatchedTreeNodeException *)e;
-        NSString *tokenName=@"<unknown>";
-        if ( mtne.expecting==ANTLRTokenTypeEOF ) {
-            tokenName = @"EOF";
-        }
-        else {
-            tokenName = [theTokNams objectAtIndex:mtne.expecting];
-        }
-        msg = [NSString stringWithFormat:@"mismatched tree node: %@ expecting %@", mtne.node, tokenName];
-    }
-    else if ( [e isKindOfClass:[ANTLRNoViableAltException class]] ) {
-        //NoViableAltException *nvae = (NoViableAltException *)e;
-        // for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
-        // and "(decision="+nvae.decisionNumber+") and
-        // "state "+nvae.stateNumber
-        msg = [NSString stringWithFormat:@"no viable alternative at input %@", [self getTokenErrorDisplay:e.token]];
-    }
-    else if ( [e isKindOfClass:[ANTLREarlyExitException class]] ) {
-        //ANTLREarlyExitException *eee = (ANTLREarlyExitException *)e;
-        // for development, can add "(decision="+eee.decisionNumber+")"
-        msg =[NSString stringWithFormat: @"required (...)+ loop did not match anything at input ", [self getTokenErrorDisplay:e.token]];
-    }
-    else if ( [e isKindOfClass:[ANTLRMismatchedSetException class]] ) {
-        ANTLRMismatchedSetException *mse = (ANTLRMismatchedSetException *)e;
-        msg = [NSString stringWithFormat:@"mismatched input %@ expecting set %@",
-               [self getTokenErrorDisplay:(e.token)],
-               mse.expecting];
-    }
-#pragma warning NotSet not yet implemented.
-    else if ( [e isKindOfClass:[ANTLRMismatchedNotSetException class] ] ) {
-        ANTLRMismatchedNotSetException *mse = (ANTLRMismatchedNotSetException *)e;
-        msg = [NSString stringWithFormat:@"mismatched input %@ expecting set %@",
-               [self getTokenErrorDisplay:(e.token)],
-               mse.expecting];
-    }
-    else if ( [e isKindOfClass:[ANTLRFailedPredicateException class]] ) {
-        ANTLRFailedPredicateException *fpe = (ANTLRFailedPredicateException *)e;
-        msg = [NSString stringWithFormat:@"rule %@ failed predicate: { %@ }?", fpe.ruleName, fpe.predicate];
-    }
-    else {
-        msg = [NSString stringWithFormat:@"Exception= %@\n", e.name];
-    }
-    return msg;
-}
-
-/** Get number of recognition errors (lexer, parser, tree parser).  Each
- *  recognizer tracks its own number.  So parser and lexer each have
- *  separate count.  Does not count the spurious errors found between
- *  an error and next valid token match
- *
- *  See also reportError()
- */
-- (NSInteger) getNumberOfSyntaxErrors
-{
-    return state.syntaxErrors;
-}
-
-/** What is the error header, normally line/character position information? */
-- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e
-{
-    return [NSString stringWithFormat:@"line %d:%d", e.line, e.charPositionInLine];
-}
-
-/** How should a token be displayed in an error message? The default
- *  is to display just the text, but during development you might
- *  want to have a lot of information spit out.  Override in that case
- *  to use t.toString() (which, for CommonToken, dumps everything about
- *  the token). This is better than forcing you to override a method in
- *  your token objects because you don't have to go modify your lexer
- *  so that it creates a new Java type.
- */
-- (NSString *)getTokenErrorDisplay:(id<ANTLRToken>)t
-{
-    NSString *s = t.text;
-    if ( s == nil ) {
-        if ( t.type == ANTLRTokenTypeEOF ) {
-            s = @"<EOF>";
-        }
-        else {
-            s = [NSString stringWithFormat:@"<%@>", t.type];
-        }
-    }
-    s = [s stringByReplacingOccurrencesOfString:@"\n" withString:@"\\\\n"];
-    s = [s stringByReplacingOccurrencesOfString:@"\r" withString:@"\\\\r"];
-    s = [s stringByReplacingOccurrencesOfString:@"\t" withString:@"\\\\t"];
-    return [NSString stringWithFormat:@"\'%@\'", s];
-}
-
-/** Override this method to change where error messages go */
-- (void) emitErrorMessage:(NSString *) msg
-{
-//    System.err.println(msg);
-    NSLog(@"%@", msg);
-}
-
-/** Recover from an error found on the input stream.  This is
- *  for NoViableAlt and mismatched symbol exceptions.  If you enable
- *  single token insertion and deletion, this will usually not
- *  handle mismatched symbol exceptions but there could be a mismatched
- *  token that the match() routine could not recover from.
- */
-- (void)recover:(id<ANTLRIntStream>)anInput Exception:(ANTLRRecognitionException *)re
-{
-    if ( state.lastErrorIndex == anInput.index ) {
-        // uh oh, another error at same token index; must be a case
-        // where LT(1) is in the recovery token set so nothing is
-        // consumed; consume a single token so at least to prevent
-        // an infinite loop; this is a failsafe.
-        [anInput consume];
-    }
-    state.lastErrorIndex = anInput.index;
-    ANTLRBitSet *followSet = [self computeErrorRecoverySet];
-    [self beginResync];
-    [self consumeUntilFollow:anInput Follow:followSet];
-    [self endResync];
-}
-
-- (void) beginResync
-{
-
-}
-
-- (void) endResync
-{
-
-}
-
-/*  Compute the error recovery set for the current rule.  During
- *  rule invocation, the parser pushes the set of tokens that can
- *  follow that rule reference on the stack; this amounts to
- *  computing FIRST of what follows the rule reference in the
- *  enclosing rule. This local follow set only includes tokens
- *  from within the rule; i.e., the FIRST computation done by
- *  ANTLR stops at the end of a rule.
- *
- *  EXAMPLE
- *
- *  When you find a "no viable alt exception", the input is not
- *  consistent with any of the alternatives for rule r.  The best
- *  thing to do is to consume tokens until you see something that
- *  can legally follow a call to r *or* any rule that called r.
- *  You don't want the exact set of viable next tokens because the
- *  input might just be missing a token--you might consume the
- *  rest of the input looking for one of the missing tokens.
- *
- *  Consider grammar:
- *
- *  a : '[' b ']'
- *    | '(' b ')'
- *    ;
- *  b : c '^' INT ;
- *  c : ID
- *    | INT
- *    ;
- *
- *  At each rule invocation, the set of tokens that could follow
- *  that rule is pushed on a stack.  Here are the various "local"
- *  follow sets:
- *
- *  FOLLOW(b1_in_a) = FIRST(']') = ']'
- *  FOLLOW(b2_in_a) = FIRST(')') = ')'
- *  FOLLOW(c_in_b) = FIRST('^') = '^'
- *
- *  Upon erroneous input "[]", the call chain is
- *
- *  a -> b -> c
- *
- *  and, hence, the follow context stack is:
- *
- *  depth  local follow set     after call to rule
- *    0         <EOF>                    a (from main())
- *    1          ']'                     b
- *    3          '^'                     c
- *
- *  Notice that ')' is not included, because b would have to have
- *  been called from a different context in rule a for ')' to be
- *  included.
- *
- *  For error recovery, we cannot consider FOLLOW(c)
- *  (context-sensitive or otherwise).  We need the combined set of
- *  all context-sensitive FOLLOW sets--the set of all tokens that
- *  could follow any reference in the call chain.  We need to
- *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
- *  we resync'd to that token, we'd consume until EOF.  We need to
- *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
- *  In this case, for input "[]", LA(1) is in this set so we would
- *  not consume anything and after printing an error rule c would
- *  return normally.  It would not find the required '^' though.
- *  At this point, it gets a mismatched token error and throws an
- *  exception (since LA(1) is not in the viable following token
- *  set).  The rule exception handler tries to recover, but finds
- *  the same recovery set and doesn't consume anything.  Rule b
- *  exits normally returning to rule a.  Now it finds the ']' (and
- *  with the successful match exits errorRecovery mode).
- *
- *  So, you cna see that the parser walks up call chain looking
- *  for the token that was a member of the recovery set.
- *
- *  Errors are not generated in errorRecovery mode.
- *
- *  ANTLR's error recovery mechanism is based upon original ideas:
- *
- *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
- *
- *  and
- *
- *  "A note on error recovery in recursive descent parsers":
- *  http://portal.acm.org/citation.cfm?id=947902.947905
- *
- *  Later, Josef Grosch had some good ideas:
- *
- *  "Efficient and Comfortable Error Recovery in Recursive Descent
- *  Parsers":
- *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
- *
- *  Like Grosch I implemented local FOLLOW sets that are combined
- *  at run-time upon error to avoid overhead during parsing.
- */
-- (ANTLRBitSet *) computeErrorRecoverySet
-{
-    return [self combineFollows:NO];
-}
-
-/** Compute the context-sensitive FOLLOW set for current rule.
- *  This is set of token types that can follow a specific rule
- *  reference given a specific call chain.  You get the set of
- *  viable tokens that can possibly come next (lookahead depth 1)
- *  given the current call chain.  Contrast this with the
- *  definition of plain FOLLOW for rule r:
- *
- *   FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
- *
- *  where x in T* and alpha, beta in V*; T is set of terminals and
- *  V is the set of terminals and nonterminals.  In other words,
- *  FOLLOW(r) is the set of all tokens that can possibly follow
- *  references to r in *any* sentential form (context).  At
- *  runtime, however, we know precisely which context applies as
- *  we have the call chain.  We may compute the exact (rather
- *  than covering superset) set of following tokens.
- *
- *  For example, consider grammar:
- *
- *  stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
- *       | "return" expr '.'
- *       ;
- *  expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
- *  atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
- *       | '(' expr ')'
- *       ;
- *
- *  The FOLLOW sets are all inclusive whereas context-sensitive
- *  FOLLOW sets are precisely what could follow a rule reference.
- *  For input input "i=(3);", here is the derivation:
- *
- *  stat => ID '=' expr ';'
- *       => ID '=' atom ('+' atom)* ';'
- *       => ID '=' '(' expr ')' ('+' atom)* ';'
- *       => ID '=' '(' atom ')' ('+' atom)* ';'
- *       => ID '=' '(' INT ')' ('+' atom)* ';'
- *       => ID '=' '(' INT ')' ';'
- *
- *  At the "3" token, you'd have a call chain of
- *
- *    stat -> expr -> atom -> expr -> atom
- *
- *  What can follow that specific nested ref to atom?  Exactly ')'
- *  as you can see by looking at the derivation of this specific
- *  input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
- *
- *  You want the exact viable token set when recovering from a
- *  token mismatch.  Upon token mismatch, if LA(1) is member of
- *  the viable next token set, then you know there is most likely
- *  a missing token in the input stream.  "Insert" one by just not
- *  throwing an exception.
- */
-- (ANTLRBitSet *)computeContextSensitiveRuleFOLLOW
-{
-    return [self combineFollows:YES];
-}
-
-// what is exact? it seems to only add sets from above on stack
-// if EOR is in set i.  When it sees a set w/o EOR, it stops adding.
-// Why would we ever want them all?  Maybe no viable alt instead of
-// mismatched token?
-- (ANTLRBitSet *)combineFollows:(BOOL) exact
-{
-    NSInteger top = state._fsp;
-    ANTLRBitSet *followSet = [[ANTLRBitSet newANTLRBitSet] retain];
-    for (int i = top; i >= 0; i--) {
-        ANTLRBitSet *localFollowSet = (ANTLRBitSet *)[state.following objectAtIndex:i];
-        /*
-         System.out.println("local follow depth "+i+"="+
-         localFollowSet.toString(getTokenNames())+")");
-         */
-        [followSet orInPlace:localFollowSet];
-        if ( exact ) {
-            // can we see end of rule?
-            if ( [localFollowSet member:ANTLRTokenTypeEOR] ) {
-                // Only leave EOR in set if at top (start rule); this lets
-                // us know if have to include follow(start rule); i.e., EOF
-                if ( i > 0 ) {
-                    [followSet remove:ANTLRTokenTypeEOR];
-                }
-            }
-            else { // can't see end of rule, quit
-                break;
-            }
-        }
-    }
-    return followSet;
-}
-
-/** Attempt to recover from a single missing or extra token.
- *
- *  EXTRA TOKEN
- *
- *  LA(1) is not what we are looking for.  If LA(2) has the right token,
- *  however, then assume LA(1) is some extra spurious token.  Delete it
- *  and LA(2) as if we were doing a normal match(), which advances the
- *  input.
- *
- *  MISSING TOKEN
- *
- *  If current token is consistent with what could come after
- *  ttype then it is ok to "insert" the missing token, else throw
- *  exception For example, Input "i=(3;" is clearly missing the
- *  ')'.  When the parser returns from the nested call to expr, it
- *  will have call chain:
- *
- *    stat -> expr -> atom
- *
- *  and it will be trying to match the ')' at this point in the
- *  derivation:
- *
- *       => ID '=' '(' INT ')' ('+' atom)* ';'
- *                          ^
- *  match() will see that ';' doesn't match ')' and report a
- *  mismatched token error.  To recover, it sees that LA(1)==';'
- *  is in the set of tokens that can follow the ')' token
- *  reference in rule atom.  It can assume that you forgot the ')'.
- */
-- (id<ANTLRToken>)recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput
-                       TokenType:(NSInteger)ttype
-                          Follow:(ANTLRBitSet *)follow
-{
-    ANTLRRecognitionException *e = nil;
-    // if next token is what we are looking for then "delete" this token
-    if ( [self mismatchIsUnwantedToken:anInput TokenType:ttype] ) {
-        e = [ANTLRUnwantedTokenException newException:ttype Stream:anInput];
-        /*
-         System.err.println("recoverFromMismatchedToken deleting "+
-         ((TokenStream)input).LT(1)+
-         " since "+((TokenStream)input).LT(2)+" is what we want");
-         */
-        [self beginResync];
-        [anInput consume]; // simply delete extra token
-        [self endResync];
-        [self reportError:e];  // report after consuming so AW sees the token in the exception
-                         // we want to return the token we're actually matching
-        id matchedSymbol = [self getCurrentInputSymbol:anInput];
-        [anInput consume]; // move past ttype token as if all were ok
-        return matchedSymbol;
-    }
-    // can't recover with single token deletion, try insertion
-    if ( [self mismatchIsMissingToken:anInput Follow:follow] ) {
-        id<ANTLRToken> inserted = [self getMissingSymbol:anInput Exception:e TokenType:ttype Follow:follow];
-        e = [ANTLRMissingTokenException newException:ttype Stream:anInput With:inserted];
-        [self reportError:e];  // report after inserting so AW sees the token in the exception
-        return inserted;
-    }
-    // even that didn't work; must throw the exception
-    e = [ANTLRMismatchedTokenException newException:ttype Stream:anInput];
-    @throw e;
-}
-
-/** Not currently used */
--(id) recoverFromMismatchedSet:(id<ANTLRIntStream>)anInput
-                     Exception:(ANTLRRecognitionException *)e
-                        Follow:(ANTLRBitSet *) follow
-{
-    if ( [self mismatchIsMissingToken:anInput Follow:follow] ) {
-        // System.out.println("missing token");
-        [self reportError:e];
-        // we don't know how to conjure up a token for sets yet
-        return [self getMissingSymbol:anInput Exception:e TokenType:ANTLRTokenTypeInvalid Follow:follow];
-    }
-    // TODO do single token deletion like above for Token mismatch
-    @throw e;
-}
-
-/** Match needs to return the current input symbol, which gets put
- *  into the label for the associated token ref; e.g., x=ID.  Token
- *  and tree parsers need to return different objects. Rather than test
- *  for input stream type or change the IntStream interface, I use
- *  a simple method to ask the recognizer to tell me what the current
- *  input symbol is.
- *
- *  This is ignored for lexers.
- */
-- (id) getCurrentInputSymbol:(id<ANTLRIntStream>)anInput
-{
-    return nil;
-}
-
-/** Conjure up a missing token during error recovery.
- *
- *  The recognizer attempts to recover from single missing
- *  symbols. But, actions might refer to that missing symbol.
- *  For example, x=ID {f($x);}. The action clearly assumes
- *  that there has been an identifier matched previously and that
- *  $x points at that token. If that token is missing, but
- *  the next token in the stream is what we want we assume that
- *  this token is missing and we keep going. Because we
- *  have to return some token to replace the missing token,
- *  we have to conjure one up. This method gives the user control
- *  over the tokens returned for missing tokens. Mostly,
- *  you will want to create something special for identifier
- *  tokens. For literals such as '{' and ',', the default
- *  action in the parser or tree parser works. It simply creates
- *  a CommonToken of the appropriate type. The text will be the token.
- *  If you change what tokens must be created by the lexer,
- *  override this method to create the appropriate tokens.
- */
-- (id)getMissingSymbol:(id<ANTLRIntStream>)anInput
-             Exception:(ANTLRRecognitionException *)e
-             TokenType:(NSInteger)expectedTokenType
-                Follow:(ANTLRBitSet *)follow
-{
-    return nil;
-}
-
-
--(void) consumeUntilTType:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)tokenType
-{
-    //System.out.println("consumeUntil "+tokenType);
-    int ttype = [anInput LA:1];
-    while (ttype != ANTLRTokenTypeEOF && ttype != tokenType) {
-        [anInput consume];
-        ttype = [anInput LA:1];
-    }
-}
-
-/** Consume tokens until one matches the given token set */
--(void) consumeUntilFollow:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *)set
-{
-    //System.out.println("consumeUntil("+set.toString(getTokenNames())+")");
-    int ttype = [anInput LA:1];
-    while (ttype != ANTLRTokenTypeEOF && ![set member:ttype] ) {
-        //System.out.println("consume during recover LA(1)="+getTokenNames()[input.LA(1)]);
-        [anInput consume];
-        ttype = [anInput LA:1];
-    }
-}
-
-/** Push a rule's follow set using our own hardcoded stack */
-- (void)pushFollow:(ANTLRBitSet *)fset
-{
-    if ( (state._fsp +1) >= [state.following count] ) {
-        //        AMutableArray *f = [AMutableArray arrayWithCapacity:[[state.following] count]*2];
-        //        System.arraycopy(state.following, 0, f, 0, state.following.length);
-        //        state.following = f;
-        [state.following addObject:fset];
-        [fset retain];
-        state._fsp++;
-    }
-    else {
-        [state.following replaceObjectAtIndex:++state._fsp withObject:fset];
-    }
-}
-
-- (ANTLRBitSet *)popFollow
-{
-    ANTLRBitSet *fset;
-
-    if ( state._fsp >= 0 && [state.following count] > 0 ) {
-        fset = [state.following objectAtIndex:state._fsp--];
-        [state.following removeLastObject];
-        return fset;
-    }
-    else {
-        NSLog( @"Attempted to pop a follow when none exists on the stack\n" );
-    }
-    return nil;
-}
-
-/** Return List<String> of the rules in your parser instance
- *  leading up to a call to this method.  You could override if
- *  you want more details such as the file/line info of where
- *  in the parser java code a rule is invoked.
- *
- *  This is very useful for error messages and for context-sensitive
- *  error recovery.
- */
-- (AMutableArray *)getRuleInvocationStack
-{
-    NSString *parserClassName = [[self className] retain];
-    return [self getRuleInvocationStack:[ANTLRRecognitionException newException] Recognizer:parserClassName];
-}
-
-/** A more general version of getRuleInvocationStack where you can
- *  pass in, for example, a RecognitionException to get it's rule
- *  stack trace.  This routine is shared with all recognizers, hence,
- *  static.
- *
- *  TODO: move to a utility class or something; weird having lexer call this
- */
-- (AMutableArray *)getRuleInvocationStack:(ANTLRRecognitionException *)e
-                                Recognizer:(NSString *)recognizerClassName
-{
-    // char *name;
-    AMutableArray *rules = [[AMutableArray arrayWithCapacity:20] retain];
-    NSArray *stack = [e callStackSymbols];
-    int i = 0;
-    for (i = [stack count]-1; i >= 0; i--) {
-        NSString *t = [stack objectAtIndex:i];
-        // NSLog(@"stack %d = %@\n", i, t);
-        if ( [t commonPrefixWithString:@"org.antlr.runtime." options:NSLiteralSearch] ) {
-            // id aClass = objc_getClass( [t UTF8String] );
-            continue; // skip support code such as this method
-        }
-        if ( [t isEqualTo:NEXT_TOKEN_RULE_NAME] ) {
-            // name = sel_getName(method_getName(method));
-            // NSString *aMethod = [NSString stringWithFormat:@"%s", name];
-            continue;
-        }
-        if ( ![t isEqualTo:recognizerClassName] ) {
-            // name = class_getName( [t UTF8String] );
-            continue; // must not be part of this parser
-        }
-        [rules addObject:t];
-    }
-#ifdef DONTUSEYET
-    StackTraceElement[] stack = e.getStackTrace();
-    int i = 0;
-    for (i=stack.length-1; i>=0; i--) {
-        StackTraceElement t = stack[i];
-        if ( [t getClassName().startsWith("org.antlr.runtime.") ) {
-            continue; // skip support code such as this method
-        }
-              if ( [[t getMethodName] equals:NEXT_TOKEN_RULE_NAME] ) {
-            continue;
-        }
-              if ( ![[t getClassName] equals:recognizerClassName] ) {
-            continue; // must not be part of this parser
-        }
-              [rules addObject:[t getMethodName]];
-    }
-#endif
-    [stack release];
-    return rules;
-}
-
-- (NSInteger) getBacktrackingLevel
-{
-    return [state getBacktracking];
-}
-
-- (void) setBacktrackingLevel:(NSInteger)level
-{
-    [state setBacktracking:level];
-}
-
-        /** Used to print out token names like ID during debugging and
- *  error reporting.  The generated parsers implement a method
- *  that overrides this to point to their String[] tokenNames.
- */
-- (NSArray *)getTokenNames
-{
-    return tokenNames;
-}
-
-/** For debugging and other purposes, might want the grammar name.
- *  Have ANTLR generate an implementation for this method.
- */
-- (NSString *)getGrammarFileName
-{
-    return grammarFileName;
-}
-
-- (NSString *)getSourceName
-{
-    return nil;
-}
-
-/** A convenience method for use most often with template rewrites.
- *  Convert a List<Token> to List<String>
- */
-- (AMutableArray *)toStrings:(AMutableArray *)tokens
-{
-    if ( tokens == nil )
-        return nil;
-    AMutableArray *strings = [AMutableArray arrayWithCapacity:[tokens count]];
-    id object;
-    NSInteger i = 0;
-    for (object in tokens) {
-        [strings addObject:[object text]];
-        i++;
-    }
-    return strings;
-}
-
-/** Given a rule number and a start token index number, return
- *  ANTLR_MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
- *  start index.  If this rule has parsed input starting from the
- *  start index before, then return where the rule stopped parsing.
- *  It returns the index of the last token matched by the rule.
- *
- *  For now we use a hashtable and just the slow Object-based one.
- *  Later, we can make a special one for ints and also one that
- *  tosses out data after we commit past input position i.
- */
-- (NSInteger)getRuleMemoization:(NSInteger)ruleIndex StartIndex:(NSInteger)ruleStartIndex
-{
-    NSNumber *stopIndexI;
-    ANTLRHashRule *aHashRule;
-    if ( (aHashRule = [state.ruleMemo objectAtIndex:ruleIndex]) == nil ) {
-        aHashRule = [ANTLRHashRule newANTLRHashRuleWithLen:17];
-        [state.ruleMemo insertObject:aHashRule atIndex:ruleIndex];
-    }
-    stopIndexI = [aHashRule getRuleMemoStopIndex:ruleStartIndex];
-    if ( stopIndexI == nil ) {
-        return ANTLR_MEMO_RULE_UNKNOWN;
-    }
-    return [stopIndexI integerValue];
-}
-
-/** Has this rule already parsed input at the current index in the
- *  input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
- *  If we attempted but failed to parse properly before, return
- *  MEMO_RULE_FAILED.
- *
- *  This method has a side-effect: if we have seen this input for
- *  this rule and successfully parsed before, then seek ahead to
- *  1 past the stop token matched for this rule last time.
- */
-- (BOOL)alreadyParsedRule:(id<ANTLRIntStream>)anInput RuleIndex:(NSInteger)ruleIndex
-{
-    NSInteger aStopIndex = [self getRuleMemoization:ruleIndex StartIndex:anInput.index];
-    if ( aStopIndex == ANTLR_MEMO_RULE_UNKNOWN ) {
-        // NSLog(@"rule %d not yet encountered\n", ruleIndex);
-        return NO;
-    }
-    if ( aStopIndex == ANTLR_MEMO_RULE_FAILED ) {
-        if (debug) NSLog(@"rule %d will never succeed\n", ruleIndex);
-        state.failed = YES;
-    }
-    else {
-        if (debug) NSLog(@"seen rule %d before; skipping ahead to %d failed = %@\n", ruleIndex, aStopIndex+1, state.failed?@"YES":@"NO");
-        [anInput seek:(aStopIndex+1)]; // jump to one past stop token
-    }
-    return YES;
-}
-
-/** Record whether or not this rule parsed the input at this position
- *  successfully.  Use a standard java hashtable for now.
- */
-- (void)memoize:(id<ANTLRIntStream>)anInput
-      RuleIndex:(NSInteger)ruleIndex
-     StartIndex:(NSInteger)ruleStartIndex
-{
-    ANTLRRuleStack *aRuleStack;
-    NSInteger stopTokenIndex;
-
-    aRuleStack = state.ruleMemo;
-    stopTokenIndex = (state.failed ? ANTLR_MEMO_RULE_FAILED : (anInput.index-1));
-    if ( aRuleStack == nil ) {
-        if (debug) NSLog(@"!!!!!!!!! memo array is nil for %@", [self getGrammarFileName]);
-        return;
-    }
-    if ( ruleIndex >= [aRuleStack length] ) {
-        if (debug) NSLog(@"!!!!!!!!! memo size is %d, but rule index is %d", [state.ruleMemo length], ruleIndex);
-        return;
-    }
-    if ( [aRuleStack objectAtIndex:ruleIndex] != nil ) {
-        [aRuleStack putHashRuleAtRuleIndex:ruleIndex StartIndex:ruleStartIndex StopIndex:stopTokenIndex];
-    }
-    return;
-}
-
-/** return how many rule/input-index pairs there are in total.
- *  TODO: this includes synpreds. :(
- */
-- (NSInteger)getRuleMemoizationCacheSize
-{
-    ANTLRRuleStack *aRuleStack;
-    ANTLRHashRule *aHashRule;
-
-    int aCnt = 0;
-    aRuleStack = state.ruleMemo;
-    for (NSUInteger i = 0; aRuleStack != nil && i < [aRuleStack length]; i++) {
-        aHashRule = [aRuleStack objectAtIndex:i];
-        if ( aHashRule != nil ) {
-            aCnt += [aHashRule count]; // how many input indexes are recorded?
-        }
-    }
-    return aCnt;
-}
-
-#pragma warning Have to fix traceIn and traceOut.
-- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol
-{
-    NSLog(@"enter %@ %@", ruleName, inputSymbol);
-    if ( state.backtracking > 0 ) {
-        NSLog(@" backtracking=%s", ((state.backtracking==YES)?"YES":"NO"));
-    }
-    NSLog(@"\n");
-}
-
-- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol
-{
-    NSLog(@"exit %@ -- %@", ruleName, inputSymbol);
-    if ( state.backtracking > 0 ) {
-        NSLog(@" backtracking=%s %s", state.backtracking?"YES":"NO", state.failed ? "failed":"succeeded");
-    }
-    NSLog(@"\n");
-}
-
-
-// call a syntactic predicate methods using its selector. this way we can support arbitrary synpreds.
-- (BOOL) evaluateSyntacticPredicate:(SEL)synpredFragment // stream:(id<ANTLRIntStream>)input
-{
-    id<ANTLRIntStream> input;
-
-    state.backtracking++;
-    // input = state.token.input;
-    input = self.input;
-    int start = [input mark];
-    @try {
-        [self performSelector:synpredFragment];
-    }
-    @catch (ANTLRRecognitionException *re) {
-        NSLog(@"impossible synpred: %@", re.name);
-    }
-    BOOL success = (state.failed == NO);
-    [input rewind:start];
-    state.backtracking--;
-    state.failed = NO;
-    return success;
-}
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRBaseStack.h b/runtime/ObjC/Framework/ANTLRBaseStack.h
deleted file mode 100644
index 2356178..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseStack.h
+++ /dev/null
@@ -1,66 +0,0 @@
-//
-//  ANTLRBaseRecognizer.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRPtrBuffer.h"
-
-//#define GLOBAL_SCOPE       0
-//#define LOCAL_SCOPE        1
-#define HASHSIZE         101
-#define HBUFSIZE      0x2000
-
-@interface ANTLRBaseStack : ANTLRPtrBuffer {
-	//ANTLRRuleStack *fNext;
-    // TStringPool *fPool;
-    NSInteger LastHash;
-}
-
-//@property (copy) ANTLRRuleStack *fNext;
-@property (getter=getLastHash, setter=setLastHash:) NSInteger LastHash;
-
-// Contruction/Destruction
-+ (ANTLRBaseStack *)newANTLRBaseStack;
-+ (ANTLRBaseStack *)newANTLRBaseStackWithLen:(NSInteger)cnt;
-- (id)init;
-- (id)initWithLen:(NSInteger)cnt;
-- (void)dealloc;
-
-// Instance Methods
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (NSUInteger)count;
-- (NSUInteger)size;
-/* clear -- reinitialize the maplist array */
-
-- (NSInteger)getLastHash;
-- (void)setLastHash:(NSInteger)aVal;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBaseStack.m b/runtime/ObjC/Framework/ANTLRBaseStack.m
deleted file mode 100644
index 7bd2282..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseStack.m
+++ /dev/null
@@ -1,131 +0,0 @@
-//
-//  ANTLRBaseRecognizer.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#define SUCCESS (0)
-#define FAILURE (-1)
-
-#import "ANTLRBaseStack.h"
-#import "ANTLRTree.h"
-
-/*
- * Start of ANTLRBaseStack
- */
-@implementation ANTLRBaseStack
-
-@synthesize LastHash;
-
-+(ANTLRBaseStack *)newANTLRBaseStack
-{
-    return [[ANTLRBaseStack alloc] init];
-}
-
-+(ANTLRBaseStack *)newANTLRBaseStackWithLen:(NSInteger)cnt
-{
-    return [[ANTLRBaseStack alloc] initWithLen:cnt];
-}
-
--(id)init
-{
-	self = [super initWithLen:HASHSIZE];
-	if ( self != nil ) {
-	}
-    return( self );
-}
-
--(id)initWithLen:(NSInteger)cnt
-{
-	self = [super initWithLen:cnt];
-    if ( self != nil ) {
-	}
-    return( self );
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRBaseStack" );
-#endif
-	[super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRBaseStack *copy;
-
-    copy = [super copyWithZone:aZone];
-    return copy;
-}
-
-- (NSUInteger)count
-{
-    NSUInteger aCnt = 0;
-
-    for (int i = 0; i < BuffSize; i++) {
-        if (ptrBuffer[i] != nil) {
-            aCnt++;
-        }
-    }
-    return aCnt;
-}
-
-- (NSUInteger) size
-{
-    return BuffSize;
-}
-
--(void)deleteANTLRBaseStack:(ANTLRBaseStack *)np
-{
-    id tmp, rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            tmp = (ANTLRLinkBase *)ptrBuffer[idx];
-            while ( tmp ) {
-                rtmp = tmp;
-                tmp = [tmp getfNext];
-                [rtmp release];
-            }
-        }
-    }
-}
-
-- (NSInteger)getLastHash
-{
-    return LastHash;
-}
-
-- (void)setLastHash:(NSInteger)aVal
-{
-    LastHash = aVal;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBaseTree.h b/runtime/ObjC/Framework/ANTLRBaseTree.h
deleted file mode 100755
index 1139cd0..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseTree.h
+++ /dev/null
@@ -1,210 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTree.h"
-#import "ANTLRCommonToken.h"
-#import "AMutableArray.h"
-
-@protocol ANTLRBaseTree <ANTLRTree>
-
-+ (id<ANTLRBaseTree>) INVALID_NODE;
-
-+ (id<ANTLRBaseTree>) newTree;
-+ (id<ANTLRBaseTree>) newTree:(id<ANTLRBaseTree>)node;
-
-- (id<ANTLRBaseTree>) init;
-- (id<ANTLRBaseTree>) initWith:(id<ANTLRBaseTree>)node;
-
-- (id<ANTLRBaseTree>) getChild:(NSUInteger)i;
-- (AMutableArray *)children;
-- (void) setChildren:(AMutableArray *)anArray;
-- (id<ANTLRBaseTree>)getFirstChildWithType:(NSInteger)type;
-- (NSUInteger) getChildCount;
-
-// Add t as a child to this node.  If t is null, do nothing.  If t
-//  is nil, add all children of t to this' children.
-
-- (void) addChild:(id<ANTLRBaseTree>) tree;
-- (void) addChildren:(NSArray *) theChildren;
-//- (void) removeAllChildren;
-
-- (void) setChild:(NSInteger) i With:(id<ANTLRBaseTree>)t;
-- (id) deleteChild:(NSInteger) i;
-- (AMutableArray *) createChildrenList;
-- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
-// Indicates the node is a nil node but may still have children, meaning
-// the tree is a flat list.
-
-- (BOOL) isNil;
-- (NSInteger) getTokenStartIndex;
-- (void) setTokenStartIndex:(NSInteger) index;
-- (NSInteger) getTokenStopIndex;
-- (void) setTokenStopIndex:(NSInteger) index;
-
-- (void) freshenParentAndChildIndexes;
-- (void) freshenParentAndChildIndexes:(NSInteger) offset;
-- (void) sanityCheckParentAndChildIndexes;
-- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>) parent At:(NSInteger) i;
-
-- (NSInteger) getChildIndex;
-- (void) setChildIndex:(NSInteger)i;
-
-- (id<ANTLRBaseTree>)getAncestor:(NSInteger)ttype;
-- (AMutableArray *)getAncestors;
-
-#pragma mark Copying
-- (id) copyWithZone:(NSZone *)aZone;	// the children themselves are not copied here!
-- (id) deepCopy;					// performs a deepCopyWithZone: with the default zone
-- (id) deepCopyWithZone:(NSZone *)aZone;
-
-#pragma mark Tree Parser support
-- (NSInteger)type;
-- (NSString *)text;
-// In case we don't have a token payload, what is the line for errors?
-- (NSUInteger)line;
-- (NSUInteger)charPositionInLine;
-
-
-#pragma mark Informational
-- (NSString *) treeDescription;
-- (NSString *) description;
-
-- (NSString *) toString;
-- (NSString *) toStringTree;
-
-@property (retain) AMutableArray *children;
-@property (retain) NSException *anException;
-
-@end
-
-@interface ANTLRBaseTree : NSObject <ANTLRTree>
-{
-	__strong AMutableArray *children;
-    __strong NSException *anException;
-}
-
-+ (id<ANTLRBaseTree>) INVALID_NODE;
-+ (id<ANTLRBaseTree>) newTree;
-+ (id<ANTLRBaseTree>) newTree:(id<ANTLRBaseTree>)node;
-
-- (id<ANTLRBaseTree>) init;
-- (id<ANTLRBaseTree>) initWith:(id<ANTLRBaseTree>)node;
-
-- (id<ANTLRBaseTree>) getChild:(NSUInteger)i;
-- (AMutableArray *)children;
-- (void) setChildren:(AMutableArray *)anArray;
-- (id<ANTLRBaseTree>)getFirstChildWithType:(NSInteger)type;
-- (NSUInteger) getChildCount;
-
-//- (void) removeAllChildren;
-
-// Add t as a child to this node.  If t is null, do nothing.  If t
-//  is nil, add all children of t to this' children.
-
-- (void) addChild:(id<ANTLRBaseTree>) tree;
-- (void) addChildren:(NSArray *) theChildren;
-
-- (void) setChild:(NSUInteger) i With:(id<ANTLRBaseTree>)t;
-- (id) deleteChild:(NSUInteger) idx;
-- (AMutableArray *) createChildrenList;
-- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
-// Indicates the node is a nil node but may still have children, meaning
-	// the tree is a flat list.
-
-- (BOOL) isNil;
-- (NSInteger) getTokenStartIndex;
-- (void) setTokenStartIndex:(NSInteger) index;
-- (NSInteger) getTokenStopIndex;
-- (void) setTokenStopIndex:(NSInteger) index;
-
-- (void) freshenParentAndChildIndexes;
-- (void) freshenParentAndChildIndexes:(NSInteger) offset;
-- (void) sanityCheckParentAndChildIndexes;
-- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>)parent At:(NSInteger) i;
-
-- (NSInteger) getChildIndex;
-- (void) setChildIndex:(NSInteger)i;
-
-- (BOOL) hasAncestor:(NSInteger) ttype;
-- (id<ANTLRBaseTree>)getAncestor:(NSInteger)ttype;
-- (AMutableArray *)getAncestors;
-
-- (id) copyWithZone:(NSZone *)aZone;
-- (id) deepCopy;					// performs a deepCopyWithZone: with the default zone
-- (id) deepCopyWithZone:(NSZone *)aZone;
-
-	// Return a token type; needed for tree parsing
-- (NSInteger)type;
-- (NSString *)text;
-
-	// In case we don't have a token payload, what is the line for errors?
-- (NSUInteger)line;
-- (NSUInteger)charPositionInLine;
-- (void) setCharPositionInLine:(NSUInteger)pos;
-
-- (NSString *) treeDescription;
-- (NSString *) description;
-- (NSString *) toString;
-- (NSString *) toStringTree;
-
-@property (retain) AMutableArray *children;
-@property (retain) NSException *anException;
-
-@end
-
-@interface ANTLRTreeNavigationNode : ANTLRBaseTree {
-}
-- (id) init;
-- (id) copyWithZone:(NSZone *)aZone;
-@end
-
-@interface ANTLRTreeNavigationNodeDown : ANTLRTreeNavigationNode {
-}
-+ (ANTLRTreeNavigationNodeDown *) getNavigationNodeDown;
-- (id) init;
-- (NSInteger) tokenType;
-- (NSString *) description;
-@end
-
-@interface ANTLRTreeNavigationNodeUp : ANTLRTreeNavigationNode {
-}
-+ (ANTLRTreeNavigationNodeUp *) getNavigationNodeUp;
-- (id) init;
-- (NSInteger) tokenType;
-- (NSString *) description;
-@end
-
-@interface ANTLRTreeNavigationNodeEOF : ANTLRTreeNavigationNode {
-}
-+ (ANTLRTreeNavigationNodeEOF *) getNavigationNodeEOF;
-- (id) init;
-- (NSInteger) tokenType;
-- (NSString *) description;
-@end
-
-extern ANTLRTreeNavigationNodeDown *navigationNodeDown;
-extern ANTLRTreeNavigationNodeUp *navigationNodeUp;
-extern ANTLRTreeNavigationNodeEOF *navigationNodeEOF;
diff --git a/runtime/ObjC/Framework/ANTLRBaseTree.m b/runtime/ObjC/Framework/ANTLRBaseTree.m
deleted file mode 100755
index 5ba4eac..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseTree.m
+++ /dev/null
@@ -1,616 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRBaseTree.h"
-#import "ANTLRBaseTreeAdaptor.h"
-#import "ANTLRToken.h"
-// TODO: this shouldn't be here...but needed for invalidNode
-#import "AMutableArray.h"
-#import "ANTLRCommonTree.h"
-#import "ANTLRRuntimeException.h"
-#import "ANTLRError.h"
-
-#pragma mark - Navigation Nodes
-ANTLRTreeNavigationNodeDown *navigationNodeDown = nil;
-ANTLRTreeNavigationNodeUp *navigationNodeUp = nil;
-ANTLRTreeNavigationNodeEOF *navigationNodeEOF = nil;
-
-
-@implementation ANTLRBaseTree
-
-static id<ANTLRBaseTree> invalidNode = nil;
-
-#pragma mark ANTLRTree protocol conformance
-
-+ (id<ANTLRBaseTree>) INVALID_NODE
-{
-	if ( invalidNode == nil ) {
-		invalidNode = [[ANTLRCommonTree alloc] initWithTokenType:ANTLRTokenTypeInvalid];
-	}
-	return invalidNode;
-}
-
-+ (id<ANTLRBaseTree>) invalidNode
-{
-	if ( invalidNode == nil ) {
-		invalidNode = [[ANTLRCommonTree alloc] initWithTokenType:ANTLRTokenTypeInvalid];
-	}
-	return invalidNode;
-}
-
-+ newTree
-{
-    return [[ANTLRBaseTree alloc] init];
-}
-
-/** Create a new node from an existing node does nothing for ANTLRBaseTree
- *  as there are no fields other than the children list, which cannot
- *  be copied as the children are not considered part of this node.
- */
-+ newTree:(id<ANTLRBaseTree>) node
-{
-    return [[ANTLRBaseTree alloc] initWith:(id<ANTLRBaseTree>) node];
-}
-
-- (id) init
-{
-    self = [super init];
-    if ( self != nil ) {
-        children = nil;
-        return self;
-    }
-    return nil;
-}
-
-- (id) initWith:(id<ANTLRBaseTree>)node
-{
-    self = [super init];
-    if ( self != nil ) {
-        // children = [[AMutableArray arrayWithCapacity:5] retain];
-        // [children addObject:node];
-        [self addChild:node];
-        return self;
-    }
-    return nil;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRBaseTree" );
-#endif
-	if ( children ) [children release];
-	[super dealloc];
-}
-
-- (id<ANTLRBaseTree>) getChild:(NSUInteger)i
-{
-    if ( children == nil || i >= [children count] ) {
-        return nil;
-    }
-    return (id<ANTLRBaseTree>)[children objectAtIndex:i];
-}
-
-/** Get the children internal List; note that if you directly mess with
- *  the list, do so at your own risk.
- */
-- (AMutableArray *) children
-{
-    return children;
-}
-
-- (void) setChildren:(AMutableArray *)anArray
-{
-    if ( children != anArray ) {
-        if ( children ) [children release];
-        if ( anArray ) [anArray retain];
-    }
-    children = anArray;
-}
-
-- (id<ANTLRBaseTree>) getFirstChildWithType:(NSInteger) aType
-{
-    for (NSUInteger i = 0; children != nil && i < [children count]; i++) {
-        id<ANTLRBaseTree> t = (id<ANTLRBaseTree>) [children objectAtIndex:i];
-        if ( t.type == aType ) {
-            return t;
-        }
-    }
-    return nil;
-}
-
-- (NSUInteger) getChildCount
-{
-    if ( children == nil ) {
-        return 0;
-    }
-    return [children count];
-}
-
-/** Add t as child of this node.
- *
- *  Warning: if t has no children, but child does
- *  and child isNil then this routine moves children to t via
- *  t.children = child.children; i.e., without copying the array.
- */
-- (void) addChild:(id<ANTLRBaseTree>) t
-{
-    //System.out.println("add child "+t.toStringTree()+" "+self.toStringTree());
-    //System.out.println("existing children: "+children);
-    if ( t == nil ) {
-        return; // do nothing upon addChild(nil)
-    }
-    if ( self == (ANTLRBaseTree *)t )
-        @throw [ANTLRIllegalArgumentException newException:@"ANTLRBaseTree Can't add self to self as child"];
-    id<ANTLRBaseTree> childTree = (id<ANTLRBaseTree>) t;
-    if ( [childTree isNil] ) { // t is an empty node possibly with children
-        if ( children != nil && children == childTree.children ) {
-            @throw [ANTLRRuntimeException newException:@"ANTLRBaseTree add child list to itself"];
-        }
-        // just add all of childTree's children to this
-        if ( childTree.children != nil ) {
-            if ( children != nil ) { // must copy, this has children already
-                int n = [childTree.children count];
-                for ( int i = 0; i < n; i++) {
-                    id<ANTLRBaseTree> c = (id<ANTLRBaseTree>)[childTree.children objectAtIndex:i];
-                    [children addObject:c];
-                    // handle double-link stuff for each child of nil root
-                    [c setParent:(id<ANTLRBaseTree>)self];
-                    [c setChildIndex:[children count]-1];
-                }
-            }
-            else {
-                // no children for this but t has children; just set pointer
-                // call general freshener routine
-                children = childTree.children;
-                [self freshenParentAndChildIndexes];
-            }
-        }
-    }
-    else { // child is not nil (don't care about children)
-        if ( children == nil ) {
-            children = [[AMutableArray arrayWithCapacity:5] retain]; // create children list on demand
-        }
-        [children addObject:t];
-        [childTree setParent:(id<ANTLRBaseTree>)self];
-        [childTree setChildIndex:[children count]-1];
-    }
-    // System.out.println("now children are: "+children);
-}
-
-/** Add all elements of kids list as children of this node */
-- (void) addChildren:(AMutableArray *) kids
-{
-    for (NSUInteger i = 0; i < [kids count]; i++) {
-        id<ANTLRBaseTree> t = (id<ANTLRBaseTree>) [kids objectAtIndex:i];
-        [self addChild:t];
-    }
-}
-
-- (void) setChild:(NSUInteger) i With:(id<ANTLRBaseTree>)t
-{
-    if ( t == nil ) {
-        return;
-    }
-    if ( [t isNil] ) {
-        @throw [ANTLRIllegalArgumentException newException:@"ANTLRBaseTree Can't set single child to a list"];
-    }
-    if ( children == nil ) {
-        children = [[AMutableArray arrayWithCapacity:5] retain];
-    }
-    if ([children count] > i ) {
-        [children replaceObjectAtIndex:i withObject:t];
-    }
-    else {
-        [children insertObject:t atIndex:i];
-    }
-    [t setParent:(id<ANTLRBaseTree>)self];
-    [t setChildIndex:i];
-}
-
-- (id) deleteChild:(NSUInteger) idx
-{
-    if ( children == nil ) {
-        return nil;
-    }
-    id<ANTLRBaseTree> killed = (id<ANTLRBaseTree>)[children objectAtIndex:idx];
-    [children removeObjectAtIndex:idx];
-    // walk rest and decrement their child indexes
-    [self freshenParentAndChildIndexes:idx];
-    return killed;
-}
-
-/** Delete children from start to stop and replace with t even if t is
- *  a list (nil-root ANTLRTree).  num of children can increase or decrease.
- *  For huge child lists, inserting children can force walking rest of
- *  children to set their childindex; could be slow.
- */
-- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t
-{
-    /*
-     System.out.println("replaceChildren "+startChildIndex+", "+stopChildIndex+
-     " with "+((ANTLRBaseTree)t).toStringTree());
-     System.out.println("in="+toStringTree());
-     */
-    if ( children == nil ) {
-        @throw [ANTLRIllegalArgumentException newException:@"ANTLRBaseTree Invalid Indexes; no children in list"];
-    }
-    int replacingHowMany = stopChildIndex - startChildIndex + 1;
-    int replacingWithHowMany;
-    id<ANTLRBaseTree> newTree = (id<ANTLRBaseTree>) t;
-    AMutableArray *newChildren = nil;
-    // normalize to a list of children to add: newChildren
-    if ( [newTree isNil] ) {
-        newChildren = newTree.children;
-    }
-    else {
-        newChildren = [AMutableArray arrayWithCapacity:5];
-        [newChildren addObject:newTree];
-    }
-    replacingWithHowMany = [newChildren count];
-    int numNewChildren = [newChildren count];
-    int delta = replacingHowMany - replacingWithHowMany;
-    // if same number of nodes, do direct replace
-    if ( delta == 0 ) {
-        int j = 0; // index into new children
-        for (int i=startChildIndex; i <= stopChildIndex; i++) {
-            id<ANTLRBaseTree> child = (id<ANTLRBaseTree>)[newChildren objectAtIndex:j];
-            [children replaceObjectAtIndex:i withObject:(id)child];
-            [child setParent:(id<ANTLRBaseTree>)self];
-            [child setChildIndex:i];
-            j++;
-        }
-    }
-    else if ( delta > 0 ) { // fewer new nodes than there were
-                            // set children and then delete extra
-        for (int j = 0; j < numNewChildren; j++) {
-            [children replaceObjectAtIndex:startChildIndex+j withObject:[newChildren objectAtIndex:j]];
-        }
-        int indexToDelete = startChildIndex+numNewChildren;
-        for (int c=indexToDelete; c<=stopChildIndex; c++) {
-            // delete same index, shifting everybody down each time
-            [children removeObjectAtIndex:indexToDelete];
-        }
-        [self freshenParentAndChildIndexes:startChildIndex];
-    }
-    else { // more new nodes than were there before
-           // fill in as many children as we can (replacingHowMany) w/o moving data
-        for (int j=0; j<replacingHowMany; j++) {
-            [children replaceObjectAtIndex:startChildIndex+j withObject:[newChildren objectAtIndex:j]];
-        }
-        //        int numToInsert = replacingWithHowMany-replacingHowMany;
-        for (int j=replacingHowMany; j<replacingWithHowMany; j++) {
-            [children insertObject:[newChildren objectAtIndex:j] atIndex:startChildIndex+j];
-        }
-        [self freshenParentAndChildIndexes:startChildIndex];
-    }
-    //System.out.println("out="+toStringTree());
-}
-
-/** Override in a subclass to change the impl of children list */
-- (AMutableArray *) createChildrenList
-{
-    return [AMutableArray arrayWithCapacity:5];
-}
-
-- (BOOL) isNil
-{
-    return NO;
-}
-
-/** Set the parent and child index values for all child of t */
-- (void) freshenParentAndChildIndexes
-{
-    [self freshenParentAndChildIndexes:0];
-}
-
-- (void) freshenParentAndChildIndexes:(NSInteger) offset
-{
-    int n = [self getChildCount];
-    for (int i = offset; i < n; i++) {
-        id<ANTLRBaseTree> child = (id<ANTLRBaseTree>)[self getChild:i];
-        [child setChildIndex:i];
-        [child setParent:(id<ANTLRBaseTree>)self];
-    }
-}
-
-- (void) sanityCheckParentAndChildIndexes
-{
-    [self sanityCheckParentAndChildIndexes:nil At:-1];
-}
-
-- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>)aParent At:(NSInteger) i
-{
-    if ( aParent != [self getParent] ) {
-        @throw [ANTLRIllegalStateException newException:[NSString stringWithFormat:@"parents don't match; expected %s found %s", aParent, [self getParent]]];
-    }
-    if ( i != [self getChildIndex] ) {
-        @throw [ANTLRIllegalStateException newException:[NSString stringWithFormat:@"child indexes don't match; expected %d found %d", i, [self getChildIndex]]];
-    }
-    int n = [self getChildCount];
-    for (int c = 0; c < n; c++) {
-        id<ANTLRBaseTree> child = (id<ANTLRBaseTree>)[self getChild:c];
-        [child sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>)self At:c];
-    }
-}
-
-/**  What is the smallest token index (indexing from 0) for this node
- *   and its children?
- */
-- (NSInteger) getTokenStartIndex
-{
-    return 0;
-}
-
-- (void) setTokenStartIndex:(NSInteger) anIndex
-{
-}
-
-/**  What is the largest token index (indexing from 0) for this node
- *   and its children?
- */
-- (NSInteger) getTokenStopIndex
-{
-    return 0;
-}
-
-- (void) setTokenStopIndex:(NSInteger) anIndex
-{
-}
-
-- (id<ANTLRBaseTree>) dupNode
-{
-    return nil;
-}
-
-
-/** ANTLRBaseTree doesn't track child indexes. */
-- (NSInteger) getChildIndex
-{
-    return 0;
-}
-
-- (void) setChildIndex:(NSInteger) anIndex
-{
-}
-
-/** ANTLRBaseTree doesn't track parent pointers. */
-- (id<ANTLRBaseTree>) getParent
-{
-    return nil;
-}
-
-- (void) setParent:(id<ANTLRBaseTree>) t
-{
-}
-
-/** Walk upwards looking for ancestor with this token type. */
-- (BOOL) hasAncestor:(NSInteger) ttype
-{
-    return([self getAncestor:ttype] != nil);
-}
-
-/** Walk upwards and get first ancestor with this token type. */
-- (id<ANTLRBaseTree>) getAncestor:(NSInteger) ttype
-{
-    id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)self;
-    t = (id<ANTLRBaseTree>)[t getParent];
-    while ( t != nil ) {
-        if ( t.type == ttype )
-            return t;
-        t = (id<ANTLRBaseTree>)[t getParent];
-    }
-    return nil;
-}
-
-/** Return a list of all ancestors of this node.  The first node of
- *  list is the root and the last is the parent of this node.
- */
-- (AMutableArray *)getAncestors
-{
-    if ( [self getParent] == nil )
-        return nil;
-    AMutableArray *ancestors = [AMutableArray arrayWithCapacity:5];
-    id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)self;
-    t = (id<ANTLRBaseTree>)[t getParent];
-    while ( t != nil ) {
-        [ancestors insertObject:t atIndex:0]; // insert at start
-        t = (id<ANTLRBaseTree>)[t getParent];
-    }
-    return ancestors;
-}
-
-- (NSInteger)type
-{
-    return ANTLRTokenTypeInvalid;
-}
-
-- (NSString *)text
-{
-    return nil;
-}
-
-- (NSUInteger)line
-{
-    return 0;
-}
-
-- (NSUInteger)charPositionInLine
-{
-    return 0;
-}
-
-- (void) setCharPositionInLine:(NSUInteger) pos
-{
-}
-
-#pragma mark Copying
-
-     // the children themselves are not copied here!
-- (id) copyWithZone:(NSZone *)aZone
-{
-    id<ANTLRBaseTree> theCopy = [[[self class] allocWithZone:aZone] init];
-    [theCopy addChildren:self.children];
-    return theCopy;
-}
-
-- (id) deepCopy 					// performs a deepCopyWithZone: with the default zone
-{
-    return [self deepCopyWithZone:NULL];
-}
-
-- (id) deepCopyWithZone:(NSZone *)aZone
-{
-    id<ANTLRBaseTree> theCopy = [self copyWithZone:aZone];
-
-    if ( [theCopy.children count] )
-        [theCopy.children removeAllObjects];
-    AMutableArray *childrenCopy = theCopy.children;
-    for (id loopItem in children) {
-        id<ANTLRBaseTree> childCopy = [loopItem deepCopyWithZone:aZone];
-        [theCopy addChild:childCopy];
-    }
-    if ( childrenCopy ) [childrenCopy release];
-    return theCopy;
-}
-
-- (NSString *) treeDescription
-{
-    if ( children == nil || [children count] == 0 ) {
-        return [self description];
-    }
-    NSMutableString *buf = [NSMutableString stringWithCapacity:[children count]];
-    if ( ![self isNil] ) {
-        [buf appendString:@"("];
-        [buf appendString:[self toString]];
-        [buf appendString:@" "];
-    }
-    for (int i = 0; children != nil && i < [children count]; i++) {
-        id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)[children objectAtIndex:i];
-        if ( i > 0 ) {
-            [buf appendString:@" "];
-        }
-        [buf appendString:[(id<ANTLRBaseTree>)t toStringTree]];
-    }
-    if ( ![self isNil] ) {
-        [buf appendString:@")"];
-    }
-    return buf;
-}
-
-/** Print out a whole tree not just a node */
-- (NSString *) toStringTree
-{
-    return [self treeDescription];
-}
-
-- (NSString *) description
-{
-    return nil;
-}
-
-/** Override to say how a node (not a tree) should look as text */
-- (NSString *) toString
-{
-    return nil;
-}
-
-@synthesize children;
-@synthesize anException;
-
-@end
-
-#pragma mark -
-
-@implementation ANTLRTreeNavigationNode
-- (id)init
-{
-    self = (ANTLRTreeNavigationNode *)[super init];
-    return self;
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-	return nil;
-}
-@end
-
-@implementation ANTLRTreeNavigationNodeDown
-+ (ANTLRTreeNavigationNodeDown *) getNavigationNodeDown
-{
-    if ( navigationNodeDown == nil )
-        navigationNodeDown = [[ANTLRTreeNavigationNodeDown alloc] init];
-    return navigationNodeDown;
-}
-
-- (id)init
-{
-    self = [super init];
-    return self;
-}
-
-- (NSInteger) tokenType { return ANTLRTokenTypeDOWN; }
-- (NSString *) description { return @"DOWN"; }
-@end
-
-@implementation ANTLRTreeNavigationNodeUp
-+ (ANTLRTreeNavigationNodeUp *) getNavigationNodeUp
-{
-    if ( navigationNodeUp == nil )
-        navigationNodeUp = [[ANTLRTreeNavigationNodeUp alloc] init];
-    return navigationNodeUp;
-}
-
-
-- (id)init
-{
-    self = [super init];
-    return self;
-}
-
-- (NSInteger) tokenType { return ANTLRTokenTypeUP; }
-- (NSString *) description { return @"UP"; }
-@end
-
-@implementation ANTLRTreeNavigationNodeEOF
-+ (ANTLRTreeNavigationNodeEOF *) getNavigationNodeEOF
-{
-    if ( navigationNodeEOF == nil )
-        navigationNodeEOF = [[ANTLRTreeNavigationNodeEOF alloc] init];
-    return navigationNodeEOF;
-}
-
-- (id)init
-{
-    self = [super init];
-    return self;
-}
-
-- (NSInteger) tokenType { return ANTLRTokenTypeEOF; }
-- (NSString *) description { return @"EOF"; }
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.h b/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.h
deleted file mode 100644
index f8ed0d2..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.h
+++ /dev/null
@@ -1,182 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTreeAdaptor.h"
-#import "ANTLRCommonErrorNode.h"
-#import "ANTLRUniqueIDMap.h"
-
-@interface ANTLRBaseTreeAdaptor : NSObject <ANTLRTreeAdaptor, NSCopying> {
-    ANTLRUniqueIDMap *treeToUniqueIDMap;
-	NSInteger uniqueNodeID;
-}
-
-- (id) init;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (id) emptyNode;
-
-- (id) createNil;
-
-/** create tree node that holds the start and stop tokens associated
- *  with an error.
- *
- *  If you specify your own kind of tree nodes, you will likely have to
- *  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
- *  if no token payload but you might have to set token type for diff
- *  node type.
- *
- *  You don't have to subclass CommonErrorNode; you will likely need to
- *  subclass your own tree node class to avoid class cast exception.
- */
-- (id) errorNode:(id<ANTLRTokenStream>)anInput
-            From:(id<ANTLRToken>)startToken
-              To:(id<ANTLRToken>)stopToken
-       Exception:(NSException *) e;
-
-- (BOOL) isNil:(id<ANTLRBaseTree>) aTree;
-
-- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)aTree;
-
-/** This is generic in the sense that it will work with any kind of
- *  tree (not just Tree interface).  It invokes the adaptor routines
- *  not the tree node routines to do the construction.
- */
-- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)aTree Parent:(id<ANTLRBaseTree>)parent;
-- (id<ANTLRBaseTree>)dupNode:(id<ANTLRBaseTree>)aNode;
-/** Add a child to the tree t.  If child is a flat tree (a list), make all
- *  in list children of t.  Warning: if t has no children, but child does
- *  and child isNil then you can decide it is ok to move children to t via
- *  t.children = child.children; i.e., without copying the array.  Just
- *  make sure that this is consistent with have the user will build
- *  ASTs.
- */
-- (void) addChild:(id<ANTLRBaseTree>)aChild toTree:(id<ANTLRBaseTree>)aTree;
-
-/** If oldRoot is a nil root, just copy or move the children to newRoot.
- *  If not a nil root, make oldRoot a child of newRoot.
- *
- *    old=^(nil a b c), new=r yields ^(r a b c)
- *    old=^(a b c), new=r yields ^(r ^(a b c))
- *
- *  If newRoot is a nil-rooted single child tree, use the single
- *  child as the new root node.
- *
- *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
- *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
- *
- *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
- *
- *    old=null, new=r yields r
- *    old=null, new=^(nil r) yields ^(nil r)
- *
- *  Return newRoot.  Throw an exception if newRoot is not a
- *  simple node or nil root with a single child node--it must be a root
- *  node.  If newRoot is ^(nil x) return x as newRoot.
- *
- *  Be advised that it's ok for newRoot to point at oldRoot's
- *  children; i.e., you don't have to copy the list.  We are
- *  constructing these nodes so we should have this control for
- *  efficiency.
- */
-- (id<ANTLRBaseTree>)becomeRoot:(id<ANTLRBaseTree>)aNewRoot old:(id<ANTLRBaseTree>)oldRoot;
-
-/** Transform ^(nil x) to x and nil to null */
-- (id<ANTLRBaseTree>)rulePostProcessing:(id<ANTLRBaseTree>)aRoot;
-
-- (id<ANTLRBaseTree>)becomeRootfromToken:(id<ANTLRToken>)aNewRoot old:(id<ANTLRBaseTree>)oldRoot;
-
-- (id<ANTLRBaseTree>) create:(id<ANTLRToken>)payload;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)aTType FromToken:(id<ANTLRToken>)aFromToken;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)aTType FromToken:(id<ANTLRToken>)aFromToken Text:(NSString *)theText;
-- (id<ANTLRBaseTree>) createTree:(NSInteger)aTType Text:(NSString *)theText;
-
-- (NSInteger) getType:(id<ANTLRBaseTree>)aTree;
-
-- (void) setType:(id<ANTLRBaseTree>)aTree Type:(NSInteger)type;
-
-- (id<ANTLRToken>)getToken:(ANTLRCommonTree *)t;
-
-- (NSString *)getText:(ANTLRCommonTree *)aTree;
-
-- (void) setText:(id<ANTLRBaseTree>)aTree Text:(NSString *)theText;
-
-- (id<ANTLRBaseTree>) getChild:(id<ANTLRBaseTree>)aTree At:(NSInteger)i;
-
-- (void) setChild:(id<ANTLRBaseTree>)aTree At:(NSInteger)index Child:(id<ANTLRBaseTree>)aChild;
-
-- (id<ANTLRBaseTree>) deleteChild:(id<ANTLRBaseTree>)aTree Index:(NSInteger)index;
-
-- (NSInteger) getChildCount:(id<ANTLRBaseTree>)aTree;
-
-- (id<ANTLRBaseTree>) getParent:(id<ANTLRBaseTree>) t;
-
-- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>) parent;
-
-/** What index is this node in the child list? Range: 0..n-1
- *  If your node type doesn't handle this, it's ok but the tree rewrites
- *  in tree parsers need this functionality.
- */
-- (NSInteger) getChildIndex:(id)t;
-- (void) setChildIndex:(id)t With:(NSInteger)index;
-
-- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t;
-
-- (NSInteger) getUniqueID:(id<ANTLRBaseTree>)node;
-
-#ifdef DONTUSENOMO
-- (NSInteger) getUniqueID;
-
-- (void) setUniqueNodeID:(NSInteger)aUniqueNodeID;
-
-- (ANTLRUniqueIDMap *)getTreeToUniqueIDMap;
-
-- (void) setTreeToUniqueIDMap:(ANTLRUniqueIDMap *)aMapNode;
-#endif
-
-/** Tell me how to create a token for use with imaginary token nodes.
- *  For example, there is probably no input symbol associated with imaginary
- *  token DECL, but you need to create it as a payload or whatever for
- *  the DECL node as in ^(DECL type ID).
- *
- *  This is a variant of createToken where the new token is derived from
- *  an actual real input token.  Typically this is for converting '{'
- *  tokens to BLOCK etc...  You'll see
- *
- *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
- *
- *  If you care what the token payload objects' type is, you should
- *  override this method and any other createToken variant.
- */
-- (id<ANTLRToken>)createToken:(NSInteger)aTType Text:(NSString *)theText;
-
-- (id<ANTLRToken>)createToken:(id<ANTLRToken>)aFromToken;
-
-@property (retain) ANTLRUniqueIDMap *treeToUniqueIDMap;
-@property (assign) NSInteger uniqueNodeID;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m b/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m
deleted file mode 100644
index 58b181d..0000000
--- a/runtime/ObjC/Framework/ANTLRBaseTreeAdaptor.m
+++ /dev/null
@@ -1,429 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRBaseTreeAdaptor.h"
-#import "ANTLRRuntimeException.h"
-#import "ANTLRUniqueIDMap.h"
-#import "ANTLRMapElement.h"
-#import "ANTLRCommonTree.h"
-
-@implementation ANTLRBaseTreeAdaptor
-
-@synthesize treeToUniqueIDMap;
-@synthesize uniqueNodeID;
-
-+ (id<ANTLRTree>) newEmptyTree
-{
-    return [[ANTLRCommonTree alloc] init];
-}
-
-- (id) init
-{
-    self = [super init];
-    if ( self != nil ) {
-    }
-    return self;
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRBaseTreeAdaptor *copy;
-
-    copy = [[[self class] alloc] init];
-    if (treeToUniqueIDMap)
-        copy.treeToUniqueIDMap = [treeToUniqueIDMap copyWithZone:aZone];
-    copy.uniqueNodeID = uniqueNodeID;
-    return copy;
-}
-
-
-- (id) createNil
-{
-    return [ANTLRCommonTree newTreeWithToken:nil];
-}
-
-- (id) emptyNode
-{
-    return [ANTLRCommonTree newTreeWithToken:nil];
-}
-
-/** create tree node that holds the start and stop tokens associated
- *  with an error.
- *
- *  If you specify your own kind of tree nodes, you will likely have to
- *  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
- *  if no token payload but you might have to set token type for diff
- *  node type.
- *
- *  You don't have to subclass CommonErrorNode; you will likely need to
- *  subclass your own tree node class to avoid class cast exception.
- */
-- (id) errorNode:(id<ANTLRTokenStream>)anInput
-            From:(id<ANTLRToken>)startToken
-              To:(id<ANTLRToken>)stopToken
-       Exception:(ANTLRRecognitionException *) e;
-{
-    //System.out.println("returning error node '"+t+"' @index="+anInput.index());
-    return [ANTLRCommonErrorNode newANTLRCommonErrorNode:anInput
-                                                    From:startToken
-                                                      To:stopToken
-                                               Exception:e];
-}
-
-- (BOOL) isNil:(id) tree
-{
-    return [(id)tree isNil];
-}
-
-- (id)dupTree:(id)tree
-{
-    return [self dupTree:(id)tree Parent:nil];
-}
-
-/** This is generic in the sense that it will work with any kind of
- *  tree (not just Tree interface).  It invokes the adaptor routines
- *  not the tree node routines to do the construction.
- */
-- (id)dupTree:(id)t Parent:(id)parent
-{
-    if ( t==nil ) {
-        return nil;
-    }
-    id newTree = [self dupNode:t];
-    // ensure new subtree root has parent/child index set
-    [self setChildIndex:newTree With:[self getChildIndex:t]]; // same index in new tree
-    [self setParent:newTree With:parent];
-    NSInteger n = [self getChildCount:t];
-    for (NSInteger i = 0; i < n; i++) {
-        id child = [self getChild:t At:i];
-        id newSubTree = [self dupTree:child Parent:t];
-        [self addChild:newSubTree toTree:newTree];
-    }
-    return newTree;
-}
-
-- (id)dupNode:(id)aNode
-{
-    return aNode; // override for better results :>)
-}
-/** Add a child to the tree t.  If child is a flat tree (a list), make all
- *  in list children of t.  Warning: if t has no children, but child does
- *  and child isNil then you can decide it is ok to move children to t via
- *  t.children = child.children; i.e., without copying the array.  Just
- *  make sure that this is consistent with have the user will build
- *  ASTs.
- */
-- (void) addChild:(id)child toTree:(id)t
-{
-    if ( t != nil && child != nil ) {
-        [(id)t addChild:child];
-    }
-}
-
-/** If oldRoot is a nil root, just copy or move the children to newRoot.
- *  If not a nil root, make oldRoot a child of newRoot.
- *
- *    old=^(nil a b c), new=r yields ^(r a b c)
- *    old=^(a b c), new=r yields ^(r ^(a b c))
- *
- *  If newRoot is a nil-rooted single child tree, use the single
- *  child as the new root node.
- *
- *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
- *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
- *
- *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
- *
- *    old=null, new=r yields r
- *    old=null, new=^(nil r) yields ^(nil r)
- *
- *  Return newRoot.  Throw an exception if newRoot is not a
- *  simple node or nil root with a single child node--it must be a root
- *  node.  If newRoot is ^(nil x) return x as newRoot.
- *
- *  Be advised that it's ok for newRoot to point at oldRoot's
- *  children; i.e., you don't have to copy the list.  We are
- *  constructing these nodes so we should have this control for
- *  efficiency.
- */
-- (id)becomeRoot:(id)newRoot old:(id)oldRoot
-{
-    if ( oldRoot == nil ) {
-        return newRoot;
-    }
-    //System.out.println("becomeroot new "+newRoot.toString()+" old "+oldRoot);
-    id newRootTree = (id)newRoot;
-    id oldRootTree = (id)oldRoot;
-    // handle ^(nil real-node)
-    if ( [newRootTree isNil] ) {
-        NSInteger nc = [newRootTree getChildCount];
-        if ( nc == 1 ) newRootTree = [(id)newRootTree getChild:0];
-        else if ( nc > 1 ) {
-            // TODO: make tree run time exceptions hierarchy
-            @throw [ANTLRRuntimeException newException:NSStringFromClass([self class]) reason:@"more than one node as root (TODO: make exception hierarchy)"];
-        }
-    }
-    // add oldRoot to newRoot; addChild takes care of case where oldRoot
-    // is a flat list (i.e., nil-rooted tree).  All children of oldRoot
-    // are added to newRoot.
-    [newRootTree addChild:oldRootTree];
-    return newRootTree;
-}
-
-/** Transform ^(nil x) to x and nil to null */
-- (id)rulePostProcessing:(id)root
-{
-    //System.out.println("rulePostProcessing: "+((Tree)root).toStringTree());
-    id r = (id)root;
-    if ( r != nil && [r isNil] ) {
-        if ( [r getChildCount] == 0 ) {
-            r = nil;
-        }
-        else if ( [r getChildCount] == 1 ) {
-            r = (id)[r getChild:0];
-            // whoever invokes rule will set parent and child index
-            [r setParent:nil];
-            [r setChildIndex:-1];
-        }
-    }
-    return r;
-}
-
-- (id)becomeRootfromToken:(id<ANTLRToken>)newRoot old:(id)oldRoot
-{
-    return [self becomeRoot:(id)[self create:newRoot] old:oldRoot];
-}
-
-- (id) create:(id<ANTLRToken>)aToken
-{
-    return [ANTLRCommonTree newTreeWithToken:aToken];
-}
-
-- (id)createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken
-{
-    fromToken = [self createToken:fromToken];
-    //((ClassicToken)fromToken).setType(tokenType);
-    [fromToken setType:tokenType];
-    id t = [self create:fromToken];
-    return t;
-}
-
-- (id)createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text
-{
-    if (fromToken == nil)
-        return [self createTree:tokenType Text:text];
-    fromToken = [self createToken:fromToken];
-    [fromToken setType:tokenType];
-    [fromToken setText:text];
-    id t = [self create:fromToken];
-    return t;
-}
-
-- (id)createTree:(NSInteger)tokenType Text:(NSString *)text
-{
-    id<ANTLRToken> fromToken = [self createToken:tokenType Text:text];
-    id t = (id)[self create:fromToken];
-    return t;
-}
-
-- (NSInteger) getType:(ANTLRCommonTree *) t
-{
-    return [t type];
-}
-
-- (void) setType:(id)t Type:(NSInteger)type
-{
-    @throw [ANTLRNoSuchElementException newException:@"don't know enough about Tree node"];
-}
-
-/** What is the Token associated with this node?  If
- *  you are not using ANTLRCommonTree, then you must
- *  override this in your own adaptor.
- */
-- (id<ANTLRToken>) getToken:(ANTLRCommonTree *) t
-{
-    if ( [t isKindOfClass:[ANTLRCommonTree class]] ) {
-        return [t getToken];
-    }
-    return nil; // no idea what to do
-}
-
-- (NSString *)getText:(ANTLRCommonTree *)t
-{
-    return [t text];
-}
-
-- (void) setText:(id)t Text:(NSString *)text
-{
-    @throw [ANTLRNoSuchElementException newException:@"don't know enough about Tree node"];
-}
-
-- (id) getChild:(id)t At:(NSInteger)index
-{
-    return [(id)t getChild:index ];
-}
-
-- (void) setChild:(id)t At:(NSInteger)index Child:(id)child
-{
-    [(id)t setChild:index With:(id)child];
-}
-
-- (id) deleteChild:(id)t Index:(NSInteger)index
-{
-    return [(id)t deleteChild:index];
-}
-
-- (NSInteger) getChildCount:(id)t
-{
-    return [(id)t getChildCount];
-}
-
-- (id<ANTLRBaseTree>) getParent:(id<ANTLRBaseTree>) t
-{
-    if ( t == nil )
-        return nil;
-    return (id<ANTLRBaseTree>)[t getParent];
-}
-
-- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>) parent
-{
-    if ( t != nil )
-        [(id<ANTLRBaseTree>) t setParent:(id<ANTLRBaseTree>)parent];
-}
-
-/** What index is this node in the child list? Range: 0..n-1
- *  If your node type doesn't handle this, it's ok but the tree rewrites
- *  in tree parsers need this functionality.
- */
-- (NSInteger) getChildIndex:(id)t
-{
-    return ((ANTLRCommonTree *)t).childIndex;
-}
-
-- (void) setChildIndex:(id)t With:(NSInteger)index
-{
-    ((ANTLRCommonTree *)t).childIndex = index;
-}
-
-- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t
-{
-    return;
-}
-
-- (NSInteger) getUniqueID:(id)node
-{
-    if ( treeToUniqueIDMap == nil ) {
-        treeToUniqueIDMap = [ANTLRUniqueIDMap newANTLRUniqueIDMap];
-    }
-    NSNumber *prevID = [treeToUniqueIDMap getNode:node];
-    if ( prevID != nil ) {
-        return [prevID integerValue];
-    }
-    NSInteger anID = uniqueNodeID;
-    // ANTLRMapElement *aMapNode = [ANTLRMapElement newANTLRMapElementWithObj1:[NSNumber numberWithInteger:anID] Obj2:node];
-    [treeToUniqueIDMap putID:[NSNumber numberWithInteger:anID] Node:node];
-    uniqueNodeID++;
-    return anID;
-    // GCC makes these nonunique:
-    // return System.identityHashCode(node);
-}
-
-/** Tell me how to create a token for use with imaginary token nodes.
- *  For example, there is probably no input symbol associated with imaginary
- *  token DECL, but you need to create it as a payload or whatever for
- *  the DECL node as in ^(DECL type ID).
- *
- *  If you care what the token payload objects' type is, you should
- *  override this method and any other createToken variant.
- */
-- (id<ANTLRToken>) createToken:(NSInteger)aTType Text:(NSString *)text
-{
-    return nil;
-}
-
-/** Tell me how to create a token for use with imaginary token nodes.
- *  For example, there is probably no input symbol associated with imaginary
- *  token DECL, but you need to create it as a payload or whatever for
- *  the DECL node as in ^(DECL type ID).
- *
- *  This is a variant of createToken where the new token is derived from
- *  an actual real input token.  Typically this is for converting '{'
- *  tokens to BLOCK etc...  You'll see
- *
- *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
- *
- *  If you care what the token payload objects' type is, you should
- *  override this method and any other createToken variant.
- */
-- (id<ANTLRToken>) createToken:(id<ANTLRToken>) fromToken
-{
-    return nil;
-}
-
-/** Track start/stop token for subtree root created for a rule.
- *  Only works with Tree nodes.  For rules that match nothing,
- *  seems like this will yield start=i and stop=i-1 in a nil node.
- *  Might be useful info so I'll not force to be i..i.
- */
-- (void) setTokenBoundaries:(id)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken
-{
-    return;
-}
-
-- (NSInteger) getTokenStartIndex:(id)aTree
-{
-    return -1;
-}
-
-- (NSInteger) getTokenStopIndex:(id)aTree
-{
-    return -1;
-}
-
-#ifdef DONTUSENOMO
-- (NSInteger)getUniqueID
-{
-    return uniqueNodeID;
-}
-
-- (void) setUniqueNodeID:(NSInteger)aUniqueNodeID
-{
-    uniqueNodeID = aUniqueNodeID;
-}
-
-- (ANTLRUniqueIDMap *)getTreeToUniqueIDMap
-{
-    return treeToUniqueIDMap;
-}
-
-- (void) setTreeToUniqueIDMap:(ANTLRUniqueIDMap *)aMapListNode
-{
-    treeToUniqueIDMap = aMapListNode;
-}
-
-#endif
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBufferedTokenStream.h b/runtime/ObjC/Framework/ANTLRBufferedTokenStream.h
deleted file mode 100644
index 28d1418..0000000
--- a/runtime/ObjC/Framework/ANTLRBufferedTokenStream.h
+++ /dev/null
@@ -1,102 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTokenStream.h"
-#import "ANTLRTokenSource.h"
-#import "ANTLRBitSet.h"
-#import "ANTLRCommonToken.h"
-#import "AMutableArray.h"
-
-@interface ANTLRBufferedTokenStream : NSObject <ANTLRTokenStream>
-{
-__strong id<ANTLRTokenSource> tokenSource;
-
-    /** Record every single token pulled from the source so we can reproduce
-     *  chunks of it later.  The buffer in LookaheadStream overlaps sometimes
-     *  as its moving window moves through the input.  This list captures
-     *  everything so we can access complete input text.
-     */
-__strong AMutableArray *tokens;
-
-    /** Track the last mark() call result value for use in rewind(). */
-NSInteger lastMarker;
-
-    /** The index into the tokens list of the current token (next token
-     *  to consume).  tokens[index] should be LT(1).  index=-1 indicates need
-     *  to initialize with first token.  The ctor doesn't get a token.
-     *  First call to LT(1) or whatever gets the first token and sets index=0;
-     */
-NSInteger index;
-
-NSInteger range; // how deep have we gone?
-
-}
-@property (retain, getter=getTokenSource,setter=setTokenSource:) id<ANTLRTokenSource> tokenSource;
-@property (retain, getter=getTokens,setter=setTokens:) AMutableArray *tokens;
-@property (assign, getter=getLastMarker,setter=setLastMarker:) NSInteger lastMarker;
-@property (assign) NSInteger index;
-@property (assign, getter=getRange,setter=setRange:) NSInteger range;
-
-+ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStream;
-+ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStreamWith:(id<ANTLRTokenSource>)aSource;
-- (id) initWithTokenSource:(id<ANTLRTokenSource>)aSource;
-- (void)dealloc;
-- (id) copyWithZone:(NSZone *)aZone;
-- (NSUInteger)charPositionInLine;
-- (NSUInteger)line;
-- (NSInteger) getRange;
-- (void) setRange:(NSInteger)anInt;
-- (NSInteger) mark;
-- (void) release:(NSInteger) marker;
-- (void) rewind:(NSInteger) marker;
-- (void) rewind;
-- (void) reset;
-- (void) seek:(NSInteger) anIndex;
-- (NSInteger) size;
-- (void) consume;
-- (void) sync:(NSInteger) i;
-- (void) fetch:(NSInteger) n;
-- (id<ANTLRToken>) getToken:(NSInteger) i;
-- (AMutableArray *)getFrom:(NSInteger)startIndex To:(NSInteger) stopIndex;
-- (NSInteger) LA:(NSInteger)i;
-- (id<ANTLRToken>) LB:(NSInteger) k;
-- (id<ANTLRToken>) LT:(NSInteger) k;
-- (void) setup;
-- (id<ANTLRTokenSource>) getTokenSource;
-- (void) setTokenSource:(id<ANTLRTokenSource>) aTokenSource;
-- (AMutableArray *)getTokens;
-- (NSString *) getSourceName;
-- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex;
-- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex With:(ANTLRBitSet *)types;
-- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithList:(AMutableArray *)types;
-- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithType:(NSInteger)ttype;
-- (NSString *) toString;
-- (NSString *) toStringFromStart:(NSInteger)startIndex ToEnd:(NSInteger)stopIndex;
-- (NSString *) toStringFromToken:(id<ANTLRToken>)startIndex ToToken:(id<ANTLRToken>)stopIndex;
-- (void) fill;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBufferedTokenStream.m b/runtime/ObjC/Framework/ANTLRBufferedTokenStream.m
deleted file mode 100644
index 94802b5..0000000
--- a/runtime/ObjC/Framework/ANTLRBufferedTokenStream.m
+++ /dev/null
@@ -1,392 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRBufferedTokenStream.h"
-#import "ANTLRTokenSource.h"
-#import "ANTLRCommonTreeAdaptor.h"
-#import "ANTLRRuntimeException.h"
-
-extern NSInteger debug;
-
-@implementation ANTLRBufferedTokenStream
-
-@synthesize tokenSource;
-@synthesize tokens;
-@synthesize lastMarker;
-@synthesize index;
-@synthesize range;
-
-+ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStream
-{
-    return [[ANTLRBufferedTokenStream alloc] init];
-}
-
-+ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStreamWith:(id<ANTLRTokenSource>)aSource
-{
-    return [[ANTLRBufferedTokenStream alloc] initWithTokenSource:aSource];
-}
-
-- (ANTLRBufferedTokenStream *) init
-{
-	if ((self = [super init]) != nil)
-	{
-        tokenSource = nil;
-        tokens = [[AMutableArray arrayWithCapacity:1000] retain];
-        index = -1;
-        range = -1;
-	}
-	return self;
-}
-
--(id) initWithTokenSource:(id<ANTLRTokenSource>)aSource
-{
-	if ((self = [super init]) != nil)
-	{
-        tokenSource = [aSource retain];
-        tokens = [[AMutableArray arrayWithCapacity:1000] retain];
-        index = -1;
-        range = -1;
-	}
-	return self;
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRBufferedTokenStream *copy;
-
-    copy = [[[self class] allocWithZone:aZone] init];
-    copy.tokenSource = self.tokenSource;
-    if ( self.tokens )
-        copy.tokens = [tokens copyWithZone:aZone];
-    copy.lastMarker = self.lastMarker;
-    copy.index = self.index;
-    copy.range = self.range;
-    return copy;
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRBufferedTokenStream" );
-#endif
-    if ( tokens ) [tokens release];
-    if ( tokenSource ) [tokenSource release];
-	[super dealloc];
-}
-
-- (NSUInteger)line
-{
-    return ((ANTLRCommonToken *)[tokens objectAtIndex:index]).line;
-}
-
-- (NSUInteger)charPositionInLine
-{
-    return ((ANTLRCommonToken *)[tokens objectAtIndex:index]).charPositionInLine;
-}
-
-- (id<ANTLRTokenSource>) getTokenSource
-{
-    return tokenSource;
-}
-
-- (NSInteger) getRange
-{
-    return range;
-}
-
-- (void) setRange:(NSInteger)anInt
-{
-    range = anInt;
-}
-
-- (NSInteger) mark
-{
-    if ( index == -1 ) {
-        [self setup];
-//        [self fill];
-    }
-    lastMarker = self.index;
-    return lastMarker;
-}
-
-- (void) release:(NSInteger) marker
-{
-    // no resources to release
-}
-
-- (void) rewind:(NSInteger) marker
-{
-    [self seek:marker];
-}
-
-- (void) rewind
-{
-    [self seek:lastMarker];
-}
-
-- (void) reset
-{
-    index = 0;
-    lastMarker = 0;
-}
-
-- (void) seek:(NSInteger) anIndex
-{
-    index = anIndex;
-}
-
-- (NSInteger) size
-{
-    return [tokens count];
-}
-
-/** Move the input pointer to the next incoming token.  The stream
- *  must become active with LT(1) available.  consume() simply
- *  moves the input pointer so that LT(1) points at the next
- *  input symbol. Consume at least one token.
- *
- *  Walk past any token not on the channel the parser is listening to.
- */
-- (void) consume
-{
-    if ( index == -1 ) {
-        [self setup];
-//        [self fill];
-    }
-    index++;
-    [self sync:index];
-}
-
-/** Make sure index i in tokens has a token. */
-- (void) sync:(NSInteger) i
-{
-    // how many more elements we need?
-    NSInteger n = (i - [tokens count]) + 1;
-    if (debug > 1) NSLog(@"[self sync:%d] needs %d\n", i, n);
-    if ( n > 0 )
-        [self fetch:n];
-}
-
-/** add n elements to buffer */
-- (void) fetch:(NSInteger)n
-{
-    for (NSInteger i=1; i <= n; i++) {
-        id<ANTLRToken> t = [tokenSource nextToken];
-        [t setTokenIndex:[tokens count]];
-        if (debug > 1) NSLog(@"adding %@ at index %d\n", [t text], [tokens count]);
-        [tokens addObject:t];
-        if ( t.type == ANTLRTokenTypeEOF )
-            break;
-    }
-}
-
-- (id<ANTLRToken>) getToken:(NSInteger) i
-{
-    if ( i < 0 || i >= [tokens count] ) {
-        @throw [ANTLRNoSuchElementException newException:[NSString stringWithFormat:@"token index %d out of range 0..%d", i, [tokens count]-1]];
-    }
-    return [tokens objectAtIndex:i];
-}
-
-/** Get all tokens from start..stop inclusively */
-- (AMutableArray *)getFrom:(NSInteger)startIndex To:(NSInteger)stopIndex
-{
-    if ( startIndex < 0 || stopIndex < 0 )
-        return nil;
-    if ( index == -1 ) {
-        [self setup];
-//        [self fill];
-    }
-    AMutableArray *subset = [AMutableArray arrayWithCapacity:5];
-    if ( stopIndex >= [tokens count] )
-        stopIndex = [tokens count]-1;
-    for (NSInteger i = startIndex; i <= stopIndex; i++) {
-        id<ANTLRToken>t = [tokens objectAtIndex:i];
-        if ( t.type == ANTLRTokenTypeEOF )
-            break;
-        [subset addObject:t];
-    }
-    return subset;
-}
-
-- (NSInteger) LA:(NSInteger)i
-{
-    return [[self LT:i] type];
-}
-
-- (id<ANTLRToken>) LB:(NSInteger)k
-{
-    if ( (index - k) < 0 )
-        return nil;
-    return [tokens objectAtIndex:(index-k)];
-}
-
-- (id<ANTLRToken>) LT:(NSInteger)k
-{
-    if ( index == -1 ) {
-        [self setup];
-//        [self fill];
-    }
-    if ( k == 0 )
-        return nil;
-    if ( k < 0 )
-        return [self LB:-k];
-
-    NSInteger i = index + k - 1;
-    [self sync:i];
-    if ( i >= [tokens count] ) { // return EOF token
-                                // EOF must be last token
-        return [tokens objectAtIndex:([tokens count]-1)];
-    }
-    if ( i > range )
-        range = i;
-    return [tokens objectAtIndex:i];
-}
-
-- (void) setup
-{
-    [self sync:0];
-    index = 0;
-}
-
-/** Reset this token stream by setting its token source. */
-- (void) setTokenSource:(id<ANTLRTokenSource>) aTokenSource
-{
-    tokenSource = aTokenSource;
-    if ( [tokens count] )
-        [tokens removeAllObjects];
-    index = -1;
-}
-
-- (AMutableArray *)getTokens
-{
-    return tokens;
-}
-
-- (AMutableArray *)getTokensFrom:(NSInteger) startIndex To:(NSInteger) stopIndex
-{
-    return [self getTokensFrom:startIndex To:stopIndex With:(ANTLRBitSet *)nil];
-}
-
-/** Given a start and stop index, return a List of all tokens in
- *  the token type BitSet.  Return null if no tokens were found.  This
- *  method looks at both on and off channel tokens.
- */
-- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex With:(ANTLRBitSet *)types
-{
-    if ( index == -1 ) {
-        [self setup];
-//        [self fill];
-    }
-    if ( stopIndex >= [tokens count] )
-        stopIndex = [tokens count]-1;
-    if ( startIndex < 0 )
-        startIndex = 0;
-    if ( startIndex > stopIndex )
-        return nil;
-
-    // list = tokens[start:stop]:{Token t, t.getType() in types}
-    AMutableArray *filteredTokens = [AMutableArray arrayWithCapacity:5];
-    for (NSInteger i = startIndex; i <= stopIndex; i++) {
-        id<ANTLRToken>t = [tokens objectAtIndex:i];
-        if ( types == nil || [types member:t.type] ) {
-            [filteredTokens addObject:t];
-        }
-    }
-    if ( [filteredTokens count] == 0 ) {
-        filteredTokens = nil;
-    }
-    return filteredTokens;
-}
-
-- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithType:(NSInteger)ttype
-{
-    return [self getTokensFrom:startIndex To:stopIndex With:[ANTLRBitSet of:ttype]];
-}
-
-- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithList:(AMutableArray *)types
-{
-    return [self getTokensFrom:startIndex To:stopIndex With:[ANTLRBitSet newANTLRBitSetWithArray:types]];
-}
-
-- (NSString *)getSourceName
-{
-    return [tokenSource getSourceName];
-}
-
-/** Grab *all* tokens from stream and return string */
-- (NSString *) toString
-{
-    if ( index == -1 ) {
-        [self setup];
-    }
-    [self fill];
-    return [self toStringFromStart:0 ToEnd:[tokens count]-1];
-}
-
-- (NSString *) toStringFromStart:(NSInteger)startIdx ToEnd:(NSInteger)stopIdx
-{
-    if ( startIdx < 0 || stopIdx < 0 )
-        return nil;
-    if ( index == -1 ) {
-        [self setup];
-    }
-    if ( stopIdx >= [tokens count] )
-        stopIdx = [tokens count]-1;
-    NSMutableString *buf = [NSMutableString stringWithCapacity:5];
-    for (NSInteger i = startIdx; i <= stopIdx; i++) {
-        id<ANTLRToken>t = [tokens objectAtIndex:i];
-        if ( t.type == ANTLRTokenTypeEOF )
-            break;
-        [buf appendString:[t text]];
-    }
-    return buf;
-}
-
-- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken
-{
-    if ( startToken != nil && stopToken != nil ) {
-        return [self toStringFromStart:[startToken getTokenIndex] ToEnd:[stopToken getTokenIndex]];
-    }
-    return nil;
-}
-
-/** Get all tokens from lexer until EOF */
-- (void) fill
-{
-    if ( index == -1 ) [self setup];
-    if ( [((ANTLRCommonToken *)[tokens objectAtIndex:index]) type] == ANTLRTokenTypeEOF )
-        return;
-
-    NSInteger i = index+1;
-    [self sync:i];
-    while ( [((ANTLRCommonToken *)[tokens objectAtIndex:i]) type] != ANTLRTokenTypeEOF ) {
-        i++;
-        [self sync:i];
-    }
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.h b/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.h
deleted file mode 100644
index 07555a5..0000000
--- a/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.h
+++ /dev/null
@@ -1,157 +0,0 @@
-//
-//  ANTLRBufferedTreeNodeStream.h
-//  ANTLR
-//
-// [The "BSD licence"]
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTree.h"
-#import "ANTLRCommonTreeAdaptor.h"
-#import "ANTLRTokenStream.h"
-#import "ANTLRCommonTreeNodeStream.h"
-#import "ANTLRLookaheadStream.h"
-#import "ANTLRTreeIterator.h"
-#import "ANTLRIntArray.h"
-#import "AMutableArray.h"
-
-#define DEFAULT_INITIAL_BUFFER_SIZE 100
-#define INITIAL_CALL_STACK_SIZE 10
-
-#ifdef DONTUSENOMO
-@interface ANTLRStreamIterator : ANTLRTreeIterator
-{
-    NSInteger idx;
-    __strong ANTLRBufferedTreeNodeStream *input;
-    __strong AMutableArray *nodes;
-}
-
-+ (id) newANTLRStreamIterator:(ANTLRBufferedTreeNodeStream *) theStream;
-
-- (id) initWithStream:(ANTLRBufferedTreeNodeStream *) theStream;
-
-- (BOOL) hasNext;
-- (id) next;
-- (void) remove;
-@end
-#endif
-
-@interface ANTLRBufferedTreeNodeStream : NSObject <ANTLRTreeNodeStream>
-{
-	id up;
-	id down;
-	id eof;
-
-	AMutableArray *nodes;
-
-	id root; // root
-
-	id<ANTLRTokenStream> tokens;
-	ANTLRCommonTreeAdaptor *adaptor;
-
-	BOOL uniqueNavigationNodes;
-	NSInteger index;
-	NSInteger lastMarker;
-	ANTLRIntArray *calls;
-
-	NSEnumerator *e;
-    id currentSymbol;
-
-}
-
-@property (retain, getter=getUp, setter=setUp:) id up;
-@property (retain, getter=getDown, setter=setDown:) id down;
-@property (retain, getter=eof, setter=setEof:) id eof;
-@property (retain, getter=getNodes, setter=setNodes:) AMutableArray *nodes;
-@property (retain, getter=getTreeSource, setter=setTreeSource:) id root;
-@property (retain, getter=getTokenStream, setter=setTokenStream:) id<ANTLRTokenStream> tokens;
-@property (retain, getter=getAdaptor, setter=setAdaptor:) ANTLRCommonTreeAdaptor *adaptor;
-@property (assign, getter=getUniqueNavigationNodes, setter=setUniqueNavigationNodes:) BOOL uniqueNavigationNodes;
-@property (assign) NSInteger index;
-@property (assign, getter=getLastMarker, setter=setLastMarker:) NSInteger lastMarker;
-@property (retain, getter=getCalls, setter=setCalls:) ANTLRIntArray *calls;
-@property (retain, getter=getEnum, setter=setEnum:) NSEnumerator *e;
-@property (retain, getter=getCurrentSymbol, setter=setCurrentSymbol:) id currentSymbol;
-
-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(ANTLRCommonTree *)tree;
-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)tree;
-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)tree withBufferSize:(NSInteger)initialBufferSize;
-
-#pragma mark Constructor
-- (id) initWithTree:(ANTLRCommonTree *)tree;
-- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)tree;
-- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)tree WithBufferSize:(NSInteger)bufferSize;
-
-- (void)dealloc;
-- (id) copyWithZone:(NSZone *)aZone;
-
-// protected methods. DO NOT USE
-#pragma mark Protected Methods
-- (void) fillBuffer;
-- (void) fillBufferWithTree:(ANTLRCommonTree *) tree;
-- (NSInteger) getNodeIndex:(ANTLRCommonTree *) node;
-- (void) addNavigationNode:(NSInteger) type;
-- (id) getNode:(NSUInteger) i;
-- (id) LT:(NSInteger) k;
-- (id) getCurrentSymbol;
-- (id) LB:(NSInteger) i;
-#pragma mark General Methods
-- (NSString *) getSourceName;
-
-- (id<ANTLRTokenStream>) getTokenStream;
-- (void) setTokenStream:(id<ANTLRTokenStream>) tokens;
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>) anAdaptor;
-
-- (BOOL)getUniqueNavigationNodes;
-- (void) setUniqueNavigationNodes:(BOOL)aVal;
-
-- (void) consume;
-- (NSInteger) LA:(NSInteger) i;
-- (NSInteger) mark;
-- (void) release:(NSInteger) marker;
-- (void) rewind:(NSInteger) marker;
-- (void) rewind;
-- (void) seek:(NSInteger) idx;
-
-- (void) push:(NSInteger) i;
-- (NSInteger) pop;
-
-- (void) reset;
-- (NSUInteger) count;
-- (NSEnumerator *) objectEnumerator;
-- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
-
-- (NSString *) toTokenTypeString;
-- (NSString *) toTokenString:(NSInteger)aStart ToEnd:(NSInteger)aStop;
-- (NSString *) toStringFromNode:(id)aStart ToNode:(id)aStop;
-
-// getters and setters
-- (AMutableArray *) getNodes;
-- (id) eof;
-- (void)setEof:(id)anEOF;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.m
deleted file mode 100644
index a8f73d8..0000000
--- a/runtime/ObjC/Framework/ANTLRBufferedTreeNodeStream.m
+++ /dev/null
@@ -1,556 +0,0 @@
-//
-//  ANTLRBufferedTreeNodeStream.m
-//  ANTLR
-//
-// [The "BSD licence"]
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRBufferedTreeNodeStream.h"
-#import "ANTLRStreamEnumerator.h"
-#import "ANTLRCommonTreeAdaptor.h"
-
-extern NSInteger debug;
-
-#ifdef DONTUSENOMO
-@implementation ANTLRTreeStreamIterator
-+ newANTLRTreeStreamIteratorWithNodes:(ANTLRBufferedTreeNodeStream *)theStream
-{
-    return[[ANTLRTreeStreamIterator alloc] initWithStream:theStream];
-}
-
-- (id) initWithStream:(ANTLRBufferedTreeNodeStream *)theStream
-{
-    if ((self = [super init]) != nil) {
-        idx = 0;
-        input = theStream;
-        nodes = [theStream getNodes];
-    }
-    return self;
-}
-
-- (BOOL) hasNext
-{
-    return idx < [nodes count];
-}
-
-- (id) next
-{
-    NSInteger current = idx;
-    idx++;
-    if (current < [nodes count]) {
-    }
-    return [nodes getEof];
-}
-
-- (void) remove
-{
-	@throw [ANTLRRuntimeException newException:@"cannot remove nodes from stream"];
-}
-
-@end
-#endif
-
-@implementation ANTLRBufferedTreeNodeStream
-
-@synthesize up;
-@synthesize down;
-@synthesize eof;
-@synthesize nodes;
-@synthesize root;
-@synthesize tokens;
-@synthesize adaptor;
-@synthesize uniqueNavigationNodes;
-@synthesize index;
-@synthesize lastMarker;
-@synthesize calls;
-@synthesize e;
-@synthesize currentSymbol;
-
-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(ANTLRCommonTree *) aTree
-{
-    return [((ANTLRBufferedTreeNodeStream *)[ANTLRBufferedTreeNodeStream alloc]) initWithTree:(ANTLRCommonTree *)aTree];
-}
-
-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)aTree
-{
-    return [[ANTLRBufferedTreeNodeStream alloc] initWithTreeAdaptor:adaptor Tree:(ANTLRCommonTree *)aTree];
-}
-
-+ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)aTree withBufferSize:(NSInteger)initialBufferSize
-{
-    return [[ANTLRBufferedTreeNodeStream alloc] initWithTreeAdaptor:adaptor Tree:(ANTLRCommonTree *)aTree WithBufferSize:initialBufferSize];
-}
-
--(ANTLRBufferedTreeNodeStream *) init
-{
-	self = [super init];
-	if (self) {
-		index = -1;
-		uniqueNavigationNodes = NO;
-        root = [[ANTLRCommonTree alloc] init];
-        //		tokens = tree;
-        adaptor = [[[ANTLRCommonTreeAdaptor alloc] init] retain];
-        nodes = [[AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE] retain];
-        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-    }
-	return self;
-}
-
-- (ANTLRBufferedTreeNodeStream *)initWithTree:(ANTLRCommonTree *) aTree
-{
-	self = [super init];
-	if (self) {
-		index = -1;
-		uniqueNavigationNodes = NO;
-        root = aTree;
-        //		tokens = aTree;
-        adaptor = [[[ANTLRCommonTreeAdaptor alloc] init] retain];
-        nodes = [[AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE] retain];
-        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-    }
-	return self;
-}
-
--(ANTLRBufferedTreeNodeStream *) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)aTree
-{
-	self = [super init];
-	if (self) {
-		index = -1;
-		uniqueNavigationNodes = NO;
-        root = aTree;
-        //		tokens = aTree;
-        adaptor = [anAdaptor retain];
-        nodes = [[AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE] retain];
-        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-    }
-	return self;
-}
-
--(ANTLRBufferedTreeNodeStream *) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)aTree WithBufferSize:(NSInteger)bufferSize
-{
-	self = [super init];
-	if (self) {
-        //		down = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"DOWN"];
-        //		up = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"UP"];
-        //		eof = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"EOF"];
-		index = -1;
-		uniqueNavigationNodes = NO;
-        root = aTree;
-        //		tokens = aTree;
-        adaptor = [anAdaptor retain];
-        nodes = [[AMutableArray arrayWithCapacity:bufferSize] retain];
-        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-	}
-	return self;
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRBufferedTreeNodeStream" );
-#endif
-    if ( adaptor ) [adaptor release];
-    if ( nodes ) [nodes release];
-    if ( root ) [root release];
-    if ( down ) [down release];
-    if ( up ) [up release];
-    if ( eof ) [eof release];
-	[super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRBufferedTreeNodeStream *copy;
-
-    copy = [[[self class] allocWithZone:aZone] init];
-    if ( up )
-        copy.up = [up copyWithZone:aZone];
-    if ( down )
-        copy.down = [down copyWithZone:aZone];
-    if ( eof )
-        copy.eof = [eof copyWithZone:aZone];
-    if ( nodes )
-        copy.nodes = [nodes copyWithZone:aZone];
-    if ( root )
-        copy.root = [root copyWithZone:aZone];
-    if ( tokens )
-        copy.tokens = [tokens copyWithZone:aZone];
-    if ( adaptor )
-        copy.adaptor = [adaptor copyWithZone:aZone];
-    copy.uniqueNavigationNodes = self.uniqueNavigationNodes;
-    copy.index = self.index;
-    copy.lastMarker = self.lastMarker;
-    if ( calls )
-        copy.calls = [calls copyWithZone:aZone];
-    return copy;
-}
-
-// protected methods. DO NOT USE
-#pragma mark Protected Methods
--(void) fillBuffer
-{
-	[self fillBufferWithTree:root];
-	// if (debug > 1) NSLog("revIndex=%@", tokenTypeToStreamIndexesMap);
-	index = 0; // buffer of nodes intialized now
-}
-
--(void) fillBufferWithTree:(ANTLRCommonTree *) aTree
-{
-	BOOL empty = [adaptor isNil:aTree];
-	if (!empty) {
-		[nodes addObject:aTree];
-	}
-	NSInteger n = [adaptor getChildCount:aTree];
-	if (!empty && n > 0) {
-		[self addNavigationNode:ANTLRTokenTypeDOWN];
-	}
-	for (NSInteger c = 0; c < n; c++) {
-		id child = [adaptor getChild:aTree At:c];
-		[self fillBufferWithTree:child];
-	}
-	if (!empty && n > 0) {
-		[self addNavigationNode:ANTLRTokenTypeUP];
-	}
-}
-
--(NSInteger) getNodeIndex:(ANTLRCommonTree *) node
-{
-	if (index == -1) {
-		[self fillBuffer];
-	}
-	for (NSUInteger i = 0; i < [nodes count]; i++) {
-		id t = [nodes objectAtIndex:i];
-		if (t == node) {
-			return i;
-		}
-	}
-	return -1;
-}
-
--(void) addNavigationNode:(NSInteger) type
-{
-	id navNode = nil;
-	if (type == ANTLRTokenTypeDOWN) {
-		if (self.uniqueNavigationNodes) {
-			navNode = [adaptor createToken:ANTLRTokenTypeDOWN Text:@"DOWN"];
-		}
-		else {
-			navNode = down;
-		}
-
-	}
-	else {
-		if (self.uniqueNavigationNodes) {
-			navNode = [adaptor createToken:ANTLRTokenTypeUP Text:@"UP"];
-		}
-		else {
-			navNode = up;
-		}
-	}
-	[nodes addObject:navNode];
-}
-
--(id) getNode:(NSUInteger) i
-{
-	if (index == -1) {
-		[self fillBuffer];
-	}
-	return [nodes objectAtIndex:i];
-}
-
--(id) LT:(NSInteger) k
-{
-	if (index == -1) {
-		[self fillBuffer];
-	}
-	if (k == 0) {
-		return nil;
-	}
-	if (k < 0) {
-		return [self LB:-k];
-	}
-	if ((index + k - 1) >= [nodes count]) {
-		return eof;
-	}
-	return [nodes objectAtIndex:(index + k - 1)];
-}
-
--(id) getCurrentSymbol
-{
-	return [self LT:1];
-}
-
--(id) LB:(NSInteger) k
-{
-	if (k == 0) {
-		return nil;
-	}
-	if ((index - k) < 0) {
-		return nil;
-	}
-	return [nodes objectAtIndex:(index - k)];
-}
-
-- (ANTLRCommonTree *)getTreeSource
-{
-    return root;
-}
-
--(NSString *)getSourceName
-{
-	return [[self getTokenStream] getSourceName];
-}
-
-- (id<ANTLRTokenStream>)getTokenStream
-{
-    return tokens;
-}
-
-- (void) setTokenStream:(id<ANTLRTokenStream>)newtokens
-{
-    tokens = newtokens;
-}
-
-- (id<ANTLRTreeAdaptor>)getTreeAdaptor
-{
-    return adaptor;
-}
-
-- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    adaptor = anAdaptor;
-}
-
-- (BOOL)getUniqueNavigationNodes
-{
-    return uniqueNavigationNodes;
-}
-
-- (void) setUniqueNavigationNodes:(BOOL)aVal
-{
-    uniqueNavigationNodes = aVal;
-}
-
--(void) consume
-{
-	if (index == -1) {
-		[self fillBuffer];
-	}
-	index++;
-}
-
--(NSInteger) LA:(NSInteger) i
-{
-	return [adaptor getType:[self LT:i]];
-}
-
--(NSInteger) mark
-{
-	if (index == -1) {
-		[self fillBuffer];
-	}
-	lastMarker = self.index;
-	return lastMarker;
-}
-
--(void) release:(NSInteger) marker
-{
-	// do nothing
-}
-
--(void) rewind:(NSInteger) marker
-{
-	[self seek:marker];
-}
-
--(void) rewind
-{
-	[self seek:lastMarker];
-}
-
--(void) seek:(NSInteger) i
-{
-	if (index == -1) {
-		[self fillBuffer];
-	}
-	index = i;
-}
-
--(void) push:(NSInteger) i
-{
-	if (calls == nil) {
-		calls = [ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE];
-	}
-	[calls push:index];
-	[self seek:i];
-}
-
--(NSInteger) pop
-{
-	NSInteger ret = [calls pop];
-	[self seek:ret];
-	return ret;
-}
-
--(void) reset
-{
-	index = 0;
-	lastMarker = 0;
-	if (calls != nil) {
-		[calls reset];
-	}
-}
-
--(NSUInteger) count
-{
-	if (index == -1) {
-		[self fillBuffer];
-	}
-	return [nodes count];
-}
-
--(NSUInteger) size
-{
-	return [self count];
-}
-
--(NSEnumerator *) objectEnumerator
-{
-	if (e == nil) {
-		e = [[ANTLRStreamEnumerator alloc] initWithNodes:nodes andEOF:eof];
-	}
-	return e;
-}
-
--(void) replaceChildren:(ANTLRCommonTree *) parent From:(NSInteger)startIdx To:(NSInteger)stopIdx With:(ANTLRCommonTree *)aTree
-{
-	if (parent != nil) {
-		[adaptor replaceChildren:parent From:startIdx To:stopIdx With:aTree];
-	}
-}
-
--(NSString *) toTokenTypeString
-{
-	if (index == -1)
-	{
-		[self fillBuffer];
-	}
-	NSMutableString *buf = [NSMutableString stringWithCapacity:10];
-	for (NSUInteger i= 0; i < [nodes count]; i++) {
-		ANTLRCommonTree * aTree = (ANTLRCommonTree *)[self getNode:i];
-		[buf appendFormat:@" %d", [adaptor getType:aTree]];
-	}
-	return buf;
-}
-
--(NSString *) toTokenString:(NSInteger)aStart ToEnd:(NSInteger)aStop
-{
-	if (index == -1) {
-		[self fillBuffer];
-	}
-	NSMutableString *buf = [NSMutableString stringWithCapacity:10];
-	for (NSUInteger i = aStart; i < [nodes count] && i <= aStop; i++) {
-		ANTLRCommonTree * t = (ANTLRCommonTree *)[self getNode:i];
-		[buf appendFormat:@" %d", [adaptor getType:t]];
-	}
-	return buf;
-}
-
--(NSString *) toStringFromNode:(id)aStart ToNode:(id)aStop
-{
-	if (aStart == nil || aStop == nil) {
-		return nil;
-	}
-	if (index == -1) {
-		[self fillBuffer];
-	}
-
-	// if we have a token stream, use that to dump text in order
-	if ([self getTokenStream] != nil) {
-		NSInteger beginTokenIndex = [adaptor getTokenStartIndex:aStart];
-		NSInteger endTokenIndex = [adaptor getTokenStopIndex:aStop];
-
-		if ([adaptor getType:aStop] == ANTLRTokenTypeUP) {
-			endTokenIndex = [adaptor getTokenStopIndex:aStart];
-		}
-		else if ([adaptor getType:aStop] == ANTLRTokenTypeEOF) {
-			endTokenIndex = [self count] - 2; //don't use EOF
-		}
-        [tokens toStringFromStart:beginTokenIndex ToEnd:endTokenIndex];
-	}
-	// walk nodes looking for aStart
-	ANTLRCommonTree * aTree = nil;
-	NSUInteger i = 0;
-	for (; i < [nodes count]; i++) {
-		aTree = [nodes objectAtIndex:i];
-		if (aTree == aStart) {
-			break;
-		}
-	}
-	NSMutableString *buf = [NSMutableString stringWithCapacity:10];
-	aTree = [nodes objectAtIndex:i]; // why?
-	while (aTree != aStop) {
-		NSString *text = [adaptor getText:aTree];
-		if (text == nil) {
-			text = [NSString stringWithFormat:@" %d", [adaptor getType:aTree]];
-		}
-		[buf appendString:text];
-		i++;
-		aTree = [nodes objectAtIndex:i];
-	}
-	NSString *text = [adaptor getText:aStop];
-	if (text == nil) {
-		text = [NSString stringWithFormat:@" %d", [adaptor getType:aStop]];
-	}
-	[buf appendString:text];
-	return buf;
-}
-
-// getters and setters
-- (AMutableArray *) getNodes
-{
-    return nodes;
-}
-
-- (id) eof
-{
-    return eof;
-}
-
-- (void) setEof:(id)theEOF
-{
-    eof = theEOF;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCharStream.h b/runtime/ObjC/Framework/ANTLRCharStream.h
deleted file mode 100644
index f7be94b..0000000
--- a/runtime/ObjC/Framework/ANTLRCharStream.h
+++ /dev/null
@@ -1,49 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRIntStream.h"
-
-#define	ANTLRCharStreamEOF -1
-
-
-@protocol ANTLRCharStream < ANTLRIntStream >
-
-- (NSString *) substringWithRange:(NSRange) theRange;
-
-/** Get the ith character of lookahead.  This is the same usually as
- *  LA(i).  This will be used for labels in the generated
- *  lexer code.  I'd prefer to return a char here type-wise, but it's
- *  probably better to be 32-bit clean and be consistent with LA.
- */
-- (NSInteger)LT:(NSInteger) i;
-
-// ANTLR tracks the line information automatically
-
-// Because this stream can rewind, we need to be able to reset the line
-
-// The index of the character relative to the beginning of the line 0..n-1
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCharStreamState.h b/runtime/ObjC/Framework/ANTLRCharStreamState.h
deleted file mode 100644
index 0cf872f..0000000
--- a/runtime/ObjC/Framework/ANTLRCharStreamState.h
+++ /dev/null
@@ -1,49 +0,0 @@
-//
-//  ANTLRCharStreamState.h
-//  ANTLR
-//
-// [The "BSD licence"]
-// Copyright (c)  2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-
-
-@interface ANTLRCharStreamState : NSObject
-{
-NSInteger index;
-NSUInteger line;
-NSUInteger charPositionInLine;
-}
-
-@property (assign) NSInteger index;
-@property (assign) NSUInteger line;
-@property (assign) NSUInteger charPositionInLine;
-
-+ newANTLRCharStreamState;
-
-- (id) init;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCharStreamState.m b/runtime/ObjC/Framework/ANTLRCharStreamState.m
deleted file mode 100755
index b2a7e3a..0000000
--- a/runtime/ObjC/Framework/ANTLRCharStreamState.m
+++ /dev/null
@@ -1,52 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRCharStreamState.h"
-
-
-@implementation ANTLRCharStreamState
-
-@synthesize index;
-@synthesize line;
-@synthesize charPositionInLine;
-
-+ newANTLRCharStreamState
-{
-    return [[ANTLRCharStreamState alloc] init];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil) {
-        index = 0;
-        line = 1;
-        charPositionInLine = 0;
-    }
-    return self;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonErrorNode.h b/runtime/ObjC/Framework/ANTLRCommonErrorNode.h
deleted file mode 100644
index d01af00..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonErrorNode.h
+++ /dev/null
@@ -1,67 +0,0 @@
-//
-//  ANTLRCommonErrorNode.h
-//  ANTLR
-//
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRCommonTree.h"
-#import "ANTLRTokenStream.h"
-//#import "ANTLRIntStream.h"
-//#import "ANTLRToken.h"
-#import "ANTLRUnWantedTokenException.h"
-
-@interface ANTLRCommonErrorNode : ANTLRCommonTree
-{
-id<ANTLRIntStream> input;
-id<ANTLRToken> startToken;
-id<ANTLRToken> stopToken;
-ANTLRRecognitionException *trappedException;
-}
-
-+ (id) newANTLRCommonErrorNode:(id<ANTLRTokenStream>)anInput
-                  From:(id<ANTLRToken>)startToken
-                    To:(id<ANTLRToken>)stopToken
-                     Exception:(ANTLRRecognitionException *) e;
-
-- (id) initWithInput:(id<ANTLRTokenStream>)anInput
-                From:(id<ANTLRToken>)startToken
-                  To:(id<ANTLRToken>)stopToken
-           Exception:(ANTLRRecognitionException *) e;
-
-- (void)dealloc;
-- (BOOL) isNil;
-
-- (NSInteger)type;
-- (NSString *)text;
-- (NSString *)toString;
-
-@property (retain) id<ANTLRIntStream> input;
-@property (retain) id<ANTLRToken> startToken;
-@property (retain) id<ANTLRToken> stopToken;
-@property (retain) ANTLRRecognitionException *trappedException;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonErrorNode.m b/runtime/ObjC/Framework/ANTLRCommonErrorNode.m
deleted file mode 100644
index 17fec33..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonErrorNode.m
+++ /dev/null
@@ -1,159 +0,0 @@
-//
-//  ANTLRCommonErrorNode.m
-//  ANTLR
-//
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRCommonErrorNode.h"
-#import "ANTLRMissingTokenException.h"
-#import "ANTLRNoViableAltException.h"
-#import "ANTLRTreeNodeStream.h"
-#import "ANTLRUnwantedTokenException.h"
-
-@implementation ANTLRCommonErrorNode
-
-+ (id) newANTLRCommonErrorNode:(id<ANTLRTokenStream>)anInput
-                          From:(id<ANTLRToken>)aStartToken
-                            To:(id<ANTLRToken>)aStopToken
-                     Exception:(ANTLRRecognitionException *) e
-{
-    return [[ANTLRCommonErrorNode alloc] initWithInput:anInput From:aStartToken To:aStopToken Exception:e];
-}
-
-- (id) init
-{
-    self = [super init];
-    if ( self != nil ) {
-    }
-    return self;
-}
-
-- (id) initWithInput:(id<ANTLRTokenStream>)anInput
-                From:(id<ANTLRToken>)aStartToken
-                  To:(id<ANTLRToken>)aStopToken
-           Exception:(ANTLRRecognitionException *) e
-{
-    self = [super init];
-    if ( self != nil ) {
-        //System.out.println("aStartToken: "+aStartToken+", aStopToken: "+aStopToken);
-        if ( aStopToken == nil ||
-            ([aStopToken getTokenIndex] < [aStartToken getTokenIndex] &&
-             aStopToken.type != ANTLRTokenTypeEOF) )
-        {
-            // sometimes resync does not consume a token (when LT(1) is
-            // in follow set.  So, aStopToken will be 1 to left to aStartToken. adjust.
-            // Also handle case where aStartToken is the first token and no token
-            // is consumed during recovery; LT(-1) will return null.
-            aStopToken = aStartToken;
-        }
-        input = anInput;
-        if ( input ) [input retain];
-        startToken = aStartToken;
-        if ( startToken ) [startToken retain];
-        stopToken = aStopToken;
-        if ( stopToken ) [stopToken retain];
-        trappedException = e;
-        if ( trappedException ) [trappedException retain];
-    }
-    return self;
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRCommonErrorNode" );
-#endif
-    if ( input ) [input release];
-    if ( startToken ) [startToken release];
-    if ( stopToken ) [stopToken release];
-    if ( trappedException ) [trappedException release];
-	[super dealloc];
-}
-
-- (BOOL) isNil
-{
-    return NO;
-}
-
-- (NSInteger)type
-{
-    return ANTLRTokenTypeInvalid;
-}
-
-- (NSString *)text
-{
-    NSString *badText = nil;
-    if ( [startToken isKindOfClass:[self class]] ) {
-        int i = [(id<ANTLRToken>)startToken getTokenIndex];
-        int j = [(id<ANTLRToken>)stopToken getTokenIndex];
-        if ( stopToken.type == ANTLRTokenTypeEOF ) {
-            j = [(id<ANTLRTokenStream>)input size];
-        }
-        badText = [(id<ANTLRTokenStream>)input toStringFromStart:i ToEnd:j];
-    }
-    else if ( [startToken isKindOfClass:[self class]] ) {
-        badText = [(id<ANTLRTreeNodeStream>)input toStringFromNode:startToken ToNode:stopToken];
-    }
-    else {
-        // people should subclass if they alter the tree type so this
-        // next one is for sure correct.
-        badText = @"<unknown>";
-    }
-    return badText;
-}
-
-- (NSString *)toString
-{
-    NSString *aString;
-    if ( [trappedException isKindOfClass:[ANTLRMissingTokenException class]] ) {
-        aString = [NSString stringWithFormat:@"<missing type: %@ >",
-        [(ANTLRMissingTokenException *)trappedException getMissingType]];
-        return aString;
-    }
-    else if ( [trappedException isKindOfClass:[ANTLRUnwantedTokenException class]] ) {
-        aString = [NSString stringWithFormat:@"<extraneous: %@, resync=%@>",
-        [trappedException getUnexpectedToken],
-        [self text]];
-        return aString;
-    }
-    else if ( [trappedException isKindOfClass:[ANTLRMismatchedTokenException class]] ) {
-        aString = [NSString stringWithFormat:@"<mismatched token: %@, resync=%@>", trappedException.token, [self text]];
-        return aString;
-    }
-    else if ( [trappedException isKindOfClass:[ANTLRNoViableAltException class]] ) {
-        aString = [NSString stringWithFormat:@"<unexpected:  %@, resync=%@>", trappedException.token, [self text]];
-        return aString;
-    }
-    aString = [NSString stringWithFormat:@"<error: %@>",[self text]];
-    return aString;
-}
-
-@synthesize input;
-@synthesize startToken;
-@synthesize stopToken;
-@synthesize trappedException;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonToken.h b/runtime/ObjC/Framework/ANTLRCommonToken.h
deleted file mode 100644
index 948e129..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonToken.h
+++ /dev/null
@@ -1,129 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRToken.h"
-#import "ANTLRCharStream.h"
-
-@interface ANTLRCommonToken : NSObject < ANTLRToken > {
-	__strong NSString *text;
-	NSInteger type;
-	// information about the Token's position in the input stream
-	NSUInteger line;
-	NSUInteger charPositionInLine;
-	NSUInteger channel;
-	// this token's position in the TokenStream
-	NSInteger index;
-
-	// indices into the CharStream to avoid copying the text
-	// can manually override the text by using -setText:
-	NSInteger startIndex;
-	NSInteger stopIndex;
-	// the actual input stream this token was found in
-	__strong id<ANTLRCharStream> input;
-}
-
-+ (void) initialize;
-+ (NSInteger) DEFAULT_CHANNEL;
-+ (id<ANTLRToken>)INVALID_TOKEN;
-+ (NSInteger) INVALID_TOKEN_TYPE;
-+ (id<ANTLRToken>) newToken;
-+ (id<ANTLRToken>) newToken:(id<ANTLRCharStream>)anInput
-                       Type:(NSInteger)aTType
-                    Channel:(NSInteger)aChannel
-                      Start:(NSInteger)aStart
-                       Stop:(NSInteger)aStop;
-+ (id<ANTLRToken>) newToken:(ANTLRTokenType)aType;
-+ (id<ANTLRToken>) newToken:(NSInteger)tokenType Text:(NSString *)tokenText;
-+ (id<ANTLRToken>) newTokenWithToken:(ANTLRCommonToken *)fromToken;
-+ (id<ANTLRToken>) eofToken;
-+ (id<ANTLRToken>) skipToken;
-+ (id<ANTLRToken>) invalidToken;
-+ (ANTLRTokenChannel) defaultChannel;
-
-// designated initializer. This is used as the default way to initialize a Token in the generated code.
-- (id) init;
-- (id) initWithInput:(id<ANTLRCharStream>)anInput
-                                Type:(NSInteger)aTType
-                             Channel:(NSInteger)aChannel
-                               Start:(NSInteger)theStart
-                                Stop:(NSInteger)theStop;
-- (id) initWithToken:(id<ANTLRToken>)aToken;
-- (id) initWithType:(ANTLRTokenType)aType;
-- (id) initWithType:(ANTLRTokenType)aTType Text:(NSString *)tokenText;
-
-//----------------------------------------------------------
-//  text
-//----------------------------------------------------------
-- (NSString *)text;
-- (void) setText:(NSString *)aText;
-
-//----------------------------------------------------------
-//  type
-//----------------------------------------------------------
-- (NSInteger)type;
-- (void) setType:(NSInteger)aType;
-
-//----------------------------------------------------------
-//  channel
-//----------------------------------------------------------
-- (NSUInteger)channel;
-- (void) setChannel:(NSUInteger)aChannel;
-
-//----------------------------------------------------------
-//  input
-//----------------------------------------------------------
-- (id<ANTLRCharStream>)input;
-- (void) setInput:(id<ANTLRCharStream>)anInput;
-
-- (NSInteger)getStart;
-- (void) setStart: (NSInteger)aStart;
-
-- (NSInteger)getStop;
-- (void) setStop: (NSInteger) aStop;
-
-// the index of this Token into the TokenStream
-- (NSInteger)getTokenIndex;
-- (void) setTokenIndex:(NSInteger)aTokenIndex;
-
-// conform to NSCopying
-- (id) copyWithZone:(NSZone *)theZone;
-
-- (NSString *) description;
-- (NSString *) toString;
-
-@property (retain, getter = text, setter = setText:) NSString *text;
-@property (assign) NSInteger type;
-@property (assign, getter = line, setter = setLine:) NSUInteger line;
-@property (assign, getter=charPositionInLine, setter = setCharPositionInLine:) NSUInteger charPositionInLine;
-@property (assign) NSUInteger channel;
-@property (assign) NSInteger index;
-@property (assign, getter=getStart, setter=setStart:) NSInteger startIndex;
-@property (assign, getter=getStop, setter=setStop:) NSInteger stopIndex;
-@property (retain) id<ANTLRCharStream> input;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonToken.m b/runtime/ObjC/Framework/ANTLRCommonToken.m
deleted file mode 100644
index ee0e018..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonToken.m
+++ /dev/null
@@ -1,397 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRCommonToken.h"
-
-static ANTLRCommonToken *SKIP_TOKEN;
-static ANTLRCommonToken *EOF_TOKEN;
-static ANTLRCommonToken *INVALID_TOKEN;
-
-@implementation ANTLRCommonToken
-
-    static NSInteger DEFAULT_CHANNEL = ANTLRTokenChannelDefault;
-    static NSInteger INVALID_TOKEN_TYPE = ANTLRTokenTypeInvalid;
-
-
-@synthesize text;
-@synthesize type;
-@synthesize line;
-@synthesize charPositionInLine;
-@synthesize channel;
-@synthesize index;
-@synthesize startIndex;
-@synthesize stopIndex;
-@synthesize input;
-
-+ (void) initialize
-{
-    EOF_TOKEN = [ANTLRCommonToken newToken:ANTLRTokenTypeEOF Text:@"EOF"];
-    SKIP_TOKEN = [ANTLRCommonToken newToken:ANTLRTokenTypeInvalid Text:@"Skip"];
-    INVALID_TOKEN = [ANTLRCommonToken newToken:ANTLRTokenTypeInvalid Text:@"Invalid"];
-    [EOF_TOKEN retain];
-    [SKIP_TOKEN retain];
-    [INVALID_TOKEN retain];
-}
-
-+ (ANTLRCommonToken *)INVALID_TOKEN
-{
-    return INVALID_TOKEN;
-}
-
-+ (NSInteger) DEFAULT_CHANNEL
-{
-    return DEFAULT_CHANNEL;
-}
-
-+ (NSInteger) INVALID_TOKEN_TYPE
-{
-    return INVALID_TOKEN_TYPE;
-}
-
-+ (ANTLRCommonToken *) newToken
-{
-    return [[ANTLRCommonToken alloc] init];
-}
-
-+ (ANTLRCommonToken *) newToken:(id<ANTLRCharStream>)anInput Type:(NSInteger)aTType Channel:(NSInteger)aChannel Start:(NSInteger)aStart Stop:(NSInteger)aStop
-{
-    return [[ANTLRCommonToken alloc] initWithInput:(id<ANTLRCharStream>)anInput Type:(NSInteger)aTType Channel:(NSInteger)aChannel Start:(NSInteger)aStart Stop:(NSInteger)aStop];
-}
-
-+ (ANTLRCommonToken *) newToken:(ANTLRTokenType)tokenType
-{
-    return( [[ANTLRCommonToken alloc] initWithType:tokenType] );
-}
-
-+ (ANTLRCommonToken *) newToken:(NSInteger)tokenType Text:(NSString *)tokenText
-{
-    return( [[ANTLRCommonToken alloc] initWithType:tokenType Text:tokenText] );
-}
-
-+ (ANTLRCommonToken *) newTokenWithToken:(ANTLRCommonToken *)fromToken
-{
-    return( [[ANTLRCommonToken alloc] initWithToken:fromToken] );
-}
-
-// return the singleton EOF Token
-+ (id<ANTLRToken>) eofToken
-{
-    if (EOF_TOKEN == nil) {
-        EOF_TOKEN = [[ANTLRCommonToken newToken:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-    }
-    return EOF_TOKEN;
-}
-
-// return the singleton skip Token
-+ (id<ANTLRToken>) skipToken
-{
-    if (SKIP_TOKEN == nil) {
-        SKIP_TOKEN = [[ANTLRCommonToken newToken:ANTLRTokenTypeInvalid Text:@"Skip"] retain];
-    }
-    return SKIP_TOKEN;
-}
-
-// return the singleton skip Token
-+ (id<ANTLRToken>) invalidToken
-{
-    if (INVALID_TOKEN == nil) {
-        INVALID_TOKEN = [[ANTLRCommonToken newToken:ANTLRTokenTypeInvalid Text:@"Invalid"] retain];
-    }
-    return SKIP_TOKEN;
-}
-
-// the default channel for this class of Tokens
-+ (ANTLRTokenChannel) defaultChannel
-{
-    return ANTLRTokenChannelDefault;
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil) {
-        input = nil;
-        type = ANTLRTokenTypeInvalid;
-        channel = ANTLRTokenChannelDefault;
-        startIndex = 0;
-        stopIndex = 0;
-    }
-    return self;
-}
-
-// designated initializer
-- (id) initWithInput:(id<ANTLRCharStream>)anInput
-                           Type:(NSInteger)aTType
-                             Channel:(NSInteger)aChannel
-                               Start:(NSInteger)aStart
-                                Stop:(NSInteger)aStop
-{
-    if ((self = [super init]) != nil) {
-        input = anInput;
-        if ( input ) [input retain];
-        type = aTType;
-        channel = aChannel;
-        startIndex = aStart;
-        stopIndex = aStop;
-        if (type == ANTLRTokenTypeEOF)
-            text = @"EOF";
-        else
-            text = [input substringWithRange:NSMakeRange(startIndex, (stopIndex-startIndex)+1)];
-        if ( text ) [text retain];
-    }
-    return self;
-}
-
-- (id) initWithToken:(ANTLRCommonToken *)oldToken
-{
-    if ((self = [super init]) != nil) {
-        text = [NSString stringWithString:oldToken.text];
-        if ( text ) [text retain];
-        type = oldToken.type;
-        line = oldToken.line;
-        index = oldToken.index;
-        charPositionInLine = oldToken.charPositionInLine;
-        channel = oldToken.channel;
-        input = oldToken.input;
-        if ( input ) [input retain];
-        if ( [oldToken isKindOfClass:[ANTLRCommonToken class]] ) {
-            startIndex = oldToken.startIndex;
-            stopIndex = oldToken.stopIndex;
-        }
-    }
-    return self;
-}
-
-- (id) initWithType:(ANTLRTokenType)aTType
-{
-    if ((self = [super init]) != nil) {
-        self.type = aTType;
-    }
-    return self;
-}
-
-- (id) initWithType:(ANTLRTokenType)aTType Text:(NSString *)tokenText
-{
-    if ((self = [super init]) != nil) {
-        self.type = aTType;
-        self.text = [NSString stringWithString:tokenText];
-        if ( text ) [text retain];
-    }
-    return self;
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRCommonToken" );
-#endif
-    if ( input ) [input release];
-    if ( text ) [text release];
-    [super dealloc];
-}
-
-// create a copy, including the text if available
-// the input stream is *not* copied!
-- (id) copyWithZone:(NSZone *)theZone
-{
-    ANTLRCommonToken *copy = [[[self class] allocWithZone:theZone] init];
-
-    if (text)
-        copy.text = [text copyWithZone:nil];
-    copy.type = type;
-    copy.line = line;
-    copy.charPositionInLine = charPositionInLine;
-    copy.channel = channel;
-    copy.index = index;
-    copy.startIndex = startIndex;
-    copy.stopIndex = stopIndex;
-    copy.input = input;
-    return copy;
-}
-
-
-//----------------------------------------------------------
-//  charPositionInLine
-//----------------------------------------------------------
-- (NSUInteger) charPositionInLine
-{
-    return charPositionInLine;
-}
-
-- (void) setCharPositionInLine:(NSUInteger)aCharPositionInLine
-{
-    charPositionInLine = aCharPositionInLine;
-}
-
-//----------------------------------------------------------
-//  line
-//----------------------------------------------------------
-- (NSUInteger) line
-{
-    return line;
-}
-
-- (void) setLine:(NSUInteger)aLine
-{
-    line = aLine;
-}
-
-//----------------------------------------------------------
-//  text
-//----------------------------------------------------------
-- (NSString *) text
-{
-    if (text != nil) {
-        return text;
-    }
-    if (input == nil) {
-        return nil;
-    }
-    return [input substringWithRange:NSMakeRange(startIndex, (stopIndex-startIndex)+1)];
-}
-
-- (void) setText:(NSString *)aText
-{
-    if (text != aText) {
-        if ( text ) [text release];
-        text = aText;
-        [text retain];
-    }
-}
-
-
-//----------------------------------------------------------
-//  type
-//----------------------------------------------------------
-- (NSInteger)type
-{
-    return type;
-}
-
-- (void) setType:(NSInteger)aType
-{
-    type = aType;
-}
-
-//----------------------------------------------------------
-//  channel
-//----------------------------------------------------------
-- (NSUInteger)channel
-{
-    return channel;
-}
-
-- (void) setChannel:(NSUInteger)aChannel
-{
-    channel = aChannel;
-}
-
-
-//----------------------------------------------------------
-//  input
-//----------------------------------------------------------
-- (id<ANTLRCharStream>) input
-{
-    return input;
-}
-
-- (void) setInput: (id<ANTLRCharStream>) anInput
-{
-    if (input != anInput) {
-        if ( input ) [input release];
-        [anInput retain];
-    }
-    input = anInput;
-}
-
-
-//----------------------------------------------------------
-//  start
-//----------------------------------------------------------
-- (NSInteger) getStart
-{
-    return startIndex;
-}
-
-- (void) setStart: (NSInteger) aStart
-{
-    startIndex = aStart;
-}
-
-//----------------------------------------------------------
-//  stop
-//----------------------------------------------------------
-- (NSInteger) getStop
-{
-    return stopIndex;
-}
-
-- (void) setStop: (NSInteger) aStop
-{
-    stopIndex = aStop;
-}
-
-//----------------------------------------------------------
-//  index
-//----------------------------------------------------------
-- (NSInteger) getTokenIndex;
-{
-    return index;
-}
-
-- (void) setTokenIndex: (NSInteger) aTokenIndex;
-{
-    index = aTokenIndex;
-}
-
-
-// provide a textual representation for debugging
-- (NSString *) description
-{
-    NSString *channelStr;
-    NSMutableString *txtString;
-
-    channelStr = @"";
-    if ( channel > 0 ) {
-        channelStr = [NSString stringWithFormat:@",channel=%d\n", channel];
-    }
-    if ([self text] != nil) {
-        txtString = [NSMutableString stringWithString:[self text]];
-        [txtString replaceOccurrencesOfString:@"\n" withString:@"\\\\n" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
-        [txtString replaceOccurrencesOfString:@"\r" withString:@"\\\\r" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
-        [txtString replaceOccurrencesOfString:@"\t" withString:@"\\\\t" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
-    } else {
-        txtString = [NSMutableString stringWithString:@"<no text>"];
-    }
-    return [NSString stringWithFormat:@"[@%d, %d:%d='%@',<%d>%@,%d:%d]", index, startIndex, stopIndex, txtString, type, channelStr, line, charPositionInLine];
-}
-
-- (NSString *)toString
-{
-   return [self description];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTokenStream.h b/runtime/ObjC/Framework/ANTLRCommonTokenStream.h
deleted file mode 100644
index c26130e..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonTokenStream.h
+++ /dev/null
@@ -1,95 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTokenStream.h"
-#import "ANTLRToken.h"
-#import "ANTLRCommonToken.h"
-#import "ANTLRTokenSource.h"
-#import "ANTLRBitSet.h"
-#import "ANTLRBufferedTokenStream.h"
-#import "AMutableDictionary.h"
-
-@interface ANTLRCommonTokenStream : ANTLRBufferedTokenStream < ANTLRTokenStream >
-{
-	__strong AMutableDictionary *channelOverride;
-	NSUInteger channel;
-}
-
-@property (retain, getter=getChannelOverride,setter=setChannelOverride:) AMutableDictionary *channelOverride;
-@property (assign, getter=channel,setter=setChannel:) NSUInteger channel;
-
-+ (ANTLRCommonTokenStream *)newANTLRCommonTokenStream;
-+ (ANTLRCommonTokenStream *)newANTLRCommonTokenStreamWithTokenSource:(id<ANTLRTokenSource>)theTokenSource;
-+ (ANTLRCommonTokenStream *)newANTLRCommonTokenStreamWithTokenSource:(id<ANTLRTokenSource>)theTokenSource
-                                                               Channel:(NSUInteger)aChannel;
-
-- (id) init;
-- (id) initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource;
-- (id) initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource Channel:(NSUInteger)aChannel;
-
-- (void) consume;
-- (id<ANTLRToken>) LB:(NSInteger)k;
-- (id<ANTLRToken>) LT:(NSInteger)k;
-
-- (NSInteger) skipOffChannelTokens:(NSInteger) i;
-- (NSInteger) skipOffChannelTokensReverse:(NSInteger) i;
-
-- (void)setup;
-
-- (NSInteger) getNumberOfOnChannelTokens;
-
-// - (id<ANTLRTokenSource>) getTokenSource;
-- (void) setTokenSource: (id<ANTLRTokenSource>) aTokenSource;
-
-- (NSUInteger)channel;
-- (void)setChannel:(NSUInteger)aChannel;
-
-- (AMutableDictionary *)channelOverride;
-- (void)setChannelOverride:(AMutableDictionary *)anOverride;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-#ifdef DONTUSENOMO
-- (NSArray *) tokensInRange:(NSRange)aRange;
-- (NSArray *) tokensInRange:(NSRange)aRange inBitSet:(ANTLRBitSet *)aBitSet;
-- (NSArray *) tokensInRange:(NSRange)aRange withTypes:(NSArray *)tokenTypes;
-- (NSArray *) tokensInRange:(NSRange)aRange withType:(NSInteger)tokenType;
-
-- (id<ANTLRToken>) getToken:(NSInteger)i;
-
-- (NSInteger) size;
-- (void) rewind;
-- (void) rewind:(NSInteger)marker;
-- (void) seek:(NSInteger)index;
-
-- (NSString *) toString;
-- (NSString *) toStringFromStart:(NSInteger)startIndex ToEnd:(NSInteger)stopIndex;
-- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken;
-
-#endif
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTokenStream.m b/runtime/ObjC/Framework/ANTLRCommonTokenStream.m
deleted file mode 100644
index 9ebc325..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonTokenStream.m
+++ /dev/null
@@ -1,352 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRToken.h"
-#import "ANTLRCommonTokenStream.h"
-
-
-@implementation ANTLRCommonTokenStream
-
-@synthesize channelOverride;
-@synthesize channel;
-
-#pragma mark Initialization
-
-+ (ANTLRCommonTokenStream *)newANTLRCommonTokenStream
-{
-    return [[ANTLRCommonTokenStream alloc] init];
-}
-
-+ (ANTLRCommonTokenStream *)newANTLRCommonTokenStreamWithTokenSource:(id<ANTLRTokenSource>)theTokenSource
-{
-    return [[ANTLRCommonTokenStream alloc] initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource];
-}
-
-+ (ANTLRCommonTokenStream *)newANTLRCommonTokenStreamWithTokenSource:(id<ANTLRTokenSource>)theTokenSource Channel:(NSUInteger)aChannel
-{
-    return [[ANTLRCommonTokenStream alloc] initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource Channel:aChannel];
-}
-
-- (id) init
-{
-	if ((self = [super init]) != nil) {
-		channelOverride = [[AMutableDictionary dictionaryWithCapacity:100] retain];
-		channel = ANTLRTokenChannelDefault;
-	}
-	return self;
-}
-
-- (id) initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource
-{
-	if ((self = [super initWithTokenSource:theTokenSource]) != nil) {
-		channelOverride = [[AMutableDictionary dictionaryWithCapacity:100] retain];
-		channel = ANTLRTokenChannelDefault;
-	}
-	return self;
-}
-
-- (id) initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource Channel:(NSUInteger)aChannel
-{
-	if ((self = [super initWithTokenSource:theTokenSource]) != nil) {
-		channelOverride = [[AMutableDictionary dictionaryWithCapacity:100] retain];
-		channel = aChannel;
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRCommonTokenStream" );
-#endif
-	if ( channelOverride ) [channelOverride release];
-	if ( tokens ) [tokens release];
-	[self setTokenSource:nil];
-	[super dealloc];
-}
-
-/** Always leave index on an on-channel token. */
-- (void) consume
-{
-    if (index == -1) [self setup];
-    index++;
-    [self sync:index];
-    while ( ((ANTLRCommonToken *)[tokens objectAtIndex:index]).channel != channel ) {
-		index++;
-		[self sync:index];
-	}
-}
-
-#pragma mark Lookahead
-
-- (id<ANTLRToken>) LB:(NSInteger)k
-{
-	if ( k == 0 || (index-k) < 0 ) {
-		return nil;
-	}
-	int i = index;
-	int n = 1;
-    // find k good tokens looking backwards
-	while ( n <= k ) {
-		i = [self skipOffChannelTokensReverse:i-1];
-		n++;
-	}
-	if ( i < 0 ) {
-		return nil;
-	}
-	return [tokens objectAtIndex:i];
-}
-
-- (id<ANTLRToken>) LT:(NSInteger)k
-{
-	if ( index == -1 ) [self setup];
-	if ( k == 0 ) return nil;
-	if ( k < 0 ) return [self LB:-k];
-	int i = index;
-	int n = 1;
-	while ( n < k ) {
-		i = [self skipOffChannelTokens:i+1];
-		n++;
-	}
-//	if ( i >= (NSInteger)[tokens count] ) {
-//		return [ANTLRCommonToken eofToken];
-//	}
-    if ( i > range ) range = i;
-	return [tokens objectAtIndex:i];
-}
-
-#pragma mark Channels & Skipping
-
-- (NSInteger) skipOffChannelTokens:(NSInteger) idx
-{
-    [self sync:idx];
-	while ( ((ANTLRCommonToken *)[tokens objectAtIndex:idx]).channel != channel ) {
-		idx++;
-        [self sync:idx];
-	}
-	return idx;
-}
-
-- (NSInteger) skipOffChannelTokensReverse:(NSInteger) i
-{
-	while ( i >= 0 && ((ANTLRCommonToken *)[tokens objectAtIndex:i]).channel != channel ) {
-		i--;
-	}
-	return i;
-}
-
-- (void) setup
-{
-    index = 0;
-    [self sync:0];
-    int i = 0;
-    while ( ((ANTLRCommonToken *)[tokens objectAtIndex:i]).channel != channel ) {
-        i++;
-        [self sync:i];
-    }
-	// leave index pointing at first token on channel
-    index = i;
-}
-
-- (NSInteger) getNumberOfOnChannelTokens
-{
-    NSInteger n = 0;
-    [self fill];
-    for( int i = 0; i < [tokens count]; i++ ) {
-        ANTLRCommonToken *t = [tokens objectAtIndex:i];
-        if ( t.channel == channel )
-            n++;
-        if ( t.type == ANTLRTokenTypeEOF )
-            break;
-    }
-    return n;
-}
-
-/** Reset this token stream by setting its token source. */
-- (void) setTokenSource:(id<ANTLRTokenSource>)aTokenSource
-{
-    [super setTokenSource:aTokenSource];
-    channel = ANTLRTokenChannelDefault;
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRCommonTokenStream *copy;
-
-    //    copy = [[[self class] allocWithZone:aZone] init];
-    copy = [super copyWithZone:aZone]; // allocation occurs in ANTLRBaseTree
-    if ( self.channelOverride )
-        copy.channelOverride = [channelOverride copyWithZone:aZone];
-    copy.channel = channel;
-    return copy;
-}
-
-- (NSUInteger)channel
-{
-    return channel;
-}
-
-- (void)setChannel:(NSUInteger)aChannel
-{
-    channel = aChannel;
-}
-
-- (AMutableDictionary *)channelOverride
-{
-    return channelOverride;
-}
-
-- (void)setChannelOverride:(AMutableDictionary *)anOverride
-{
-    channelOverride = anOverride;
-}
-
-#ifdef DONTUSENOMO
-#pragma mark Token access
-
-- (NSArray *) tokensInRange:(NSRange)aRange
-{
-	return [tokens subarrayWithRange:aRange];
-}
-
-#pragma mark Accessors
-
-- (id<ANTLRTokenSource>) getTokenSource
-{
-    return tokenSource;
-}
-
-- (NSArray *) tokensInRange:(NSRange)aRange inBitSet:(ANTLRBitSet *)aBitSet
-{
-	unsigned int startIndex = aRange.location;
-	unsigned int stopIndex = aRange.location+aRange.length;
-	if ( index == -1 ) {
-		[self setup];
-	}
-	if (stopIndex >= [tokens count]) {
-		stopIndex = [tokens count] - 1;
-	}
-	AMutableArray *filteredTokens = [AMutableArray arrayWithCapacity:100];
-	unsigned int i=0;
-	for (i = startIndex; i<=stopIndex; i++) {
-		id<ANTLRToken> token = [tokens objectAtIndex:i];
-		if (aBitSet == nil || [aBitSet member:token.type]) {
-			[filteredTokens addObject:token];
-		}
-	}
-	if ([filteredTokens count]) {
-		return filteredTokens;
-	} else {
-		[filteredTokens release];
-		return nil;
-	}
-}
-
-- (NSArray *) tokensInRange:(NSRange)aRange withTypes:(NSArray *)tokenTypes
-{
-	ANTLRBitSet *bits = [[ANTLRBitSet alloc] initWithArrayOfBits:tokenTypes];
-	NSArray *returnTokens = [[self tokensInRange:aRange inBitSet:bits] retain];
-	[bits release];
-	return returnTokens;
-}
-
-- (NSArray *) tokensInRange:(NSRange)aRange withType:(NSInteger)tokenType
-{
-	ANTLRBitSet *bits = [[ANTLRBitSet alloc] init];
-	[bits add:tokenType];
-	NSArray *returnTokens = [[self tokensInRange:aRange inBitSet:bits] retain];
-	[bits release];
-	return returnTokens;
-}
-
-- (id<ANTLRToken>) getToken:(NSInteger)i
-{
-	return [tokens objectAtIndex:i];
-}
-
-- (NSInteger) size
-{
-	return [tokens count];
-}
-
-- (void) rewind
-{
-	[self seek:lastMarker];
-}
-
-- (void) rewind:(NSInteger)marker
-{
-	[self seek:marker];
-}
-
-- (void) seek:(NSInteger)anIndex
-{
-	index = anIndex;
-}
-#pragma mark toString routines
-
-- (NSString *) toString
-{
-	if ( index == -1 ) {
-		[self setup];
-	}
-	return [self toStringFromStart:0 ToEnd:[tokens count]];
-}
-
-- (NSString *) toStringFromStart:(NSInteger)startIdx ToEnd:(NSInteger) stopIdx
-{
-    NSMutableString *stringBuffer;
-    id<ANTLRToken> t;
-
-    if ( startIdx < 0 || stopIdx < 0 ) {
-        return nil;
-    }
-    if ( index == -1 ) {
-        [self setup];
-    }
-    if ( stopIdx >= [tokens count] ) {
-        stopIdx = [tokens count]-1;
-    }
-    stringBuffer = [NSMutableString stringWithCapacity:30];
-    for (int i = startIdx; i <= stopIdx; i++) {
-        t = (id<ANTLRToken>)[tokens objectAtIndex:i];
-        [stringBuffer appendString:[t text]];
-    }
-    return stringBuffer;
-}
-
-- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken
-{
-	if (startToken && stopToken) {
-		int startIdx = [startToken getTokenIndex];
-		int stopIdx = [stopToken getTokenIndex];
-		return [self toStringFromStart:startIdx ToEnd:stopIdx];
-	}
-	return nil;
-}
-#endif
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTree.h b/runtime/ObjC/Framework/ANTLRCommonTree.h
deleted file mode 100644
index 2becb76..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonTree.h
+++ /dev/null
@@ -1,92 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRCommonToken.h"
-#import "ANTLRBaseTree.h"
-
-@interface ANTLRCommonTree : ANTLRBaseTree <ANTLRTree> {
-	__strong ANTLRCommonToken *token;
-	NSInteger startIndex;
-	NSInteger stopIndex;
-    __strong ANTLRCommonTree *parent;
-    NSInteger childIndex;
-}
-
-+ (ANTLRCommonTree *) invalidNode;
-+ (ANTLRCommonTree *) newTree;
-+ (ANTLRCommonTree *) newTreeWithTree:(ANTLRCommonTree *)aTree;
-+ (ANTLRCommonTree *) newTreeWithToken:(ANTLRCommonToken *)aToken;
-+ (ANTLRCommonTree *) newTreeWithTokenType:(NSInteger)tokenType;
-+ (ANTLRCommonTree *) newTreeWithTokenType:(NSInteger)aTType Text:(NSString *)theText;
-
-- (id) init;
-- (id) initWithTreeNode:(ANTLRCommonTree *)aNode;
-- (id) initWithToken:(ANTLRCommonToken *)aToken;
-- (id) initWithTokenType:(NSInteger)aTokenType;
-- (id) initWithTokenType:(NSInteger)aTokenType Text:(NSString *)theText;
-
-- (id<ANTLRBaseTree>) copyWithZone:(NSZone *)aZone;
-
-- (BOOL) isNil;
-
-- (ANTLRCommonToken *) getToken;
-- (void) setToken:(ANTLRCommonToken *)aToken;
-- (ANTLRCommonToken *) dupNode;
-- (NSInteger)type;
-- (NSString *)text;
-- (NSUInteger)line;
-- (void) setLine:(NSUInteger)aLine;
-- (NSUInteger)charPositionInLine;
-- (void) setCharPositionInLine:(NSUInteger)pos;
-- (ANTLRCommonTree *) getParent;
-- (void) setParent:(ANTLRCommonTree *) t;
-
-#ifdef DONTUSENOMO
-- (NSString *) treeDescription;
-#endif
-- (NSString *) description;
-- (void) setUnknownTokenBoundaries;
-- (NSInteger) getTokenStartIndex;
-- (void) setTokenStartIndex: (NSInteger) aStartIndex;
-- (NSInteger) getTokenStopIndex;
-- (void) setTokenStopIndex: (NSInteger) aStopIndex;
-
-/*
- @property (retain, getter=getANTLRCommonToken, setter=setANTLRCommonToken:) ANTLRCommonToken *token;
- @property (assign, getter=getTokenStartIndex, setter=setTokenStartIndex:) NSInteger startIndex;
- @property (assign, getter=getTokenStopIndex, setter=setTokenStopIndex:) NSInteger stopIndex;
- @property (retain, getter=getParent, setter=setParent:) id<ANTLRBaseTree> parentparent;
- @property (assign, getter=getChildIndex, setter=setChildIndex:) NSInteger childIndex;
- */
-
-@property (retain) ANTLRCommonToken *token;
-@property (assign) NSInteger startIndex;
-@property (assign) NSInteger stopIndex;
-@property (retain) ANTLRCommonTree *parent;
-@property (assign) NSInteger childIndex;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTree.m b/runtime/ObjC/Framework/ANTLRCommonTree.m
deleted file mode 100644
index 68c1fc1..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonTree.m
+++ /dev/null
@@ -1,345 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRCommonTree.h"
-
-
-@implementation ANTLRCommonTree
-
-+ (ANTLRCommonTree *)INVALID_NODE
-{
-	return [[ANTLRCommonTree alloc] initWithToken:[ANTLRCommonToken invalidToken]];
-}
-
-+ (ANTLRCommonTree *)invalidNode
-{
-    // Had to cast to ANTLRCommonTree * here, because GCC is dumb.
-	return [[ANTLRCommonTree alloc] initWithToken:ANTLRCommonToken.INVALID_TOKEN];
-}
-
-+ (ANTLRCommonTree *)newTree
-{
-    return [[ANTLRCommonTree alloc] init];
-}
-
-+ (ANTLRCommonTree *)newTreeWithTree:(ANTLRCommonTree *)aTree
-{
-    return [[ANTLRCommonTree alloc] initWithTreeNode:aTree];
-}
-
-+ (ANTLRCommonTree *)newTreeWithToken:(id<ANTLRToken>)aToken
-{
-	return [[ANTLRCommonTree alloc] initWithToken:aToken];
-}
-
-+ (ANTLRCommonTree *)newTreeWithTokenType:(NSInteger)aTType
-{
-	return [[ANTLRCommonTree alloc] initWithTokenType:(NSInteger)aTType];
-}
-
-+ (ANTLRCommonTree *)newTreeWithTokenType:(NSInteger)aTType Text:(NSString *)theText
-{
-	return [[ANTLRCommonTree alloc] initWithTokenType:(NSInteger)aTType Text:theText];
-}
-
-- (id)init
-{
-	self = (ANTLRCommonTree *)[super init];
-	if ( self != nil ) {
-        token = nil;
-		startIndex = -1;
-		stopIndex = -1;
-        parent = nil;
-        childIndex = -1;
-	}
-	return (ANTLRCommonTree *)self;
-}
-
-- (id)initWithTreeNode:(ANTLRCommonTree *)aNode
-{
-	self = (ANTLRCommonTree *)[super init];
-	if ( self != nil ) {
-		token = aNode.token;
-        if ( token ) [token retain];
-		startIndex = aNode.startIndex;
-		stopIndex = aNode.stopIndex;
-        parent = nil;
-        childIndex = -1;
-	}
-	return self;
-}
-
-- (id)initWithToken:(id<ANTLRToken>)aToken
-{
-	self = (ANTLRCommonTree *)[super init];
-	if ( self != nil ) {
-		token = aToken;
-        if ( token ) [token retain];
-		startIndex = -1;
-		stopIndex = -1;
-        parent = nil;
-        childIndex = -1;
-	}
-	return self;
-}
-
-- (id)initWithTokenType:(NSInteger)aTokenType
-{
-	self = (ANTLRCommonTree *)[super init];
-	if ( self != nil ) {
-		token = [[ANTLRCommonToken newToken:aTokenType] retain];
-//		startIndex = token.startIndex;
-		startIndex = -1;
-//		stopIndex = token.stopIndex;
-		stopIndex = -1;
-        parent = nil;
-        childIndex = -1;
-	}
-	return self;
-}
-
-- (id) initWithTokenType:(NSInteger)aTokenType Text:(NSString *)theText
-{
-	self = (ANTLRCommonTree *)[super init];
-	if ( self != nil ) {
-		token = [[ANTLRCommonToken newToken:aTokenType Text:theText] retain];
-//		startIndex = token.startIndex;
-		startIndex = -1;
-//		stopIndex = token.stopIndex;
-		stopIndex = -1;
-        parent = nil;
-        childIndex = -1;
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-    if ( token ) {
-        [token release];
-        token = nil;
-    }
-    if ( parent ) {
-        [parent release];
-        parent = nil;
-    }
-	[super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRCommonTree *copy;
-
-    //    copy = [[[self class] allocWithZone:aZone] init];
-    copy = [super copyWithZone:aZone]; // allocation occurs in ANTLRBaseTree
-    if ( self.token )
-        copy.token = [self.token copyWithZone:aZone];
-    copy.startIndex = startIndex;
-    copy.stopIndex = stopIndex;
-    copy.parent = (ANTLRCommonTree *)[self.parent copyWithZone:aZone];
-    copy.childIndex = childIndex;
-    return copy;
-}
-
-- (BOOL) isNil
-{
-	return token == nil;
-}
-
-- (ANTLRCommonToken *) getToken
-{
-	return token;
-}
-
-- (void) setToken:(ANTLRCommonToken *) aToken
-{
-	if ( token != aToken ) {
-		if ( token ) [token release];
-		[aToken retain];
-		token = aToken;
-	}
-}
-
-- (ANTLRCommonTree *) dupNode
-{
-    return [ANTLRCommonTree newTreeWithTree:self ];
-}
-
-- (NSInteger)type
-{
-	if (token)
-		return token.type;
-	return ANTLRTokenTypeInvalid;
-}
-
-- (NSString *)text
-{
-	if (token)
-		return token.text;
-	return nil;
-}
-
-- (NSUInteger)line
-{
-	if (token)
-		return token.line;
-	return 0;
-}
-
-- (void) setLine:(NSUInteger)aLine
-{
-    if (token)
-        token.line = aLine;
-}
-
-- (NSUInteger)charPositionInLine
-{
-	if (token)
-		return token.charPositionInLine;
-	return 0;
-}
-
-- (void) setCharPositionInLine:(NSUInteger)pos
-{
-    if (token)
-        token.charPositionInLine = pos;
-}
-
-- (NSInteger) getTokenStartIndex
-{
-	if ( startIndex == -1 && token != nil ) {
-		return [token getTokenIndex];
-	}
-    return startIndex;
-}
-
-- (void) setTokenStartIndex: (NSInteger) aStartIndex
-{
-    startIndex = aStartIndex;
-}
-
-- (NSInteger) getTokenStopIndex
-{
-	if ( stopIndex == -1 && token != nil ) {
-		return [token getTokenIndex];
-	}
-    return stopIndex;
-}
-
-- (void) setTokenStopIndex: (NSInteger) aStopIndex
-{
-    stopIndex = aStopIndex;
-}
-
-#ifdef DONTUSENOMO
-- (NSString *) treeDescription
-{
-	if (children) {
-		NSMutableString *desc = [NSMutableString stringWithString:@"(^"];
-		[desc appendString:[self description]];
-		unsigned int childIdx;
-		for (childIdx = 0; childIdx < [children count]; childIdx++) {
-			[desc appendFormat:@"%@", [[children objectAtIndex:childIdx] treeDescription]];
-		}
-		[desc appendString:@")"];
-		return desc;
-	} else {
-		return [self description];
-	}
-}
-#endif
-
-/** For every node in this subtree, make sure it's start/stop token's
- *  are set.  Walk depth first, visit bottom up.  Only updates nodes
- *  with at least one token index < 0.
- */
-- (void) setUnknownTokenBoundaries
-{
-    if ( children == nil ) {
-        if ( startIndex<0 || stopIndex<0 ) {
-            startIndex = stopIndex = [token getTokenIndex];
-        }
-        return;
-    }
-    for (NSUInteger i=0; i < [children count]; i++) {
-        [[children objectAtIndex:i] setUnknownTokenBoundaries];
-    }
-    if ( startIndex >= 0 && stopIndex >= 0 )
-         return; // already set
-    if ( [children count] > 0 ) {
-        ANTLRCommonTree *firstChild = (ANTLRCommonTree *)[children objectAtIndex:0];
-        ANTLRCommonTree *lastChild = (ANTLRCommonTree *)[children objectAtIndex:[children count]-1];
-        startIndex = [firstChild getTokenStartIndex];
-        stopIndex = [lastChild getTokenStopIndex];
-    }
-}
-
-- (NSInteger) getChildIndex
-{
-    return childIndex;
-}
-
-- (ANTLRCommonTree *) getParent
-{
-    return parent;
-}
-
-- (void) setParent:(ANTLRCommonTree *) t
-{
-    parent = t;
-}
-
-- (void) setChildIndex:(NSInteger) anIndex
-{
-    childIndex = anIndex;
-}
-
-- (NSString *) description
-{
-    return [self toString];
-}
-
-- (NSString *) toString
-{
-    if ( [self isNil] ) {
-        return @"nil";
-    }
-    if ( [self type] == ANTLRTokenTypeInvalid ) {
-        return @"<errornode>";
-    }
-    if ( token==nil ) {
-        return nil;
-    }
-    return token.text;
-}
-
-@synthesize token;
-@synthesize startIndex;
-@synthesize stopIndex;
-@synthesize parent;
-@synthesize childIndex;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.h b/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.h
deleted file mode 100644
index e79f0ab..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.h
+++ /dev/null
@@ -1,65 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTree.h"
-#import "ANTLRCommonToken.h"
-#import "ANTLRCommonTree.h"
-#import "ANTLRBaseTreeAdaptor.h"
-
-@interface ANTLRCommonTreeAdaptor : ANTLRBaseTreeAdaptor {
-}
-
-+ (ANTLRCommonTree *) newEmptyTree;
-+ (ANTLRCommonTreeAdaptor *)newTreeAdaptor;
-- (id) init;
-- (ANTLRCommonTree *)dupNode:(ANTLRCommonTree *)t;
-
-- (ANTLRCommonTree *) create:(id<ANTLRToken>) payload;
-//- (ANTLRCommonTree *) createTree:(NSInteger)tokenType fromToken:(ANTLRCommonToken *)aToken;
-//- (ANTLRCommonTree *) createTree:(NSInteger)tokenType fromToken:(ANTLRCommonToken *)aToken Text:(NSString *)text;
-- (id<ANTLRToken>)createToken:(NSInteger)tokenType Text:(NSString *)text;
-- (id<ANTLRToken>)createToken:(id<ANTLRToken>)fromToken;
-- (void) setTokenBoundaries:(ANTLRCommonTree *)t From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
-- (NSInteger)getTokenStartIndex:(ANTLRCommonTree *)t;
-- (NSInteger)getTokenStopIndex:(ANTLRCommonTree *)t;
-- (NSString *)getText:(ANTLRCommonTree *)t;
-- (void)setText:(ANTLRCommonTree *)t Text:(NSString *)text;
-- (NSInteger)getType:(ANTLRCommonTree *)t;
-- (void) setType:(ANTLRCommonTree *)t Type:(NSInteger)tokenType;
-- (id<ANTLRToken>)getToken:(ANTLRCommonTree *)t;
-- (ANTLRCommonTree *)getChild:(ANTLRCommonTree *)t At:(NSInteger)i;
-- (void) setChild:(ANTLRCommonTree *)t At:(NSInteger)i Child:(ANTLRCommonTree *)child;
-- (NSInteger)getChildCount:(ANTLRCommonTree *)t;
-- (ANTLRCommonTree *)getParent:(ANTLRCommonTree *)t;
-- (void)setParent:(ANTLRCommonTree *)t With:(ANTLRCommonTree *)parent;
-- (NSInteger)getChildIndex:(ANTLRCommonTree *)t;
-- (void)setChildIndex:(ANTLRCommonTree *)t With:(NSInteger)index;
-- (void)replaceChildren:(ANTLRCommonTree *)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(ANTLRCommonTree *)t;
-- (id)copyWithZone:(NSZone *)zone;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m b/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m
deleted file mode 100644
index 7609698..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonTreeAdaptor.m
+++ /dev/null
@@ -1,240 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRCommonTreeAdaptor.h"
-
-@implementation ANTLRCommonTreeAdaptor
-
-+ (ANTLRCommonTree *) newEmptyTree;
-{
-    return [ANTLRCommonTree newTree];
-}
-
-+ (ANTLRCommonTreeAdaptor *)newTreeAdaptor
-{
-    return[[ANTLRCommonTreeAdaptor alloc] init];
-}
-
-- (id) init
-{
-    self = [super init];
-    if (self) {
-    }
-    return self;
-}
-
-/** Duplicate a node.  This is part of the factory;
- *	override if you want another kind of node to be built.
- *
- *  I could use reflection to prevent having to override this
- *  but reflection is slow.
- */
-- (id) dupNode:(id<ANTLRBaseTree>)t
-{
-    if ( t==nil )
-        return nil;
-    return [ANTLRCommonTree newTree:t];
-}
-
-/** Tell me how to create a token for use with imaginary token nodes.
- *  For example, there is probably no input symbol associated with imaginary
- *  token DECL, but you need to create it as a payload or whatever for
- *  the DECL node as in ^(DECL type ID).
- *
- *  This is a variant of createToken where the new token is derived from
- *  an actual real input token.  Typically this is for converting '{'
- *  tokens to BLOCK etc...  You'll see
- *
- *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
- *
- *  If you care what the token payload objects' type is, you should
- *  override this method and any other createToken variant.
- */
-- (ANTLRCommonTree *) create:(ANTLRCommonToken *)aToken
-{
-    return [ANTLRCommonTree newTreeWithToken:aToken];
-}
-
-/** Tell me how to create a token for use with imaginary token nodes.
- *  For example, there is probably no input symbol associated with imaginary
- *  token DECL, but you need to create it as a payload or whatever for
- *  the DECL node as in ^(DECL type ID).
- *
- *  If you care what the token payload objects' type is, you should
- *  override this method and any other createToken variant.
- */
-- (ANTLRCommonTree *)createTree:(NSInteger)tokenType Text:(NSString *)text
-{
-    return [ANTLRCommonTree newTreeWithTokenType:tokenType Text:text];
-}
-
-- (id<ANTLRToken>)createToken:(NSInteger)tokenType Text:(NSString *)text
-{
-    id<ANTLRToken> fromToken = [ANTLRCommonToken newToken:tokenType Text:text];
-    return fromToken;
-}
-
-- (id<ANTLRToken>)createToken:(id<ANTLRToken>)fromToken
-{
-    return [ANTLRCommonToken newTokenWithToken:(ANTLRCommonToken *)fromToken];
-}
-
-/** Track start/stop token for subtree root created for a rule.
- *  Only works with Tree nodes.  For rules that match nothing,
- *  seems like this will yield start=i and stop=i-1 in a nil node.
- *  Might be useful info so I'll not force to be i..i.
- */
-- (void) setTokenBoundaries:(id<ANTLRBaseTree>)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken
-{
-    if ( aTree == nil )
-        return;
-    int startTokIdx = 0;
-    int stopTokIdx = 0;
-    if ( startToken != nil )
-        startTokIdx = [startToken getTokenIndex];
-    if ( stopToken != nil )
-        stopTokIdx = [stopToken getTokenIndex];
-    [(id<ANTLRBaseTree>)aTree setTokenStartIndex:startTokIdx];
-    [(id<ANTLRBaseTree>)aTree setTokenStopIndex:stopTokIdx];
-}
-
-- (NSInteger)getTokenStartIndex:(id<ANTLRBaseTree>) t
-{
-    if ( t == nil )
-        return -1;
-    return [(id<ANTLRBaseTree>)t getTokenStartIndex];
-}
-
-- (NSInteger)getTokenStopIndex:(id<ANTLRBaseTree>) t
-{
-    if ( t == nil )
-        return -1;
-    return [(id<ANTLRBaseTree>)t getTokenStopIndex];
-}
-
-- (NSString *)getText:(ANTLRCommonTree *)t
-{
-    if ( t == nil )
-        return nil;
-    return t.token.text;
-}
-
-- (void)setText:(id<ANTLRBaseTree>)t Text:(NSString *)text
-{
-    if ( t == nil )
-        return;
-}
-
-- (NSInteger)getType:(ANTLRCommonTree *)t
-{
-    if ( t==nil )
-        return ANTLRTokenTypeInvalid;
-    return t.token.type;
-}
-
-- (void) setType:(id<ANTLRBaseTree>)t Type:(NSInteger)tokenType
-{
-    if ( t==nil )
-        return;
-}
-
-/** What is the Token associated with this node?  If
- *  you are not using ANTLRCommonTree, then you must
- *  override this in your own adaptor.
- */
-- (id<ANTLRToken>) getToken:(ANTLRCommonTree *) t
-{
-    if ( [t isKindOfClass:[ANTLRCommonTree class]] ) {
-        return t.token;
-    }
-    return nil; // no idea what to do
-}
-
-- (id<ANTLRBaseTree>) getChild:(id<ANTLRBaseTree>)t At:(NSInteger)i
-{
-    if ( t == nil )
-        return nil;
-    return [(id<ANTLRBaseTree>)t getChild:i];
-}
-
-- (void) setChild:(id<ANTLRBaseTree>)t At:(NSInteger)i Child:(id<ANTLRBaseTree>)child
-{
-    if ( t == nil )
-        return;
-    [(id<ANTLRBaseTree>)t setChild:i With:child];
-}
-
-- (id) deleteChild:(id<ANTLRBaseTree>)t Index:(NSInteger)anIndex
-{
-    return [t deleteChild:anIndex];
-}
-
-- (NSInteger) getChildCount:(id<ANTLRBaseTree>) t
-{
-    if ( t == nil )
-        return 0;
-    return [(id<ANTLRBaseTree>) t getChildCount];
-}
-
-- (id<ANTLRBaseTree>) getParent:(id<ANTLRBaseTree>) t
-{
-    if ( t == nil )
-        return nil;
-    return (id<ANTLRBaseTree>)[t getParent];
-}
-
-- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>) parent
-{
-    if ( t != nil )
-        [(id<ANTLRBaseTree>) t setParent:(id<ANTLRBaseTree>)parent];
-}
-
-- (NSInteger) getChildIndex:(id<ANTLRBaseTree>) t
-{
-    if ( t == nil )
-        return 0;
-    return [(id<ANTLRBaseTree>) t getChildIndex];
-}
-
-- (void) setChildIndex:(id<ANTLRBaseTree>)t With:(NSInteger)anIndex
-{
-    if ( t!=nil )
-        [(id<ANTLRBaseTree>)t setChildIndex:anIndex];
-}
-
-- (void) replaceChildren:(id<ANTLRBaseTree>)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id<ANTLRBaseTree>)t
-{
-    if ( parent != nil ) {
-        [(id<ANTLRBaseTree>)parent replaceChildrenFrom:startChildIndex To:stopChildIndex With:t];
-    }
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    return [[[self class] allocWithZone:aZone] init];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.h b/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.h
deleted file mode 100644
index 52efc0f..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.h
+++ /dev/null
@@ -1,120 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRCommonTree.h"
-#import "ANTLRCommonTreeNodeStream.h"
-#import "ANTLRLookaheadStream.h"
-#import "ANTLRTreeNodeStream.h"
-#import "ANTLRTreeIterator.h"
-#import "ANTLRIntArray.h"
-
-@interface ANTLRCommonTreeNodeStream : ANTLRLookaheadStream <ANTLRTreeNodeStream> {
-#define DEFAULT_INITIAL_BUFFER_SIZE 100
-#define INITIAL_CALL_STACK_SIZE 10
-
-/** Pull nodes from which tree? */
-__strong id root;
-
-/** If this tree (root) was created from a token stream, track it. */
-__strong id <ANTLRTokenStream> tokens;
-
-	/** What tree adaptor was used to build these trees */
-__strong ANTLRCommonTreeAdaptor *adaptor;
-
-/** The tree iterator we using */
-__strong ANTLRTreeIterator *it;
-
-/** Stack of indexes used for push/pop calls */
-__strong ANTLRIntArray *calls;
-
-/** Tree (nil A B C) trees like flat A B C streams */
-BOOL hasNilRoot;
-
-/** Tracks tree depth.  Level=0 means we're at root node level. */
-NSInteger level;
-}
-@property (retain, getter=getRoot, setter=setRoot:) ANTLRCommonTree *root;
-@property (retain, getter=getTokens,setter=setTokens:) id<ANTLRTokenStream> tokens;
-@property (retain, getter=getTreeAdaptor, setter=setTreeAdaptor:) ANTLRCommonTreeAdaptor *adaptor;
-@property (assign, getter=getLevel, setter=setLevel:) NSInteger level;
-
-+ (ANTLRCommonTreeNodeStream *) newANTLRCommonTreeNodeStream:(ANTLRCommonTree *)theTree;
-+ (ANTLRCommonTreeNodeStream *) newANTLRCommonTreeNodeStream:(id<ANTLRTreeAdaptor>)anAdaptor Tree:(ANTLRCommonTree *)theTree;
-
-- (id) initWithTree:(ANTLRCommonTree *)theTree;
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)theTree;
-
-- (void) reset;
-
-    /** Pull elements from tree iterator.  Track tree level 0..max_level.
-     *  If nil rooted tree, don't give initial nil and DOWN nor final UP.
-     */
-- (id) nextElement;
-
-- (BOOL) isEOF:(id<ANTLRBaseTree>) obj;
-- (void) setUniqueNavigationNodes:(BOOL) uniqueNavigationNodes;
-
-- (id) getTreeSource;
-
-- (NSString *) getSourceName;
-
-- (id<ANTLRTokenStream>) getTokenStream;
-
-- (void) setTokenStream:(id<ANTLRTokenStream>) tokens;
-
-- (ANTLRCommonTreeAdaptor *) getTreeAdaptor;
-
-- (void) setTreeAdaptor:(ANTLRCommonTreeAdaptor *) adaptor;
-
-- (NSInteger) LA:(NSInteger) i;
-
-    /** Make stream jump to a new location, saving old location.
-     *  Switch back with pop().
-     */
-- (ANTLRCommonTree *)getNode:(NSInteger) i;
-
-- (void) push:(NSInteger) index;
-
-    /** Seek back to previous index saved during last push() call.
-     *  Return top of stack (return index).
-     */
-- (NSInteger) pop;
-
-// TREE REWRITE INTERFACE
-
-- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
-
-- (NSString *) toStringFromNode:(id<ANTLRBaseTree>)startNode ToNode:(id<ANTLRBaseTree>)stopNode;
-
-/** For debugging; destructive: moves tree iterator to end. */
-- (NSString *) toTokenTypeString;
-
-@property (retain) ANTLRTreeIterator *it;
-@property (retain) ANTLRIntArray *calls;
-@property BOOL hasNilRoot;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m
deleted file mode 100644
index 23eddee..0000000
--- a/runtime/ObjC/Framework/ANTLRCommonTreeNodeStream.m
+++ /dev/null
@@ -1,249 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRCommonTreeNodeStream.h"
-#import "ANTLRTokenStream.h"
-#import "ANTLRIntStream.h"
-#import "ANTLRCharStream.h"
-#import "AMutableArray.h"
-#import "ANTLRCommonTreeAdaptor.h"
-
-#ifndef DEBUG_DEALLOC
-#define DEBUG_DEALLOC
-#endif
-
-@implementation ANTLRCommonTreeNodeStream
-
-@synthesize root;
-@synthesize tokens;
-@synthesize adaptor;
-@synthesize level;
-
-+ (ANTLRCommonTreeNodeStream *) newANTLRCommonTreeNodeStream:(ANTLRCommonTree *)theTree
-{
-    return [[ANTLRCommonTreeNodeStream alloc] initWithTree:theTree];
-}
-
-+ (ANTLRCommonTreeNodeStream *) newANTLRCommonTreeNodeStream:(id<ANTLRTreeAdaptor>)anAdaptor Tree:(ANTLRCommonTree *)theTree
-{
-    return [[ANTLRCommonTreeNodeStream alloc] initWithTreeAdaptor:anAdaptor Tree:theTree];
-}
-
-- (id) initWithTree:(ANTLRCommonTree *)theTree
-{
-    if ((self = [super init]) != nil ) {
-        adaptor = [[ANTLRCommonTreeAdaptor newTreeAdaptor] retain];
-        root = [theTree retain];
-        navigationNodeEOF = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain]; // set EOF
-        it = [[ANTLRTreeIterator newANTRLTreeIteratorWithAdaptor:adaptor andTree:root] retain];
-        calls = [[ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE] retain];
-        /** Tree (nil A B C) trees like flat A B C streams */
-        hasNilRoot = NO;
-        level = 0;
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor Tree:(ANTLRCommonTree *)theTree
-{
-    if ((self = [super init]) != nil ) {
-        adaptor = [anAdaptor retain];
-        root = [theTree retain];
-        navigationNodeEOF = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain]; // set EOF
-        //    it = [root objectEnumerator];
-        it = [[ANTLRTreeIterator newANTRLTreeIteratorWithAdaptor:adaptor andTree:root] retain];
-        calls = [[ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE] retain];
-        /** Tree (nil A B C) trees like flat A B C streams */
-        hasNilRoot = NO;
-        level = 0;
-    }
-    //    eof = [self isEOF]; // make sure tree iterator returns the EOF we want
-    return self;
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRCommonTreeNodeStream" );
-#endif
-    if ( root ) [root release];
-    if ( tokens ) [tokens release];
-    if ( adaptor ) [adaptor release];
-    if ( it ) [it release];
-    if ( calls ) [calls release];
-    [super dealloc];
-}
-
-- (void) reset
-{
-    [super reset];
-    [it reset];
-    hasNilRoot = false;
-    level = 0;
-    if ( calls != nil )
-        [calls reset];  // [calls clear]; // in Java
-}
-
-/** Pull elements from tree iterator.  Track tree level 0..max_level.
- *  If nil rooted tree, don't give initial nil and DOWN nor final UP.
- */
-- (id) nextElement
-{
-    id t = [it nextObject];
-    //System.out.println("pulled "+adaptor.getType(t));
-    if ( t == [it up] ) {
-        level--;
-        if ( level==0 && hasNilRoot ) return [it nextObject]; // don't give last UP; get EOF
-    }
-    else if ( t == [it down] )
-        level++;
-    if ( level == 0 && [adaptor isNil:t] ) { // if nil root, scarf nil, DOWN
-        hasNilRoot = true;
-        t = [it nextObject]; // t is now DOWN, so get first real node next
-        level++;
-        t = [it nextObject];
-    }
-    return t;
-}
-
-- (BOOL) isEOF:(id<ANTLRBaseTree>) aTree
-{
-    return [adaptor getType:(ANTLRCommonTree *)aTree] == ANTLRTokenTypeEOF;
-}
-
-- (void) setUniqueNavigationNodes:(BOOL) uniqueNavigationNodes
-{
-}
-
-- (id) getTreeSource
-{
-    return root;
-}
-
-- (NSString *) getSourceName
-{
-    return [[self getTokenStream] getSourceName];
-}
-
-- (id<ANTLRTokenStream>) getTokenStream
-{
-    return tokens;
-}
-
-- (void) setTokenStream:(id<ANTLRTokenStream>)theTokens
-{
-    if ( tokens != theTokens ) {
-        if ( tokens ) [tokens release];
-        [theTokens retain];
-    }
-    tokens = theTokens;
-}
-
-- (ANTLRCommonTreeAdaptor *) getTreeAdaptor
-{
-    return adaptor;
-}
-
-- (void) setTreeAdaptor:(ANTLRCommonTreeAdaptor *) anAdaptor
-{
-    if ( adaptor != anAdaptor ) {
-        if ( adaptor ) [adaptor release];
-        [anAdaptor retain];
-    }
-    adaptor = anAdaptor;
-}
-
-- (ANTLRCommonTree *)getNode:(NSInteger) i
-{
-    @throw [ANTLRRuntimeException newException:@"Absolute node indexes are meaningless in an unbuffered stream"];
-    return nil;
-}
-
-- (NSInteger) LA:(NSInteger) i
-{
-    return [adaptor getType:[self LT:i]];
-}
-
-/** Make stream jump to a new location, saving old location.
- *  Switch back with pop().
- */
-- (void) push:(NSInteger) anIndex
-{
-    if ( calls == nil ) {
-        calls = [[ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE] retain];
-    }
-    [calls push:p]; // save current anIndex
-    [self seek:anIndex];
-}
-
-/** Seek back to previous anIndex saved during last push() call.
- *  Return top of stack (return anIndex).
- */
-- (NSInteger) pop
-{
-    int ret = [calls pop];
-    [self seek:ret];
-    return ret;
-}
-
-// TREE REWRITE INTERFACE
-
-- (void) replaceChildren:(id) parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) aTree
-{
-    if ( parent != nil ) {
-        [adaptor replaceChildren:parent From:startChildIndex To:stopChildIndex With:aTree];
-    }
-}
-
-- (NSString *) toStringFromNode:(id<ANTLRBaseTree>)startNode ToNode:(id<ANTLRBaseTree>)stopNode
-{
-    // we'll have to walk from start to stop in tree; we're not keeping
-    // a complete node stream buffer
-    return @"n/a";
-}
-
-/** For debugging; destructive: moves tree iterator to end. */
-- (NSString *) toTokenTypeString
-{
-    [self reset];
-    NSMutableString *buf = [NSMutableString stringWithCapacity:5];
-    id obj = [self LT:1];
-    NSInteger type = [adaptor getType:obj];
-    while ( type != ANTLRTokenTypeEOF ) {
-        [buf appendString:@" "];
-        [buf appendString:[NSString stringWithFormat:@"%d", type]];
-        [self consume];
-        obj = [self LT:1];
-        type = [adaptor getType:obj];
-    }
-    return buf;
-}
-
-@synthesize it;
-@synthesize calls;
-@synthesize hasNilRoot;
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRDFA.h b/runtime/ObjC/Framework/ANTLRDFA.h
deleted file mode 100644
index 9adedb1..0000000
--- a/runtime/ObjC/Framework/ANTLRDFA.h
+++ /dev/null
@@ -1,82 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseRecognizer.h"
-#import "ANTLRCharStream.h"
-#import "ANTLRNoViableAltException.h"
-
-@interface ANTLRDFA : NSObject {
-	// the tables are set by subclasses to their own static versions.
-	const int *eot;
-	const int *eof;
-	const unichar *min;
-	const unichar *max;
-	const int *accept;
-	const int *special;
-	const int **transition;
-
-	__strong ANTLRBaseRecognizer *recognizer;
-	NSInteger decisionNumber;
-    NSInteger len;
-}
-
-- (id) initWithRecognizer:(id) theRecognizer;
-// simulate the DFA using the static tables and predict an alternative
-- (NSInteger) predict:(id<ANTLRCharStream>)anInput;
-- (void) noViableAlt:(NSInteger)state Stream:(id<ANTLRIntStream>)anInput;
-
-- (NSInteger) specialStateTransition:(NSInteger)state Stream:(id<ANTLRIntStream>)anInput;
-// - (NSInteger) specialStateTransition:(NSInteger) state;
-//- (unichar) specialTransition:(unichar) state symbol:(NSInteger) symbol;
-
-// hook for debugger support
-- (void) error:(ANTLRNoViableAltException *)nvae;
-
-- (NSString *) description;
-- (BOOL) evaluateSyntacticPredicate:(SEL)synpredFragment;
-
-+ (void) setIsEmittingDebugInfo:(BOOL) shouldEmitDebugInfo;
-
-- (NSInteger)getDecision;
-- (void)setDecision:(NSInteger)aDecison;
-
-- (ANTLRBaseRecognizer *)getRecognizer;
-- (void)setRecognizer:(ANTLRBaseRecognizer *)aRecognizer;
-- (NSInteger)length;
-
-@property const int *eot;
-@property const int *eof;
-@property const unichar *min;
-@property const unichar *max;
-@property const int *accept;
-@property const int *special;
-@property const int **transition;
-
-@property (retain, getter=getRecognizer,setter=setRecognizer:) ANTLRBaseRecognizer *recognizer;
-@property (assign, getter=getDecision,setter=setDecision:) NSInteger decisionNumber;
-@property (assign, getter=getLen,setter=setLen:) NSInteger len;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDFA.m b/runtime/ObjC/Framework/ANTLRDFA.m
deleted file mode 100644
index b42daf5..0000000
--- a/runtime/ObjC/Framework/ANTLRDFA.m
+++ /dev/null
@@ -1,262 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRDFA.h"
-#import <ANTLRToken.h>
-#import <ANTLRNoViableAltException.h>
-
-NSInteger debug = 0;
-
-@implementation ANTLRDFA
-@synthesize recognizer;
-@synthesize decisionNumber;
-@synthesize len;
-
-- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
-{
-	if ((self = [super init]) != nil) {
-		recognizer = theRecognizer;
-        [recognizer retain];
-        debug = 0;
-	}
-	return self;
-}
-
-// using the tables ANTLR generates for the DFA based prediction this method simulates the DFA
-// and returns the prediction of the alternative to be used.
-- (NSInteger) predict:(id<ANTLRIntStream>)input
-{
-    if ( debug > 2 ) {
-        NSLog(@"Enter DFA.predict for decision %d", decisionNumber);
-    }
-	int aMark = [input mark];
-	int s = 0;
-	@try {
-		while (YES) {
-			if ( debug > 2 )
-                NSLog(@"DFA %d state %d LA(1)='%c'(%x)", decisionNumber, s, (unichar)[input LA:1], [input LA:1]);
-			NSInteger specialState = special[s];
-			if (specialState >= 0) {
-				// this state is special in that it has some code associated with it. we cannot do this in a pure DFA so
-				// we signal the caller accordingly.
-				if ( debug > 2 ) {
-                    NSLog(@"DFA %d state %d is special state %d", decisionNumber, s, specialState);
-                }
-				s = [self specialStateTransition:specialState Stream:input];
-                if ( debug > 2 ) {
-                    NSLog(@"DFA %d returns from special state %d to %d", decisionNumber, specialState, s);
-                }
-                if (s == -1 ) {
-                    [self noViableAlt:s Stream:input];
-                    return 0;
-                }
-				[input consume];
-				continue;
-			}
-			if (accept[s] >= 1) {  // if this is an accepting state return the prediction
-				if ( debug > 2 ) NSLog(@"accept; predict %d from state %d", accept[s], s);
-				return accept[s];
-			}
-			// based on the lookahead lookup the next transition, consume and do transition
-			// or signal that we have no viable alternative
-			int c = [input LA:1];
-			if ( (unichar)c >= min[s] && (unichar)c <= max[s]) {
-				int snext = transition[s][c-min[s]];
-				if (snext < 0) {
-                    // was in range but not a normal transition
-                    // must check EOT, which is like the else clause.
-                    // eot[s]>=0 indicates that an EOT edge goes to another
-                    // state.
-					if (eot[s] >= 0) {
-						if ( debug > 2 ) NSLog(@"EOT transition");
-						s = eot[s];
-						[input consume];
-                        // TODO: I had this as return accept[eot[s]]
-                        // which assumed here that the EOT edge always
-                        // went to an accept...faster to do this, but
-                        // what about predicated edges coming from EOT
-                        // target?
-						continue;
-					}
-					[self noViableAlt:s Stream:input];
-					return 0;
-				}
-				s = snext;
-				[input consume];
-				continue;
-			}
-
-			if (eot[s] >= 0) {// EOT transition? we may still accept the input in the next state
-				if ( debug > 2 ) NSLog(@"EOT transition");
-				s = eot[s];
-				[input consume];
-				continue;
-			}
-			if ( c == ANTLRTokenTypeEOF && eof[s] >= 0) {  // we are at EOF and may even accept the input.
-				if ( debug > 2 ) NSLog(@"accept via EOF; predict %d from %d", accept[eof[s]], eof[s]);
-				return accept[eof[s]];
-			}
-			if ( debug > 2 ) {
-                NSLog(@"no viable alt!\n");
-                NSLog(@"min[%d] = %d\n", s, min[s]);
-                NSLog(@"max[%d] = %d\n", s, min[s]);
-                NSLog(@"eot[%d] = %d\n", s, min[s]);
-                NSLog(@"eof[%d] = %d\n", s, min[s]);
-                for (NSInteger p = 0; p < self.len; p++) {
-                    NSLog(@"%d ", transition[s][p]);
-                }
-                NSLog(@"\n");
-            }
-			[self noViableAlt:s Stream:input];
-            return 0;
-		}
-	}
-	@finally {
-		[input rewind:aMark];
-	}
-	return 0; // silence warning
-}
-
-- (void) noViableAlt:(NSInteger)state Stream:(id<ANTLRIntStream>)anInput
-{
-	if ([recognizer.state isBacktracking]) {
-		[recognizer.state setFailed:YES];
-		return;
-	}
-	ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:decisionNumber state:state stream:anInput];
-	[self error:nvae];
-	@throw nvae;
-}
-
-- (NSInteger) specialStateTransition:(NSInteger)state Stream:(id<ANTLRIntStream>)anInput
-{
-    @throw [ANTLRNoViableAltException newException:-1 state:state stream:anInput];
-	return -1;
-}
-
-- (void) error:(ANTLRNoViableAltException *)nvae
-{
-	// empty, hook for debugger support
-}
-
-- (NSString *) description
-{
-	return @"subclass responsibility";
-}
-
-- (BOOL) evaluateSyntacticPredicate:(SEL)synpredFragment
-{
-	return [recognizer evaluateSyntacticPredicate:synpredFragment];
-}
-
-+ (void) setIsEmittingDebugInfo:(BOOL) shouldEmitDebugInfo
-{
-	debug = shouldEmitDebugInfo;
-}
-
-/** Given a String that has a run-length-encoding of some unsigned shorts
- *  like "\1\2\3\9", convert to short[] {2,9,9,9}.  We do this to avoid
- *  static short[] which generates so much init code that the class won't
- *  compile. :(
- */
-- (short *) unpackEncodedString:(NSString *)encodedString
-{
-    // walk first to find how big it is.
-    int size = 0;
-    for (int i=0; i < [encodedString length]; i+=2) {
-        size += [encodedString characterAtIndex:i];
-    }
-    __strong short *data = (short *)calloc(size, sizeof(short));
-    int di = 0;
-    for (int i=0; i < [encodedString length]; i+=2) {
-        char n = [encodedString characterAtIndex:i];
-        char v = [encodedString characterAtIndex:i+1];
-        // add v n times to data
-        for (int j = 0; j < n; j++) {
-            data[di++] = v;
-        }
-    }
-    return data;
-}
-
-/** Hideous duplication of code, but I need different typed arrays out :( */
-- (char *) unpackEncodedStringToUnsignedChars:(NSString *)encodedString
-{
-    // walk first to find how big it is.
-    int size = 0;
-    for (int i=0; i < [encodedString length]; i+=2) {
-        size += [encodedString characterAtIndex:i];
-    }
-    __strong short *data = (short *)calloc(size, sizeof(short));
-    int di = 0;
-    for (int i=0; i < [encodedString length]; i+=2) {
-        char n = [encodedString characterAtIndex:i];
-        char v = [encodedString characterAtIndex:i+1];
-        // add v n times to data
-        for (int j = 0; j < n; j++) {
-            data[di++] = v;
-        }
-    }
-    return (char *)data;
-}
-
-- (NSInteger)getDecision
-{
-    return decisionNumber;
-}
-
-- (void)setDecision:(NSInteger)aDecison
-{
-    decisionNumber = aDecison;
-}
-
-- (ANTLRBaseRecognizer *)getRecognizer
-{
-    return recognizer;
-}
-
-- (void)setRecognizer:(ANTLRBaseRecognizer *)aRecognizer
-{
-    if ( recognizer != aRecognizer ) {
-        if ( recognizer ) [recognizer release];
-        [aRecognizer retain];
-    }
-    recognizer = aRecognizer;
-}
-
-- (NSInteger)length
-{
-    return len;
-}
-
-@synthesize eot;
-@synthesize eof;
-@synthesize min;
-@synthesize max;
-@synthesize accept;
-@synthesize special;
-@synthesize transition;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebug.h b/runtime/ObjC/Framework/ANTLRDebug.h
deleted file mode 100644
index 87383c9..0000000
--- a/runtime/ObjC/Framework/ANTLRDebug.h
+++ /dev/null
@@ -1,33 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRDebugEventListener.h"
-#import "ANTLRDebugEventProxy.h"
-#import "ANTLRDebugParser.h"
-#import "ANTLRDebugTokenStream.h"
-#import "ANTLRDebugTreeParser.h"
-#import "ANTLRDebugTreeNodeStream.h"
-#import "ANTLRDebugTreeAdaptor.h"
diff --git a/runtime/ObjC/Framework/ANTLRDebugEventListener.h b/runtime/ObjC/Framework/ANTLRDebugEventListener.h
deleted file mode 100644
index c2bee6c..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugEventListener.h
+++ /dev/null
@@ -1,275 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRToken.h"
-#import "ANTLRRecognitionException.h"
-
-@protocol ANTLRDebugEventListener
-
-#define ANTLRDebugProtocolVersion 1
-
-/** The parser has just entered a rule.  No decision has been made about
-*  which alt is predicted.  This is fired AFTER init actions have been
-*  executed.  Attributes are defined and available etc...
-*/
-- (void) enterRule:(NSString *)ruleName;
-
-/** Because rules can have lots of alternatives, it is very useful to
-*  know which alt you are entering.  This is 1..n for n alts.
-*/
-- (void) enterAlt:(NSInteger)alt;
-
-/** This is the last thing executed before leaving a rule.  It is
-*  executed even if an exception is thrown.  This is triggered after
-*  error reporting and recovery have occurred (unless the exception is
-											   *  not caught in this rule).  This implies an "exitAlt" event.
-*/
-- (void) exitRule:(NSString *)ruleName;
-
-/** Track entry into any (...) subrule other EBNF construct */
-- (void) enterSubRule:(NSInteger)decisionNumber;
-
-- (void) exitSubRule:(NSInteger)decisionNumber;
-
-/** Every decision, fixed k or arbitrary, has an enter/exit event
-*  so that a GUI can easily track what LT/consume events are
-*  associated with prediction.  You will see a single enter/exit
-*  subrule but multiple enter/exit decision events, one for each
-*  loop iteration.
-*/
-- (void) enterDecision:(NSInteger)decisionNumber;
-
-- (void) exitDecision:(NSInteger)decisionNumber;
-
-/** An input token was consumed; matched by any kind of element.
-*  Trigger after the token was matched by things like match(), matchAny().
-*/
-- (void) consumeToken:(id<ANTLRToken>)t;
-
-/** An off-channel input token was consumed.
-*  Trigger after the token was matched by things like match(), matchAny().
-*  (unless of course the hidden token is first stuff in the input stream).
-*/
-- (void) consumeHiddenToken:(id<ANTLRToken>)t;
-
-/** Somebody (anybody) looked ahead.  Note that this actually gets
-*  triggered by both LA and LT calls.  The debugger will want to know
-*  which Token object was examined.  Like consumeToken, this indicates
-*  what token was seen at that depth.  A remote debugger cannot look
-*  ahead into a file it doesn't have so LT events must pass the token
-*  even if the info is redundant.
-*/
-- (void) LT:(NSInteger)i foundToken:(id<ANTLRToken>)t;
-
-/** The parser is going to look arbitrarily ahead; mark this location,
-*  the token stream's marker is sent in case you need it.
-*/
-- (void) mark:(NSInteger)marker;
-
-/** After an arbitrairly long lookahead as with a cyclic DFA (or with
-*  any backtrack), this informs the debugger that stream should be
-*  rewound to the position associated with marker.
-*/
-- (void) rewind:(NSInteger)marker;
-
-/** Rewind to the input position of the last marker.
-*  Used currently only after a cyclic DFA and just
-*  before starting a sem/syn predicate to get the
-*  input position back to the start of the decision.
-*  Do not "pop" the marker off the state.  mark(i)
-*  and rewind(i) should balance still.
-*/
-- (void) rewind;
-
-- (void) beginBacktrack:(NSInteger)level;
-
-- (void) endBacktrack:(NSInteger)level wasSuccessful:(BOOL)successful;
-
-/** To watch a parser move through the grammar, the parser needs to
-*  inform the debugger what line/charPos it is passing in the grammar.
-*  For now, this does not know how to switch from one grammar to the
-*  other and back for island grammars etc...
-*
-*  This should also allow breakpoints because the debugger can stop
-*  the parser whenever it hits this line/pos.
-*/
-- (void) locationLine:(NSInteger)line column:(NSInteger)pos;
-
-/** A recognition exception occurred such as NoViableAltException.  I made
-*  this a generic event so that I can alter the exception hierachy later
-*  without having to alter all the debug objects.
-*
-*  Upon error, the stack of enter rule/subrule must be properly unwound.
-*  If no viable alt occurs it is within an enter/exit decision, which
-*  also must be rewound.  Even the rewind for each mark must be unwount.
-*  In the Java target this is pretty easy using try/finally, if a bit
-*  ugly in the generated code.  The rewind is generated in DFA.predict()
-*  actually so no code needs to be generated for that.  For languages
-*  w/o this "finally" feature (C++?), the target implementor will have
-*  to build an event stack or something.
-*
-*  Across a socket for remote debugging, only the RecognitionException
-*  data fields are transmitted.  The token object or whatever that
-*  caused the problem was the last object referenced by LT.  The
-*  immediately preceding LT event should hold the unexpected Token or
-*  char.
-*
-*  Here is a sample event trace for grammar:
-*
-*  b : C ({;}A|B) // {;} is there to prevent A|B becoming a set
-*    | D
-*    ;
-*
-*  The sequence for this rule (with no viable alt in the subrule) for
-*  input 'c c' (there are 3 tokens) is:
-*
-*		commence
-*		LT(1)
-*		enterRule b
-*		location 7 1
-*		enter decision 3
-*		LT(1)
-*		exit decision 3
-*		enterAlt1
-*		location 7 5
-*		LT(1)
-*		consumeToken [c/<4>,1:0]
-*		location 7 7
-*		enterSubRule 2
-*		enter decision 2
-*		LT(1)
-*		LT(1)
-*		recognitionException NoViableAltException 2 1 2
-*		exit decision 2
-*		exitSubRule 2
-*		beginResync
-*		LT(1)
-*		consumeToken [c/<4>,1:1]
-*		LT(1)
-*		endResync
-*		LT(-1)
-*		exitRule b
-*		terminate
-*/
-- (void) recognitionException:(ANTLRRecognitionException *)e;
-
-/** Indicates the recognizer is about to consume tokens to resynchronize
-*  the parser.  Any consume events from here until the recovered event
-*  are not part of the parse--they are dead tokens.
-*/
-- (void) beginResync;
-
-/** Indicates that the recognizer has finished consuming tokens in order
-*  to resychronize.  There may be multiple beginResync/endResync pairs
-*  before the recognizer comes out of errorRecovery mode (in which
-*  multiple errors are suppressed).  This will be useful
-*  in a gui where you want to probably grey out tokens that are consumed
-*  but not matched to anything in grammar.  Anything between
-*  a beginResync/endResync pair was tossed out by the parser.
-*/
-- (void) endResync;
-
-/** A semantic predicate was evaluate with this result and action text */
-- (void) semanticPredicate:(NSString *)predicate matched:(BOOL)result;
-
-/** Announce that parsing has begun.  Not technically useful except for
-*  sending events over a socket.  A GUI for example will launch a thread
-*  to connect and communicate with a remote parser.  The thread will want
-*  to notify the GUI when a connection is made.  ANTLR parsers
-*  trigger this upon entry to the first rule (the ruleLevel is used to
-*  figure this out).
-*/
-- (void) commence;
-
-/** Parsing is over; successfully or not.  Mostly useful for telling
-*  remote debugging listeners that it's time to quit.  When the rule
-*  invocation level goes to zero at the end of a rule, we are done
-*  parsing.
-*/
-- (void) terminate;
-
-
-// T r e e  P a r s i n g
-
-/** Input for a tree parser is an AST, but we know nothing for sure
-*  about a node except its type and text (obtained from the adaptor).
-*  This is the analog of the consumeToken method.  Again, the ID is
-*  the hashCode usually of the node so it only works if hashCode is
-*  not implemented.  If the type is UP or DOWN, then
-*  the ID is not really meaningful as it's fixed--there is
-*  just one UP node and one DOWN navigation node.
-*/
-- (void) consumeNode:(NSInteger)nodeHash ofType:(NSInteger)type text:(NSString *)text;
-
-/** The tree parser lookedahead.  If the type is UP or DOWN,
-*  then the ID is not really meaningful as it's fixed--there is
-*  just one UP node and one DOWN navigation node.
-*/
-- (void) LT:(NSInteger)i foundNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text;
-
-
-// A S T  E v e n t s
-
-/** A nil was created (even nil nodes have a unique ID...
-*  they are not "null" per se).  As of 4/28/2006, this
-*  seems to be uniquely triggered when starting a new subtree
-*  such as when entering a subrule in automatic mode and when
-*  building a tree in rewrite mode.
-*/
-- (void) createNilNode:(unsigned)hash;
-
-/** Announce a new node built from text */
-- (void) createNode:(unsigned)hash text:(NSString *)text type:(NSInteger)type;
-
-/** Announce a new node built from an existing token */
-- (void) createNode:(unsigned)hash fromTokenAtIndex:(NSInteger)tokenIndex;
-
-/** Make a node the new root of an existing root.  See
-*
-*  Note: the newRootID parameter is possibly different
-*  than the TreeAdaptor.becomeRoot() newRoot parameter.
-*  In our case, it will always be the result of calling
-*  TreeAdaptor.becomeRoot() and not root_n or whatever.
-*
-*  The listener should assume that this event occurs
-*  only when the current subrule (or rule) subtree is
-*  being reset to newRootID.
-*
-*/
-- (void) makeNode:(unsigned)newRootHash parentOf:(unsigned)oldRootHash;
-
-/** Make childID a child of rootID.
-*  @see org.antlr.runtime.tree.TreeAdaptor.addChild()
-*/
-- (void) addChild:(unsigned)childHash toTree:(unsigned)treeHash;
-
-/** Set the token start/stop token index for a subtree root or node */
-- (void) setTokenBoundariesForTree:(unsigned)nodeHash From:(NSUInteger)tokenStartIndex To:(NSUInteger)tokenStopIndex;
-
-- (void) waitForDebuggerConnection;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugEventProxy.h b/runtime/ObjC/Framework/ANTLRDebugEventProxy.h
deleted file mode 100644
index af8cd33..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugEventProxy.h
+++ /dev/null
@@ -1,112 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRParser.h"
-#import "ANTLRDebugEventListener.h"
-#import <sys/socket.h>
-#import <netinet/in.h>
-#import <netinet/tcp.h>
-#include <arpa/inet.h>
-
-// default port for ANTLRWorks
-#define DEFAULT_DEBUGGER_PORT 49001
-
-@interface ANTLRDebugEventProxy : NSObject <ANTLRDebugEventListener> {
-	int serverSocket;
-
-	struct sockaddr debugger_sockaddr;
-	socklen_t debugger_socklen;
-	int debuggerSocket;
-	NSFileHandle *debuggerFH;
-
-	NSString *grammarName;
-	int debuggerPort;
-}
-
-- (id) init;
-- (id) initWithGrammarName:(NSString *)aGrammarName debuggerPort:(NSInteger)aPort;
-- (void) waitForDebuggerConnection;
-- (void) waitForAck;
-- (void) sendToDebugger:(NSString *)message;
-- (void) sendToDebugger:(NSString *)message waitForResponse:(BOOL)wait;
-
-- (NSInteger) serverSocket;
-- (void) setServerSocket: (NSInteger) aServerSocket;
-
-- (NSInteger) debuggerSocket;
-- (void) setDebuggerSocket: (NSInteger) aDebuggerSocket;
-
-- (NSString *) grammarName;
-- (void) setGrammarName: (NSString *) aGrammarName;
-
-- (NSInteger) debuggerPort;
-- (void) setDebuggerPort: (NSInteger) aDebuggerPort;
-
-- (NSString *) escapeNewlines:(NSString *)aString;
-
-#pragma mark -
-
-#pragma mark DebugEventListener Protocol
-- (void) enterRule:(NSString *)ruleName;
-- (void) enterAlt:(NSInteger)alt;
-- (void) exitRule:(NSString *)ruleName;
-- (void) enterSubRule:(NSInteger)decisionNumber;
-- (void) exitSubRule:(NSInteger)decisionNumber;
-- (void) enterDecision:(NSInteger)decisionNumber;
-- (void) exitDecision:(NSInteger)decisionNumber;
-- (void) consumeToken:(id<ANTLRToken>)t;
-- (void) consumeHiddenToken:(id<ANTLRToken>)t;
-- (void) LT:(NSInteger)i foundToken:(id<ANTLRToken>)t;
-- (void) mark:(NSInteger)marker;
-- (void) rewind:(NSInteger)marker;
-- (void) rewind;
-- (void) beginBacktrack:(NSInteger)level;
-- (void) endBacktrack:(NSInteger)level wasSuccessful:(BOOL)successful;
-- (void) locationLine:(NSInteger)line column:(NSInteger)pos;
-- (void) recognitionException:(ANTLRRecognitionException *)e;
-- (void) beginResync;
-- (void) endResync;
-- (void) semanticPredicate:(NSString *)predicate matched:(BOOL)result;
-- (void) commence;
-- (void) terminate;
-
-
-#pragma mark Tree Parsing
-- (void) consumeNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text;
-- (void) LT:(NSInteger)i foundNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text;
-
-
-#pragma mark AST Events
-
-- (void) createNilNode:(unsigned)hash;
-- (void) createNode:(unsigned)hash text:(NSString *)text type:(NSInteger)type;
-- (void) createNode:(unsigned)hash fromTokenAtIndex:(NSInteger)tokenIndex;
-- (void) makeNode:(unsigned)newRootHash parentOf:(unsigned)oldRootHash;
-- (void) addChild:(unsigned)childHash toTree:(unsigned)treeHash;
-- (void) setTokenBoundariesForTree:(unsigned)nodeHash From:(NSInteger)tokenStartIndex To:(NSInteger)tokenStopIndex;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugEventProxy.m b/runtime/ObjC/Framework/ANTLRDebugEventProxy.m
deleted file mode 100644
index f68059a..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugEventProxy.m
+++ /dev/null
@@ -1,370 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRDebugEventProxy.h"
-#import "ANTLRToken+DebuggerSupport.h"
-#include <string.h>
-
-static NSData *newlineData = nil;
-static unsigned lengthOfUTF8Ack = 0;
-
-@implementation ANTLRDebugEventProxy
-
-+ (void) initialize
-{
-	if (!newlineData) newlineData = [@"\n" dataUsingEncoding:NSUTF8StringEncoding];
-	if (!lengthOfUTF8Ack) lengthOfUTF8Ack = [[@"ack\n" dataUsingEncoding:NSUTF8StringEncoding] length];
-}
-
-- (id) init
-{
-	return [self initWithGrammarName:nil debuggerPort:DEFAULT_DEBUGGER_PORT];
-}
-
-- (id) initWithGrammarName:(NSString *)aGrammarName debuggerPort:(NSInteger)aPort
-{
-	self = [super init];
-	if (self) {
-		serverSocket = -1;
-		[self setGrammarName:aGrammarName];
-		if (aPort == -1) aPort = DEFAULT_DEBUGGER_PORT;
-		[self setDebuggerPort:aPort];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-	if (serverSocket != -1)
-		shutdown(serverSocket,SHUT_RDWR);
-	serverSocket = -1;
-	[debuggerFH release];
-    [self setGrammarName:nil];
-    [super dealloc];
-}
-
-- (void) waitForDebuggerConnection
-{
-	if (serverSocket == -1) {
-		serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
-
-		NSAssert1(serverSocket != -1, @"Failed to create debugger socket. %s", strerror(errno));
-
-		int yes = 1;
-		setsockopt(serverSocket, SOL_SOCKET, SO_KEEPALIVE|SO_REUSEPORT|SO_REUSEADDR|TCP_NODELAY, (void *)&yes, sizeof(NSInteger));
-
-		struct sockaddr_in server_addr;
-		bzero(&server_addr, sizeof(struct sockaddr_in));
-		server_addr.sin_family = AF_INET;
-		server_addr.sin_port = htons([self debuggerPort]);
-		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
-		NSAssert1( bind(serverSocket, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)) != -1, @"bind(2) failed. %s", strerror(errno));
-
-		NSAssert1(listen(serverSocket,50) == 0, @"listen(2) failed. %s", strerror(errno));
-
-		NSLog(@"ANTLR waiting for debugger attach (grammar %@)", [self grammarName]);
-
-		debuggerSocket = accept(serverSocket, &debugger_sockaddr, &debugger_socklen);
-		NSAssert1( debuggerSocket != -1, @"accept(2) failed. %s", strerror(errno));
-
-		debuggerFH = [[NSFileHandle alloc] initWithFileDescriptor:debuggerSocket];
-		[self sendToDebugger:[NSString stringWithFormat:@"ANTLR %d", ANTLRDebugProtocolVersion] waitForResponse:NO];
-		[self sendToDebugger:[NSString stringWithFormat:@"grammar \"%@", [self grammarName]] waitForResponse:NO];
-	}
-}
-
-- (void) waitForAck
-{
-	NSString *response;
-	@try {
-		NSData *newLine = [debuggerFH readDataOfLength:lengthOfUTF8Ack];
-		response = [[NSString alloc] initWithData:newLine encoding:NSUTF8StringEncoding];
-		if (![response isEqualToString:@"ack\n"]) @throw [NSException exceptionWithName:@"ANTLRDebugEventProxy" reason:@"illegal response from debugger" userInfo:nil];
-	}
-	@catch (NSException *e) {
-		NSLog(@"socket died or debugger misbehaved: %@ read <%@>", e, response);
-	}
-	@finally {
-		[response release];
-	}
-}
-
-- (void) sendToDebugger:(NSString *)message
-{
-	[self sendToDebugger:message waitForResponse:YES];
-}
-
-- (void) sendToDebugger:(NSString *)message waitForResponse:(BOOL)wait
-{
-	if (! debuggerFH ) return;
-	[debuggerFH writeData:[message dataUsingEncoding:NSUTF8StringEncoding]];
-	[debuggerFH writeData:newlineData];
-	if (wait) [self waitForAck];
-}
-
-- (NSInteger) serverSocket
-{
-    return serverSocket;
-}
-
-- (void) setServerSocket: (NSInteger) aServerSocket
-{
-    serverSocket = aServerSocket;
-}
-
-- (NSInteger) debuggerSocket
-{
-    return debuggerSocket;
-}
-
-- (void) setDebuggerSocket: (NSInteger) aDebuggerSocket
-{
-    debuggerSocket = aDebuggerSocket;
-}
-
-- (NSString *) grammarName
-{
-    return grammarName;
-}
-
-- (void) setGrammarName: (NSString *) aGrammarName
-{
-    if (grammarName != aGrammarName) {
-        [aGrammarName retain];
-        [grammarName release];
-        grammarName = aGrammarName;
-    }
-}
-
-- (NSInteger) debuggerPort
-{
-    return debuggerPort;
-}
-
-- (void) setDebuggerPort: (NSInteger) aDebuggerPort
-{
-    debuggerPort = aDebuggerPort;
-}
-
-- (NSString *) escapeNewlines:(NSString *)aString
-{
-	NSMutableString *escapedText;
-	if (aString) {
-		escapedText = [NSMutableString stringWithString:aString];
-		NSRange wholeString = NSMakeRange(0,[escapedText length]);
-		[escapedText replaceOccurrencesOfString:@"%" withString:@"%25" options:0 range:wholeString];
-		[escapedText replaceOccurrencesOfString:@"\n" withString:@"%0A" options:0 range:wholeString];
-		[escapedText replaceOccurrencesOfString:@"\r" withString:@"%0D" options:0 range:wholeString];
-	} else {
-		escapedText = [NSMutableString stringWithString:@""];
-	}
-	return escapedText;
-}
-
-#pragma mark -
-
-#pragma mark DebugEventListener Protocol
-- (void) enterRule:(NSString *)ruleName
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"enterRule %@", ruleName]];
-}
-
-- (void) enterAlt:(NSInteger)alt
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"enterAlt %d", alt]];
-}
-
-- (void) exitRule:(NSString *)ruleName
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"exitRule %@", ruleName]];
-}
-
-- (void) enterSubRule:(NSInteger)decisionNumber
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"enterSubRule %d", decisionNumber]];
-}
-
-- (void) exitSubRule:(NSInteger)decisionNumber
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"exitSubRule %d", decisionNumber]];
-}
-
-- (void) enterDecision:(NSInteger)decisionNumber
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"enterDecision %d", decisionNumber]];
-}
-
-- (void) exitDecision:(NSInteger)decisionNumber
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"exitDecision %d", decisionNumber]];
-}
-
-- (void) consumeToken:(id<ANTLRToken>)t
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"consumeToken %@", [self escapeNewlines:[t description]]]];
-}
-
-- (void) consumeHiddenToken:(id<ANTLRToken>)t
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"consumeHiddenToken %@", [self escapeNewlines:[t description]]]];
-}
-
-- (void) LT:(NSInteger)i foundToken:(id<ANTLRToken>)t
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"LT %d %@", i, [self escapeNewlines:[t description]]]];
-}
-
-- (void) mark:(NSInteger)marker
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"mark %d", marker]];
-}
-- (void) rewind:(NSInteger)marker
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"rewind %d", marker]];
-}
-
-- (void) rewind
-{
-	[self sendToDebugger:@"rewind"];
-}
-
-- (void) beginBacktrack:(NSInteger)level
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"beginBacktrack %d", level]];
-}
-
-- (void) endBacktrack:(NSInteger)level wasSuccessful:(BOOL)successful
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"endBacktrack %d %d", level, successful ? 1 : 0]];
-}
-
-- (void) locationLine:(NSInteger)line column:(NSInteger)pos
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"location %d %d", line, pos]];
-}
-
-- (void) recognitionException:(ANTLRRecognitionException *)e
-{
-#warning TODO: recognition exceptions
-	// these must use the names of the corresponding Java exception classes, because ANTLRWorks recreates the exception
-	// objects on the Java side.
-	// Write categories for Objective-C exceptions to provide those names
-}
-
-- (void) beginResync
-{
-	[self sendToDebugger:@"beginResync"];
-}
-
-- (void) endResync
-{
-	[self sendToDebugger:@"endResync"];
-}
-
-- (void) semanticPredicate:(NSString *)predicate matched:(BOOL)result
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"semanticPredicate %d %@", result?1:0, [self escapeNewlines:predicate]]];
-}
-
-- (void) commence
-{
-	// no need to send event
-}
-
-- (void) terminate
-{
-	[self sendToDebugger:@"terminate"];
-	@try {
-		[debuggerFH closeFile];
-	}
-	@finally {
-#warning TODO: make socket handling robust. too lazy now...
-		shutdown(serverSocket,SHUT_RDWR);
-		serverSocket = -1;
-	}
-}
-
-
-#pragma mark Tree Parsing
-- (void) consumeNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"consumeNode %u %d %@",
-		nodeHash,
-		type,
-		[self escapeNewlines:text]
-		]];
-}
-
-- (void) LT:(NSInteger)i foundNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"LN %d %u %d %@",
-		i,
-		nodeHash,
-		type,
-		[self escapeNewlines:text]
-		]];
-}
-
-
-#pragma mark AST Events
-
-- (void) createNilNode:(unsigned)hash
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"nilNode %u", hash]];
-}
-
-- (void) createNode:(unsigned)hash text:(NSString *)text type:(NSInteger)type
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"createNodeFromToken %u %d %@",
-		hash,
-		type,
-		[self escapeNewlines:text]
-		]];
-}
-
-- (void) createNode:(unsigned)hash fromTokenAtIndex:(NSInteger)tokenIndex
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"createNode %u %d", hash, tokenIndex]];
-}
-
-- (void) becomeRoot:(unsigned)newRootHash old:(unsigned)oldRootHash
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"becomeRoot %u %u", newRootHash, oldRootHash]];
-}
-
-- (void) addChild:(unsigned)childHash toTree:(unsigned)treeHash
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"addChild %u %u", treeHash, childHash]];
-}
-
-- (void) setTokenBoundariesForTree:(unsigned)nodeHash From:(NSInteger)tokenStartIndex To:(NSInteger)tokenStopIndex
-{
-	[self sendToDebugger:[NSString stringWithFormat:@"setTokenBoundaries %u %d %d", nodeHash, tokenStartIndex, tokenStopIndex]];
-}
-
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugParser.h b/runtime/ObjC/Framework/ANTLRDebugParser.h
deleted file mode 100644
index ed403ef..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugParser.h
+++ /dev/null
@@ -1,57 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRParser.h"
-#import "ANTLRDebugEventProxy.h"
-#import "ANTLRDebugTokenStream.h"
-
-@interface ANTLRDebugParser : ANTLRParser {
-	id<ANTLRDebugEventListener> debugListener;
-}
-
-+ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
-        debugListener:(id<ANTLRDebugEventListener>)debugListener;
-
-+ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
-                state:(ANTLRRecognizerSharedState *)state;
-
-+ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
-        debugListener:(id<ANTLRDebugEventListener>)debugListener
-                state:(ANTLRRecognizerSharedState *)state;
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream;
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
-			  debuggerPort:(NSInteger)portNumber;
-// designated initializer
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
-			 debugListener:(id<ANTLRDebugEventListener>)theDebugListener
-			  debuggerPort:(NSInteger)portNumber;
-
-- (id<ANTLRDebugEventListener>) debugListener;
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugParser.m b/runtime/ObjC/Framework/ANTLRDebugParser.m
deleted file mode 100644
index f86a8ba..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugParser.m
+++ /dev/null
@@ -1,113 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRDebugParser.h"
-
-
-@implementation ANTLRDebugParser
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
-{
-	return [self initWithTokenStream:theStream debugListener:nil debuggerPort:-1];
-}
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
-			  debuggerPort:(NSInteger)portNumber
-{
-	return [self initWithTokenStream:theStream debugListener:nil debuggerPort:portNumber];
-}
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
-			 debugListener:(id<ANTLRDebugEventListener>)theDebugListener
-			  debuggerPort:(NSInteger)portNumber
-{
-	id<ANTLRDebugEventListener,NSObject> debugger = nil;
-	id<ANTLRTokenStream> tokenStream = nil;
-	if (theDebugListener) {
-		debugger = [(id<ANTLRDebugEventListener,NSObject>)theDebugListener retain];
-		debugger = theDebugListener;
-	} else {
-		debugger = [[ANTLRDebugEventProxy alloc] initWithGrammarName:[self grammarFileName] debuggerPort:portNumber];
-	}
-	if (theStream && ![theStream isKindOfClass:[ANTLRDebugTokenStream class]]) {
-		tokenStream = [[ANTLRDebugTokenStream alloc] initWithTokenStream:theStream debugListener:debugger];
-	} else {
-		tokenStream = [theStream retain];
-		tokenStream = theStream;
-	}
-	self = [super initWithTokenStream:tokenStream];
-	if (self) {
-		[self setDebugListener:debugger];
-		[debugger release];
-		[tokenStream release];
-		[debugListener waitForDebuggerConnection];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-    [self setDebugListener: nil];
-    [super dealloc];
-}
-
-- (id<ANTLRDebugEventListener>) debugListener
-{
-    return debugListener;
-}
-
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
-{
-    if (debugListener != aDebugListener) {
-        [(id<ANTLRDebugEventListener,NSObject>)aDebugListener retain];
-        [(id<ANTLRDebugEventListener,NSObject>)debugListener release];
-        debugListener = aDebugListener;
-    }
-}
-
-#pragma mark -
-#pragma mark Overrides
-
-- (void) beginResync
-{
-	[debugListener beginResync];
-}
-
-- (void) endResync
-{
-	[debugListener endResync];
-}
-- (void)beginBacktracking:(NSInteger)level
-{
-	[debugListener beginBacktrack:level];
-}
-
-- (void)endBacktracking:(NSInteger)level wasSuccessful:(BOOL)successful
-{
-	[debugListener endBacktrack:level wasSuccessful:successful];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTokenStream.h b/runtime/ObjC/Framework/ANTLRDebugTokenStream.h
deleted file mode 100644
index 9f6c438..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugTokenStream.h
+++ /dev/null
@@ -1,62 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRParser.h"
-#import "ANTLRTokenStream.h"
-#import "ANTLRTokenSource.h"
-#import "ANTLRDebugTokenStream.h"
-#import "ANTLRDebugEventListener.h"
-
-@interface ANTLRDebugTokenStream : NSObject <ANTLRTokenStream>
-{
-	id<ANTLRDebugEventListener> debugListener;
-	id<ANTLRTokenStream> input;
-	BOOL initialStreamState;
-    NSInteger lastMarker;
-}
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream debugListener:(id<ANTLRDebugEventListener>)debugger;
-
-- (id<ANTLRDebugEventListener>) debugListener;
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;
-
-- (id<ANTLRTokenStream>) input;
-- (void) setInput:(id<ANTLRTokenStream>)aTokenStream;
-
-- (void) consume;
-- (id<ANTLRToken>) getToken:(NSInteger)index;
-- (NSInteger) getIndex;
-- (void) release:(NSInteger)marker;
-- (void) seek:(NSInteger)index;
-- (NSInteger) size;
-- (id<ANTLRTokenSource>) getTokenSource;
-- (NSString *) getSourceName;
-- (NSString *) toString;
-- (NSString *) toStringFromStart:(NSInteger)aStart ToEnd:(NSInteger)aStop;
-- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTokenStream.m b/runtime/ObjC/Framework/ANTLRDebugTokenStream.m
deleted file mode 100644
index 8a294c9..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugTokenStream.m
+++ /dev/null
@@ -1,204 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRDebugTokenStream.h"
-
-
-@implementation ANTLRDebugTokenStream
-
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream debugListener:(id<ANTLRDebugEventListener>)debugger
-{
-	self = [super init];
-	if (self) {
-		[self setDebugListener:debugger];
-		[self setInput:theStream];
-		[self.input LT:1];	// force reading first on-channel token
-		initialStreamState = YES;
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-    [self setDebugListener:nil];
-    self.input = nil;
-    [super dealloc];
-}
-
-
-- (id<ANTLRDebugEventListener>) debugListener
-{
-    return debugListener;
-}
-
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
-{
-    if (debugListener != aDebugListener) {
-        [(id<ANTLRDebugEventListener,NSObject>)aDebugListener retain];
-        [(id<ANTLRDebugEventListener,NSObject>)debugListener release];
-        debugListener = aDebugListener;
-    }
-}
-
-- (id<ANTLRTokenStream>) input
-{
-    return input;
-}
-
-- (void) setInput: (id<ANTLRTokenStream>) aTokenStream
-{
-    if (input != aTokenStream) {
-        if ( input ) [input release];
-        input = aTokenStream;
-        [input retain];
-    }
-}
-
-- (void) consumeInitialHiddenTokens
-{
-	int firstIdx = input.index;
-	for (int i = 0; i<firstIdx; i++)
-		[debugListener consumeHiddenToken:[input getToken:i]];
-	initialStreamState = NO;
-}
-
-#pragma mark -
-#pragma mark Proxy implementation
-
-// anything else that hasn't some debugger event assicioated with it, is simply
-// forwarded to the actual token stream
-- (void) forwardInvocation:(NSInvocation *)anInvocation
-{
-	[anInvocation invokeWithTarget:self.input];
-}
-
-- (void) consume
-{
-	if ( initialStreamState )
-		[self consumeInitialHiddenTokens];
-	int a = input.index;
-	id<ANTLRToken> token = [input LT:1];
-	[input consume];
-	int b = input.index;
-	[debugListener consumeToken:token];
-	if (b > a+1) // must have consumed hidden tokens
-		for (int i = a+1; i < b; i++)
-			[debugListener consumeHiddenToken:[input getToken:i]];
-}
-
-- (NSInteger) mark
-{
-	lastMarker = [input mark];
-	[debugListener mark:lastMarker];
-	return lastMarker;
-}
-
-- (void) rewind
-{
-	[debugListener rewind];
-	[input rewind];
-}
-
-- (void) rewind:(NSInteger)marker
-{
-	[debugListener rewind:marker];
-	[input rewind:marker];
-}
-
-- (id<ANTLRToken>) LT:(NSInteger)k
-{
-	if ( initialStreamState )
-		[self consumeInitialHiddenTokens];
-	[debugListener LT:k foundToken:[input LT:k]];
-	return [input LT:k];
-}
-
-- (NSInteger) LA:(NSInteger)k
-{
-	if ( initialStreamState )
-		[self consumeInitialHiddenTokens];
-	[debugListener LT:k foundToken:[input LT:k]];
-	return [input LA:k];
-}
-
-- (id<ANTLRToken>) getToken:(NSInteger)i
-{
-    return [input getToken:i];
-}
-
-- (NSInteger) getIndex
-{
-    return input.index;
-}
-
-- (void) release:(NSInteger) marker
-{
-}
-
-- (void) seek:(NSInteger)index
-{
-    // TODO: implement seek in dbg interface
-    // db.seek(index);
-    [input seek:index];
-}
-
-- (NSInteger) size
-{
-    return [input size];
-}
-
-- (id<ANTLRTokenSource>) getTokenSource
-{
-    return [input getTokenSource];
-}
-
-- (NSString *) getSourceName
-{
-    return [[input getTokenSource] getSourceName];
-}
-
-- (NSString *) description
-{
-    return [input toString];
-}
-
-- (NSString *) toString
-{
-    return [input toString];
-}
-
-- (NSString *) toStringFromStart:(NSInteger)startIndex ToEnd:(NSInteger)stopIndex
-{
-    return [input toStringFromStart:startIndex ToEnd:stopIndex];
-}
-
-- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken
-{
-    return [input toStringFromStart:[startToken getStart] ToEnd:[stopToken getStopToken]];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeAdaptor.h b/runtime/ObjC/Framework/ANTLRDebugTreeAdaptor.h
deleted file mode 100644
index f8dd07e..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugTreeAdaptor.h
+++ /dev/null
@@ -1,45 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRParser.h"
-#import "ANTLRCommonTreeAdaptor.h"
-#import "ANTLRDebugEventListener.h"
-
-@interface ANTLRDebugTreeAdaptor : ANTLRBaseTreeAdaptor {
-	id<ANTLRDebugEventListener> debugListener;
-	ANTLRCommonTreeAdaptor *treeAdaptor;
-}
-
-- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)aTreeAdaptor debugListener:(id<ANTLRDebugEventListener>)aDebugListener;
-
-- (id<ANTLRDebugEventListener>)debugListener;
-- (void) setDebugListener:(id<ANTLRDebugEventListener>)aDebugListener;
-
-- (ANTLRCommonTreeAdaptor *) getTreeAdaptor;
-- (void) setTreeAdaptor:(ANTLRCommonTreeAdaptor *)aTreeAdaptor;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeAdaptor.m b/runtime/ObjC/Framework/ANTLRDebugTreeAdaptor.m
deleted file mode 100644
index 01c4c6e..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugTreeAdaptor.m
+++ /dev/null
@@ -1,229 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRDebugTreeAdaptor.h"
-
-
-@implementation ANTLRDebugTreeAdaptor
-
-
-- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)aTreeAdaptor debugListener:(id<ANTLRDebugEventListener>)aDebugListener
-{
-	self = [super init];
-	if (self) {
-		[self setDebugListener:aDebugListener];
-		[self setTreeAdaptor:aTreeAdaptor];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-    [self setDebugListener: nil];
-    [self setTreeAdaptor: nil];
-    [super dealloc];
-}
-
-- (id<ANTLRDebugEventListener>) debugListener
-{
-    return debugListener;
-}
-
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
-{
-    if (debugListener != aDebugListener) {
-        [(id<ANTLRTreeAdaptor,NSObject>)aDebugListener retain];
-        [(id<ANTLRTreeAdaptor,NSObject>)debugListener release];
-        debugListener = aDebugListener;
-    }
-}
-
-- (ANTLRCommonTreeAdaptor *) getTreeAdaptor
-{
-    return treeAdaptor;
-}
-
-- (void) setTreeAdaptor: (ANTLRCommonTreeAdaptor *) aTreeAdaptor
-{
-    if (treeAdaptor != aTreeAdaptor) {
-        [aTreeAdaptor retain];
-        [treeAdaptor release];
-        treeAdaptor = aTreeAdaptor;
-    }
-}
-
-#pragma mark -
-#pragma mark Proxy implementation
-
-// anything else that hasn't some debugger event assicioated with it, is simply
-// forwarded to the actual token stream
-- (void) forwardInvocation:(NSInvocation *)anInvocation
-{
-	[anInvocation invokeWithTarget:[self getTreeAdaptor]];
-}
-
-#pragma mark -
-
-#pragma mark Construction
-
-- (id<ANTLRBaseTree>) newANTLRTreeWithToken:(id<ANTLRToken>) payload
-{
-	id<ANTLRBaseTree> newTree = [ANTLRCommonTree newTreeWithToken:payload];
-	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] fromTokenAtIndex:[payload getTokenIndex]];
-	return newTree;
-}
-
-- (id<ANTLRBaseTree>) emptyTree
-{
-	id<ANTLRBaseTree> newTree = [treeAdaptor newEmptyTree];
-	[debugListener createNilNode:[treeAdaptor uniqueIdForTree:newTree]];
-	return newTree;
-}
-
-/*	We don't have debug events for those:
- - (id) copyNode:(id<ANTLRBaseTree>)aNode
-{
-}
-- (id) copyTree:(id<ANTLRBaseTree>)aTree
-{
-}
-*/
-
-- (void) addChild:(id<ANTLRBaseTree>)child toTree:(id<ANTLRBaseTree>)aTree
-{
-	[treeAdaptor addChild:child toTree:aTree];
-	[debugListener addChild:[treeAdaptor uniqueIdForTree:child] toTree:[self uniqueIdForTree:aTree]];
-}
-
-- (id<ANTLRBaseTree>) becomeRoot:(id<ANTLRBaseTree>)newRoot old:(id<ANTLRBaseTree>)oldRoot
-{
-	id<ANTLRBaseTree> newTree = [treeAdaptor becomeRoot:newRoot old:oldRoot];
-	[debugListener becomeRoot:[treeAdaptor uniqueIdForTree:newTree] old:[self uniqueIdForTree:oldRoot]];
-	return newTree;
-}
-
-/* handle by forwardInvocation:
-- (NSUInteger) uniqueIdForTree:(id<ANTLRBaseTree>)aNode
-{
-}
-*/
-
-#pragma mark Rewrite Rules
-
- - (void) addTokenAsChild:(id<ANTLRToken>)child toTree:(id<ANTLRBaseTree>)aTree
-{
-	id<ANTLRBaseTree> newChild = [self newANTLRTreeWithToken:child];
-	[self addChild:newChild toTree:aTree];
-}
-
-- (id<ANTLRBaseTree>) makeToken:(id<ANTLRToken>)newRoot parentOf:(id<ANTLRBaseTree>)oldRoot
-{
-	id<ANTLRBaseTree> newNode = [self newANTLRTreeWithToken:newRoot];
-	return [self becomeRoot:newNode old:oldRoot];
-}
-
-- (id<ANTLRBaseTree>) newANTLRTreeWithTokenType:(NSInteger)tokenType
-{
-	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithTokenType:tokenType];
-	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:nil type:tokenType];
-	return newTree;
-}
-
-- (id<ANTLRBaseTree>) newANTLRTreeWithTokenType:(NSInteger)tokenType text:(NSString *)tokenText
-{
-	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithTokenType:tokenType text:tokenText];
-	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:tokenText type:tokenType];
-	return newTree;
-}
-- (id<ANTLRBaseTree>) newANTLRTreeWithToken:(id<ANTLRToken>)fromToken tokenType:(NSInteger)tokenType
-{
-	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithToken:fromToken tokenType:tokenType];
-	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:fromToken.text type:tokenType];
-	return newTree;
-}
-
-- (id<ANTLRBaseTree>) newANTLRTreeWithToken:(id<ANTLRToken>)fromToken tokenType:(NSInteger)tokenType text:(NSString *)tokenText
-{
-	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithToken:fromToken tokenType:tokenType text:tokenText];
-	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:tokenText type:tokenType];
-	return newTree;
-}
-
-- (id<ANTLRBaseTree>) newANTLRTreeWithToken:(id<ANTLRToken>)fromToken text:(NSString *)tokenText
-{
-	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithToken:fromToken text:tokenText];
-	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:tokenText type:fromToken.type];
-	return newTree;
-}
-
-#pragma mark Content
-
-/* handled by forwardInvocation:
-- (NSInteger) tokenTypeForNode:(id<ANTLRBaseTree>)aNode
-{
-}
-
-- (void) setTokenType:(NSInteger)tokenType forNode:(id)aNode
-{
-}
-
-- (NSString *) textForNode:(id<ANTLRBaseTree>)aNode
-{
-}
-
-- (void) setText:(NSString *)tokenText forNode:(id<ANTLRBaseTree>)aNode
-{
-}
-*/
-- (void) setBoundariesForTree:(id<ANTLRBaseTree>)aTree fromToken:(id<ANTLRToken>)startToken toToken:(id<ANTLRToken>)stopToken
-{
-	[treeAdaptor setBoundariesForTree:aTree fromToken:startToken toToken:stopToken];
-	if (aTree && startToken && stopToken) {
-		[debugListener setTokenBoundariesForTree:[aTree hash] From:[startToken getTokenIndex] To:[stopToken getTokenIndex]];
-	}
-}
-/* handled by forwardInvocation:
-- (NSInteger) tokenStartIndexForTree:(id<ANTLRBaseTree>)aTree
-{
-}
-
-- (NSInteger) tokenStopIndexForTree:(id<ANTLRBaseTree>)aTree
-{
-}
-*/
-
-#pragma mark Navigation / Tree Parsing
-/* handled by forwardInvocation:
-- (id<ANTLRBaseTree>) childForNode:(id<ANTLRBaseTree>) aNode atIndex:(NSInteger) i
-{
-}
-
-- (NSInteger) childCountForTree:(id<ANTLRBaseTree>) aTree
-{
-}
-*/
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.h b/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.h
deleted file mode 100644
index 733f6fd..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.h
+++ /dev/null
@@ -1,67 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRDebugEventListener.h"
-#import "ANTLRTreeAdaptor.h"
-#import "ANTLRTreeNodeStream.h"
-
-@interface ANTLRDebugTreeNodeStream : NSObject <ANTLRTreeNodeStream> {
-	id<ANTLRDebugEventListener> debugListener;
-	id<ANTLRTreeAdaptor> treeAdaptor;
-	id<ANTLRTreeNodeStream> input;
-	BOOL initialStreamState;
-}
-
-- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream debugListener:(id<ANTLRDebugEventListener>)debugger;
-
-- (id<ANTLRDebugEventListener>) debugListener;
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;
-
-- (id<ANTLRTreeNodeStream>) input;
-- (void) setInput: (id<ANTLRTreeNodeStream>) aTreeNodeStream;
-
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void) setTreeAdaptor: (id<ANTLRTreeAdaptor>) aTreeAdaptor;
-
-#pragma mark ANTLRTreeNodeStream conformance
-
-- (id) LT:(NSInteger)k;
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void) setUniqueNavigationNodes:(BOOL)flag;
-
-#pragma mark ANTLRIntStream conformance
-- (void) consume;
-- (NSInteger) LA:(NSUInteger) i;
-- (NSUInteger) mark;
-- (NSUInteger) getIndex;
-- (void) rewind:(NSUInteger) marker;
-- (void) rewind;
-- (void) release:(NSUInteger) marker;
-- (void) seek:(NSUInteger) index;
-- (NSUInteger) size;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m
deleted file mode 100644
index 37f55de..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugTreeNodeStream.m
+++ /dev/null
@@ -1,175 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRDebugTreeNodeStream.h"
-
-
-@implementation ANTLRDebugTreeNodeStream
-
-- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream debugListener:(id<ANTLRDebugEventListener>)debugger
-{
-	self = [super init];
-	if (self) {
-		[self setDebugListener:debugger];
-		[self setTreeAdaptor:[theStream treeAdaptor]];
-		[self setInput:theStream];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-    [self setDebugListener: nil];
-    [self setTreeAdaptor: nil];
-    input = nil;
-    [super dealloc];
-}
-
-- (id<ANTLRDebugEventListener>) debugListener
-{
-    return debugListener;
-}
-
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
-{
-    if (debugListener != aDebugListener) {
-        [(id<ANTLRDebugEventListener,NSObject>)aDebugListener retain];
-        [(id<ANTLRDebugEventListener,NSObject>)debugListener release];
-        debugListener = aDebugListener;
-    }
-}
-
-
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor
-{
-    return treeAdaptor;
-}
-
-- (void) setTreeAdaptor: (id<ANTLRTreeAdaptor>) aTreeAdaptor
-{
-    if (treeAdaptor != aTreeAdaptor) {
-        [(id<ANTLRTreeAdaptor,NSObject>)aTreeAdaptor retain];
-        [(id<ANTLRTreeAdaptor,NSObject>)treeAdaptor release];
-        treeAdaptor = aTreeAdaptor;
-    }
-}
-
-
-- (id<ANTLRTreeNodeStream>) input
-{
-    return input;
-}
-
-- (void) setInput:(id<ANTLRTreeNodeStream>) aTreeNodeStream
-{
-    if (input != aTreeNodeStream) {
-        [input release];
-        [(id<ANTLRTreeNodeStream,NSObject>)aTreeNodeStream retain];
-    }
-    input = aTreeNodeStream;
-}
-
-
-#pragma mark ANTLRTreeNodeStream conformance
-
-- (id) LT:(NSInteger)k
-{
-	id node = [input LT:k];
-	unsigned hash = [treeAdaptor uniqueIdForTree:node];
-	NSString *text = [treeAdaptor textForNode:node];
-	int type = [treeAdaptor tokenTypeForNode:node];
-	[debugListener LT:k foundNode:hash ofType:type text:text];
-	return node;
-}
-
-- (void) setUniqueNavigationNodes:(BOOL)flag
-{
-	[input setUniqueNavigationNodes:flag];
-}
-
-#pragma mark ANTLRIntStream conformance
-- (void) consume
-{
-	id node = [input LT:1];
-	[input consume];
-	unsigned hash = [treeAdaptor uniqueIdForTree:node];
-	NSString *theText = [treeAdaptor textForNode:node];
-	int aType = [treeAdaptor tokenTypeForNode:node];
-	[debugListener consumeNode:hash ofType:aType text:theText];
-}
-
-- (NSInteger) LA:(NSUInteger) i
-{
-	id<ANTLRBaseTree> node = [self LT:1];
-	return node.type;
-}
-
-- (NSUInteger) mark
-{
-	unsigned lastMarker = [input mark];
-	[debugListener mark:lastMarker];
-	return lastMarker;
-}
-
-- (NSUInteger) getIndex
-{
-	return input.index;
-}
-
-- (void) rewind:(NSUInteger) marker
-{
-	[input rewind:marker];
-	[debugListener rewind:marker];
-}
-
-- (void) rewind
-{
-	[input rewind];
-	[debugListener rewind];
-}
-
-- (void) release:(NSUInteger) marker
-{
-	[input release:marker];
-}
-
-- (void) seek:(NSUInteger) index
-{
-	[input seek:index];
-	// todo: seek missing in debug protocol
-}
-
-- (NSUInteger) size
-{
-	return [input size];
-}
-
-- (NSString *) toStringFromToken:(id)startNode ToToken:(id)stopNode
-{
-    return [input toStringFromToken:(id<ANTLRToken>)startNode ToToken:(id<ANTLRToken>)stopNode];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeParser.h b/runtime/ObjC/Framework/ANTLRDebugTreeParser.h
deleted file mode 100644
index 171c1e7..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugTreeParser.h
+++ /dev/null
@@ -1,52 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTreeParser.h"
-#import "ANTLRDebugEventProxy.h"
-#import "ANTLRDebugTreeNodeStream.h"
-
-@interface ANTLRDebugTreeParser : ANTLRTreeParser {
-	id<ANTLRDebugEventListener> debugListener;
-}
-
-- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream;
-- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
-				 debuggerPort:(NSInteger)portNumber;
-	// designated initializer
-- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
-				debugListener:(id<ANTLRDebugEventListener>)theDebugListener
-				 debuggerPort:(NSInteger)portNumber;
-
-- (id<ANTLRDebugEventListener>) debugListener;
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;
-
-- (void) recoverFromMismatchedToken:(id<ANTLRIntStream>)inputStream
-						  exception:(NSException *)e
-						  tokenType:(ANTLRTokenType)ttype
-							 follow:(ANTLRBitSet *)follow;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDebugTreeParser.m b/runtime/ObjC/Framework/ANTLRDebugTreeParser.m
deleted file mode 100644
index 5692993..0000000
--- a/runtime/ObjC/Framework/ANTLRDebugTreeParser.m
+++ /dev/null
@@ -1,128 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRDebugTreeParser.h"
-
-
-@implementation ANTLRDebugTreeParser
-
-- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
-{
-	return [self initWithTreeNodeStream:theStream debugListener:nil debuggerPort:-1];
-}
-
-- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
-				 debuggerPort:(NSInteger)portNumber
-{
-	return [self initWithTreeNodeStream:theStream debugListener:nil debuggerPort:portNumber];
-}
-
-- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
-				debugListener:(id<ANTLRDebugEventListener>)theDebugListener
-				 debuggerPort:(NSInteger)portNumber
-{
-	id<ANTLRDebugEventListener,NSObject> debugger = nil;
-	id<ANTLRTreeNodeStream> treeNodeStream = nil;
-	if (theDebugListener) {
-		debugger = (id<ANTLRDebugEventListener>)theDebugListener;
-	} else {
-		debugger = [[ANTLRDebugEventProxy alloc] initWithGrammarName:[self grammarFileName] debuggerPort:portNumber];
-	}
-	if (theStream && ![theStream isKindOfClass:[ANTLRDebugTreeNodeStream class]]) {
-		treeNodeStream = [[ANTLRDebugTreeNodeStream alloc] initWithTreeNodeStream:theStream debugListener:debugger];
-	} else {
-		treeNodeStream = theStream;
-	}
-	self = [super initWithStream:treeNodeStream];
-	if ( self ) {
-		[self setDebugListener:debugger];
-		//[debugger release];
-		//[treeNodeStream release];
-		[debugListener waitForDebuggerConnection];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-    [self setDebugListener: nil];
-    [super dealloc];
-}
-
-- (id<ANTLRDebugEventListener>) debugListener
-{
-    return debugListener;
-}
-
-- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
-{
-    if (debugListener != aDebugListener) {
-        [(id<ANTLRDebugEventListener,NSObject>)aDebugListener retain];
-        [(id<ANTLRDebugEventListener,NSObject>)debugListener release];
-        debugListener = aDebugListener;
-    }
-}
-
-#pragma mark -
-#pragma mark Overrides
-
-- (void) beginResync
-{
-	[debugListener beginResync];
-}
-
-- (void) endResync
-{
-	[debugListener endResync];
-}
-- (void)beginBacktracking:(NSInteger)level
-{
-	[debugListener beginBacktrack:level];
-}
-
-- (void)endBacktracking:(NSInteger)level wasSuccessful:(BOOL)successful
-{
-	[debugListener endBacktrack:level wasSuccessful:successful];
-}
-
-- (void) recoverFromMismatchedToken:(id<ANTLRIntStream>)inputStream
-						  exception:(NSException *)e
-						  tokenType:(ANTLRTokenType)ttype
-							 follow:(ANTLRBitSet *)follow
-{
-#warning TODO: recoverFromMismatchedToken in debugger
-	[self recoverFromMismatchedToken:inputStream exception:e follow:follow];
-}
-
-- (void) recoverFromMismatchedSet:(id<ANTLRIntStream>)inputStream
-						exception:(NSException *)e
-						   follow:(ANTLRBitSet *)follow
-{
-#warning TODO: recoverFromMismatchedSet in debugger
-	[super recoverFromMismatchedSet:inputStream];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDoubleKeyMap.h b/runtime/ObjC/Framework/ANTLRDoubleKeyMap.h
deleted file mode 100644
index 7885879..0000000
--- a/runtime/ObjC/Framework/ANTLRDoubleKeyMap.h
+++ /dev/null
@@ -1,28 +0,0 @@
-
-#import "AMutableArray.h"
-#import "AMutableDictionary.h"
-#import "ANTLRLinkBase.h"
-/**
- * Sometimes we need to map a key to a value but key is two pieces of data.
- * This nested hash table saves creating a single key each time we access
- * map; avoids mem creation.
- */
-
-@class AMutableArray;
-
-@interface ANTLRDoubleKeyMap : ANTLRLinkBase {
-    AMutableDictionary *data;
-}
-
-- (id) init;
-- (id) setObject:(id)v forKey1:(id)k1 forKey2:(NSString *)k2;
-- (id) objectForKey1:(id)k1 forKey2:(id)k2;
-- (AMutableDictionary *) objectForKey:(id)k1;
-- (NSArray *) valuesForKey:(id)k1;
-- (NSArray *) allKeys1;
-- (AMutableArray *) allKeys2:(id)k1;
-- (NSArray *) values;
-
-@property (retain) AMutableDictionary *data;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRDoubleKeyMap.m b/runtime/ObjC/Framework/ANTLRDoubleKeyMap.m
deleted file mode 100644
index 3642ef0..0000000
--- a/runtime/ObjC/Framework/ANTLRDoubleKeyMap.m
+++ /dev/null
@@ -1,101 +0,0 @@
-#import "ANTLRDoubleKeyMap.h"
-
-@implementation ANTLRDoubleKeyMap
-
-- (id) init
-{
-    self = [super init];
-    if ( self  != nil ) {
-        data = [[AMutableDictionary dictionaryWithCapacity:30] retain];
-    }
-    return self;
-}
-
-- (id) setObject:(id)v forKey1:(id)k1 forKey2:(id)k2
-{
-    AMutableDictionary *data2 = [data objectForKey:k1];
-    id prev = nil;
-    if ( data2 == nil ) {
-        data2 = [AMutableDictionary dictionaryWithCapacity:30];
-        [data setObject:data2 forKey:k1];
-    }
-    else {
-        prev = [data2 objectForKey:k2];
-    }
-    [data2 setObject:v forKey:k2];
-    return prev;
-}
-
-- (id) objectForKey1:(id)k1 forKey2:(id)k2
-{
-    AMutableDictionary *data2 = [data objectForKey:k1];
-    if ( data2 == nil )
-        return nil;
-    return [data2 objectForKey:k2];
-}
-
-- (AMutableDictionary *) objectForKey:(id)k1
-{
-    return [data objectForKey:k1];
-}
-
-
-/**
- * Get all values associated with primary key
- */
-- (NSArray *) valuesForKey:(id)k1
-{
-    AMutableDictionary *data2 = [data objectForKey:k1];
-    if ( data2 == nil )
-        return nil;
-    return [data2 allValues];
-}
-
-
-/**
- * get all primary keys
- */
-- (NSArray *) allKeys1
-{
-    return [data allKeys];
-}
-
-
-/**
- * get all secondary keys associated with a primary key
- */
-- (NSArray *) allKeys2:(id)k1
-{
-    AMutableDictionary * data2 = [data objectForKey:k1];
-    if ( data2 == nil )
-        return nil;
-    return [data2 allKeys];
-}
-
-- (AMutableArray *) values
-{
-//    ANTLRHashMap *s = [[ANTLRHashMap newANTLRHashMapWithLen:30];
-    AMutableArray *s = [AMutableArray arrayWithCapacity:30];
-
-    for (AMutableDictionary *k2 in [data allValues]) {
-
-        for ( NSString *v in [k2 allValues]) {
-            [s addObject:v];
-        }
-
-    }
-
-    return s;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRCommonToken" );
-#endif
-    [data release];
-    [super dealloc];
-}
-
-@synthesize data;
-@end
diff --git a/runtime/ObjC/Framework/ANTLREarlyExitException.h b/runtime/ObjC/Framework/ANTLREarlyExitException.h
deleted file mode 100644
index 07e840d..0000000
--- a/runtime/ObjC/Framework/ANTLREarlyExitException.h
+++ /dev/null
@@ -1,39 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRecognitionException.h"
-
-@interface ANTLREarlyExitException : ANTLRRecognitionException {
-	int decisionNumber;
-}
-
-+ (ANTLREarlyExitException *) newException:(id<ANTLRIntStream>)anInputStream decisionNumber:(NSInteger)aDecisionNumber;
-- (id) initWithStream:(id<ANTLRIntStream>)anInputStream decisionNumber:(NSInteger) aDecisionNumber;
-
-@property int decisionNumber;
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLREarlyExitException.m b/runtime/ObjC/Framework/ANTLREarlyExitException.m
deleted file mode 100644
index 81ffb26..0000000
--- a/runtime/ObjC/Framework/ANTLREarlyExitException.m
+++ /dev/null
@@ -1,54 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLREarlyExitException.h"
-
-
-@implementation ANTLREarlyExitException
-
-+ (ANTLREarlyExitException *) newException:(id<ANTLRIntStream>) anInputStream decisionNumber:(NSInteger) aDecisionNumber
-{
-	return [[self alloc] initWithStream:anInputStream decisionNumber:aDecisionNumber];
-}
-
-- (id) initWithStream:(id<ANTLRIntStream>)anInputStream decisionNumber:(NSInteger) aDecisionNumber
-{
-	if ((self = [super initWithStream:anInputStream]) != nil) {
-		decisionNumber = aDecisionNumber;
-	}
-	return self;
-}
-
-- (NSString *) description
-{
-	NSMutableString *desc = (NSMutableString *)[super description];
-	[desc appendFormat:@" decision:%d", decisionNumber];
-	return desc;
-}
-
-@synthesize decisionNumber;
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRFailedPredicateException.h b/runtime/ObjC/Framework/ANTLRFailedPredicateException.h
deleted file mode 100644
index afbb653..0000000
--- a/runtime/ObjC/Framework/ANTLRFailedPredicateException.h
+++ /dev/null
@@ -1,50 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRecognitionException.h"
-
-
-@interface ANTLRFailedPredicateException : ANTLRRecognitionException
-{
-	NSString *predicate;
-	NSString *ruleName;
-}
-
-@property (retain) NSString *predicate;
-@property (retain) NSString *ruleName;
-
-+ (ANTLRFailedPredicateException *) newException:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream;
-- (ANTLRFailedPredicateException *) initWithRuleName:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream;
-
-#ifdef DONTUSEYET
-- (NSString *) getPredicate;
-- (void) setPredicate:(NSString *)thePredicate;
-- (NSString *) getRuleName;
-- (void) setRuleName:(NSString *)theRuleName;
-#endif
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRFailedPredicateException.m b/runtime/ObjC/Framework/ANTLRFailedPredicateException.m
deleted file mode 100644
index caf7716..0000000
--- a/runtime/ObjC/Framework/ANTLRFailedPredicateException.m
+++ /dev/null
@@ -1,96 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 20110 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRFailedPredicateException.h"
-
-
-@implementation ANTLRFailedPredicateException
-
-@synthesize predicate;
-@synthesize ruleName;
-
-+ (ANTLRFailedPredicateException *) newException:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream
-{
-	return [[ANTLRFailedPredicateException alloc] initWithRuleName:theRuleName predicate:thePredicate stream:theStream];
-}
-
-- (ANTLRFailedPredicateException *) initWithRuleName:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream
-{
-	if ((self = [super initWithStream:theStream])) {
-		[self setPredicate:thePredicate];
-		[self setRuleName:theRuleName];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRFailedPredicateException" );
-#endif
-	[self setPredicate:nil];
-	[self setRuleName:nil];
-	[super dealloc];
-}
-
-- (NSString *) description
-{
-	NSMutableString *desc = (NSMutableString *)[super description];
-	[desc appendFormat:@" rule: %@ predicate failed: %@", ruleName, predicate];
-	return desc;
-}
-
-#ifdef DONTUSEYET
-- (NSString *) getPredicate
-{
-	return predicate;
-}
-
-- (void) setPredicate:(NSString *)thePredicate
-{
-	if (thePredicate != predicate) {
-		[thePredicate retain];
-		if ( predicate ) [predicate release];
-		predicate = thePredicate;
-	}
-}
-
-- (NSString *) getRuleName
-{
-	return ruleName;
-}
-
-- (void) setRuleName:(NSString *)theRuleName
-{
-	if (theRuleName != ruleName) {
-		[theRuleName retain];
-		if ( ruleName ) [ruleName release];
-		ruleName = theRuleName;
-	}
-}
-#endif
-
-@end
diff --git a/runtime/ObjC/Framework/BaseMapElement.h b/runtime/ObjC/Framework/BaseMapElement.h
new file mode 100644
index 0000000..ce5a454
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseMapElement.h
@@ -0,0 +1,51 @@
+//
+//  BaseMapElement.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "LinkBase.h"
+
+@interface BaseMapElement : LinkBase {
+    NSNumber *index;
+}
+
+@property (retain) NSNumber *index;
+
++ (id) newBaseMapElement;
++ (id) newBaseMapElementWithIndex:(NSNumber *)anIdx;
+- (id) init;
+- (id) initWithAnIndex:(NSNumber *)anIdx;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (NSInteger)count;
+- (NSInteger)size;
+
+@end
diff --git a/runtime/ObjC/Framework/BaseMapElement.m b/runtime/ObjC/Framework/BaseMapElement.m
new file mode 100644
index 0000000..911b1af
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseMapElement.m
@@ -0,0 +1,95 @@
+//
+//  BaseMapElement.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "BaseMapElement.h"
+
+
+@implementation BaseMapElement
+
+@synthesize index;
+
++ (BaseMapElement *)newBaseMapElement
+{
+    return [[BaseMapElement alloc] init];
+}
+
++ (BaseMapElement *)newBaseMapElementWithIndex:(NSNumber *)aNumber
+{
+    return [[BaseMapElement alloc] initWithAnIndex:(NSNumber *)aNumber];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil ) {
+        index = nil;
+    }
+    return (self);
+}
+
+- (id) initWithAnIndex:(NSNumber *)aNumber
+{
+    if ((self = [super init]) != nil ) {
+        index = aNumber;
+        if ( index ) [index retain];
+    }
+    return (self);
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in BaseMapElement" );
+#endif
+    if ( index ) [index release];
+    [super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    BaseMapElement *copy;
+
+    copy = [super copyWithZone:aZone];
+    copy.index = index;
+    return( copy );
+}
+
+- (NSInteger)count
+{
+    return 1;
+}
+
+
+- (NSInteger)size
+{
+    return(  sizeof(index) );
+}
+
+@end
diff --git a/runtime/ObjC/Framework/BaseRecognizer.h b/runtime/ObjC/Framework/BaseRecognizer.h
new file mode 100644
index 0000000..346a857
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseRecognizer.h
@@ -0,0 +1,180 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import <Foundation/Foundation.h>
+
+#import "ANTLRIntStream.h"
+#import "AMutableArray.h"
+
+// This is an abstract superclass for lexers and parsers.
+
+#define ANTLR_MEMO_RULE_FAILED -2
+#define ANTLR_MEMO_RULE_UNKNOWN -1
+#define ANTLR_INITIAL_FOLLOW_STACK_SIZE 100
+
+#import "ANTLRMapElement.h"
+#import "ANTLRBitSet.h"
+#import "ANTLRToken.h"
+#import "ANTLRRecognizerSharedState.h"
+#import "ANTLRRecognitionException.h"
+#import "ANTLRMissingTokenException.h"
+#import "ANTLRMismatchedTokenException.h"
+#import "ANTLRMismatchedTreeNodeException.h"
+#import "ANTLRUnwantedTokenException.h"
+#import "ANTLRNoViableAltException.h"
+#import "ANTLREarlyExitException.h"
+#import "ANTLRMismatchedSetException.h"
+#import "ANTLRMismatchedNotSetException.h"
+#import "ANTLRFailedPredicateException.h"
+
+@interface ANTLRBaseRecognizer : NSObject {
+    __strong ANTLRRecognizerSharedState *state;  // the state of this recognizer. Might be shared with other recognizers, e.g. in grammar import scenarios.
+    __strong NSString *grammarFileName;          // where did the grammar come from. filled in by codegeneration
+    __strong NSString *sourceName;
+    __strong AMutableArray *tokenNames;
+}
+
++ (void) initialize;
+
++ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer;
++ (ANTLRBaseRecognizer *) newANTLRBaseRecognizerWithRuleLen:(NSInteger)aLen;
++ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer:(ANTLRRecognizerSharedState *)aState;
+
++ (AMutableArray *)getTokenNames;
++ (void)setTokenNames:(NSArray *)aTokNamArray;
++ (void)setGrammarFileName:(NSString *)aFileName;
+
+- (id) init;
+- (id) initWithLen:(NSInteger)aLen;
+- (id) initWithState:(ANTLRRecognizerSharedState *)aState;
+
+- (void) dealloc;
+
+// simple accessors
+- (NSInteger) getBacktrackingLevel;
+- (void) setBacktrackingLevel:(NSInteger) level;
+
+- (BOOL) getFailed;
+- (void) setFailed: (BOOL) flag;
+
+- (ANTLRRecognizerSharedState *) getState;
+- (void) setState:(ANTLRRecognizerSharedState *) theState;
+
+// reset this recognizer - might be extended by codegeneration/grammar
+- (void) reset;
+
+/** Match needs to return the current input symbol, which gets put
+ *  into the label for the associated token ref; e.g., x=ID.  Token
+ *  and tree parsers need to return different objects. Rather than test
+ *  for input stream type or change the IntStream interface, I use
+ *  a simple method to ask the recognizer to tell me what the current
+ *  input symbol is.
+ *
+ *  This is ignored for lexers.
+ */
+- (id) input;
+
+- (void)skip;
+
+// do actual matching of tokens/characters
+- (id) match:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)ttype Follow:(ANTLRBitSet *)follow;
+- (void) matchAny:(id<ANTLRIntStream>)anInput;
+- (BOOL) mismatchIsUnwantedToken:(id<ANTLRIntStream>)anInput TokenType:(NSInteger) ttype;
+- (BOOL) mismatchIsMissingToken:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *)follow;
+
+// error reporting and recovery
+- (void) reportError:(ANTLRRecognitionException *)e;
+- (void) displayRecognitionError:(AMutableArray *)theTokNams Exception:(ANTLRRecognitionException *)e;
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)theTokNams;
+- (NSInteger) getNumberOfSyntaxErrors;
+- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e;
+- (NSString *)getTokenErrorDisplay:(id<ANTLRToken>)t;
+- (void) emitErrorMessage:(NSString *)msg;
+- (void) recover:(id<ANTLRIntStream>)anInput Exception:(ANTLRRecognitionException *)e;
+
+// begin hooks for debugger
+- (void) beginResync;
+- (void) endResync;
+// end hooks for debugger
+
+// compute the bitsets necessary to do matching and recovery
+- (ANTLRBitSet *)computeErrorRecoverySet;
+- (ANTLRBitSet *)computeContextSensitiveRuleFOLLOW;
+- (ANTLRBitSet *)combineFollows:(BOOL) exact;
+
+- (id<ANTLRToken>) recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput
+                                    TokenType:(NSInteger)ttype
+                                       Follow:(ANTLRBitSet *)follow;
+
+- (id<ANTLRToken>)recoverFromMismatchedSet:(id<ANTLRIntStream>)anInput
+                                    Exception:(ANTLRRecognitionException *)e
+                                    Follow:(ANTLRBitSet *)follow;
+
+- (id) getCurrentInputSymbol:(id<ANTLRIntStream>)anInput;
+- (id) getMissingSymbol:(id<ANTLRIntStream>)anInput
+              Exception:(ANTLRRecognitionException *)e
+              TokenType:(NSInteger) expectedTokenType
+                Follow:(ANTLRBitSet *)follow;
+
+// helper methods for recovery. try to resync somewhere
+- (void) consumeUntilTType:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)ttype;
+- (void) consumeUntilFollow:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *)bitSet;
+- (void) pushFollow:(ANTLRBitSet *)fset;
+- (ANTLRBitSet *)popFollow;
+
+// to be used by the debugger to do reporting. maybe hook in incremental stuff here, too.
+- (AMutableArray *) getRuleInvocationStack;
+- (AMutableArray *) getRuleInvocationStack:(ANTLRRecognitionException *)exception
+                                 Recognizer:(NSString *)recognizerClassName;
+
+- (AMutableArray *) getTokenNames;
+- (NSString *)getGrammarFileName;
+- (NSString *)getSourceName;
+- (AMutableArray *) toStrings:(NSArray *)tokens;
+// support for memoization
+- (NSInteger) getRuleMemoization:(NSInteger)ruleIndex StartIndex:(NSInteger)ruleStartIndex;
+- (BOOL) alreadyParsedRule:(id<ANTLRIntStream>)anInput RuleIndex:(NSInteger)ruleIndex;
+- (void) memoize:(id<ANTLRIntStream>)anInput
+         RuleIndex:(NSInteger)ruleIndex
+        StartIndex:(NSInteger)ruleStartIndex;
+- (NSInteger) getRuleMemoizationCacheSize;
+- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol;
+- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol;
+
+
+// support for syntactic predicates. these are called indirectly to support funky stuff in grammars,
+// like supplying selectors instead of writing code directly into the actions of the grammar.
+- (BOOL) evaluateSyntacticPredicate:(SEL)synpredFragment;
+// stream:(id<ANTLRIntStream>)anInput;
+
+@property (retain) ANTLRRecognizerSharedState *state;
+@property (retain) NSString *grammarFileName;
+@property (retain) NSString *sourceName;
+@property (retain) AMutableArray *tokenNames;
+
+@end
diff --git a/runtime/ObjC/Framework/BaseRecognizer.m b/runtime/ObjC/Framework/BaseRecognizer.m
new file mode 100644
index 0000000..573e0dc
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseRecognizer.m
@@ -0,0 +1,1129 @@
+//
+//  ANTLRBaseRecognizer.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRBaseRecognizer.h"
+#import "ANTLRHashRule.h"
+#import "ANTLRRuleMemo.h"
+#import "ANTLRCommonToken.h"
+#import "ANTLRMap.h"
+
+extern NSInteger debug;
+
+@implementation ANTLRBaseRecognizer
+
+static AMutableArray *_tokenNames;
+static NSString *_grammarFileName;
+static NSString *NEXT_TOKEN_RULE_NAME;
+
+@synthesize state;
+@synthesize grammarFileName;
+//@synthesize failed;
+@synthesize sourceName;
+//@synthesize numberOfSyntaxErrors;
+@synthesize tokenNames;
+
++ (void) initialize
+{
+    NEXT_TOKEN_RULE_NAME = [NSString stringWithString:@"nextToken"];
+    [NEXT_TOKEN_RULE_NAME retain];
+}
+
++ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer
+{
+    return [[ANTLRBaseRecognizer alloc] init];
+}
+
++ (ANTLRBaseRecognizer *) newANTLRBaseRecognizerWithRuleLen:(NSInteger)aLen
+{
+    return [[ANTLRBaseRecognizer alloc] initWithLen:aLen];
+}
+
++ (ANTLRBaseRecognizer *) newANTLRBaseRecognizer:(ANTLRRecognizerSharedState *)aState
+{
+	return [[ANTLRBaseRecognizer alloc] initWithState:aState];
+}
+
++ (AMutableArray *)getTokenNames
+{
+    return _tokenNames;
+}
+
++ (void)setTokenNames:(AMutableArray *)theTokNams
+{
+    if ( _tokenNames != theTokNams ) {
+        if ( _tokenNames ) [_tokenNames release];
+        [theTokNams retain];
+    }
+    _tokenNames = theTokNams;
+}
+
++ (void)setGrammarFileName:(NSString *)aFileName
+{
+    if ( _grammarFileName != aFileName ) {
+        if ( _grammarFileName ) [_grammarFileName release];
+        [aFileName retain];
+    }
+    [_grammarFileName retain];
+}
+
+- (id) init
+{
+	if ((self = [super init]) != nil) {
+        if (state == nil) {
+            state = [[ANTLRRecognizerSharedState newANTLRRecognizerSharedState] retain];
+        }
+        tokenNames = _tokenNames;
+        if ( tokenNames ) [tokenNames retain];
+        grammarFileName = _grammarFileName;
+        if ( grammarFileName ) [grammarFileName retain];
+        state._fsp = -1;
+        state.errorRecovery = NO;		// are we recovering?
+        state.lastErrorIndex = -1;
+        state.failed = NO;				// indicate that some match failed
+        state.syntaxErrors = 0;
+        state.backtracking = 0;			// the level of backtracking
+        state.tokenStartCharIndex = -1;
+	}
+	return self;
+}
+
+- (id) initWithLen:(NSInteger)aLen
+{
+	if ((self = [super init]) != nil) {
+        if (state == nil) {
+            state = [[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:aLen] retain];
+        }
+        tokenNames = _tokenNames;
+        if ( tokenNames ) [tokenNames retain];
+        grammarFileName = _grammarFileName;
+        if ( grammarFileName ) [grammarFileName retain];
+        state._fsp = -1;
+        state.errorRecovery = NO;		// are we recovering?
+        state.lastErrorIndex = -1;
+        state.failed = NO;				// indicate that some match failed
+        state.syntaxErrors = 0;
+        state.backtracking = 0;			// the level of backtracking
+        state.tokenStartCharIndex = -1;
+	}
+	return self;
+}
+
+- (id) initWithState:(ANTLRRecognizerSharedState *)aState
+{
+	if ((self = [super init]) != nil) {
+		state = aState;
+        if (state == nil) {
+            state = [ANTLRRecognizerSharedState newANTLRRecognizerSharedState];
+        }
+        [state retain];
+        tokenNames = _tokenNames;
+        if ( tokenNames ) [tokenNames retain];
+        grammarFileName = _grammarFileName;
+        if ( grammarFileName ) [grammarFileName retain];
+        state._fsp = -1;
+        state.errorRecovery = NO;		// are we recovering?
+        state.lastErrorIndex = -1;
+        state.failed = NO;				// indicate that some match failed
+        state.syntaxErrors = 0;
+        state.backtracking = 0;			// the level of backtracking
+        state.tokenStartCharIndex = -1;
+	}
+	return self;
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRBaseRecognizer" );
+#endif
+	if ( grammarFileName ) [grammarFileName release];
+	if ( tokenNames ) [tokenNames release];
+	if ( state ) [state release];
+	[super dealloc];
+}
+
+// reset the recognizer to the initial state. does not touch the token source!
+// this can be extended by the grammar writer to reset custom ivars
+- (void) reset
+{
+    if ( state == nil )
+        return;
+    if ( state.following != nil ) {
+        if ( [state.following count] )
+            [state.following removeAllObjects];
+    }
+    state._fsp = -1;
+    state.errorRecovery = NO;		// are we recovering?
+    state.lastErrorIndex = -1;
+    state.failed = NO;				// indicate that some match failed
+    state.syntaxErrors = 0;
+    state.backtracking = 0;			// the level of backtracking
+    state.tokenStartCharIndex = -1;
+    if ( state.ruleMemo != nil ) {
+        if ( [state.ruleMemo count] )
+            [state.ruleMemo removeAllObjects];
+    }
+}
+
+- (BOOL) getFailed
+{
+	return [state getFailed];
+}
+
+- (void) setFailed:(BOOL)flag
+{
+	[state setFailed:flag];
+}
+
+- (ANTLRRecognizerSharedState *) getState
+{
+	return state;
+}
+
+- (void) setState:(ANTLRRecognizerSharedState *) theState
+{
+	if (state != theState) {
+		if ( state ) [state release];
+		state = theState;
+		[state retain];
+	}
+}
+
+- (id)input
+{
+    return nil; // Must be overriden in inheriting class
+}
+
+- (void)skip // override in inheriting class
+{
+    return;
+}
+
+-(id) match:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)ttype Follow:(ANTLRBitSet *)follow
+{
+	id matchedSymbol = [self getCurrentInputSymbol:anInput];
+	if ([anInput LA:1] == ttype) {
+		[anInput consume];
+		state.errorRecovery = NO;
+		state.failed = NO;
+		return matchedSymbol;
+	}
+	if (state.backtracking > 0) {
+		state.failed = YES;
+		return matchedSymbol;
+	}
+	matchedSymbol = [self recoverFromMismatchedToken:anInput TokenType:ttype Follow:follow];
+	return matchedSymbol;
+}
+
+-(void) matchAny:(id<ANTLRIntStream>)anInput
+{
+    state.errorRecovery = NO;
+    state.failed = NO;
+    [anInput consume];
+}
+
+-(BOOL) mismatchIsUnwantedToken:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)ttype
+{
+    return [anInput LA:2] == ttype;
+}
+
+-(BOOL) mismatchIsMissingToken:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *) follow
+{
+    if ( follow == nil ) {
+        // we have no information about the follow; we can only consume
+        // a single token and hope for the best
+        return NO;
+    }
+    // compute what can follow this grammar element reference
+    if ( [follow member:ANTLRTokenTypeEOR] ) {
+        ANTLRBitSet *viableTokensFollowingThisRule = [self computeContextSensitiveRuleFOLLOW];
+        follow = [follow or:viableTokensFollowingThisRule];
+        if ( state._fsp >= 0 ) { // remove EOR if we're not the start symbol
+            [follow remove:(ANTLRTokenTypeEOR)];
+        }
+    }
+    // if current token is consistent with what could come after set
+    // then we know we're missing a token; error recovery is free to
+    // "insert" the missing token
+
+    //System.out.println("viable tokens="+follow.toString(getTokenNames()));
+    //System.out.println("LT(1)="+((TokenStream)input).LT(1));
+
+    // BitSet cannot handle negative numbers like -1 (EOF) so I leave EOR
+    // in follow set to indicate that the fall of the start symbol is
+    // in the set (EOF can follow).
+    if ( [follow member:[anInput LA:1]] || [follow member:ANTLRTokenTypeEOR] ) {
+        //System.out.println("LT(1)=="+((TokenStream)input).LT(1)+" is consistent with what follows; inserting...");
+        return YES;
+    }
+    return NO;
+}
+
+/** Report a recognition problem.
+ *
+ *  This method sets errorRecovery to indicate the parser is recovering
+ *  not parsing.  Once in recovery mode, no errors are generated.
+ *  To get out of recovery mode, the parser must successfully match
+ *  a token (after a resync).  So it will go:
+ *
+ * 		1. error occurs
+ * 		2. enter recovery mode, report error
+ * 		3. consume until token found in resynch set
+ * 		4. try to resume parsing
+ * 		5. next match() will reset errorRecovery mode
+ *
+ *  If you override, make sure to update syntaxErrors if you care about that.
+ */
+-(void) reportError:(ANTLRRecognitionException *) e
+{
+    // if we've already reported an error and have not matched a token
+    // yet successfully, don't report any errors.
+    if ( state.errorRecovery ) {
+        //System.err.print("[SPURIOUS] ");
+        return;
+    }
+    state.syntaxErrors++; // don't count spurious
+    state.errorRecovery = YES;
+
+    [self displayRecognitionError:[self getTokenNames] Exception:e];
+}
+
+-(void) displayRecognitionError:(AMutableArray *)theTokNams Exception:(ANTLRRecognitionException *)e
+{
+    NSString *hdr = [self getErrorHeader:e];
+    NSString *msg = [self getErrorMessage:e TokenNames:theTokNams];
+    [self emitErrorMessage:[NSString stringWithFormat:@" %@ %@", hdr, msg]];
+}
+
+/** What error message should be generated for the various
+ *  exception types?
+ *
+ *  Not very object-oriented code, but I like having all error message
+ *  generation within one method rather than spread among all of the
+ *  exception classes. This also makes it much easier for the exception
+ *  handling because the exception classes do not have to have pointers back
+ *  to this object to access utility routines and so on. Also, changing
+ *  the message for an exception type would be difficult because you
+ *  would have to subclassing exception, but then somehow get ANTLR
+ *  to make those kinds of exception objects instead of the default.
+ *  This looks weird, but trust me--it makes the most sense in terms
+ *  of flexibility.
+ *
+ *  For grammar debugging, you will want to override this to add
+ *  more information such as the stack frame with
+ *  getRuleInvocationStack(e, this.getClass().getName()) and,
+ *  for no viable alts, the decision description and state etc...
+ *
+ *  Override this to change the message generated for one or more
+ *  exception types.
+ */
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)theTokNams
+{
+    // NSString *msg = [e getMessage];
+    NSString *msg;
+    if ( [e isKindOfClass:[ANTLRUnwantedTokenException class]] ) {
+        ANTLRUnwantedTokenException *ute = (ANTLRUnwantedTokenException *)e;
+        NSString *tokenName=@"<unknown>";
+        if ( ute.expecting == ANTLRTokenTypeEOF ) {
+            tokenName = @"EOF";
+        }
+        else {
+            tokenName = (NSString *)[theTokNams objectAtIndex:ute.expecting];
+        }
+        msg = [NSString stringWithFormat:@"extraneous input %@ expecting %@", [self getTokenErrorDisplay:[ute getUnexpectedToken]],
+               tokenName];
+    }
+    else if ( [e isKindOfClass:[ANTLRMissingTokenException class] ] ) {
+        ANTLRMissingTokenException *mte = (ANTLRMissingTokenException *)e;
+        NSString *tokenName=@"<unknown>";
+        if ( mte.expecting== ANTLRTokenTypeEOF ) {
+            tokenName = @"EOF";
+        }
+        else {
+            tokenName = [theTokNams objectAtIndex:mte.expecting];
+        }
+        msg = [NSString stringWithFormat:@"missing %@ at %@", tokenName, [self getTokenErrorDisplay:(e.token)] ];
+    }
+    else if ( [e isKindOfClass:[ANTLRMismatchedTokenException class]] ) {
+        ANTLRMismatchedTokenException *mte = (ANTLRMismatchedTokenException *)e;
+        NSString *tokenName=@"<unknown>";
+        if ( mte.expecting== ANTLRTokenTypeEOF ) {
+            tokenName = @"EOF";
+        }
+        else {
+            tokenName = [theTokNams objectAtIndex:mte.expecting];
+        }
+        msg = [NSString stringWithFormat:@"mismatched input %@ expecting %@",[self getTokenErrorDisplay:(e.token)], tokenName];
+    }
+    else if ( [e isKindOfClass:[ANTLRMismatchedTreeNodeException class]] ) {
+        ANTLRMismatchedTreeNodeException *mtne = (ANTLRMismatchedTreeNodeException *)e;
+        NSString *tokenName=@"<unknown>";
+        if ( mtne.expecting==ANTLRTokenTypeEOF ) {
+            tokenName = @"EOF";
+        }
+        else {
+            tokenName = [theTokNams objectAtIndex:mtne.expecting];
+        }
+        msg = [NSString stringWithFormat:@"mismatched tree node: %@ expecting %@", mtne.node, tokenName];
+    }
+    else if ( [e isKindOfClass:[ANTLRNoViableAltException class]] ) {
+        //NoViableAltException *nvae = (NoViableAltException *)e;
+        // for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
+        // and "(decision="+nvae.decisionNumber+") and
+        // "state "+nvae.stateNumber
+        msg = [NSString stringWithFormat:@"no viable alternative at input %@", [self getTokenErrorDisplay:e.token]];
+    }
+    else if ( [e isKindOfClass:[ANTLREarlyExitException class]] ) {
+        //ANTLREarlyExitException *eee = (ANTLREarlyExitException *)e;
+        // for development, can add "(decision="+eee.decisionNumber+")"
+        msg =[NSString stringWithFormat: @"required (...)+ loop did not match anything at input ", [self getTokenErrorDisplay:e.token]];
+    }
+    else if ( [e isKindOfClass:[ANTLRMismatchedSetException class]] ) {
+        ANTLRMismatchedSetException *mse = (ANTLRMismatchedSetException *)e;
+        msg = [NSString stringWithFormat:@"mismatched input %@ expecting set %@",
+               [self getTokenErrorDisplay:(e.token)],
+               mse.expecting];
+    }
+#pragma warning NotSet not yet implemented.
+    else if ( [e isKindOfClass:[ANTLRMismatchedNotSetException class] ] ) {
+        ANTLRMismatchedNotSetException *mse = (ANTLRMismatchedNotSetException *)e;
+        msg = [NSString stringWithFormat:@"mismatched input %@ expecting set %@",
+               [self getTokenErrorDisplay:(e.token)],
+               mse.expecting];
+    }
+    else if ( [e isKindOfClass:[ANTLRFailedPredicateException class]] ) {
+        ANTLRFailedPredicateException *fpe = (ANTLRFailedPredicateException *)e;
+        msg = [NSString stringWithFormat:@"rule %@ failed predicate: { %@ }?", fpe.ruleName, fpe.predicate];
+    }
+    else {
+        msg = [NSString stringWithFormat:@"Exception= %@\n", e.name];
+    }
+    return msg;
+}
+
+/** Get number of recognition errors (lexer, parser, tree parser).  Each
+ *  recognizer tracks its own number.  So parser and lexer each have
+ *  separate count.  Does not count the spurious errors found between
+ *  an error and next valid token match
+ *
+ *  See also reportError()
+ */
+- (NSInteger) getNumberOfSyntaxErrors
+{
+    return state.syntaxErrors;
+}
+
+/** What is the error header, normally line/character position information? */
+- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e
+{
+    return [NSString stringWithFormat:@"line %d:%d", e.line, e.charPositionInLine];
+}
+
+/** How should a token be displayed in an error message? The default
+ *  is to display just the text, but during development you might
+ *  want to have a lot of information spit out.  Override in that case
+ *  to use t.toString() (which, for CommonToken, dumps everything about
+ *  the token). This is better than forcing you to override a method in
+ *  your token objects because you don't have to go modify your lexer
+ *  so that it creates a new Java type.
+ */
+- (NSString *)getTokenErrorDisplay:(id<ANTLRToken>)t
+{
+    NSString *s = t.text;
+    if ( s == nil ) {
+        if ( t.type == ANTLRTokenTypeEOF ) {
+            s = @"<EOF>";
+        }
+        else {
+            s = [NSString stringWithFormat:@"<%@>", t.type];
+        }
+    }
+    s = [s stringByReplacingOccurrencesOfString:@"\n" withString:@"\\\\n"];
+    s = [s stringByReplacingOccurrencesOfString:@"\r" withString:@"\\\\r"];
+    s = [s stringByReplacingOccurrencesOfString:@"\t" withString:@"\\\\t"];
+    return [NSString stringWithFormat:@"\'%@\'", s];
+}
+
+/** Override this method to change where error messages go */
+- (void) emitErrorMessage:(NSString *) msg
+{
+//    System.err.println(msg);
+    NSLog(@"%@", msg);
+}
+
+/** Recover from an error found on the input stream.  This is
+ *  for NoViableAlt and mismatched symbol exceptions.  If you enable
+ *  single token insertion and deletion, this will usually not
+ *  handle mismatched symbol exceptions but there could be a mismatched
+ *  token that the match() routine could not recover from.
+ */
+- (void)recover:(id<ANTLRIntStream>)anInput Exception:(ANTLRRecognitionException *)re
+{
+    if ( state.lastErrorIndex == anInput.index ) {
+        // uh oh, another error at same token index; must be a case
+        // where LT(1) is in the recovery token set so nothing is
+        // consumed; consume a single token so at least to prevent
+        // an infinite loop; this is a failsafe.
+        [anInput consume];
+    }
+    state.lastErrorIndex = anInput.index;
+    ANTLRBitSet *followSet = [self computeErrorRecoverySet];
+    [self beginResync];
+    [self consumeUntilFollow:anInput Follow:followSet];
+    [self endResync];
+}
+
+- (void) beginResync
+{
+
+}
+
+- (void) endResync
+{
+
+}
+
+/*  Compute the error recovery set for the current rule.  During
+ *  rule invocation, the parser pushes the set of tokens that can
+ *  follow that rule reference on the stack; this amounts to
+ *  computing FIRST of what follows the rule reference in the
+ *  enclosing rule. This local follow set only includes tokens
+ *  from within the rule; i.e., the FIRST computation done by
+ *  ANTLR stops at the end of a rule.
+ *
+ *  EXAMPLE
+ *
+ *  When you find a "no viable alt exception", the input is not
+ *  consistent with any of the alternatives for rule r.  The best
+ *  thing to do is to consume tokens until you see something that
+ *  can legally follow a call to r *or* any rule that called r.
+ *  You don't want the exact set of viable next tokens because the
+ *  input might just be missing a token--you might consume the
+ *  rest of the input looking for one of the missing tokens.
+ *
+ *  Consider grammar:
+ *
+ *  a : '[' b ']'
+ *    | '(' b ')'
+ *    ;
+ *  b : c '^' INT ;
+ *  c : ID
+ *    | INT
+ *    ;
+ *
+ *  At each rule invocation, the set of tokens that could follow
+ *  that rule is pushed on a stack.  Here are the various "local"
+ *  follow sets:
+ *
+ *  FOLLOW(b1_in_a) = FIRST(']') = ']'
+ *  FOLLOW(b2_in_a) = FIRST(')') = ')'
+ *  FOLLOW(c_in_b) = FIRST('^') = '^'
+ *
+ *  Upon erroneous input "[]", the call chain is
+ *
+ *  a -> b -> c
+ *
+ *  and, hence, the follow context stack is:
+ *
+ *  depth  local follow set     after call to rule
+ *    0         <EOF>                    a (from main())
+ *    1          ']'                     b
+ *    3          '^'                     c
+ *
+ *  Notice that ')' is not included, because b would have to have
+ *  been called from a different context in rule a for ')' to be
+ *  included.
+ *
+ *  For error recovery, we cannot consider FOLLOW(c)
+ *  (context-sensitive or otherwise).  We need the combined set of
+ *  all context-sensitive FOLLOW sets--the set of all tokens that
+ *  could follow any reference in the call chain.  We need to
+ *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if
+ *  we resync'd to that token, we'd consume until EOF.  We need to
+ *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.
+ *  In this case, for input "[]", LA(1) is in this set so we would
+ *  not consume anything and after printing an error rule c would
+ *  return normally.  It would not find the required '^' though.
+ *  At this point, it gets a mismatched token error and throws an
+ *  exception (since LA(1) is not in the viable following token
+ *  set).  The rule exception handler tries to recover, but finds
+ *  the same recovery set and doesn't consume anything.  Rule b
+ *  exits normally returning to rule a.  Now it finds the ']' (and
+ *  with the successful match exits errorRecovery mode).
+ *
+ *  So, you cna see that the parser walks up call chain looking
+ *  for the token that was a member of the recovery set.
+ *
+ *  Errors are not generated in errorRecovery mode.
+ *
+ *  ANTLR's error recovery mechanism is based upon original ideas:
+ *
+ *  "Algorithms + Data Structures = Programs" by Niklaus Wirth
+ *
+ *  and
+ *
+ *  "A note on error recovery in recursive descent parsers":
+ *  http://portal.acm.org/citation.cfm?id=947902.947905
+ *
+ *  Later, Josef Grosch had some good ideas:
+ *
+ *  "Efficient and Comfortable Error Recovery in Recursive Descent
+ *  Parsers":
+ *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip
+ *
+ *  Like Grosch I implemented local FOLLOW sets that are combined
+ *  at run-time upon error to avoid overhead during parsing.
+ */
+- (ANTLRBitSet *) computeErrorRecoverySet
+{
+    return [self combineFollows:NO];
+}
+
+/** Compute the context-sensitive FOLLOW set for current rule.
+ *  This is set of token types that can follow a specific rule
+ *  reference given a specific call chain.  You get the set of
+ *  viable tokens that can possibly come next (lookahead depth 1)
+ *  given the current call chain.  Contrast this with the
+ *  definition of plain FOLLOW for rule r:
+ *
+ *   FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
+ *
+ *  where x in T* and alpha, beta in V*; T is set of terminals and
+ *  V is the set of terminals and nonterminals.  In other words,
+ *  FOLLOW(r) is the set of all tokens that can possibly follow
+ *  references to r in *any* sentential form (context).  At
+ *  runtime, however, we know precisely which context applies as
+ *  we have the call chain.  We may compute the exact (rather
+ *  than covering superset) set of following tokens.
+ *
+ *  For example, consider grammar:
+ *
+ *  stat : ID '=' expr ';'      // FOLLOW(stat)=={EOF}
+ *       | "return" expr '.'
+ *       ;
+ *  expr : atom ('+' atom)* ;   // FOLLOW(expr)=={';','.',')'}
+ *  atom : INT                  // FOLLOW(atom)=={'+',')',';','.'}
+ *       | '(' expr ')'
+ *       ;
+ *
+ *  The FOLLOW sets are all inclusive whereas context-sensitive
+ *  FOLLOW sets are precisely what could follow a rule reference.
+ *  For input input "i=(3);", here is the derivation:
+ *
+ *  stat => ID '=' expr ';'
+ *       => ID '=' atom ('+' atom)* ';'
+ *       => ID '=' '(' expr ')' ('+' atom)* ';'
+ *       => ID '=' '(' atom ')' ('+' atom)* ';'
+ *       => ID '=' '(' INT ')' ('+' atom)* ';'
+ *       => ID '=' '(' INT ')' ';'
+ *
+ *  At the "3" token, you'd have a call chain of
+ *
+ *    stat -> expr -> atom -> expr -> atom
+ *
+ *  What can follow that specific nested ref to atom?  Exactly ')'
+ *  as you can see by looking at the derivation of this specific
+ *  input.  Contrast this with the FOLLOW(atom)={'+',')',';','.'}.
+ *
+ *  You want the exact viable token set when recovering from a
+ *  token mismatch.  Upon token mismatch, if LA(1) is member of
+ *  the viable next token set, then you know there is most likely
+ *  a missing token in the input stream.  "Insert" one by just not
+ *  throwing an exception.
+ */
+- (ANTLRBitSet *)computeContextSensitiveRuleFOLLOW
+{
+    return [self combineFollows:YES];
+}
+
+// what is exact? it seems to only add sets from above on stack
+// if EOR is in set i.  When it sees a set w/o EOR, it stops adding.
+// Why would we ever want them all?  Maybe no viable alt instead of
+// mismatched token?
+- (ANTLRBitSet *)combineFollows:(BOOL) exact
+{
+    NSInteger top = state._fsp;
+    ANTLRBitSet *followSet = [[ANTLRBitSet newANTLRBitSet] retain];
+    for (int i = top; i >= 0; i--) {
+        ANTLRBitSet *localFollowSet = (ANTLRBitSet *)[state.following objectAtIndex:i];
+        /*
+         System.out.println("local follow depth "+i+"="+
+         localFollowSet.toString(getTokenNames())+")");
+         */
+        [followSet orInPlace:localFollowSet];
+        if ( exact ) {
+            // can we see end of rule?
+            if ( [localFollowSet member:ANTLRTokenTypeEOR] ) {
+                // Only leave EOR in set if at top (start rule); this lets
+                // us know if have to include follow(start rule); i.e., EOF
+                if ( i > 0 ) {
+                    [followSet remove:ANTLRTokenTypeEOR];
+                }
+            }
+            else { // can't see end of rule, quit
+                break;
+            }
+        }
+    }
+    return followSet;
+}
+
+/** Attempt to recover from a single missing or extra token.
+ *
+ *  EXTRA TOKEN
+ *
+ *  LA(1) is not what we are looking for.  If LA(2) has the right token,
+ *  however, then assume LA(1) is some extra spurious token.  Delete it
+ *  and LA(2) as if we were doing a normal match(), which advances the
+ *  input.
+ *
+ *  MISSING TOKEN
+ *
+ *  If current token is consistent with what could come after
+ *  ttype then it is ok to "insert" the missing token, else throw
+ *  exception For example, Input "i=(3;" is clearly missing the
+ *  ')'.  When the parser returns from the nested call to expr, it
+ *  will have call chain:
+ *
+ *    stat -> expr -> atom
+ *
+ *  and it will be trying to match the ')' at this point in the
+ *  derivation:
+ *
+ *       => ID '=' '(' INT ')' ('+' atom)* ';'
+ *                          ^
+ *  match() will see that ';' doesn't match ')' and report a
+ *  mismatched token error.  To recover, it sees that LA(1)==';'
+ *  is in the set of tokens that can follow the ')' token
+ *  reference in rule atom.  It can assume that you forgot the ')'.
+ */
+- (id<ANTLRToken>)recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput
+                       TokenType:(NSInteger)ttype
+                          Follow:(ANTLRBitSet *)follow
+{
+    ANTLRRecognitionException *e = nil;
+    // if next token is what we are looking for then "delete" this token
+    if ( [self mismatchIsUnwantedToken:anInput TokenType:ttype] ) {
+        e = [ANTLRUnwantedTokenException newException:ttype Stream:anInput];
+        /*
+         System.err.println("recoverFromMismatchedToken deleting "+
+         ((TokenStream)input).LT(1)+
+         " since "+((TokenStream)input).LT(2)+" is what we want");
+         */
+        [self beginResync];
+        [anInput consume]; // simply delete extra token
+        [self endResync];
+        [self reportError:e];  // report after consuming so AW sees the token in the exception
+                         // we want to return the token we're actually matching
+        id matchedSymbol = [self getCurrentInputSymbol:anInput];
+        [anInput consume]; // move past ttype token as if all were ok
+        return matchedSymbol;
+    }
+    // can't recover with single token deletion, try insertion
+    if ( [self mismatchIsMissingToken:anInput Follow:follow] ) {
+        id<ANTLRToken> inserted = [self getMissingSymbol:anInput Exception:e TokenType:ttype Follow:follow];
+        e = [ANTLRMissingTokenException newException:ttype Stream:anInput With:inserted];
+        [self reportError:e];  // report after inserting so AW sees the token in the exception
+        return inserted;
+    }
+    // even that didn't work; must throw the exception
+    e = [ANTLRMismatchedTokenException newException:ttype Stream:anInput];
+    @throw e;
+}
+
+/** Not currently used */
+-(id) recoverFromMismatchedSet:(id<ANTLRIntStream>)anInput
+                     Exception:(ANTLRRecognitionException *)e
+                        Follow:(ANTLRBitSet *) follow
+{
+    if ( [self mismatchIsMissingToken:anInput Follow:follow] ) {
+        // System.out.println("missing token");
+        [self reportError:e];
+        // we don't know how to conjure up a token for sets yet
+        return [self getMissingSymbol:anInput Exception:e TokenType:ANTLRTokenTypeInvalid Follow:follow];
+    }
+    // TODO do single token deletion like above for Token mismatch
+    @throw e;
+}
+
+/** Match needs to return the current input symbol, which gets put
+ *  into the label for the associated token ref; e.g., x=ID.  Token
+ *  and tree parsers need to return different objects. Rather than test
+ *  for input stream type or change the IntStream interface, I use
+ *  a simple method to ask the recognizer to tell me what the current
+ *  input symbol is.
+ *
+ *  This is ignored for lexers.
+ */
+- (id) getCurrentInputSymbol:(id<ANTLRIntStream>)anInput
+{
+    return nil;
+}
+
+/** Conjure up a missing token during error recovery.
+ *
+ *  The recognizer attempts to recover from single missing
+ *  symbols. But, actions might refer to that missing symbol.
+ *  For example, x=ID {f($x);}. The action clearly assumes
+ *  that there has been an identifier matched previously and that
+ *  $x points at that token. If that token is missing, but
+ *  the next token in the stream is what we want we assume that
+ *  this token is missing and we keep going. Because we
+ *  have to return some token to replace the missing token,
+ *  we have to conjure one up. This method gives the user control
+ *  over the tokens returned for missing tokens. Mostly,
+ *  you will want to create something special for identifier
+ *  tokens. For literals such as '{' and ',', the default
+ *  action in the parser or tree parser works. It simply creates
+ *  a CommonToken of the appropriate type. The text will be the token.
+ *  If you change what tokens must be created by the lexer,
+ *  override this method to create the appropriate tokens.
+ */
+- (id)getMissingSymbol:(id<ANTLRIntStream>)anInput
+             Exception:(ANTLRRecognitionException *)e
+             TokenType:(NSInteger)expectedTokenType
+                Follow:(ANTLRBitSet *)follow
+{
+    return nil;
+}
+
+
+-(void) consumeUntilTType:(id<ANTLRIntStream>)anInput TokenType:(NSInteger)tokenType
+{
+    //System.out.println("consumeUntil "+tokenType);
+    int ttype = [anInput LA:1];
+    while (ttype != ANTLRTokenTypeEOF && ttype != tokenType) {
+        [anInput consume];
+        ttype = [anInput LA:1];
+    }
+}
+
+/** Consume tokens until one matches the given token set */
+-(void) consumeUntilFollow:(id<ANTLRIntStream>)anInput Follow:(ANTLRBitSet *)set
+{
+    //System.out.println("consumeUntil("+set.toString(getTokenNames())+")");
+    int ttype = [anInput LA:1];
+    while (ttype != ANTLRTokenTypeEOF && ![set member:ttype] ) {
+        //System.out.println("consume during recover LA(1)="+getTokenNames()[input.LA(1)]);
+        [anInput consume];
+        ttype = [anInput LA:1];
+    }
+}
+
+/** Push a rule's follow set using our own hardcoded stack */
+- (void)pushFollow:(ANTLRBitSet *)fset
+{
+    if ( (state._fsp +1) >= [state.following count] ) {
+        //        AMutableArray *f = [AMutableArray arrayWithCapacity:[[state.following] count]*2];
+        //        System.arraycopy(state.following, 0, f, 0, state.following.length);
+        //        state.following = f;
+        [state.following addObject:fset];
+        [fset retain];
+        state._fsp++;
+    }
+    else {
+        [state.following replaceObjectAtIndex:++state._fsp withObject:fset];
+    }
+}
+
+- (ANTLRBitSet *)popFollow
+{
+    ANTLRBitSet *fset;
+
+    if ( state._fsp >= 0 && [state.following count] > 0 ) {
+        fset = [state.following objectAtIndex:state._fsp--];
+        [state.following removeLastObject];
+        return fset;
+    }
+    else {
+        NSLog( @"Attempted to pop a follow when none exists on the stack\n" );
+    }
+    return nil;
+}
+
+/** Return List<String> of the rules in your parser instance
+ *  leading up to a call to this method.  You could override if
+ *  you want more details such as the file/line info of where
+ *  in the parser java code a rule is invoked.
+ *
+ *  This is very useful for error messages and for context-sensitive
+ *  error recovery.
+ */
+- (AMutableArray *)getRuleInvocationStack
+{
+    NSString *parserClassName = [[self className] retain];
+    return [self getRuleInvocationStack:[ANTLRRecognitionException newException] Recognizer:parserClassName];
+}
+
+/** A more general version of getRuleInvocationStack where you can
+ *  pass in, for example, a RecognitionException to get it's rule
+ *  stack trace.  This routine is shared with all recognizers, hence,
+ *  static.
+ *
+ *  TODO: move to a utility class or something; weird having lexer call this
+ */
+- (AMutableArray *)getRuleInvocationStack:(ANTLRRecognitionException *)e
+                                Recognizer:(NSString *)recognizerClassName
+{
+    // char *name;
+    AMutableArray *rules = [[AMutableArray arrayWithCapacity:20] retain];
+    NSArray *stack = [e callStackSymbols];
+    int i = 0;
+    for (i = [stack count]-1; i >= 0; i--) {
+        NSString *t = [stack objectAtIndex:i];
+        // NSLog(@"stack %d = %@\n", i, t);
+        if ( [t commonPrefixWithString:@"org.antlr.runtime." options:NSLiteralSearch] ) {
+            // id aClass = objc_getClass( [t UTF8String] );
+            continue; // skip support code such as this method
+        }
+        if ( [t isEqualTo:NEXT_TOKEN_RULE_NAME] ) {
+            // name = sel_getName(method_getName(method));
+            // NSString *aMethod = [NSString stringWithFormat:@"%s", name];
+            continue;
+        }
+        if ( ![t isEqualTo:recognizerClassName] ) {
+            // name = class_getName( [t UTF8String] );
+            continue; // must not be part of this parser
+        }
+        [rules addObject:t];
+    }
+#ifdef DONTUSEYET
+    StackTraceElement[] stack = e.getStackTrace();
+    int i = 0;
+    for (i=stack.length-1; i>=0; i--) {
+        StackTraceElement t = stack[i];
+        if ( [t getClassName().startsWith("org.antlr.runtime.") ) {
+            continue; // skip support code such as this method
+        }
+              if ( [[t getMethodName] equals:NEXT_TOKEN_RULE_NAME] ) {
+            continue;
+        }
+              if ( ![[t getClassName] equals:recognizerClassName] ) {
+            continue; // must not be part of this parser
+        }
+              [rules addObject:[t getMethodName]];
+    }
+#endif
+    [stack release];
+    return rules;
+}
+
+- (NSInteger) getBacktrackingLevel
+{
+    return [state getBacktracking];
+}
+
+- (void) setBacktrackingLevel:(NSInteger)level
+{
+    [state setBacktracking:level];
+}
+
+        /** Used to print out token names like ID during debugging and
+ *  error reporting.  The generated parsers implement a method
+ *  that overrides this to point to their String[] tokenNames.
+ */
+- (NSArray *)getTokenNames
+{
+    return tokenNames;
+}
+
+/** For debugging and other purposes, might want the grammar name.
+ *  Have ANTLR generate an implementation for this method.
+ */
+- (NSString *)getGrammarFileName
+{
+    return grammarFileName;
+}
+
+- (NSString *)getSourceName
+{
+    return nil;
+}
+
+/** A convenience method for use most often with template rewrites.
+ *  Convert a List<Token> to List<String>
+ */
+- (AMutableArray *)toStrings:(AMutableArray *)tokens
+{
+    if ( tokens == nil )
+        return nil;
+    AMutableArray *strings = [AMutableArray arrayWithCapacity:[tokens count]];
+    id object;
+    NSInteger i = 0;
+    for (object in tokens) {
+        [strings addObject:[object text]];
+        i++;
+    }
+    return strings;
+}
+
+/** Given a rule number and a start token index number, return
+ *  ANTLR_MEMO_RULE_UNKNOWN if the rule has not parsed input starting from
+ *  start index.  If this rule has parsed input starting from the
+ *  start index before, then return where the rule stopped parsing.
+ *  It returns the index of the last token matched by the rule.
+ *
+ *  For now we use a hashtable and just the slow Object-based one.
+ *  Later, we can make a special one for ints and also one that
+ *  tosses out data after we commit past input position i.
+ */
+- (NSInteger)getRuleMemoization:(NSInteger)ruleIndex StartIndex:(NSInteger)ruleStartIndex
+{
+    NSNumber *stopIndexI;
+    ANTLRHashRule *aHashRule;
+    if ( (aHashRule = [state.ruleMemo objectAtIndex:ruleIndex]) == nil ) {
+        aHashRule = [ANTLRHashRule newANTLRHashRuleWithLen:17];
+        [state.ruleMemo insertObject:aHashRule atIndex:ruleIndex];
+    }
+    stopIndexI = [aHashRule getRuleMemoStopIndex:ruleStartIndex];
+    if ( stopIndexI == nil ) {
+        return ANTLR_MEMO_RULE_UNKNOWN;
+    }
+    return [stopIndexI integerValue];
+}
+
+/** Has this rule already parsed input at the current index in the
+ *  input stream?  Return the stop token index or MEMO_RULE_UNKNOWN.
+ *  If we attempted but failed to parse properly before, return
+ *  MEMO_RULE_FAILED.
+ *
+ *  This method has a side-effect: if we have seen this input for
+ *  this rule and successfully parsed before, then seek ahead to
+ *  1 past the stop token matched for this rule last time.
+ */
+- (BOOL)alreadyParsedRule:(id<ANTLRIntStream>)anInput RuleIndex:(NSInteger)ruleIndex
+{
+    NSInteger aStopIndex = [self getRuleMemoization:ruleIndex StartIndex:anInput.index];
+    if ( aStopIndex == ANTLR_MEMO_RULE_UNKNOWN ) {
+        // NSLog(@"rule %d not yet encountered\n", ruleIndex);
+        return NO;
+    }
+    if ( aStopIndex == ANTLR_MEMO_RULE_FAILED ) {
+        if (debug) NSLog(@"rule %d will never succeed\n", ruleIndex);
+        state.failed = YES;
+    }
+    else {
+        if (debug) NSLog(@"seen rule %d before; skipping ahead to %d failed = %@\n", ruleIndex, aStopIndex+1, state.failed?@"YES":@"NO");
+        [anInput seek:(aStopIndex+1)]; // jump to one past stop token
+    }
+    return YES;
+}
+
+/** Record whether or not this rule parsed the input at this position
+ *  successfully.  Use a standard java hashtable for now.
+ */
+- (void)memoize:(id<ANTLRIntStream>)anInput
+      RuleIndex:(NSInteger)ruleIndex
+     StartIndex:(NSInteger)ruleStartIndex
+{
+    ANTLRRuleStack *aRuleStack;
+    NSInteger stopTokenIndex;
+
+    aRuleStack = state.ruleMemo;
+    stopTokenIndex = (state.failed ? ANTLR_MEMO_RULE_FAILED : (anInput.index-1));
+    if ( aRuleStack == nil ) {
+        if (debug) NSLog(@"!!!!!!!!! memo array is nil for %@", [self getGrammarFileName]);
+        return;
+    }
+    if ( ruleIndex >= [aRuleStack length] ) {
+        if (debug) NSLog(@"!!!!!!!!! memo size is %d, but rule index is %d", [state.ruleMemo length], ruleIndex);
+        return;
+    }
+    if ( [aRuleStack objectAtIndex:ruleIndex] != nil ) {
+        [aRuleStack putHashRuleAtRuleIndex:ruleIndex StartIndex:ruleStartIndex StopIndex:stopTokenIndex];
+    }
+    return;
+}
+
+/** return how many rule/input-index pairs there are in total.
+ *  TODO: this includes synpreds. :(
+ */
+- (NSInteger)getRuleMemoizationCacheSize
+{
+    ANTLRRuleStack *aRuleStack;
+    ANTLRHashRule *aHashRule;
+
+    int aCnt = 0;
+    aRuleStack = state.ruleMemo;
+    for (NSUInteger i = 0; aRuleStack != nil && i < [aRuleStack length]; i++) {
+        aHashRule = [aRuleStack objectAtIndex:i];
+        if ( aHashRule != nil ) {
+            aCnt += [aHashRule count]; // how many input indexes are recorded?
+        }
+    }
+    return aCnt;
+}
+
+#pragma warning Have to fix traceIn and traceOut.
+- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol
+{
+    NSLog(@"enter %@ %@", ruleName, inputSymbol);
+    if ( state.backtracking > 0 ) {
+        NSLog(@" backtracking=%s", ((state.backtracking==YES)?"YES":"NO"));
+    }
+    NSLog(@"\n");
+}
+
+- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex Object:(id)inputSymbol
+{
+    NSLog(@"exit %@ -- %@", ruleName, inputSymbol);
+    if ( state.backtracking > 0 ) {
+        NSLog(@" backtracking=%s %s", state.backtracking?"YES":"NO", state.failed ? "failed":"succeeded");
+    }
+    NSLog(@"\n");
+}
+
+
+// call a syntactic predicate methods using its selector. this way we can support arbitrary synpreds.
+- (BOOL) evaluateSyntacticPredicate:(SEL)synpredFragment // stream:(id<ANTLRIntStream>)input
+{
+    id<ANTLRIntStream> input;
+
+    state.backtracking++;
+    // input = state.token.input;
+    input = self.input;
+    int start = [input mark];
+    @try {
+        [self performSelector:synpredFragment];
+    }
+    @catch (ANTLRRecognitionException *re) {
+        NSLog(@"impossible synpred: %@", re.name);
+    }
+    BOOL success = (state.failed == NO);
+    [input rewind:start];
+    state.backtracking--;
+    state.failed = NO;
+    return success;
+}
+
+@end
+
diff --git a/runtime/ObjC/Framework/BaseStack.h b/runtime/ObjC/Framework/BaseStack.h
new file mode 100644
index 0000000..2356178
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseStack.h
@@ -0,0 +1,66 @@
+//
+//  ANTLRBaseRecognizer.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRPtrBuffer.h"
+
+//#define GLOBAL_SCOPE       0
+//#define LOCAL_SCOPE        1
+#define HASHSIZE         101
+#define HBUFSIZE      0x2000
+
+@interface ANTLRBaseStack : ANTLRPtrBuffer {
+	//ANTLRRuleStack *fNext;
+    // TStringPool *fPool;
+    NSInteger LastHash;
+}
+
+//@property (copy) ANTLRRuleStack *fNext;
+@property (getter=getLastHash, setter=setLastHash:) NSInteger LastHash;
+
+// Contruction/Destruction
++ (ANTLRBaseStack *)newANTLRBaseStack;
++ (ANTLRBaseStack *)newANTLRBaseStackWithLen:(NSInteger)cnt;
+- (id)init;
+- (id)initWithLen:(NSInteger)cnt;
+- (void)dealloc;
+
+// Instance Methods
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (NSUInteger)count;
+- (NSUInteger)size;
+/* clear -- reinitialize the maplist array */
+
+- (NSInteger)getLastHash;
+- (void)setLastHash:(NSInteger)aVal;
+
+@end
diff --git a/runtime/ObjC/Framework/BaseStack.m b/runtime/ObjC/Framework/BaseStack.m
new file mode 100644
index 0000000..7bd2282
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseStack.m
@@ -0,0 +1,131 @@
+//
+//  ANTLRBaseRecognizer.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#define SUCCESS (0)
+#define FAILURE (-1)
+
+#import "ANTLRBaseStack.h"
+#import "ANTLRTree.h"
+
+/*
+ * Start of ANTLRBaseStack
+ */
+@implementation ANTLRBaseStack
+
+@synthesize LastHash;
+
++(ANTLRBaseStack *)newANTLRBaseStack
+{
+    return [[ANTLRBaseStack alloc] init];
+}
+
++(ANTLRBaseStack *)newANTLRBaseStackWithLen:(NSInteger)cnt
+{
+    return [[ANTLRBaseStack alloc] initWithLen:cnt];
+}
+
+-(id)init
+{
+	self = [super initWithLen:HASHSIZE];
+	if ( self != nil ) {
+	}
+    return( self );
+}
+
+-(id)initWithLen:(NSInteger)cnt
+{
+	self = [super initWithLen:cnt];
+    if ( self != nil ) {
+	}
+    return( self );
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRBaseStack" );
+#endif
+	[super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRBaseStack *copy;
+
+    copy = [super copyWithZone:aZone];
+    return copy;
+}
+
+- (NSUInteger)count
+{
+    NSUInteger aCnt = 0;
+
+    for (int i = 0; i < BuffSize; i++) {
+        if (ptrBuffer[i] != nil) {
+            aCnt++;
+        }
+    }
+    return aCnt;
+}
+
+- (NSUInteger) size
+{
+    return BuffSize;
+}
+
+-(void)deleteANTLRBaseStack:(ANTLRBaseStack *)np
+{
+    id tmp, rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            tmp = (ANTLRLinkBase *)ptrBuffer[idx];
+            while ( tmp ) {
+                rtmp = tmp;
+                tmp = [tmp getfNext];
+                [rtmp release];
+            }
+        }
+    }
+}
+
+- (NSInteger)getLastHash
+{
+    return LastHash;
+}
+
+- (void)setLastHash:(NSInteger)aVal
+{
+    LastHash = aVal;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/BaseTree.h b/runtime/ObjC/Framework/BaseTree.h
new file mode 100755
index 0000000..1139cd0
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseTree.h
@@ -0,0 +1,210 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTree.h"
+#import "ANTLRCommonToken.h"
+#import "AMutableArray.h"
+
+@protocol ANTLRBaseTree <ANTLRTree>
+
++ (id<ANTLRBaseTree>) INVALID_NODE;
+
++ (id<ANTLRBaseTree>) newTree;
++ (id<ANTLRBaseTree>) newTree:(id<ANTLRBaseTree>)node;
+
+- (id<ANTLRBaseTree>) init;
+- (id<ANTLRBaseTree>) initWith:(id<ANTLRBaseTree>)node;
+
+- (id<ANTLRBaseTree>) getChild:(NSUInteger)i;
+- (AMutableArray *)children;
+- (void) setChildren:(AMutableArray *)anArray;
+- (id<ANTLRBaseTree>)getFirstChildWithType:(NSInteger)type;
+- (NSUInteger) getChildCount;
+
+// Add t as a child to this node.  If t is null, do nothing.  If t
+//  is nil, add all children of t to this' children.
+
+- (void) addChild:(id<ANTLRBaseTree>) tree;
+- (void) addChildren:(NSArray *) theChildren;
+//- (void) removeAllChildren;
+
+- (void) setChild:(NSInteger) i With:(id<ANTLRBaseTree>)t;
+- (id) deleteChild:(NSInteger) i;
+- (AMutableArray *) createChildrenList;
+- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
+// Indicates the node is a nil node but may still have children, meaning
+// the tree is a flat list.
+
+- (BOOL) isNil;
+- (NSInteger) getTokenStartIndex;
+- (void) setTokenStartIndex:(NSInteger) index;
+- (NSInteger) getTokenStopIndex;
+- (void) setTokenStopIndex:(NSInteger) index;
+
+- (void) freshenParentAndChildIndexes;
+- (void) freshenParentAndChildIndexes:(NSInteger) offset;
+- (void) sanityCheckParentAndChildIndexes;
+- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>) parent At:(NSInteger) i;
+
+- (NSInteger) getChildIndex;
+- (void) setChildIndex:(NSInteger)i;
+
+- (id<ANTLRBaseTree>)getAncestor:(NSInteger)ttype;
+- (AMutableArray *)getAncestors;
+
+#pragma mark Copying
+- (id) copyWithZone:(NSZone *)aZone;	// the children themselves are not copied here!
+- (id) deepCopy;					// performs a deepCopyWithZone: with the default zone
+- (id) deepCopyWithZone:(NSZone *)aZone;
+
+#pragma mark Tree Parser support
+- (NSInteger)type;
+- (NSString *)text;
+// In case we don't have a token payload, what is the line for errors?
+- (NSUInteger)line;
+- (NSUInteger)charPositionInLine;
+
+
+#pragma mark Informational
+- (NSString *) treeDescription;
+- (NSString *) description;
+
+- (NSString *) toString;
+- (NSString *) toStringTree;
+
+@property (retain) AMutableArray *children;
+@property (retain) NSException *anException;
+
+@end
+
+@interface ANTLRBaseTree : NSObject <ANTLRTree>
+{
+	__strong AMutableArray *children;
+    __strong NSException *anException;
+}
+
++ (id<ANTLRBaseTree>) INVALID_NODE;
++ (id<ANTLRBaseTree>) newTree;
++ (id<ANTLRBaseTree>) newTree:(id<ANTLRBaseTree>)node;
+
+- (id<ANTLRBaseTree>) init;
+- (id<ANTLRBaseTree>) initWith:(id<ANTLRBaseTree>)node;
+
+- (id<ANTLRBaseTree>) getChild:(NSUInteger)i;
+- (AMutableArray *)children;
+- (void) setChildren:(AMutableArray *)anArray;
+- (id<ANTLRBaseTree>)getFirstChildWithType:(NSInteger)type;
+- (NSUInteger) getChildCount;
+
+//- (void) removeAllChildren;
+
+// Add t as a child to this node.  If t is null, do nothing.  If t
+//  is nil, add all children of t to this' children.
+
+- (void) addChild:(id<ANTLRBaseTree>) tree;
+- (void) addChildren:(NSArray *) theChildren;
+
+- (void) setChild:(NSUInteger) i With:(id<ANTLRBaseTree>)t;
+- (id) deleteChild:(NSUInteger) idx;
+- (AMutableArray *) createChildrenList;
+- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
+// Indicates the node is a nil node but may still have children, meaning
+	// the tree is a flat list.
+
+- (BOOL) isNil;
+- (NSInteger) getTokenStartIndex;
+- (void) setTokenStartIndex:(NSInteger) index;
+- (NSInteger) getTokenStopIndex;
+- (void) setTokenStopIndex:(NSInteger) index;
+
+- (void) freshenParentAndChildIndexes;
+- (void) freshenParentAndChildIndexes:(NSInteger) offset;
+- (void) sanityCheckParentAndChildIndexes;
+- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>)parent At:(NSInteger) i;
+
+- (NSInteger) getChildIndex;
+- (void) setChildIndex:(NSInteger)i;
+
+- (BOOL) hasAncestor:(NSInteger) ttype;
+- (id<ANTLRBaseTree>)getAncestor:(NSInteger)ttype;
+- (AMutableArray *)getAncestors;
+
+- (id) copyWithZone:(NSZone *)aZone;
+- (id) deepCopy;					// performs a deepCopyWithZone: with the default zone
+- (id) deepCopyWithZone:(NSZone *)aZone;
+
+	// Return a token type; needed for tree parsing
+- (NSInteger)type;
+- (NSString *)text;
+
+	// In case we don't have a token payload, what is the line for errors?
+- (NSUInteger)line;
+- (NSUInteger)charPositionInLine;
+- (void) setCharPositionInLine:(NSUInteger)pos;
+
+- (NSString *) treeDescription;
+- (NSString *) description;
+- (NSString *) toString;
+- (NSString *) toStringTree;
+
+@property (retain) AMutableArray *children;
+@property (retain) NSException *anException;
+
+@end
+
+@interface ANTLRTreeNavigationNode : ANTLRBaseTree {
+}
+- (id) init;
+- (id) copyWithZone:(NSZone *)aZone;
+@end
+
+@interface ANTLRTreeNavigationNodeDown : ANTLRTreeNavigationNode {
+}
++ (ANTLRTreeNavigationNodeDown *) getNavigationNodeDown;
+- (id) init;
+- (NSInteger) tokenType;
+- (NSString *) description;
+@end
+
+@interface ANTLRTreeNavigationNodeUp : ANTLRTreeNavigationNode {
+}
++ (ANTLRTreeNavigationNodeUp *) getNavigationNodeUp;
+- (id) init;
+- (NSInteger) tokenType;
+- (NSString *) description;
+@end
+
+@interface ANTLRTreeNavigationNodeEOF : ANTLRTreeNavigationNode {
+}
++ (ANTLRTreeNavigationNodeEOF *) getNavigationNodeEOF;
+- (id) init;
+- (NSInteger) tokenType;
+- (NSString *) description;
+@end
+
+extern ANTLRTreeNavigationNodeDown *navigationNodeDown;
+extern ANTLRTreeNavigationNodeUp *navigationNodeUp;
+extern ANTLRTreeNavigationNodeEOF *navigationNodeEOF;
diff --git a/runtime/ObjC/Framework/BaseTree.m b/runtime/ObjC/Framework/BaseTree.m
new file mode 100755
index 0000000..5ba4eac
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseTree.m
@@ -0,0 +1,616 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRBaseTree.h"
+#import "ANTLRBaseTreeAdaptor.h"
+#import "ANTLRToken.h"
+// TODO: this shouldn't be here...but needed for invalidNode
+#import "AMutableArray.h"
+#import "ANTLRCommonTree.h"
+#import "ANTLRRuntimeException.h"
+#import "ANTLRError.h"
+
+#pragma mark - Navigation Nodes
+ANTLRTreeNavigationNodeDown *navigationNodeDown = nil;
+ANTLRTreeNavigationNodeUp *navigationNodeUp = nil;
+ANTLRTreeNavigationNodeEOF *navigationNodeEOF = nil;
+
+
+@implementation ANTLRBaseTree
+
+static id<ANTLRBaseTree> invalidNode = nil;
+
+#pragma mark ANTLRTree protocol conformance
+
++ (id<ANTLRBaseTree>) INVALID_NODE
+{
+	if ( invalidNode == nil ) {
+		invalidNode = [[ANTLRCommonTree alloc] initWithTokenType:ANTLRTokenTypeInvalid];
+	}
+	return invalidNode;
+}
+
++ (id<ANTLRBaseTree>) invalidNode
+{
+	if ( invalidNode == nil ) {
+		invalidNode = [[ANTLRCommonTree alloc] initWithTokenType:ANTLRTokenTypeInvalid];
+	}
+	return invalidNode;
+}
+
++ newTree
+{
+    return [[ANTLRBaseTree alloc] init];
+}
+
+/** Create a new node from an existing node does nothing for ANTLRBaseTree
+ *  as there are no fields other than the children list, which cannot
+ *  be copied as the children are not considered part of this node.
+ */
++ newTree:(id<ANTLRBaseTree>) node
+{
+    return [[ANTLRBaseTree alloc] initWith:(id<ANTLRBaseTree>) node];
+}
+
+- (id) init
+{
+    self = [super init];
+    if ( self != nil ) {
+        children = nil;
+        return self;
+    }
+    return nil;
+}
+
+- (id) initWith:(id<ANTLRBaseTree>)node
+{
+    self = [super init];
+    if ( self != nil ) {
+        // children = [[AMutableArray arrayWithCapacity:5] retain];
+        // [children addObject:node];
+        [self addChild:node];
+        return self;
+    }
+    return nil;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRBaseTree" );
+#endif
+	if ( children ) [children release];
+	[super dealloc];
+}
+
+- (id<ANTLRBaseTree>) getChild:(NSUInteger)i
+{
+    if ( children == nil || i >= [children count] ) {
+        return nil;
+    }
+    return (id<ANTLRBaseTree>)[children objectAtIndex:i];
+}
+
+/** Get the children internal List; note that if you directly mess with
+ *  the list, do so at your own risk.
+ */
+- (AMutableArray *) children
+{
+    return children;
+}
+
+- (void) setChildren:(AMutableArray *)anArray
+{
+    if ( children != anArray ) {
+        if ( children ) [children release];
+        if ( anArray ) [anArray retain];
+    }
+    children = anArray;
+}
+
+- (id<ANTLRBaseTree>) getFirstChildWithType:(NSInteger) aType
+{
+    for (NSUInteger i = 0; children != nil && i < [children count]; i++) {
+        id<ANTLRBaseTree> t = (id<ANTLRBaseTree>) [children objectAtIndex:i];
+        if ( t.type == aType ) {
+            return t;
+        }
+    }
+    return nil;
+}
+
+- (NSUInteger) getChildCount
+{
+    if ( children == nil ) {
+        return 0;
+    }
+    return [children count];
+}
+
+/** Add t as child of this node.
+ *
+ *  Warning: if t has no children, but child does
+ *  and child isNil then this routine moves children to t via
+ *  t.children = child.children; i.e., without copying the array.
+ */
+- (void) addChild:(id<ANTLRBaseTree>) t
+{
+    //System.out.println("add child "+t.toStringTree()+" "+self.toStringTree());
+    //System.out.println("existing children: "+children);
+    if ( t == nil ) {
+        return; // do nothing upon addChild(nil)
+    }
+    if ( self == (ANTLRBaseTree *)t )
+        @throw [ANTLRIllegalArgumentException newException:@"ANTLRBaseTree Can't add self to self as child"];
+    id<ANTLRBaseTree> childTree = (id<ANTLRBaseTree>) t;
+    if ( [childTree isNil] ) { // t is an empty node possibly with children
+        if ( children != nil && children == childTree.children ) {
+            @throw [ANTLRRuntimeException newException:@"ANTLRBaseTree add child list to itself"];
+        }
+        // just add all of childTree's children to this
+        if ( childTree.children != nil ) {
+            if ( children != nil ) { // must copy, this has children already
+                int n = [childTree.children count];
+                for ( int i = 0; i < n; i++) {
+                    id<ANTLRBaseTree> c = (id<ANTLRBaseTree>)[childTree.children objectAtIndex:i];
+                    [children addObject:c];
+                    // handle double-link stuff for each child of nil root
+                    [c setParent:(id<ANTLRBaseTree>)self];
+                    [c setChildIndex:[children count]-1];
+                }
+            }
+            else {
+                // no children for this but t has children; just set pointer
+                // call general freshener routine
+                children = childTree.children;
+                [self freshenParentAndChildIndexes];
+            }
+        }
+    }
+    else { // child is not nil (don't care about children)
+        if ( children == nil ) {
+            children = [[AMutableArray arrayWithCapacity:5] retain]; // create children list on demand
+        }
+        [children addObject:t];
+        [childTree setParent:(id<ANTLRBaseTree>)self];
+        [childTree setChildIndex:[children count]-1];
+    }
+    // System.out.println("now children are: "+children);
+}
+
+/** Add all elements of kids list as children of this node */
+- (void) addChildren:(AMutableArray *) kids
+{
+    for (NSUInteger i = 0; i < [kids count]; i++) {
+        id<ANTLRBaseTree> t = (id<ANTLRBaseTree>) [kids objectAtIndex:i];
+        [self addChild:t];
+    }
+}
+
+- (void) setChild:(NSUInteger) i With:(id<ANTLRBaseTree>)t
+{
+    if ( t == nil ) {
+        return;
+    }
+    if ( [t isNil] ) {
+        @throw [ANTLRIllegalArgumentException newException:@"ANTLRBaseTree Can't set single child to a list"];
+    }
+    if ( children == nil ) {
+        children = [[AMutableArray arrayWithCapacity:5] retain];
+    }
+    if ([children count] > i ) {
+        [children replaceObjectAtIndex:i withObject:t];
+    }
+    else {
+        [children insertObject:t atIndex:i];
+    }
+    [t setParent:(id<ANTLRBaseTree>)self];
+    [t setChildIndex:i];
+}
+
+- (id) deleteChild:(NSUInteger) idx
+{
+    if ( children == nil ) {
+        return nil;
+    }
+    id<ANTLRBaseTree> killed = (id<ANTLRBaseTree>)[children objectAtIndex:idx];
+    [children removeObjectAtIndex:idx];
+    // walk rest and decrement their child indexes
+    [self freshenParentAndChildIndexes:idx];
+    return killed;
+}
+
+/** Delete children from start to stop and replace with t even if t is
+ *  a list (nil-root ANTLRTree).  num of children can increase or decrease.
+ *  For huge child lists, inserting children can force walking rest of
+ *  children to set their childindex; could be slow.
+ */
+- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t
+{
+    /*
+     System.out.println("replaceChildren "+startChildIndex+", "+stopChildIndex+
+     " with "+((ANTLRBaseTree)t).toStringTree());
+     System.out.println("in="+toStringTree());
+     */
+    if ( children == nil ) {
+        @throw [ANTLRIllegalArgumentException newException:@"ANTLRBaseTree Invalid Indexes; no children in list"];
+    }
+    int replacingHowMany = stopChildIndex - startChildIndex + 1;
+    int replacingWithHowMany;
+    id<ANTLRBaseTree> newTree = (id<ANTLRBaseTree>) t;
+    AMutableArray *newChildren = nil;
+    // normalize to a list of children to add: newChildren
+    if ( [newTree isNil] ) {
+        newChildren = newTree.children;
+    }
+    else {
+        newChildren = [AMutableArray arrayWithCapacity:5];
+        [newChildren addObject:newTree];
+    }
+    replacingWithHowMany = [newChildren count];
+    int numNewChildren = [newChildren count];
+    int delta = replacingHowMany - replacingWithHowMany;
+    // if same number of nodes, do direct replace
+    if ( delta == 0 ) {
+        int j = 0; // index into new children
+        for (int i=startChildIndex; i <= stopChildIndex; i++) {
+            id<ANTLRBaseTree> child = (id<ANTLRBaseTree>)[newChildren objectAtIndex:j];
+            [children replaceObjectAtIndex:i withObject:(id)child];
+            [child setParent:(id<ANTLRBaseTree>)self];
+            [child setChildIndex:i];
+            j++;
+        }
+    }
+    else if ( delta > 0 ) { // fewer new nodes than there were
+                            // set children and then delete extra
+        for (int j = 0; j < numNewChildren; j++) {
+            [children replaceObjectAtIndex:startChildIndex+j withObject:[newChildren objectAtIndex:j]];
+        }
+        int indexToDelete = startChildIndex+numNewChildren;
+        for (int c=indexToDelete; c<=stopChildIndex; c++) {
+            // delete same index, shifting everybody down each time
+            [children removeObjectAtIndex:indexToDelete];
+        }
+        [self freshenParentAndChildIndexes:startChildIndex];
+    }
+    else { // more new nodes than were there before
+           // fill in as many children as we can (replacingHowMany) w/o moving data
+        for (int j=0; j<replacingHowMany; j++) {
+            [children replaceObjectAtIndex:startChildIndex+j withObject:[newChildren objectAtIndex:j]];
+        }
+        //        int numToInsert = replacingWithHowMany-replacingHowMany;
+        for (int j=replacingHowMany; j<replacingWithHowMany; j++) {
+            [children insertObject:[newChildren objectAtIndex:j] atIndex:startChildIndex+j];
+        }
+        [self freshenParentAndChildIndexes:startChildIndex];
+    }
+    //System.out.println("out="+toStringTree());
+}
+
+/** Override in a subclass to change the impl of children list */
+- (AMutableArray *) createChildrenList
+{
+    return [AMutableArray arrayWithCapacity:5];
+}
+
+- (BOOL) isNil
+{
+    return NO;
+}
+
+/** Set the parent and child index values for all child of t */
+- (void) freshenParentAndChildIndexes
+{
+    [self freshenParentAndChildIndexes:0];
+}
+
+- (void) freshenParentAndChildIndexes:(NSInteger) offset
+{
+    int n = [self getChildCount];
+    for (int i = offset; i < n; i++) {
+        id<ANTLRBaseTree> child = (id<ANTLRBaseTree>)[self getChild:i];
+        [child setChildIndex:i];
+        [child setParent:(id<ANTLRBaseTree>)self];
+    }
+}
+
+- (void) sanityCheckParentAndChildIndexes
+{
+    [self sanityCheckParentAndChildIndexes:nil At:-1];
+}
+
+- (void) sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>)aParent At:(NSInteger) i
+{
+    if ( aParent != [self getParent] ) {
+        @throw [ANTLRIllegalStateException newException:[NSString stringWithFormat:@"parents don't match; expected %s found %s", aParent, [self getParent]]];
+    }
+    if ( i != [self getChildIndex] ) {
+        @throw [ANTLRIllegalStateException newException:[NSString stringWithFormat:@"child indexes don't match; expected %d found %d", i, [self getChildIndex]]];
+    }
+    int n = [self getChildCount];
+    for (int c = 0; c < n; c++) {
+        id<ANTLRBaseTree> child = (id<ANTLRBaseTree>)[self getChild:c];
+        [child sanityCheckParentAndChildIndexes:(id<ANTLRBaseTree>)self At:c];
+    }
+}
+
+/**  What is the smallest token index (indexing from 0) for this node
+ *   and its children?
+ */
+- (NSInteger) getTokenStartIndex
+{
+    return 0;
+}
+
+- (void) setTokenStartIndex:(NSInteger) anIndex
+{
+}
+
+/**  What is the largest token index (indexing from 0) for this node
+ *   and its children?
+ */
+- (NSInteger) getTokenStopIndex
+{
+    return 0;
+}
+
+- (void) setTokenStopIndex:(NSInteger) anIndex
+{
+}
+
+- (id<ANTLRBaseTree>) dupNode
+{
+    return nil;
+}
+
+
+/** ANTLRBaseTree doesn't track child indexes. */
+- (NSInteger) getChildIndex
+{
+    return 0;
+}
+
+- (void) setChildIndex:(NSInteger) anIndex
+{
+}
+
+/** ANTLRBaseTree doesn't track parent pointers. */
+- (id<ANTLRBaseTree>) getParent
+{
+    return nil;
+}
+
+- (void) setParent:(id<ANTLRBaseTree>) t
+{
+}
+
+/** Walk upwards looking for ancestor with this token type. */
+- (BOOL) hasAncestor:(NSInteger) ttype
+{
+    return([self getAncestor:ttype] != nil);
+}
+
+/** Walk upwards and get first ancestor with this token type. */
+- (id<ANTLRBaseTree>) getAncestor:(NSInteger) ttype
+{
+    id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)self;
+    t = (id<ANTLRBaseTree>)[t getParent];
+    while ( t != nil ) {
+        if ( t.type == ttype )
+            return t;
+        t = (id<ANTLRBaseTree>)[t getParent];
+    }
+    return nil;
+}
+
+/** Return a list of all ancestors of this node.  The first node of
+ *  list is the root and the last is the parent of this node.
+ */
+- (AMutableArray *)getAncestors
+{
+    if ( [self getParent] == nil )
+        return nil;
+    AMutableArray *ancestors = [AMutableArray arrayWithCapacity:5];
+    id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)self;
+    t = (id<ANTLRBaseTree>)[t getParent];
+    while ( t != nil ) {
+        [ancestors insertObject:t atIndex:0]; // insert at start
+        t = (id<ANTLRBaseTree>)[t getParent];
+    }
+    return ancestors;
+}
+
+- (NSInteger)type
+{
+    return ANTLRTokenTypeInvalid;
+}
+
+- (NSString *)text
+{
+    return nil;
+}
+
+- (NSUInteger)line
+{
+    return 0;
+}
+
+- (NSUInteger)charPositionInLine
+{
+    return 0;
+}
+
+- (void) setCharPositionInLine:(NSUInteger) pos
+{
+}
+
+#pragma mark Copying
+
+     // the children themselves are not copied here!
+- (id) copyWithZone:(NSZone *)aZone
+{
+    id<ANTLRBaseTree> theCopy = [[[self class] allocWithZone:aZone] init];
+    [theCopy addChildren:self.children];
+    return theCopy;
+}
+
+- (id) deepCopy 					// performs a deepCopyWithZone: with the default zone
+{
+    return [self deepCopyWithZone:NULL];
+}
+
+- (id) deepCopyWithZone:(NSZone *)aZone
+{
+    id<ANTLRBaseTree> theCopy = [self copyWithZone:aZone];
+
+    if ( [theCopy.children count] )
+        [theCopy.children removeAllObjects];
+    AMutableArray *childrenCopy = theCopy.children;
+    for (id loopItem in children) {
+        id<ANTLRBaseTree> childCopy = [loopItem deepCopyWithZone:aZone];
+        [theCopy addChild:childCopy];
+    }
+    if ( childrenCopy ) [childrenCopy release];
+    return theCopy;
+}
+
+- (NSString *) treeDescription
+{
+    if ( children == nil || [children count] == 0 ) {
+        return [self description];
+    }
+    NSMutableString *buf = [NSMutableString stringWithCapacity:[children count]];
+    if ( ![self isNil] ) {
+        [buf appendString:@"("];
+        [buf appendString:[self toString]];
+        [buf appendString:@" "];
+    }
+    for (int i = 0; children != nil && i < [children count]; i++) {
+        id<ANTLRBaseTree> t = (id<ANTLRBaseTree>)[children objectAtIndex:i];
+        if ( i > 0 ) {
+            [buf appendString:@" "];
+        }
+        [buf appendString:[(id<ANTLRBaseTree>)t toStringTree]];
+    }
+    if ( ![self isNil] ) {
+        [buf appendString:@")"];
+    }
+    return buf;
+}
+
+/** Print out a whole tree not just a node */
+- (NSString *) toStringTree
+{
+    return [self treeDescription];
+}
+
+- (NSString *) description
+{
+    return nil;
+}
+
+/** Override to say how a node (not a tree) should look as text */
+- (NSString *) toString
+{
+    return nil;
+}
+
+@synthesize children;
+@synthesize anException;
+
+@end
+
+#pragma mark -
+
+@implementation ANTLRTreeNavigationNode
+- (id)init
+{
+    self = (ANTLRTreeNavigationNode *)[super init];
+    return self;
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+	return nil;
+}
+@end
+
+@implementation ANTLRTreeNavigationNodeDown
++ (ANTLRTreeNavigationNodeDown *) getNavigationNodeDown
+{
+    if ( navigationNodeDown == nil )
+        navigationNodeDown = [[ANTLRTreeNavigationNodeDown alloc] init];
+    return navigationNodeDown;
+}
+
+- (id)init
+{
+    self = [super init];
+    return self;
+}
+
+- (NSInteger) tokenType { return ANTLRTokenTypeDOWN; }
+- (NSString *) description { return @"DOWN"; }
+@end
+
+@implementation ANTLRTreeNavigationNodeUp
++ (ANTLRTreeNavigationNodeUp *) getNavigationNodeUp
+{
+    if ( navigationNodeUp == nil )
+        navigationNodeUp = [[ANTLRTreeNavigationNodeUp alloc] init];
+    return navigationNodeUp;
+}
+
+
+- (id)init
+{
+    self = [super init];
+    return self;
+}
+
+- (NSInteger) tokenType { return ANTLRTokenTypeUP; }
+- (NSString *) description { return @"UP"; }
+@end
+
+@implementation ANTLRTreeNavigationNodeEOF
++ (ANTLRTreeNavigationNodeEOF *) getNavigationNodeEOF
+{
+    if ( navigationNodeEOF == nil )
+        navigationNodeEOF = [[ANTLRTreeNavigationNodeEOF alloc] init];
+    return navigationNodeEOF;
+}
+
+- (id)init
+{
+    self = [super init];
+    return self;
+}
+
+- (NSInteger) tokenType { return ANTLRTokenTypeEOF; }
+- (NSString *) description { return @"EOF"; }
+
+@end
+
diff --git a/runtime/ObjC/Framework/BaseTreeAdaptor.h b/runtime/ObjC/Framework/BaseTreeAdaptor.h
new file mode 100644
index 0000000..f8ed0d2
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseTreeAdaptor.h
@@ -0,0 +1,182 @@
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTreeAdaptor.h"
+#import "ANTLRCommonErrorNode.h"
+#import "ANTLRUniqueIDMap.h"
+
+@interface ANTLRBaseTreeAdaptor : NSObject <ANTLRTreeAdaptor, NSCopying> {
+    ANTLRUniqueIDMap *treeToUniqueIDMap;
+	NSInteger uniqueNodeID;
+}
+
+- (id) init;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (id) emptyNode;
+
+- (id) createNil;
+
+/** create tree node that holds the start and stop tokens associated
+ *  with an error.
+ *
+ *  If you specify your own kind of tree nodes, you will likely have to
+ *  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
+ *  if no token payload but you might have to set token type for diff
+ *  node type.
+ *
+ *  You don't have to subclass CommonErrorNode; you will likely need to
+ *  subclass your own tree node class to avoid class cast exception.
+ */
+- (id) errorNode:(id<ANTLRTokenStream>)anInput
+            From:(id<ANTLRToken>)startToken
+              To:(id<ANTLRToken>)stopToken
+       Exception:(NSException *) e;
+
+- (BOOL) isNil:(id<ANTLRBaseTree>) aTree;
+
+- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)aTree;
+
+/** This is generic in the sense that it will work with any kind of
+ *  tree (not just Tree interface).  It invokes the adaptor routines
+ *  not the tree node routines to do the construction.
+ */
+- (id<ANTLRBaseTree>)dupTree:(id<ANTLRBaseTree>)aTree Parent:(id<ANTLRBaseTree>)parent;
+- (id<ANTLRBaseTree>)dupNode:(id<ANTLRBaseTree>)aNode;
+/** Add a child to the tree t.  If child is a flat tree (a list), make all
+ *  in list children of t.  Warning: if t has no children, but child does
+ *  and child isNil then you can decide it is ok to move children to t via
+ *  t.children = child.children; i.e., without copying the array.  Just
+ *  make sure that this is consistent with have the user will build
+ *  ASTs.
+ */
+- (void) addChild:(id<ANTLRBaseTree>)aChild toTree:(id<ANTLRBaseTree>)aTree;
+
+/** If oldRoot is a nil root, just copy or move the children to newRoot.
+ *  If not a nil root, make oldRoot a child of newRoot.
+ *
+ *    old=^(nil a b c), new=r yields ^(r a b c)
+ *    old=^(a b c), new=r yields ^(r ^(a b c))
+ *
+ *  If newRoot is a nil-rooted single child tree, use the single
+ *  child as the new root node.
+ *
+ *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
+ *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
+ *
+ *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
+ *
+ *    old=null, new=r yields r
+ *    old=null, new=^(nil r) yields ^(nil r)
+ *
+ *  Return newRoot.  Throw an exception if newRoot is not a
+ *  simple node or nil root with a single child node--it must be a root
+ *  node.  If newRoot is ^(nil x) return x as newRoot.
+ *
+ *  Be advised that it's ok for newRoot to point at oldRoot's
+ *  children; i.e., you don't have to copy the list.  We are
+ *  constructing these nodes so we should have this control for
+ *  efficiency.
+ */
+- (id<ANTLRBaseTree>)becomeRoot:(id<ANTLRBaseTree>)aNewRoot old:(id<ANTLRBaseTree>)oldRoot;
+
+/** Transform ^(nil x) to x and nil to null */
+- (id<ANTLRBaseTree>)rulePostProcessing:(id<ANTLRBaseTree>)aRoot;
+
+- (id<ANTLRBaseTree>)becomeRootfromToken:(id<ANTLRToken>)aNewRoot old:(id<ANTLRBaseTree>)oldRoot;
+
+- (id<ANTLRBaseTree>) create:(id<ANTLRToken>)payload;
+- (id<ANTLRBaseTree>) createTree:(NSInteger)aTType FromToken:(id<ANTLRToken>)aFromToken;
+- (id<ANTLRBaseTree>) createTree:(NSInteger)aTType FromToken:(id<ANTLRToken>)aFromToken Text:(NSString *)theText;
+- (id<ANTLRBaseTree>) createTree:(NSInteger)aTType Text:(NSString *)theText;
+
+- (NSInteger) getType:(id<ANTLRBaseTree>)aTree;
+
+- (void) setType:(id<ANTLRBaseTree>)aTree Type:(NSInteger)type;
+
+- (id<ANTLRToken>)getToken:(ANTLRCommonTree *)t;
+
+- (NSString *)getText:(ANTLRCommonTree *)aTree;
+
+- (void) setText:(id<ANTLRBaseTree>)aTree Text:(NSString *)theText;
+
+- (id<ANTLRBaseTree>) getChild:(id<ANTLRBaseTree>)aTree At:(NSInteger)i;
+
+- (void) setChild:(id<ANTLRBaseTree>)aTree At:(NSInteger)index Child:(id<ANTLRBaseTree>)aChild;
+
+- (id<ANTLRBaseTree>) deleteChild:(id<ANTLRBaseTree>)aTree Index:(NSInteger)index;
+
+- (NSInteger) getChildCount:(id<ANTLRBaseTree>)aTree;
+
+- (id<ANTLRBaseTree>) getParent:(id<ANTLRBaseTree>) t;
+
+- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>) parent;
+
+/** What index is this node in the child list? Range: 0..n-1
+ *  If your node type doesn't handle this, it's ok but the tree rewrites
+ *  in tree parsers need this functionality.
+ */
+- (NSInteger) getChildIndex:(id)t;
+- (void) setChildIndex:(id)t With:(NSInteger)index;
+
+- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t;
+
+- (NSInteger) getUniqueID:(id<ANTLRBaseTree>)node;
+
+#ifdef DONTUSENOMO
+- (NSInteger) getUniqueID;
+
+- (void) setUniqueNodeID:(NSInteger)aUniqueNodeID;
+
+- (ANTLRUniqueIDMap *)getTreeToUniqueIDMap;
+
+- (void) setTreeToUniqueIDMap:(ANTLRUniqueIDMap *)aMapNode;
+#endif
+
+/** Tell me how to create a token for use with imaginary token nodes.
+ *  For example, there is probably no input symbol associated with imaginary
+ *  token DECL, but you need to create it as a payload or whatever for
+ *  the DECL node as in ^(DECL type ID).
+ *
+ *  This is a variant of createToken where the new token is derived from
+ *  an actual real input token.  Typically this is for converting '{'
+ *  tokens to BLOCK etc...  You'll see
+ *
+ *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
+ *
+ *  If you care what the token payload objects' type is, you should
+ *  override this method and any other createToken variant.
+ */
+- (id<ANTLRToken>)createToken:(NSInteger)aTType Text:(NSString *)theText;
+
+- (id<ANTLRToken>)createToken:(id<ANTLRToken>)aFromToken;
+
+@property (retain) ANTLRUniqueIDMap *treeToUniqueIDMap;
+@property (assign) NSInteger uniqueNodeID;
+
+@end
diff --git a/runtime/ObjC/Framework/BaseTreeAdaptor.m b/runtime/ObjC/Framework/BaseTreeAdaptor.m
new file mode 100644
index 0000000..58b181d
--- /dev/null
+++ b/runtime/ObjC/Framework/BaseTreeAdaptor.m
@@ -0,0 +1,429 @@
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRBaseTreeAdaptor.h"
+#import "ANTLRRuntimeException.h"
+#import "ANTLRUniqueIDMap.h"
+#import "ANTLRMapElement.h"
+#import "ANTLRCommonTree.h"
+
+@implementation ANTLRBaseTreeAdaptor
+
+@synthesize treeToUniqueIDMap;
+@synthesize uniqueNodeID;
+
++ (id<ANTLRTree>) newEmptyTree
+{
+    return [[ANTLRCommonTree alloc] init];
+}
+
+- (id) init
+{
+    self = [super init];
+    if ( self != nil ) {
+    }
+    return self;
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRBaseTreeAdaptor *copy;
+
+    copy = [[[self class] alloc] init];
+    if (treeToUniqueIDMap)
+        copy.treeToUniqueIDMap = [treeToUniqueIDMap copyWithZone:aZone];
+    copy.uniqueNodeID = uniqueNodeID;
+    return copy;
+}
+
+
+- (id) createNil
+{
+    return [ANTLRCommonTree newTreeWithToken:nil];
+}
+
+- (id) emptyNode
+{
+    return [ANTLRCommonTree newTreeWithToken:nil];
+}
+
+/** create tree node that holds the start and stop tokens associated
+ *  with an error.
+ *
+ *  If you specify your own kind of tree nodes, you will likely have to
+ *  override this method. CommonTree returns Token.INVALID_TOKEN_TYPE
+ *  if no token payload but you might have to set token type for diff
+ *  node type.
+ *
+ *  You don't have to subclass CommonErrorNode; you will likely need to
+ *  subclass your own tree node class to avoid class cast exception.
+ */
+- (id) errorNode:(id<ANTLRTokenStream>)anInput
+            From:(id<ANTLRToken>)startToken
+              To:(id<ANTLRToken>)stopToken
+       Exception:(ANTLRRecognitionException *) e;
+{
+    //System.out.println("returning error node '"+t+"' @index="+anInput.index());
+    return [ANTLRCommonErrorNode newANTLRCommonErrorNode:anInput
+                                                    From:startToken
+                                                      To:stopToken
+                                               Exception:e];
+}
+
+- (BOOL) isNil:(id) tree
+{
+    return [(id)tree isNil];
+}
+
+- (id)dupTree:(id)tree
+{
+    return [self dupTree:(id)tree Parent:nil];
+}
+
+/** This is generic in the sense that it will work with any kind of
+ *  tree (not just Tree interface).  It invokes the adaptor routines
+ *  not the tree node routines to do the construction.
+ */
+- (id)dupTree:(id)t Parent:(id)parent
+{
+    if ( t==nil ) {
+        return nil;
+    }
+    id newTree = [self dupNode:t];
+    // ensure new subtree root has parent/child index set
+    [self setChildIndex:newTree With:[self getChildIndex:t]]; // same index in new tree
+    [self setParent:newTree With:parent];
+    NSInteger n = [self getChildCount:t];
+    for (NSInteger i = 0; i < n; i++) {
+        id child = [self getChild:t At:i];
+        id newSubTree = [self dupTree:child Parent:t];
+        [self addChild:newSubTree toTree:newTree];
+    }
+    return newTree;
+}
+
+- (id)dupNode:(id)aNode
+{
+    return aNode; // override for better results :>)
+}
+/** Add a child to the tree t.  If child is a flat tree (a list), make all
+ *  in list children of t.  Warning: if t has no children, but child does
+ *  and child isNil then you can decide it is ok to move children to t via
+ *  t.children = child.children; i.e., without copying the array.  Just
+ *  make sure that this is consistent with have the user will build
+ *  ASTs.
+ */
+- (void) addChild:(id)child toTree:(id)t
+{
+    if ( t != nil && child != nil ) {
+        [(id)t addChild:child];
+    }
+}
+
+/** If oldRoot is a nil root, just copy or move the children to newRoot.
+ *  If not a nil root, make oldRoot a child of newRoot.
+ *
+ *    old=^(nil a b c), new=r yields ^(r a b c)
+ *    old=^(a b c), new=r yields ^(r ^(a b c))
+ *
+ *  If newRoot is a nil-rooted single child tree, use the single
+ *  child as the new root node.
+ *
+ *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
+ *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
+ *
+ *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
+ *
+ *    old=null, new=r yields r
+ *    old=null, new=^(nil r) yields ^(nil r)
+ *
+ *  Return newRoot.  Throw an exception if newRoot is not a
+ *  simple node or nil root with a single child node--it must be a root
+ *  node.  If newRoot is ^(nil x) return x as newRoot.
+ *
+ *  Be advised that it's ok for newRoot to point at oldRoot's
+ *  children; i.e., you don't have to copy the list.  We are
+ *  constructing these nodes so we should have this control for
+ *  efficiency.
+ */
+- (id)becomeRoot:(id)newRoot old:(id)oldRoot
+{
+    if ( oldRoot == nil ) {
+        return newRoot;
+    }
+    //System.out.println("becomeroot new "+newRoot.toString()+" old "+oldRoot);
+    id newRootTree = (id)newRoot;
+    id oldRootTree = (id)oldRoot;
+    // handle ^(nil real-node)
+    if ( [newRootTree isNil] ) {
+        NSInteger nc = [newRootTree getChildCount];
+        if ( nc == 1 ) newRootTree = [(id)newRootTree getChild:0];
+        else if ( nc > 1 ) {
+            // TODO: make tree run time exceptions hierarchy
+            @throw [ANTLRRuntimeException newException:NSStringFromClass([self class]) reason:@"more than one node as root (TODO: make exception hierarchy)"];
+        }
+    }
+    // add oldRoot to newRoot; addChild takes care of case where oldRoot
+    // is a flat list (i.e., nil-rooted tree).  All children of oldRoot
+    // are added to newRoot.
+    [newRootTree addChild:oldRootTree];
+    return newRootTree;
+}
+
+/** Transform ^(nil x) to x and nil to null */
+- (id)rulePostProcessing:(id)root
+{
+    //System.out.println("rulePostProcessing: "+((Tree)root).toStringTree());
+    id r = (id)root;
+    if ( r != nil && [r isNil] ) {
+        if ( [r getChildCount] == 0 ) {
+            r = nil;
+        }
+        else if ( [r getChildCount] == 1 ) {
+            r = (id)[r getChild:0];
+            // whoever invokes rule will set parent and child index
+            [r setParent:nil];
+            [r setChildIndex:-1];
+        }
+    }
+    return r;
+}
+
+- (id)becomeRootfromToken:(id<ANTLRToken>)newRoot old:(id)oldRoot
+{
+    return [self becomeRoot:(id)[self create:newRoot] old:oldRoot];
+}
+
+- (id) create:(id<ANTLRToken>)aToken
+{
+    return [ANTLRCommonTree newTreeWithToken:aToken];
+}
+
+- (id)createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken
+{
+    fromToken = [self createToken:fromToken];
+    //((ClassicToken)fromToken).setType(tokenType);
+    [fromToken setType:tokenType];
+    id t = [self create:fromToken];
+    return t;
+}
+
+- (id)createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text
+{
+    if (fromToken == nil)
+        return [self createTree:tokenType Text:text];
+    fromToken = [self createToken:fromToken];
+    [fromToken setType:tokenType];
+    [fromToken setText:text];
+    id t = [self create:fromToken];
+    return t;
+}
+
+- (id)createTree:(NSInteger)tokenType Text:(NSString *)text
+{
+    id<ANTLRToken> fromToken = [self createToken:tokenType Text:text];
+    id t = (id)[self create:fromToken];
+    return t;
+}
+
+- (NSInteger) getType:(ANTLRCommonTree *) t
+{
+    return [t type];
+}
+
+- (void) setType:(id)t Type:(NSInteger)type
+{
+    @throw [ANTLRNoSuchElementException newException:@"don't know enough about Tree node"];
+}
+
+/** What is the Token associated with this node?  If
+ *  you are not using ANTLRCommonTree, then you must
+ *  override this in your own adaptor.
+ */
+- (id<ANTLRToken>) getToken:(ANTLRCommonTree *) t
+{
+    if ( [t isKindOfClass:[ANTLRCommonTree class]] ) {
+        return [t getToken];
+    }
+    return nil; // no idea what to do
+}
+
+- (NSString *)getText:(ANTLRCommonTree *)t
+{
+    return [t text];
+}
+
+- (void) setText:(id)t Text:(NSString *)text
+{
+    @throw [ANTLRNoSuchElementException newException:@"don't know enough about Tree node"];
+}
+
+- (id) getChild:(id)t At:(NSInteger)index
+{
+    return [(id)t getChild:index ];
+}
+
+- (void) setChild:(id)t At:(NSInteger)index Child:(id)child
+{
+    [(id)t setChild:index With:(id)child];
+}
+
+- (id) deleteChild:(id)t Index:(NSInteger)index
+{
+    return [(id)t deleteChild:index];
+}
+
+- (NSInteger) getChildCount:(id)t
+{
+    return [(id)t getChildCount];
+}
+
+- (id<ANTLRBaseTree>) getParent:(id<ANTLRBaseTree>) t
+{
+    if ( t == nil )
+        return nil;
+    return (id<ANTLRBaseTree>)[t getParent];
+}
+
+- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>) parent
+{
+    if ( t != nil )
+        [(id<ANTLRBaseTree>) t setParent:(id<ANTLRBaseTree>)parent];
+}
+
+/** What index is this node in the child list? Range: 0..n-1
+ *  If your node type doesn't handle this, it's ok but the tree rewrites
+ *  in tree parsers need this functionality.
+ */
+- (NSInteger) getChildIndex:(id)t
+{
+    return ((ANTLRCommonTree *)t).childIndex;
+}
+
+- (void) setChildIndex:(id)t With:(NSInteger)index
+{
+    ((ANTLRCommonTree *)t).childIndex = index;
+}
+
+- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t
+{
+    return;
+}
+
+- (NSInteger) getUniqueID:(id)node
+{
+    if ( treeToUniqueIDMap == nil ) {
+        treeToUniqueIDMap = [ANTLRUniqueIDMap newANTLRUniqueIDMap];
+    }
+    NSNumber *prevID = [treeToUniqueIDMap getNode:node];
+    if ( prevID != nil ) {
+        return [prevID integerValue];
+    }
+    NSInteger anID = uniqueNodeID;
+    // ANTLRMapElement *aMapNode = [ANTLRMapElement newANTLRMapElementWithObj1:[NSNumber numberWithInteger:anID] Obj2:node];
+    [treeToUniqueIDMap putID:[NSNumber numberWithInteger:anID] Node:node];
+    uniqueNodeID++;
+    return anID;
+    // GCC makes these nonunique:
+    // return System.identityHashCode(node);
+}
+
+/** Tell me how to create a token for use with imaginary token nodes.
+ *  For example, there is probably no input symbol associated with imaginary
+ *  token DECL, but you need to create it as a payload or whatever for
+ *  the DECL node as in ^(DECL type ID).
+ *
+ *  If you care what the token payload objects' type is, you should
+ *  override this method and any other createToken variant.
+ */
+- (id<ANTLRToken>) createToken:(NSInteger)aTType Text:(NSString *)text
+{
+    return nil;
+}
+
+/** Tell me how to create a token for use with imaginary token nodes.
+ *  For example, there is probably no input symbol associated with imaginary
+ *  token DECL, but you need to create it as a payload or whatever for
+ *  the DECL node as in ^(DECL type ID).
+ *
+ *  This is a variant of createToken where the new token is derived from
+ *  an actual real input token.  Typically this is for converting '{'
+ *  tokens to BLOCK etc...  You'll see
+ *
+ *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
+ *
+ *  If you care what the token payload objects' type is, you should
+ *  override this method and any other createToken variant.
+ */
+- (id<ANTLRToken>) createToken:(id<ANTLRToken>) fromToken
+{
+    return nil;
+}
+
+/** Track start/stop token for subtree root created for a rule.
+ *  Only works with Tree nodes.  For rules that match nothing,
+ *  seems like this will yield start=i and stop=i-1 in a nil node.
+ *  Might be useful info so I'll not force to be i..i.
+ */
+- (void) setTokenBoundaries:(id)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken
+{
+    return;
+}
+
+- (NSInteger) getTokenStartIndex:(id)aTree
+{
+    return -1;
+}
+
+- (NSInteger) getTokenStopIndex:(id)aTree
+{
+    return -1;
+}
+
+#ifdef DONTUSENOMO
+- (NSInteger)getUniqueID
+{
+    return uniqueNodeID;
+}
+
+- (void) setUniqueNodeID:(NSInteger)aUniqueNodeID
+{
+    uniqueNodeID = aUniqueNodeID;
+}
+
+- (ANTLRUniqueIDMap *)getTreeToUniqueIDMap
+{
+    return treeToUniqueIDMap;
+}
+
+- (void) setTreeToUniqueIDMap:(ANTLRUniqueIDMap *)aMapListNode
+{
+    treeToUniqueIDMap = aMapListNode;
+}
+
+#endif
+
+@end
diff --git a/runtime/ObjC/Framework/BufferedTokenStream.h b/runtime/ObjC/Framework/BufferedTokenStream.h
new file mode 100644
index 0000000..28d1418
--- /dev/null
+++ b/runtime/ObjC/Framework/BufferedTokenStream.h
@@ -0,0 +1,102 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTokenStream.h"
+#import "ANTLRTokenSource.h"
+#import "ANTLRBitSet.h"
+#import "ANTLRCommonToken.h"
+#import "AMutableArray.h"
+
+@interface ANTLRBufferedTokenStream : NSObject <ANTLRTokenStream>
+{
+__strong id<ANTLRTokenSource> tokenSource;
+
+    /** Record every single token pulled from the source so we can reproduce
+     *  chunks of it later.  The buffer in LookaheadStream overlaps sometimes
+     *  as its moving window moves through the input.  This list captures
+     *  everything so we can access complete input text.
+     */
+__strong AMutableArray *tokens;
+
+    /** Track the last mark() call result value for use in rewind(). */
+NSInteger lastMarker;
+
+    /** The index into the tokens list of the current token (next token
+     *  to consume).  tokens[index] should be LT(1).  index=-1 indicates need
+     *  to initialize with first token.  The ctor doesn't get a token.
+     *  First call to LT(1) or whatever gets the first token and sets index=0;
+     */
+NSInteger index;
+
+NSInteger range; // how deep have we gone?
+
+}
+@property (retain, getter=getTokenSource,setter=setTokenSource:) id<ANTLRTokenSource> tokenSource;
+@property (retain, getter=getTokens,setter=setTokens:) AMutableArray *tokens;
+@property (assign, getter=getLastMarker,setter=setLastMarker:) NSInteger lastMarker;
+@property (assign) NSInteger index;
+@property (assign, getter=getRange,setter=setRange:) NSInteger range;
+
++ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStream;
++ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStreamWith:(id<ANTLRTokenSource>)aSource;
+- (id) initWithTokenSource:(id<ANTLRTokenSource>)aSource;
+- (void)dealloc;
+- (id) copyWithZone:(NSZone *)aZone;
+- (NSUInteger)charPositionInLine;
+- (NSUInteger)line;
+- (NSInteger) getRange;
+- (void) setRange:(NSInteger)anInt;
+- (NSInteger) mark;
+- (void) release:(NSInteger) marker;
+- (void) rewind:(NSInteger) marker;
+- (void) rewind;
+- (void) reset;
+- (void) seek:(NSInteger) anIndex;
+- (NSInteger) size;
+- (void) consume;
+- (void) sync:(NSInteger) i;
+- (void) fetch:(NSInteger) n;
+- (id<ANTLRToken>) getToken:(NSInteger) i;
+- (AMutableArray *)getFrom:(NSInteger)startIndex To:(NSInteger) stopIndex;
+- (NSInteger) LA:(NSInteger)i;
+- (id<ANTLRToken>) LB:(NSInteger) k;
+- (id<ANTLRToken>) LT:(NSInteger) k;
+- (void) setup;
+- (id<ANTLRTokenSource>) getTokenSource;
+- (void) setTokenSource:(id<ANTLRTokenSource>) aTokenSource;
+- (AMutableArray *)getTokens;
+- (NSString *) getSourceName;
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex;
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex With:(ANTLRBitSet *)types;
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithList:(AMutableArray *)types;
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithType:(NSInteger)ttype;
+- (NSString *) toString;
+- (NSString *) toStringFromStart:(NSInteger)startIndex ToEnd:(NSInteger)stopIndex;
+- (NSString *) toStringFromToken:(id<ANTLRToken>)startIndex ToToken:(id<ANTLRToken>)stopIndex;
+- (void) fill;
+
+@end
diff --git a/runtime/ObjC/Framework/BufferedTokenStream.m b/runtime/ObjC/Framework/BufferedTokenStream.m
new file mode 100644
index 0000000..94802b5
--- /dev/null
+++ b/runtime/ObjC/Framework/BufferedTokenStream.m
@@ -0,0 +1,392 @@
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRBufferedTokenStream.h"
+#import "ANTLRTokenSource.h"
+#import "ANTLRCommonTreeAdaptor.h"
+#import "ANTLRRuntimeException.h"
+
+extern NSInteger debug;
+
+@implementation ANTLRBufferedTokenStream
+
+@synthesize tokenSource;
+@synthesize tokens;
+@synthesize lastMarker;
+@synthesize index;
+@synthesize range;
+
++ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStream
+{
+    return [[ANTLRBufferedTokenStream alloc] init];
+}
+
++ (ANTLRBufferedTokenStream *) newANTLRBufferedTokenStreamWith:(id<ANTLRTokenSource>)aSource
+{
+    return [[ANTLRBufferedTokenStream alloc] initWithTokenSource:aSource];
+}
+
+- (ANTLRBufferedTokenStream *) init
+{
+	if ((self = [super init]) != nil)
+	{
+        tokenSource = nil;
+        tokens = [[AMutableArray arrayWithCapacity:1000] retain];
+        index = -1;
+        range = -1;
+	}
+	return self;
+}
+
+-(id) initWithTokenSource:(id<ANTLRTokenSource>)aSource
+{
+	if ((self = [super init]) != nil)
+	{
+        tokenSource = [aSource retain];
+        tokens = [[AMutableArray arrayWithCapacity:1000] retain];
+        index = -1;
+        range = -1;
+	}
+	return self;
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRBufferedTokenStream *copy;
+
+    copy = [[[self class] allocWithZone:aZone] init];
+    copy.tokenSource = self.tokenSource;
+    if ( self.tokens )
+        copy.tokens = [tokens copyWithZone:aZone];
+    copy.lastMarker = self.lastMarker;
+    copy.index = self.index;
+    copy.range = self.range;
+    return copy;
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRBufferedTokenStream" );
+#endif
+    if ( tokens ) [tokens release];
+    if ( tokenSource ) [tokenSource release];
+	[super dealloc];
+}
+
+- (NSUInteger)line
+{
+    return ((ANTLRCommonToken *)[tokens objectAtIndex:index]).line;
+}
+
+- (NSUInteger)charPositionInLine
+{
+    return ((ANTLRCommonToken *)[tokens objectAtIndex:index]).charPositionInLine;
+}
+
+- (id<ANTLRTokenSource>) getTokenSource
+{
+    return tokenSource;
+}
+
+- (NSInteger) getRange
+{
+    return range;
+}
+
+- (void) setRange:(NSInteger)anInt
+{
+    range = anInt;
+}
+
+- (NSInteger) mark
+{
+    if ( index == -1 ) {
+        [self setup];
+//        [self fill];
+    }
+    lastMarker = self.index;
+    return lastMarker;
+}
+
+- (void) release:(NSInteger) marker
+{
+    // no resources to release
+}
+
+- (void) rewind:(NSInteger) marker
+{
+    [self seek:marker];
+}
+
+- (void) rewind
+{
+    [self seek:lastMarker];
+}
+
+- (void) reset
+{
+    index = 0;
+    lastMarker = 0;
+}
+
+- (void) seek:(NSInteger) anIndex
+{
+    index = anIndex;
+}
+
+- (NSInteger) size
+{
+    return [tokens count];
+}
+
+/** Move the input pointer to the next incoming token.  The stream
+ *  must become active with LT(1) available.  consume() simply
+ *  moves the input pointer so that LT(1) points at the next
+ *  input symbol. Consume at least one token.
+ *
+ *  Walk past any token not on the channel the parser is listening to.
+ */
+- (void) consume
+{
+    if ( index == -1 ) {
+        [self setup];
+//        [self fill];
+    }
+    index++;
+    [self sync:index];
+}
+
+/** Make sure index i in tokens has a token. */
+- (void) sync:(NSInteger) i
+{
+    // how many more elements we need?
+    NSInteger n = (i - [tokens count]) + 1;
+    if (debug > 1) NSLog(@"[self sync:%d] needs %d\n", i, n);
+    if ( n > 0 )
+        [self fetch:n];
+}
+
+/** add n elements to buffer */
+- (void) fetch:(NSInteger)n
+{
+    for (NSInteger i=1; i <= n; i++) {
+        id<ANTLRToken> t = [tokenSource nextToken];
+        [t setTokenIndex:[tokens count]];
+        if (debug > 1) NSLog(@"adding %@ at index %d\n", [t text], [tokens count]);
+        [tokens addObject:t];
+        if ( t.type == ANTLRTokenTypeEOF )
+            break;
+    }
+}
+
+- (id<ANTLRToken>) getToken:(NSInteger) i
+{
+    if ( i < 0 || i >= [tokens count] ) {
+        @throw [ANTLRNoSuchElementException newException:[NSString stringWithFormat:@"token index %d out of range 0..%d", i, [tokens count]-1]];
+    }
+    return [tokens objectAtIndex:i];
+}
+
+/** Get all tokens from start..stop inclusively */
+- (AMutableArray *)getFrom:(NSInteger)startIndex To:(NSInteger)stopIndex
+{
+    if ( startIndex < 0 || stopIndex < 0 )
+        return nil;
+    if ( index == -1 ) {
+        [self setup];
+//        [self fill];
+    }
+    AMutableArray *subset = [AMutableArray arrayWithCapacity:5];
+    if ( stopIndex >= [tokens count] )
+        stopIndex = [tokens count]-1;
+    for (NSInteger i = startIndex; i <= stopIndex; i++) {
+        id<ANTLRToken>t = [tokens objectAtIndex:i];
+        if ( t.type == ANTLRTokenTypeEOF )
+            break;
+        [subset addObject:t];
+    }
+    return subset;
+}
+
+- (NSInteger) LA:(NSInteger)i
+{
+    return [[self LT:i] type];
+}
+
+- (id<ANTLRToken>) LB:(NSInteger)k
+{
+    if ( (index - k) < 0 )
+        return nil;
+    return [tokens objectAtIndex:(index-k)];
+}
+
+- (id<ANTLRToken>) LT:(NSInteger)k
+{
+    if ( index == -1 ) {
+        [self setup];
+//        [self fill];
+    }
+    if ( k == 0 )
+        return nil;
+    if ( k < 0 )
+        return [self LB:-k];
+
+    NSInteger i = index + k - 1;
+    [self sync:i];
+    if ( i >= [tokens count] ) { // return EOF token
+                                // EOF must be last token
+        return [tokens objectAtIndex:([tokens count]-1)];
+    }
+    if ( i > range )
+        range = i;
+    return [tokens objectAtIndex:i];
+}
+
+- (void) setup
+{
+    [self sync:0];
+    index = 0;
+}
+
+/** Reset this token stream by setting its token source. */
+- (void) setTokenSource:(id<ANTLRTokenSource>) aTokenSource
+{
+    tokenSource = aTokenSource;
+    if ( [tokens count] )
+        [tokens removeAllObjects];
+    index = -1;
+}
+
+- (AMutableArray *)getTokens
+{
+    return tokens;
+}
+
+- (AMutableArray *)getTokensFrom:(NSInteger) startIndex To:(NSInteger) stopIndex
+{
+    return [self getTokensFrom:startIndex To:stopIndex With:(ANTLRBitSet *)nil];
+}
+
+/** Given a start and stop index, return a List of all tokens in
+ *  the token type BitSet.  Return null if no tokens were found.  This
+ *  method looks at both on and off channel tokens.
+ */
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex With:(ANTLRBitSet *)types
+{
+    if ( index == -1 ) {
+        [self setup];
+//        [self fill];
+    }
+    if ( stopIndex >= [tokens count] )
+        stopIndex = [tokens count]-1;
+    if ( startIndex < 0 )
+        startIndex = 0;
+    if ( startIndex > stopIndex )
+        return nil;
+
+    // list = tokens[start:stop]:{Token t, t.getType() in types}
+    AMutableArray *filteredTokens = [AMutableArray arrayWithCapacity:5];
+    for (NSInteger i = startIndex; i <= stopIndex; i++) {
+        id<ANTLRToken>t = [tokens objectAtIndex:i];
+        if ( types == nil || [types member:t.type] ) {
+            [filteredTokens addObject:t];
+        }
+    }
+    if ( [filteredTokens count] == 0 ) {
+        filteredTokens = nil;
+    }
+    return filteredTokens;
+}
+
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithType:(NSInteger)ttype
+{
+    return [self getTokensFrom:startIndex To:stopIndex With:[ANTLRBitSet of:ttype]];
+}
+
+- (AMutableArray *)getTokensFrom:(NSInteger)startIndex To:(NSInteger)stopIndex WithList:(AMutableArray *)types
+{
+    return [self getTokensFrom:startIndex To:stopIndex With:[ANTLRBitSet newANTLRBitSetWithArray:types]];
+}
+
+- (NSString *)getSourceName
+{
+    return [tokenSource getSourceName];
+}
+
+/** Grab *all* tokens from stream and return string */
+- (NSString *) toString
+{
+    if ( index == -1 ) {
+        [self setup];
+    }
+    [self fill];
+    return [self toStringFromStart:0 ToEnd:[tokens count]-1];
+}
+
+- (NSString *) toStringFromStart:(NSInteger)startIdx ToEnd:(NSInteger)stopIdx
+{
+    if ( startIdx < 0 || stopIdx < 0 )
+        return nil;
+    if ( index == -1 ) {
+        [self setup];
+    }
+    if ( stopIdx >= [tokens count] )
+        stopIdx = [tokens count]-1;
+    NSMutableString *buf = [NSMutableString stringWithCapacity:5];
+    for (NSInteger i = startIdx; i <= stopIdx; i++) {
+        id<ANTLRToken>t = [tokens objectAtIndex:i];
+        if ( t.type == ANTLRTokenTypeEOF )
+            break;
+        [buf appendString:[t text]];
+    }
+    return buf;
+}
+
+- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken
+{
+    if ( startToken != nil && stopToken != nil ) {
+        return [self toStringFromStart:[startToken getTokenIndex] ToEnd:[stopToken getTokenIndex]];
+    }
+    return nil;
+}
+
+/** Get all tokens from lexer until EOF */
+- (void) fill
+{
+    if ( index == -1 ) [self setup];
+    if ( [((ANTLRCommonToken *)[tokens objectAtIndex:index]) type] == ANTLRTokenTypeEOF )
+        return;
+
+    NSInteger i = index+1;
+    [self sync:i];
+    while ( [((ANTLRCommonToken *)[tokens objectAtIndex:i]) type] != ANTLRTokenTypeEOF ) {
+        i++;
+        [self sync:i];
+    }
+}
+
+@end
diff --git a/runtime/ObjC/Framework/BufferedTreeNodeStream.h b/runtime/ObjC/Framework/BufferedTreeNodeStream.h
new file mode 100644
index 0000000..07555a5
--- /dev/null
+++ b/runtime/ObjC/Framework/BufferedTreeNodeStream.h
@@ -0,0 +1,157 @@
+//
+//  ANTLRBufferedTreeNodeStream.h
+//  ANTLR
+//
+// [The "BSD licence"]
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTree.h"
+#import "ANTLRCommonTreeAdaptor.h"
+#import "ANTLRTokenStream.h"
+#import "ANTLRCommonTreeNodeStream.h"
+#import "ANTLRLookaheadStream.h"
+#import "ANTLRTreeIterator.h"
+#import "ANTLRIntArray.h"
+#import "AMutableArray.h"
+
+#define DEFAULT_INITIAL_BUFFER_SIZE 100
+#define INITIAL_CALL_STACK_SIZE 10
+
+#ifdef DONTUSENOMO
+@interface ANTLRStreamIterator : ANTLRTreeIterator
+{
+    NSInteger idx;
+    __strong ANTLRBufferedTreeNodeStream *input;
+    __strong AMutableArray *nodes;
+}
+
++ (id) newANTLRStreamIterator:(ANTLRBufferedTreeNodeStream *) theStream;
+
+- (id) initWithStream:(ANTLRBufferedTreeNodeStream *) theStream;
+
+- (BOOL) hasNext;
+- (id) next;
+- (void) remove;
+@end
+#endif
+
+@interface ANTLRBufferedTreeNodeStream : NSObject <ANTLRTreeNodeStream>
+{
+	id up;
+	id down;
+	id eof;
+
+	AMutableArray *nodes;
+
+	id root; // root
+
+	id<ANTLRTokenStream> tokens;
+	ANTLRCommonTreeAdaptor *adaptor;
+
+	BOOL uniqueNavigationNodes;
+	NSInteger index;
+	NSInteger lastMarker;
+	ANTLRIntArray *calls;
+
+	NSEnumerator *e;
+    id currentSymbol;
+
+}
+
+@property (retain, getter=getUp, setter=setUp:) id up;
+@property (retain, getter=getDown, setter=setDown:) id down;
+@property (retain, getter=eof, setter=setEof:) id eof;
+@property (retain, getter=getNodes, setter=setNodes:) AMutableArray *nodes;
+@property (retain, getter=getTreeSource, setter=setTreeSource:) id root;
+@property (retain, getter=getTokenStream, setter=setTokenStream:) id<ANTLRTokenStream> tokens;
+@property (retain, getter=getAdaptor, setter=setAdaptor:) ANTLRCommonTreeAdaptor *adaptor;
+@property (assign, getter=getUniqueNavigationNodes, setter=setUniqueNavigationNodes:) BOOL uniqueNavigationNodes;
+@property (assign) NSInteger index;
+@property (assign, getter=getLastMarker, setter=setLastMarker:) NSInteger lastMarker;
+@property (retain, getter=getCalls, setter=setCalls:) ANTLRIntArray *calls;
+@property (retain, getter=getEnum, setter=setEnum:) NSEnumerator *e;
+@property (retain, getter=getCurrentSymbol, setter=setCurrentSymbol:) id currentSymbol;
+
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(ANTLRCommonTree *)tree;
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)tree;
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)tree withBufferSize:(NSInteger)initialBufferSize;
+
+#pragma mark Constructor
+- (id) initWithTree:(ANTLRCommonTree *)tree;
+- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)tree;
+- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)tree WithBufferSize:(NSInteger)bufferSize;
+
+- (void)dealloc;
+- (id) copyWithZone:(NSZone *)aZone;
+
+// protected methods. DO NOT USE
+#pragma mark Protected Methods
+- (void) fillBuffer;
+- (void) fillBufferWithTree:(ANTLRCommonTree *) tree;
+- (NSInteger) getNodeIndex:(ANTLRCommonTree *) node;
+- (void) addNavigationNode:(NSInteger) type;
+- (id) getNode:(NSUInteger) i;
+- (id) LT:(NSInteger) k;
+- (id) getCurrentSymbol;
+- (id) LB:(NSInteger) i;
+#pragma mark General Methods
+- (NSString *) getSourceName;
+
+- (id<ANTLRTokenStream>) getTokenStream;
+- (void) setTokenStream:(id<ANTLRTokenStream>) tokens;
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
+- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>) anAdaptor;
+
+- (BOOL)getUniqueNavigationNodes;
+- (void) setUniqueNavigationNodes:(BOOL)aVal;
+
+- (void) consume;
+- (NSInteger) LA:(NSInteger) i;
+- (NSInteger) mark;
+- (void) release:(NSInteger) marker;
+- (void) rewind:(NSInteger) marker;
+- (void) rewind;
+- (void) seek:(NSInteger) idx;
+
+- (void) push:(NSInteger) i;
+- (NSInteger) pop;
+
+- (void) reset;
+- (NSUInteger) count;
+- (NSEnumerator *) objectEnumerator;
+- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
+
+- (NSString *) toTokenTypeString;
+- (NSString *) toTokenString:(NSInteger)aStart ToEnd:(NSInteger)aStop;
+- (NSString *) toStringFromNode:(id)aStart ToNode:(id)aStop;
+
+// getters and setters
+- (AMutableArray *) getNodes;
+- (id) eof;
+- (void)setEof:(id)anEOF;
+
+@end
diff --git a/runtime/ObjC/Framework/BufferedTreeNodeStream.m b/runtime/ObjC/Framework/BufferedTreeNodeStream.m
new file mode 100644
index 0000000..a8f73d8
--- /dev/null
+++ b/runtime/ObjC/Framework/BufferedTreeNodeStream.m
@@ -0,0 +1,556 @@
+//
+//  ANTLRBufferedTreeNodeStream.m
+//  ANTLR
+//
+// [The "BSD licence"]
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRBufferedTreeNodeStream.h"
+#import "ANTLRStreamEnumerator.h"
+#import "ANTLRCommonTreeAdaptor.h"
+
+extern NSInteger debug;
+
+#ifdef DONTUSENOMO
+@implementation ANTLRTreeStreamIterator
++ newANTLRTreeStreamIteratorWithNodes:(ANTLRBufferedTreeNodeStream *)theStream
+{
+    return[[ANTLRTreeStreamIterator alloc] initWithStream:theStream];
+}
+
+- (id) initWithStream:(ANTLRBufferedTreeNodeStream *)theStream
+{
+    if ((self = [super init]) != nil) {
+        idx = 0;
+        input = theStream;
+        nodes = [theStream getNodes];
+    }
+    return self;
+}
+
+- (BOOL) hasNext
+{
+    return idx < [nodes count];
+}
+
+- (id) next
+{
+    NSInteger current = idx;
+    idx++;
+    if (current < [nodes count]) {
+    }
+    return [nodes getEof];
+}
+
+- (void) remove
+{
+	@throw [ANTLRRuntimeException newException:@"cannot remove nodes from stream"];
+}
+
+@end
+#endif
+
+@implementation ANTLRBufferedTreeNodeStream
+
+@synthesize up;
+@synthesize down;
+@synthesize eof;
+@synthesize nodes;
+@synthesize root;
+@synthesize tokens;
+@synthesize adaptor;
+@synthesize uniqueNavigationNodes;
+@synthesize index;
+@synthesize lastMarker;
+@synthesize calls;
+@synthesize e;
+@synthesize currentSymbol;
+
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(ANTLRCommonTree *) aTree
+{
+    return [((ANTLRBufferedTreeNodeStream *)[ANTLRBufferedTreeNodeStream alloc]) initWithTree:(ANTLRCommonTree *)aTree];
+}
+
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)aTree
+{
+    return [[ANTLRBufferedTreeNodeStream alloc] initWithTreeAdaptor:adaptor Tree:(ANTLRCommonTree *)aTree];
+}
+
++ (ANTLRBufferedTreeNodeStream *) newANTLRBufferedTreeNodeStream:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)aTree withBufferSize:(NSInteger)initialBufferSize
+{
+    return [[ANTLRBufferedTreeNodeStream alloc] initWithTreeAdaptor:adaptor Tree:(ANTLRCommonTree *)aTree WithBufferSize:initialBufferSize];
+}
+
+-(ANTLRBufferedTreeNodeStream *) init
+{
+	self = [super init];
+	if (self) {
+		index = -1;
+		uniqueNavigationNodes = NO;
+        root = [[ANTLRCommonTree alloc] init];
+        //		tokens = tree;
+        adaptor = [[[ANTLRCommonTreeAdaptor alloc] init] retain];
+        nodes = [[AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+    }
+	return self;
+}
+
+- (ANTLRBufferedTreeNodeStream *)initWithTree:(ANTLRCommonTree *) aTree
+{
+	self = [super init];
+	if (self) {
+		index = -1;
+		uniqueNavigationNodes = NO;
+        root = aTree;
+        //		tokens = aTree;
+        adaptor = [[[ANTLRCommonTreeAdaptor alloc] init] retain];
+        nodes = [[AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+    }
+	return self;
+}
+
+-(ANTLRBufferedTreeNodeStream *) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)aTree
+{
+	self = [super init];
+	if (self) {
+		index = -1;
+		uniqueNavigationNodes = NO;
+        root = aTree;
+        //		tokens = aTree;
+        adaptor = [anAdaptor retain];
+        nodes = [[AMutableArray arrayWithCapacity:DEFAULT_INITIAL_BUFFER_SIZE] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+    }
+	return self;
+}
+
+-(ANTLRBufferedTreeNodeStream *) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)anAdaptor Tree:(ANTLRCommonTree *)aTree WithBufferSize:(NSInteger)bufferSize
+{
+	self = [super init];
+	if (self) {
+        //		down = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"DOWN"];
+        //		up = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"UP"];
+        //		eof = [adaptor createToken:ANTLRTokenTypeDOWN withText:@"EOF"];
+		index = -1;
+		uniqueNavigationNodes = NO;
+        root = aTree;
+        //		tokens = aTree;
+        adaptor = [anAdaptor retain];
+        nodes = [[AMutableArray arrayWithCapacity:bufferSize] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+	}
+	return self;
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRBufferedTreeNodeStream" );
+#endif
+    if ( adaptor ) [adaptor release];
+    if ( nodes ) [nodes release];
+    if ( root ) [root release];
+    if ( down ) [down release];
+    if ( up ) [up release];
+    if ( eof ) [eof release];
+	[super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRBufferedTreeNodeStream *copy;
+
+    copy = [[[self class] allocWithZone:aZone] init];
+    if ( up )
+        copy.up = [up copyWithZone:aZone];
+    if ( down )
+        copy.down = [down copyWithZone:aZone];
+    if ( eof )
+        copy.eof = [eof copyWithZone:aZone];
+    if ( nodes )
+        copy.nodes = [nodes copyWithZone:aZone];
+    if ( root )
+        copy.root = [root copyWithZone:aZone];
+    if ( tokens )
+        copy.tokens = [tokens copyWithZone:aZone];
+    if ( adaptor )
+        copy.adaptor = [adaptor copyWithZone:aZone];
+    copy.uniqueNavigationNodes = self.uniqueNavigationNodes;
+    copy.index = self.index;
+    copy.lastMarker = self.lastMarker;
+    if ( calls )
+        copy.calls = [calls copyWithZone:aZone];
+    return copy;
+}
+
+// protected methods. DO NOT USE
+#pragma mark Protected Methods
+-(void) fillBuffer
+{
+	[self fillBufferWithTree:root];
+	// if (debug > 1) NSLog("revIndex=%@", tokenTypeToStreamIndexesMap);
+	index = 0; // buffer of nodes intialized now
+}
+
+-(void) fillBufferWithTree:(ANTLRCommonTree *) aTree
+{
+	BOOL empty = [adaptor isNil:aTree];
+	if (!empty) {
+		[nodes addObject:aTree];
+	}
+	NSInteger n = [adaptor getChildCount:aTree];
+	if (!empty && n > 0) {
+		[self addNavigationNode:ANTLRTokenTypeDOWN];
+	}
+	for (NSInteger c = 0; c < n; c++) {
+		id child = [adaptor getChild:aTree At:c];
+		[self fillBufferWithTree:child];
+	}
+	if (!empty && n > 0) {
+		[self addNavigationNode:ANTLRTokenTypeUP];
+	}
+}
+
+-(NSInteger) getNodeIndex:(ANTLRCommonTree *) node
+{
+	if (index == -1) {
+		[self fillBuffer];
+	}
+	for (NSUInteger i = 0; i < [nodes count]; i++) {
+		id t = [nodes objectAtIndex:i];
+		if (t == node) {
+			return i;
+		}
+	}
+	return -1;
+}
+
+-(void) addNavigationNode:(NSInteger) type
+{
+	id navNode = nil;
+	if (type == ANTLRTokenTypeDOWN) {
+		if (self.uniqueNavigationNodes) {
+			navNode = [adaptor createToken:ANTLRTokenTypeDOWN Text:@"DOWN"];
+		}
+		else {
+			navNode = down;
+		}
+
+	}
+	else {
+		if (self.uniqueNavigationNodes) {
+			navNode = [adaptor createToken:ANTLRTokenTypeUP Text:@"UP"];
+		}
+		else {
+			navNode = up;
+		}
+	}
+	[nodes addObject:navNode];
+}
+
+-(id) getNode:(NSUInteger) i
+{
+	if (index == -1) {
+		[self fillBuffer];
+	}
+	return [nodes objectAtIndex:i];
+}
+
+-(id) LT:(NSInteger) k
+{
+	if (index == -1) {
+		[self fillBuffer];
+	}
+	if (k == 0) {
+		return nil;
+	}
+	if (k < 0) {
+		return [self LB:-k];
+	}
+	if ((index + k - 1) >= [nodes count]) {
+		return eof;
+	}
+	return [nodes objectAtIndex:(index + k - 1)];
+}
+
+-(id) getCurrentSymbol
+{
+	return [self LT:1];
+}
+
+-(id) LB:(NSInteger) k
+{
+	if (k == 0) {
+		return nil;
+	}
+	if ((index - k) < 0) {
+		return nil;
+	}
+	return [nodes objectAtIndex:(index - k)];
+}
+
+- (ANTLRCommonTree *)getTreeSource
+{
+    return root;
+}
+
+-(NSString *)getSourceName
+{
+	return [[self getTokenStream] getSourceName];
+}
+
+- (id<ANTLRTokenStream>)getTokenStream
+{
+    return tokens;
+}
+
+- (void) setTokenStream:(id<ANTLRTokenStream>)newtokens
+{
+    tokens = newtokens;
+}
+
+- (id<ANTLRTreeAdaptor>)getTreeAdaptor
+{
+    return adaptor;
+}
+
+- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    adaptor = anAdaptor;
+}
+
+- (BOOL)getUniqueNavigationNodes
+{
+    return uniqueNavigationNodes;
+}
+
+- (void) setUniqueNavigationNodes:(BOOL)aVal
+{
+    uniqueNavigationNodes = aVal;
+}
+
+-(void) consume
+{
+	if (index == -1) {
+		[self fillBuffer];
+	}
+	index++;
+}
+
+-(NSInteger) LA:(NSInteger) i
+{
+	return [adaptor getType:[self LT:i]];
+}
+
+-(NSInteger) mark
+{
+	if (index == -1) {
+		[self fillBuffer];
+	}
+	lastMarker = self.index;
+	return lastMarker;
+}
+
+-(void) release:(NSInteger) marker
+{
+	// do nothing
+}
+
+-(void) rewind:(NSInteger) marker
+{
+	[self seek:marker];
+}
+
+-(void) rewind
+{
+	[self seek:lastMarker];
+}
+
+-(void) seek:(NSInteger) i
+{
+	if (index == -1) {
+		[self fillBuffer];
+	}
+	index = i;
+}
+
+-(void) push:(NSInteger) i
+{
+	if (calls == nil) {
+		calls = [ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE];
+	}
+	[calls push:index];
+	[self seek:i];
+}
+
+-(NSInteger) pop
+{
+	NSInteger ret = [calls pop];
+	[self seek:ret];
+	return ret;
+}
+
+-(void) reset
+{
+	index = 0;
+	lastMarker = 0;
+	if (calls != nil) {
+		[calls reset];
+	}
+}
+
+-(NSUInteger) count
+{
+	if (index == -1) {
+		[self fillBuffer];
+	}
+	return [nodes count];
+}
+
+-(NSUInteger) size
+{
+	return [self count];
+}
+
+-(NSEnumerator *) objectEnumerator
+{
+	if (e == nil) {
+		e = [[ANTLRStreamEnumerator alloc] initWithNodes:nodes andEOF:eof];
+	}
+	return e;
+}
+
+-(void) replaceChildren:(ANTLRCommonTree *) parent From:(NSInteger)startIdx To:(NSInteger)stopIdx With:(ANTLRCommonTree *)aTree
+{
+	if (parent != nil) {
+		[adaptor replaceChildren:parent From:startIdx To:stopIdx With:aTree];
+	}
+}
+
+-(NSString *) toTokenTypeString
+{
+	if (index == -1)
+	{
+		[self fillBuffer];
+	}
+	NSMutableString *buf = [NSMutableString stringWithCapacity:10];
+	for (NSUInteger i= 0; i < [nodes count]; i++) {
+		ANTLRCommonTree * aTree = (ANTLRCommonTree *)[self getNode:i];
+		[buf appendFormat:@" %d", [adaptor getType:aTree]];
+	}
+	return buf;
+}
+
+-(NSString *) toTokenString:(NSInteger)aStart ToEnd:(NSInteger)aStop
+{
+	if (index == -1) {
+		[self fillBuffer];
+	}
+	NSMutableString *buf = [NSMutableString stringWithCapacity:10];
+	for (NSUInteger i = aStart; i < [nodes count] && i <= aStop; i++) {
+		ANTLRCommonTree * t = (ANTLRCommonTree *)[self getNode:i];
+		[buf appendFormat:@" %d", [adaptor getType:t]];
+	}
+	return buf;
+}
+
+-(NSString *) toStringFromNode:(id)aStart ToNode:(id)aStop
+{
+	if (aStart == nil || aStop == nil) {
+		return nil;
+	}
+	if (index == -1) {
+		[self fillBuffer];
+	}
+
+	// if we have a token stream, use that to dump text in order
+	if ([self getTokenStream] != nil) {
+		NSInteger beginTokenIndex = [adaptor getTokenStartIndex:aStart];
+		NSInteger endTokenIndex = [adaptor getTokenStopIndex:aStop];
+
+		if ([adaptor getType:aStop] == ANTLRTokenTypeUP) {
+			endTokenIndex = [adaptor getTokenStopIndex:aStart];
+		}
+		else if ([adaptor getType:aStop] == ANTLRTokenTypeEOF) {
+			endTokenIndex = [self count] - 2; //don't use EOF
+		}
+        [tokens toStringFromStart:beginTokenIndex ToEnd:endTokenIndex];
+	}
+	// walk nodes looking for aStart
+	ANTLRCommonTree * aTree = nil;
+	NSUInteger i = 0;
+	for (; i < [nodes count]; i++) {
+		aTree = [nodes objectAtIndex:i];
+		if (aTree == aStart) {
+			break;
+		}
+	}
+	NSMutableString *buf = [NSMutableString stringWithCapacity:10];
+	aTree = [nodes objectAtIndex:i]; // why?
+	while (aTree != aStop) {
+		NSString *text = [adaptor getText:aTree];
+		if (text == nil) {
+			text = [NSString stringWithFormat:@" %d", [adaptor getType:aTree]];
+		}
+		[buf appendString:text];
+		i++;
+		aTree = [nodes objectAtIndex:i];
+	}
+	NSString *text = [adaptor getText:aStop];
+	if (text == nil) {
+		text = [NSString stringWithFormat:@" %d", [adaptor getType:aStop]];
+	}
+	[buf appendString:text];
+	return buf;
+}
+
+// getters and setters
+- (AMutableArray *) getNodes
+{
+    return nodes;
+}
+
+- (id) eof
+{
+    return eof;
+}
+
+- (void) setEof:(id)theEOF
+{
+    eof = theEOF;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/CharStream.h b/runtime/ObjC/Framework/CharStream.h
new file mode 100644
index 0000000..f7be94b
--- /dev/null
+++ b/runtime/ObjC/Framework/CharStream.h
@@ -0,0 +1,49 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRIntStream.h"
+
+#define	ANTLRCharStreamEOF -1
+
+
+@protocol ANTLRCharStream < ANTLRIntStream >
+
+- (NSString *) substringWithRange:(NSRange) theRange;
+
+/** Get the ith character of lookahead.  This is the same usually as
+ *  LA(i).  This will be used for labels in the generated
+ *  lexer code.  I'd prefer to return a char here type-wise, but it's
+ *  probably better to be 32-bit clean and be consistent with LA.
+ */
+- (NSInteger)LT:(NSInteger) i;
+
+// ANTLR tracks the line information automatically
+
+// Because this stream can rewind, we need to be able to reset the line
+
+// The index of the character relative to the beginning of the line 0..n-1
+
+@end
diff --git a/runtime/ObjC/Framework/CharStreamState.h b/runtime/ObjC/Framework/CharStreamState.h
new file mode 100644
index 0000000..0cf872f
--- /dev/null
+++ b/runtime/ObjC/Framework/CharStreamState.h
@@ -0,0 +1,49 @@
+//
+//  ANTLRCharStreamState.h
+//  ANTLR
+//
+// [The "BSD licence"]
+// Copyright (c)  2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+
+
+@interface ANTLRCharStreamState : NSObject
+{
+NSInteger index;
+NSUInteger line;
+NSUInteger charPositionInLine;
+}
+
+@property (assign) NSInteger index;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;
+
++ newANTLRCharStreamState;
+
+- (id) init;
+
+@end
diff --git a/runtime/ObjC/Framework/CharStreamState.m b/runtime/ObjC/Framework/CharStreamState.m
new file mode 100755
index 0000000..b2a7e3a
--- /dev/null
+++ b/runtime/ObjC/Framework/CharStreamState.m
@@ -0,0 +1,52 @@
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRCharStreamState.h"
+
+
+@implementation ANTLRCharStreamState
+
+@synthesize index;
+@synthesize line;
+@synthesize charPositionInLine;
+
++ newANTLRCharStreamState
+{
+    return [[ANTLRCharStreamState alloc] init];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil) {
+        index = 0;
+        line = 1;
+        charPositionInLine = 0;
+    }
+    return self;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/CommonErrorNode.h b/runtime/ObjC/Framework/CommonErrorNode.h
new file mode 100644
index 0000000..d01af00
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonErrorNode.h
@@ -0,0 +1,67 @@
+//
+//  ANTLRCommonErrorNode.h
+//  ANTLR
+//
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRCommonTree.h"
+#import "ANTLRTokenStream.h"
+//#import "ANTLRIntStream.h"
+//#import "ANTLRToken.h"
+#import "ANTLRUnWantedTokenException.h"
+
+@interface ANTLRCommonErrorNode : ANTLRCommonTree
+{
+id<ANTLRIntStream> input;
+id<ANTLRToken> startToken;
+id<ANTLRToken> stopToken;
+ANTLRRecognitionException *trappedException;
+}
+
++ (id) newANTLRCommonErrorNode:(id<ANTLRTokenStream>)anInput
+                  From:(id<ANTLRToken>)startToken
+                    To:(id<ANTLRToken>)stopToken
+                     Exception:(ANTLRRecognitionException *) e;
+
+- (id) initWithInput:(id<ANTLRTokenStream>)anInput
+                From:(id<ANTLRToken>)startToken
+                  To:(id<ANTLRToken>)stopToken
+           Exception:(ANTLRRecognitionException *) e;
+
+- (void)dealloc;
+- (BOOL) isNil;
+
+- (NSInteger)type;
+- (NSString *)text;
+- (NSString *)toString;
+
+@property (retain) id<ANTLRIntStream> input;
+@property (retain) id<ANTLRToken> startToken;
+@property (retain) id<ANTLRToken> stopToken;
+@property (retain) ANTLRRecognitionException *trappedException;
+@end
diff --git a/runtime/ObjC/Framework/CommonErrorNode.m b/runtime/ObjC/Framework/CommonErrorNode.m
new file mode 100644
index 0000000..17fec33
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonErrorNode.m
@@ -0,0 +1,159 @@
+//
+//  ANTLRCommonErrorNode.m
+//  ANTLR
+//
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRCommonErrorNode.h"
+#import "ANTLRMissingTokenException.h"
+#import "ANTLRNoViableAltException.h"
+#import "ANTLRTreeNodeStream.h"
+#import "ANTLRUnwantedTokenException.h"
+
+@implementation ANTLRCommonErrorNode
+
++ (id) newANTLRCommonErrorNode:(id<ANTLRTokenStream>)anInput
+                          From:(id<ANTLRToken>)aStartToken
+                            To:(id<ANTLRToken>)aStopToken
+                     Exception:(ANTLRRecognitionException *) e
+{
+    return [[ANTLRCommonErrorNode alloc] initWithInput:anInput From:aStartToken To:aStopToken Exception:e];
+}
+
+- (id) init
+{
+    self = [super init];
+    if ( self != nil ) {
+    }
+    return self;
+}
+
+- (id) initWithInput:(id<ANTLRTokenStream>)anInput
+                From:(id<ANTLRToken>)aStartToken
+                  To:(id<ANTLRToken>)aStopToken
+           Exception:(ANTLRRecognitionException *) e
+{
+    self = [super init];
+    if ( self != nil ) {
+        //System.out.println("aStartToken: "+aStartToken+", aStopToken: "+aStopToken);
+        if ( aStopToken == nil ||
+            ([aStopToken getTokenIndex] < [aStartToken getTokenIndex] &&
+             aStopToken.type != ANTLRTokenTypeEOF) )
+        {
+            // sometimes resync does not consume a token (when LT(1) is
+            // in follow set.  So, aStopToken will be 1 to left to aStartToken. adjust.
+            // Also handle case where aStartToken is the first token and no token
+            // is consumed during recovery; LT(-1) will return null.
+            aStopToken = aStartToken;
+        }
+        input = anInput;
+        if ( input ) [input retain];
+        startToken = aStartToken;
+        if ( startToken ) [startToken retain];
+        stopToken = aStopToken;
+        if ( stopToken ) [stopToken retain];
+        trappedException = e;
+        if ( trappedException ) [trappedException retain];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRCommonErrorNode" );
+#endif
+    if ( input ) [input release];
+    if ( startToken ) [startToken release];
+    if ( stopToken ) [stopToken release];
+    if ( trappedException ) [trappedException release];
+	[super dealloc];
+}
+
+- (BOOL) isNil
+{
+    return NO;
+}
+
+- (NSInteger)type
+{
+    return ANTLRTokenTypeInvalid;
+}
+
+- (NSString *)text
+{
+    NSString *badText = nil;
+    if ( [startToken isKindOfClass:[self class]] ) {
+        int i = [(id<ANTLRToken>)startToken getTokenIndex];
+        int j = [(id<ANTLRToken>)stopToken getTokenIndex];
+        if ( stopToken.type == ANTLRTokenTypeEOF ) {
+            j = [(id<ANTLRTokenStream>)input size];
+        }
+        badText = [(id<ANTLRTokenStream>)input toStringFromStart:i ToEnd:j];
+    }
+    else if ( [startToken isKindOfClass:[self class]] ) {
+        badText = [(id<ANTLRTreeNodeStream>)input toStringFromNode:startToken ToNode:stopToken];
+    }
+    else {
+        // people should subclass if they alter the tree type so this
+        // next one is for sure correct.
+        badText = @"<unknown>";
+    }
+    return badText;
+}
+
+- (NSString *)toString
+{
+    NSString *aString;
+    if ( [trappedException isKindOfClass:[ANTLRMissingTokenException class]] ) {
+        aString = [NSString stringWithFormat:@"<missing type: %@ >",
+        [(ANTLRMissingTokenException *)trappedException getMissingType]];
+        return aString;
+    }
+    else if ( [trappedException isKindOfClass:[ANTLRUnwantedTokenException class]] ) {
+        aString = [NSString stringWithFormat:@"<extraneous: %@, resync=%@>",
+        [trappedException getUnexpectedToken],
+        [self text]];
+        return aString;
+    }
+    else if ( [trappedException isKindOfClass:[ANTLRMismatchedTokenException class]] ) {
+        aString = [NSString stringWithFormat:@"<mismatched token: %@, resync=%@>", trappedException.token, [self text]];
+        return aString;
+    }
+    else if ( [trappedException isKindOfClass:[ANTLRNoViableAltException class]] ) {
+        aString = [NSString stringWithFormat:@"<unexpected:  %@, resync=%@>", trappedException.token, [self text]];
+        return aString;
+    }
+    aString = [NSString stringWithFormat:@"<error: %@>",[self text]];
+    return aString;
+}
+
+@synthesize input;
+@synthesize startToken;
+@synthesize stopToken;
+@synthesize trappedException;
+@end
diff --git a/runtime/ObjC/Framework/CommonToken.h b/runtime/ObjC/Framework/CommonToken.h
new file mode 100644
index 0000000..948e129
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonToken.h
@@ -0,0 +1,129 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRToken.h"
+#import "ANTLRCharStream.h"
+
+@interface ANTLRCommonToken : NSObject < ANTLRToken > {
+	__strong NSString *text;
+	NSInteger type;
+	// information about the Token's position in the input stream
+	NSUInteger line;
+	NSUInteger charPositionInLine;
+	NSUInteger channel;
+	// this token's position in the TokenStream
+	NSInteger index;
+
+	// indices into the CharStream to avoid copying the text
+	// can manually override the text by using -setText:
+	NSInteger startIndex;
+	NSInteger stopIndex;
+	// the actual input stream this token was found in
+	__strong id<ANTLRCharStream> input;
+}
+
++ (void) initialize;
++ (NSInteger) DEFAULT_CHANNEL;
++ (id<ANTLRToken>)INVALID_TOKEN;
++ (NSInteger) INVALID_TOKEN_TYPE;
++ (id<ANTLRToken>) newToken;
++ (id<ANTLRToken>) newToken:(id<ANTLRCharStream>)anInput
+                       Type:(NSInteger)aTType
+                    Channel:(NSInteger)aChannel
+                      Start:(NSInteger)aStart
+                       Stop:(NSInteger)aStop;
++ (id<ANTLRToken>) newToken:(ANTLRTokenType)aType;
++ (id<ANTLRToken>) newToken:(NSInteger)tokenType Text:(NSString *)tokenText;
++ (id<ANTLRToken>) newTokenWithToken:(ANTLRCommonToken *)fromToken;
++ (id<ANTLRToken>) eofToken;
++ (id<ANTLRToken>) skipToken;
++ (id<ANTLRToken>) invalidToken;
++ (ANTLRTokenChannel) defaultChannel;
+
+// designated initializer. This is used as the default way to initialize a Token in the generated code.
+- (id) init;
+- (id) initWithInput:(id<ANTLRCharStream>)anInput
+                                Type:(NSInteger)aTType
+                             Channel:(NSInteger)aChannel
+                               Start:(NSInteger)theStart
+                                Stop:(NSInteger)theStop;
+- (id) initWithToken:(id<ANTLRToken>)aToken;
+- (id) initWithType:(ANTLRTokenType)aType;
+- (id) initWithType:(ANTLRTokenType)aTType Text:(NSString *)tokenText;
+
+//----------------------------------------------------------
+//  text
+//----------------------------------------------------------
+- (NSString *)text;
+- (void) setText:(NSString *)aText;
+
+//----------------------------------------------------------
+//  type
+//----------------------------------------------------------
+- (NSInteger)type;
+- (void) setType:(NSInteger)aType;
+
+//----------------------------------------------------------
+//  channel
+//----------------------------------------------------------
+- (NSUInteger)channel;
+- (void) setChannel:(NSUInteger)aChannel;
+
+//----------------------------------------------------------
+//  input
+//----------------------------------------------------------
+- (id<ANTLRCharStream>)input;
+- (void) setInput:(id<ANTLRCharStream>)anInput;
+
+- (NSInteger)getStart;
+- (void) setStart: (NSInteger)aStart;
+
+- (NSInteger)getStop;
+- (void) setStop: (NSInteger) aStop;
+
+// the index of this Token into the TokenStream
+- (NSInteger)getTokenIndex;
+- (void) setTokenIndex:(NSInteger)aTokenIndex;
+
+// conform to NSCopying
+- (id) copyWithZone:(NSZone *)theZone;
+
+- (NSString *) description;
+- (NSString *) toString;
+
+@property (retain, getter = text, setter = setText:) NSString *text;
+@property (assign) NSInteger type;
+@property (assign, getter = line, setter = setLine:) NSUInteger line;
+@property (assign, getter=charPositionInLine, setter = setCharPositionInLine:) NSUInteger charPositionInLine;
+@property (assign) NSUInteger channel;
+@property (assign) NSInteger index;
+@property (assign, getter=getStart, setter=setStart:) NSInteger startIndex;
+@property (assign, getter=getStop, setter=setStop:) NSInteger stopIndex;
+@property (retain) id<ANTLRCharStream> input;
+
+@end
diff --git a/runtime/ObjC/Framework/CommonToken.m b/runtime/ObjC/Framework/CommonToken.m
new file mode 100644
index 0000000..ee0e018
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonToken.m
@@ -0,0 +1,397 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRCommonToken.h"
+
+static ANTLRCommonToken *SKIP_TOKEN;
+static ANTLRCommonToken *EOF_TOKEN;
+static ANTLRCommonToken *INVALID_TOKEN;
+
+@implementation ANTLRCommonToken
+
+    static NSInteger DEFAULT_CHANNEL = ANTLRTokenChannelDefault;
+    static NSInteger INVALID_TOKEN_TYPE = ANTLRTokenTypeInvalid;
+
+
+@synthesize text;
+@synthesize type;
+@synthesize line;
+@synthesize charPositionInLine;
+@synthesize channel;
+@synthesize index;
+@synthesize startIndex;
+@synthesize stopIndex;
+@synthesize input;
+
++ (void) initialize
+{
+    EOF_TOKEN = [ANTLRCommonToken newToken:ANTLRTokenTypeEOF Text:@"EOF"];
+    SKIP_TOKEN = [ANTLRCommonToken newToken:ANTLRTokenTypeInvalid Text:@"Skip"];
+    INVALID_TOKEN = [ANTLRCommonToken newToken:ANTLRTokenTypeInvalid Text:@"Invalid"];
+    [EOF_TOKEN retain];
+    [SKIP_TOKEN retain];
+    [INVALID_TOKEN retain];
+}
+
++ (ANTLRCommonToken *)INVALID_TOKEN
+{
+    return INVALID_TOKEN;
+}
+
++ (NSInteger) DEFAULT_CHANNEL
+{
+    return DEFAULT_CHANNEL;
+}
+
++ (NSInteger) INVALID_TOKEN_TYPE
+{
+    return INVALID_TOKEN_TYPE;
+}
+
++ (ANTLRCommonToken *) newToken
+{
+    return [[ANTLRCommonToken alloc] init];
+}
+
++ (ANTLRCommonToken *) newToken:(id<ANTLRCharStream>)anInput Type:(NSInteger)aTType Channel:(NSInteger)aChannel Start:(NSInteger)aStart Stop:(NSInteger)aStop
+{
+    return [[ANTLRCommonToken alloc] initWithInput:(id<ANTLRCharStream>)anInput Type:(NSInteger)aTType Channel:(NSInteger)aChannel Start:(NSInteger)aStart Stop:(NSInteger)aStop];
+}
+
++ (ANTLRCommonToken *) newToken:(ANTLRTokenType)tokenType
+{
+    return( [[ANTLRCommonToken alloc] initWithType:tokenType] );
+}
+
++ (ANTLRCommonToken *) newToken:(NSInteger)tokenType Text:(NSString *)tokenText
+{
+    return( [[ANTLRCommonToken alloc] initWithType:tokenType Text:tokenText] );
+}
+
++ (ANTLRCommonToken *) newTokenWithToken:(ANTLRCommonToken *)fromToken
+{
+    return( [[ANTLRCommonToken alloc] initWithToken:fromToken] );
+}
+
+// return the singleton EOF Token
++ (id<ANTLRToken>) eofToken
+{
+    if (EOF_TOKEN == nil) {
+        EOF_TOKEN = [[ANTLRCommonToken newToken:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+    }
+    return EOF_TOKEN;
+}
+
+// return the singleton skip Token
++ (id<ANTLRToken>) skipToken
+{
+    if (SKIP_TOKEN == nil) {
+        SKIP_TOKEN = [[ANTLRCommonToken newToken:ANTLRTokenTypeInvalid Text:@"Skip"] retain];
+    }
+    return SKIP_TOKEN;
+}
+
+// return the singleton skip Token
++ (id<ANTLRToken>) invalidToken
+{
+    if (INVALID_TOKEN == nil) {
+        INVALID_TOKEN = [[ANTLRCommonToken newToken:ANTLRTokenTypeInvalid Text:@"Invalid"] retain];
+    }
+    return SKIP_TOKEN;
+}
+
+// the default channel for this class of Tokens
++ (ANTLRTokenChannel) defaultChannel
+{
+    return ANTLRTokenChannelDefault;
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil) {
+        input = nil;
+        type = ANTLRTokenTypeInvalid;
+        channel = ANTLRTokenChannelDefault;
+        startIndex = 0;
+        stopIndex = 0;
+    }
+    return self;
+}
+
+// designated initializer
+- (id) initWithInput:(id<ANTLRCharStream>)anInput
+                           Type:(NSInteger)aTType
+                             Channel:(NSInteger)aChannel
+                               Start:(NSInteger)aStart
+                                Stop:(NSInteger)aStop
+{
+    if ((self = [super init]) != nil) {
+        input = anInput;
+        if ( input ) [input retain];
+        type = aTType;
+        channel = aChannel;
+        startIndex = aStart;
+        stopIndex = aStop;
+        if (type == ANTLRTokenTypeEOF)
+            text = @"EOF";
+        else
+            text = [input substringWithRange:NSMakeRange(startIndex, (stopIndex-startIndex)+1)];
+        if ( text ) [text retain];
+    }
+    return self;
+}
+
+- (id) initWithToken:(ANTLRCommonToken *)oldToken
+{
+    if ((self = [super init]) != nil) {
+        text = [NSString stringWithString:oldToken.text];
+        if ( text ) [text retain];
+        type = oldToken.type;
+        line = oldToken.line;
+        index = oldToken.index;
+        charPositionInLine = oldToken.charPositionInLine;
+        channel = oldToken.channel;
+        input = oldToken.input;
+        if ( input ) [input retain];
+        if ( [oldToken isKindOfClass:[ANTLRCommonToken class]] ) {
+            startIndex = oldToken.startIndex;
+            stopIndex = oldToken.stopIndex;
+        }
+    }
+    return self;
+}
+
+- (id) initWithType:(ANTLRTokenType)aTType
+{
+    if ((self = [super init]) != nil) {
+        self.type = aTType;
+    }
+    return self;
+}
+
+- (id) initWithType:(ANTLRTokenType)aTType Text:(NSString *)tokenText
+{
+    if ((self = [super init]) != nil) {
+        self.type = aTType;
+        self.text = [NSString stringWithString:tokenText];
+        if ( text ) [text retain];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRCommonToken" );
+#endif
+    if ( input ) [input release];
+    if ( text ) [text release];
+    [super dealloc];
+}
+
+// create a copy, including the text if available
+// the input stream is *not* copied!
+- (id) copyWithZone:(NSZone *)theZone
+{
+    ANTLRCommonToken *copy = [[[self class] allocWithZone:theZone] init];
+
+    if (text)
+        copy.text = [text copyWithZone:nil];
+    copy.type = type;
+    copy.line = line;
+    copy.charPositionInLine = charPositionInLine;
+    copy.channel = channel;
+    copy.index = index;
+    copy.startIndex = startIndex;
+    copy.stopIndex = stopIndex;
+    copy.input = input;
+    return copy;
+}
+
+
+//----------------------------------------------------------
+//  charPositionInLine
+//----------------------------------------------------------
+- (NSUInteger) charPositionInLine
+{
+    return charPositionInLine;
+}
+
+- (void) setCharPositionInLine:(NSUInteger)aCharPositionInLine
+{
+    charPositionInLine = aCharPositionInLine;
+}
+
+//----------------------------------------------------------
+//  line
+//----------------------------------------------------------
+- (NSUInteger) line
+{
+    return line;
+}
+
+- (void) setLine:(NSUInteger)aLine
+{
+    line = aLine;
+}
+
+//----------------------------------------------------------
+//  text
+//----------------------------------------------------------
+- (NSString *) text
+{
+    if (text != nil) {
+        return text;
+    }
+    if (input == nil) {
+        return nil;
+    }
+    return [input substringWithRange:NSMakeRange(startIndex, (stopIndex-startIndex)+1)];
+}
+
+- (void) setText:(NSString *)aText
+{
+    if (text != aText) {
+        if ( text ) [text release];
+        text = aText;
+        [text retain];
+    }
+}
+
+
+//----------------------------------------------------------
+//  type
+//----------------------------------------------------------
+- (NSInteger)type
+{
+    return type;
+}
+
+- (void) setType:(NSInteger)aType
+{
+    type = aType;
+}
+
+//----------------------------------------------------------
+//  channel
+//----------------------------------------------------------
+- (NSUInteger)channel
+{
+    return channel;
+}
+
+- (void) setChannel:(NSUInteger)aChannel
+{
+    channel = aChannel;
+}
+
+
+//----------------------------------------------------------
+//  input
+//----------------------------------------------------------
+- (id<ANTLRCharStream>) input
+{
+    return input;
+}
+
+- (void) setInput: (id<ANTLRCharStream>) anInput
+{
+    if (input != anInput) {
+        if ( input ) [input release];
+        [anInput retain];
+    }
+    input = anInput;
+}
+
+
+//----------------------------------------------------------
+//  start
+//----------------------------------------------------------
+- (NSInteger) getStart
+{
+    return startIndex;
+}
+
+- (void) setStart: (NSInteger) aStart
+{
+    startIndex = aStart;
+}
+
+//----------------------------------------------------------
+//  stop
+//----------------------------------------------------------
+- (NSInteger) getStop
+{
+    return stopIndex;
+}
+
+- (void) setStop: (NSInteger) aStop
+{
+    stopIndex = aStop;
+}
+
+//----------------------------------------------------------
+//  index
+//----------------------------------------------------------
+- (NSInteger) getTokenIndex;
+{
+    return index;
+}
+
+- (void) setTokenIndex: (NSInteger) aTokenIndex;
+{
+    index = aTokenIndex;
+}
+
+
+// provide a textual representation for debugging
+- (NSString *) description
+{
+    NSString *channelStr;
+    NSMutableString *txtString;
+
+    channelStr = @"";
+    if ( channel > 0 ) {
+        channelStr = [NSString stringWithFormat:@",channel=%d\n", channel];
+    }
+    if ([self text] != nil) {
+        txtString = [NSMutableString stringWithString:[self text]];
+        [txtString replaceOccurrencesOfString:@"\n" withString:@"\\\\n" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
+        [txtString replaceOccurrencesOfString:@"\r" withString:@"\\\\r" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
+        [txtString replaceOccurrencesOfString:@"\t" withString:@"\\\\t" options:NSAnchoredSearch range:NSMakeRange(0, [txtString length])];
+    } else {
+        txtString = [NSMutableString stringWithString:@"<no text>"];
+    }
+    return [NSString stringWithFormat:@"[@%d, %d:%d='%@',<%d>%@,%d:%d]", index, startIndex, stopIndex, txtString, type, channelStr, line, charPositionInLine];
+}
+
+- (NSString *)toString
+{
+   return [self description];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/CommonTokenStream.h b/runtime/ObjC/Framework/CommonTokenStream.h
new file mode 100644
index 0000000..c26130e
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonTokenStream.h
@@ -0,0 +1,95 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTokenStream.h"
+#import "ANTLRToken.h"
+#import "ANTLRCommonToken.h"
+#import "ANTLRTokenSource.h"
+#import "ANTLRBitSet.h"
+#import "ANTLRBufferedTokenStream.h"
+#import "AMutableDictionary.h"
+
+@interface ANTLRCommonTokenStream : ANTLRBufferedTokenStream < ANTLRTokenStream >
+{
+	__strong AMutableDictionary *channelOverride;
+	NSUInteger channel;
+}
+
+@property (retain, getter=getChannelOverride,setter=setChannelOverride:) AMutableDictionary *channelOverride;
+@property (assign, getter=channel,setter=setChannel:) NSUInteger channel;
+
++ (ANTLRCommonTokenStream *)newANTLRCommonTokenStream;
++ (ANTLRCommonTokenStream *)newANTLRCommonTokenStreamWithTokenSource:(id<ANTLRTokenSource>)theTokenSource;
++ (ANTLRCommonTokenStream *)newANTLRCommonTokenStreamWithTokenSource:(id<ANTLRTokenSource>)theTokenSource
+                                                               Channel:(NSUInteger)aChannel;
+
+- (id) init;
+- (id) initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource;
+- (id) initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource Channel:(NSUInteger)aChannel;
+
+- (void) consume;
+- (id<ANTLRToken>) LB:(NSInteger)k;
+- (id<ANTLRToken>) LT:(NSInteger)k;
+
+- (NSInteger) skipOffChannelTokens:(NSInteger) i;
+- (NSInteger) skipOffChannelTokensReverse:(NSInteger) i;
+
+- (void)setup;
+
+- (NSInteger) getNumberOfOnChannelTokens;
+
+// - (id<ANTLRTokenSource>) getTokenSource;
+- (void) setTokenSource: (id<ANTLRTokenSource>) aTokenSource;
+
+- (NSUInteger)channel;
+- (void)setChannel:(NSUInteger)aChannel;
+
+- (AMutableDictionary *)channelOverride;
+- (void)setChannelOverride:(AMutableDictionary *)anOverride;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+#ifdef DONTUSENOMO
+- (NSArray *) tokensInRange:(NSRange)aRange;
+- (NSArray *) tokensInRange:(NSRange)aRange inBitSet:(ANTLRBitSet *)aBitSet;
+- (NSArray *) tokensInRange:(NSRange)aRange withTypes:(NSArray *)tokenTypes;
+- (NSArray *) tokensInRange:(NSRange)aRange withType:(NSInteger)tokenType;
+
+- (id<ANTLRToken>) getToken:(NSInteger)i;
+
+- (NSInteger) size;
+- (void) rewind;
+- (void) rewind:(NSInteger)marker;
+- (void) seek:(NSInteger)index;
+
+- (NSString *) toString;
+- (NSString *) toStringFromStart:(NSInteger)startIndex ToEnd:(NSInteger)stopIndex;
+- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken;
+
+#endif
+
+@end
diff --git a/runtime/ObjC/Framework/CommonTokenStream.m b/runtime/ObjC/Framework/CommonTokenStream.m
new file mode 100644
index 0000000..9ebc325
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonTokenStream.m
@@ -0,0 +1,352 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRToken.h"
+#import "ANTLRCommonTokenStream.h"
+
+
+@implementation ANTLRCommonTokenStream
+
+@synthesize channelOverride;
+@synthesize channel;
+
+#pragma mark Initialization
+
++ (ANTLRCommonTokenStream *)newANTLRCommonTokenStream
+{
+    return [[ANTLRCommonTokenStream alloc] init];
+}
+
++ (ANTLRCommonTokenStream *)newANTLRCommonTokenStreamWithTokenSource:(id<ANTLRTokenSource>)theTokenSource
+{
+    return [[ANTLRCommonTokenStream alloc] initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource];
+}
+
++ (ANTLRCommonTokenStream *)newANTLRCommonTokenStreamWithTokenSource:(id<ANTLRTokenSource>)theTokenSource Channel:(NSUInteger)aChannel
+{
+    return [[ANTLRCommonTokenStream alloc] initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource Channel:aChannel];
+}
+
+- (id) init
+{
+	if ((self = [super init]) != nil) {
+		channelOverride = [[AMutableDictionary dictionaryWithCapacity:100] retain];
+		channel = ANTLRTokenChannelDefault;
+	}
+	return self;
+}
+
+- (id) initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource
+{
+	if ((self = [super initWithTokenSource:theTokenSource]) != nil) {
+		channelOverride = [[AMutableDictionary dictionaryWithCapacity:100] retain];
+		channel = ANTLRTokenChannelDefault;
+	}
+	return self;
+}
+
+- (id) initWithTokenSource:(id<ANTLRTokenSource>)theTokenSource Channel:(NSUInteger)aChannel
+{
+	if ((self = [super initWithTokenSource:theTokenSource]) != nil) {
+		channelOverride = [[AMutableDictionary dictionaryWithCapacity:100] retain];
+		channel = aChannel;
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRCommonTokenStream" );
+#endif
+	if ( channelOverride ) [channelOverride release];
+	if ( tokens ) [tokens release];
+	[self setTokenSource:nil];
+	[super dealloc];
+}
+
+/** Always leave index on an on-channel token. */
+- (void) consume
+{
+    if (index == -1) [self setup];
+    index++;
+    [self sync:index];
+    while ( ((ANTLRCommonToken *)[tokens objectAtIndex:index]).channel != channel ) {
+		index++;
+		[self sync:index];
+	}
+}
+
+#pragma mark Lookahead
+
+- (id<ANTLRToken>) LB:(NSInteger)k
+{
+	if ( k == 0 || (index-k) < 0 ) {
+		return nil;
+	}
+	int i = index;
+	int n = 1;
+    // find k good tokens looking backwards
+	while ( n <= k ) {
+		i = [self skipOffChannelTokensReverse:i-1];
+		n++;
+	}
+	if ( i < 0 ) {
+		return nil;
+	}
+	return [tokens objectAtIndex:i];
+}
+
+- (id<ANTLRToken>) LT:(NSInteger)k
+{
+	if ( index == -1 ) [self setup];
+	if ( k == 0 ) return nil;
+	if ( k < 0 ) return [self LB:-k];
+	int i = index;
+	int n = 1;
+	while ( n < k ) {
+		i = [self skipOffChannelTokens:i+1];
+		n++;
+	}
+//	if ( i >= (NSInteger)[tokens count] ) {
+//		return [ANTLRCommonToken eofToken];
+//	}
+    if ( i > range ) range = i;
+	return [tokens objectAtIndex:i];
+}
+
+#pragma mark Channels & Skipping
+
+- (NSInteger) skipOffChannelTokens:(NSInteger) idx
+{
+    [self sync:idx];
+	while ( ((ANTLRCommonToken *)[tokens objectAtIndex:idx]).channel != channel ) {
+		idx++;
+        [self sync:idx];
+	}
+	return idx;
+}
+
+- (NSInteger) skipOffChannelTokensReverse:(NSInteger) i
+{
+	while ( i >= 0 && ((ANTLRCommonToken *)[tokens objectAtIndex:i]).channel != channel ) {
+		i--;
+	}
+	return i;
+}
+
+- (void) setup
+{
+    index = 0;
+    [self sync:0];
+    int i = 0;
+    while ( ((ANTLRCommonToken *)[tokens objectAtIndex:i]).channel != channel ) {
+        i++;
+        [self sync:i];
+    }
+	// leave index pointing at first token on channel
+    index = i;
+}
+
+- (NSInteger) getNumberOfOnChannelTokens
+{
+    NSInteger n = 0;
+    [self fill];
+    for( int i = 0; i < [tokens count]; i++ ) {
+        ANTLRCommonToken *t = [tokens objectAtIndex:i];
+        if ( t.channel == channel )
+            n++;
+        if ( t.type == ANTLRTokenTypeEOF )
+            break;
+    }
+    return n;
+}
+
+/** Reset this token stream by setting its token source. */
+- (void) setTokenSource:(id<ANTLRTokenSource>)aTokenSource
+{
+    [super setTokenSource:aTokenSource];
+    channel = ANTLRTokenChannelDefault;
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRCommonTokenStream *copy;
+
+    //    copy = [[[self class] allocWithZone:aZone] init];
+    copy = [super copyWithZone:aZone]; // allocation occurs in ANTLRBaseTree
+    if ( self.channelOverride )
+        copy.channelOverride = [channelOverride copyWithZone:aZone];
+    copy.channel = channel;
+    return copy;
+}
+
+- (NSUInteger)channel
+{
+    return channel;
+}
+
+- (void)setChannel:(NSUInteger)aChannel
+{
+    channel = aChannel;
+}
+
+- (AMutableDictionary *)channelOverride
+{
+    return channelOverride;
+}
+
+- (void)setChannelOverride:(AMutableDictionary *)anOverride
+{
+    channelOverride = anOverride;
+}
+
+#ifdef DONTUSENOMO
+#pragma mark Token access
+
+- (NSArray *) tokensInRange:(NSRange)aRange
+{
+	return [tokens subarrayWithRange:aRange];
+}
+
+#pragma mark Accessors
+
+- (id<ANTLRTokenSource>) getTokenSource
+{
+    return tokenSource;
+}
+
+- (NSArray *) tokensInRange:(NSRange)aRange inBitSet:(ANTLRBitSet *)aBitSet
+{
+	unsigned int startIndex = aRange.location;
+	unsigned int stopIndex = aRange.location+aRange.length;
+	if ( index == -1 ) {
+		[self setup];
+	}
+	if (stopIndex >= [tokens count]) {
+		stopIndex = [tokens count] - 1;
+	}
+	AMutableArray *filteredTokens = [AMutableArray arrayWithCapacity:100];
+	unsigned int i=0;
+	for (i = startIndex; i<=stopIndex; i++) {
+		id<ANTLRToken> token = [tokens objectAtIndex:i];
+		if (aBitSet == nil || [aBitSet member:token.type]) {
+			[filteredTokens addObject:token];
+		}
+	}
+	if ([filteredTokens count]) {
+		return filteredTokens;
+	} else {
+		[filteredTokens release];
+		return nil;
+	}
+}
+
+- (NSArray *) tokensInRange:(NSRange)aRange withTypes:(NSArray *)tokenTypes
+{
+	ANTLRBitSet *bits = [[ANTLRBitSet alloc] initWithArrayOfBits:tokenTypes];
+	NSArray *returnTokens = [[self tokensInRange:aRange inBitSet:bits] retain];
+	[bits release];
+	return returnTokens;
+}
+
+- (NSArray *) tokensInRange:(NSRange)aRange withType:(NSInteger)tokenType
+{
+	ANTLRBitSet *bits = [[ANTLRBitSet alloc] init];
+	[bits add:tokenType];
+	NSArray *returnTokens = [[self tokensInRange:aRange inBitSet:bits] retain];
+	[bits release];
+	return returnTokens;
+}
+
+- (id<ANTLRToken>) getToken:(NSInteger)i
+{
+	return [tokens objectAtIndex:i];
+}
+
+- (NSInteger) size
+{
+	return [tokens count];
+}
+
+- (void) rewind
+{
+	[self seek:lastMarker];
+}
+
+- (void) rewind:(NSInteger)marker
+{
+	[self seek:marker];
+}
+
+- (void) seek:(NSInteger)anIndex
+{
+	index = anIndex;
+}
+#pragma mark toString routines
+
+- (NSString *) toString
+{
+	if ( index == -1 ) {
+		[self setup];
+	}
+	return [self toStringFromStart:0 ToEnd:[tokens count]];
+}
+
+- (NSString *) toStringFromStart:(NSInteger)startIdx ToEnd:(NSInteger) stopIdx
+{
+    NSMutableString *stringBuffer;
+    id<ANTLRToken> t;
+
+    if ( startIdx < 0 || stopIdx < 0 ) {
+        return nil;
+    }
+    if ( index == -1 ) {
+        [self setup];
+    }
+    if ( stopIdx >= [tokens count] ) {
+        stopIdx = [tokens count]-1;
+    }
+    stringBuffer = [NSMutableString stringWithCapacity:30];
+    for (int i = startIdx; i <= stopIdx; i++) {
+        t = (id<ANTLRToken>)[tokens objectAtIndex:i];
+        [stringBuffer appendString:[t text]];
+    }
+    return stringBuffer;
+}
+
+- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken
+{
+	if (startToken && stopToken) {
+		int startIdx = [startToken getTokenIndex];
+		int stopIdx = [stopToken getTokenIndex];
+		return [self toStringFromStart:startIdx ToEnd:stopIdx];
+	}
+	return nil;
+}
+#endif
+
+@end
diff --git a/runtime/ObjC/Framework/CommonTree.h b/runtime/ObjC/Framework/CommonTree.h
new file mode 100644
index 0000000..2becb76
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonTree.h
@@ -0,0 +1,92 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRCommonToken.h"
+#import "ANTLRBaseTree.h"
+
+@interface ANTLRCommonTree : ANTLRBaseTree <ANTLRTree> {
+	__strong ANTLRCommonToken *token;
+	NSInteger startIndex;
+	NSInteger stopIndex;
+    __strong ANTLRCommonTree *parent;
+    NSInteger childIndex;
+}
+
++ (ANTLRCommonTree *) invalidNode;
++ (ANTLRCommonTree *) newTree;
++ (ANTLRCommonTree *) newTreeWithTree:(ANTLRCommonTree *)aTree;
++ (ANTLRCommonTree *) newTreeWithToken:(ANTLRCommonToken *)aToken;
++ (ANTLRCommonTree *) newTreeWithTokenType:(NSInteger)tokenType;
++ (ANTLRCommonTree *) newTreeWithTokenType:(NSInteger)aTType Text:(NSString *)theText;
+
+- (id) init;
+- (id) initWithTreeNode:(ANTLRCommonTree *)aNode;
+- (id) initWithToken:(ANTLRCommonToken *)aToken;
+- (id) initWithTokenType:(NSInteger)aTokenType;
+- (id) initWithTokenType:(NSInteger)aTokenType Text:(NSString *)theText;
+
+- (id<ANTLRBaseTree>) copyWithZone:(NSZone *)aZone;
+
+- (BOOL) isNil;
+
+- (ANTLRCommonToken *) getToken;
+- (void) setToken:(ANTLRCommonToken *)aToken;
+- (ANTLRCommonToken *) dupNode;
+- (NSInteger)type;
+- (NSString *)text;
+- (NSUInteger)line;
+- (void) setLine:(NSUInteger)aLine;
+- (NSUInteger)charPositionInLine;
+- (void) setCharPositionInLine:(NSUInteger)pos;
+- (ANTLRCommonTree *) getParent;
+- (void) setParent:(ANTLRCommonTree *) t;
+
+#ifdef DONTUSENOMO
+- (NSString *) treeDescription;
+#endif
+- (NSString *) description;
+- (void) setUnknownTokenBoundaries;
+- (NSInteger) getTokenStartIndex;
+- (void) setTokenStartIndex: (NSInteger) aStartIndex;
+- (NSInteger) getTokenStopIndex;
+- (void) setTokenStopIndex: (NSInteger) aStopIndex;
+
+/*
+ @property (retain, getter=getANTLRCommonToken, setter=setANTLRCommonToken:) ANTLRCommonToken *token;
+ @property (assign, getter=getTokenStartIndex, setter=setTokenStartIndex:) NSInteger startIndex;
+ @property (assign, getter=getTokenStopIndex, setter=setTokenStopIndex:) NSInteger stopIndex;
+ @property (retain, getter=getParent, setter=setParent:) id<ANTLRBaseTree> parentparent;
+ @property (assign, getter=getChildIndex, setter=setChildIndex:) NSInteger childIndex;
+ */
+
+@property (retain) ANTLRCommonToken *token;
+@property (assign) NSInteger startIndex;
+@property (assign) NSInteger stopIndex;
+@property (retain) ANTLRCommonTree *parent;
+@property (assign) NSInteger childIndex;
+
+@end
diff --git a/runtime/ObjC/Framework/CommonTree.m b/runtime/ObjC/Framework/CommonTree.m
new file mode 100644
index 0000000..68c1fc1
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonTree.m
@@ -0,0 +1,345 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRCommonTree.h"
+
+
+@implementation ANTLRCommonTree
+
++ (ANTLRCommonTree *)INVALID_NODE
+{
+	return [[ANTLRCommonTree alloc] initWithToken:[ANTLRCommonToken invalidToken]];
+}
+
++ (ANTLRCommonTree *)invalidNode
+{
+    // Had to cast to ANTLRCommonTree * here, because GCC is dumb.
+	return [[ANTLRCommonTree alloc] initWithToken:ANTLRCommonToken.INVALID_TOKEN];
+}
+
++ (ANTLRCommonTree *)newTree
+{
+    return [[ANTLRCommonTree alloc] init];
+}
+
++ (ANTLRCommonTree *)newTreeWithTree:(ANTLRCommonTree *)aTree
+{
+    return [[ANTLRCommonTree alloc] initWithTreeNode:aTree];
+}
+
++ (ANTLRCommonTree *)newTreeWithToken:(id<ANTLRToken>)aToken
+{
+	return [[ANTLRCommonTree alloc] initWithToken:aToken];
+}
+
++ (ANTLRCommonTree *)newTreeWithTokenType:(NSInteger)aTType
+{
+	return [[ANTLRCommonTree alloc] initWithTokenType:(NSInteger)aTType];
+}
+
++ (ANTLRCommonTree *)newTreeWithTokenType:(NSInteger)aTType Text:(NSString *)theText
+{
+	return [[ANTLRCommonTree alloc] initWithTokenType:(NSInteger)aTType Text:theText];
+}
+
+- (id)init
+{
+	self = (ANTLRCommonTree *)[super init];
+	if ( self != nil ) {
+        token = nil;
+		startIndex = -1;
+		stopIndex = -1;
+        parent = nil;
+        childIndex = -1;
+	}
+	return (ANTLRCommonTree *)self;
+}
+
+- (id)initWithTreeNode:(ANTLRCommonTree *)aNode
+{
+	self = (ANTLRCommonTree *)[super init];
+	if ( self != nil ) {
+		token = aNode.token;
+        if ( token ) [token retain];
+		startIndex = aNode.startIndex;
+		stopIndex = aNode.stopIndex;
+        parent = nil;
+        childIndex = -1;
+	}
+	return self;
+}
+
+- (id)initWithToken:(id<ANTLRToken>)aToken
+{
+	self = (ANTLRCommonTree *)[super init];
+	if ( self != nil ) {
+		token = aToken;
+        if ( token ) [token retain];
+		startIndex = -1;
+		stopIndex = -1;
+        parent = nil;
+        childIndex = -1;
+	}
+	return self;
+}
+
+- (id)initWithTokenType:(NSInteger)aTokenType
+{
+	self = (ANTLRCommonTree *)[super init];
+	if ( self != nil ) {
+		token = [[ANTLRCommonToken newToken:aTokenType] retain];
+//		startIndex = token.startIndex;
+		startIndex = -1;
+//		stopIndex = token.stopIndex;
+		stopIndex = -1;
+        parent = nil;
+        childIndex = -1;
+	}
+	return self;
+}
+
+- (id) initWithTokenType:(NSInteger)aTokenType Text:(NSString *)theText
+{
+	self = (ANTLRCommonTree *)[super init];
+	if ( self != nil ) {
+		token = [[ANTLRCommonToken newToken:aTokenType Text:theText] retain];
+//		startIndex = token.startIndex;
+		startIndex = -1;
+//		stopIndex = token.stopIndex;
+		stopIndex = -1;
+        parent = nil;
+        childIndex = -1;
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+    if ( token ) {
+        [token release];
+        token = nil;
+    }
+    if ( parent ) {
+        [parent release];
+        parent = nil;
+    }
+	[super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRCommonTree *copy;
+
+    //    copy = [[[self class] allocWithZone:aZone] init];
+    copy = [super copyWithZone:aZone]; // allocation occurs in ANTLRBaseTree
+    if ( self.token )
+        copy.token = [self.token copyWithZone:aZone];
+    copy.startIndex = startIndex;
+    copy.stopIndex = stopIndex;
+    copy.parent = (ANTLRCommonTree *)[self.parent copyWithZone:aZone];
+    copy.childIndex = childIndex;
+    return copy;
+}
+
+- (BOOL) isNil
+{
+	return token == nil;
+}
+
+- (ANTLRCommonToken *) getToken
+{
+	return token;
+}
+
+- (void) setToken:(ANTLRCommonToken *) aToken
+{
+	if ( token != aToken ) {
+		if ( token ) [token release];
+		[aToken retain];
+		token = aToken;
+	}
+}
+
+- (ANTLRCommonTree *) dupNode
+{
+    return [ANTLRCommonTree newTreeWithTree:self ];
+}
+
+- (NSInteger)type
+{
+	if (token)
+		return token.type;
+	return ANTLRTokenTypeInvalid;
+}
+
+- (NSString *)text
+{
+	if (token)
+		return token.text;
+	return nil;
+}
+
+- (NSUInteger)line
+{
+	if (token)
+		return token.line;
+	return 0;
+}
+
+- (void) setLine:(NSUInteger)aLine
+{
+    if (token)
+        token.line = aLine;
+}
+
+- (NSUInteger)charPositionInLine
+{
+	if (token)
+		return token.charPositionInLine;
+	return 0;
+}
+
+- (void) setCharPositionInLine:(NSUInteger)pos
+{
+    if (token)
+        token.charPositionInLine = pos;
+}
+
+- (NSInteger) getTokenStartIndex
+{
+	if ( startIndex == -1 && token != nil ) {
+		return [token getTokenIndex];
+	}
+    return startIndex;
+}
+
+- (void) setTokenStartIndex: (NSInteger) aStartIndex
+{
+    startIndex = aStartIndex;
+}
+
+- (NSInteger) getTokenStopIndex
+{
+	if ( stopIndex == -1 && token != nil ) {
+		return [token getTokenIndex];
+	}
+    return stopIndex;
+}
+
+- (void) setTokenStopIndex: (NSInteger) aStopIndex
+{
+    stopIndex = aStopIndex;
+}
+
+#ifdef DONTUSENOMO
+- (NSString *) treeDescription
+{
+	if (children) {
+		NSMutableString *desc = [NSMutableString stringWithString:@"(^"];
+		[desc appendString:[self description]];
+		unsigned int childIdx;
+		for (childIdx = 0; childIdx < [children count]; childIdx++) {
+			[desc appendFormat:@"%@", [[children objectAtIndex:childIdx] treeDescription]];
+		}
+		[desc appendString:@")"];
+		return desc;
+	} else {
+		return [self description];
+	}
+}
+#endif
+
+/** For every node in this subtree, make sure it's start/stop token's
+ *  are set.  Walk depth first, visit bottom up.  Only updates nodes
+ *  with at least one token index < 0.
+ */
+- (void) setUnknownTokenBoundaries
+{
+    if ( children == nil ) {
+        if ( startIndex<0 || stopIndex<0 ) {
+            startIndex = stopIndex = [token getTokenIndex];
+        }
+        return;
+    }
+    for (NSUInteger i=0; i < [children count]; i++) {
+        [[children objectAtIndex:i] setUnknownTokenBoundaries];
+    }
+    if ( startIndex >= 0 && stopIndex >= 0 )
+         return; // already set
+    if ( [children count] > 0 ) {
+        ANTLRCommonTree *firstChild = (ANTLRCommonTree *)[children objectAtIndex:0];
+        ANTLRCommonTree *lastChild = (ANTLRCommonTree *)[children objectAtIndex:[children count]-1];
+        startIndex = [firstChild getTokenStartIndex];
+        stopIndex = [lastChild getTokenStopIndex];
+    }
+}
+
+- (NSInteger) getChildIndex
+{
+    return childIndex;
+}
+
+- (ANTLRCommonTree *) getParent
+{
+    return parent;
+}
+
+- (void) setParent:(ANTLRCommonTree *) t
+{
+    parent = t;
+}
+
+- (void) setChildIndex:(NSInteger) anIndex
+{
+    childIndex = anIndex;
+}
+
+- (NSString *) description
+{
+    return [self toString];
+}
+
+- (NSString *) toString
+{
+    if ( [self isNil] ) {
+        return @"nil";
+    }
+    if ( [self type] == ANTLRTokenTypeInvalid ) {
+        return @"<errornode>";
+    }
+    if ( token==nil ) {
+        return nil;
+    }
+    return token.text;
+}
+
+@synthesize token;
+@synthesize startIndex;
+@synthesize stopIndex;
+@synthesize parent;
+@synthesize childIndex;
+
+@end
diff --git a/runtime/ObjC/Framework/CommonTreeAdaptor.h b/runtime/ObjC/Framework/CommonTreeAdaptor.h
new file mode 100644
index 0000000..e79f0ab
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonTreeAdaptor.h
@@ -0,0 +1,65 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTree.h"
+#import "ANTLRCommonToken.h"
+#import "ANTLRCommonTree.h"
+#import "ANTLRBaseTreeAdaptor.h"
+
+@interface ANTLRCommonTreeAdaptor : ANTLRBaseTreeAdaptor {
+}
+
++ (ANTLRCommonTree *) newEmptyTree;
++ (ANTLRCommonTreeAdaptor *)newTreeAdaptor;
+- (id) init;
+- (ANTLRCommonTree *)dupNode:(ANTLRCommonTree *)t;
+
+- (ANTLRCommonTree *) create:(id<ANTLRToken>) payload;
+//- (ANTLRCommonTree *) createTree:(NSInteger)tokenType fromToken:(ANTLRCommonToken *)aToken;
+//- (ANTLRCommonTree *) createTree:(NSInteger)tokenType fromToken:(ANTLRCommonToken *)aToken Text:(NSString *)text;
+- (id<ANTLRToken>)createToken:(NSInteger)tokenType Text:(NSString *)text;
+- (id<ANTLRToken>)createToken:(id<ANTLRToken>)fromToken;
+- (void) setTokenBoundaries:(ANTLRCommonTree *)t From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
+- (NSInteger)getTokenStartIndex:(ANTLRCommonTree *)t;
+- (NSInteger)getTokenStopIndex:(ANTLRCommonTree *)t;
+- (NSString *)getText:(ANTLRCommonTree *)t;
+- (void)setText:(ANTLRCommonTree *)t Text:(NSString *)text;
+- (NSInteger)getType:(ANTLRCommonTree *)t;
+- (void) setType:(ANTLRCommonTree *)t Type:(NSInteger)tokenType;
+- (id<ANTLRToken>)getToken:(ANTLRCommonTree *)t;
+- (ANTLRCommonTree *)getChild:(ANTLRCommonTree *)t At:(NSInteger)i;
+- (void) setChild:(ANTLRCommonTree *)t At:(NSInteger)i Child:(ANTLRCommonTree *)child;
+- (NSInteger)getChildCount:(ANTLRCommonTree *)t;
+- (ANTLRCommonTree *)getParent:(ANTLRCommonTree *)t;
+- (void)setParent:(ANTLRCommonTree *)t With:(ANTLRCommonTree *)parent;
+- (NSInteger)getChildIndex:(ANTLRCommonTree *)t;
+- (void)setChildIndex:(ANTLRCommonTree *)t With:(NSInteger)index;
+- (void)replaceChildren:(ANTLRCommonTree *)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(ANTLRCommonTree *)t;
+- (id)copyWithZone:(NSZone *)zone;
+
+@end
diff --git a/runtime/ObjC/Framework/CommonTreeAdaptor.m b/runtime/ObjC/Framework/CommonTreeAdaptor.m
new file mode 100644
index 0000000..7609698
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonTreeAdaptor.m
@@ -0,0 +1,240 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRCommonTreeAdaptor.h"
+
+@implementation ANTLRCommonTreeAdaptor
+
++ (ANTLRCommonTree *) newEmptyTree;
+{
+    return [ANTLRCommonTree newTree];
+}
+
++ (ANTLRCommonTreeAdaptor *)newTreeAdaptor
+{
+    return[[ANTLRCommonTreeAdaptor alloc] init];
+}
+
+- (id) init
+{
+    self = [super init];
+    if (self) {
+    }
+    return self;
+}
+
+/** Duplicate a node.  This is part of the factory;
+ *	override if you want another kind of node to be built.
+ *
+ *  I could use reflection to prevent having to override this
+ *  but reflection is slow.
+ */
+- (id) dupNode:(id<ANTLRBaseTree>)t
+{
+    if ( t==nil )
+        return nil;
+    return [ANTLRCommonTree newTree:t];
+}
+
+/** Tell me how to create a token for use with imaginary token nodes.
+ *  For example, there is probably no input symbol associated with imaginary
+ *  token DECL, but you need to create it as a payload or whatever for
+ *  the DECL node as in ^(DECL type ID).
+ *
+ *  This is a variant of createToken where the new token is derived from
+ *  an actual real input token.  Typically this is for converting '{'
+ *  tokens to BLOCK etc...  You'll see
+ *
+ *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
+ *
+ *  If you care what the token payload objects' type is, you should
+ *  override this method and any other createToken variant.
+ */
+- (ANTLRCommonTree *) create:(ANTLRCommonToken *)aToken
+{
+    return [ANTLRCommonTree newTreeWithToken:aToken];
+}
+
+/** Tell me how to create a token for use with imaginary token nodes.
+ *  For example, there is probably no input symbol associated with imaginary
+ *  token DECL, but you need to create it as a payload or whatever for
+ *  the DECL node as in ^(DECL type ID).
+ *
+ *  If you care what the token payload objects' type is, you should
+ *  override this method and any other createToken variant.
+ */
+- (ANTLRCommonTree *)createTree:(NSInteger)tokenType Text:(NSString *)text
+{
+    return [ANTLRCommonTree newTreeWithTokenType:tokenType Text:text];
+}
+
+- (id<ANTLRToken>)createToken:(NSInteger)tokenType Text:(NSString *)text
+{
+    id<ANTLRToken> fromToken = [ANTLRCommonToken newToken:tokenType Text:text];
+    return fromToken;
+}
+
+- (id<ANTLRToken>)createToken:(id<ANTLRToken>)fromToken
+{
+    return [ANTLRCommonToken newTokenWithToken:(ANTLRCommonToken *)fromToken];
+}
+
+/** Track start/stop token for subtree root created for a rule.
+ *  Only works with Tree nodes.  For rules that match nothing,
+ *  seems like this will yield start=i and stop=i-1 in a nil node.
+ *  Might be useful info so I'll not force to be i..i.
+ */
+- (void) setTokenBoundaries:(id<ANTLRBaseTree>)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken
+{
+    if ( aTree == nil )
+        return;
+    int startTokIdx = 0;
+    int stopTokIdx = 0;
+    if ( startToken != nil )
+        startTokIdx = [startToken getTokenIndex];
+    if ( stopToken != nil )
+        stopTokIdx = [stopToken getTokenIndex];
+    [(id<ANTLRBaseTree>)aTree setTokenStartIndex:startTokIdx];
+    [(id<ANTLRBaseTree>)aTree setTokenStopIndex:stopTokIdx];
+}
+
+- (NSInteger)getTokenStartIndex:(id<ANTLRBaseTree>) t
+{
+    if ( t == nil )
+        return -1;
+    return [(id<ANTLRBaseTree>)t getTokenStartIndex];
+}
+
+- (NSInteger)getTokenStopIndex:(id<ANTLRBaseTree>) t
+{
+    if ( t == nil )
+        return -1;
+    return [(id<ANTLRBaseTree>)t getTokenStopIndex];
+}
+
+- (NSString *)getText:(ANTLRCommonTree *)t
+{
+    if ( t == nil )
+        return nil;
+    return t.token.text;
+}
+
+- (void)setText:(id<ANTLRBaseTree>)t Text:(NSString *)text
+{
+    if ( t == nil )
+        return;
+}
+
+- (NSInteger)getType:(ANTLRCommonTree *)t
+{
+    if ( t==nil )
+        return ANTLRTokenTypeInvalid;
+    return t.token.type;
+}
+
+- (void) setType:(id<ANTLRBaseTree>)t Type:(NSInteger)tokenType
+{
+    if ( t==nil )
+        return;
+}
+
+/** What is the Token associated with this node?  If
+ *  you are not using ANTLRCommonTree, then you must
+ *  override this in your own adaptor.
+ */
+- (id<ANTLRToken>) getToken:(ANTLRCommonTree *) t
+{
+    if ( [t isKindOfClass:[ANTLRCommonTree class]] ) {
+        return t.token;
+    }
+    return nil; // no idea what to do
+}
+
+- (id<ANTLRBaseTree>) getChild:(id<ANTLRBaseTree>)t At:(NSInteger)i
+{
+    if ( t == nil )
+        return nil;
+    return [(id<ANTLRBaseTree>)t getChild:i];
+}
+
+- (void) setChild:(id<ANTLRBaseTree>)t At:(NSInteger)i Child:(id<ANTLRBaseTree>)child
+{
+    if ( t == nil )
+        return;
+    [(id<ANTLRBaseTree>)t setChild:i With:child];
+}
+
+- (id) deleteChild:(id<ANTLRBaseTree>)t Index:(NSInteger)anIndex
+{
+    return [t deleteChild:anIndex];
+}
+
+- (NSInteger) getChildCount:(id<ANTLRBaseTree>) t
+{
+    if ( t == nil )
+        return 0;
+    return [(id<ANTLRBaseTree>) t getChildCount];
+}
+
+- (id<ANTLRBaseTree>) getParent:(id<ANTLRBaseTree>) t
+{
+    if ( t == nil )
+        return nil;
+    return (id<ANTLRBaseTree>)[t getParent];
+}
+
+- (void) setParent:(id<ANTLRBaseTree>)t With:(id<ANTLRBaseTree>) parent
+{
+    if ( t != nil )
+        [(id<ANTLRBaseTree>) t setParent:(id<ANTLRBaseTree>)parent];
+}
+
+- (NSInteger) getChildIndex:(id<ANTLRBaseTree>) t
+{
+    if ( t == nil )
+        return 0;
+    return [(id<ANTLRBaseTree>) t getChildIndex];
+}
+
+- (void) setChildIndex:(id<ANTLRBaseTree>)t With:(NSInteger)anIndex
+{
+    if ( t!=nil )
+        [(id<ANTLRBaseTree>)t setChildIndex:anIndex];
+}
+
+- (void) replaceChildren:(id<ANTLRBaseTree>)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id<ANTLRBaseTree>)t
+{
+    if ( parent != nil ) {
+        [(id<ANTLRBaseTree>)parent replaceChildrenFrom:startChildIndex To:stopChildIndex With:t];
+    }
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    return [[[self class] allocWithZone:aZone] init];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/CommonTreeNodeStream.h b/runtime/ObjC/Framework/CommonTreeNodeStream.h
new file mode 100644
index 0000000..52efc0f
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonTreeNodeStream.h
@@ -0,0 +1,120 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRCommonTree.h"
+#import "ANTLRCommonTreeNodeStream.h"
+#import "ANTLRLookaheadStream.h"
+#import "ANTLRTreeNodeStream.h"
+#import "ANTLRTreeIterator.h"
+#import "ANTLRIntArray.h"
+
+@interface ANTLRCommonTreeNodeStream : ANTLRLookaheadStream <ANTLRTreeNodeStream> {
+#define DEFAULT_INITIAL_BUFFER_SIZE 100
+#define INITIAL_CALL_STACK_SIZE 10
+
+/** Pull nodes from which tree? */
+__strong id root;
+
+/** If this tree (root) was created from a token stream, track it. */
+__strong id <ANTLRTokenStream> tokens;
+
+	/** What tree adaptor was used to build these trees */
+__strong ANTLRCommonTreeAdaptor *adaptor;
+
+/** The tree iterator we using */
+__strong ANTLRTreeIterator *it;
+
+/** Stack of indexes used for push/pop calls */
+__strong ANTLRIntArray *calls;
+
+/** Tree (nil A B C) trees like flat A B C streams */
+BOOL hasNilRoot;
+
+/** Tracks tree depth.  Level=0 means we're at root node level. */
+NSInteger level;
+}
+@property (retain, getter=getRoot, setter=setRoot:) ANTLRCommonTree *root;
+@property (retain, getter=getTokens,setter=setTokens:) id<ANTLRTokenStream> tokens;
+@property (retain, getter=getTreeAdaptor, setter=setTreeAdaptor:) ANTLRCommonTreeAdaptor *adaptor;
+@property (assign, getter=getLevel, setter=setLevel:) NSInteger level;
+
++ (ANTLRCommonTreeNodeStream *) newANTLRCommonTreeNodeStream:(ANTLRCommonTree *)theTree;
++ (ANTLRCommonTreeNodeStream *) newANTLRCommonTreeNodeStream:(id<ANTLRTreeAdaptor>)anAdaptor Tree:(ANTLRCommonTree *)theTree;
+
+- (id) initWithTree:(ANTLRCommonTree *)theTree;
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)adaptor Tree:(ANTLRCommonTree *)theTree;
+
+- (void) reset;
+
+    /** Pull elements from tree iterator.  Track tree level 0..max_level.
+     *  If nil rooted tree, don't give initial nil and DOWN nor final UP.
+     */
+- (id) nextElement;
+
+- (BOOL) isEOF:(id<ANTLRBaseTree>) obj;
+- (void) setUniqueNavigationNodes:(BOOL) uniqueNavigationNodes;
+
+- (id) getTreeSource;
+
+- (NSString *) getSourceName;
+
+- (id<ANTLRTokenStream>) getTokenStream;
+
+- (void) setTokenStream:(id<ANTLRTokenStream>) tokens;
+
+- (ANTLRCommonTreeAdaptor *) getTreeAdaptor;
+
+- (void) setTreeAdaptor:(ANTLRCommonTreeAdaptor *) adaptor;
+
+- (NSInteger) LA:(NSInteger) i;
+
+    /** Make stream jump to a new location, saving old location.
+     *  Switch back with pop().
+     */
+- (ANTLRCommonTree *)getNode:(NSInteger) i;
+
+- (void) push:(NSInteger) index;
+
+    /** Seek back to previous index saved during last push() call.
+     *  Return top of stack (return index).
+     */
+- (NSInteger) pop;
+
+// TREE REWRITE INTERFACE
+
+- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
+
+- (NSString *) toStringFromNode:(id<ANTLRBaseTree>)startNode ToNode:(id<ANTLRBaseTree>)stopNode;
+
+/** For debugging; destructive: moves tree iterator to end. */
+- (NSString *) toTokenTypeString;
+
+@property (retain) ANTLRTreeIterator *it;
+@property (retain) ANTLRIntArray *calls;
+@property BOOL hasNilRoot;
+@end
diff --git a/runtime/ObjC/Framework/CommonTreeNodeStream.m b/runtime/ObjC/Framework/CommonTreeNodeStream.m
new file mode 100644
index 0000000..23eddee
--- /dev/null
+++ b/runtime/ObjC/Framework/CommonTreeNodeStream.m
@@ -0,0 +1,249 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRCommonTreeNodeStream.h"
+#import "ANTLRTokenStream.h"
+#import "ANTLRIntStream.h"
+#import "ANTLRCharStream.h"
+#import "AMutableArray.h"
+#import "ANTLRCommonTreeAdaptor.h"
+
+#ifndef DEBUG_DEALLOC
+#define DEBUG_DEALLOC
+#endif
+
+@implementation ANTLRCommonTreeNodeStream
+
+@synthesize root;
+@synthesize tokens;
+@synthesize adaptor;
+@synthesize level;
+
++ (ANTLRCommonTreeNodeStream *) newANTLRCommonTreeNodeStream:(ANTLRCommonTree *)theTree
+{
+    return [[ANTLRCommonTreeNodeStream alloc] initWithTree:theTree];
+}
+
++ (ANTLRCommonTreeNodeStream *) newANTLRCommonTreeNodeStream:(id<ANTLRTreeAdaptor>)anAdaptor Tree:(ANTLRCommonTree *)theTree
+{
+    return [[ANTLRCommonTreeNodeStream alloc] initWithTreeAdaptor:anAdaptor Tree:theTree];
+}
+
+- (id) initWithTree:(ANTLRCommonTree *)theTree
+{
+    if ((self = [super init]) != nil ) {
+        adaptor = [[ANTLRCommonTreeAdaptor newTreeAdaptor] retain];
+        root = [theTree retain];
+        navigationNodeEOF = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain]; // set EOF
+        it = [[ANTLRTreeIterator newANTRLTreeIteratorWithAdaptor:adaptor andTree:root] retain];
+        calls = [[ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE] retain];
+        /** Tree (nil A B C) trees like flat A B C streams */
+        hasNilRoot = NO;
+        level = 0;
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor Tree:(ANTLRCommonTree *)theTree
+{
+    if ((self = [super init]) != nil ) {
+        adaptor = [anAdaptor retain];
+        root = [theTree retain];
+        navigationNodeEOF = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain]; // set EOF
+        //    it = [root objectEnumerator];
+        it = [[ANTLRTreeIterator newANTRLTreeIteratorWithAdaptor:adaptor andTree:root] retain];
+        calls = [[ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE] retain];
+        /** Tree (nil A B C) trees like flat A B C streams */
+        hasNilRoot = NO;
+        level = 0;
+    }
+    //    eof = [self isEOF]; // make sure tree iterator returns the EOF we want
+    return self;
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRCommonTreeNodeStream" );
+#endif
+    if ( root ) [root release];
+    if ( tokens ) [tokens release];
+    if ( adaptor ) [adaptor release];
+    if ( it ) [it release];
+    if ( calls ) [calls release];
+    [super dealloc];
+}
+
+- (void) reset
+{
+    [super reset];
+    [it reset];
+    hasNilRoot = false;
+    level = 0;
+    if ( calls != nil )
+        [calls reset];  // [calls clear]; // in Java
+}
+
+/** Pull elements from tree iterator.  Track tree level 0..max_level.
+ *  If nil rooted tree, don't give initial nil and DOWN nor final UP.
+ */
+- (id) nextElement
+{
+    id t = [it nextObject];
+    //System.out.println("pulled "+adaptor.getType(t));
+    if ( t == [it up] ) {
+        level--;
+        if ( level==0 && hasNilRoot ) return [it nextObject]; // don't give last UP; get EOF
+    }
+    else if ( t == [it down] )
+        level++;
+    if ( level == 0 && [adaptor isNil:t] ) { // if nil root, scarf nil, DOWN
+        hasNilRoot = true;
+        t = [it nextObject]; // t is now DOWN, so get first real node next
+        level++;
+        t = [it nextObject];
+    }
+    return t;
+}
+
+- (BOOL) isEOF:(id<ANTLRBaseTree>) aTree
+{
+    return [adaptor getType:(ANTLRCommonTree *)aTree] == ANTLRTokenTypeEOF;
+}
+
+- (void) setUniqueNavigationNodes:(BOOL) uniqueNavigationNodes
+{
+}
+
+- (id) getTreeSource
+{
+    return root;
+}
+
+- (NSString *) getSourceName
+{
+    return [[self getTokenStream] getSourceName];
+}
+
+- (id<ANTLRTokenStream>) getTokenStream
+{
+    return tokens;
+}
+
+- (void) setTokenStream:(id<ANTLRTokenStream>)theTokens
+{
+    if ( tokens != theTokens ) {
+        if ( tokens ) [tokens release];
+        [theTokens retain];
+    }
+    tokens = theTokens;
+}
+
+- (ANTLRCommonTreeAdaptor *) getTreeAdaptor
+{
+    return adaptor;
+}
+
+- (void) setTreeAdaptor:(ANTLRCommonTreeAdaptor *) anAdaptor
+{
+    if ( adaptor != anAdaptor ) {
+        if ( adaptor ) [adaptor release];
+        [anAdaptor retain];
+    }
+    adaptor = anAdaptor;
+}
+
+- (ANTLRCommonTree *)getNode:(NSInteger) i
+{
+    @throw [ANTLRRuntimeException newException:@"Absolute node indexes are meaningless in an unbuffered stream"];
+    return nil;
+}
+
+- (NSInteger) LA:(NSInteger) i
+{
+    return [adaptor getType:[self LT:i]];
+}
+
+/** Make stream jump to a new location, saving old location.
+ *  Switch back with pop().
+ */
+- (void) push:(NSInteger) anIndex
+{
+    if ( calls == nil ) {
+        calls = [[ANTLRIntArray newArrayWithLen:INITIAL_CALL_STACK_SIZE] retain];
+    }
+    [calls push:p]; // save current anIndex
+    [self seek:anIndex];
+}
+
+/** Seek back to previous anIndex saved during last push() call.
+ *  Return top of stack (return anIndex).
+ */
+- (NSInteger) pop
+{
+    int ret = [calls pop];
+    [self seek:ret];
+    return ret;
+}
+
+// TREE REWRITE INTERFACE
+
+- (void) replaceChildren:(id) parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) aTree
+{
+    if ( parent != nil ) {
+        [adaptor replaceChildren:parent From:startChildIndex To:stopChildIndex With:aTree];
+    }
+}
+
+- (NSString *) toStringFromNode:(id<ANTLRBaseTree>)startNode ToNode:(id<ANTLRBaseTree>)stopNode
+{
+    // we'll have to walk from start to stop in tree; we're not keeping
+    // a complete node stream buffer
+    return @"n/a";
+}
+
+/** For debugging; destructive: moves tree iterator to end. */
+- (NSString *) toTokenTypeString
+{
+    [self reset];
+    NSMutableString *buf = [NSMutableString stringWithCapacity:5];
+    id obj = [self LT:1];
+    NSInteger type = [adaptor getType:obj];
+    while ( type != ANTLRTokenTypeEOF ) {
+        [buf appendString:@" "];
+        [buf appendString:[NSString stringWithFormat:@"%d", type]];
+        [self consume];
+        obj = [self LT:1];
+        type = [adaptor getType:obj];
+    }
+    return buf;
+}
+
+@synthesize it;
+@synthesize calls;
+@synthesize hasNilRoot;
+@end
+
diff --git a/runtime/ObjC/Framework/DFA.h b/runtime/ObjC/Framework/DFA.h
new file mode 100644
index 0000000..9adedb1
--- /dev/null
+++ b/runtime/ObjC/Framework/DFA.h
@@ -0,0 +1,82 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseRecognizer.h"
+#import "ANTLRCharStream.h"
+#import "ANTLRNoViableAltException.h"
+
+@interface ANTLRDFA : NSObject {
+	// the tables are set by subclasses to their own static versions.
+	const int *eot;
+	const int *eof;
+	const unichar *min;
+	const unichar *max;
+	const int *accept;
+	const int *special;
+	const int **transition;
+
+	__strong ANTLRBaseRecognizer *recognizer;
+	NSInteger decisionNumber;
+    NSInteger len;
+}
+
+- (id) initWithRecognizer:(id) theRecognizer;
+// simulate the DFA using the static tables and predict an alternative
+- (NSInteger) predict:(id<ANTLRCharStream>)anInput;
+- (void) noViableAlt:(NSInteger)state Stream:(id<ANTLRIntStream>)anInput;
+
+- (NSInteger) specialStateTransition:(NSInteger)state Stream:(id<ANTLRIntStream>)anInput;
+// - (NSInteger) specialStateTransition:(NSInteger) state;
+//- (unichar) specialTransition:(unichar) state symbol:(NSInteger) symbol;
+
+// hook for debugger support
+- (void) error:(ANTLRNoViableAltException *)nvae;
+
+- (NSString *) description;
+- (BOOL) evaluateSyntacticPredicate:(SEL)synpredFragment;
+
++ (void) setIsEmittingDebugInfo:(BOOL) shouldEmitDebugInfo;
+
+- (NSInteger)getDecision;
+- (void)setDecision:(NSInteger)aDecison;
+
+- (ANTLRBaseRecognizer *)getRecognizer;
+- (void)setRecognizer:(ANTLRBaseRecognizer *)aRecognizer;
+- (NSInteger)length;
+
+@property const int *eot;
+@property const int *eof;
+@property const unichar *min;
+@property const unichar *max;
+@property const int *accept;
+@property const int *special;
+@property const int **transition;
+
+@property (retain, getter=getRecognizer,setter=setRecognizer:) ANTLRBaseRecognizer *recognizer;
+@property (assign, getter=getDecision,setter=setDecision:) NSInteger decisionNumber;
+@property (assign, getter=getLen,setter=setLen:) NSInteger len;
+@end
diff --git a/runtime/ObjC/Framework/DFA.m b/runtime/ObjC/Framework/DFA.m
new file mode 100644
index 0000000..b42daf5
--- /dev/null
+++ b/runtime/ObjC/Framework/DFA.m
@@ -0,0 +1,262 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRDFA.h"
+#import <ANTLRToken.h>
+#import <ANTLRNoViableAltException.h>
+
+NSInteger debug = 0;
+
+@implementation ANTLRDFA
+@synthesize recognizer;
+@synthesize decisionNumber;
+@synthesize len;
+
+- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
+{
+	if ((self = [super init]) != nil) {
+		recognizer = theRecognizer;
+        [recognizer retain];
+        debug = 0;
+	}
+	return self;
+}
+
+// using the tables ANTLR generates for the DFA based prediction this method simulates the DFA
+// and returns the prediction of the alternative to be used.
+- (NSInteger) predict:(id<ANTLRIntStream>)input
+{
+    if ( debug > 2 ) {
+        NSLog(@"Enter DFA.predict for decision %d", decisionNumber);
+    }
+	int aMark = [input mark];
+	int s = 0;
+	@try {
+		while (YES) {
+			if ( debug > 2 )
+                NSLog(@"DFA %d state %d LA(1)='%c'(%x)", decisionNumber, s, (unichar)[input LA:1], [input LA:1]);
+			NSInteger specialState = special[s];
+			if (specialState >= 0) {
+				// this state is special in that it has some code associated with it. we cannot do this in a pure DFA so
+				// we signal the caller accordingly.
+				if ( debug > 2 ) {
+                    NSLog(@"DFA %d state %d is special state %d", decisionNumber, s, specialState);
+                }
+				s = [self specialStateTransition:specialState Stream:input];
+                if ( debug > 2 ) {
+                    NSLog(@"DFA %d returns from special state %d to %d", decisionNumber, specialState, s);
+                }
+                if (s == -1 ) {
+                    [self noViableAlt:s Stream:input];
+                    return 0;
+                }
+				[input consume];
+				continue;
+			}
+			if (accept[s] >= 1) {  // if this is an accepting state return the prediction
+				if ( debug > 2 ) NSLog(@"accept; predict %d from state %d", accept[s], s);
+				return accept[s];
+			}
+			// based on the lookahead lookup the next transition, consume and do transition
+			// or signal that we have no viable alternative
+			int c = [input LA:1];
+			if ( (unichar)c >= min[s] && (unichar)c <= max[s]) {
+				int snext = transition[s][c-min[s]];
+				if (snext < 0) {
+                    // was in range but not a normal transition
+                    // must check EOT, which is like the else clause.
+                    // eot[s]>=0 indicates that an EOT edge goes to another
+                    // state.
+					if (eot[s] >= 0) {
+						if ( debug > 2 ) NSLog(@"EOT transition");
+						s = eot[s];
+						[input consume];
+                        // TODO: I had this as return accept[eot[s]]
+                        // which assumed here that the EOT edge always
+                        // went to an accept...faster to do this, but
+                        // what about predicated edges coming from EOT
+                        // target?
+						continue;
+					}
+					[self noViableAlt:s Stream:input];
+					return 0;
+				}
+				s = snext;
+				[input consume];
+				continue;
+			}
+
+			if (eot[s] >= 0) {// EOT transition? we may still accept the input in the next state
+				if ( debug > 2 ) NSLog(@"EOT transition");
+				s = eot[s];
+				[input consume];
+				continue;
+			}
+			if ( c == ANTLRTokenTypeEOF && eof[s] >= 0) {  // we are at EOF and may even accept the input.
+				if ( debug > 2 ) NSLog(@"accept via EOF; predict %d from %d", accept[eof[s]], eof[s]);
+				return accept[eof[s]];
+			}
+			if ( debug > 2 ) {
+                NSLog(@"no viable alt!\n");
+                NSLog(@"min[%d] = %d\n", s, min[s]);
+                NSLog(@"max[%d] = %d\n", s, min[s]);
+                NSLog(@"eot[%d] = %d\n", s, min[s]);
+                NSLog(@"eof[%d] = %d\n", s, min[s]);
+                for (NSInteger p = 0; p < self.len; p++) {
+                    NSLog(@"%d ", transition[s][p]);
+                }
+                NSLog(@"\n");
+            }
+			[self noViableAlt:s Stream:input];
+            return 0;
+		}
+	}
+	@finally {
+		[input rewind:aMark];
+	}
+	return 0; // silence warning
+}
+
+- (void) noViableAlt:(NSInteger)state Stream:(id<ANTLRIntStream>)anInput
+{
+	if ([recognizer.state isBacktracking]) {
+		[recognizer.state setFailed:YES];
+		return;
+	}
+	ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:decisionNumber state:state stream:anInput];
+	[self error:nvae];
+	@throw nvae;
+}
+
+- (NSInteger) specialStateTransition:(NSInteger)state Stream:(id<ANTLRIntStream>)anInput
+{
+    @throw [ANTLRNoViableAltException newException:-1 state:state stream:anInput];
+	return -1;
+}
+
+- (void) error:(ANTLRNoViableAltException *)nvae
+{
+	// empty, hook for debugger support
+}
+
+- (NSString *) description
+{
+	return @"subclass responsibility";
+}
+
+- (BOOL) evaluateSyntacticPredicate:(SEL)synpredFragment
+{
+	return [recognizer evaluateSyntacticPredicate:synpredFragment];
+}
+
++ (void) setIsEmittingDebugInfo:(BOOL) shouldEmitDebugInfo
+{
+	debug = shouldEmitDebugInfo;
+}
+
+/** Given a String that has a run-length-encoding of some unsigned shorts
+ *  like "\1\2\3\9", convert to short[] {2,9,9,9}.  We do this to avoid
+ *  static short[] which generates so much init code that the class won't
+ *  compile. :(
+ */
+- (short *) unpackEncodedString:(NSString *)encodedString
+{
+    // walk first to find how big it is.
+    int size = 0;
+    for (int i=0; i < [encodedString length]; i+=2) {
+        size += [encodedString characterAtIndex:i];
+    }
+    __strong short *data = (short *)calloc(size, sizeof(short));
+    int di = 0;
+    for (int i=0; i < [encodedString length]; i+=2) {
+        char n = [encodedString characterAtIndex:i];
+        char v = [encodedString characterAtIndex:i+1];
+        // add v n times to data
+        for (int j = 0; j < n; j++) {
+            data[di++] = v;
+        }
+    }
+    return data;
+}
+
+/** Hideous duplication of code, but I need different typed arrays out :( */
+- (char *) unpackEncodedStringToUnsignedChars:(NSString *)encodedString
+{
+    // walk first to find how big it is.
+    int size = 0;
+    for (int i=0; i < [encodedString length]; i+=2) {
+        size += [encodedString characterAtIndex:i];
+    }
+    __strong short *data = (short *)calloc(size, sizeof(short));
+    int di = 0;
+    for (int i=0; i < [encodedString length]; i+=2) {
+        char n = [encodedString characterAtIndex:i];
+        char v = [encodedString characterAtIndex:i+1];
+        // add v n times to data
+        for (int j = 0; j < n; j++) {
+            data[di++] = v;
+        }
+    }
+    return (char *)data;
+}
+
+- (NSInteger)getDecision
+{
+    return decisionNumber;
+}
+
+- (void)setDecision:(NSInteger)aDecison
+{
+    decisionNumber = aDecison;
+}
+
+- (ANTLRBaseRecognizer *)getRecognizer
+{
+    return recognizer;
+}
+
+- (void)setRecognizer:(ANTLRBaseRecognizer *)aRecognizer
+{
+    if ( recognizer != aRecognizer ) {
+        if ( recognizer ) [recognizer release];
+        [aRecognizer retain];
+    }
+    recognizer = aRecognizer;
+}
+
+- (NSInteger)length
+{
+    return len;
+}
+
+@synthesize eot;
+@synthesize eof;
+@synthesize min;
+@synthesize max;
+@synthesize accept;
+@synthesize special;
+@synthesize transition;
+@end
diff --git a/runtime/ObjC/Framework/Debug.h b/runtime/ObjC/Framework/Debug.h
new file mode 100644
index 0000000..87383c9
--- /dev/null
+++ b/runtime/ObjC/Framework/Debug.h
@@ -0,0 +1,33 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRDebugEventListener.h"
+#import "ANTLRDebugEventProxy.h"
+#import "ANTLRDebugParser.h"
+#import "ANTLRDebugTokenStream.h"
+#import "ANTLRDebugTreeParser.h"
+#import "ANTLRDebugTreeNodeStream.h"
+#import "ANTLRDebugTreeAdaptor.h"
diff --git a/runtime/ObjC/Framework/DebugEventListener.h b/runtime/ObjC/Framework/DebugEventListener.h
new file mode 100644
index 0000000..c2bee6c
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugEventListener.h
@@ -0,0 +1,275 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRToken.h"
+#import "ANTLRRecognitionException.h"
+
+@protocol ANTLRDebugEventListener
+
+#define ANTLRDebugProtocolVersion 1
+
+/** The parser has just entered a rule.  No decision has been made about
+*  which alt is predicted.  This is fired AFTER init actions have been
+*  executed.  Attributes are defined and available etc...
+*/
+- (void) enterRule:(NSString *)ruleName;
+
+/** Because rules can have lots of alternatives, it is very useful to
+*  know which alt you are entering.  This is 1..n for n alts.
+*/
+- (void) enterAlt:(NSInteger)alt;
+
+/** This is the last thing executed before leaving a rule.  It is
+*  executed even if an exception is thrown.  This is triggered after
+*  error reporting and recovery have occurred (unless the exception is
+											   *  not caught in this rule).  This implies an "exitAlt" event.
+*/
+- (void) exitRule:(NSString *)ruleName;
+
+/** Track entry into any (...) subrule other EBNF construct */
+- (void) enterSubRule:(NSInteger)decisionNumber;
+
+- (void) exitSubRule:(NSInteger)decisionNumber;
+
+/** Every decision, fixed k or arbitrary, has an enter/exit event
+*  so that a GUI can easily track what LT/consume events are
+*  associated with prediction.  You will see a single enter/exit
+*  subrule but multiple enter/exit decision events, one for each
+*  loop iteration.
+*/
+- (void) enterDecision:(NSInteger)decisionNumber;
+
+- (void) exitDecision:(NSInteger)decisionNumber;
+
+/** An input token was consumed; matched by any kind of element.
+*  Trigger after the token was matched by things like match(), matchAny().
+*/
+- (void) consumeToken:(id<ANTLRToken>)t;
+
+/** An off-channel input token was consumed.
+*  Trigger after the token was matched by things like match(), matchAny().
+*  (unless of course the hidden token is first stuff in the input stream).
+*/
+- (void) consumeHiddenToken:(id<ANTLRToken>)t;
+
+/** Somebody (anybody) looked ahead.  Note that this actually gets
+*  triggered by both LA and LT calls.  The debugger will want to know
+*  which Token object was examined.  Like consumeToken, this indicates
+*  what token was seen at that depth.  A remote debugger cannot look
+*  ahead into a file it doesn't have so LT events must pass the token
+*  even if the info is redundant.
+*/
+- (void) LT:(NSInteger)i foundToken:(id<ANTLRToken>)t;
+
+/** The parser is going to look arbitrarily ahead; mark this location,
+*  the token stream's marker is sent in case you need it.
+*/
+- (void) mark:(NSInteger)marker;
+
+/** After an arbitrairly long lookahead as with a cyclic DFA (or with
+*  any backtrack), this informs the debugger that stream should be
+*  rewound to the position associated with marker.
+*/
+- (void) rewind:(NSInteger)marker;
+
+/** Rewind to the input position of the last marker.
+*  Used currently only after a cyclic DFA and just
+*  before starting a sem/syn predicate to get the
+*  input position back to the start of the decision.
+*  Do not "pop" the marker off the state.  mark(i)
+*  and rewind(i) should balance still.
+*/
+- (void) rewind;
+
+- (void) beginBacktrack:(NSInteger)level;
+
+- (void) endBacktrack:(NSInteger)level wasSuccessful:(BOOL)successful;
+
+/** To watch a parser move through the grammar, the parser needs to
+*  inform the debugger what line/charPos it is passing in the grammar.
+*  For now, this does not know how to switch from one grammar to the
+*  other and back for island grammars etc...
+*
+*  This should also allow breakpoints because the debugger can stop
+*  the parser whenever it hits this line/pos.
+*/
+- (void) locationLine:(NSInteger)line column:(NSInteger)pos;
+
+/** A recognition exception occurred such as NoViableAltException.  I made
+*  this a generic event so that I can alter the exception hierachy later
+*  without having to alter all the debug objects.
+*
+*  Upon error, the stack of enter rule/subrule must be properly unwound.
+*  If no viable alt occurs it is within an enter/exit decision, which
+*  also must be rewound.  Even the rewind for each mark must be unwount.
+*  In the Java target this is pretty easy using try/finally, if a bit
+*  ugly in the generated code.  The rewind is generated in DFA.predict()
+*  actually so no code needs to be generated for that.  For languages
+*  w/o this "finally" feature (C++?), the target implementor will have
+*  to build an event stack or something.
+*
+*  Across a socket for remote debugging, only the RecognitionException
+*  data fields are transmitted.  The token object or whatever that
+*  caused the problem was the last object referenced by LT.  The
+*  immediately preceding LT event should hold the unexpected Token or
+*  char.
+*
+*  Here is a sample event trace for grammar:
+*
+*  b : C ({;}A|B) // {;} is there to prevent A|B becoming a set
+*    | D
+*    ;
+*
+*  The sequence for this rule (with no viable alt in the subrule) for
+*  input 'c c' (there are 3 tokens) is:
+*
+*		commence
+*		LT(1)
+*		enterRule b
+*		location 7 1
+*		enter decision 3
+*		LT(1)
+*		exit decision 3
+*		enterAlt1
+*		location 7 5
+*		LT(1)
+*		consumeToken [c/<4>,1:0]
+*		location 7 7
+*		enterSubRule 2
+*		enter decision 2
+*		LT(1)
+*		LT(1)
+*		recognitionException NoViableAltException 2 1 2
+*		exit decision 2
+*		exitSubRule 2
+*		beginResync
+*		LT(1)
+*		consumeToken [c/<4>,1:1]
+*		LT(1)
+*		endResync
+*		LT(-1)
+*		exitRule b
+*		terminate
+*/
+- (void) recognitionException:(ANTLRRecognitionException *)e;
+
+/** Indicates the recognizer is about to consume tokens to resynchronize
+*  the parser.  Any consume events from here until the recovered event
+*  are not part of the parse--they are dead tokens.
+*/
+- (void) beginResync;
+
+/** Indicates that the recognizer has finished consuming tokens in order
+*  to resychronize.  There may be multiple beginResync/endResync pairs
+*  before the recognizer comes out of errorRecovery mode (in which
+*  multiple errors are suppressed).  This will be useful
+*  in a gui where you want to probably grey out tokens that are consumed
+*  but not matched to anything in grammar.  Anything between
+*  a beginResync/endResync pair was tossed out by the parser.
+*/
+- (void) endResync;
+
+/** A semantic predicate was evaluate with this result and action text */
+- (void) semanticPredicate:(NSString *)predicate matched:(BOOL)result;
+
+/** Announce that parsing has begun.  Not technically useful except for
+*  sending events over a socket.  A GUI for example will launch a thread
+*  to connect and communicate with a remote parser.  The thread will want
+*  to notify the GUI when a connection is made.  ANTLR parsers
+*  trigger this upon entry to the first rule (the ruleLevel is used to
+*  figure this out).
+*/
+- (void) commence;
+
+/** Parsing is over; successfully or not.  Mostly useful for telling
+*  remote debugging listeners that it's time to quit.  When the rule
+*  invocation level goes to zero at the end of a rule, we are done
+*  parsing.
+*/
+- (void) terminate;
+
+
+// T r e e  P a r s i n g
+
+/** Input for a tree parser is an AST, but we know nothing for sure
+*  about a node except its type and text (obtained from the adaptor).
+*  This is the analog of the consumeToken method.  Again, the ID is
+*  the hashCode usually of the node so it only works if hashCode is
+*  not implemented.  If the type is UP or DOWN, then
+*  the ID is not really meaningful as it's fixed--there is
+*  just one UP node and one DOWN navigation node.
+*/
+- (void) consumeNode:(NSInteger)nodeHash ofType:(NSInteger)type text:(NSString *)text;
+
+/** The tree parser lookedahead.  If the type is UP or DOWN,
+*  then the ID is not really meaningful as it's fixed--there is
+*  just one UP node and one DOWN navigation node.
+*/
+- (void) LT:(NSInteger)i foundNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text;
+
+
+// A S T  E v e n t s
+
+/** A nil was created (even nil nodes have a unique ID...
+*  they are not "null" per se).  As of 4/28/2006, this
+*  seems to be uniquely triggered when starting a new subtree
+*  such as when entering a subrule in automatic mode and when
+*  building a tree in rewrite mode.
+*/
+- (void) createNilNode:(unsigned)hash;
+
+/** Announce a new node built from text */
+- (void) createNode:(unsigned)hash text:(NSString *)text type:(NSInteger)type;
+
+/** Announce a new node built from an existing token */
+- (void) createNode:(unsigned)hash fromTokenAtIndex:(NSInteger)tokenIndex;
+
+/** Make a node the new root of an existing root.  See
+*
+*  Note: the newRootID parameter is possibly different
+*  than the TreeAdaptor.becomeRoot() newRoot parameter.
+*  In our case, it will always be the result of calling
+*  TreeAdaptor.becomeRoot() and not root_n or whatever.
+*
+*  The listener should assume that this event occurs
+*  only when the current subrule (or rule) subtree is
+*  being reset to newRootID.
+*
+*/
+- (void) makeNode:(unsigned)newRootHash parentOf:(unsigned)oldRootHash;
+
+/** Make childID a child of rootID.
+*  @see org.antlr.runtime.tree.TreeAdaptor.addChild()
+*/
+- (void) addChild:(unsigned)childHash toTree:(unsigned)treeHash;
+
+/** Set the token start/stop token index for a subtree root or node */
+- (void) setTokenBoundariesForTree:(unsigned)nodeHash From:(NSUInteger)tokenStartIndex To:(NSUInteger)tokenStopIndex;
+
+- (void) waitForDebuggerConnection;
+
+@end
diff --git a/runtime/ObjC/Framework/DebugEventSocketProxy.h b/runtime/ObjC/Framework/DebugEventSocketProxy.h
new file mode 100644
index 0000000..af8cd33
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugEventSocketProxy.h
@@ -0,0 +1,112 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRParser.h"
+#import "ANTLRDebugEventListener.h"
+#import <sys/socket.h>
+#import <netinet/in.h>
+#import <netinet/tcp.h>
+#include <arpa/inet.h>
+
+// default port for ANTLRWorks
+#define DEFAULT_DEBUGGER_PORT 49001
+
+@interface ANTLRDebugEventProxy : NSObject <ANTLRDebugEventListener> {
+	int serverSocket;
+
+	struct sockaddr debugger_sockaddr;
+	socklen_t debugger_socklen;
+	int debuggerSocket;
+	NSFileHandle *debuggerFH;
+
+	NSString *grammarName;
+	int debuggerPort;
+}
+
+- (id) init;
+- (id) initWithGrammarName:(NSString *)aGrammarName debuggerPort:(NSInteger)aPort;
+- (void) waitForDebuggerConnection;
+- (void) waitForAck;
+- (void) sendToDebugger:(NSString *)message;
+- (void) sendToDebugger:(NSString *)message waitForResponse:(BOOL)wait;
+
+- (NSInteger) serverSocket;
+- (void) setServerSocket: (NSInteger) aServerSocket;
+
+- (NSInteger) debuggerSocket;
+- (void) setDebuggerSocket: (NSInteger) aDebuggerSocket;
+
+- (NSString *) grammarName;
+- (void) setGrammarName: (NSString *) aGrammarName;
+
+- (NSInteger) debuggerPort;
+- (void) setDebuggerPort: (NSInteger) aDebuggerPort;
+
+- (NSString *) escapeNewlines:(NSString *)aString;
+
+#pragma mark -
+
+#pragma mark DebugEventListener Protocol
+- (void) enterRule:(NSString *)ruleName;
+- (void) enterAlt:(NSInteger)alt;
+- (void) exitRule:(NSString *)ruleName;
+- (void) enterSubRule:(NSInteger)decisionNumber;
+- (void) exitSubRule:(NSInteger)decisionNumber;
+- (void) enterDecision:(NSInteger)decisionNumber;
+- (void) exitDecision:(NSInteger)decisionNumber;
+- (void) consumeToken:(id<ANTLRToken>)t;
+- (void) consumeHiddenToken:(id<ANTLRToken>)t;
+- (void) LT:(NSInteger)i foundToken:(id<ANTLRToken>)t;
+- (void) mark:(NSInteger)marker;
+- (void) rewind:(NSInteger)marker;
+- (void) rewind;
+- (void) beginBacktrack:(NSInteger)level;
+- (void) endBacktrack:(NSInteger)level wasSuccessful:(BOOL)successful;
+- (void) locationLine:(NSInteger)line column:(NSInteger)pos;
+- (void) recognitionException:(ANTLRRecognitionException *)e;
+- (void) beginResync;
+- (void) endResync;
+- (void) semanticPredicate:(NSString *)predicate matched:(BOOL)result;
+- (void) commence;
+- (void) terminate;
+
+
+#pragma mark Tree Parsing
+- (void) consumeNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text;
+- (void) LT:(NSInteger)i foundNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text;
+
+
+#pragma mark AST Events
+
+- (void) createNilNode:(unsigned)hash;
+- (void) createNode:(unsigned)hash text:(NSString *)text type:(NSInteger)type;
+- (void) createNode:(unsigned)hash fromTokenAtIndex:(NSInteger)tokenIndex;
+- (void) makeNode:(unsigned)newRootHash parentOf:(unsigned)oldRootHash;
+- (void) addChild:(unsigned)childHash toTree:(unsigned)treeHash;
+- (void) setTokenBoundariesForTree:(unsigned)nodeHash From:(NSInteger)tokenStartIndex To:(NSInteger)tokenStopIndex;
+
+@end
diff --git a/runtime/ObjC/Framework/DebugEventSocketProxy.m b/runtime/ObjC/Framework/DebugEventSocketProxy.m
new file mode 100644
index 0000000..f68059a
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugEventSocketProxy.m
@@ -0,0 +1,370 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRDebugEventProxy.h"
+#import "ANTLRToken+DebuggerSupport.h"
+#include <string.h>
+
+static NSData *newlineData = nil;
+static unsigned lengthOfUTF8Ack = 0;
+
+@implementation ANTLRDebugEventProxy
+
++ (void) initialize
+{
+	if (!newlineData) newlineData = [@"\n" dataUsingEncoding:NSUTF8StringEncoding];
+	if (!lengthOfUTF8Ack) lengthOfUTF8Ack = [[@"ack\n" dataUsingEncoding:NSUTF8StringEncoding] length];
+}
+
+- (id) init
+{
+	return [self initWithGrammarName:nil debuggerPort:DEFAULT_DEBUGGER_PORT];
+}
+
+- (id) initWithGrammarName:(NSString *)aGrammarName debuggerPort:(NSInteger)aPort
+{
+	self = [super init];
+	if (self) {
+		serverSocket = -1;
+		[self setGrammarName:aGrammarName];
+		if (aPort == -1) aPort = DEFAULT_DEBUGGER_PORT;
+		[self setDebuggerPort:aPort];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+	if (serverSocket != -1)
+		shutdown(serverSocket,SHUT_RDWR);
+	serverSocket = -1;
+	[debuggerFH release];
+    [self setGrammarName:nil];
+    [super dealloc];
+}
+
+- (void) waitForDebuggerConnection
+{
+	if (serverSocket == -1) {
+		serverSocket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
+
+		NSAssert1(serverSocket != -1, @"Failed to create debugger socket. %s", strerror(errno));
+
+		int yes = 1;
+		setsockopt(serverSocket, SOL_SOCKET, SO_KEEPALIVE|SO_REUSEPORT|SO_REUSEADDR|TCP_NODELAY, (void *)&yes, sizeof(NSInteger));
+
+		struct sockaddr_in server_addr;
+		bzero(&server_addr, sizeof(struct sockaddr_in));
+		server_addr.sin_family = AF_INET;
+		server_addr.sin_port = htons([self debuggerPort]);
+		server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
+		NSAssert1( bind(serverSocket, (struct sockaddr *)&server_addr, sizeof(struct sockaddr)) != -1, @"bind(2) failed. %s", strerror(errno));
+
+		NSAssert1(listen(serverSocket,50) == 0, @"listen(2) failed. %s", strerror(errno));
+
+		NSLog(@"ANTLR waiting for debugger attach (grammar %@)", [self grammarName]);
+
+		debuggerSocket = accept(serverSocket, &debugger_sockaddr, &debugger_socklen);
+		NSAssert1( debuggerSocket != -1, @"accept(2) failed. %s", strerror(errno));
+
+		debuggerFH = [[NSFileHandle alloc] initWithFileDescriptor:debuggerSocket];
+		[self sendToDebugger:[NSString stringWithFormat:@"ANTLR %d", ANTLRDebugProtocolVersion] waitForResponse:NO];
+		[self sendToDebugger:[NSString stringWithFormat:@"grammar \"%@", [self grammarName]] waitForResponse:NO];
+	}
+}
+
+- (void) waitForAck
+{
+	NSString *response;
+	@try {
+		NSData *newLine = [debuggerFH readDataOfLength:lengthOfUTF8Ack];
+		response = [[NSString alloc] initWithData:newLine encoding:NSUTF8StringEncoding];
+		if (![response isEqualToString:@"ack\n"]) @throw [NSException exceptionWithName:@"ANTLRDebugEventProxy" reason:@"illegal response from debugger" userInfo:nil];
+	}
+	@catch (NSException *e) {
+		NSLog(@"socket died or debugger misbehaved: %@ read <%@>", e, response);
+	}
+	@finally {
+		[response release];
+	}
+}
+
+- (void) sendToDebugger:(NSString *)message
+{
+	[self sendToDebugger:message waitForResponse:YES];
+}
+
+- (void) sendToDebugger:(NSString *)message waitForResponse:(BOOL)wait
+{
+	if (! debuggerFH ) return;
+	[debuggerFH writeData:[message dataUsingEncoding:NSUTF8StringEncoding]];
+	[debuggerFH writeData:newlineData];
+	if (wait) [self waitForAck];
+}
+
+- (NSInteger) serverSocket
+{
+    return serverSocket;
+}
+
+- (void) setServerSocket: (NSInteger) aServerSocket
+{
+    serverSocket = aServerSocket;
+}
+
+- (NSInteger) debuggerSocket
+{
+    return debuggerSocket;
+}
+
+- (void) setDebuggerSocket: (NSInteger) aDebuggerSocket
+{
+    debuggerSocket = aDebuggerSocket;
+}
+
+- (NSString *) grammarName
+{
+    return grammarName;
+}
+
+- (void) setGrammarName: (NSString *) aGrammarName
+{
+    if (grammarName != aGrammarName) {
+        [aGrammarName retain];
+        [grammarName release];
+        grammarName = aGrammarName;
+    }
+}
+
+- (NSInteger) debuggerPort
+{
+    return debuggerPort;
+}
+
+- (void) setDebuggerPort: (NSInteger) aDebuggerPort
+{
+    debuggerPort = aDebuggerPort;
+}
+
+- (NSString *) escapeNewlines:(NSString *)aString
+{
+	NSMutableString *escapedText;
+	if (aString) {
+		escapedText = [NSMutableString stringWithString:aString];
+		NSRange wholeString = NSMakeRange(0,[escapedText length]);
+		[escapedText replaceOccurrencesOfString:@"%" withString:@"%25" options:0 range:wholeString];
+		[escapedText replaceOccurrencesOfString:@"\n" withString:@"%0A" options:0 range:wholeString];
+		[escapedText replaceOccurrencesOfString:@"\r" withString:@"%0D" options:0 range:wholeString];
+	} else {
+		escapedText = [NSMutableString stringWithString:@""];
+	}
+	return escapedText;
+}
+
+#pragma mark -
+
+#pragma mark DebugEventListener Protocol
+- (void) enterRule:(NSString *)ruleName
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"enterRule %@", ruleName]];
+}
+
+- (void) enterAlt:(NSInteger)alt
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"enterAlt %d", alt]];
+}
+
+- (void) exitRule:(NSString *)ruleName
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"exitRule %@", ruleName]];
+}
+
+- (void) enterSubRule:(NSInteger)decisionNumber
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"enterSubRule %d", decisionNumber]];
+}
+
+- (void) exitSubRule:(NSInteger)decisionNumber
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"exitSubRule %d", decisionNumber]];
+}
+
+- (void) enterDecision:(NSInteger)decisionNumber
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"enterDecision %d", decisionNumber]];
+}
+
+- (void) exitDecision:(NSInteger)decisionNumber
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"exitDecision %d", decisionNumber]];
+}
+
+- (void) consumeToken:(id<ANTLRToken>)t
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"consumeToken %@", [self escapeNewlines:[t description]]]];
+}
+
+- (void) consumeHiddenToken:(id<ANTLRToken>)t
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"consumeHiddenToken %@", [self escapeNewlines:[t description]]]];
+}
+
+- (void) LT:(NSInteger)i foundToken:(id<ANTLRToken>)t
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"LT %d %@", i, [self escapeNewlines:[t description]]]];
+}
+
+- (void) mark:(NSInteger)marker
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"mark %d", marker]];
+}
+- (void) rewind:(NSInteger)marker
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"rewind %d", marker]];
+}
+
+- (void) rewind
+{
+	[self sendToDebugger:@"rewind"];
+}
+
+- (void) beginBacktrack:(NSInteger)level
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"beginBacktrack %d", level]];
+}
+
+- (void) endBacktrack:(NSInteger)level wasSuccessful:(BOOL)successful
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"endBacktrack %d %d", level, successful ? 1 : 0]];
+}
+
+- (void) locationLine:(NSInteger)line column:(NSInteger)pos
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"location %d %d", line, pos]];
+}
+
+- (void) recognitionException:(ANTLRRecognitionException *)e
+{
+#warning TODO: recognition exceptions
+	// these must use the names of the corresponding Java exception classes, because ANTLRWorks recreates the exception
+	// objects on the Java side.
+	// Write categories for Objective-C exceptions to provide those names
+}
+
+- (void) beginResync
+{
+	[self sendToDebugger:@"beginResync"];
+}
+
+- (void) endResync
+{
+	[self sendToDebugger:@"endResync"];
+}
+
+- (void) semanticPredicate:(NSString *)predicate matched:(BOOL)result
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"semanticPredicate %d %@", result?1:0, [self escapeNewlines:predicate]]];
+}
+
+- (void) commence
+{
+	// no need to send event
+}
+
+- (void) terminate
+{
+	[self sendToDebugger:@"terminate"];
+	@try {
+		[debuggerFH closeFile];
+	}
+	@finally {
+#warning TODO: make socket handling robust. too lazy now...
+		shutdown(serverSocket,SHUT_RDWR);
+		serverSocket = -1;
+	}
+}
+
+
+#pragma mark Tree Parsing
+- (void) consumeNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"consumeNode %u %d %@",
+		nodeHash,
+		type,
+		[self escapeNewlines:text]
+		]];
+}
+
+- (void) LT:(NSInteger)i foundNode:(unsigned)nodeHash ofType:(NSInteger)type text:(NSString *)text
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"LN %d %u %d %@",
+		i,
+		nodeHash,
+		type,
+		[self escapeNewlines:text]
+		]];
+}
+
+
+#pragma mark AST Events
+
+- (void) createNilNode:(unsigned)hash
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"nilNode %u", hash]];
+}
+
+- (void) createNode:(unsigned)hash text:(NSString *)text type:(NSInteger)type
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"createNodeFromToken %u %d %@",
+		hash,
+		type,
+		[self escapeNewlines:text]
+		]];
+}
+
+- (void) createNode:(unsigned)hash fromTokenAtIndex:(NSInteger)tokenIndex
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"createNode %u %d", hash, tokenIndex]];
+}
+
+- (void) becomeRoot:(unsigned)newRootHash old:(unsigned)oldRootHash
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"becomeRoot %u %u", newRootHash, oldRootHash]];
+}
+
+- (void) addChild:(unsigned)childHash toTree:(unsigned)treeHash
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"addChild %u %u", treeHash, childHash]];
+}
+
+- (void) setTokenBoundariesForTree:(unsigned)nodeHash From:(NSInteger)tokenStartIndex To:(NSInteger)tokenStopIndex
+{
+	[self sendToDebugger:[NSString stringWithFormat:@"setTokenBoundaries %u %d %d", nodeHash, tokenStartIndex, tokenStopIndex]];
+}
+
+
+
+@end
diff --git a/runtime/ObjC/Framework/DebugParser.h b/runtime/ObjC/Framework/DebugParser.h
new file mode 100644
index 0000000..ed403ef
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugParser.h
@@ -0,0 +1,57 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRParser.h"
+#import "ANTLRDebugEventProxy.h"
+#import "ANTLRDebugTokenStream.h"
+
+@interface ANTLRDebugParser : ANTLRParser {
+	id<ANTLRDebugEventListener> debugListener;
+}
+
++ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
+        debugListener:(id<ANTLRDebugEventListener>)debugListener;
+
++ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
+                state:(ANTLRRecognizerSharedState *)state;
+
++ (id) newDebugParser:(id<ANTLRTokenStream>)theStream
+        debugListener:(id<ANTLRDebugEventListener>)debugListener
+                state:(ANTLRRecognizerSharedState *)state;
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream;
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
+			  debuggerPort:(NSInteger)portNumber;
+// designated initializer
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
+			 debugListener:(id<ANTLRDebugEventListener>)theDebugListener
+			  debuggerPort:(NSInteger)portNumber;
+
+- (id<ANTLRDebugEventListener>) debugListener;
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;
+
+@end
diff --git a/runtime/ObjC/Framework/DebugParser.m b/runtime/ObjC/Framework/DebugParser.m
new file mode 100644
index 0000000..f86a8ba
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugParser.m
@@ -0,0 +1,113 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRDebugParser.h"
+
+
+@implementation ANTLRDebugParser
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
+{
+	return [self initWithTokenStream:theStream debugListener:nil debuggerPort:-1];
+}
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
+			  debuggerPort:(NSInteger)portNumber
+{
+	return [self initWithTokenStream:theStream debugListener:nil debuggerPort:portNumber];
+}
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
+			 debugListener:(id<ANTLRDebugEventListener>)theDebugListener
+			  debuggerPort:(NSInteger)portNumber
+{
+	id<ANTLRDebugEventListener,NSObject> debugger = nil;
+	id<ANTLRTokenStream> tokenStream = nil;
+	if (theDebugListener) {
+		debugger = [(id<ANTLRDebugEventListener,NSObject>)theDebugListener retain];
+		debugger = theDebugListener;
+	} else {
+		debugger = [[ANTLRDebugEventProxy alloc] initWithGrammarName:[self grammarFileName] debuggerPort:portNumber];
+	}
+	if (theStream && ![theStream isKindOfClass:[ANTLRDebugTokenStream class]]) {
+		tokenStream = [[ANTLRDebugTokenStream alloc] initWithTokenStream:theStream debugListener:debugger];
+	} else {
+		tokenStream = [theStream retain];
+		tokenStream = theStream;
+	}
+	self = [super initWithTokenStream:tokenStream];
+	if (self) {
+		[self setDebugListener:debugger];
+		[debugger release];
+		[tokenStream release];
+		[debugListener waitForDebuggerConnection];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+    [self setDebugListener: nil];
+    [super dealloc];
+}
+
+- (id<ANTLRDebugEventListener>) debugListener
+{
+    return debugListener;
+}
+
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
+{
+    if (debugListener != aDebugListener) {
+        [(id<ANTLRDebugEventListener,NSObject>)aDebugListener retain];
+        [(id<ANTLRDebugEventListener,NSObject>)debugListener release];
+        debugListener = aDebugListener;
+    }
+}
+
+#pragma mark -
+#pragma mark Overrides
+
+- (void) beginResync
+{
+	[debugListener beginResync];
+}
+
+- (void) endResync
+{
+	[debugListener endResync];
+}
+- (void)beginBacktracking:(NSInteger)level
+{
+	[debugListener beginBacktrack:level];
+}
+
+- (void)endBacktracking:(NSInteger)level wasSuccessful:(BOOL)successful
+{
+	[debugListener endBacktrack:level wasSuccessful:successful];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/DebugTokenStream.h b/runtime/ObjC/Framework/DebugTokenStream.h
new file mode 100644
index 0000000..9f6c438
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugTokenStream.h
@@ -0,0 +1,62 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRParser.h"
+#import "ANTLRTokenStream.h"
+#import "ANTLRTokenSource.h"
+#import "ANTLRDebugTokenStream.h"
+#import "ANTLRDebugEventListener.h"
+
+@interface ANTLRDebugTokenStream : NSObject <ANTLRTokenStream>
+{
+	id<ANTLRDebugEventListener> debugListener;
+	id<ANTLRTokenStream> input;
+	BOOL initialStreamState;
+    NSInteger lastMarker;
+}
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream debugListener:(id<ANTLRDebugEventListener>)debugger;
+
+- (id<ANTLRDebugEventListener>) debugListener;
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;
+
+- (id<ANTLRTokenStream>) input;
+- (void) setInput:(id<ANTLRTokenStream>)aTokenStream;
+
+- (void) consume;
+- (id<ANTLRToken>) getToken:(NSInteger)index;
+- (NSInteger) getIndex;
+- (void) release:(NSInteger)marker;
+- (void) seek:(NSInteger)index;
+- (NSInteger) size;
+- (id<ANTLRTokenSource>) getTokenSource;
+- (NSString *) getSourceName;
+- (NSString *) toString;
+- (NSString *) toStringFromStart:(NSInteger)aStart ToEnd:(NSInteger)aStop;
+- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken;
+
+@end
diff --git a/runtime/ObjC/Framework/DebugTokenStream.m b/runtime/ObjC/Framework/DebugTokenStream.m
new file mode 100644
index 0000000..8a294c9
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugTokenStream.m
@@ -0,0 +1,204 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRDebugTokenStream.h"
+
+
+@implementation ANTLRDebugTokenStream
+
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream debugListener:(id<ANTLRDebugEventListener>)debugger
+{
+	self = [super init];
+	if (self) {
+		[self setDebugListener:debugger];
+		[self setInput:theStream];
+		[self.input LT:1];	// force reading first on-channel token
+		initialStreamState = YES;
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+    [self setDebugListener:nil];
+    self.input = nil;
+    [super dealloc];
+}
+
+
+- (id<ANTLRDebugEventListener>) debugListener
+{
+    return debugListener;
+}
+
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
+{
+    if (debugListener != aDebugListener) {
+        [(id<ANTLRDebugEventListener,NSObject>)aDebugListener retain];
+        [(id<ANTLRDebugEventListener,NSObject>)debugListener release];
+        debugListener = aDebugListener;
+    }
+}
+
+- (id<ANTLRTokenStream>) input
+{
+    return input;
+}
+
+- (void) setInput: (id<ANTLRTokenStream>) aTokenStream
+{
+    if (input != aTokenStream) {
+        if ( input ) [input release];
+        input = aTokenStream;
+        [input retain];
+    }
+}
+
+- (void) consumeInitialHiddenTokens
+{
+	int firstIdx = input.index;
+	for (int i = 0; i<firstIdx; i++)
+		[debugListener consumeHiddenToken:[input getToken:i]];
+	initialStreamState = NO;
+}
+
+#pragma mark -
+#pragma mark Proxy implementation
+
+// anything else that hasn't some debugger event assicioated with it, is simply
+// forwarded to the actual token stream
+- (void) forwardInvocation:(NSInvocation *)anInvocation
+{
+	[anInvocation invokeWithTarget:self.input];
+}
+
+- (void) consume
+{
+	if ( initialStreamState )
+		[self consumeInitialHiddenTokens];
+	int a = input.index;
+	id<ANTLRToken> token = [input LT:1];
+	[input consume];
+	int b = input.index;
+	[debugListener consumeToken:token];
+	if (b > a+1) // must have consumed hidden tokens
+		for (int i = a+1; i < b; i++)
+			[debugListener consumeHiddenToken:[input getToken:i]];
+}
+
+- (NSInteger) mark
+{
+	lastMarker = [input mark];
+	[debugListener mark:lastMarker];
+	return lastMarker;
+}
+
+- (void) rewind
+{
+	[debugListener rewind];
+	[input rewind];
+}
+
+- (void) rewind:(NSInteger)marker
+{
+	[debugListener rewind:marker];
+	[input rewind:marker];
+}
+
+- (id<ANTLRToken>) LT:(NSInteger)k
+{
+	if ( initialStreamState )
+		[self consumeInitialHiddenTokens];
+	[debugListener LT:k foundToken:[input LT:k]];
+	return [input LT:k];
+}
+
+- (NSInteger) LA:(NSInteger)k
+{
+	if ( initialStreamState )
+		[self consumeInitialHiddenTokens];
+	[debugListener LT:k foundToken:[input LT:k]];
+	return [input LA:k];
+}
+
+- (id<ANTLRToken>) getToken:(NSInteger)i
+{
+    return [input getToken:i];
+}
+
+- (NSInteger) getIndex
+{
+    return input.index;
+}
+
+- (void) release:(NSInteger) marker
+{
+}
+
+- (void) seek:(NSInteger)index
+{
+    // TODO: implement seek in dbg interface
+    // db.seek(index);
+    [input seek:index];
+}
+
+- (NSInteger) size
+{
+    return [input size];
+}
+
+- (id<ANTLRTokenSource>) getTokenSource
+{
+    return [input getTokenSource];
+}
+
+- (NSString *) getSourceName
+{
+    return [[input getTokenSource] getSourceName];
+}
+
+- (NSString *) description
+{
+    return [input toString];
+}
+
+- (NSString *) toString
+{
+    return [input toString];
+}
+
+- (NSString *) toStringFromStart:(NSInteger)startIndex ToEnd:(NSInteger)stopIndex
+{
+    return [input toStringFromStart:startIndex ToEnd:stopIndex];
+}
+
+- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken
+{
+    return [input toStringFromStart:[startToken getStart] ToEnd:[stopToken getStopToken]];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/DebugTreeAdaptor.h b/runtime/ObjC/Framework/DebugTreeAdaptor.h
new file mode 100644
index 0000000..f8dd07e
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugTreeAdaptor.h
@@ -0,0 +1,45 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRParser.h"
+#import "ANTLRCommonTreeAdaptor.h"
+#import "ANTLRDebugEventListener.h"
+
+@interface ANTLRDebugTreeAdaptor : ANTLRBaseTreeAdaptor {
+	id<ANTLRDebugEventListener> debugListener;
+	ANTLRCommonTreeAdaptor *treeAdaptor;
+}
+
+- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)aTreeAdaptor debugListener:(id<ANTLRDebugEventListener>)aDebugListener;
+
+- (id<ANTLRDebugEventListener>)debugListener;
+- (void) setDebugListener:(id<ANTLRDebugEventListener>)aDebugListener;
+
+- (ANTLRCommonTreeAdaptor *) getTreeAdaptor;
+- (void) setTreeAdaptor:(ANTLRCommonTreeAdaptor *)aTreeAdaptor;
+
+@end
diff --git a/runtime/ObjC/Framework/DebugTreeAdaptor.m b/runtime/ObjC/Framework/DebugTreeAdaptor.m
new file mode 100644
index 0000000..01c4c6e
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugTreeAdaptor.m
@@ -0,0 +1,229 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRDebugTreeAdaptor.h"
+
+
+@implementation ANTLRDebugTreeAdaptor
+
+
+- (id) initWithTreeAdaptor:(ANTLRCommonTreeAdaptor *)aTreeAdaptor debugListener:(id<ANTLRDebugEventListener>)aDebugListener
+{
+	self = [super init];
+	if (self) {
+		[self setDebugListener:aDebugListener];
+		[self setTreeAdaptor:aTreeAdaptor];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+    [self setDebugListener: nil];
+    [self setTreeAdaptor: nil];
+    [super dealloc];
+}
+
+- (id<ANTLRDebugEventListener>) debugListener
+{
+    return debugListener;
+}
+
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
+{
+    if (debugListener != aDebugListener) {
+        [(id<ANTLRTreeAdaptor,NSObject>)aDebugListener retain];
+        [(id<ANTLRTreeAdaptor,NSObject>)debugListener release];
+        debugListener = aDebugListener;
+    }
+}
+
+- (ANTLRCommonTreeAdaptor *) getTreeAdaptor
+{
+    return treeAdaptor;
+}
+
+- (void) setTreeAdaptor: (ANTLRCommonTreeAdaptor *) aTreeAdaptor
+{
+    if (treeAdaptor != aTreeAdaptor) {
+        [aTreeAdaptor retain];
+        [treeAdaptor release];
+        treeAdaptor = aTreeAdaptor;
+    }
+}
+
+#pragma mark -
+#pragma mark Proxy implementation
+
+// anything else that hasn't some debugger event assicioated with it, is simply
+// forwarded to the actual token stream
+- (void) forwardInvocation:(NSInvocation *)anInvocation
+{
+	[anInvocation invokeWithTarget:[self getTreeAdaptor]];
+}
+
+#pragma mark -
+
+#pragma mark Construction
+
+- (id<ANTLRBaseTree>) newANTLRTreeWithToken:(id<ANTLRToken>) payload
+{
+	id<ANTLRBaseTree> newTree = [ANTLRCommonTree newTreeWithToken:payload];
+	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] fromTokenAtIndex:[payload getTokenIndex]];
+	return newTree;
+}
+
+- (id<ANTLRBaseTree>) emptyTree
+{
+	id<ANTLRBaseTree> newTree = [treeAdaptor newEmptyTree];
+	[debugListener createNilNode:[treeAdaptor uniqueIdForTree:newTree]];
+	return newTree;
+}
+
+/*	We don't have debug events for those:
+ - (id) copyNode:(id<ANTLRBaseTree>)aNode
+{
+}
+- (id) copyTree:(id<ANTLRBaseTree>)aTree
+{
+}
+*/
+
+- (void) addChild:(id<ANTLRBaseTree>)child toTree:(id<ANTLRBaseTree>)aTree
+{
+	[treeAdaptor addChild:child toTree:aTree];
+	[debugListener addChild:[treeAdaptor uniqueIdForTree:child] toTree:[self uniqueIdForTree:aTree]];
+}
+
+- (id<ANTLRBaseTree>) becomeRoot:(id<ANTLRBaseTree>)newRoot old:(id<ANTLRBaseTree>)oldRoot
+{
+	id<ANTLRBaseTree> newTree = [treeAdaptor becomeRoot:newRoot old:oldRoot];
+	[debugListener becomeRoot:[treeAdaptor uniqueIdForTree:newTree] old:[self uniqueIdForTree:oldRoot]];
+	return newTree;
+}
+
+/* handle by forwardInvocation:
+- (NSUInteger) uniqueIdForTree:(id<ANTLRBaseTree>)aNode
+{
+}
+*/
+
+#pragma mark Rewrite Rules
+
+ - (void) addTokenAsChild:(id<ANTLRToken>)child toTree:(id<ANTLRBaseTree>)aTree
+{
+	id<ANTLRBaseTree> newChild = [self newANTLRTreeWithToken:child];
+	[self addChild:newChild toTree:aTree];
+}
+
+- (id<ANTLRBaseTree>) makeToken:(id<ANTLRToken>)newRoot parentOf:(id<ANTLRBaseTree>)oldRoot
+{
+	id<ANTLRBaseTree> newNode = [self newANTLRTreeWithToken:newRoot];
+	return [self becomeRoot:newNode old:oldRoot];
+}
+
+- (id<ANTLRBaseTree>) newANTLRTreeWithTokenType:(NSInteger)tokenType
+{
+	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithTokenType:tokenType];
+	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:nil type:tokenType];
+	return newTree;
+}
+
+- (id<ANTLRBaseTree>) newANTLRTreeWithTokenType:(NSInteger)tokenType text:(NSString *)tokenText
+{
+	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithTokenType:tokenType text:tokenText];
+	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:tokenText type:tokenType];
+	return newTree;
+}
+- (id<ANTLRBaseTree>) newANTLRTreeWithToken:(id<ANTLRToken>)fromToken tokenType:(NSInteger)tokenType
+{
+	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithToken:fromToken tokenType:tokenType];
+	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:fromToken.text type:tokenType];
+	return newTree;
+}
+
+- (id<ANTLRBaseTree>) newANTLRTreeWithToken:(id<ANTLRToken>)fromToken tokenType:(NSInteger)tokenType text:(NSString *)tokenText
+{
+	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithToken:fromToken tokenType:tokenType text:tokenText];
+	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:tokenText type:tokenType];
+	return newTree;
+}
+
+- (id<ANTLRBaseTree>) newANTLRTreeWithToken:(id<ANTLRToken>)fromToken text:(NSString *)tokenText
+{
+	id<ANTLRBaseTree> newTree = [treeAdaptor newANTLRTreeWithToken:fromToken text:tokenText];
+	[debugListener createNode:[treeAdaptor uniqueIdForTree:newTree] text:tokenText type:fromToken.type];
+	return newTree;
+}
+
+#pragma mark Content
+
+/* handled by forwardInvocation:
+- (NSInteger) tokenTypeForNode:(id<ANTLRBaseTree>)aNode
+{
+}
+
+- (void) setTokenType:(NSInteger)tokenType forNode:(id)aNode
+{
+}
+
+- (NSString *) textForNode:(id<ANTLRBaseTree>)aNode
+{
+}
+
+- (void) setText:(NSString *)tokenText forNode:(id<ANTLRBaseTree>)aNode
+{
+}
+*/
+- (void) setBoundariesForTree:(id<ANTLRBaseTree>)aTree fromToken:(id<ANTLRToken>)startToken toToken:(id<ANTLRToken>)stopToken
+{
+	[treeAdaptor setBoundariesForTree:aTree fromToken:startToken toToken:stopToken];
+	if (aTree && startToken && stopToken) {
+		[debugListener setTokenBoundariesForTree:[aTree hash] From:[startToken getTokenIndex] To:[stopToken getTokenIndex]];
+	}
+}
+/* handled by forwardInvocation:
+- (NSInteger) tokenStartIndexForTree:(id<ANTLRBaseTree>)aTree
+{
+}
+
+- (NSInteger) tokenStopIndexForTree:(id<ANTLRBaseTree>)aTree
+{
+}
+*/
+
+#pragma mark Navigation / Tree Parsing
+/* handled by forwardInvocation:
+- (id<ANTLRBaseTree>) childForNode:(id<ANTLRBaseTree>) aNode atIndex:(NSInteger) i
+{
+}
+
+- (NSInteger) childCountForTree:(id<ANTLRBaseTree>) aTree
+{
+}
+*/
+
+@end
diff --git a/runtime/ObjC/Framework/DebugTreeNodeStream.h b/runtime/ObjC/Framework/DebugTreeNodeStream.h
new file mode 100644
index 0000000..733f6fd
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugTreeNodeStream.h
@@ -0,0 +1,67 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRDebugEventListener.h"
+#import "ANTLRTreeAdaptor.h"
+#import "ANTLRTreeNodeStream.h"
+
+@interface ANTLRDebugTreeNodeStream : NSObject <ANTLRTreeNodeStream> {
+	id<ANTLRDebugEventListener> debugListener;
+	id<ANTLRTreeAdaptor> treeAdaptor;
+	id<ANTLRTreeNodeStream> input;
+	BOOL initialStreamState;
+}
+
+- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream debugListener:(id<ANTLRDebugEventListener>)debugger;
+
+- (id<ANTLRDebugEventListener>) debugListener;
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;
+
+- (id<ANTLRTreeNodeStream>) input;
+- (void) setInput: (id<ANTLRTreeNodeStream>) aTreeNodeStream;
+
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
+- (void) setTreeAdaptor: (id<ANTLRTreeAdaptor>) aTreeAdaptor;
+
+#pragma mark ANTLRTreeNodeStream conformance
+
+- (id) LT:(NSInteger)k;
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
+- (void) setUniqueNavigationNodes:(BOOL)flag;
+
+#pragma mark ANTLRIntStream conformance
+- (void) consume;
+- (NSInteger) LA:(NSUInteger) i;
+- (NSUInteger) mark;
+- (NSUInteger) getIndex;
+- (void) rewind:(NSUInteger) marker;
+- (void) rewind;
+- (void) release:(NSUInteger) marker;
+- (void) seek:(NSUInteger) index;
+- (NSUInteger) size;
+
+@end
diff --git a/runtime/ObjC/Framework/DebugTreeNodeStream.m b/runtime/ObjC/Framework/DebugTreeNodeStream.m
new file mode 100644
index 0000000..37f55de
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugTreeNodeStream.m
@@ -0,0 +1,175 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRDebugTreeNodeStream.h"
+
+
+@implementation ANTLRDebugTreeNodeStream
+
+- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream debugListener:(id<ANTLRDebugEventListener>)debugger
+{
+	self = [super init];
+	if (self) {
+		[self setDebugListener:debugger];
+		[self setTreeAdaptor:[theStream treeAdaptor]];
+		[self setInput:theStream];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+    [self setDebugListener: nil];
+    [self setTreeAdaptor: nil];
+    input = nil;
+    [super dealloc];
+}
+
+- (id<ANTLRDebugEventListener>) debugListener
+{
+    return debugListener;
+}
+
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
+{
+    if (debugListener != aDebugListener) {
+        [(id<ANTLRDebugEventListener,NSObject>)aDebugListener retain];
+        [(id<ANTLRDebugEventListener,NSObject>)debugListener release];
+        debugListener = aDebugListener;
+    }
+}
+
+
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor
+{
+    return treeAdaptor;
+}
+
+- (void) setTreeAdaptor: (id<ANTLRTreeAdaptor>) aTreeAdaptor
+{
+    if (treeAdaptor != aTreeAdaptor) {
+        [(id<ANTLRTreeAdaptor,NSObject>)aTreeAdaptor retain];
+        [(id<ANTLRTreeAdaptor,NSObject>)treeAdaptor release];
+        treeAdaptor = aTreeAdaptor;
+    }
+}
+
+
+- (id<ANTLRTreeNodeStream>) input
+{
+    return input;
+}
+
+- (void) setInput:(id<ANTLRTreeNodeStream>) aTreeNodeStream
+{
+    if (input != aTreeNodeStream) {
+        [input release];
+        [(id<ANTLRTreeNodeStream,NSObject>)aTreeNodeStream retain];
+    }
+    input = aTreeNodeStream;
+}
+
+
+#pragma mark ANTLRTreeNodeStream conformance
+
+- (id) LT:(NSInteger)k
+{
+	id node = [input LT:k];
+	unsigned hash = [treeAdaptor uniqueIdForTree:node];
+	NSString *text = [treeAdaptor textForNode:node];
+	int type = [treeAdaptor tokenTypeForNode:node];
+	[debugListener LT:k foundNode:hash ofType:type text:text];
+	return node;
+}
+
+- (void) setUniqueNavigationNodes:(BOOL)flag
+{
+	[input setUniqueNavigationNodes:flag];
+}
+
+#pragma mark ANTLRIntStream conformance
+- (void) consume
+{
+	id node = [input LT:1];
+	[input consume];
+	unsigned hash = [treeAdaptor uniqueIdForTree:node];
+	NSString *theText = [treeAdaptor textForNode:node];
+	int aType = [treeAdaptor tokenTypeForNode:node];
+	[debugListener consumeNode:hash ofType:aType text:theText];
+}
+
+- (NSInteger) LA:(NSUInteger) i
+{
+	id<ANTLRBaseTree> node = [self LT:1];
+	return node.type;
+}
+
+- (NSUInteger) mark
+{
+	unsigned lastMarker = [input mark];
+	[debugListener mark:lastMarker];
+	return lastMarker;
+}
+
+- (NSUInteger) getIndex
+{
+	return input.index;
+}
+
+- (void) rewind:(NSUInteger) marker
+{
+	[input rewind:marker];
+	[debugListener rewind:marker];
+}
+
+- (void) rewind
+{
+	[input rewind];
+	[debugListener rewind];
+}
+
+- (void) release:(NSUInteger) marker
+{
+	[input release:marker];
+}
+
+- (void) seek:(NSUInteger) index
+{
+	[input seek:index];
+	// todo: seek missing in debug protocol
+}
+
+- (NSUInteger) size
+{
+	return [input size];
+}
+
+- (NSString *) toStringFromToken:(id)startNode ToToken:(id)stopNode
+{
+    return [input toStringFromToken:(id<ANTLRToken>)startNode ToToken:(id<ANTLRToken>)stopNode];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/DebugTreeParser.h b/runtime/ObjC/Framework/DebugTreeParser.h
new file mode 100644
index 0000000..171c1e7
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugTreeParser.h
@@ -0,0 +1,52 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTreeParser.h"
+#import "ANTLRDebugEventProxy.h"
+#import "ANTLRDebugTreeNodeStream.h"
+
+@interface ANTLRDebugTreeParser : ANTLRTreeParser {
+	id<ANTLRDebugEventListener> debugListener;
+}
+
+- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream;
+- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
+				 debuggerPort:(NSInteger)portNumber;
+	// designated initializer
+- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
+				debugListener:(id<ANTLRDebugEventListener>)theDebugListener
+				 debuggerPort:(NSInteger)portNumber;
+
+- (id<ANTLRDebugEventListener>) debugListener;
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener;
+
+- (void) recoverFromMismatchedToken:(id<ANTLRIntStream>)inputStream
+						  exception:(NSException *)e
+						  tokenType:(ANTLRTokenType)ttype
+							 follow:(ANTLRBitSet *)follow;
+
+@end
diff --git a/runtime/ObjC/Framework/DebugTreeParser.m b/runtime/ObjC/Framework/DebugTreeParser.m
new file mode 100644
index 0000000..5692993
--- /dev/null
+++ b/runtime/ObjC/Framework/DebugTreeParser.m
@@ -0,0 +1,128 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRDebugTreeParser.h"
+
+
+@implementation ANTLRDebugTreeParser
+
+- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
+{
+	return [self initWithTreeNodeStream:theStream debugListener:nil debuggerPort:-1];
+}
+
+- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
+				 debuggerPort:(NSInteger)portNumber
+{
+	return [self initWithTreeNodeStream:theStream debugListener:nil debuggerPort:portNumber];
+}
+
+- (id) initWithTreeNodeStream:(id<ANTLRTreeNodeStream>)theStream
+				debugListener:(id<ANTLRDebugEventListener>)theDebugListener
+				 debuggerPort:(NSInteger)portNumber
+{
+	id<ANTLRDebugEventListener,NSObject> debugger = nil;
+	id<ANTLRTreeNodeStream> treeNodeStream = nil;
+	if (theDebugListener) {
+		debugger = (id<ANTLRDebugEventListener>)theDebugListener;
+	} else {
+		debugger = [[ANTLRDebugEventProxy alloc] initWithGrammarName:[self grammarFileName] debuggerPort:portNumber];
+	}
+	if (theStream && ![theStream isKindOfClass:[ANTLRDebugTreeNodeStream class]]) {
+		treeNodeStream = [[ANTLRDebugTreeNodeStream alloc] initWithTreeNodeStream:theStream debugListener:debugger];
+	} else {
+		treeNodeStream = theStream;
+	}
+	self = [super initWithStream:treeNodeStream];
+	if ( self ) {
+		[self setDebugListener:debugger];
+		//[debugger release];
+		//[treeNodeStream release];
+		[debugListener waitForDebuggerConnection];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+    [self setDebugListener: nil];
+    [super dealloc];
+}
+
+- (id<ANTLRDebugEventListener>) debugListener
+{
+    return debugListener;
+}
+
+- (void) setDebugListener: (id<ANTLRDebugEventListener>) aDebugListener
+{
+    if (debugListener != aDebugListener) {
+        [(id<ANTLRDebugEventListener,NSObject>)aDebugListener retain];
+        [(id<ANTLRDebugEventListener,NSObject>)debugListener release];
+        debugListener = aDebugListener;
+    }
+}
+
+#pragma mark -
+#pragma mark Overrides
+
+- (void) beginResync
+{
+	[debugListener beginResync];
+}
+
+- (void) endResync
+{
+	[debugListener endResync];
+}
+- (void)beginBacktracking:(NSInteger)level
+{
+	[debugListener beginBacktrack:level];
+}
+
+- (void)endBacktracking:(NSInteger)level wasSuccessful:(BOOL)successful
+{
+	[debugListener endBacktrack:level wasSuccessful:successful];
+}
+
+- (void) recoverFromMismatchedToken:(id<ANTLRIntStream>)inputStream
+						  exception:(NSException *)e
+						  tokenType:(ANTLRTokenType)ttype
+							 follow:(ANTLRBitSet *)follow
+{
+#warning TODO: recoverFromMismatchedToken in debugger
+	[self recoverFromMismatchedToken:inputStream exception:e follow:follow];
+}
+
+- (void) recoverFromMismatchedSet:(id<ANTLRIntStream>)inputStream
+						exception:(NSException *)e
+						   follow:(ANTLRBitSet *)follow
+{
+#warning TODO: recoverFromMismatchedSet in debugger
+	[super recoverFromMismatchedSet:inputStream];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/DoubleKeyMap.h b/runtime/ObjC/Framework/DoubleKeyMap.h
new file mode 100644
index 0000000..7885879
--- /dev/null
+++ b/runtime/ObjC/Framework/DoubleKeyMap.h
@@ -0,0 +1,28 @@
+
+#import "AMutableArray.h"
+#import "AMutableDictionary.h"
+#import "ANTLRLinkBase.h"
+/**
+ * Sometimes we need to map a key to a value but key is two pieces of data.
+ * This nested hash table saves creating a single key each time we access
+ * map; avoids mem creation.
+ */
+
+@class AMutableArray;
+
+@interface ANTLRDoubleKeyMap : ANTLRLinkBase {
+    AMutableDictionary *data;
+}
+
+- (id) init;
+- (id) setObject:(id)v forKey1:(id)k1 forKey2:(NSString *)k2;
+- (id) objectForKey1:(id)k1 forKey2:(id)k2;
+- (AMutableDictionary *) objectForKey:(id)k1;
+- (NSArray *) valuesForKey:(id)k1;
+- (NSArray *) allKeys1;
+- (AMutableArray *) allKeys2:(id)k1;
+- (NSArray *) values;
+
+@property (retain) AMutableDictionary *data;
+
+@end
diff --git a/runtime/ObjC/Framework/DoubleKeyMap.m b/runtime/ObjC/Framework/DoubleKeyMap.m
new file mode 100644
index 0000000..3642ef0
--- /dev/null
+++ b/runtime/ObjC/Framework/DoubleKeyMap.m
@@ -0,0 +1,101 @@
+#import "ANTLRDoubleKeyMap.h"
+
+@implementation ANTLRDoubleKeyMap
+
+- (id) init
+{
+    self = [super init];
+    if ( self  != nil ) {
+        data = [[AMutableDictionary dictionaryWithCapacity:30] retain];
+    }
+    return self;
+}
+
+- (id) setObject:(id)v forKey1:(id)k1 forKey2:(id)k2
+{
+    AMutableDictionary *data2 = [data objectForKey:k1];
+    id prev = nil;
+    if ( data2 == nil ) {
+        data2 = [AMutableDictionary dictionaryWithCapacity:30];
+        [data setObject:data2 forKey:k1];
+    }
+    else {
+        prev = [data2 objectForKey:k2];
+    }
+    [data2 setObject:v forKey:k2];
+    return prev;
+}
+
+- (id) objectForKey1:(id)k1 forKey2:(id)k2
+{
+    AMutableDictionary *data2 = [data objectForKey:k1];
+    if ( data2 == nil )
+        return nil;
+    return [data2 objectForKey:k2];
+}
+
+- (AMutableDictionary *) objectForKey:(id)k1
+{
+    return [data objectForKey:k1];
+}
+
+
+/**
+ * Get all values associated with primary key
+ */
+- (NSArray *) valuesForKey:(id)k1
+{
+    AMutableDictionary *data2 = [data objectForKey:k1];
+    if ( data2 == nil )
+        return nil;
+    return [data2 allValues];
+}
+
+
+/**
+ * get all primary keys
+ */
+- (NSArray *) allKeys1
+{
+    return [data allKeys];
+}
+
+
+/**
+ * get all secondary keys associated with a primary key
+ */
+- (NSArray *) allKeys2:(id)k1
+{
+    AMutableDictionary * data2 = [data objectForKey:k1];
+    if ( data2 == nil )
+        return nil;
+    return [data2 allKeys];
+}
+
+- (AMutableArray *) values
+{
+//    ANTLRHashMap *s = [[ANTLRHashMap newANTLRHashMapWithLen:30];
+    AMutableArray *s = [AMutableArray arrayWithCapacity:30];
+
+    for (AMutableDictionary *k2 in [data allValues]) {
+
+        for ( NSString *v in [k2 allValues]) {
+            [s addObject:v];
+        }
+
+    }
+
+    return s;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRCommonToken" );
+#endif
+    [data release];
+    [super dealloc];
+}
+
+@synthesize data;
+@end
diff --git a/runtime/ObjC/Framework/EarlyExitException.h b/runtime/ObjC/Framework/EarlyExitException.h
new file mode 100644
index 0000000..07e840d
--- /dev/null
+++ b/runtime/ObjC/Framework/EarlyExitException.h
@@ -0,0 +1,39 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRecognitionException.h"
+
+@interface ANTLREarlyExitException : ANTLRRecognitionException {
+	int decisionNumber;
+}
+
++ (ANTLREarlyExitException *) newException:(id<ANTLRIntStream>)anInputStream decisionNumber:(NSInteger)aDecisionNumber;
+- (id) initWithStream:(id<ANTLRIntStream>)anInputStream decisionNumber:(NSInteger) aDecisionNumber;
+
+@property int decisionNumber;
+@end
+
diff --git a/runtime/ObjC/Framework/EarlyExitException.m b/runtime/ObjC/Framework/EarlyExitException.m
new file mode 100644
index 0000000..81ffb26
--- /dev/null
+++ b/runtime/ObjC/Framework/EarlyExitException.m
@@ -0,0 +1,54 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLREarlyExitException.h"
+
+
+@implementation ANTLREarlyExitException
+
++ (ANTLREarlyExitException *) newException:(id<ANTLRIntStream>) anInputStream decisionNumber:(NSInteger) aDecisionNumber
+{
+	return [[self alloc] initWithStream:anInputStream decisionNumber:aDecisionNumber];
+}
+
+- (id) initWithStream:(id<ANTLRIntStream>)anInputStream decisionNumber:(NSInteger) aDecisionNumber
+{
+	if ((self = [super initWithStream:anInputStream]) != nil) {
+		decisionNumber = aDecisionNumber;
+	}
+	return self;
+}
+
+- (NSString *) description
+{
+	NSMutableString *desc = (NSMutableString *)[super description];
+	[desc appendFormat:@" decision:%d", decisionNumber];
+	return desc;
+}
+
+@synthesize decisionNumber;
+@end
+
diff --git a/runtime/ObjC/Framework/FailedPredicateException.h b/runtime/ObjC/Framework/FailedPredicateException.h
new file mode 100644
index 0000000..afbb653
--- /dev/null
+++ b/runtime/ObjC/Framework/FailedPredicateException.h
@@ -0,0 +1,50 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRecognitionException.h"
+
+
+@interface ANTLRFailedPredicateException : ANTLRRecognitionException
+{
+	NSString *predicate;
+	NSString *ruleName;
+}
+
+@property (retain) NSString *predicate;
+@property (retain) NSString *ruleName;
+
++ (ANTLRFailedPredicateException *) newException:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream;
+- (ANTLRFailedPredicateException *) initWithRuleName:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream;
+
+#ifdef DONTUSEYET
+- (NSString *) getPredicate;
+- (void) setPredicate:(NSString *)thePredicate;
+- (NSString *) getRuleName;
+- (void) setRuleName:(NSString *)theRuleName;
+#endif
+
+@end
diff --git a/runtime/ObjC/Framework/FailedPredicateException.m b/runtime/ObjC/Framework/FailedPredicateException.m
new file mode 100644
index 0000000..caf7716
--- /dev/null
+++ b/runtime/ObjC/Framework/FailedPredicateException.m
@@ -0,0 +1,96 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 20110 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRFailedPredicateException.h"
+
+
+@implementation ANTLRFailedPredicateException
+
+@synthesize predicate;
+@synthesize ruleName;
+
++ (ANTLRFailedPredicateException *) newException:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream
+{
+	return [[ANTLRFailedPredicateException alloc] initWithRuleName:theRuleName predicate:thePredicate stream:theStream];
+}
+
+- (ANTLRFailedPredicateException *) initWithRuleName:(NSString *)theRuleName predicate:(NSString *)thePredicate stream:(id<ANTLRIntStream>)theStream
+{
+	if ((self = [super initWithStream:theStream])) {
+		[self setPredicate:thePredicate];
+		[self setRuleName:theRuleName];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRFailedPredicateException" );
+#endif
+	[self setPredicate:nil];
+	[self setRuleName:nil];
+	[super dealloc];
+}
+
+- (NSString *) description
+{
+	NSMutableString *desc = (NSMutableString *)[super description];
+	[desc appendFormat:@" rule: %@ predicate failed: %@", ruleName, predicate];
+	return desc;
+}
+
+#ifdef DONTUSEYET
+- (NSString *) getPredicate
+{
+	return predicate;
+}
+
+- (void) setPredicate:(NSString *)thePredicate
+{
+	if (thePredicate != predicate) {
+		[thePredicate retain];
+		if ( predicate ) [predicate release];
+		predicate = thePredicate;
+	}
+}
+
+- (NSString *) getRuleName
+{
+	return ruleName;
+}
+
+- (void) setRuleName:(NSString *)theRuleName
+{
+	if (theRuleName != ruleName) {
+		[theRuleName retain];
+		if ( ruleName ) [ruleName release];
+		ruleName = theRuleName;
+	}
+}
+#endif
+
+@end

