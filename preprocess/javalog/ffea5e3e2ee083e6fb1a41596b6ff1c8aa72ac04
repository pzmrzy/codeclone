commit ffea5e3e2ee083e6fb1a41596b6ff1c8aa72ac04
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Tue Dec 11 23:00:31 2012 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Wed Dec 12 01:40:40 2012 -0600

Fix invalid code produced by empty rule containing a rewrite (fixed antlr/antlr3#64)

diff --git a/tool/src/main/java/org/antlr/tool/Grammar.java b/tool/src/main/java/org/antlr/tool/Grammar.java
index ac1ec61..dc4774a 100644
--- a/tool/src/main/java/org/antlr/tool/Grammar.java
+++ b/tool/src/main/java/org/antlr/tool/Grammar.java
@@ -75,6 +75,8 @@ import java.io.Reader;
import java.io.StreamTokenizer;
import java.io.StringReader;
import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
@@ -2080,25 +2082,32 @@ outer:
*  any else.
*/
public boolean isEmptyRule(GrammarAST block) {
-		GrammarAST aTokenRefNode =
-			block.findFirstType(ANTLRParser.TOKEN_REF);
-		GrammarAST aStringLiteralRefNode =
-			block.findFirstType(ANTLRParser.STRING_LITERAL);
-		GrammarAST aCharLiteralRefNode =
-			block.findFirstType(ANTLRParser.CHAR_LITERAL);
-		GrammarAST aWildcardRefNode =
-			block.findFirstType(ANTLRParser.WILDCARD);
-		GrammarAST aRuleRefNode =
-			block.findFirstType(ANTLRParser.RULE_REF);
-		if ( aTokenRefNode==null&&
-			 aStringLiteralRefNode==null&&
-			 aCharLiteralRefNode==null&&
-			 aWildcardRefNode==null&&
-			 aRuleRefNode==null )
-		{
-			return true;
+		BitSet nonEmptyTerminals = new BitSet();
+		nonEmptyTerminals.set(ANTLRParser.TOKEN_REF);
+		nonEmptyTerminals.set(ANTLRParser.STRING_LITERAL);
+		nonEmptyTerminals.set(ANTLRParser.CHAR_LITERAL);
+		nonEmptyTerminals.set(ANTLRParser.WILDCARD);
+		nonEmptyTerminals.set(ANTLRParser.RULE_REF);
+		return findFirstTypeOutsideRewrite(block, nonEmptyTerminals) == null;
+	}
+
+	protected GrammarAST findFirstTypeOutsideRewrite(GrammarAST block, BitSet types) {
+		ArrayList<GrammarAST> worklist = new ArrayList<GrammarAST>();
+		worklist.add(block);
+		while (!worklist.isEmpty()) {
+			GrammarAST current = worklist.remove(worklist.size() - 1);
+			if (current.getType() == ANTLRParser.REWRITE) {
+				continue;
+			}
+
+			if (current.getType() >= 0 && types.get(current.getType())) {
+				return current;
+			}
+
+			worklist.addAll(Arrays.asList(current.getChildrenAsArray()));
}
-		return false;
+
+		return null;
}

public boolean isAtomTokenType(int ttype) {
diff --git a/tool/src/main/java/org/antlr/tool/GrammarAST.java b/tool/src/main/java/org/antlr/tool/GrammarAST.java
index 03da98c..4a66d15 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarAST.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarAST.java
@@ -341,9 +341,13 @@ public class GrammarAST extends CommonTree {
return (GrammarAST)parent.getChild(parent.getChildCount() - 1);
}

-
public GrammarAST[] getChildrenAsArray() {
-        return getChildren().toArray(new GrammarAST[getChildCount()]);
+		List<? extends Object> children = getChildren();
+		if (children == null) {
+			return new GrammarAST[0];
+		}
+
+        return children.toArray(new GrammarAST[children.size()]);
}

private static final GrammarAST DescendantDownNode = new GrammarAST(Token.DOWN, "DOWN");
diff --git a/tool/src/test/java/org/antlr/test/TestRewriteAST.java b/tool/src/test/java/org/antlr/test/TestRewriteAST.java
index f50c36d..7999112 100644
--- a/tool/src/test/java/org/antlr/test/TestRewriteAST.java
+++ b/tool/src/test/java/org/antlr/test/TestRewriteAST.java
@@ -1456,4 +1456,18 @@ public class TestRewriteAST extends BaseTest {
assertEquals("<unexpected: [@0,0:0='*',<6>,1:0], resync=*>\n", found);
}

+	@Test public void testRewriteEmptyRule() throws Exception {
+		String grammar =
+			"grammar T;\n" +
+			"options {output=AST;}\n" +
+			"tokens {IMAGINARY;}\n" +
+			"a : empty EOF! ;\n" +
+			"empty : -> IMAGINARY;\n" +
+			"WS : ' ';\n";
+		String result = execParser("T.g", grammar, "TParser", "TLexer",
+				   "a", "", debug);
+		assertEquals("IMAGINARY\n", result);
+		assertNull(stderrDuringParse);
+	}
+
}

