commit e1989ab413c0b9c4b602cead4865252c314cafb4
Author:     parrt <parrt@antlr.org>
AuthorDate: Thu Apr 14 15:20:44 2011 -0800
Commit:     parrt <parrt@antlr.org>
CommitDate: Thu Apr 14 15:20:44 2011 -0800

STv4 upgrade

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8235]

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Scala/Scala.stg b/tool/src/main/resources/org/antlr/codegen/templates/Scala/Scala.stg
index e0282dc..cd3f92e 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Scala/Scala.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Scala/Scala.stg
@@ -27,8 +27,6 @@
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
-group Scala;
-
scalaTypeInitMap ::= [
"Int":"0",
"Long":"0",
@@ -66,10 +64,10 @@ import org.antlr.runtime.tree._
<recognizer>
>>

-lexer(grammar, name, tokens, scopes, rules, numRules, labelType="CommonToken",
-      filterMode, superClass="Lexer") ::= <<
+lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
+      superClass="Lexer") ::= <<
object <grammar.recognizerName> {
-    <tokens:{val <it.name> = <it.type>}; separator="\n">
+    <tokens:{it | val <it.name> = <it.type>}; separator="\n">

<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
}
@@ -86,7 +84,7 @@ class <grammar.recognizerName>(input: CharStream, state<grammar.delegators:{g|,
{g|<g.recognizerName> <g:delegateName()>}; separator="\n">
<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>

-    <scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+    <scopes:{it | <if(it.isDynamicGlobalScope)><globalAttributeScope()><endif>}>

def this(input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>: CharStream) =
this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
@@ -182,8 +180,8 @@ filteringActionGate() ::= "state.backtracking==1"
/** How to generate a parser */
genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
bitsets, inputStreamType, superClass,
-              ASTLabelType="Object", labelType, members, rewriteElementType,
-              filterMode) ::= <<
+              labelType, members, rewriteElementType,
+              filterMode, ASTLabelType="Object") ::= <<
object <grammar.recognizerName> {
<if(grammar.grammarIsRoot)>
val tokenNames = Array(
@@ -191,12 +189,12 @@ object <grammar.recognizerName> {
)<\n>
<endif>

-    <tokens:{val <it.name> = <it.type>}; separator="\n">
+    <tokens:{it | val <it.name> = <it.type>}; separator="\n">

<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>

-    <bitsets:bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
-                    words64=it.bits)>
+    <bitsets:{it | <bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
+                    words64=it.bits)>}>
}

class <grammar.recognizerName>(input: <inputStreamType>, state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>: RecognizerSharedState) extends <@superClassName><superClass><@end>(input, state) {
@@ -209,7 +207,7 @@ class <grammar.recognizerName>(input: <inputStreamType>, state<grammar.delegator
{g|public <g.recognizerName> <g:delegateName()>}; separator="\n">
<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>

-    <scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+    <scopes:{it | <if(it.isDynamicGlobalScope)><globalAttributeScope()><endif>}>

<@members>
<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
@@ -235,7 +233,7 @@ class <grammar.recognizerName>(input: <inputStreamType>, state<grammar.delegator
// Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
@throws(classOf[RecognitionException])
-    def <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>): <returnType()> = \{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">) \}}; separator="\n">
+    def <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope()>): <returnType()> = \{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">) \}}; separator="\n">

<synpreds:{p | <synpred(p)>}>

@@ -263,10 +261,10 @@ parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
*  stream is a different type.
*/
treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
-           numRules, bitsets, labelType={<ASTLabelType>}, ASTLabelType="Object",
+           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="Object",
superClass={<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif>},
-           members={<actions.treeparser.members>},
-           filterMode) ::= <<
+           members={<actions.treeparser.members>}
+           ) ::= <<
<genericParser(inputStreamType="TreeNodeStream", rewriteElementType="Node", ...)>
>>

@@ -281,7 +279,7 @@ synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
// $ANTLR start <ruleName>
@throws(classOf[RecognitionException])
-def <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope(scope=it)>): Unit = {
+def <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>): Unit = {
<ruleLabelDefs()>
<if(trace)>
traceIn("<ruleName>_fragment", <ruleDescriptor.index>)
@@ -348,7 +346,7 @@ rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memo
// $ANTLR start "<ruleName>"
// <fileName>:<description>
@throws(classOf[RecognitionException])
-final def <ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>): <returnType()> = {
+final def <ruleName>(<ruleDescriptor.parameterScope:parameterScope()>): <returnType()> = {
<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>)<endif>
<ruleScopeSetUp()>
<ruleDeclarations()>
@@ -410,25 +408,25 @@ val <ruleDescriptor.name>_StartIndex = input.index()
>>

ruleScopeSetUp() ::= <<
-<ruleDescriptor.useScopes:{<it>_stack.push(new <it>_scope())}; separator="\n">
-<ruleDescriptor.ruleScope:{<it.name>_stack.push(new <it.name>_scope())}; separator="\n">
+<ruleDescriptor.useScopes:{it | <it>_stack.push(new <it>_scope())}; separator="\n">
+<ruleDescriptor.ruleScope:{it | <it.name>_stack.push(new <it.name>_scope())}; separator="\n">
>>

ruleScopeCleanUp() ::= <<
-<ruleDescriptor.useScopes:{<it>_stack.pop()}; separator="\n">
-<ruleDescriptor.ruleScope:{<it.name>_stack.pop()}; separator="\n">
+<ruleDescriptor.useScopes:{it | <it>_stack.pop()}; separator="\n">
+<ruleDescriptor.ruleScope:{it | <it.name>_stack.pop()}; separator="\n">
>>


ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,
ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{var <it.label.text>: <labelType> = null}; separator="\n"
+    :{it | var <it.label.text>: <labelType> = null}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{var list_<it.label.text>: java.util.List=null}; separator="\n"
+    :{it | var list_<it.label.text>: java.util.List=null}; separator="\n"
>
-<ruleDescriptor.ruleLabels:ruleLabelDef(label=it); separator="\n">
+<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
<ruleDescriptor.ruleListLabels:{ll|var <ll.label.text>: RuleReturnScope = null}; separator="\n">
>>

@@ -436,12 +434,12 @@ lexerRuleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,
ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleLabels]
-    :{var <it.label.text>: <labelType>=null}; separator="\n"
+    :{it | var <it.label.text>: <labelType>=null}; separator="\n"
>
-<ruleDescriptor.charLabels:{int <it.label.text>;}; separator="\n">
+<ruleDescriptor.charLabels:{it | int <it.label.text>;}; separator="\n">
<[ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleListLabels]
-    :{var list_<it.label.text>: java.util.List=null}; separator="\n"
+    :{it | var list_<it.label.text>: java.util.List=null}; separator="\n"
>
>>

@@ -479,7 +477,7 @@ if ( state.backtracking>0 ) { memoize(input, <ruleDescriptor.index>, <ruleDescri
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
// $ANTLR start "<ruleName>"
@throws(classOf[RecognitionException])
-final def m<ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>): Unit = {
+final def m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>): Unit = {
<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>)<endif>
<ruleScopeSetUp()>
<ruleDeclarations()>
@@ -533,7 +531,7 @@ var alt<decisionNumber> = <maxAlt>
<@postdecision()>
<@prebranch()>
alt<decisionNumber> match {
-    <alts:altSwitchCase()>
+    <alts:{a | <altSwitchCase(i,a)>}>
case _ =>
}
<@postbranch()>
@@ -548,7 +546,7 @@ var alt<decisionNumber> = <maxAlt>
<decision>
<@postdecision()>
alt<decisionNumber> match {
-    <alts:altSwitchCase()>
+    <alts:{a | <altSwitchCase(i,a)>}>
case _ =>
}
>>
@@ -583,7 +581,7 @@ while (!loop<decisionNumber>_quitflag) {
<decision>
<@postdecision()>
alt<decisionNumber> match {
-	<alts:altSwitchCase()>
+        <alts:{a | <altSwitchCase(i,a)>}>
case _ =>
if ( cnt<decisionNumber> >= 1 ) loop<decisionNumber>_quitflag = true
else {
@@ -612,7 +610,7 @@ while (!loop<decisionNumber>_quitflag) {
<decision>
<@postdecision()>
alt<decisionNumber> match {
-	<alts:altSwitchCase()>
+        <alts:{a | <altSwitchCase(i,a)>}>
case _ => loop<decisionNumber>_quitflag = true
}
}
@@ -632,10 +630,10 @@ optionalBlockSingleAlt ::= block
*  number.  A DFA predicts the alternative and then a simple switch
*  does the jump to the code that actually matches that alternative.
*/
-altSwitchCase() ::= <<
-case <i> =>
+altSwitchCase(altNum, alt) ::= <<
+case <altNum> =>
<@prealt()>
-    <it>
+    <alt>
>>

/** An alternative is just a list of elements; at outermost level */
@@ -657,9 +655,9 @@ noRewrite(rewriteBlockLevel, treeLevel) ::= ""
// E L E M E N T S

/** Dump the elements one per line */
-element() ::= <<
+element(e) ::= <<
<@prematch()>
-<it.el><\n>
+<e.el><\n>
>>

/** match a token optionally with a label in front */
@@ -697,7 +695,7 @@ matchRange(<a>,<b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,elementIndex,postmatchCode="") ::= <<
+matchSet(s,label,elementIndex,terminalOptions,postmatchCode="") ::= <<
<if(label)>
<if(LEXER)>
<label>= input.LA(1)<\n>
@@ -753,7 +751,7 @@ val <label>StartCharPos<elementIndex> = getCharPositionInLine()
<endif>
>>

-wildcard(label,elementIndex) ::= <<
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
<if(label)>
<label>=input.LT(1).asInstanceOf[<labelType>]<\n>
<endif>
@@ -761,7 +759,7 @@ matchAny(input)
<checkRuleBacktrackFailure()>
>>

-wildcardAndListLabel(label,elementIndex) ::= <<
+wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<wildcard(...)>
<listLabel(elem=label,...)>
>>
@@ -981,7 +979,7 @@ case _ =>
>>

dfaEdgeSwitch(labels, targetState) ::= <<
-case <labels:{<it>}; separator=" | "> =>
+case <labels:{it | <it>}; separator=" | "> =>
{
<targetState>
}
@@ -1118,7 +1116,7 @@ andPredicates(left,right) ::= "(<left>&&<right>)"

orPredicates(operands) ::= "(<first(operands)><rest(operands):{o | ||<o>}>)"

-notPredicate(pred) ::= "!(<evalPredicate(...)>)"
+notPredicate(pred) ::= "!(<evalPredicate(pred,\"\")>)"

evalPredicate(pred,description) ::= "(<pred>)"

@@ -1132,10 +1130,10 @@ lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
-(LA<decisionNumber>_<stateNumber>\>=<lower> && LA<decisionNumber>_<stateNumber>\<=<upper>)
+(LA<decisionNumber>_<stateNumber> >= <lower> && LA<decisionNumber>_<stateNumber> \<= <upper>)
>>

-isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)\>=<lower> && input.LA(<k>)\<=<upper>)"
+isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>) >=<lower> && input.LA(<k>) \<= <upper>)"

setTest(ranges) ::= "<ranges; separator=\"||\">"

@@ -1144,7 +1142,7 @@ setTest(ranges) ::= "<ranges; separator=\"||\">"
globalAttributeScope(scope) ::= <<
<if(scope.attributes)>
class <scope.name>_scope {
-    <scope.attributes:{var <it.name>: <it.type> = _}; separator="\n">
+    <scope.attributes:{it | var <it.name>: <it.type> = _}; separator="\n">
}
val <scope.name>_stack = new collection.mutable.Stack[<scope.name>_scope]<\n>
<endif>
@@ -1153,13 +1151,13 @@ val <scope.name>_stack = new collection.mutable.Stack[<scope.name>_scope]<\n>
ruleAttributeScope(scope) ::= <<
<if(scope.attributes)>
class <scope.name>_scope {
-    <scope.attributes:{var <it.name>: <it.type> = _}; separator="\n">
+    <scope.attributes:{it | var <it.name>: <it.type> = _}; separator="\n">
}
val <scope.name>_stack = new collection.mutable.Stack[<scope.name>_scope]<\n>
<endif>
>>

-returnStructName() ::= "<it.name>_return"
+returnStructName(r) ::= "<r.name>_return"

returnType() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
@@ -1188,8 +1186,8 @@ Unit
<endif>
>>

-delegateName() ::= <<
-<if(it.label)><it.label><else>g<it.name><endif>
+delegateName(d) ::= <<
+<if(d.label)><d.label><else>g<d.name><endif>
>>

/** Using a type to init value map, try to init a type; if not in table
@@ -1212,20 +1210,20 @@ var <label.label.text>: <ruleLabelType(referencedRule=label.referencedRule)> = <
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
final class <ruleDescriptor:returnStructName()> extends <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope {
-    <scope.attributes:{var <it.name>: <it.type> = _}; separator="\n">
+    <scope.attributes:{it | var <it.name>: <it.type> = _}; separator="\n">
<@ruleReturnMembers()>
}
<endif>
>>

parameterScope(scope) ::= <<
-<scope.attributes:{<it.name>: <it.type>}; separator=", ">
+<scope.attributes:{it | <it.name>: <it.type>}; separator=", ">
>>

parameterAttributeRef(attr) ::= "<attr.name>"
parameterSetAttributeRef(attr,expr) ::= "<attr.name> =<expr>"

-scopeAttributeRef(scope,attr,index,negIndex) ::= <<
+scopeAttributeRef(scope,attr,index,negIndex) ::= <%
<if(negIndex)>
<scope>_stack(<scope>_stack.size-<negIndex>-1).<attr.name>
<else>
@@ -1235,9 +1233,9 @@ scopeAttributeRef(scope,attr,index,negIndex) ::= <<
<scope>_stack.top.<attr.name>
<endif>
<endif>
->>
+%>

-scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
+scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
<if(negIndex)>
<scope>_stack(<scope>_stack.size-<negIndex>-1).<attr.name> = <expr>
<else>
@@ -1247,7 +1245,7 @@ scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
<scope>_stack.top.<attr.name> = <expr>
<endif>
<endif>
->>
+%>

/** $x is either global scope or x is rule with dynamic scope; refers
*  to stack itself not top of stack.  This is useful for predicates
@@ -1256,29 +1254,29 @@ scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
isolatedDynamicScopeRef(scope) ::= "<scope>_stack"

/** reference an attribute of rule; might only have single return value */
-ruleLabelRef(referencedRule,scope,attr) ::= <<
+ruleLabelRef(referencedRule,scope,attr) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
(if (<scope>!=null) <scope>.<attr.name> else <initValue(attr.type)>)
<else>
<scope>
<endif>
->>
+%>

-returnAttributeRef(ruleDescriptor,attr) ::= <<
+returnAttributeRef(ruleDescriptor,attr) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.<attr.name>
<else>
<attr.name>
<endif>
->>
+%>

-returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <<
+returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.<attr.name> =<expr>
<else>
<attr.name> =<expr>
<endif>
->>
+%>

/** How to translate $tokenLabel */
tokenLabelRef(label) ::= "<label>"
@@ -1378,10 +1376,10 @@ execForcedAction(action) ::= "<action>"
// M I S C (properties, etc...)

bitset(name, words64) ::= <<
-val <name> = new BitSet(Array[Long](<words64:{<it>L};separator=",">))<\n>
+val <name> = new BitSet(Array[Long](<words64:{it | <it>L};separator=",">))<\n>
>>

codeFileExtension() ::= ".scala"

-true() ::= "true"
-false() ::= "false"
+true_value() ::= "true"
+false_value() ::= "false"

