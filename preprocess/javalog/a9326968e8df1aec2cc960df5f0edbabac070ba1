commit a9326968e8df1aec2cc960df5f0edbabac070ba1
Author:     parrt <parrt@antlr.org>
AuthorDate: Sun Apr 10 15:12:56 2011 -0800
Commit:     parrt <parrt@antlr.org>
CommitDate: Sun Apr 10 15:12:56 2011 -0800

* Uses ST v4 now!!!  Massive change.  Only updated Java target so far.
Ripped out ST v3 usage to remove indirect dependency on ANTLR v2.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8151]

diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
index 5488b5b..6c519d1 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
@@ -89,7 +89,7 @@ public class DOTTreeGenerator {
/*
if ( adaptor.getChildCount(tree)==0 ) {
// single node, don't do edge.
-            treeST.setAttribute("nodes", adaptor.getText(tree));
+            treeST.add("nodes", adaptor.getText(tree));
}
*/
return treeST;
diff --git a/tool/CHANGES.txt b/tool/CHANGES.txt
index 3cff471..3073166 100644
--- a/tool/CHANGES.txt
+++ b/tool/CHANGES.txt
@@ -7,6 +7,15 @@ University of San Francisco

CHANGES

+March 29 - April 10, 2011
+
+* Uses ST v4 now!!!  Massive change.  Only updated Java target so far.
+  Ripped out ST v3 usage to remove indirect dependency on ANTLR v2.
+
+March 28, 2011
+
+* Sam Harwell ported all v2 grammars to v3!
+
March 3, 2011

* left-recursion pattern off until all targets catch up
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/ActionTranslator.g b/tool/src/main/antlr3/org/antlr/grammar/v3/ActionTranslator.g
index 52a9a50..0aca8b8 100644
--- a/tool/src/main/antlr3/org/antlr/grammar/v3/ActionTranslator.g
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/ActionTranslator.g
@@ -33,7 +33,7 @@ options {

@header {
package org.antlr.grammar.v3;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.runtime.*;
import org.antlr.tool.*;
import org.antlr.codegen.*;
@@ -78,7 +78,7 @@ Token actionToken;
this.outerAltNum = outerAltNum;
}

-/** Return a list of strings and StringTemplate objects that
+/** Return a list of strings and ST objects that
*  represent the translated action.
*/
public List translateToChunks() {
@@ -96,7 +96,8 @@ public String translate() {
StringBuffer buf = new StringBuffer();
for (int i = 0; i < theChunks.size(); i++) {
Object o = (Object) theChunks.get(i);
-		buf.append(o);
+		if ( o instanceof ST ) buf.append(((ST)o).render());
+		else buf.append(o);
}
//System.out.println("translated: "+buf.toString());
return buf.toString();
@@ -163,8 +164,8 @@ AttributeScope resolveDynamicScope(String scopeName) {
return null; // not a valid dynamic scope
}

-protected StringTemplate template(String name) {
-	StringTemplate st = generator.getTemplates().getInstanceOf(name);
+protected ST template(String name) {
+	ST st = generator.getTemplates().getInstanceOf(name);
chunks.add(st);
return st;
}
@@ -186,15 +187,15 @@ SET_ENCLOSING_RULE_SCOPE_ATTR
enclosingRule.getLocalAttributeScope($y.text)!=null}?
//{System.out.println("found \$rule.attr");}
{
-		StringTemplate st = null;
+		ST st = null;
AttributeScope scope = enclosingRule.getLocalAttributeScope($y.text);
if ( scope.isPredefinedRuleScope ) {
if ( $y.text.equals("st") || $y.text.equals("tree") ) {
st = template("ruleSetPropertyRef_"+$y.text);
grammar.referenceRuleLabelPredefinedAttribute($x.text);
-				st.setAttribute("scope", $x.text);
-				st.setAttribute("attr", $y.text);
-				st.setAttribute("expr", translateAction($expr.text));
+				st.add("scope", $x.text);
+				st.add("attr", $y.text);
+				st.add("expr", translateAction($expr.text));
} else {
ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
@@ -213,14 +214,14 @@ SET_ENCLOSING_RULE_SCOPE_ATTR
}
else if ( scope.isParameterScope ) {
st = template("parameterSetAttributeRef");
-			st.setAttribute("attr", scope.getAttribute($y.text));
-			st.setAttribute("expr", translateAction($expr.text));
+			st.add("attr", scope.getAttribute($y.text));
+			st.add("expr", translateAction($expr.text));
}
else { // must be return value
st = template("returnSetAttributeRef");
-			st.setAttribute("ruleDescriptor", enclosingRule);
-			st.setAttribute("attr", scope.getAttribute($y.text));
-			st.setAttribute("expr", translateAction($expr.text));
+			st.add("ruleDescriptor", enclosingRule);
+			st.add("attr", scope.getAttribute($y.text));
+			st.add("expr", translateAction($expr.text));
}
}
;
@@ -236,13 +237,13 @@ ENCLOSING_RULE_SCOPE_ATTR
actionToken,
$x.text);
}
-		StringTemplate st = null;
+		ST st = null;
AttributeScope scope = enclosingRule.getLocalAttributeScope($y.text);
if ( scope.isPredefinedRuleScope ) {
st = template("rulePropertyRef_"+$y.text);
grammar.referenceRuleLabelPredefinedAttribute($x.text);
-			st.setAttribute("scope", $x.text);
-			st.setAttribute("attr", $y.text);
+			st.add("scope", $x.text);
+			st.add("attr", $y.text);
}
else if ( scope.isPredefinedLexerRuleScope ) {
// perhaps not the most precise error message to use, but...
@@ -253,12 +254,12 @@ ENCLOSING_RULE_SCOPE_ATTR
}
else if ( scope.isParameterScope ) {
st = template("parameterAttributeRef");
-			st.setAttribute("attr", scope.getAttribute($y.text));
+			st.add("attr", scope.getAttribute($y.text));
}
else { // must be return value
st = template("returnAttributeRef");
-			st.setAttribute("ruleDescriptor", enclosingRule);
-			st.setAttribute("attr", scope.getAttribute($y.text));
+			st.add("ruleDescriptor", enclosingRule);
+			st.add("attr", scope.getAttribute($y.text));
}
}
;
@@ -306,9 +307,9 @@ TOKEN_SCOPE_ATTR
label = $x.text;
}
}
-		StringTemplate st = template("tokenLabelPropertyRef_"+$y.text);
-		st.setAttribute("scope", label);
-		st.setAttribute("attr", AttributeScope.tokenScope.getAttribute($y.text));
+		ST st = template("tokenLabelPropertyRef_"+$y.text);
+		st.add("scope", label);
+		st.add("attr", AttributeScope.tokenScope.getAttribute($y.text));
}
;

@@ -379,29 +380,29 @@ String refdRuleName=null;
label = $x.text;
}
}
-		StringTemplate st;
+		ST st;
Rule refdRule = grammar.getRule(refdRuleName);
AttributeScope scope = refdRule.getLocalAttributeScope($y.text);
if ( scope.isPredefinedRuleScope ) {
st = template("ruleLabelPropertyRef_"+$y.text);
grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
-			st.setAttribute("scope", label);
-			st.setAttribute("attr", $y.text);
+			st.add("scope", label);
+			st.add("attr", $y.text);
}
else if ( scope.isPredefinedLexerRuleScope ) {
st = template("lexerRuleLabelPropertyRef_"+$y.text);
grammar.referenceRuleLabelPredefinedAttribute(refdRuleName);
-			st.setAttribute("scope", label);
-			st.setAttribute("attr", $y.text);
+			st.add("scope", label);
+			st.add("attr", $y.text);
}
else if ( scope.isParameterScope ) {
// TODO: error!
}
else {
st = template("ruleLabelRef");
-			st.setAttribute("referencedRule", refdRule);
-			st.setAttribute("scope", label);
-			st.setAttribute("attr", scope.getAttribute($y.text));
+			st.add("referencedRule", refdRule);
+			st.add("scope", label);
+			st.add("attr", scope.getAttribute($y.text));
}
}
;
@@ -414,7 +415,7 @@ LABEL_REF
enclosingRule.getRuleLabel($ID.text)==null}?
// {System.out.println("found \$label");}
{
-		StringTemplate st;
+		ST st;
Grammar.LabelElementPair pair = getElementLabel($ID.text);
if ( pair.type==Grammar.RULE_LIST_LABEL ||
pair.type==Grammar.TOKEN_LIST_LABEL ||
@@ -425,7 +426,7 @@ LABEL_REF
else {
st = template("tokenLabelRef");
}
-		st.setAttribute("label", $ID.text);
+		st.add("label", $ID.text);
}
;

@@ -443,8 +444,8 @@ ISOLATED_TOKEN_REF
$ID.text);
}
else {
-			StringTemplate st = template("tokenLabelRef");
-			st.setAttribute("label", label);
+			ST st = template("tokenLabelRef");
+			st.add("label", label);
}
}
;
@@ -465,8 +466,8 @@ ISOLATED_LEXER_RULE_REF
$ID.text);
}
else {
-			StringTemplate st = template("lexerRuleLabel");
-			st.setAttribute("label", label);
+			ST st = template("lexerRuleLabel");
+			st.add("label", label);
}
}
;
@@ -488,15 +489,15 @@ SET_LOCAL_ATTR
&& !enclosingRule.getLocalAttributeScope($ID.text).isPredefinedLexerRuleScope}?
//{System.out.println("found set \$localattr");}
{
-		StringTemplate st;
+		ST st;
AttributeScope scope = enclosingRule.getLocalAttributeScope($ID.text);
if ( scope.isPredefinedRuleScope ) {
if ($ID.text.equals("tree") || $ID.text.equals("st")) {
st = template("ruleSetPropertyRef_"+$ID.text);
grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
-				st.setAttribute("scope", enclosingRule.name);
-				st.setAttribute("attr", $ID.text);
-				st.setAttribute("expr", translateAction($expr.text));
+				st.add("scope", enclosingRule.name);
+				st.add("attr", $ID.text);
+				st.add("expr", translateAction($expr.text));
} else {
ErrorManager.grammarError(ErrorManager.MSG_WRITE_TO_READONLY_ATTR,
grammar,
@@ -507,14 +508,14 @@ SET_LOCAL_ATTR
}
else if ( scope.isParameterScope ) {
st = template("parameterSetAttributeRef");
-			st.setAttribute("attr", scope.getAttribute($ID.text));
-			st.setAttribute("expr", translateAction($expr.text));
+			st.add("attr", scope.getAttribute($ID.text));
+			st.add("expr", translateAction($expr.text));
}
else {
st = template("returnSetAttributeRef");
-			st.setAttribute("ruleDescriptor", enclosingRule);
-			st.setAttribute("attr", scope.getAttribute($ID.text));
-			st.setAttribute("expr", translateAction($expr.text));
+			st.add("ruleDescriptor", enclosingRule);
+			st.add("attr", scope.getAttribute($ID.text));
+			st.add("expr", translateAction($expr.text));
}
}
;
@@ -522,27 +523,27 @@ LOCAL_ATTR
:	'$' ID {enclosingRule!=null && enclosingRule.getLocalAttributeScope($ID.text)!=null}?
//{System.out.println("found \$localattr");}
{
-		StringTemplate st;
+		ST st;
AttributeScope scope = enclosingRule.getLocalAttributeScope($ID.text);
if ( scope.isPredefinedRuleScope ) {
st = template("rulePropertyRef_"+$ID.text);
grammar.referenceRuleLabelPredefinedAttribute(enclosingRule.name);
-			st.setAttribute("scope", enclosingRule.name);
-			st.setAttribute("attr", $ID.text);
+			st.add("scope", enclosingRule.name);
+			st.add("attr", $ID.text);
}
else if ( scope.isPredefinedLexerRuleScope ) {
st = template("lexerRulePropertyRef_"+$ID.text);
-			st.setAttribute("scope", enclosingRule.name);
-			st.setAttribute("attr", $ID.text);
+			st.add("scope", enclosingRule.name);
+			st.add("attr", $ID.text);
}
else if ( scope.isParameterScope ) {
st = template("parameterAttributeRef");
-			st.setAttribute("attr", scope.getAttribute($ID.text));
+			st.add("attr", scope.getAttribute($ID.text));
}
else {
st = template("returnAttributeRef");
-			st.setAttribute("ruleDescriptor", enclosingRule);
-			st.setAttribute("attr", scope.getAttribute($ID.text));
+			st.add("ruleDescriptor", enclosingRule);
+			st.add("attr", scope.getAttribute($ID.text));
}
}
;
@@ -567,10 +568,10 @@ SET_DYNAMIC_SCOPE_ATTR
{
AttributeScope scope = resolveDynamicScope($x.text);
if ( scope!=null ) {
-			StringTemplate st = template("scopeSetAttributeRef");
-			st.setAttribute("scope", $x.text);
-			st.setAttribute("attr",  scope.getAttribute($y.text));
-			st.setAttribute("expr",  translateAction($expr.text));
+			ST st = template("scopeSetAttributeRef");
+			st.add("scope", $x.text);
+			st.add("attr",  scope.getAttribute($y.text));
+			st.add("expr",  translateAction($expr.text));
}
else {
// error: invalid dynamic attribute
@@ -586,9 +587,9 @@ DYNAMIC_SCOPE_ATTR
{
AttributeScope scope = resolveDynamicScope($x.text);
if ( scope!=null ) {
-			StringTemplate st = template("scopeAttributeRef");
-			st.setAttribute("scope", $x.text);
-			st.setAttribute("attr",  scope.getAttribute($y.text));
+			ST st = template("scopeAttributeRef");
+			st.add("scope", $x.text);
+			st.add("attr",  scope.getAttribute($y.text));
}
else {
// error: invalid dynamic attribute
@@ -619,10 +620,10 @@ DYNAMIC_NEGATIVE_INDEXED_SCOPE_ATTR
:	'$' x=ID '[' '-' expr=SCOPE_INDEX_EXPR ']' '::' y=ID
// {System.out.println("found \$scope[-...]::attr");}
{
-		StringTemplate st = template("scopeAttributeRef");
-		st.setAttribute("scope",    $x.text);
-		st.setAttribute("attr",     resolveDynamicScope($x.text).getAttribute($y.text));
-		st.setAttribute("negIndex", $expr.text);
+		ST st = template("scopeAttributeRef");
+		st.add("scope",    $x.text);
+		st.add("attr",     resolveDynamicScope($x.text).getAttribute($y.text));
+		st.add("negIndex", $expr.text);
}
;

@@ -630,10 +631,10 @@ DYNAMIC_ABSOLUTE_INDEXED_SCOPE_ATTR
:	'$' x=ID '[' expr=SCOPE_INDEX_EXPR ']' '::' y=ID
// {System.out.println("found \$scope[...]::attr");}
{
-		StringTemplate st = template("scopeAttributeRef");
-		st.setAttribute("scope", $x.text);
-		st.setAttribute("attr",  resolveDynamicScope($x.text).getAttribute($y.text));
-		st.setAttribute("index", $expr.text);
+		ST st = template("scopeAttributeRef");
+		st.add("scope", $x.text);
+		st.add("attr",  resolveDynamicScope($x.text).getAttribute($y.text));
+		st.add("index", $expr.text);
}
;

@@ -651,8 +652,8 @@ ISOLATED_DYNAMIC_SCOPE
:	'$' ID {resolveDynamicScope($ID.text)!=null}?
// {System.out.println("found isolated \$scope where scope is a dynamic scope");}
{
-		StringTemplate st = template("isolatedDynamicScopeRef");
-		st.setAttribute("scope", $ID.text);
+		ST st = template("isolatedDynamicScopeRef");
+		st.add("scope", $ID.text);
}
;

@@ -669,7 +670,7 @@ TEMPLATE_INSTANCE
if ( enclosingRule!=null ) {
ruleName = enclosingRule.name;
}
-		StringTemplate st =
+		ST st =
generator.translateTemplateConstructor(ruleName,
outerAltNum,
actionToken,
@@ -686,7 +687,7 @@ INDIRECT_TEMPLATE_INSTANCE
// {System.out.println("found \%({...})(args)");}
{
String action = getText().substring(1,getText().length());
-		StringTemplate st =
+		ST st =
generator.translateTemplateConstructor(enclosingRule.name,
outerAltNum,
actionToken,
@@ -699,17 +700,17 @@ fragment
ARG	:	ID '=' ACTION
;

-/**	%{expr}.y = z; template attribute y of StringTemplate-typed expr to z */
+/**	%{expr}.y = z; template attribute y of ST-typed expr to z */
SET_EXPR_ATTRIBUTE
:	'%' a=ACTION '.' ID WS? '=' expr=ATTR_VALUE_EXPR ';'
// {System.out.println("found \%{expr}.y = z;");}
{
-		StringTemplate st = template("actionSetAttribute");
+		ST st = template("actionSetAttribute");
String action = $a.text;
action = action.substring(1,action.length()-1); // stuff inside {...}
-		st.setAttribute("st", translateAction(action));
-		st.setAttribute("attrName", $ID.text);
-		st.setAttribute("expr", translateAction($expr.text));
+		st.add("st", translateAction(action));
+		st.add("attrName", $ID.text);
+		st.add("expr", translateAction($expr.text));
}
;

@@ -721,10 +722,10 @@ SET_ATTRIBUTE
:	'%' x=ID '.' y=ID WS? '=' expr=ATTR_VALUE_EXPR ';'
// {System.out.println("found \%x.y = z;");}
{
-		StringTemplate st = template("actionSetAttribute");
-		st.setAttribute("st", $x.text);
-		st.setAttribute("attrName", $y.text);
-		st.setAttribute("expr", translateAction($expr.text));
+		ST st = template("actionSetAttribute");
+		st.add("st", $x.text);
+		st.add("attrName", $y.text);
+		st.add("expr", translateAction($expr.text));
}
;

@@ -739,10 +740,10 @@ TEMPLATE_EXPR
:	'%' a=ACTION
// {System.out.println("found \%{expr}");}
{
-		StringTemplate st = template("actionStringConstructor");
+		ST st = template("actionStringConstructor");
String action = $a.text;
action = action.substring(1,action.length()-1); // stuff inside {...}
-		st.setAttribute("stringExpr", translateAction(action));
+		st.add("stringExpr", translateAction(action));
}
;

diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g b/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g
index 2ca9116..80e4d32 100644
--- a/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.g
@@ -31,7 +31,7 @@
*/

/** Walk a grammar and generate code by gradually building up
- *  a bigger and bigger StringTemplate.
+ *  a bigger and bigger ST.
*
*  Terence Parr
*  University of San Francisco
@@ -57,8 +57,8 @@ import java.util.Set;
import java.util.Collection;
import org.antlr.runtime.BitSet;
import org.antlr.runtime.DFA;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
}

@members {
@@ -69,7 +69,7 @@ private String currentRuleName = null;
protected int blockNestingLevel = 0;
protected int rewriteBlockNestingLevel = 0;
private int outerAltNum = 0;
-protected StringTemplate currentBlockST = null;
+protected ST currentBlockST = null;
protected boolean currentAltHasASTRewrite = false;
protected int rewriteTreeNestingLevel = 0;
protected HashSet<Object> rewriteRuleRefs = null;
@@ -113,19 +113,19 @@ public final void reportError(String s) {

protected CodeGenerator generator;
protected Grammar grammar;
-protected StringTemplateGroup templates;
+protected STGroup templates;

/** The overall lexer/parser template; simulate dynamically scoped
*  attributes by making this an instance var of the walker.
*/
-protected StringTemplate recognizerST;
+protected ST recognizerST;

-protected StringTemplate outputFileST;
-protected StringTemplate headerFileST;
+protected ST outputFileST;
+protected ST headerFileST;

protected String outputOption = "";

-protected final StringTemplate getWildcardST(GrammarAST elementAST, GrammarAST ast_suffix, String label) {
+protected final ST getWildcardST(GrammarAST elementAST, GrammarAST ast_suffix, String label) {
String name = "wildcard";
if (grammar.type == Grammar.LEXER) {
name = "wildcardChar";
@@ -133,7 +133,7 @@ protected final StringTemplate getWildcardST(GrammarAST elementAST, GrammarAST a
return getTokenElementST(name, name, elementAST, ast_suffix, label);
}

-protected final StringTemplate getRuleElementST( String name,
+protected final ST getRuleElementST( String name,
String ruleTargetName,
GrammarAST elementAST,
GrammarAST ast_suffix,
@@ -151,15 +151,15 @@ protected final StringTemplate getRuleElementST( String name,
grammar.defineRuleRefLabel( currentRuleName, labelTok, elementAST );
}

-    StringTemplate elementST = templates.getInstanceOf( name );
+    ST elementST = templates.getInstanceOf( name );
if ( label != null ) {
-        elementST.setAttribute( "label", label );
+        elementST.add( "label", label );
}

return elementST;
}

-protected final StringTemplate getTokenElementST( String name,
+protected final ST getTokenElementST( String name,
String elementName,
GrammarAST elementAST,
GrammarAST ast_suffix,
@@ -187,7 +187,7 @@ protected final StringTemplate getTokenElementST( String name,
grammar.defineTokenRefLabel( currentRuleName, labelTok, elementAST );
}

-    StringTemplate elementST = null;
+    ST elementST = null;
if ( tryUnchecked && templates.isDefined( name + "Unchecked" + suffix ) )
elementST = templates.getInstanceOf( name + "Unchecked" + suffix );
if ( elementST == null )
@@ -195,7 +195,7 @@ protected final StringTemplate getTokenElementST( String name,

if ( label != null )
{
-        elementST.setAttribute( "label", label );
+        elementST.add( "label", label );
}
return elementST;
}
@@ -292,9 +292,9 @@ public final void init( Grammar g ) {

public
grammar_[Grammar g,
-		StringTemplate recognizerST,
-		StringTemplate outputFileST,
-		StringTemplate headerFileST]
+		ST recognizerST,
+		ST outputFileST,
+		ST headerFileST]
@init
{
if ( state.backtracking == 0 )
@@ -305,9 +305,10 @@ grammar_[Grammar g,
this.headerFileST = headerFileST;
String superClass = (String)g.getOption("superClass");
outputOption = (String)g.getOption("output");
-		recognizerST.setAttribute("superClass", superClass);
+		if ( superClass!=null ) recognizerST.add("superClass", superClass);
if ( g.type!=Grammar.LEXER ) {
-			recognizerST.setAttribute("ASTLabelType", g.getOption("ASTLabelType"));
+		    Object lt = g.getOption("ASTLabelType");
+			if ( lt!=null ) recognizerST.add("ASTLabelType", lt);
}
if ( g.type==Grammar.TREE_PARSER && g.getOption("ASTLabelType")==null ) {
ErrorManager.grammarWarning(ErrorManager.MSG_MISSING_AST_TYPE_IN_TREE_GRAMMAR,
@@ -316,11 +317,12 @@ grammar_[Grammar g,
g.name);
}
if ( g.type!=Grammar.TREE_PARSER ) {
-			recognizerST.setAttribute("labelType", g.getOption("TokenLabelType"));
+		    Object lt = g.getOption("TokenLabelType");
+			if ( lt!=null ) recognizerST.add("labelType", lt);
}
-		$recognizerST.setAttribute("numRules", grammar.getRules().size());
-		$outputFileST.setAttribute("numRules", grammar.getRules().size());
-		$headerFileST.setAttribute("numRules", grammar.getRules().size());
+		$recognizerST.add("numRules", grammar.getRules().size());
+		$outputFileST.add("numRules", grammar.getRules().size());
+		$headerFileST.add("numRules", grammar.getRules().size());
}
}
:	(	^( LEXER_GRAMMAR grammarSpec )
@@ -338,16 +340,16 @@ grammarSpec
:   name=ID
(	cmt=DOC_COMMENT
{
-				outputFileST.setAttribute("docComment", $cmt.text);
-				headerFileST.setAttribute("docComment", $cmt.text);
+				outputFileST.add("docComment", $cmt.text);
+				headerFileST.add("docComment", $cmt.text);
}
)?
{
-			recognizerST.setAttribute("name", grammar.getRecognizerName());
-			outputFileST.setAttribute("name", grammar.getRecognizerName());
-			headerFileST.setAttribute("name", grammar.getRecognizerName());
-			recognizerST.setAttribute("scopes", grammar.getGlobalScopes());
-			headerFileST.setAttribute("scopes", grammar.getGlobalScopes());
+			recognizerST.add("name", grammar.getRecognizerName());
+			outputFileST.add("name", grammar.getRecognizerName());
+			headerFileST.add("name", grammar.getRecognizerName());
+			recognizerST.add("scopes", grammar.getGlobalScopes());
+			headerFileST.add("scopes", grammar.getGlobalScopes());
}
( ^(OPTIONS .*) )?
( ^(IMPORT .*) )?
@@ -357,7 +359,7 @@ grammarSpec
rules[recognizerST]
;

-rules[StringTemplate recognizerST]
+rules[ST recognizerST]
@init
{
String ruleName = ((GrammarAST)input.LT(1)).getChild(0).getText();
@@ -369,9 +371,9 @@ rules[StringTemplate recognizerST]
{
if ( $rST.code != null )
{
-						recognizerST.setAttribute("rules", $rST.code);
-						outputFileST.setAttribute("rules", $rST.code);
-						headerFileST.setAttribute("rules", $rST.code);
+						recognizerST.add("rules", $rST.code);
+						outputFileST.add("rules", $rST.code);
+						headerFileST.add("rules", $rST.code);
}
}
|	^(RULE .*)
@@ -388,7 +390,7 @@ rules[StringTemplate recognizerST]
)+
;

-rule returns [StringTemplate code=null]
+rule returns [ST code=null]
@init
{
String initAction = null;
@@ -403,7 +405,7 @@ rule returns [StringTemplate code=null]

// For syn preds, we don't want any AST code etc... in there.
// Save old templates ptr and restore later.  Base templates include Dbg.
-	StringTemplateGroup saveGroup = templates;
+	STGroup saveGroup = templates;
if ( ruleDescr.isSynPred )
{
templates = generator.getBaseTemplates();
@@ -427,7 +429,7 @@ rule returns [StringTemplate code=null]
false);
description =
generator.target.getTargetStringLiteralFromString(description);
-				$b.code.setAttribute("description", description);
+				$b.code.add("description", description);
// do not generate lexer rules in combined grammar
String stName = null;
if ( ruleDescr.isSynPred )
@@ -456,9 +458,9 @@ rule returns [StringTemplate code=null]
$code = templates.getInstanceOf(stName);
if ( $code.getName().equals("rule") )
{
-					$code.setAttribute("emptyRule", grammar.isEmptyRule(block2));
+					$code.add("emptyRule", grammar.isEmptyRule(block2));
}
-				$code.setAttribute("ruleDescriptor", ruleDescr);
+				$code.add("ruleDescriptor", ruleDescr);
String memo = (String)grammar.getBlockOption($start,"memoize");
if ( memo==null )
{
@@ -467,7 +469,7 @@ rule returns [StringTemplate code=null]
if ( memo!=null && memo.equals("true") &&
(stName.equals("rule")||stName.equals("lexerRule")) )
{
-					$code.setAttribute("memoize", memo!=null && memo.equals("true"));
+					$code.add("memoize", memo!=null && memo.equals("true"));
}
}

@@ -482,24 +484,24 @@ rule returns [StringTemplate code=null]
boolean naked =
currentRuleName.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) ||
($mod.start!=null&&$mod.start.getText().equals(Grammar.FRAGMENT_RULE_MODIFIER));
-					$code.setAttribute("nakedBlock", naked);
+					$code.add("nakedBlock", naked);
}
else
{
description = grammar.grammarTreeToString($start,false);
description = generator.target.getTargetStringLiteralFromString(description);
-					$code.setAttribute("description", description);
+					$code.add("description", description);
}
Rule theRule = grammar.getRule(currentRuleName);
generator.translateActionAttributeReferencesForSingleScope(
theRule,
theRule.getActions()
);
-				$code.setAttribute("ruleName", currentRuleName);
-				$code.setAttribute("block", $b.code);
+				$code.add("ruleName", currentRuleName);
+				$code.add("block", $b.code);
if ( initAction!=null )
{
-					$code.setAttribute("initAction", initAction);
+					$code.add("initAction", initAction);
}
}
}
@@ -522,7 +524,7 @@ ruleScopeSpec
;

block[String blockTemplateName, org.antlr.analysis.DFA dfa]
-	 returns [StringTemplate code=null]
+	 returns [ST code=null]
options { k=1; }
@init
{
@@ -531,22 +533,22 @@ options { k=1; }
blockNestingLevel++;
if ( state.backtracking == 0 )
{
-		StringTemplate decision = null;
+		ST decision = null;
if ( $dfa != null )
{
$code = templates.getInstanceOf($blockTemplateName);
decision = generator.genLookaheadDecision(recognizerST,$dfa);
-			$code.setAttribute("decision", decision);
-			$code.setAttribute("decisionNumber", $dfa.getDecisionNumber());
-			$code.setAttribute("maxK",$dfa.getMaxLookaheadDepth());
-			$code.setAttribute("maxAlt",$dfa.getNumberOfAlts());
+			$code.add("decision", decision);
+			$code.add("decisionNumber", $dfa.getDecisionNumber());
+			$code.add("maxK",$dfa.getMaxLookaheadDepth());
+			$code.add("maxAlt",$dfa.getNumberOfAlts());
}
else
{
$code = templates.getInstanceOf($blockTemplateName+"SingleAlt");
}
-		$code.setAttribute("blockLevel", blockNestingLevel);
-		$code.setAttribute("enclosingBlockLevel", blockNestingLevel-1);
+		$code.add("blockLevel", blockNestingLevel);
+		$code.add("enclosingBlockLevel", blockNestingLevel-1);
altNum = 1;
if ( this.blockNestingLevel==RULE_BLOCK_NESTING_LEVEL ) {
this.outerAltNum=1;
@@ -555,7 +557,7 @@ options { k=1; }
}
:	{$start.getSetValue()!=null}? => setBlock
{
-			$code.setAttribute("alts",$setBlock.code);
+			$code.add("alts",$setBlock.code);
}

|	^(  BLOCK
@@ -576,12 +578,12 @@ options { k=1; }
firstRewriteAST.getChild(0).getType()==ETC;
if ( $rew.code!=null && !etc )
{
-						$alt.code.setAttribute("rew", $rew.code);
+						$alt.code.add("rew", $rew.code);
}
// add this alt to the list of alts for this block
-					$code.setAttribute("alts",$alt.code);
-					$alt.code.setAttribute("altNum", altNum);
-					$alt.code.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+					$code.add("alts",$alt.code);
+					$alt.code.add("altNum", altNum);
+					$alt.code.add("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
altNum++;
}
)+
@@ -590,10 +592,10 @@ options { k=1; }
;
finally { blockNestingLevel--; }

-setBlock returns [StringTemplate code=null]
+setBlock returns [ST code=null]
@init
{
-	StringTemplate setcode = null;
+	ST setcode = null;
if ( state.backtracking == 0 )
{
if ( blockNestingLevel==RULE_BLOCK_NESTING_LEVEL && grammar.buildAST() )
@@ -618,26 +620,26 @@ setBlock returns [StringTemplate code=null]
{
setcode = getTokenElementST("matchSet", "set", $s, null, null);
}
-			setcode.setAttribute("elementIndex", i);
+			setcode.add("elementIndex", i);
//if ( grammar.type!=Grammar.LEXER )
//{
//	generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
//}
-			setcode.setAttribute("s",
+			setcode.add("s",
generator.genSetExpr(templates,$s.getSetValue(),1,false));
-			StringTemplate altcode=templates.getInstanceOf("alt");
-			altcode.setAttribute("elements.{el,line,pos}",
+			ST altcode=templates.getInstanceOf("alt");
+			altcode.addAggr("elements.{el,line,pos}",
setcode,
$s.getLine(),
$s.getCharPositionInLine() + 1
);
-			altcode.setAttribute("altNum", 1);
-			altcode.setAttribute("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
+			altcode.add("altNum", 1);
+			altcode.add("outerAlt", blockNestingLevel==RULE_BLOCK_NESTING_LEVEL);
if ( !currentAltHasASTRewrite && grammar.buildAST() )
{
-				altcode.setAttribute("autoAST", true);
+				altcode.add("autoAST", true);
}
-			altcode.setAttribute("treeLevel", rewriteTreeNestingLevel);
+			altcode.add("treeLevel", rewriteTreeNestingLevel);
$code = altcode;
}
;
@@ -646,28 +648,28 @@ setAlternative
:	^(ALT setElement+ EOA)
;

-exceptionGroup[StringTemplate ruleST]
+exceptionGroup[ST ruleST]
:	( exceptionHandler[$ruleST] )+ (finallyClause[$ruleST])?
|	finallyClause[$ruleST]
;

-exceptionHandler[StringTemplate ruleST]
+exceptionHandler[ST ruleST]
:	^('catch' ARG_ACTION ACTION)
{
List chunks = generator.translateAction(currentRuleName,$ACTION);
-			$ruleST.setAttribute("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
+			$ruleST.addAggr("exceptions.{decl,action}",$ARG_ACTION.text,chunks);
}
;

-finallyClause[StringTemplate ruleST]
+finallyClause[ST ruleST]
:	^('finally' ACTION)
{
List chunks = generator.translateAction(currentRuleName,$ACTION);
-			$ruleST.setAttribute("finally",chunks);
+			$ruleST.add("finally",chunks);
}
;

-alternative returns [StringTemplate code]
+alternative returns [ST code]
@init
{
if ( state.backtracking == 0 )
@@ -680,11 +682,11 @@ alternative returns [StringTemplate code]
}
String description = grammar.grammarTreeToString($start, false);
description = generator.target.getTargetStringLiteralFromString(description);
-		$code.setAttribute("description", description);
-		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+		$code.add("description", description);
+		$code.add("treeLevel", rewriteTreeNestingLevel);
if ( !currentAltHasASTRewrite && grammar.buildAST() )
{
-			$code.setAttribute("autoAST", true);
+			$code.add("autoAST", true);
}
}
}
@@ -694,7 +696,7 @@ alternative returns [StringTemplate code]
{
if (e != null && e.code != null)
{
-						$code.setAttribute("elements.{el,line,pos}",
+						$code.addAggr("elements.{el,line,pos}",
$e.code,
$e.start.getLine(),
$e.start.getCharPositionInLine() + 1
@@ -706,7 +708,7 @@ alternative returns [StringTemplate code]
)
;

-element[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+element[GrammarAST label, GrammarAST astSuffix] returns [ST code=null]
options { k=1; }
@init
{
@@ -733,11 +735,11 @@ options { k=1; }
$code = templates.getInstanceOf("charRangeRef");
String low = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$a.text);
String high = generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$b.text);
-			$code.setAttribute("a", low);
-			$code.setAttribute("b", high);
+			$code.add("a", low);
+			$code.add("b", high);
if ( label!=null )
{
-				$code.setAttribute("label", $label.getText());
+				$code.add("label", $label.getText());
}
}

@@ -756,9 +758,9 @@ options { k=1; }
|   (sp=SEMPRED|sp=GATED_SEMPRED)
{
$code = templates.getInstanceOf("validateSemanticPredicate");
-			$code.setAttribute("pred", generator.translateAction(currentRuleName,$sp));
+			$code.add("pred", generator.translateAction(currentRuleName,$sp));
String description = generator.target.getTargetStringLiteralFromString($sp.text);
-			$code.setAttribute("description", description);
+			$code.add("description", description);
}

|	SYN_SEMPRED // used only in lookahead; don't generate validating pred
@@ -770,20 +772,20 @@ options { k=1; }
|   EPSILON
;

-element_action returns [StringTemplate code=null]
+element_action returns [ST code=null]
:	act=ACTION
{
$code = templates.getInstanceOf("execAction");
-			$code.setAttribute("action", generator.translateAction(currentRuleName,$act));
+			$code.add("action", generator.translateAction(currentRuleName,$act));
}
|	act2=FORCED_ACTION
{
$code = templates.getInstanceOf("execForcedAction");
-			$code.setAttribute("action", generator.translateAction(currentRuleName,$act2));
+			$code.add("action", generator.translateAction(currentRuleName,$act2));
}
;

-notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [ST code=null]
@init
{
IntSet elements=null;
@@ -836,9 +838,9 @@ notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [String
(GrammarAST)$n.getChild(0),
astSuffix,
labelText);
-			$code.setAttribute("s",generator.genSetExpr(templates,elements,1,false));
+			$code.add("s",generator.genSetExpr(templates,elements,1,false));
int i = ((CommonToken)n.getToken()).getTokenIndex();
-			$code.setAttribute("elementIndex", i);
+			$code.add("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
{
generator.generateLocalFOLLOW(n,"set",currentRuleName,i);
@@ -846,7 +848,7 @@ notElement[GrammarAST n, GrammarAST label, GrammarAST astSuffix] returns [String
}
;

-ebnf returns [StringTemplate code=null]
+ebnf returns [ST code=null]
@init
{
org.antlr.analysis.DFA dfa=null;
@@ -869,11 +871,11 @@ ebnf returns [StringTemplate code=null]
{
String description = grammar.grammarTreeToString($start, false);
description = generator.target.getTargetStringLiteralFromString(description);
-			$code.setAttribute("description", description);
+			$code.add("description", description);
}
;

-tree_ returns [StringTemplate code]
+tree_ returns [ST code]
@init
{
rewriteTreeNestingLevel++;
@@ -887,10 +889,10 @@ tree_ returns [StringTemplate code]
// nullable child list if we can see the UP as the next token
// we need an "if ( input.LA(1)==Token.DOWN )" gate around
// the child list.
-			$code.setAttribute("nullableChildList", "true");
+			$code.add("nullableChildList", "true");
}
-		$code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
-		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
+		$code.add("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+		$code.add("treeLevel", rewriteTreeNestingLevel);
Rule r = grammar.getRule(currentRuleName);
if ( grammar.buildAST() && !r.hasRewrite(outerAltNum) ) {
rootSuffix = new GrammarAST(ROOT,"ROOT");
@@ -900,7 +902,7 @@ tree_ returns [StringTemplate code]
:	^(	TREE_BEGIN
el=element[null,rootSuffix]
{
-				$code.setAttribute("root.{el,line,pos}",
+				$code.addAggr("root.{el,line,pos}",
$el.code,
$el.start.getLine(),
$el.start.getCharPositionInLine() + 1
@@ -912,7 +914,7 @@ tree_ returns [StringTemplate code]
(	(element_action) =>
act=element_action
{
-					$code.setAttribute("actionsAfterRoot.{el,line,pos}",
+					$code.addAggr("actionsAfterRoot.{el,line,pos}",
$act.code,
$act.start.getLine(),
$act.start.getCharPositionInLine() + 1
@@ -921,7 +923,7 @@ tree_ returns [StringTemplate code]
)*
(	 el=element[null,null]
{
-				 $code.setAttribute("children.{el,line,pos}",
+				 $code.addAggr("children.{el,line,pos}",
$el.code,
$el.start.getLine(),
$el.start.getCharPositionInLine() + 1
@@ -932,8 +934,8 @@ tree_ returns [StringTemplate code]
;
finally { rewriteTreeNestingLevel--; }

-atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
-	returns [StringTemplate code=null]
+atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
+	returns [ST code=null]
@init
{
String labelText=null;
@@ -973,23 +975,23 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
labelText = null;
}
$code = getRuleElementST("ruleRef", $r.text, $r, astSuffix, labelText);
-			$code.setAttribute("rule", rdef);
+			$code.add("rule", rdef);
if ( scope!=null ) { // scoped rule ref
Grammar scopeG = grammar.composite.getGrammar(scope.getText());
-				$code.setAttribute("scope", scopeG);
+				$code.add("scope", scopeG);
}
else if ( rdef.grammar != this.grammar ) { // nonlocal
// if rule definition is not in this grammar, it's nonlocal
List<Grammar> rdefDelegates = rdef.grammar.getDelegates();
if ( rdefDelegates.contains(this.grammar) ) {
-					$code.setAttribute("scope", rdef.grammar);
+					$code.add("scope", rdef.grammar);
}
else {
// defining grammar is not a delegate, scope all the
// back to root, which has delegate methods for all
// rules.  Don't use scope if we are root.
if ( this.grammar != rdef.grammar.composite.delegateGrammarTreeRoot.grammar ) {
-						$code.setAttribute("scope",
+						$code.add("scope",
rdef.grammar.composite.delegateGrammarTreeRoot.grammar);
}
}
@@ -997,10 +999,10 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]

if ( $rarg!=null ) {
List args = generator.translateAction(currentRuleName,$rarg);
-				$code.setAttribute("args", args);
+				$code.add("args", args);
}
int i = ((CommonToken)r.getToken()).getTokenIndex();
-			$code.setAttribute("elementIndex", i);
+			$code.add("elementIndex", i);
generator.generateLocalFOLLOW($r,$r.text,currentRuleName,i);
$r.code = $code;
}
@@ -1035,66 +1037,66 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
scopeName = scope.getText();
}
Rule rdef2 = grammar.getRule(scopeName, $t.text);
-					$code.setAttribute("rule", rdef2);
+					$code.add("rule", rdef2);
if ( scope!=null )
{ // scoped rule ref
Grammar scopeG = grammar.composite.getGrammar(scope.getText());
-						$code.setAttribute("scope", scopeG);
+						$code.add("scope", scopeG);
}
else if ( rdef2.grammar != this.grammar )
{ // nonlocal
// if rule definition is not in this grammar, it's nonlocal
-						$code.setAttribute("scope", rdef2.grammar);
+						$code.add("scope", rdef2.grammar);
}
if ( $targ!=null )
{
List args = generator.translateAction(currentRuleName,$targ);
-						$code.setAttribute("args", args);
+						$code.add("args", args);
}
}
int i = ((CommonToken)$t.getToken()).getTokenIndex();
-				$code.setAttribute("elementIndex", i);
+				$code.add("elementIndex", i);
if ( label!=null )
-					$code.setAttribute("label", labelText);
+					$code.add("label", labelText);
}
else
{
$code = getTokenElementST("tokenRef", $t.text, $t, astSuffix, labelText);
String tokenLabel =
generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.getText()));
-				$code.setAttribute("token",tokenLabel);
+				$code.add("token",tokenLabel);
if ( !currentAltHasASTRewrite && $t.terminalOptions!=null )
-				{
-					$code.setAttribute("terminalOptions", $t.terminalOptions);
+				{
+					$code.add("terminalOptions", $t.terminalOptions);
}
int i = ((CommonToken)$t.getToken()).getTokenIndex();
-				$code.setAttribute("elementIndex", i);
+				$code.add("elementIndex", i);
generator.generateLocalFOLLOW($t,tokenLabel,currentRuleName,i);
}
$t.code = $code;
}

-	|	c=CHAR_LITERAL
+	|	c=CHAR_LITERAL
{
if ( grammar.type==Grammar.LEXER )
{
$code = templates.getInstanceOf("charRef");
-				$code.setAttribute("char",
+				$code.add("char",
generator.target.getTargetCharLiteralFromANTLRCharLiteral(generator,$c.text));
if ( label!=null )
{
-					$code.setAttribute("label", labelText);
+					$code.add("label", labelText);
}
}
else { // else it's a token type reference
$code = getTokenElementST("tokenRef", "char_literal", $c, astSuffix, labelText);
String tokenLabel = generator.getTokenTypeAsTargetLabel(grammar.getTokenType($c.text));
-				$code.setAttribute("token",tokenLabel);
+				$code.add("token",tokenLabel);
if ( $c.terminalOptions!=null ) {
-					$code.setAttribute("terminalOptions",$c.terminalOptions);
+					$code.add("terminalOptions",$c.terminalOptions);
}
int i = ((CommonToken)$c.getToken()).getTokenIndex();
-				$code.setAttribute("elementIndex", i);
+				$code.add("elementIndex", i);
generator.generateLocalFOLLOW($c,tokenLabel,currentRuleName,i);
}
}
@@ -1105,12 +1107,12 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
if ( grammar.type==Grammar.LEXER )
{
$code = templates.getInstanceOf("lexerStringRef");
-				$code.setAttribute("string",
+				$code.add("string",
generator.target.getTargetStringLiteralFromANTLRStringLiteral(generator,$s.text));
-				$code.setAttribute("elementIndex", i);
+				$code.add("elementIndex", i);
if ( label!=null )
{
-					$code.setAttribute("label", labelText);
+					$code.add("label", labelText);
}
}
else
@@ -1119,12 +1121,12 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
$code = getTokenElementST("tokenRef", "string_literal", $s, astSuffix, labelText);
String tokenLabel =
generator.getTokenTypeAsTargetLabel(grammar.getTokenType($s.text));
-				$code.setAttribute("token",tokenLabel);
+				$code.add("token",tokenLabel);
if ( $s.terminalOptions!=null )
{
-					$code.setAttribute("terminalOptions",$s.terminalOptions);
+					$code.add("terminalOptions",$s.terminalOptions);
}
-				$code.setAttribute("elementIndex", i);
+				$code.add("elementIndex", i);
generator.generateLocalFOLLOW($s,tokenLabel,currentRuleName,i);
}
}
@@ -1132,7 +1134,7 @@ atom[GrammarAST scope, GrammarAST label, GrammarAST astSuffix]
|	w=WILDCARD
{
$code = getWildcardST($w,astSuffix,labelText);
-			$code.setAttribute("elementIndex", ((CommonToken)$w.getToken()).getTokenIndex());
+			$code.add("elementIndex", ((CommonToken)$w.getToken()).getTokenIndex());
}

|	^(DOT ID a=atom[$ID, label, astSuffix]) // scope override on rule or token
@@ -1147,7 +1149,7 @@ ast_suffix
|	BANG
;

-set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
+set[GrammarAST label, GrammarAST astSuffix] returns [ST code=null]
@init
{
String labelText=null;
@@ -1160,12 +1162,12 @@ set[GrammarAST label, GrammarAST astSuffix] returns [StringTemplate code=null]
{
$code = getTokenElementST("matchSet", "set", $s, astSuffix, labelText);
int i = ((CommonToken)$s.getToken()).getTokenIndex();
-			$code.setAttribute("elementIndex", i);
+			$code.add("elementIndex", i);
if ( grammar.type!=Grammar.LEXER )
{
generator.generateLocalFOLLOW($s,"set",currentRuleName,i);
}
-			$code.setAttribute("s", generator.genSetExpr(templates,$s.getSetValue(),1,false));
+			$code.add("s", generator.genSetExpr(templates,$s.getSetValue(),1,false));
}
;

@@ -1178,7 +1180,7 @@ setElement

// REWRITE stuff

-rewrite returns [StringTemplate code=null]
+rewrite returns [ST code=null]
@init
{
if ( state.backtracking == 0 )
@@ -1192,9 +1194,9 @@ rewrite returns [StringTemplate code=null]
else
{
$code = templates.getInstanceOf("rewriteCode");
-				$code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
-				$code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
-				$code.setAttribute("referencedElementsDeep",
+				$code.add("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.add("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.add("referencedElementsDeep",
getTokenTypesAsTargetLabels($start.rewriteRefsDeep));
Set<String> tokenLabels =
grammar.getLabels($start.rewriteRefsDeep, Grammar.TOKEN_LABEL);
@@ -1210,21 +1212,21 @@ rewrite returns [StringTemplate code=null]
grammar.getLabels($start.rewriteRefsDeep, Grammar.WILDCARD_TREE_LIST_LABEL);
// just in case they ref $r for "previous value", make a stream
// from retval.tree
-				StringTemplate retvalST = templates.getInstanceOf("prevRuleRootRef");
-				ruleLabels.add(retvalST.toString());
-				$code.setAttribute("referencedTokenLabels", tokenLabels);
-				$code.setAttribute("referencedTokenListLabels", tokenListLabels);
-				$code.setAttribute("referencedRuleLabels", ruleLabels);
-				$code.setAttribute("referencedRuleListLabels", ruleListLabels);
-				$code.setAttribute("referencedWildcardLabels", wildcardLabels);
-				$code.setAttribute("referencedWildcardListLabels", wildcardListLabels);
+				ST retvalST = templates.getInstanceOf("prevRuleRootRef");
+				ruleLabels.add(retvalST.render());
+				$code.add("referencedTokenLabels", tokenLabels);
+				$code.add("referencedTokenListLabels", tokenListLabels);
+				$code.add("referencedRuleLabels", ruleLabels);
+				$code.add("referencedRuleListLabels", ruleListLabels);
+				$code.add("referencedWildcardLabels", wildcardLabels);
+				$code.add("referencedWildcardListLabels", wildcardListLabels);
}
}
else
{
$code = templates.getInstanceOf("noRewrite");
-				$code.setAttribute("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
-				$code.setAttribute("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.add("treeLevel", OUTER_REWRITE_NESTING_LEVEL);
+				$code.add("rewriteBlockLevel", OUTER_REWRITE_NESTING_LEVEL);
}
}
}
@@ -1243,7 +1245,7 @@ rewrite returns [StringTemplate code=null]
String description =
grammar.grammarTreeToString($r,false);
description = generator.target.getTargetStringLiteralFromString(description);
-					$code.setAttribute("alts.{pred,alt,description}",
+					$code.addAggr("alts.{pred,alt,description}",
predChunks,
alt,
description);
@@ -1254,40 +1256,40 @@ rewrite returns [StringTemplate code=null]
|
;

-rewrite_block[String blockTemplateName] returns [StringTemplate code=null]
+rewrite_block[String blockTemplateName] returns [ST code=null]
@init
{
rewriteBlockNestingLevel++;
-	StringTemplate save_currentBlockST = currentBlockST;
+	ST save_currentBlockST = currentBlockST;
if ( state.backtracking == 0 )
{
$code = templates.getInstanceOf(blockTemplateName);
currentBlockST = $code;
-		$code.setAttribute("rewriteBlockLevel", rewriteBlockNestingLevel);
+		$code.add("rewriteBlockLevel", rewriteBlockNestingLevel);
}
}
:	^(	BLOCK
{
-				currentBlockST.setAttribute("referencedElementsDeep",
+				currentBlockST.add("referencedElementsDeep",
getTokenTypesAsTargetLabels($BLOCK.rewriteRefsDeep));
-				currentBlockST.setAttribute("referencedElements",
+				currentBlockST.add("referencedElements",
getTokenTypesAsTargetLabels($BLOCK.rewriteRefsShallow));
}
alt=rewrite_alternative
EOB
)
{
-			$code.setAttribute("alt", $alt.code);
+			$code.add("alt", $alt.code);
}
;
finally { rewriteBlockNestingLevel--; currentBlockST = save_currentBlockST; }

-rewrite_alternative returns [StringTemplate code=null]
+rewrite_alternative returns [ST code=null]
:	{generator.grammar.buildAST()}?
^(	a=ALT {$code=templates.getInstanceOf("rewriteElementList");}
(	(
el=rewrite_element
-					{$code.setAttribute("elements.{el,line,pos}",
+					{$code.addAggr("elements.{el,line,pos}",
$el.code,
$el.start.getLine(),
$el.start.getCharPositionInLine() + 1
@@ -1295,7 +1297,7 @@ rewrite_alternative returns [StringTemplate code=null]
}
)+
|	EPSILON
-				{$code.setAttribute("elements.{el,line,pos}",
+				{$code.addAggr("elements.{el,line,pos}",
templates.getInstanceOf("rewriteEmptyAlt"),
$a.getLine(),
$a.getCharPositionInLine() + 1
@@ -1312,7 +1314,7 @@ rewrite_alternative returns [StringTemplate code=null]
ETC
;

-rewrite_element returns [StringTemplate code=null]
+rewrite_element returns [ST code=null]
@init
{
IntSet elements=null;
@@ -1326,45 +1328,45 @@ rewrite_element returns [StringTemplate code=null]
{ $code = $rewrite_tree.code; }
;

-rewrite_ebnf returns [StringTemplate code=null]
+rewrite_ebnf returns [ST code=null]
:	^( OPTIONAL rewrite_block["rewriteOptionalBlock"] )
{ $code = $rewrite_block.code; }
{
String description = grammar.grammarTreeToString($start, false);
description = generator.target.getTargetStringLiteralFromString(description);
-			$code.setAttribute("description", description);
+			$code.add("description", description);
}
|	^( CLOSURE rewrite_block["rewriteClosureBlock"] )
{ $code = $rewrite_block.code; }
{
String description = grammar.grammarTreeToString($start, false);
description = generator.target.getTargetStringLiteralFromString(description);
-			$code.setAttribute("description", description);
+			$code.add("description", description);
}
|	^( POSITIVE_CLOSURE rewrite_block["rewritePositiveClosureBlock"] )
{ $code = $rewrite_block.code; }
{
String description = grammar.grammarTreeToString($start, false);
description = generator.target.getTargetStringLiteralFromString(description);
-			$code.setAttribute("description", description);
+			$code.add("description", description);
}
;

-rewrite_tree returns [StringTemplate code]
+rewrite_tree returns [ST code]
@init
{
rewriteTreeNestingLevel++;
if ( state.backtracking == 0 )
{
$code = templates.getInstanceOf("rewriteTree");
-		$code.setAttribute("treeLevel", rewriteTreeNestingLevel);
-		$code.setAttribute("enclosingTreeLevel", rewriteTreeNestingLevel-1);
+		$code.add("treeLevel", rewriteTreeNestingLevel);
+		$code.add("enclosingTreeLevel", rewriteTreeNestingLevel-1);
}
}
:	^(	TREE_BEGIN
r=rewrite_atom[true]
{
-				$code.setAttribute("root.{el,line,pos}",
+				$code.addAggr("root.{el,line,pos}",
$r.code,
$r.start.getLine(),
$r.start.getCharPositionInLine() + 1
@@ -1373,7 +1375,7 @@ rewrite_tree returns [StringTemplate code]
(
el=rewrite_element
{
-				$code.setAttribute("children.{el,line,pos}",
+				$code.addAggr("children.{el,line,pos}",
$el.code,
$el.start.getLine(),
$el.start.getCharPositionInLine() + 1
@@ -1384,12 +1386,12 @@ rewrite_tree returns [StringTemplate code]
{
String description = grammar.grammarTreeToString($start, false);
description = generator.target.getTargetStringLiteralFromString(description);
-			$code.setAttribute("description", description);
+			$code.add("description", description);
}
;
finally { rewriteTreeNestingLevel--; }

-rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
+rewrite_atom[boolean isRoot] returns [ST code=null]
:   r=RULE_REF
{
String ruleRefName = $r.text;
@@ -1399,14 +1401,14 @@ rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
stName += "Root";
}
$code = templates.getInstanceOf(stName);
-			$code.setAttribute("rule", ruleRefName);
+			$code.add("rule", ruleRefName);
if ( grammar.getRule(ruleRefName)==null )
{
ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,
grammar,
((GrammarAST)($r)).getToken(),
ruleRefName);
-				$code = new StringTemplate(); // blank; no code gen
+				$code = new ST(""); // blank; no code gen
}
else if ( grammar.getRule(currentRuleName)
.getRuleRefsInAlt(ruleRefName,outerAltNum)==null )
@@ -1415,7 +1417,7 @@ rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
grammar,
((GrammarAST)($r)).getToken(),
ruleRefName);
-				$code = new StringTemplate(); // blank; no code gen
+				$code = new ST(); // blank; no code gen
}
else
{
@@ -1450,23 +1452,23 @@ rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
stName += "Root";
}
$code = templates.getInstanceOf(stName);
-			$code.setAttribute("terminalOptions",term.terminalOptions);
+			$code.add("terminalOptions",term.terminalOptions);
if ( $arg!=null )
{
List args = generator.translateAction(currentRuleName,$arg);
-				$code.setAttribute("args", args);
+				$code.add("args", args);
}
-			$code.setAttribute("elementIndex", ((CommonToken)$start.getToken()).getTokenIndex());
+			$code.add("elementIndex", ((CommonToken)$start.getToken()).getTokenIndex());
int ttype = grammar.getTokenType(tokenName);
String tok = generator.getTokenTypeAsTargetLabel(ttype);
-			$code.setAttribute("token", tok);
+			$code.add("token", tok);
if ( grammar.getTokenType(tokenName)==Label.INVALID )
{
ErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_TOKEN_REF_IN_REWRITE,
grammar,
((GrammarAST)($start)).getToken(),
tokenName);
-				$code = new StringTemplate(); // blank; no code gen
+				$code = new ST(); // blank; no code gen
}
}

@@ -1486,9 +1488,9 @@ rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
((GrammarAST)($LABEL)).getToken(),
labelName);
}
-				StringTemplate labelST = templates.getInstanceOf("prevRuleRootRef");
+				ST labelST = templates.getInstanceOf("prevRuleRootRef");
$code = templates.getInstanceOf("rewriteRuleLabelRef"+(isRoot?"Root":""));
-				$code.setAttribute("label", labelST);
+				$code.add("label", labelST);
}
else if ( pair==null )
{
@@ -1496,7 +1498,7 @@ rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
grammar,
((GrammarAST)($LABEL)).getToken(),
labelName);
-				$code = new StringTemplate();
+				$code = new ST();
}
else
{
@@ -1527,7 +1529,7 @@ rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
stName += "Root";
}
$code = templates.getInstanceOf(stName);
-				$code.setAttribute("label", labelName);
+				$code.add("label", labelName);
}
}

@@ -1537,12 +1539,12 @@ rewrite_atom[boolean isRoot] returns [StringTemplate code=null]
String actText = $ACTION.text;
List chunks = generator.translateAction(currentRuleName,$ACTION);
$code = templates.getInstanceOf("rewriteNodeAction"+(isRoot?"Root":""));
-			$code.setAttribute("action", chunks);
+			$code.add("action", chunks);
}
;

public
-rewrite_template returns [StringTemplate code=null]
+rewrite_template returns [ST code=null]
:	^( ALT EPSILON EOA ) {$code=templates.getInstanceOf("rewriteEmptyTemplate");}
|	^(	TEMPLATE (id=ID|ind=ACTION)
{
@@ -1553,13 +1555,13 @@ rewrite_template returns [StringTemplate code=null]
else if ( $id!=null )
{
$code = templates.getInstanceOf("rewriteExternalTemplate");
-						$code.setAttribute("name", $id.text);
+						$code.add("name", $id.text);
}
else if ( $ind!=null )
{ // must be \%({expr})(args)
$code = templates.getInstanceOf("rewriteIndirectTemplate");
List chunks=generator.translateAction(currentRuleName,$ind);
-					$code.setAttribute("expr", chunks);
+					$code.add("expr", chunks);
}
}
^(	ARGLIST
@@ -1570,7 +1572,7 @@ rewrite_template returns [StringTemplate code=null]
// broken up yet into trees.
$a.outerAltNum = this.outerAltNum;
List chunks = generator.translateAction(currentRuleName,$a);
-						$code.setAttribute("args.{name,value}", $arg.text, chunks);
+						$code.addAggr("args.{name,value}", $arg.text, chunks);
}
)
)*
@@ -1580,14 +1582,14 @@ rewrite_template returns [StringTemplate code=null]
String sl = $DOUBLE_QUOTE_STRING_LITERAL.text;
String t = sl.substring( 1, sl.length() - 1 ); // strip quotes
t = generator.target.getTargetStringLiteralFromString(t);
-					$code.setAttribute("template",t);
+					$code.add("template",t);
}
|	DOUBLE_ANGLE_STRING_LITERAL
{
String sl = $DOUBLE_ANGLE_STRING_LITERAL.text;
String t = sl.substring( 2, sl.length() - 2 ); // strip double angle quotes
t = generator.target.getTargetStringLiteralFromString(t);
-					$code.setAttribute("template",t);
+					$code.add("template",t);
}
)?
)
@@ -1597,7 +1599,7 @@ rewrite_template returns [StringTemplate code=null]
// set alt num for same reason as ARGLIST above
$act.outerAltNum = this.outerAltNum;
$code=templates.getInstanceOf("rewriteAction");
-			$code.setAttribute("action",
+			$code.add("action",
generator.translateAction(currentRuleName,$act));
}
;
diff --git a/tool/src/main/java/org/antlr/Tool.java b/tool/src/main/java/org/antlr/Tool.java
index 8f3b9d6..0dd4fe0 100644
--- a/tool/src/main/java/org/antlr/Tool.java
+++ b/tool/src/main/java/org/antlr/Tool.java
@@ -32,6 +32,7 @@ import org.antlr.codegen.CodeGenerator;
import org.antlr.misc.Graph;
import org.antlr.runtime.misc.Stats;
import org.antlr.tool.*;
+import org.stringtemplate.v4.STGroup;

import java.io.*;
import java.util.*;
@@ -66,7 +67,9 @@ public class Tool {
/** Don't process grammar file if generated files are newer than grammar */
private boolean make = false;
private boolean showBanner = true;
-    private static boolean exitNow = false;
+	private static boolean exitNow = false;
+	private static boolean return_dont_exit = false;
+

public String forcedLanguageOption; // -language L on command line

@@ -88,6 +91,7 @@ public class Tool {

if (!exitNow) {
antlr.process();
+			if ( return_dont_exit ) return;
if (ErrorManager.getNumErrors() > 0) {
System.exit(1);
}
@@ -127,14 +131,12 @@ public class Tool {
}

public Tool(String[] args) {
+		STGroup.iterateAcrossValues = true; // ST v3 compatibility with Maps

loadResources();

// Set all the options and pick up all the named grammar files
-        //
processArgs(args);
-
-
}

public void processArgs(String[] args) {
@@ -270,7 +272,9 @@ public class Tool {
internalOption_watchNFAConversion = true;
}
else if (args[i].equals("-XdbgST")) {
-                CodeGenerator.EMIT_TEMPLATE_DELIMITERS = true;
+                CodeGenerator.LAUNCH_ST_INSPECTOR = true;
+				STGroup.trackCreationEvents = true;
+				return_dont_exit = true;
}
else if (args[i].equals("-Xmaxinlinedfastates")) {
if (i + 1 >= args.length) {
@@ -592,7 +596,7 @@ public class Tool {
public Grammar getRootGrammar(String grammarFileName)
throws IOException
{
-        //StringTemplate.setLintMode(true);
+        //ST.setLintMode(true);
// grammars mentioned on command line are either roots or single grammars.
// create the necessary composite in case it's got delegates; even
// single grammar needs it to get token types.
diff --git a/tool/src/main/java/org/antlr/analysis/DFA.java b/tool/src/main/java/org/antlr/analysis/DFA.java
index 9bd29f6..896acc7 100644
--- a/tool/src/main/java/org/antlr/analysis/DFA.java
+++ b/tool/src/main/java/org/antlr/analysis/DFA.java
@@ -32,7 +32,7 @@ import org.antlr.misc.IntSet;
import org.antlr.misc.IntervalSet;
import org.antlr.misc.Utils;
import org.antlr.runtime.IntStream;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.*;

import java.util.*;
@@ -446,7 +446,7 @@ public class DFA {
// now that we have computed list of specialStates, gen code for 'em
for (int i = 0; i < specialStates.size(); i++) {
DFAState ss = (DFAState) specialStates.get(i);
-			StringTemplate stateST =
+			ST stateST =
generator.generateSpecialState(ss);
specialStateSTs.add(stateST);
}
diff --git a/tool/src/main/java/org/antlr/analysis/SemanticContext.java b/tool/src/main/java/org/antlr/analysis/SemanticContext.java
index 838902b..a639175 100644
--- a/tool/src/main/java/org/antlr/analysis/SemanticContext.java
+++ b/tool/src/main/java/org/antlr/analysis/SemanticContext.java
@@ -29,8 +29,8 @@ package org.antlr.analysis;

import org.antlr.codegen.CodeGenerator;
import org.antlr.grammar.v3.ANTLRParser;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
import org.antlr.tool.Grammar;
import org.antlr.tool.GrammarAST;

@@ -75,8 +75,8 @@ public abstract class SemanticContext {
/** Generate an expression that will evaluate the semantic context,
*  given a set of output templates.
*/
-	public abstract StringTemplate genExpr(CodeGenerator generator,
-										   StringTemplateGroup templates,
+	public abstract ST genExpr(CodeGenerator generator,
+										   STGroup templates,
DFA dfa);

public abstract boolean hasUserSemanticPredicate(); // user-specified sempred {}? or {}?=>
@@ -155,11 +155,11 @@ public abstract class SemanticContext {
return predicateAST.getText().hashCode();
}

-		public StringTemplate genExpr(CodeGenerator generator,
-									  StringTemplateGroup templates,
+		public ST genExpr(CodeGenerator generator,
+									  STGroup templates,
DFA dfa)
{
-			StringTemplate eST = null;
+			ST eST = null;
if ( templates!=null ) {
if ( synpred ) {
eST = templates.getInstanceOf("evalSynPredicate");
@@ -176,21 +176,21 @@ public abstract class SemanticContext {
// Currently I don't warn you about this as it could be annoying.
// I do the translation anyway.
*/
-				//eST.setAttribute("pred", this.toString());
+				//eST.add("pred", this.toString());
if ( generator!=null ) {
-					eST.setAttribute("pred",
+					eST.add("pred",
generator.translateAction(predEnclosingRuleName,predicateAST));
}
}
else {
-				eST = new StringTemplate("$pred$");
-				eST.setAttribute("pred", this.toString());
+				eST = new ST("<pred>");
+				eST.add("pred", this.toString());
return eST;
}
if ( generator!=null ) {
String description =
generator.target.getTargetStringLiteralFromString(this.toString());
-				eST.setAttribute("description", description);
+				eST.add("description", description);
}
return eST;
}
@@ -235,14 +235,14 @@ public abstract class SemanticContext {
this.constantValue = TRUE_PRED;
}

-		public StringTemplate genExpr(CodeGenerator generator,
-									  StringTemplateGroup templates,
+		public ST genExpr(CodeGenerator generator,
+									  STGroup templates,
DFA dfa)
{
if ( templates!=null ) {
-				return templates.getInstanceOf("true");
+				return templates.getInstanceOf("true_value");
}
-			return new StringTemplate("true");
+			return new ST("true");
}

@Override
@@ -261,14 +261,14 @@ public abstract class SemanticContext {
super();
this.constantValue = FALSE_PRED;
}
-		public StringTemplate genExpr(CodeGenerator generator,
-									  StringTemplateGroup templates,
+		public ST genExpr(CodeGenerator generator,
+									  STGroup templates,
DFA dfa)
{
if ( templates!=null ) {
return templates.getInstanceOf("false");
}
-			return new StringTemplate("false");
+			return new ST("false");
}
public String toString() {
return "false"; // not used for code gen, just DOT and print outs
@@ -282,19 +282,19 @@ public abstract class SemanticContext {
this.left = a;
this.right = b;
}
-		public StringTemplate genExpr(CodeGenerator generator,
-									  StringTemplateGroup templates,
+		public ST genExpr(CodeGenerator generator,
+									  STGroup templates,
DFA dfa)
{
-			StringTemplate eST = null;
+			ST eST = null;
if ( templates!=null ) {
eST = templates.getInstanceOf("andPredicates");
}
else {
-				eST = new StringTemplate("($left$&&$right$)");
+				eST = new ST("(<left>&&<right>)");
}
-			eST.setAttribute("left", left.genExpr(generator,templates,dfa));
-			eST.setAttribute("right", right.genExpr(generator,templates,dfa));
+			eST.add("left", left.genExpr(generator,templates,dfa));
+			eST.add("right", right.genExpr(generator,templates,dfa));
return eST;
}
public SemanticContext getGatedPredicateContext() {
@@ -343,20 +343,21 @@ public abstract class SemanticContext {
operands.add(b);
}
}
-		public StringTemplate genExpr(CodeGenerator generator,
-									  StringTemplateGroup templates,
+		public ST genExpr(CodeGenerator generator,
+									  STGroup templates,
DFA dfa)
{
-			StringTemplate eST = null;
+			ST eST = null;
if ( templates!=null ) {
eST = templates.getInstanceOf("orPredicates");
}
else {
-				eST = new StringTemplate("($first(operands)$$rest(operands):{o | ||$o$}$)");
+				// looks like these are called during testing
+				eST = new ST("(<first(operands)><rest(operands):{o | ||<o>}>)");
}
for (Iterator it = operands.iterator(); it.hasNext();) {
SemanticContext semctx = (SemanticContext) it.next();
-				eST.setAttribute("operands", semctx.genExpr(generator,templates,dfa));
+				eST.add("operands", semctx.genExpr(generator,templates,dfa));
}
return eST;
}
@@ -419,18 +420,18 @@ public abstract class SemanticContext {
public NOT(SemanticContext ctx) {
this.ctx = ctx;
}
-		public StringTemplate genExpr(CodeGenerator generator,
-									  StringTemplateGroup templates,
+		public ST genExpr(CodeGenerator generator,
+									  STGroup templates,
DFA dfa)
{
-			StringTemplate eST = null;
+			ST eST = null;
if ( templates!=null ) {
eST = templates.getInstanceOf("notPredicate");
}
else {
-				eST = new StringTemplate("?!($pred$)");
+				eST = new ST("!(<pred>)");
}
-			eST.setAttribute("pred", ctx.genExpr(generator,templates,dfa));
+			eST.add("pred", ctx.genExpr(generator,templates,dfa));
return eST;
}
public SemanticContext getGatedPredicateContext() {
diff --git a/tool/src/main/java/org/antlr/codegen/ACyclicDFACodeGenerator.java b/tool/src/main/java/org/antlr/codegen/ACyclicDFACodeGenerator.java
index 96b6c14..6bc5fd3 100644
--- a/tool/src/main/java/org/antlr/codegen/ACyclicDFACodeGenerator.java
+++ b/tool/src/main/java/org/antlr/codegen/ACyclicDFACodeGenerator.java
@@ -29,8 +29,8 @@ package org.antlr.codegen;

import org.antlr.analysis.*;
import org.antlr.misc.Utils;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;

import java.util.List;

@@ -41,22 +41,22 @@ public class ACyclicDFACodeGenerator {
this.parentGenerator = parent;
}

-	public StringTemplate genFixedLookaheadDecision(StringTemplateGroup templates,
+	public ST genFixedLookaheadDecision(STGroup templates,
DFA dfa)
{
return walkFixedDFAGeneratingStateMachine(templates, dfa, dfa.startState, 1);
}

-	protected StringTemplate walkFixedDFAGeneratingStateMachine(
-			StringTemplateGroup templates,
+	protected ST walkFixedDFAGeneratingStateMachine(
+			STGroup templates,
DFA dfa,
DFAState s,
int k)
{
//System.out.println("walk "+s.stateNumber+" in dfa for decision "+dfa.decisionNumber);
if ( s.isAcceptState() ) {
-			StringTemplate dfaST = templates.getInstanceOf("dfaAcceptState");
-			dfaST.setAttribute("alt", Utils.integer(s.getUniquelyPredictedAlt()));
+			ST dfaST = templates.getInstanceOf("dfaAcceptState");
+			dfaST.add("alt", Utils.integer(s.getUniquelyPredictedAlt()));
return dfaST;
}

@@ -73,23 +73,23 @@ public class ACyclicDFACodeGenerator {
dfaEdgeName = "dfaEdgeSwitch";
}

-		StringTemplate dfaST = templates.getInstanceOf(dfaStateName);
+		ST dfaST = templates.getInstanceOf(dfaStateName);
if ( dfa.getNFADecisionStartState().decisionStateType==NFAState.LOOPBACK ) {
dfaST = templates.getInstanceOf(dfaLoopbackStateName);
}
else if ( dfa.getNFADecisionStartState().decisionStateType==NFAState.OPTIONAL_BLOCK_START ) {
dfaST = templates.getInstanceOf(dfaOptionalBlockStateName);
}
-		dfaST.setAttribute("k", Utils.integer(k));
-		dfaST.setAttribute("stateNumber", Utils.integer(s.stateNumber));
-		dfaST.setAttribute("semPredState",
+		dfaST.add("k", Utils.integer(k));
+		dfaST.add("stateNumber", Utils.integer(s.stateNumber));
+		dfaST.add("semPredState",
Boolean.valueOf(s.isResolvedWithPredicates()));
/*
String description = dfa.getNFADecisionStartState().getDescription();
description = parentGenerator.target.getTargetStringLiteralFromString(description);
//System.out.println("DFA: "+description+" associated with AST "+dfa.getNFADecisionStartState());
if ( description!=null ) {
-			dfaST.setAttribute("description", description);
+			dfaST.add("description", description);
}
*/
int EOTPredicts = NFA.INVALID_ALT_NUMBER;
@@ -110,9 +110,9 @@ public class ACyclicDFACodeGenerator {
*/
continue;
}
-			StringTemplate edgeST = templates.getInstanceOf(dfaEdgeName);
+			ST edgeST = templates.getInstanceOf(dfaEdgeName);
// If the template wants all the label values delineated, do that
-			if ( edgeST.getFormalArgument("labels")!=null ) {
+			if ( edgeST.impl.formalArguments.get("labels")!=null ) {
List labels = edge.label.getSet().toList();
for (int j = 0; j < labels.size(); j++) {
Integer vI = (Integer) labels.get(j);
@@ -120,10 +120,10 @@ public class ACyclicDFACodeGenerator {
parentGenerator.getTokenTypeAsTargetLabel(vI.intValue());
labels.set(j, label); // rewrite List element to be name
}
-				edgeST.setAttribute("labels", labels);
+				edgeST.add("labels", labels);
}
else { // else create an expression to evaluate (the general case)
-				edgeST.setAttribute("labelExpr",
+				edgeST.add("labelExpr",
parentGenerator.genLabelExpr(templates,edge,k));
}

@@ -134,20 +134,20 @@ public class ACyclicDFACodeGenerator {
target.getGatedPredicatesInNFAConfigurations();
if ( preds!=null ) {
//System.out.println("preds="+target.getGatedPredicatesInNFAConfigurations());
-					StringTemplate predST = preds.genExpr(parentGenerator,
+					ST predST = preds.genExpr(parentGenerator,
parentGenerator.getTemplates(),
dfa);
-					edgeST.setAttribute("predicates", predST);
+					edgeST.add("predicates", predST);
}
}

-			StringTemplate targetST =
+			ST targetST =
walkFixedDFAGeneratingStateMachine(templates,
dfa,
(DFAState)edge.target,
k+1);
-			edgeST.setAttribute("targetState", targetST);
-			dfaST.setAttribute("edges", edgeST);
+			edgeST.add("targetState", targetST);
+			dfaST.add("edges", edgeST);
/*
System.out.println("back to DFA "+
dfa.decisionNumber+"."+s.stateNumber);
@@ -157,7 +157,7 @@ public class ACyclicDFACodeGenerator {
// HANDLE EOT EDGE
if ( EOTPredicts!=NFA.INVALID_ALT_NUMBER ) {
// EOT unique predicts an alt
-			dfaST.setAttribute("eotPredictsAlt", Utils.integer(EOTPredicts));
+			dfaST.add("eotPredictsAlt", Utils.integer(EOTPredicts));
}
else if ( EOTTarget!=null && EOTTarget.getNumberOfTransitions()>0 ) {
// EOT state has transitions so must split on predicates.
@@ -170,18 +170,18 @@ public class ACyclicDFACodeGenerator {
// hoisted up to the state that has the EOT edge.
for (int i = 0; i < EOTTarget.getNumberOfTransitions(); i++) {
Transition predEdge = (Transition)EOTTarget.transition(i);
-				StringTemplate edgeST = templates.getInstanceOf(dfaEdgeName);
-				edgeST.setAttribute("labelExpr",
+				ST edgeST = templates.getInstanceOf(dfaEdgeName);
+				edgeST.add("labelExpr",
parentGenerator.genSemanticPredicateExpr(templates,predEdge));
// the target must be an accept state
//System.out.println("EOT edge");
-				StringTemplate targetST =
+				ST targetST =
walkFixedDFAGeneratingStateMachine(templates,
dfa,
(DFAState)predEdge.target,
k+1);
-				edgeST.setAttribute("targetState", targetST);
-				dfaST.setAttribute("edges", edgeST);
+				edgeST.add("targetState", targetST);
+				dfaST.add("edges", edgeST);
}
}
return dfaST;
diff --git a/tool/src/main/java/org/antlr/codegen/ActionScriptTarget.java b/tool/src/main/java/org/antlr/codegen/ActionScriptTarget.java
index c0e0b34..4e2943b 100644
--- a/tool/src/main/java/org/antlr/codegen/ActionScriptTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/ActionScriptTarget.java
@@ -28,7 +28,7 @@
package org.antlr.codegen;

import org.antlr.Tool;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.Grammar;

public class ActionScriptTarget extends Target {
@@ -123,11 +123,11 @@ public class ActionScriptTarget extends Target {
buf.append(digits);
}

-    protected StringTemplate chooseWhereCyclicDFAsGo(Tool tool,
+    protected ST chooseWhereCyclicDFAsGo(Tool tool,
CodeGenerator generator,
Grammar grammar,
-                                                     StringTemplate recognizerST,
-                                                     StringTemplate cyclicDFAST) {
+                                                     ST recognizerST,
+                                                     ST cyclicDFAST) {
return recognizerST;
}
}
diff --git a/tool/src/main/java/org/antlr/codegen/CPPTarget.java b/tool/src/main/java/org/antlr/codegen/CPPTarget.java
index a020a2a..22962e0 100644
--- a/tool/src/main/java/org/antlr/codegen/CPPTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/CPPTarget.java
@@ -28,8 +28,8 @@
package org.antlr.codegen;

import org.antlr.Tool;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
import org.antlr.tool.Grammar;

import java.io.IOException;
@@ -86,11 +86,10 @@ public class CPPTarget extends Target {
protected void genRecognizerHeaderFile(Tool tool,
CodeGenerator generator,
Grammar grammar,
-										   StringTemplate headerFileST,
+										   ST headerFileST,
String extName)
throws IOException
{
-		StringTemplateGroup templates = generator.getTemplates();
generator.write(headerFileST, grammar.name+extName);
}

diff --git a/tool/src/main/java/org/antlr/codegen/CSharp2Target.java b/tool/src/main/java/org/antlr/codegen/CSharp2Target.java
index 33cbf06..7403787 100644
--- a/tool/src/main/java/org/antlr/codegen/CSharp2Target.java
+++ b/tool/src/main/java/org/antlr/codegen/CSharp2Target.java
@@ -28,7 +28,7 @@
package org.antlr.codegen;

import org.antlr.Tool;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.Grammar;

public class CSharp2Target extends Target
diff --git a/tool/src/main/java/org/antlr/codegen/CTarget.java b/tool/src/main/java/org/antlr/codegen/CTarget.java
index cbbde29..51911c3 100644
--- a/tool/src/main/java/org/antlr/codegen/CTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/CTarget.java
@@ -28,7 +28,7 @@
package org.antlr.codegen;

import org.antlr.Tool;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.Grammar;

import java.io.IOException;
@@ -42,13 +42,13 @@ public class CTarget extends Target {
protected void genRecognizerFile(Tool tool,
CodeGenerator generator,
Grammar grammar,
-            StringTemplate outputFileST)
+            ST outputFileST)
throws IOException {

// Before we write this, and cause it to generate its string,
// we need to add all the string literals that we are going to match
//
-        outputFileST.setAttribute("literals", strings);
+        outputFileST.add("literals", strings);
String fileName = generator.getRecognizerFileName(grammar.name, grammar.type);
generator.write(outputFileST, fileName);
}
@@ -57,7 +57,7 @@ public class CTarget extends Target {
protected void genRecognizerHeaderFile(Tool tool,
CodeGenerator generator,
Grammar grammar,
-            StringTemplate headerFileST,
+            ST headerFileST,
String extName)
throws IOException {
// Pick up the file name we are generating. This method will return a
@@ -70,11 +70,11 @@ public class CTarget extends Target {
generator.write(headerFileST, fileName);
}

-    protected StringTemplate chooseWhereCyclicDFAsGo(Tool tool,
+    protected ST chooseWhereCyclicDFAsGo(Tool tool,
CodeGenerator generator,
Grammar grammar,
-            StringTemplate recognizerST,
-            StringTemplate cyclicDFAST) {
+            ST recognizerST,
+            ST cyclicDFAST) {
return recognizerST;
}

diff --git a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
index 31946ed..61c85ec 100644
--- a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
+++ b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
@@ -39,20 +39,18 @@ import org.antlr.misc.BitSet;
import org.antlr.misc.*;
import org.antlr.runtime.*;
import org.antlr.runtime.tree.CommonTreeNodeStream;
-import org.antlr.runtime.tree.Tree;
-import org.antlr.stringtemplate.*;
-import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
+import org.stringtemplate.v4.*;
import org.antlr.tool.*;
+import org.stringtemplate.v4.AutoIndentWriter;

import java.io.IOException;
-import java.io.StringReader;
import java.io.Writer;
import java.util.*;

/** ANTLR's code generator.
*
*  Generate recognizers derived from grammars.  Language independence
- *  achieved through the use of StringTemplateGroup objects.  All output
+ *  achieved through the use of STGroup objects.  All output
*  strings are completely encapsulated in the group files such as Java.stg.
*  Some computations are done that are unused by a particular language.
*  This generator just computes and sets the values into the templates;
@@ -84,7 +82,7 @@ public class CodeGenerator {
public final static int MSA_DEFAULT = 3;
public static int MIN_SWITCH_ALTS = MSA_DEFAULT;
public boolean GENERATE_SWITCHES_WHEN_POSSIBLE = true;
-	public static boolean EMIT_TEMPLATE_DELIMITERS = false;
+	public static boolean LAUNCH_ST_INSPECTOR = false;
public final static int MADSI_DEFAULT = 60; // do lots of states inline (needed for expression rules)
public static int MAX_ACYCLIC_DFA_STATES_INLINE = MADSI_DEFAULT;

@@ -105,17 +103,17 @@ public class CodeGenerator {
public Target target = null;

/** Where are the templates this generator should use to generate code? */
-	protected StringTemplateGroup templates;
+	protected STGroup templates;

/** The basic output templates without AST or templates stuff; this will be
*  the templates loaded for the language such as Java.stg *and* the Dbg
*  stuff if turned on.  This is used for generating syntactic predicates.
*/
-	protected StringTemplateGroup baseTemplates;
+	protected STGroup baseTemplates;

-	protected StringTemplate recognizerST;
-	protected StringTemplate outputFileST;
-	protected StringTemplate headerFileST;
+	protected ST recognizerST;
+	protected ST outputFileST;
+	protected ST headerFileST;

/** Used to create unique labels */
protected int uniqueLabelNumber = 1;
@@ -150,8 +148,8 @@ public class CodeGenerator {

public static final String VOCAB_FILE_EXTENSION = ".tokens";
protected final static String vocabFilePattern =
-		"<tokens:{<attr.name>=<attr.type>\n}>" +
-		"<literals:{<attr.name>=<attr.type>\n}>";
+		"<tokens:{it|<it.name>=<it.type>\n}>" +
+		"<literals:{it|<it.name>=<it.type>\n}>";

public CodeGenerator(Tool tool, Grammar grammar, String language) {
this.tool = tool;
@@ -185,20 +183,8 @@ public class CodeGenerator {

/** load the main language.stg template group file */
public void loadTemplates(String language) {
-		// get a group loader containing main templates dir and target subdir
-		String templateDirs =
-			classpathTemplateRootDirectoryName+":"+
-			classpathTemplateRootDirectoryName+"/"+language;
-		//System.out.println("targets="+templateDirs.toString());
-		StringTemplateGroupLoader loader =
-			new CommonGroupLoader(templateDirs,
-								  ErrorManager.getStringTemplateErrorListener());
-		StringTemplateGroup.registerGroupLoader(loader);
-		StringTemplateGroup.registerDefaultLexer(AngleBracketTemplateLexer.class);
-
-		// first load main language template
-		StringTemplateGroup coreTemplates =
-			StringTemplateGroup.loadGroup(language);
+		String langDir = classpathTemplateRootDirectoryName+"/"+language;
+		STGroup coreTemplates = new STGroupFile(langDir+"/"+language+".stg");
baseTemplates = coreTemplates;
if ( coreTemplates ==null ) {
ErrorManager.error(ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES,
@@ -211,69 +197,63 @@ public class CodeGenerator {
String outputOption = (String)grammar.getOption("output");
if ( outputOption!=null && outputOption.equals("AST") ) {
if ( debug && grammar.type!=Grammar.LEXER ) {
-				StringTemplateGroup dbgTemplates =
-					StringTemplateGroup.loadGroup("Dbg", coreTemplates);
+				STGroup dbgTemplates = new STGroupFile(langDir+"/Dbg.stg");
+				dbgTemplates.importTemplates(coreTemplates);
baseTemplates = dbgTemplates;
-				StringTemplateGroup astTemplates =
-					StringTemplateGroup.loadGroup("AST",dbgTemplates);
-				StringTemplateGroup astParserTemplates = astTemplates;
-				//if ( !grammar.rewriteMode() ) {
-					if ( grammar.type==Grammar.TREE_PARSER ) {
-						astParserTemplates =
-							StringTemplateGroup.loadGroup("ASTTreeParser", astTemplates);
-					}
-					else {
-						astParserTemplates =
-							StringTemplateGroup.loadGroup("ASTParser", astTemplates);
-					}
-				//}
-				StringTemplateGroup astDbgTemplates =
-					StringTemplateGroup.loadGroup("ASTDbg", astParserTemplates);
+				STGroup astTemplates = new STGroupFile(langDir+"/AST.stg");
+				astTemplates.importTemplates(dbgTemplates);
+				STGroup astParserTemplates = astTemplates;
+				if ( grammar.type==Grammar.TREE_PARSER ) {
+					astParserTemplates = new STGroupFile(langDir+"/ASTTreeParser.stg");
+					astParserTemplates.importTemplates(astTemplates);
+				}
+				else {
+					astParserTemplates = new STGroupFile(langDir+"/ASTParser.stg");
+					astParserTemplates.importTemplates(astTemplates);
+				}
+				STGroup astDbgTemplates = new STGroupFile(langDir+"/ASTDbg.stg");
+				astDbgTemplates.importTemplates(astParserTemplates);
templates = astDbgTemplates;
}
else {
-				StringTemplateGroup astTemplates =
-					StringTemplateGroup.loadGroup("AST", coreTemplates);
-				StringTemplateGroup astParserTemplates = astTemplates;
-				//if ( !grammar.rewriteMode() ) {
-					if ( grammar.type==Grammar.TREE_PARSER ) {
-						astParserTemplates =
-							StringTemplateGroup.loadGroup("ASTTreeParser", astTemplates);
-					}
-					else {
-						astParserTemplates =
-							StringTemplateGroup.loadGroup("ASTParser", astTemplates);
-					}
-				//}
+				STGroup astTemplates = new STGroupFile(langDir+"/AST.stg");
+				astTemplates.importTemplates(coreTemplates);
+				STGroup astParserTemplates = astTemplates;
+				if ( grammar.type==Grammar.TREE_PARSER ) {
+					astParserTemplates = new STGroupFile(langDir+"/ASTTreeParser.stg");
+					astParserTemplates.importTemplates(astTemplates);
+				}
+				else {
+					astParserTemplates = new STGroupFile(langDir+"/ASTParser.stg");
+					astParserTemplates.importTemplates(astTemplates);
+				}
templates = astParserTemplates;
}
}
else if ( outputOption!=null && outputOption.equals("template") ) {
if ( debug && grammar.type!=Grammar.LEXER ) {
-				StringTemplateGroup dbgTemplates =
-					StringTemplateGroup.loadGroup("Dbg", coreTemplates);
+				STGroup dbgTemplates = new STGroupFile(langDir+"/Dbg.stg");
+				dbgTemplates.importTemplates(coreTemplates);
baseTemplates = dbgTemplates;
-				StringTemplateGroup stTemplates =
-					StringTemplateGroup.loadGroup("ST",dbgTemplates);
+				STGroup stTemplates = new STGroupFile(langDir+"/ST.stg");
+				stTemplates.importTemplates(dbgTemplates);
templates = stTemplates;
}
else {
-				templates = StringTemplateGroup.loadGroup("ST", coreTemplates);
+				STGroup stTemplates = new STGroupFile(langDir+"/ST.stg");
+				stTemplates.importTemplates(coreTemplates);
+				templates = stTemplates;
}
}
else if ( debug && grammar.type!=Grammar.LEXER ) {
-			templates = StringTemplateGroup.loadGroup("Dbg", coreTemplates);
+			STGroup dbgTemplates = new STGroupFile(langDir+"/Dbg.stg");
+			dbgTemplates.importTemplates(coreTemplates);
+			templates = dbgTemplates;
baseTemplates = templates;
}
else {
templates = coreTemplates;
}
-
-		if ( EMIT_TEMPLATE_DELIMITERS ) {
-			templates.emitDebugStartStopStrings(true);
-			templates.doNotEmitDebugStringsForTemplate("codeFileExtension");
-			templates.doNotEmitDebugStringsForTemplate("headerFileExtension");
-		}
}

/** Given the grammar to which we are attached, walk the AST associated
@@ -288,7 +268,7 @@ public class CodeGenerator {
*
*  The target, such as JavaTarget, dictates which files get written.
*/
-	public StringTemplate genRecognizer() {
+	public ST genRecognizer() {
//System.out.println("### generate "+grammar.name+" recognizer");
// LOAD OUTPUT TEMPLATES
loadTemplates(language);
@@ -321,8 +301,9 @@ public class CodeGenerator {
}
else {
// create a dummy to avoid null-checks all over code generator
-			headerFileST = new StringTemplate(templates,"");
-			headerFileST.setName("dummy-header-file");
+			headerFileST = new ST(templates,"xyz");
+			headerFileST.add("cyclicDFAs", (Object)null); // it normally sees this from outputFile
+			//headerFileST.impl.name = "dummy-header-file";
}

boolean filterMode = grammar.getOption("filter")!=null &&
@@ -343,7 +324,7 @@ public class CodeGenerator {
// translate $x::y references
translateActionAttributeReferences(actions);

-        StringTemplate gateST = templates.getInstanceOf("actionGate");
+        ST gateST = templates.getInstanceOf("actionGate");
if ( filterMode ) {
// if filtering, we need to set actions to execute at backtracking
// level 1 not 0.
@@ -351,76 +332,76 @@ public class CodeGenerator {
}
grammar.setSynPredGateIfNotAlready(gateST);

-        headerFileST.setAttribute("actions", actions);
-		outputFileST.setAttribute("actions", actions);
+        headerFileST.add("actions", actions);
+		outputFileST.add("actions", actions);

-		headerFileST.setAttribute("buildTemplate", new Boolean(grammar.buildTemplate()));
-		outputFileST.setAttribute("buildTemplate", new Boolean(grammar.buildTemplate()));
-		headerFileST.setAttribute("buildAST", new Boolean(grammar.buildAST()));
-		outputFileST.setAttribute("buildAST", new Boolean(grammar.buildAST()));
+		headerFileST.add("buildTemplate", new Boolean(grammar.buildTemplate()));
+		outputFileST.add("buildTemplate", new Boolean(grammar.buildTemplate()));
+		headerFileST.add("buildAST", new Boolean(grammar.buildAST()));
+		outputFileST.add("buildAST", new Boolean(grammar.buildAST()));

-		outputFileST.setAttribute("rewriteMode", Boolean.valueOf(grammar.rewriteMode()));
-		headerFileST.setAttribute("rewriteMode", Boolean.valueOf(grammar.rewriteMode()));
+		outputFileST.add("rewriteMode", Boolean.valueOf(grammar.rewriteMode()));
+		headerFileST.add("rewriteMode", Boolean.valueOf(grammar.rewriteMode()));

-		outputFileST.setAttribute("backtracking", Boolean.valueOf(canBacktrack));
-		headerFileST.setAttribute("backtracking", Boolean.valueOf(canBacktrack));
+		outputFileST.add("backtracking", Boolean.valueOf(canBacktrack));
+		headerFileST.add("backtracking", Boolean.valueOf(canBacktrack));
// turn on memoize attribute at grammar level so we can create ruleMemo.
// each rule has memoize attr that hides this one, indicating whether
// it needs to save results
String memoize = (String)grammar.getOption("memoize");
-		outputFileST.setAttribute("memoize",
-								  (grammar.atLeastOneRuleMemoizes||
-								  Boolean.valueOf(memoize!=null&&memoize.equals("true"))&&
-									          canBacktrack));
-		headerFileST.setAttribute("memoize",
-								  (grammar.atLeastOneRuleMemoizes||
-								  Boolean.valueOf(memoize!=null&&memoize.equals("true"))&&
-									          canBacktrack));
+		outputFileST.add("memoize",
+						 (grammar.atLeastOneRuleMemoizes ||
+						  Boolean.valueOf(memoize != null && memoize.equals("true")) &&
+						  canBacktrack));
+		headerFileST.add("memoize",
+						 (grammar.atLeastOneRuleMemoizes ||
+						  Boolean.valueOf(memoize != null && memoize.equals("true")) &&
+						  canBacktrack));


-		outputFileST.setAttribute("trace", Boolean.valueOf(trace));
-		headerFileST.setAttribute("trace", Boolean.valueOf(trace));
+		outputFileST.add("trace", Boolean.valueOf(trace));
+		headerFileST.add("trace", Boolean.valueOf(trace));

-		outputFileST.setAttribute("profile", Boolean.valueOf(profile));
-		headerFileST.setAttribute("profile", Boolean.valueOf(profile));
+		outputFileST.add("profile", Boolean.valueOf(profile));
+		headerFileST.add("profile", Boolean.valueOf(profile));

// RECOGNIZER
if ( grammar.type==Grammar.LEXER ) {
recognizerST = templates.getInstanceOf("lexer");
-			outputFileST.setAttribute("LEXER", Boolean.valueOf(true));
-			headerFileST.setAttribute("LEXER", Boolean.valueOf(true));
-			recognizerST.setAttribute("filterMode",
-									  Boolean.valueOf(filterMode));
+			outputFileST.add("LEXER", Boolean.valueOf(true));
+			headerFileST.add("LEXER", Boolean.valueOf(true));
+			recognizerST.add("filterMode",
+							 Boolean.valueOf(filterMode));
}
else if ( grammar.type==Grammar.PARSER ||
grammar.type==Grammar.COMBINED )
{
recognizerST = templates.getInstanceOf("parser");
-			outputFileST.setAttribute("PARSER", Boolean.valueOf(true));
-			headerFileST.setAttribute("PARSER", Boolean.valueOf(true));
+			outputFileST.add("PARSER", Boolean.valueOf(true));
+			headerFileST.add("PARSER", Boolean.valueOf(true));
}
else {
recognizerST = templates.getInstanceOf("treeParser");
-			outputFileST.setAttribute("TREE_PARSER", Boolean.valueOf(true));
-			headerFileST.setAttribute("TREE_PARSER", Boolean.valueOf(true));
-            recognizerST.setAttribute("filterMode",
-                                      Boolean.valueOf(filterMode));
-		}
-		outputFileST.setAttribute("recognizer", recognizerST);
-		headerFileST.setAttribute("recognizer", recognizerST);
-		outputFileST.setAttribute("actionScope",
-								  grammar.getDefaultActionScope(grammar.type));
-		headerFileST.setAttribute("actionScope",
-								  grammar.getDefaultActionScope(grammar.type));
+			outputFileST.add("TREE_PARSER", Boolean.valueOf(true));
+			headerFileST.add("TREE_PARSER", Boolean.valueOf(true));
+            recognizerST.add("filterMode",
+							 Boolean.valueOf(filterMode));
+		}
+		outputFileST.add("recognizer", recognizerST);
+		headerFileST.add("recognizer", recognizerST);
+		outputFileST.add("actionScope",
+						 grammar.getDefaultActionScope(grammar.type));
+		headerFileST.add("actionScope",
+						 grammar.getDefaultActionScope(grammar.type));

String targetAppropriateFileNameString =
target.getTargetStringLiteralFromString(grammar.getFileName());
-		outputFileST.setAttribute("fileName", targetAppropriateFileNameString);
-		headerFileST.setAttribute("fileName", targetAppropriateFileNameString);
-		outputFileST.setAttribute("ANTLRVersion", tool.VERSION);
-		headerFileST.setAttribute("ANTLRVersion", tool.VERSION);
-		outputFileST.setAttribute("generatedTimestamp", Tool.getCurrentTimeStamp());
-		headerFileST.setAttribute("generatedTimestamp", Tool.getCurrentTimeStamp());
+		outputFileST.add("fileName", targetAppropriateFileNameString);
+		headerFileST.add("fileName", targetAppropriateFileNameString);
+		outputFileST.add("ANTLRVersion", tool.VERSION);
+		headerFileST.add("ANTLRVersion", tool.VERSION);
+		outputFileST.add("generatedTimestamp", Tool.getCurrentTimeStamp());
+		headerFileST.add("generatedTimestamp", Tool.getCurrentTimeStamp());

// GENERATE RECOGNIZER
// Walk the AST holding the input grammar, this time generating code
@@ -454,22 +435,27 @@ public class CodeGenerator {
if ( grammar.synPredNamesUsedInDFA.size()>0 ) {
synpredNames = grammar.synPredNamesUsedInDFA;
}
-		outputFileST.setAttribute("synpreds", synpredNames);
-		headerFileST.setAttribute("synpreds", synpredNames);
+		outputFileST.add("synpreds", synpredNames);
+		headerFileST.add("synpreds", synpredNames);

// all recognizers can see Grammar object
-		recognizerST.setAttribute("grammar", grammar);
+		recognizerST.add("grammar", grammar);
+
+		if (LAUNCH_ST_INSPECTOR) {
+			outputFileST.inspect();
+			if ( templates.isDefined("headerFile") ) headerFileST.inspect();
+		}

// WRITE FILES
try {
target.genRecognizerFile(tool,this,grammar,outputFileST);
if ( templates.isDefined("headerFile") ) {
-				StringTemplate extST = templates.getInstanceOf("headerFileExtension");
-				target.genRecognizerHeaderFile(tool,this,grammar,headerFileST,extST.toString());
+				ST extST = templates.getInstanceOf("headerFileExtension");
+				target.genRecognizerHeaderFile(tool,this,grammar,headerFileST,extST.render());
}
// write out the vocab interchange file; used by antlr,
// does not change per target
-			StringTemplate tokenVocabSerialization = genTokenVocabOutput();
+			ST tokenVocabSerialization = genTokenVocabOutput();
String vocabFileName = getVocabFileName();
if ( vocabFileName!=null ) {
write(tokenVocabSerialization, vocabFileName);
@@ -606,24 +592,24 @@ public class CodeGenerator {
long w = words[j];
wordStrings[j] = target.getTarget64BitStringFromValue(w);
}
-        recognizerST.setAttribute("bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
-                referencedElementName,
-                enclosingRuleName,
-                wordStrings,
-                tokenTypeList,
-                Utils.integer(elementIndex));
-        outputFileST.setAttribute("bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
-                referencedElementName,
-                enclosingRuleName,
-                wordStrings,
-                tokenTypeList,
-                Utils.integer(elementIndex));
-        headerFileST.setAttribute("bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
-                referencedElementName,
-                enclosingRuleName,
-                wordStrings,
-                tokenTypeList,
-                Utils.integer(elementIndex));
+		recognizerST.addAggr("bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
+							 referencedElementName,
+							 enclosingRuleName,
+							 wordStrings,
+							 tokenTypeList,
+							 Utils.integer(elementIndex));
+		outputFileST.addAggr("bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
+							 referencedElementName,
+							 enclosingRuleName,
+							 wordStrings,
+							 tokenTypeList,
+							 Utils.integer(elementIndex));
+		headerFileST.addAggr("bitsets.{name,inName,bits,tokenTypes,tokenIndex}",
+							 referencedElementName,
+							 enclosingRuleName,
+							 wordStrings,
+							 tokenTypeList,
+							 Utils.integer(elementIndex));
}

// L O O K A H E A D  D E C I S I O N  G E N E R A T I O N
@@ -635,10 +621,10 @@ public class CodeGenerator {
*
*  Regardless, the output file and header file get a copy of the DFAs.
*/
-	public StringTemplate genLookaheadDecision(StringTemplate recognizerST,
-											   DFA dfa)
+	public ST genLookaheadDecision(ST recognizerST,
+								   DFA dfa)
{
-		StringTemplate decisionST;
+		ST decisionST;
// If we are doing inline DFA and this one is acyclic and LL(*)
// I have to check for is-non-LL(*) because if non-LL(*) the cyclic
// check is not done by DFA.verify(); that is, verify() avoids
@@ -650,16 +636,16 @@ public class CodeGenerator {
else {
// generate any kind of DFA here (cyclic or acyclic)
dfa.createStateTables(this);
-			outputFileST.setAttribute("cyclicDFAs", dfa);
-			headerFileST.setAttribute("cyclicDFAs", dfa);
+			outputFileST.add("cyclicDFAs", dfa);
+			headerFileST.add("cyclicDFAs", dfa);
decisionST = templates.getInstanceOf("dfaDecision");
String description = dfa.getNFADecisionStartState().getDescription();
description = target.getTargetStringLiteralFromString(description);
if ( description!=null ) {
-				decisionST.setAttribute("description", description);
+				decisionST.add("description", description);
}
-			decisionST.setAttribute("decisionNumber",
-									Utils.integer(dfa.getDecisionNumber()));
+			decisionST.add("decisionNumber",
+						   Utils.integer(dfa.getDecisionNumber()));
}
return decisionST;
}
@@ -670,64 +656,64 @@ public class CodeGenerator {
*  because if you get here, the state is super complicated and needs an
*  if-then-else.  This is used by the new DFA scheme created June 2006.
*/
-	public StringTemplate generateSpecialState(DFAState s) {
-		StringTemplate stateST;
+	public ST generateSpecialState(DFAState s) {
+		ST stateST;
stateST = templates.getInstanceOf("cyclicDFAState");
-		stateST.setAttribute("needErrorClause", Boolean.valueOf(true));
-		stateST.setAttribute("semPredState",
-							 Boolean.valueOf(s.isResolvedWithPredicates()));
-		stateST.setAttribute("stateNumber", s.stateNumber);
-		stateST.setAttribute("decisionNumber", s.dfa.decisionNumber);
+		stateST.add("needErrorClause", Boolean.valueOf(true));
+		stateST.add("semPredState",
+					Boolean.valueOf(s.isResolvedWithPredicates()));
+		stateST.add("stateNumber", s.stateNumber);
+		stateST.add("decisionNumber", s.dfa.decisionNumber);

boolean foundGatedPred = false;
-		StringTemplate eotST = null;
+		ST eotST = null;
for (int i = 0; i < s.getNumberOfTransitions(); i++) {
Transition edge = (Transition) s.transition(i);
-			StringTemplate edgeST;
+			ST edgeST;
if ( edge.label.getAtom()==Label.EOT ) {
// this is the default clause; has to held until last
edgeST = templates.getInstanceOf("eotDFAEdge");
-				stateST.removeAttribute("needErrorClause");
+				stateST.remove("needErrorClause");
eotST = edgeST;
}
else {
edgeST = templates.getInstanceOf("cyclicDFAEdge");
-				StringTemplate exprST =
+				ST exprST =
genLabelExpr(templates,edge,1);
-				edgeST.setAttribute("labelExpr", exprST);
+				edgeST.add("labelExpr", exprST);
}
-			edgeST.setAttribute("edgeNumber", Utils.integer(i+1));
-			edgeST.setAttribute("targetStateNumber",
-								 Utils.integer(edge.target.stateNumber));
+			edgeST.add("edgeNumber", Utils.integer(i + 1));
+			edgeST.add("targetStateNumber",
+					   Utils.integer(edge.target.stateNumber));
// stick in any gated predicates for any edge if not already a pred
if ( !edge.label.isSemanticPredicate() ) {
DFAState t = (DFAState)edge.target;
SemanticContext preds =	t.getGatedPredicatesInNFAConfigurations();
if ( preds!=null ) {
foundGatedPred = true;
-					StringTemplate predST = preds.genExpr(this,
+					ST predST = preds.genExpr(this,
getTemplates(),
t.dfa);
-					edgeST.setAttribute("predicates", predST.toString());
+					edgeST.add("predicates", predST.render());
}
}
if ( edge.label.getAtom()!=Label.EOT ) {
-				stateST.setAttribute("edges", edgeST);
+				stateST.add("edges", edgeST);
}
}
if ( foundGatedPred ) {
// state has >= 1 edge with a gated pred (syn or sem)
// must rewind input first, set flag.
-			stateST.setAttribute("semPredState", new Boolean(foundGatedPred));
+			stateST.add("semPredState", new Boolean(foundGatedPred));
}
if ( eotST!=null ) {
-			stateST.setAttribute("edges", eotST);
+			stateST.add("edges", eotST);
}
return stateST;
}

/** Generate an expression for traversing an edge. */
-	protected StringTemplate genLabelExpr(StringTemplateGroup templates,
+	protected ST genLabelExpr(STGroup templates,
Transition edge,
int k)
{
@@ -739,14 +725,14 @@ public class CodeGenerator {
return genSetExpr(templates, label.getSet(), k, true);
}
// must be simple label
-		StringTemplate eST = templates.getInstanceOf("lookaheadTest");
-		eST.setAttribute("atom", getTokenTypeAsTargetLabel(label.getAtom()));
-		eST.setAttribute("atomAsInt", Utils.integer(label.getAtom()));
-		eST.setAttribute("k", Utils.integer(k));
+		ST eST = templates.getInstanceOf("lookaheadTest");
+		eST.add("atom", getTokenTypeAsTargetLabel(label.getAtom()));
+		eST.add("atomAsInt", Utils.integer(label.getAtom()));
+		eST.add("k", Utils.integer(k));
return eST;
}

-	protected StringTemplate genSemanticPredicateExpr(StringTemplateGroup templates,
+	protected ST genSemanticPredicateExpr(STGroup templates,
Transition edge)
{
DFA dfa = ((DFAState)edge.target).dfa; // which DFA are we in
@@ -758,7 +744,7 @@ public class CodeGenerator {
/** For intervals such as [3..3, 30..35], generate an expression that
*  tests the lookahead similar to LA(1)==3 || (LA(1)>=30&&LA(1)<=35)
*/
-	public StringTemplate genSetExpr(StringTemplateGroup templates,
+	public ST genSetExpr(STGroup templates,
IntSet set,
int k,
boolean partOfDFA)
@@ -768,8 +754,8 @@ public class CodeGenerator {
}
IntervalSet iset = (IntervalSet)set;
if ( iset.getIntervals()==null || iset.getIntervals().size()==0 ) {
-			StringTemplate emptyST = new StringTemplate(templates, "");
-			emptyST.setName("empty-set-expr");
+			ST emptyST = new ST(templates, "");
+			emptyST.impl.name = "empty-set-expr";
return emptyST;
}
String testSTName = "lookaheadTest";
@@ -778,30 +764,30 @@ public class CodeGenerator {
testSTName = "isolatedLookaheadTest";
testRangeSTName = "isolatedLookaheadRangeTest";
}
-		StringTemplate setST = templates.getInstanceOf("setTest");
+		ST setST = templates.getInstanceOf("setTest");
Iterator iter = iset.getIntervals().iterator();
int rangeNumber = 1;
while (iter.hasNext()) {
Interval I = (Interval) iter.next();
int a = I.a;
int b = I.b;
-			StringTemplate eST;
+			ST eST;
if ( a==b ) {
eST = templates.getInstanceOf(testSTName);
-				eST.setAttribute("atom", getTokenTypeAsTargetLabel(a));
-				eST.setAttribute("atomAsInt", Utils.integer(a));
-				//eST.setAttribute("k",Utils.integer(k));
+				eST.add("atom", getTokenTypeAsTargetLabel(a));
+				eST.add("atomAsInt", Utils.integer(a));
+				//eST.add("k",Utils.integer(k));
}
else {
eST = templates.getInstanceOf(testRangeSTName);
-				eST.setAttribute("lower",getTokenTypeAsTargetLabel(a));
-				eST.setAttribute("lowerAsInt", Utils.integer(a));
-				eST.setAttribute("upper",getTokenTypeAsTargetLabel(b));
-				eST.setAttribute("upperAsInt", Utils.integer(b));
-				eST.setAttribute("rangeNumber",Utils.integer(rangeNumber));
+				eST.add("lower", getTokenTypeAsTargetLabel(a));
+				eST.add("lowerAsInt", Utils.integer(a));
+				eST.add("upper", getTokenTypeAsTargetLabel(b));
+				eST.add("upperAsInt", Utils.integer(b));
+				eST.add("rangeNumber", Utils.integer(rangeNumber));
}
-			eST.setAttribute("k",Utils.integer(k));
-			setST.setAttribute("ranges", eST);
+			eST.add("k", Utils.integer(k));
+			setST.add("ranges", eST);
rangeNumber++;
}
return setST;
@@ -813,7 +799,7 @@ public class CodeGenerator {
*  code template.  This is not the token vocab interchange file, but
*  rather a list of token type ID needed by the recognizer.
*/
-	protected void genTokenTypeConstants(StringTemplate code) {
+	protected void genTokenTypeConstants(ST code) {
// make constants for the token types
Iterator tokenIDs = grammar.getTokenIDs().iterator();
while (tokenIDs.hasNext()) {
@@ -823,7 +809,7 @@ public class CodeGenerator {
tokenType>=Label.MIN_TOKEN_TYPE )
{
// don't do FAUX labels 'cept EOF
-				code.setAttribute("tokens.{name,type}", tokenID, Utils.integer(tokenType));
+				code.addAggr("tokens.{name,type}", tokenID, Utils.integer(tokenType));
}
}
}
@@ -831,12 +817,12 @@ public class CodeGenerator {
/** Generate a token names table that maps token type to a printable
*  name: either the label like INT or the literal like "begin".
*/
-	protected void genTokenTypeNames(StringTemplate code) {
+	protected void genTokenTypeNames(ST code) {
for (int t=Label.MIN_TOKEN_TYPE; t<=grammar.getMaxTokenType(); t++) {
String tokenName = grammar.getTokenDisplayName(t);
if ( tokenName!=null ) {
tokenName=target.getTargetStringLiteralFromString(tokenName, true);
-				code.setAttribute("tokenNames", tokenName);
+				code.add("tokenNames", tokenName);
}
}
}
@@ -866,18 +852,18 @@ public class CodeGenerator {
*
*  This is independent of the target language; used by antlr internally
*/
-	protected StringTemplate genTokenVocabOutput() {
-		StringTemplate vocabFileST =
-			new StringTemplate(vocabFilePattern,
-							   AngleBracketTemplateLexer.class);
-		vocabFileST.setName("vocab-file");
+	protected ST genTokenVocabOutput() {
+		ST vocabFileST = new ST(vocabFilePattern);
+		vocabFileST.add("literals",(Object)null); // "define" literals arg
+		vocabFileST.add("tokens",(Object)null);
+		vocabFileST.impl.name = "vocab-file";
// make constants for the token names
Iterator tokenIDs = grammar.getTokenIDs().iterator();
while (tokenIDs.hasNext()) {
String tokenID = (String) tokenIDs.next();
int tokenType = grammar.getTokenType(tokenID);
if ( tokenType>=Label.MIN_TOKEN_TYPE ) {
-				vocabFileST.setAttribute("tokens.{name,type}", tokenID, Utils.integer(tokenType));
+				vocabFileST.addAggr("tokens.{name,type}", tokenID, Utils.integer(tokenType));
}
}

@@ -887,7 +873,7 @@ public class CodeGenerator {
String literal = (String) literals.next();
int tokenType = grammar.getTokenType(literal);
if ( tokenType>=Label.MIN_TOKEN_TYPE ) {
-				vocabFileST.setAttribute("tokens.{name,type}", literal, Utils.integer(tokenType));
+				vocabFileST.addAggr("tokens.{name,type}", literal, Utils.integer(tokenType));
}
}

@@ -908,15 +894,15 @@ public class CodeGenerator {

/** Translate an action like [3,"foo",a[3]] and return a List of the
*  translated actions.  Because actions are themselves translated to a list
-	 *  of chunks, must cat together into a StringTemplate>.  Don't translate
+	 *  of chunks, must cat together into a ST>.  Don't translate
*  to strings early as we need to eval templates in context.
*/
-	public List<StringTemplate> translateArgAction(String ruleName,
+	public List<ST> translateArgAction(String ruleName,
GrammarAST actionTree)
{
String actionText = actionTree.token.getText();
List<String> args = getListOfArgumentsFromAction(actionText,',');
-		List<StringTemplate> translatedArgs = new ArrayList<StringTemplate>();
+		List<ST> translatedArgs = new ArrayList<ST>();
for (String arg : args) {
if ( arg!=null ) {
Token actionToken =
@@ -927,9 +913,8 @@ public class CodeGenerator {
actionTree.outerAltNum);
List chunks = translator.translateToChunks();
chunks = target.postProcessAction(chunks, actionToken);
-				StringTemplate catST = new StringTemplate(templates, "<chunks>");
-				catST.setAttribute("chunks", chunks);
-				templates.createStringTemplate();
+				ST catST = new ST(templates, "<chunks>");
+				catST.add("chunks", chunks);
translatedArgs.add(catST);
}
}
@@ -1041,7 +1026,7 @@ public class CodeGenerator {
*  an action, translate it to the appropriate template constructor
*  from the templateLib. This translates a *piece* of the action.
*/
-	public StringTemplate translateTemplateConstructor(String ruleName,
+	public ST translateTemplateConstructor(String ruleName,
int outerAltNum,
Token actionToken,
String templateActionText)
@@ -1072,7 +1057,7 @@ public class CodeGenerator {
gen.init(grammar);
gen.setCurrentRuleName(ruleName);
gen.setOuterAltNum(outerAltNum);
-		StringTemplate st = null;
+		ST st = null;
try {
st = gen.rewrite_template();
}
@@ -1210,11 +1195,11 @@ public class CodeGenerator {

// M I S C

-	public StringTemplateGroup getTemplates() {
+	public STGroup getTemplates() {
return templates;
}

-	public StringTemplateGroup getBaseTemplates() {
+	public STGroup getBaseTemplates() {
return baseTemplates;
}

@@ -1233,7 +1218,7 @@ public class CodeGenerator {
}
}

-	public StringTemplate getRecognizerST() {
+	public ST getRecognizerST() {
return outputFileST;
}

@@ -1241,9 +1226,9 @@ public class CodeGenerator {
*  just use T.java as output regardless of type.
*/
public String getRecognizerFileName(String name, int type) {
-		StringTemplate extST = templates.getInstanceOf("codeFileExtension");
+		ST extST = templates.getInstanceOf("codeFileExtension");
String recognizerName = grammar.getRecognizerName();
-		return recognizerName+extST.toString();
+		return recognizerName+extST.render();
/*
String suffix = "";
if ( type==Grammar.COMBINED ||
@@ -1265,16 +1250,16 @@ public class CodeGenerator {
return grammar.name+VOCAB_FILE_EXTENSION;
}

-	public void write(StringTemplate code, String fileName) throws IOException {
+	public void write(ST code, String fileName) throws IOException {
long start = System.currentTimeMillis();
Writer w = tool.getOutputFile(grammar, fileName);
// Write the output to a StringWriter
-		StringTemplateWriter wr = templates.getStringTemplateWriter(w);
+		STWriter wr = new AutoIndentWriter(w);
wr.setLineWidth(lineWidth);
code.write(wr);
w.close();
long stop = System.currentTimeMillis();
-		//System.out.println("render time for "+fileName+": "+(int)(stop-start)+"ms");
+		System.out.println("render time for "+fileName+": "+(int)(stop-start)+"ms");
}

/** You can generate a switch rather than if-then-else for a DFA state
diff --git a/tool/src/main/java/org/antlr/codegen/DelphiTarget.java b/tool/src/main/java/org/antlr/codegen/DelphiTarget.java
index 408c20e..24bb819 100644
--- a/tool/src/main/java/org/antlr/codegen/DelphiTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/DelphiTarget.java
@@ -30,7 +30,7 @@ package org.antlr.codegen;
import org.antlr.Tool;
import org.antlr.analysis.Label;
import org.antlr.misc.Utils;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.Grammar;

public class DelphiTarget extends Target
@@ -46,11 +46,11 @@ public class DelphiTarget extends Target
targetCharValueEscape['"'] = "'";
}

-  protected StringTemplate chooseWhereCyclicDFAsGo(Tool tool,
+  protected ST chooseWhereCyclicDFAsGo(Tool tool,
CodeGenerator generator,
Grammar grammar,
-                           StringTemplate recognizerST,
-                           StringTemplate cyclicDFAST)
+                           ST recognizerST,
+                           ST cyclicDFAST)
{
return recognizerST;
}
diff --git a/tool/src/main/java/org/antlr/codegen/JavaTarget.java b/tool/src/main/java/org/antlr/codegen/JavaTarget.java
index 6044c1a..53c64d2 100644
--- a/tool/src/main/java/org/antlr/codegen/JavaTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/JavaTarget.java
@@ -28,15 +28,15 @@
package org.antlr.codegen;

import org.antlr.Tool;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.Grammar;

public class JavaTarget extends Target {
-	protected StringTemplate chooseWhereCyclicDFAsGo(Tool tool,
+	protected ST chooseWhereCyclicDFAsGo(Tool tool,
CodeGenerator generator,
Grammar grammar,
-													 StringTemplate recognizerST,
-													 StringTemplate cyclicDFAST)
+													 ST recognizerST,
+													 ST cyclicDFAST)
{
return recognizerST;
}
diff --git a/tool/src/main/java/org/antlr/codegen/ObjCTarget.java b/tool/src/main/java/org/antlr/codegen/ObjCTarget.java
index 9c1ff56..e4554e9 100644
--- a/tool/src/main/java/org/antlr/codegen/ObjCTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/ObjCTarget.java
@@ -30,7 +30,7 @@ package org.antlr.codegen;

import org.antlr.Tool;
import org.antlr.misc.Utils;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.Grammar;

import java.io.IOException;
@@ -39,7 +39,7 @@ public class ObjCTarget extends Target {
protected void genRecognizerHeaderFile(Tool tool,
CodeGenerator generator,
Grammar grammar,
-										   StringTemplate headerFileST,
+										   ST headerFileST,
String extName)
throws IOException
{
diff --git a/tool/src/main/java/org/antlr/codegen/RubyTarget.java b/tool/src/main/java/org/antlr/codegen/RubyTarget.java
index 4b86cb3..2565678 100644
--- a/tool/src/main/java/org/antlr/codegen/RubyTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/RubyTarget.java
@@ -29,7 +29,7 @@
package org.antlr.codegen;

import org.antlr.Tool;
-import org.antlr.stringtemplate.*;
+import org.stringtemplate.v4.*;
import org.antlr.tool.Grammar;

import java.io.IOException;
@@ -88,11 +88,11 @@ public class RubyTarget extends Target
rubyCharValueEscape['"'] = "\\\"";
}

-        public String toString( Object o ) {
-            return o.toString();
-        }
-
-        public String toString( Object o, String formatName ) {
+        public String toString( Object o, String formatName, Locale locale ) {
+			if ( formatName==null ) {
+				return o.toString();
+			}
+
String idString = o.toString();

if ( idString.isEmpty() ) return idString;
@@ -302,7 +302,7 @@ public class RubyTarget extends Target
Tool tool,
CodeGenerator generator,
Grammar grammar,
-    		StringTemplate outputFileST
+    		ST outputFileST
) throws IOException
{
/*
@@ -348,7 +348,7 @@ public class RubyTarget extends Target
}
}

-        StringTemplateGroup group = generator.getTemplates();
+        STGroup group = generator.getTemplates();
RubyRenderer renderer = new RubyRenderer();
try {
group.registerRenderer( Class.forName( "java.lang.String" ), renderer );
diff --git a/tool/src/main/java/org/antlr/codegen/Target.java b/tool/src/main/java/org/antlr/codegen/Target.java
index 9687bec..848dd7f 100644
--- a/tool/src/main/java/org/antlr/codegen/Target.java
+++ b/tool/src/main/java/org/antlr/codegen/Target.java
@@ -30,7 +30,7 @@ package org.antlr.codegen;
import org.antlr.Tool;
import org.antlr.analysis.Label;
import org.antlr.runtime.Token;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.Grammar;

import java.io.IOException;
@@ -86,7 +86,7 @@ public class Target {
protected void genRecognizerFile(Tool tool,
CodeGenerator generator,
Grammar grammar,
-									 StringTemplate outputFileST)
+									 ST outputFileST)
throws IOException
{
String fileName =
@@ -97,7 +97,7 @@ public class Target {
protected void genRecognizerHeaderFile(Tool tool,
CodeGenerator generator,
Grammar grammar,
-										   StringTemplate headerFileST,
+										   ST headerFileST,
String extName) // e.g., ".h"
throws IOException
{
diff --git a/tool/src/main/java/org/antlr/misc/Utils.java b/tool/src/main/java/org/antlr/misc/Utils.java
index 970bec2..ca156d5 100644
--- a/tool/src/main/java/org/antlr/misc/Utils.java
+++ b/tool/src/main/java/org/antlr/misc/Utils.java
@@ -27,6 +27,9 @@
*/
package org.antlr.misc;

+import java.util.HashMap;
+import java.util.Map;
+
public class Utils {
public static final int INTEGER_POOL_MAX_VALUE = 1000;
static Integer[] ints = new Integer[INTEGER_POOL_MAX_VALUE+1];
@@ -70,4 +73,20 @@ public class Utils {
result.append(src.substring(startIndex,src.length()));
return result.toString();
}
+
+//	/** mimic struct; like a non-iterable map. */
+//	public static class Struct {
+//		public Map<String,Object> fields = new HashMap<String,Object>();
+//
+//		@Override
+//		public String toString() { return fields.toString(); }
+//	}
+//
+//	public static Struct struct(String propNames, Object... values) {
+//		String[] props = propNames.split(",");
+//		int i=0;
+//		Struct s = new Struct();
+//		for (String p : props) s.fields.put(p, values[i++]);
+//		return s;
+//	}
}
diff --git a/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java b/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java
index f88a053..844046e 100644
--- a/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java
+++ b/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java
@@ -30,9 +30,9 @@ package org.antlr.tool;
import org.antlr.Tool;
import org.antlr.codegen.CodeGenerator;
import org.antlr.misc.Utils;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
-import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
+import org.stringtemplate.v4.STGroupFile;

import java.io.*;
import java.util.ArrayList;
@@ -80,7 +80,7 @@ public class BuildDependencyGenerator {
protected Tool tool;
protected Grammar grammar;
protected CodeGenerator generator;
-    protected StringTemplateGroup templates;
+    protected STGroup templates;

public BuildDependencyGenerator(Tool tool, String grammarFileName)
throws IOException {
@@ -115,12 +115,12 @@ public class BuildDependencyGenerator {
//
files.add(new File(tool.getOutputDirectory(), generator.getVocabFileName()));
// are we generating a .h file?
-        StringTemplate headerExtST = null;
-        StringTemplate extST = generator.getTemplates().getInstanceOf("codeFileExtension");
+        ST headerExtST = null;
+        ST extST = generator.getTemplates().getInstanceOf("codeFileExtension");
if (generator.getTemplates().isDefined("headerFile")) {
headerExtST = generator.getTemplates().getInstanceOf("headerFileExtension");
String suffix = Grammar.grammarTypeToFileNameSuffix[grammar.type];
-            String fileName = grammar.name + suffix + headerExtST.toString();
+            String fileName = grammar.name + suffix + headerExtST.render();
files.add(new File(outputDir, fileName));
}
if (grammar.type == Grammar.COMBINED) {
@@ -128,12 +128,12 @@ public class BuildDependencyGenerator {
// don't add T__.g (just a temp file)

String suffix = Grammar.grammarTypeToFileNameSuffix[Grammar.LEXER];
-            String lexer = grammar.name + suffix + extST.toString();
+            String lexer = grammar.name + suffix + extST.render();
files.add(new File(outputDir, lexer));

// TLexer.h
if (headerExtST != null) {
-                String header = grammar.name + suffix + headerExtST.toString();
+                String header = grammar.name + suffix + headerExtST.render();
files.add(new File(outputDir, header));
}
// for combined, don't generate TLexer.tokens
@@ -144,7 +144,7 @@ public class BuildDependencyGenerator {
grammar.composite.getDelegates(grammar.composite.getRootGrammar());
for (Grammar g : imports) {
outputDir = tool.getOutputDirectory(g.getFileName());
-            String fname = groomQualifiedFileName(outputDir.toString(), g.getRecognizerName() + extST.toString());
+            String fname = groomQualifiedFileName(outputDir.toString(), g.getRecognizerName() + extST.render());
files.add(new File(fname));
}

@@ -199,47 +199,19 @@ public class BuildDependencyGenerator {
return files;
}

-    public StringTemplate getDependencies() {
+    public ST getDependencies() {
loadDependencyTemplates();
-        StringTemplate dependenciesST = templates.getInstanceOf("dependencies");
-        dependenciesST.setAttribute("in", getDependenciesFileList());
-        dependenciesST.setAttribute("out", getGeneratedFileList());
-        dependenciesST.setAttribute("grammarFileName", grammar.fileName);
+        ST dependenciesST = templates.getInstanceOf("dependencies");
+        dependenciesST.add("in", getDependenciesFileList());
+        dependenciesST.add("out", getGeneratedFileList());
+        dependenciesST.add("grammarFileName", grammar.fileName);
return dependenciesST;
}

public void loadDependencyTemplates() {
-        if (templates != null) {
-            return;
-        }
+        if (templates != null) return;
String fileName = "org/antlr/tool/templates/depend.stg";
-        ClassLoader cl = Thread.currentThread().getContextClassLoader();
-        InputStream is = cl.getResourceAsStream(fileName);
-        if (is == null) {
-            cl = ErrorManager.class.getClassLoader();
-            is = cl.getResourceAsStream(fileName);
-        }
-        if (is == null) {
-            ErrorManager.internalError("Can't load dependency templates: " + fileName);
-            return;
-        }
-        BufferedReader br = null;
-        try {
-            br = new BufferedReader(new InputStreamReader(is));
-            templates = new StringTemplateGroup(br,
-                    AngleBracketTemplateLexer.class);
-            br.close();
-        } catch (IOException ioe) {
-            ErrorManager.internalError("error reading dependency templates file " + fileName, ioe);
-        } finally {
-            if (br != null) {
-                try {
-                    br.close();
-                } catch (IOException ioe) {
-                    ErrorManager.internalError("cannot close dependency templates file " + fileName, ioe);
-                }
-            }
-        }
+        templates = new STGroupFile(fileName);
}

public String getTokenVocab() {
diff --git a/tool/src/main/java/org/antlr/tool/DOTGenerator.java b/tool/src/main/java/org/antlr/tool/DOTGenerator.java
index 14462a7..4e906a3 100644
--- a/tool/src/main/java/org/antlr/tool/DOTGenerator.java
+++ b/tool/src/main/java/org/antlr/tool/DOTGenerator.java
@@ -31,9 +31,9 @@ import org.antlr.Tool;
import org.antlr.analysis.*;
import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.misc.Utils;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
-import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
+import org.stringtemplate.v4.STGroupDir;

import java.util.*;

@@ -45,8 +45,7 @@ public class DOTGenerator {
protected String rankdir="LR";

/** Library of output templates; use <attrname> format */
-    public static StringTemplateGroup stlib =
-            new StringTemplateGroup("toollib", AngleBracketTemplateLexer.class);
+    public static STGroup stlib = new STGroupDir("org/antlr/tool/templates/dot/dfa");

/** To prevent infinite recursion when walking state machines, record
*  which states we've visited.  Make a new set every time you start
@@ -70,23 +69,23 @@ public class DOTGenerator {
return null;
}
// The output DOT graph for visualization
-		StringTemplate dot = null;
+		ST dot = null;
markedStates = new HashSet();
if ( startState instanceof DFAState ) {
-            dot = stlib.getInstanceOf("org/antlr/tool/templates/dot/dfa");
-			dot.setAttribute("startState",
+            dot = stlib.getInstanceOf("dfa");
+			dot.add("startState",
Utils.integer(startState.stateNumber));
-			dot.setAttribute("useBox",
-							 Boolean.valueOf(Tool.internalOption_ShowNFAConfigsInDFA));
+			dot.add("useBox",
+					Boolean.valueOf(Tool.internalOption_ShowNFAConfigsInDFA));
walkCreatingDFADOT(dot, (DFAState)startState);
}
else {
-            dot = stlib.getInstanceOf("org/antlr/tool/templates/dot/nfa");
-			dot.setAttribute("startState",
+            dot = stlib.getInstanceOf("nfa");
+			dot.add("startState",
Utils.integer(startState.stateNumber));
walkRuleNFACreatingDOT(dot, startState);
}
-		dot.setAttribute("rankdir", rankdir);
+		dot.add("rankdir", rankdir);
return dot.toString();
}

@@ -95,10 +94,10 @@ public class DOTGenerator {
*  from startState will be included.
public String getRuleNFADOT(State startState) {
// The output DOT graph for visualization
-        StringTemplate dot = stlib.getInstanceOf("org/antlr/tool/templates/dot/nfa");
+        ST dot = stlib.getInstanceOf("nfa");

markedStates = new HashSet();
-        dot.setAttribute("startState",
+        dot.add("startState",
Utils.integer(startState.stateNumber));
walkRuleNFACreatingDOT(dot, startState);
return dot.toString();
@@ -109,7 +108,7 @@ public class DOTGenerator {
*  fill a DOT description template.  Keep filling the
*  states and edges attributes.
*/
-    protected void walkCreatingDFADOT(StringTemplate dot,
+    protected void walkCreatingDFADOT(ST dot,
DFAState s)
{
if ( markedStates.contains(Utils.integer(s.stateNumber)) ) {
@@ -119,15 +118,15 @@ public class DOTGenerator {
markedStates.add(Utils.integer(s.stateNumber)); // mark this node as completed.

// first add this node
-        StringTemplate st;
+        ST st;
if ( s.isAcceptState() ) {
-            st = stlib.getInstanceOf("org/antlr/tool/templates/dot/stopstate");
+            st = stlib.getInstanceOf("stopstate");
}
else {
-            st = stlib.getInstanceOf("org/antlr/tool/templates/dot/state");
+            st = stlib.getInstanceOf("state");
}
-        st.setAttribute("name", getStateLabel(s));
-        dot.setAttribute("states", st);
+        st.add("name", getStateLabel(s));
+        dot.add("states", st);

// make a DOT edge for each transition
for (int i = 0; i < s.getNumberOfTransitions(); i++) {
@@ -143,12 +142,12 @@ public class DOTGenerator {
continue; // don't generate nodes for terminal states
}
}
-			st = stlib.getInstanceOf("org/antlr/tool/templates/dot/edge");
-			st.setAttribute("label", getEdgeLabel(edge));
-			st.setAttribute("src", getStateLabel(s));
-            st.setAttribute("target", getStateLabel(edge.target));
-			st.setAttribute("arrowhead", arrowhead);
-            dot.setAttribute("edges", st);
+			st = stlib.getInstanceOf("edge");
+			st.add("label", getEdgeLabel(edge));
+			st.add("src", getStateLabel(s));
+            st.add("target", getStateLabel(edge.target));
+			st.add("arrowhead", arrowhead);
+            dot.add("edges", st);
walkCreatingDFADOT(dot, (DFAState)edge.target); // keep walkin'
}
}
@@ -159,7 +158,7 @@ public class DOTGenerator {
*  for a rule so don't traverse edges to other rules and
*  don't go past rule end state.
*/
-    protected void walkRuleNFACreatingDOT(StringTemplate dot,
+    protected void walkRuleNFACreatingDOT(ST dot,
State s)
{
if ( markedStates.contains(s) ) {
@@ -169,15 +168,15 @@ public class DOTGenerator {
markedStates.add(s); // mark this node as completed.

// first add this node
-        StringTemplate stateST;
+        ST stateST;
if ( s.isAcceptState() ) {
-            stateST = stlib.getInstanceOf("org/antlr/tool/templates/dot/stopstate");
+            stateST = stlib.getInstanceOf("stopstate");
}
else {
-            stateST = stlib.getInstanceOf("org/antlr/tool/templates/dot/state");
+            stateST = stlib.getInstanceOf("state");
}
-        stateST.setAttribute("name", getStateLabel(s));
-        dot.setAttribute("states", stateST);
+        stateST.add("name", getStateLabel(s));
+        dot.add("states", stateST);

if ( s.isAcceptState() )  {
return; // don't go past end of rule node to the follow states
@@ -188,10 +187,10 @@ public class DOTGenerator {
if ( ((NFAState)s).isDecisionState() ) {
GrammarAST n = ((NFAState)s).associatedASTNode;
if ( n!=null && n.getType()!=ANTLRParser.EOB ) {
-				StringTemplate rankST = stlib.getInstanceOf("org/antlr/tool/templates/dot/decision-rank");
+				ST rankST = stlib.getInstanceOf("decision-rank");
NFAState alt = (NFAState)s;
while ( alt!=null ) {
-					rankST.setAttribute("states", getStateLabel(alt));
+					rankST.add("states", getStateLabel(alt));
if ( alt.transition[1] !=null ) {
alt = (NFAState)alt.transition[1].target;
}
@@ -199,45 +198,45 @@ public class DOTGenerator {
alt=null;
}
}
-				dot.setAttribute("decisionRanks", rankST);
+				dot.add("decisionRanks", rankST);
}
}

// make a DOT edge for each transition
-		StringTemplate edgeST = null;
+		ST edgeST = null;
for (int i = 0; i < s.getNumberOfTransitions(); i++) {
Transition edge = (Transition) s.transition(i);
if ( edge instanceof RuleClosureTransition ) {
RuleClosureTransition rr = ((RuleClosureTransition)edge);
// don't jump to other rules, but display edge to follow node
-                edgeST = stlib.getInstanceOf("org/antlr/tool/templates/dot/edge");
+                edgeST = stlib.getInstanceOf("edge");
if ( rr.rule.grammar != grammar ) {
-					edgeST.setAttribute("label", "<"+rr.rule.grammar.name+"."+rr.rule.name+">");
+					edgeST.add("label", "<" + rr.rule.grammar.name + "." + rr.rule.name + ">");
}
else {
-					edgeST.setAttribute("label", "<"+rr.rule.name+">");
+					edgeST.add("label", "<" + rr.rule.name + ">");
}
-				edgeST.setAttribute("src", getStateLabel(s));
-				edgeST.setAttribute("target", getStateLabel(rr.followState));
-				edgeST.setAttribute("arrowhead", arrowhead);
-                dot.setAttribute("edges", edgeST);
+				edgeST.add("src", getStateLabel(s));
+				edgeST.add("target", getStateLabel(rr.followState));
+				edgeST.add("arrowhead", arrowhead);
+                dot.add("edges", edgeST);
walkRuleNFACreatingDOT(dot, rr.followState);
continue;
}
if ( edge.isAction() ) {
-				edgeST = stlib.getInstanceOf("org/antlr/tool/templates/dot/action-edge");
+				edgeST = stlib.getInstanceOf("action-edge");
}
else if ( edge.isEpsilon() ) {
-				edgeST = stlib.getInstanceOf("org/antlr/tool/templates/dot/epsilon-edge");
+				edgeST = stlib.getInstanceOf("epsilon-edge");
}
else {
-				edgeST = stlib.getInstanceOf("org/antlr/tool/templates/dot/edge");
+				edgeST = stlib.getInstanceOf("edge");
}
-			edgeST.setAttribute("label", getEdgeLabel(edge));
-            edgeST.setAttribute("src", getStateLabel(s));
-			edgeST.setAttribute("target", getStateLabel(edge.target));
-			edgeST.setAttribute("arrowhead", arrowhead);
-            dot.setAttribute("edges", edgeST);
+			edgeST.add("label", getEdgeLabel(edge));
+            edgeST.add("src", getStateLabel(s));
+			edgeST.add("target", getStateLabel(edge.target));
+			edgeST.add("arrowhead", arrowhead);
+            dot.add("edges", edgeST);
walkRuleNFACreatingDOT(dot, edge.target); // keep walkin'
}
}
diff --git a/tool/src/main/java/org/antlr/tool/ErrorManager.java b/tool/src/main/java/org/antlr/tool/ErrorManager.java
index 5999b64..2d82393 100644
--- a/tool/src/main/java/org/antlr/tool/ErrorManager.java
+++ b/tool/src/main/java/org/antlr/tool/ErrorManager.java
@@ -33,10 +33,11 @@ import org.antlr.analysis.DecisionProbe;
import org.antlr.misc.BitSet;
import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.Token;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateErrorListener;
-import org.antlr.stringtemplate.StringTemplateGroup;
-import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STErrorListener;
+import org.stringtemplate.v4.STGroup;
+import org.stringtemplate.v4.STGroupFile;
+import org.stringtemplate.v4.misc.STMessage;

import java.io.BufferedReader;
import java.io.IOException;
@@ -81,7 +82,7 @@ import java.util.*;
*  full of messages has an error, how could I print to anything but System.err?
*
*  TODO: how to map locale to a file encoding for the stringtemplate group file?
- *  StringTemplate knows how to pay attention to the default encoding so it
+ *  ST knows how to pay attention to the default encoding so it
*  should probably just work unless a GUI sets the local to some chinese
*  variation but System.getProperty("file.encoding") is US.  Hmm...
*
@@ -281,9 +282,9 @@ public class ErrorManager {
private static Map threadToToolMap = new HashMap();

/** The group of templates that represent all possible ANTLR errors. */
-	private static StringTemplateGroup messages;
+	private static STGroup messages;
/** The group of templates that represent the current message format. */
-	private static StringTemplateGroup format;
+	private static STGroup format;

/** From a msgID how can I get the name of the template that describes
*  the error or warning?
@@ -326,52 +327,58 @@ public class ErrorManager {
/** Handle all ST error listeners here (code gen, Grammar, and this class
*  use templates.
*/
-	static StringTemplateErrorListener initSTListener =
-		new StringTemplateErrorListener() {
-			public void error(String s, Throwable e) {
-				System.err.println("ErrorManager init error: "+s);
-				if ( e!=null ) {
-					System.err.println("exception: "+e);
-				}
-				/*
-				if ( e!=null ) {
-					e.printStackTrace(System.err);
-				}
-				*/
+	static STErrorListener initSTListener =
+		new STErrorListener() {
+			public void compileTimeError(STMessage msg) {
+				System.err.println("ErrorManager init error: "+msg);
+			}
+
+			public void runTimeError(STMessage msg) {
+				System.err.println("ErrorManager init error: "+msg);
+			}
+
+			public void IOError(STMessage msg) {
+				System.err.println("ErrorManager init error: "+msg);
}
-			public void warning(String s) {
-				System.err.println("ErrorManager init warning: "+s);
+
+			public void internalError(STMessage msg) {
+				System.err.println("ErrorManager init error: "+msg);
}
-			public void debug(String s) {}
+
};

/** During verification of the messages group file, don't gen errors.
*  I'll handle them here.  This is used only after file has loaded ok
*  and only for the messages STG.
*/
-	static StringTemplateErrorListener blankSTListener =
-		new StringTemplateErrorListener() {
-			public void error(String s, Throwable e) {}
-			public void warning(String s) {}
-			public void debug(String s) {}
+	static STErrorListener blankSTListener =
+		new STErrorListener() {
+			public void compileTimeError(STMessage msg) {			}
+			public void runTimeError(STMessage msg) {			}
+			public void IOError(STMessage msg) {			}
+			public void internalError(STMessage msg) {			}
};

/** Errors during initialization related to ST must all go to System.err.
*/
-	static StringTemplateErrorListener theDefaultSTListener =
-		new StringTemplateErrorListener() {
-		public void error(String s, Throwable e) {
-			if ( e instanceof InvocationTargetException ) {
-				e = ((InvocationTargetException)e).getTargetException();
+	static STErrorListener theDefaultSTListener =
+		new STErrorListener() {
+			public void compileTimeError(STMessage msg) {
+				ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, msg.toString(), msg.cause);
+			}
+
+			public void runTimeError(STMessage msg) {
+				ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, msg.toString(), msg.cause);
+			}
+
+			public void IOError(STMessage msg) {
+				ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, msg.toString(), msg.cause);
}
-			ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, s, e);
-		}
-		public void warning(String s) {
-			ErrorManager.warning(ErrorManager.MSG_INTERNAL_WARNING, s);
-		}
-		public void debug(String s) {
-		}
-	};
+
+			public void internalError(STMessage msg) {
+				ErrorManager.error(ErrorManager.MSG_INTERNAL_ERROR, msg.toString(), msg.cause);
+			}
+		};

// make sure that this class is ready to use after loading
static {
@@ -387,7 +394,7 @@ public class ErrorManager {
setFormat("antlr");
}

-    public static StringTemplateErrorListener getStringTemplateErrorListener() {
+    public static STErrorListener getSTErrorListener() {
return theDefaultSTListener;
}

@@ -400,44 +407,19 @@ public class ErrorManager {
ErrorManager.locale = locale;
String language = locale.getLanguage();
String fileName = "org/antlr/tool/templates/messages/languages/"+language+".stg";
-		ClassLoader cl = Thread.currentThread().getContextClassLoader();
-		InputStream is = cl.getResourceAsStream(fileName);
-		if ( is==null ) {
-			cl = ErrorManager.class.getClassLoader();
-			is = cl.getResourceAsStream(fileName);
-		}
-		if ( is==null && language.equals(Locale.US.getLanguage()) ) {
-			rawError("ANTLR installation corrupted; cannot find English messages file "+fileName);
-			panic();
-		}
-		else if ( is==null ) {
-			//rawError("no such locale file "+fileName+" retrying with English locale");
-			setLocale(Locale.US); // recurse on this rule, trying the US locale
-			return;
-		}
-		BufferedReader br = null;
-		try {
-			br = new BufferedReader(new InputStreamReader(is));
-			messages = new StringTemplateGroup(br,
-											   AngleBracketTemplateLexer.class,
-											   initSTListener);
-			br.close();
-		}
-		catch (IOException ioe) {
-			rawError("error reading message file "+fileName, ioe);
-		}
-		finally {
-			if ( br!=null ) {
-				try {
-					br.close();
-				}
-				catch (IOException ioe) {
-					rawError("cannot close message file "+fileName, ioe);
-				}
+		messages = new STGroupFile(fileName);
+		messages.setListener(initSTListener);
+		if ( !messages.isDefined("INTERNAL_ERROR") ) { // pick random msg to load
+			if ( language.equals(Locale.US.getLanguage()) ) {
+				rawError("ANTLR installation corrupted; cannot find English messages file "+fileName);
+				panic();
+			}
+			else {
+				setLocale(Locale.US); // recurse on this rule, trying the US locale
}
}

-		messages.setErrorListener(blankSTListener);
+		messages.setListener(blankSTListener);
boolean messagesOK = verifyMessages();
if ( !messagesOK && language.equals(Locale.US.getLanguage()) ) {
rawError("ANTLR installation corrupted; English messages file "+language+".stg incomplete");
@@ -454,40 +436,20 @@ public class ErrorManager {
public static void setFormat(String formatName) {
ErrorManager.formatName = formatName;
String fileName = "org/antlr/tool/templates/messages/formats/"+formatName+".stg";
-		ClassLoader cl = Thread.currentThread().getContextClassLoader();
-		InputStream is = cl.getResourceAsStream(fileName);
-		if ( is==null ) {
-			cl = ErrorManager.class.getClassLoader();
-			is = cl.getResourceAsStream(fileName);
-		}
-		if ( is==null && formatName.equals("antlr") ) {
-			rawError("ANTLR installation corrupted; cannot find ANTLR messages format file "+fileName);
-			panic();
-		}
-		else if ( is==null ) {
-			rawError("no such message format file "+fileName+" retrying with default ANTLR format");
-			setFormat("antlr"); // recurse on this rule, trying the default message format
-			return;
-		}
-		BufferedReader br = null;
-		try {
-			br = new BufferedReader(new InputStreamReader(is));
-			format = new StringTemplateGroup(br,
-											   AngleBracketTemplateLexer.class,
-											   initSTListener);
-		}
-		finally {
-			try {
-				if ( br!=null ) {
-					br.close();
-				}
+		format = new STGroupFile(fileName);
+		format.setListener(initSTListener);
+		if ( !format.isDefined("message") ) { // pick random msg to load
+			if ( formatName.equals("antlr") ) {
+				rawError("no such message format file "+fileName+" retrying with default ANTLR format");
+				setFormat("antlr"); // recurse on this rule, trying the default message format
+				return;
}
-			catch (IOException ioe) {
-				rawError("cannot close message format file "+fileName, ioe);
+			else {
+				setFormat("antlr"); // recurse on this rule, trying the default message format
}
}

-		format.setErrorListener(blankSTListener);
+		format.setListener(blankSTListener);
boolean formatOK = verifyFormat();
if ( !formatOK && formatName.equals("antlr") ) {
rawError("ANTLR installation corrupted; ANTLR messages format file "+formatName+".stg incomplete");
@@ -544,39 +506,39 @@ public class ErrorManager {
threadToToolMap.put(Thread.currentThread(), tool);
}

-	/** Given a message ID, return a StringTemplate that somebody can fill
+	/** Given a message ID, return a ST that somebody can fill
*  with data.  We need to convert the int ID to the name of a template
*  in the messages ST group.
*/
-	public static StringTemplate getMessage(int msgID) {
+	public static ST getMessage(int msgID) {
String msgName = idToMessageTemplateName[msgID];
return messages.getInstanceOf(msgName);
}
public static String getMessageType(int msgID) {
if (getErrorState().warningMsgIDs.member(msgID)) {
-			return messages.getInstanceOf("warning").toString();
+			return messages.getInstanceOf("warning").render();
}
else if (getErrorState().errorMsgIDs.member(msgID)) {
-			return messages.getInstanceOf("error").toString();
+			return messages.getInstanceOf("error").render();
}
assertTrue(false, "Assertion failed! Message ID " + msgID + " created but is not present in errorMsgIDs or warningMsgIDs.");
return "";
}

-	/** Return a StringTemplate that refers to the current format used for
+	/** Return a ST that refers to the current format used for
* emitting messages.
*/
-	public static StringTemplate getLocationFormat() {
+	public static ST getLocationFormat() {
return format.getInstanceOf("location");
}
-	public static StringTemplate getReportFormat() {
+	public static ST getReportFormat() {
return format.getInstanceOf("report");
}
-	public static StringTemplate getMessageFormat() {
+	public static ST getMessageFormat() {
return format.getInstanceOf("message");
}
public static boolean formatWantsSingleLineMessage() {
-		return format.getInstanceOf("wantsSingleLineMessage").toString().equals("true");
+		return format.getInstanceOf("wantsSingleLineMessage").render().equals("true");
}

public static ANTLRErrorListener getErrorListener() {
diff --git a/tool/src/main/java/org/antlr/tool/FASerializer.java b/tool/src/main/java/org/antlr/tool/FASerializer.java
index d28bab0..401bbb3 100644
--- a/tool/src/main/java/org/antlr/tool/FASerializer.java
+++ b/tool/src/main/java/org/antlr/tool/FASerializer.java
@@ -170,7 +170,7 @@ public class FASerializer {
if ( preds!=null ) {
predsStr = "&&{"+
preds.genExpr(grammar.generator,
-									   	  grammar.generator.getTemplates(), null).toString()
+									   	  grammar.generator.getTemplates(), null).render()
+"}?";
}
}
diff --git a/tool/src/main/java/org/antlr/tool/Grammar.java b/tool/src/main/java/org/antlr/tool/Grammar.java
index 9af0145..2d4ef6e 100644
--- a/tool/src/main/java/org/antlr/tool/Grammar.java
+++ b/tool/src/main/java/org/antlr/tool/Grammar.java
@@ -37,8 +37,9 @@ import org.antlr.misc.*;
import org.antlr.misc.Utils;
import org.antlr.runtime.*;
import org.antlr.runtime.tree.CommonTreeNodeStream;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
+import org.stringtemplate.v4.STGroupString;

import java.io.*;
import java.util.*;
@@ -438,20 +439,20 @@ public class Grammar {
*  as it's a lexer grammar.  A bit odd, but autogenerated.  Can tweak
*  later if we want.
*/
-	protected StringTemplate lexerGrammarST =
-		new StringTemplate(
+	protected String lexerGrammarTemplate =
+			"grammar(name, options, imports, actionNames, actions, literals, rules) ::= <<\n" +
"lexer grammar <name>;\n" +
"<if(options)>" +
"options {\n" +
-			"  <options:{<it.name>=<it.value>;<\\n>}>\n" +
+			"  <options:{it | <it.name>=<it.value>;<\\n>}>\n" +
"}<\\n>\n" +
"<endif>\n" +
"<if(imports)>import <imports; separator=\", \">;<endif>\n" +
-			"<actionNames,actions:{n,a|@<n> {<a>}\n}>\n" +
-			"<literals:{<it.ruleName> : <it.literal> ;\n}>\n" +
-			"<rules>",
-			AngleBracketTemplateLexer.class
-		);
+			"<actionNames,actions:{n,a|@<n> {<a>\\}\n}>\n" +
+			"<literals:{it | <it.ruleName> : <it.literal> ;\n}>\n" +
+			"<rules>\n" +
+			">>\n";
+	protected ST lexerGrammarST;

/** What file name holds this grammar? */
protected String fileName;
@@ -519,7 +520,9 @@ public class Grammar {
if ( composite.delegateGrammarTreeRoot==null ) {
composite.setDelegationRoot(this);
}
-		target = CodeGenerator.loadLanguageTarget((String)getOption("language"));
+		STGroup lexerGrammarSTG = new STGroupString(lexerGrammarTemplate);
+		lexerGrammarST = lexerGrammarSTG.getInstanceOf("grammar");
+		target = CodeGenerator.loadLanguageTarget((String) getOption("language"));
}

/** Useful for when you are sure that you are not part of a composite
@@ -531,6 +534,8 @@ public class Grammar {
setTool(tool);
builtFromString = true;
composite = new CompositeGrammar(this);
+		STGroup lexerGrammarSTG = new STGroupString(lexerGrammarTemplate);
+		lexerGrammarST = lexerGrammarSTG.getInstanceOf("grammar");
target = CodeGenerator.loadLanguageTarget((String)getOption("language"));
}

@@ -772,12 +777,12 @@ public class Grammar {
// if no rules, return nothing
return null;
}
-		lexerGrammarST.setAttribute("name", name);
+		lexerGrammarST.add("name", name);
// if there are any actions set for lexer, pass them in
if ( actions.get("lexer")!=null ) {
-			lexerGrammarST.setAttribute("actionNames",
+			lexerGrammarST.add("actionNames",
((Map)actions.get("lexer")).keySet());
-			lexerGrammarST.setAttribute("actions",
+			lexerGrammarST.add("actions",
((Map)actions.get("lexer")).values());
}
// make sure generated grammar has the same options
@@ -787,11 +792,11 @@ public class Grammar {
String optionName = (String) optionNames.next();
if ( !doNotCopyOptionsToLexer.contains(optionName) ) {
Object value = options.get(optionName);
-					lexerGrammarST.setAttribute("options.{name,value}", optionName, value);
+					lexerGrammarST.addAggr("options.{name,value}", optionName, value);
}
}
}
-		return lexerGrammarST.toString();
+		return lexerGrammarST.render();
}

public String getImplicitlyGeneratedLexerFileName() {
@@ -846,53 +851,28 @@ public class Grammar {
List<String> ruleNames,
List<String> delegateNames,
boolean filterMode) {
-		StringTemplate matchTokenRuleST = null;
+		ST matchTokenRuleST = null;
if ( filterMode ) {
-			matchTokenRuleST = new StringTemplate(
+			matchTokenRuleST = new ST(
ARTIFICIAL_TOKENS_RULENAME+
-					" options {k=1; backtrack=true;} : <rules; separator=\"|\">;",
-					AngleBracketTemplateLexer.class);
+					" options {k=1; backtrack=true;} : <rules; separator=\"|\">;");
}
else {
-			matchTokenRuleST = new StringTemplate(
-					ARTIFICIAL_TOKENS_RULENAME+" : <rules; separator=\"|\">;",
-					AngleBracketTemplateLexer.class);
+			matchTokenRuleST = new ST(
+					ARTIFICIAL_TOKENS_RULENAME+" : <rules; separator=\"|\">;");
}

// Now add token rule references
for (int i = 0; i < ruleNames.size(); i++) {
String rname = (String) ruleNames.get(i);
-			matchTokenRuleST.setAttribute("rules", rname);
+			matchTokenRuleST.add("rules", rname);
}
for (int i = 0; i < delegateNames.size(); i++) {
String dname = (String) delegateNames.get(i);
-			matchTokenRuleST.setAttribute("rules", dname+".Tokens");
+			matchTokenRuleST.add("rules", dname+".Tokens");
}
//System.out.println("tokens rule: "+matchTokenRuleST.toString());
-
-//		ANTLRLexer lexer = new ANTLRLexer(new StringReader(matchTokenRuleST.toString()));
-//		lexer.setTokenObjectClass("antlr.TokenWithIndex");
-//		TokenStreamRewriteEngine tokbuf =
-//			new ANTLRTokenStream(lexer);
-//		tokbuf.discard(ANTLRParser.WS);
-//		tokbuf.discard(ANTLRParser.ML_COMMENT);
-//		tokbuf.discard(ANTLRParser.COMMENT);
-//		tokbuf.discard(ANTLRParser.SL_COMMENT);
-//		ANTLRParser parser = new ANTLRParser(tokbuf);
-//		parser.setGrammar(this);
-//		parser.setGtype(ANTLRParser.LEXER_GRAMMAR);
-//		parser.setASTNodeClass("org.antlr.tool.GrammarAST");
-//		try {
-//			parser.rule();
-//			if ( Tool.internalOption_PrintGrammarTree ) {
-//				System.out.println("Tokens rule: "+parser.getAST().toStringTree());
-//			}
-//		}
-//		catch (Exception e) {
-//			ErrorManager.error(ErrorManager.MSG_ERROR_CREATING_ARTIFICIAL_RULE,
-//							   e);
-//		}
-		GrammarAST r = parseArtificialRule(matchTokenRuleST.toString());
+		GrammarAST r = parseArtificialRule(matchTokenRuleST.render());
addRule(grammarAST, r);
//addRule((GrammarAST)parser.getAST());
//return (GrammarAST)parser.getAST();
@@ -1546,7 +1526,7 @@ outer:
}
}

-    public void setSynPredGateIfNotAlready(StringTemplate gateST) {
+    public void setSynPredGateIfNotAlready(ST gateST) {
String scope = getDefaultActionScope(type);
Map actionsForGrammarScope = (Map)actions.get(scope);
// if no synpredgate action set by user then set
@@ -1634,7 +1614,7 @@ outer:
//System.out.println("[["+ruleText+"]]");
// now put the rule into the lexer grammar template
if ( getGrammarIsRoot() ) { // don't build lexers for delegates
-			lexerGrammarST.setAttribute("rules", ruleText);
+			lexerGrammarST.add("rules", ruleText);
}
// track this lexer rule's name
composite.lexerRules.add(ruleToken.getText());
@@ -1649,7 +1629,7 @@ outer:
{
if ( getGrammarIsRoot() ) { // don't build lexers for delegates
//System.out.println("defineLexerRuleForAliasedStringLiteral: "+literal+" "+tokenType);
-			lexerGrammarST.setAttribute("literals.{ruleName,type,literal}",
+			lexerGrammarST.addAggr("literals.{ruleName,type,literal}",
tokenID,
Utils.integer(tokenType),
literal);
@@ -1665,7 +1645,7 @@ outer:
defineToken(tokenID, tokenType);
// tell implicit lexer to define a rule to match the literal
if ( getGrammarIsRoot() ) { // don't build lexers for delegates
-			lexerGrammarST.setAttribute("literals.{ruleName,type,literal}",
+			lexerGrammarST.addAggr("literals.{ruleName,type,literal}",
tokenID,
Utils.integer(tokenType),
literal);
@@ -2294,7 +2274,7 @@ outer:
if ( delegateGrammar.type == LEXER && this.type == COMBINED ) {
// ooops, we wasted some effort; tell lexer to read it in
// later
-					lexerGrammarST.setAttribute("imports", grammarName);
+					lexerGrammarST.add("imports", grammarName);
// but, this parser grammar will need the vocab
// so add to composite anyway so we suck in the tokens later
}
diff --git a/tool/src/main/java/org/antlr/tool/GrammarAST.java b/tool/src/main/java/org/antlr/tool/GrammarAST.java
index 258f40a..b010845 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarAST.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarAST.java
@@ -38,7 +38,7 @@ import org.antlr.runtime.TokenSource;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.Tree;
import org.antlr.runtime.tree.TreeAdaptor;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.omg.PortableInterceptor.ORBInitInfoPackage.DuplicateName;

import java.util.*;
@@ -120,11 +120,11 @@ public class GrammarAST extends CommonTree {
*/
public int outerAltNum;

-	/** if this is a TOKEN_REF or RULE_REF node, this is the code StringTemplate
+	/** if this is a TOKEN_REF or RULE_REF node, this is the code ST
*  generated for this node.  We need to update it later to add
*  a label if someone does $tokenref or $ruleref in an action.
*/
-	public StringTemplate code;
+	public ST code;

/**
*
diff --git a/tool/src/main/java/org/antlr/tool/GrammarAnalysisAbortedMessage.java b/tool/src/main/java/org/antlr/tool/GrammarAnalysisAbortedMessage.java
index a099568..95d1d17 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarAnalysisAbortedMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarAnalysisAbortedMessage.java
@@ -28,7 +28,7 @@
package org.antlr.tool;

import org.antlr.analysis.DecisionProbe;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

/** Reports the condition that ANTLR's LL(*) analysis engine terminated
*  early.
@@ -49,8 +49,8 @@ public class GrammarAnalysisAbortedMessage extends Message {
if ( fileName!=null ) {
file = fileName;
}
-		StringTemplate st = getMessageTemplate();
-		st.setAttribute("enclosingRule",
+		ST st = getMessageTemplate();
+		st.add("enclosingRule",
probe.dfa.getNFADecisionStartState().enclosingRule.name);

return super.toString(st);
diff --git a/tool/src/main/java/org/antlr/tool/GrammarDanglingStateMessage.java b/tool/src/main/java/org/antlr/tool/GrammarDanglingStateMessage.java
index 19f50da..e360dd7 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarDanglingStateMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarDanglingStateMessage.java
@@ -29,7 +29,7 @@ package org.antlr.tool;

import org.antlr.analysis.DFAState;
import org.antlr.analysis.DecisionProbe;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

import java.util.ArrayList;
import java.util.Collections;
@@ -60,12 +60,12 @@ public class GrammarDanglingStateMessage extends Message {
}
List labels = probe.getSampleNonDeterministicInputSequence(problemState);
String input = probe.getInputSequenceDisplay(labels);
-		StringTemplate st = getMessageTemplate();
+		ST st = getMessageTemplate();
List alts = new ArrayList();
alts.addAll(problemState.getAltSet());
Collections.sort(alts);
-		st.setAttribute("danglingAlts", alts);
-		st.setAttribute("input", input);
+		st.add("danglingAlts", alts);
+		st.add("input", input);

return super.toString(st);
}
diff --git a/tool/src/main/java/org/antlr/tool/GrammarInsufficientPredicatesMessage.java b/tool/src/main/java/org/antlr/tool/GrammarInsufficientPredicatesMessage.java
index 494851d..156bdc1 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarInsufficientPredicatesMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarInsufficientPredicatesMessage.java
@@ -31,7 +31,7 @@ import org.antlr.analysis.DFAState;
import org.antlr.analysis.DecisionProbe;
import org.antlr.analysis.Label;
import org.antlr.runtime.Token;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

import java.util.*;

@@ -58,7 +58,7 @@ public class GrammarInsufficientPredicatesMessage extends Message {
if ( fileName!=null ) {
file = fileName;
}
-		StringTemplate st = getMessageTemplate();
+		ST st = getMessageTemplate();
// convert to string key to avoid 3.1 ST bug
Map<String, Set<Token>> altToLocationsWithStringKey = new LinkedHashMap<String, Set<Token>>();
List<Integer> alts = new ArrayList<Integer>();
@@ -75,13 +75,13 @@ public class GrammarInsufficientPredicatesMessage extends Message {
System.out.println("tokens=\n"+tokens);
*/
}
-		st.setAttribute("altToLocations", altToLocationsWithStringKey);
+		st.add("altToLocations", altToLocationsWithStringKey);

List<Label> sampleInputLabels = problemState.dfa.probe.getSampleNonDeterministicInputSequence(problemState);
String input = problemState.dfa.probe.getInputSequenceDisplay(sampleInputLabels);
-		st.setAttribute("upon", input);
+		st.add("upon", input);

-		st.setAttribute("hasPredicateBlockedByAction", problemState.dfa.hasPredicateBlockedByAction);
+		st.add("hasPredicateBlockedByAction", problemState.dfa.hasPredicateBlockedByAction);

return super.toString(st);
}
diff --git a/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java b/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
index 2922fd9..8cd95ae 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarNonDeterminismMessage.java
@@ -30,7 +30,8 @@ package org.antlr.tool;
import org.antlr.analysis.DFAState;
import org.antlr.analysis.DecisionProbe;
import org.antlr.analysis.NFAState;
-import org.antlr.stringtemplate.StringTemplate;
+import org.antlr.misc.Utils;
+import org.stringtemplate.v4.ST;

import java.util.Iterator;
import java.util.List;
@@ -64,11 +65,11 @@ public class GrammarNonDeterminismMessage extends Message {
file = fileName;
}

-		StringTemplate st = getMessageTemplate();
+		ST st = getMessageTemplate();
// Now fill template with information about problemState
List labels = probe.getSampleNonDeterministicInputSequence(problemState);
String input = probe.getInputSequenceDisplay(labels);
-		st.setAttribute("input", input);
+		st.add("input", input);

if ( probe.dfa.isTokensRuleDecision() ) {
Set disabledAlts = probe.getDisabledAlternatives(problemState);
@@ -81,11 +82,11 @@ public class GrammarNonDeterminismMessage extends Message {
probe.dfa.nfa.grammar.getRuleStartState(tokenName);
line = ruleStart.associatedASTNode.getLine();
column = ruleStart.associatedASTNode.getCharPositionInLine();
-				st.setAttribute("disabled", tokenName);
+				st.add("disabled", tokenName);
}
}
else {
-			st.setAttribute("disabled", probe.getDisabledAlternatives(problemState));
+			st.add("disabled", probe.getDisabledAlternatives(problemState));
}

List nondetAlts = probe.getNonDeterministicAltsForState(problemState);
@@ -105,23 +106,22 @@ public class GrammarNonDeterminismMessage extends Message {
probe.getNFAPathStatesForAlt(firstAlt,
tracePathAlt,
labels);
-					st.setAttribute("paths.{alt,states}",
-									displayAltI, path);
+					st.addAggr("paths.{alt, states}", displayAltI, path);
}
else {
if ( probe.dfa.isTokensRuleDecision() ) {
// alts are token rules, convert to the names instead of numbers
String tokenName =
probe.getTokenNameForTokensRuleAlt(displayAltI.intValue());
-						st.setAttribute("conflictingTokens", tokenName);
+						st.add("conflictingTokens", tokenName);
}
else {
-						st.setAttribute("conflictingAlts", displayAltI);
+						st.add("conflictingAlts", displayAltI);
}
}
}
}
-		st.setAttribute("hasPredicateBlockedByAction", problemState.dfa.hasPredicateBlockedByAction);
+		st.add("hasPredicateBlockedByAction", problemState.dfa.hasPredicateBlockedByAction);
return super.toString(st);
}

diff --git a/tool/src/main/java/org/antlr/tool/GrammarSemanticsMessage.java b/tool/src/main/java/org/antlr/tool/GrammarSemanticsMessage.java
index a5b79fe..1027182 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSemanticsMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSemanticsMessage.java
@@ -28,7 +28,7 @@
package org.antlr.tool;

import org.antlr.runtime.Token;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

/** A problem with the symbols and/or meaning of a grammar such as rule
*  redefinition.
@@ -76,12 +76,12 @@ public class GrammarSemanticsMessage extends Message {
if ( g!=null ) {
file = g.getFileName();
}
-		StringTemplate st = getMessageTemplate();
+		ST st = getMessageTemplate();
if ( arg!=null ) {
-			st.setAttribute("arg", arg);
+			st.add("arg", arg);
}
if ( arg2!=null ) {
-			st.setAttribute("arg2", arg2);
+			st.add("arg2", arg2);
}
return super.toString(st);
}
diff --git a/tool/src/main/java/org/antlr/tool/GrammarSyntaxMessage.java b/tool/src/main/java/org/antlr/tool/GrammarSyntaxMessage.java
index 45730d1..290cb66 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSyntaxMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSyntaxMessage.java
@@ -29,7 +29,7 @@ package org.antlr.tool;

import org.antlr.runtime.RecognitionException;
import org.antlr.runtime.Token;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

/** A problem with the syntax of your antlr grammar such as
*  "The '{' came as a complete surprise to me at this point in your program"
@@ -72,9 +72,9 @@ public class GrammarSyntaxMessage extends Message {
if (g != null) {
file = g.getFileName();
}
-		StringTemplate st = getMessageTemplate();
+		ST st = getMessageTemplate();
if ( arg!=null ) {
-			st.setAttribute("arg", arg);
+			st.add("arg", arg);
}
return super.toString(st);
}
diff --git a/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java b/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
index d13d773..1c18cd5 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarUnreachableAltsMessage.java
@@ -29,7 +29,7 @@ package org.antlr.tool;

import org.antlr.analysis.DecisionProbe;
import org.antlr.analysis.NFAState;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

import java.util.List;

@@ -61,7 +61,7 @@ public class GrammarUnreachableAltsMessage extends Message {
file = fileName;
}

-		StringTemplate st = getMessageTemplate();
+		ST st = getMessageTemplate();

if ( probe.dfa.isTokensRuleDecision() ) {
// alts are token rules, convert to the names instead of numbers
@@ -74,12 +74,12 @@ public class GrammarUnreachableAltsMessage extends Message {
probe.dfa.nfa.grammar.getRuleStartState(tokenName);
line = ruleStart.associatedASTNode.getLine();
column = ruleStart.associatedASTNode.getCharPositionInLine();
-				st.setAttribute("tokens", tokenName);
+				st.add("tokens", tokenName);
}
}
else {
// regular alt numbers, show the alts
-			st.setAttribute("alts", alts);
+			st.add("alts", alts);
}

return super.toString(st);
diff --git a/tool/src/main/java/org/antlr/tool/LeftRecursionCyclesMessage.java b/tool/src/main/java/org/antlr/tool/LeftRecursionCyclesMessage.java
index 193ae8a..412978e 100644
--- a/tool/src/main/java/org/antlr/tool/LeftRecursionCyclesMessage.java
+++ b/tool/src/main/java/org/antlr/tool/LeftRecursionCyclesMessage.java
@@ -27,7 +27,7 @@
*/
package org.antlr.tool;

-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

import java.util.Collection;

@@ -44,8 +44,8 @@ public class LeftRecursionCyclesMessage extends Message {
}

public String toString() {
-		StringTemplate st = getMessageTemplate();
-		st.setAttribute("listOfCycles", cycles);
+		ST st = getMessageTemplate();
+		st.add("listOfCycles", cycles);
return super.toString(st);
}
}
diff --git a/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java b/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
index b01743e..fcbf7db 100644
--- a/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
+++ b/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
@@ -5,8 +5,7 @@ import org.antlr.grammar.v3.*;
import org.antlr.runtime.Token;
import org.antlr.runtime.tree.CommonTreeNodeStream;
import org.antlr.runtime.tree.TreeNodeStream;
-import org.antlr.stringtemplate.*;
-import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
+import org.stringtemplate.v4.*;

import java.util.*;

@@ -26,7 +25,7 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {

public GrammarAST retvals;

-	public StringTemplateGroup recRuleTemplates;
+	public STGroup recRuleTemplates;
public String language;

public Map<Integer, ASSOC> altAssociativity = new HashMap<Integer, ASSOC>();
@@ -42,16 +41,10 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {
}

public void loadPrecRuleTemplates() {
-		String templateDirs =
-			CodeGenerator.classpathTemplateRootDirectoryName;
-		StringTemplateGroupLoader loader =
-			new CommonGroupLoader(templateDirs,
-								  ErrorManager.getStringTemplateErrorListener());
-		StringTemplateGroup.registerGroupLoader(loader);
-		StringTemplateGroup.registerDefaultLexer(AngleBracketTemplateLexer.class);
-
-		recRuleTemplates =	StringTemplateGroup.loadGroup("LeftRecursiveRules");
-		if ( recRuleTemplates==null ) {
+		recRuleTemplates =
+			new STGroupFile(CodeGenerator.classpathTemplateRootDirectoryName+
+							"/LeftRecursiveRules.stg");
+		if ( !recRuleTemplates.isDefined("recRuleName") ) {
ErrorManager.error(ErrorManager.MSG_MISSING_CODE_GEN_TEMPLATES,
"PrecRules");
return;
@@ -99,17 +92,17 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {

// rewrite e to be e_[rec_arg]
int nextPrec = nextPrecedence(alt);
-		StringTemplate refST = recRuleTemplates.getInstanceOf("recRuleRef");
-		refST.setAttribute("ruleName", ruleName);
-		refST.setAttribute("arg", nextPrec);
-		altTree = replaceRuleRefs(altTree, refST.toString());
+		ST refST = recRuleTemplates.getInstanceOf("recRuleRef");
+		refST.add("ruleName", ruleName);
+		refST.add("arg", nextPrec);
+		altTree = replaceRuleRefs(altTree, refST.render());

String altText = text(altTree);
altText = altText.trim();
altText += "{}"; // add empty alt to prevent pred hoisting
-		StringTemplate nameST = recRuleTemplates.getInstanceOf("recRuleName");
-		nameST.setAttribute("ruleName", ruleName);
-		rewriteTree = replaceRuleRefs(rewriteTree, "$" + nameST.toString());
+		ST nameST = recRuleTemplates.getInstanceOf("recRuleName");
+		nameST.add("ruleName", ruleName);
+		rewriteTree = replaceRuleRefs(rewriteTree, "$" + nameST.render());
String rewriteText = text(rewriteTree);
binaryAlts.put(alt, altText + (rewriteText != null ? " " + rewriteText : ""));
//System.out.println("binaryAlt " + alt + ": " + altText + ", rewrite=" + rewriteText);
@@ -125,17 +118,17 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {
stripLeftRecursion(altTree);

int nextPrec = nextPrecedence(alt);
-		StringTemplate refST = recRuleTemplates.getInstanceOf("recRuleRef");
-		refST.setAttribute("ruleName", ruleName);
-		refST.setAttribute("arg", nextPrec);
-		altTree = replaceLastRuleRef(altTree, refST.toString());
+		ST refST = recRuleTemplates.getInstanceOf("recRuleRef");
+		refST.add("ruleName", ruleName);
+		refST.add("arg", nextPrec);
+		altTree = replaceLastRuleRef(altTree, refST.render());

String altText = text(altTree);
altText = altText.trim();
altText += "{}"; // add empty alt to prevent pred hoisting
-		StringTemplate nameST = recRuleTemplates.getInstanceOf("recRuleName");
-		nameST.setAttribute("ruleName", ruleName);
-		rewriteTree = replaceRuleRefs(rewriteTree, "$" + nameST.toString());
+		ST nameST = recRuleTemplates.getInstanceOf("recRuleName");
+		nameST.add("ruleName", ruleName);
+		rewriteTree = replaceRuleRefs(rewriteTree, "$" + nameST.render());
String rewriteText = text(rewriteTree);
ternaryAlts.put(alt, altText + (rewriteText != null ? " " + rewriteText : ""));
//System.out.println("ternaryAlt " + alt + ": " + altText + ", rewrite=" + rewriteText);
@@ -150,17 +143,17 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {

int nextPrec = precedence(alt);
// rewrite e to be e_[rec_arg]
-		StringTemplate refST = recRuleTemplates.getInstanceOf("recRuleRef");
-		refST.setAttribute("ruleName", ruleName);
-		refST.setAttribute("arg", nextPrec);
-		altTree = replaceRuleRefs(altTree, refST.toString());
+		ST refST = recRuleTemplates.getInstanceOf("recRuleRef");
+		refST.add("ruleName", ruleName);
+		refST.add("arg", nextPrec);
+		altTree = replaceRuleRefs(altTree, refST.render());
String altText = text(altTree);
altText = altText.trim();
altText += "{}"; // add empty alt to prevent pred hoisting

-		StringTemplate nameST = recRuleTemplates.getInstanceOf("recRuleName");
-		nameST.setAttribute("ruleName", ruleName);
-		rewriteTree = replaceRuleRefs(rewriteTree, nameST.toString());
+		ST nameST = recRuleTemplates.getInstanceOf("recRuleName");
+		nameST.add("ruleName", ruleName);
+		rewriteTree = replaceRuleRefs(rewriteTree, nameST.render());
String rewriteText = text(rewriteTree);

prefixAlts.add(altText + (rewriteText != null ? " " + rewriteText : ""));
@@ -173,9 +166,9 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {
rewriteTree = GrammarAST.dupTree(rewriteTree);
stripSynPred(altTree);
stripLeftRecursion(altTree);
-		StringTemplate nameST = recRuleTemplates.getInstanceOf("recRuleName");
-		nameST.setAttribute("ruleName", ruleName);
-		rewriteTree = replaceRuleRefs(rewriteTree, "$" + nameST.toString());
+		ST nameST = recRuleTemplates.getInstanceOf("recRuleName");
+		nameST.add("ruleName", ruleName);
+		rewriteTree = replaceRuleRefs(rewriteTree, "$" + nameST.render());
String rewriteText = text(rewriteTree);
String altText = text(altTree);
altText = altText.trim();
@@ -199,30 +192,30 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {
// --------- get transformed rules ----------------

public String getArtificialPrecStartRule() {
-		StringTemplate ruleST = recRuleTemplates.getInstanceOf("recRuleStart");
-		ruleST.setAttribute("ruleName", ruleName);
-		ruleST.setAttribute("minPrec", 0);
-		ruleST.setAttribute("userRetvals", retvals);
+		ST ruleST = recRuleTemplates.getInstanceOf("recRuleStart");
+		ruleST.add("ruleName", ruleName);
+		ruleST.add("minPrec", 0);
+		ruleST.add("userRetvals", retvals);
fillRetValAssignments(ruleST, "recRuleName");

System.out.println("start: " + ruleST);
-		return ruleST.toString();
+		return ruleST.render();
}

public String getArtificialOpPrecRule() {
-		StringTemplate ruleST = recRuleTemplates.getInstanceOf("recRule");
-		ruleST.setAttribute("ruleName", ruleName);
-		ruleST.setAttribute("buildAST", grammar.buildAST());
-		StringTemplate argDefST =
+		ST ruleST = recRuleTemplates.getInstanceOf("recRule");
+		ruleST.add("ruleName", ruleName);
+		ruleST.add("buildAST", grammar.buildAST());
+		ST argDefST =
generator.getTemplates().getInstanceOf("recRuleDefArg");
-		ruleST.setAttribute("precArgDef", argDefST);
-		StringTemplate ruleArgST =
+		ruleST.add("precArgDef", argDefST);
+		ST ruleArgST =
generator.getTemplates().getInstanceOf("recRuleArg");
-		ruleST.setAttribute("argName", ruleArgST);
-		StringTemplate setResultST =
+		ruleST.add("argName", ruleArgST);
+		ST setResultST =
generator.getTemplates().getInstanceOf("recRuleSetResultAction");
-		ruleST.setAttribute("setResultAction", setResultST);
-		ruleST.setAttribute("userRetvals", retvals);
+		ruleST.add("setResultAction", setResultST);
+		ruleST.add("userRetvals", retvals);
fillRetValAssignments(ruleST, "recPrimaryName");

LinkedHashMap<Integer, String> opPrecRuleAlts = new LinkedHashMap<Integer, String>();
@@ -231,29 +224,29 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {
opPrecRuleAlts.putAll(suffixAlts);
for (int alt : opPrecRuleAlts.keySet()) {
String altText = opPrecRuleAlts.get(alt);
-			StringTemplate altST = recRuleTemplates.getInstanceOf("recRuleAlt");
-			StringTemplate predST =
+			ST altST = recRuleTemplates.getInstanceOf("recRuleAlt");
+			ST predST =
generator.getTemplates().getInstanceOf("recRuleAltPredicate");
-			predST.setAttribute("opPrec", precedence(alt));
-			predST.setAttribute("ruleName", ruleName);
-			altST.setAttribute("pred", predST);
-			altST.setAttribute("alt", altText);
-			ruleST.setAttribute("alts", altST);
+			predST.add("opPrec", precedence(alt));
+			predST.add("ruleName", ruleName);
+			altST.add("pred", predST);
+			altST.add("alt", altText);
+			ruleST.add("alts", altST);
}

System.out.println(ruleST);

-		return ruleST.toString();
+		return ruleST.render();
}

public String getArtificialPrimaryRule() {
-		StringTemplate ruleST = recRuleTemplates.getInstanceOf("recPrimaryRule");
-		ruleST.setAttribute("ruleName", ruleName);
-		ruleST.setAttribute("alts", prefixAlts);
-		ruleST.setAttribute("alts", otherAlts);
-		ruleST.setAttribute("userRetvals", retvals);
+		ST ruleST = recRuleTemplates.getInstanceOf("recPrimaryRule");
+		ruleST.add("ruleName", ruleName);
+		ruleST.add("alts", prefixAlts);
+		ruleST.add("alts", otherAlts);
+		ruleST.add("userRetvals", retvals);
System.out.println(ruleST);
-		return ruleST.toString();
+		return ruleST.render();
}

public GrammarAST replaceRuleRefs(GrammarAST t, String name) {
@@ -324,18 +317,18 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {
return p;
}

-	public void fillRetValAssignments(StringTemplate ruleST, String srcName) {
+	public void fillRetValAssignments(ST ruleST, String srcName) {
if ( retvals==null ) return;

// complicated since we must be target-independent
for (String name : getNamesFromArgAction(retvals.token)) {
-			StringTemplate setRetValST =
+			ST setRetValST =
generator.getTemplates().getInstanceOf("recRuleSetReturnAction");
-			StringTemplate ruleNameST = recRuleTemplates.getInstanceOf(srcName);
-			ruleNameST.setAttribute("ruleName", ruleName);
-			setRetValST.setAttribute("src", ruleNameST);
-			setRetValST.setAttribute("name", name);
-			ruleST.setAttribute("userRetvalAssignments",setRetValST);
+			ST ruleNameST = recRuleTemplates.getInstanceOf(srcName);
+			ruleNameST.add("ruleName", ruleName);
+			setRetValST.add("src", ruleNameST);
+			setRetValST.add("name", name);
+			ruleST.add("userRetvalAssignments",setRetValST);
}
}

diff --git a/tool/src/main/java/org/antlr/tool/Message.java b/tool/src/main/java/org/antlr/tool/Message.java
index 5792360..5c609bb 100644
--- a/tool/src/main/java/org/antlr/tool/Message.java
+++ b/tool/src/main/java/org/antlr/tool/Message.java
@@ -27,7 +27,7 @@
*/
package org.antlr.tool;

-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

/** The ANTLR code calls methods on ErrorManager to report errors etc...
*  Rather than simply pass these arguments to the ANTLRErrorListener directly,
@@ -40,11 +40,11 @@ import org.antlr.stringtemplate.StringTemplate;
*/
public abstract class Message {
// msgST is the actual text of the message
-	public StringTemplate msgST;
+	public ST msgST;
// these are for supporting different output formats
-	public StringTemplate locationST;
-	public StringTemplate reportST;
-	public StringTemplate messageFormatST;
+	public ST locationST;
+	public ST reportST;
+	public ST messageFormatST;

public int msgID;
public Object arg;
@@ -84,45 +84,41 @@ public abstract class Message {
/** Return a new template instance every time someone tries to print
*  a Message.
*/
-	public StringTemplate getMessageTemplate() {
-		return msgST.getInstanceOf();
-	}
+	public ST getMessageTemplate() { return new ST(msgST); }

/** Return a new template instance for the location part of a Message.
*  TODO: Is this really necessary? -Kay
*/
-	public StringTemplate getLocationTemplate() {
-		return locationST.getInstanceOf();
-	}
+	public ST getLocationTemplate() { return new ST(locationST); }

-	public String toString(StringTemplate messageST) {
+	public String toString(ST messageST) {
// setup the location
locationST = ErrorManager.getLocationFormat();
reportST = ErrorManager.getReportFormat();
messageFormatST = ErrorManager.getMessageFormat();
boolean locationValid = false;
if (line != -1) {
-			locationST.setAttribute("line", line);
+			locationST.add("line", line);
locationValid = true;
}
if (column != -1) {
-			locationST.setAttribute("column", column+1);
+			locationST.add("column", column+1);
locationValid = true;
}
if (file != null) {
-			locationST.setAttribute("file", file);
+			locationST.add("file", file);
locationValid = true;
}

-		messageFormatST.setAttribute("id", msgID);
-		messageFormatST.setAttribute("text", messageST);
+		messageFormatST.add("id", msgID);
+		messageFormatST.add("text", messageST);

if (locationValid) {
-			reportST.setAttribute("location", locationST);
+			reportST.add("location", locationST);
}
-		reportST.setAttribute("message", messageFormatST);
-		reportST.setAttribute("type", ErrorManager.getMessageType(msgID));
+		reportST.add("message", messageFormatST);
+		reportST.add("type", ErrorManager.getMessageType(msgID));

-		return reportST.toString();
+		return reportST.render();
}
}
diff --git a/tool/src/main/java/org/antlr/tool/NonRegularDecisionMessage.java b/tool/src/main/java/org/antlr/tool/NonRegularDecisionMessage.java
index 1afc50a..169f99a 100644
--- a/tool/src/main/java/org/antlr/tool/NonRegularDecisionMessage.java
+++ b/tool/src/main/java/org/antlr/tool/NonRegularDecisionMessage.java
@@ -28,7 +28,7 @@
package org.antlr.tool;

import org.antlr.analysis.DecisionProbe;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

import java.util.ArrayList;
import java.util.Collections;
@@ -55,13 +55,13 @@ public class NonRegularDecisionMessage extends Message {
file = fileName;
}

-		StringTemplate st = getMessageTemplate();
+		ST st = getMessageTemplate();
String ruleName = probe.dfa.getNFADecisionStartState().enclosingRule.name;
-		st.setAttribute("ruleName", ruleName);
+		st.add("ruleName", ruleName);
List sortedAlts = new ArrayList();
sortedAlts.addAll(altsWithRecursion);
Collections.sort(sortedAlts); // make sure it's 1, 2, ...
-		st.setAttribute("alts", sortedAlts);
+		st.add("alts", sortedAlts);

return super.toString(st);
}
diff --git a/tool/src/main/java/org/antlr/tool/RecursionOverflowMessage.java b/tool/src/main/java/org/antlr/tool/RecursionOverflowMessage.java
index 1f0718e..50e72c6 100644
--- a/tool/src/main/java/org/antlr/tool/RecursionOverflowMessage.java
+++ b/tool/src/main/java/org/antlr/tool/RecursionOverflowMessage.java
@@ -29,7 +29,7 @@ package org.antlr.tool;

import org.antlr.analysis.DFAState;
import org.antlr.analysis.DecisionProbe;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

import java.util.Collection;
import java.util.List;
@@ -67,15 +67,15 @@ public class RecursionOverflowMessage extends Message {
file = fileName;
}

-		StringTemplate st = getMessageTemplate();
-		st.setAttribute("targetRules", targetRules);
-		st.setAttribute("alt", alt);
-		st.setAttribute("callSiteStates", callSiteStates);
+		ST st = getMessageTemplate();
+		st.add("targetRules", targetRules);
+		st.add("alt", alt);
+		st.add("callSiteStates", callSiteStates);

List labels =
probe.getSampleNonDeterministicInputSequence(sampleBadState);
String input = probe.getInputSequenceDisplay(labels);
-		st.setAttribute("input", input);
+		st.add("input", input);

return super.toString(st);
}
diff --git a/tool/src/main/java/org/antlr/tool/Rule.java b/tool/src/main/java/org/antlr/tool/Rule.java
index 4a1bfed..0c141f3 100644
--- a/tool/src/main/java/org/antlr/tool/Rule.java
+++ b/tool/src/main/java/org/antlr/tool/Rule.java
@@ -439,7 +439,7 @@ public class Rule {
else {
grammar.defineRuleRefLabel(name, label, uniqueRefAST);
}
-			uniqueRefAST.code.setAttribute("label", labelName);
+			uniqueRefAST.code.add("label", labelName);
}
return labelName;
}
diff --git a/tool/src/main/java/org/antlr/tool/ToolMessage.java b/tool/src/main/java/org/antlr/tool/ToolMessage.java
index e188f73..6bbd5c0 100644
--- a/tool/src/main/java/org/antlr/tool/ToolMessage.java
+++ b/tool/src/main/java/org/antlr/tool/ToolMessage.java
@@ -27,7 +27,7 @@
*/
package org.antlr.tool;

-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;

/** A generic message from the tool such as "file not found" type errors; there
*  is no reason to create a special object for each error unlike the grammar
@@ -59,16 +59,16 @@ public class ToolMessage extends Message {
this.e = e;
}
public String toString() {
-		StringTemplate st = getMessageTemplate();
+		ST st = getMessageTemplate();
if ( arg!=null ) {
-			st.setAttribute("arg", arg);
+			st.add("arg", arg);
}
if ( arg2!=null ) {
-			st.setAttribute("arg2", arg2);
+			st.add("arg2", arg2);
}
if ( e!=null ) {
-			st.setAttribute("exception", e);
-			st.setAttribute("stackTrace", e.getStackTrace());
+			st.add("exception", e);
+			st.add("stackTrace", e.getStackTrace());
}
return super.toString(st);
}
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
index e2d9cc2..8ba155b 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
@@ -25,7 +25,6 @@
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
-group AST;

@outputFile.imports() ::= <<
<@super.imports()>
@@ -65,12 +64,12 @@ ruleDeclarations() ::= <<
ruleLabelDefs() ::= <<
<super.ruleLabelDefs()>
<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,
-  ruleDescriptor.wildcardTreeListLabels]:{<ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
-<ruleDescriptor.tokenListLabels:{<ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
+  ruleDescriptor.wildcardTreeListLabels]:{it | <ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
+<ruleDescriptor.tokenListLabels:{it | <ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
<ruleDescriptor.allTokenRefsInAltsWithRewrites
-    :{RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
+    :{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
<ruleDescriptor.allRuleRefsInAltsWithRewrites
-    :{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
+    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
>>

/** When doing auto AST construction, we must define some variables;
@@ -92,7 +91,7 @@ root_0 = (<ASTLabelType>)adaptor.nil();<\n>

/** ID and track it for use in a rewrite rule */
tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRefBang(...)> <! Track implies no auto AST construction!>
+<tokenRefBang(token,label,elementIndex,terminalOptions)> <! Track implies no auto AST construction!>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<token>.add(<label>);<\n>
>>

@@ -100,44 +99,44 @@ tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
*  to the tracking list stream_ID for use in the rewrite.
*/
tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRefTrack(...)>
-<listLabel(elem=label,...)>
+<tokenRefTrack(token,label,elementIndex,terminalOptions)>
+<listLabel(label, label)>
>>

/** ^(ID ...) track for rewrite */
tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRefBang(...)>
+<tokenRefBang(token,label,elementIndex,terminalOptions)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<token>.add(<label>);<\n>
>>

/** Match ^(label+=TOKEN ...) track for rewrite */
tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRefRuleRootTrack(...)>
-<listLabel(elem=label,...)>
+<tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions)>
+<listLabel(label, label)>
>>

/** rule when output=AST and tracking for rewrite */
ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
-<super.ruleRef(...)>
+<super.ruleRef(rule,label,elementIndex,args,scope)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<rule.name>.add(<label>.getTree());
>>

/** x+=rule when output=AST and tracking for rewrite */
ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefTrack(...)>
-<listLabel(elem=label+".getTree()",...)>
+<ruleRefTrack(rule,label,elementIndex,args,scope)>
+<listLabel(label, {<label>.getTree()})>
>>

/** ^(rule ...) rewrite */
ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRoot(...)>
+<ruleRefRuleRoot(rule,label,elementIndex,args,scope)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<rule>.add(<label>.getTree());
>>

/** ^(x+=rule ...) rewrite */
ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRootTrack(...)>
-<listLabel(elem=label+".getTree()",...)>
+<ruleRefRuleRootTrack(rule,label,elementIndex,args,scope)>
+<listLabel(label, {<label>.getTree()})>
>>

// R e w r i t e
@@ -193,27 +192,27 @@ input.replaceChildren(adaptor.getParent(retval.start),

rewriteCodeLabels() ::= <<
<referencedTokenLabels
-    :{RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
+    :{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
separator="\n"
>
<referencedTokenListLabels
-    :{RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
+    :{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
separator="\n"
>
<referencedWildcardLabels
-    :{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
+    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
separator="\n"
>
<referencedWildcardListLabels
-    :{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
+    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
separator="\n"
>
<referencedRuleLabels
-    :{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.tree:null);};
+    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.tree:null);};
separator="\n"
>
<referencedRuleListLabels
-    :{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
+    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
separator="\n"
>
>>
@@ -297,7 +296,7 @@ rewriteElement(e) ::= <<

/** Gen ID or ID[args] */
rewriteTokenRef(token,elementIndex,terminalOptions,args) ::= <<
-adaptor.addChild(root_<treeLevel>, <createRewriteNodeFromElement(...)>);<\n>
+adaptor.addChild(root_<treeLevel>, <createRewriteNodeFromElement(token,terminalOptions,args)>);<\n>
>>

/** Gen $label ... where defined via label=ID */
@@ -320,15 +319,15 @@ rewriteTokenListLabelRefRoot ::= rewriteTokenLabelRefRoot

/** Gen ^(ID ...) or ^(ID[args] ...) */
rewriteTokenRefRoot(token,elementIndex,terminalOptions,args) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<createRewriteNodeFromElement(...)>, root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<createRewriteNodeFromElement(token,terminalOptions,args)>, root_<treeLevel>);<\n>
>>

rewriteImaginaryTokenRef(args,token,terminalOptions,elementIndex) ::= <<
-adaptor.addChild(root_<treeLevel>, <createImaginaryNode(tokenType=token, ...)>);<\n>
+adaptor.addChild(root_<treeLevel>, <createImaginaryNode(token,terminalOptions,args)>);<\n>
>>

rewriteImaginaryTokenRefRoot(args,token,terminalOptions,elementIndex) ::= <<
-root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<createImaginaryNode(tokenType=token, ...)>, root_<treeLevel>);<\n>
+root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<createImaginaryNode(token,terminalOptions,args)>, root_<treeLevel>);<\n>
>>

/** plain -> {foo} action */
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTDbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTDbg.stg
index 6eb204f..886e198 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTDbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTDbg.stg
@@ -29,7 +29,6 @@
/** Template overrides to add debugging to AST stuff.  Dynamic inheritance
*  hierarchy is set up as ASTDbg : AST : Dbg : Java by code generator.
*/
-group ASTDbg;

parserMembers() ::= <<
protected DebugTreeAdaptor adaptor;
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
index d3fc37e..1ac8e20 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTParser.stg
@@ -37,7 +37,6 @@
*  The situation is not too bad as rewrite (->) usage makes ^ and !
*  invalid. There is no huge explosion of combinations.
*/
-group ASTParser;

@rule.setErrorReturnValue() ::= <<
retval.tree = (<ASTLabelType>)adaptor.errorNode(input, retval.start, input.LT(-1), re);
@@ -48,41 +47,41 @@ retval.tree = (<ASTLabelType>)adaptor.errorNode(input, retval.start, input.LT(-1

/** ID and output=AST */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
-<super.tokenRef(...)>
+<super.tokenRef(token,label,elementIndex,terminalOptions)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
-<label>_tree = <createNodeFromToken(...)>;
+<label>_tree = <createNodeFromToken(label,terminalOptions)>;
adaptor.addChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
>>

/** ID! and output=AST (same as plain tokenRef) */
-tokenRefBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"
+tokenRefBang(token,label,elementIndex,terminalOptions) ::= "<super.tokenRef(token,label,elementIndex,terminalOptions)>"

/** ID^ and output=AST */
tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
-<super.tokenRef(...)>
+<super.tokenRef(token,label,elementIndex,terminalOptions)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
-<label>_tree = <createNodeFromToken(...)>;
+<label>_tree = <createNodeFromToken(label,terminalOptions)>;
root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
>>

/** ids+=ID! and output=AST */
tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRefBang(...)>
-<listLabel(elem=label,...)>
+<tokenRefBang(token,label,elementIndex,terminalOptions)>
+<listLabel(label, label)>
>>

/** label+=TOKEN when output=AST but not rewrite alt */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRef(...)>
-<listLabel(elem=label,...)>
+<tokenRef(token,label,elementIndex,terminalOptions)>
+<listLabel(label, label)>
>>

/** Match label+=TOKEN^ when output=AST but not rewrite alt */
tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
-<tokenRefRuleRoot(...)>
-<listLabel(elem=label,...)>
+<tokenRefRuleRoot(token,label,elementIndex,terminalOptions)>
+<listLabel(label, label)>
>>

// SET AST
@@ -98,15 +97,15 @@ tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
// rather than just added on code.  Investigate that refactoring when
// I have more time.

-matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
-<super.matchSet(..., postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.addChild(root_0, <createNodeFromToken(...)>);})>
->>
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <%
+<super.matchSet(postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.addChild(root_0, <createNodeFromToken(label,terminalOptions)>);}, ...)>
+%>

matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
<matchSet(...)>
>>

-matchSetBang(s,label,elementIndex,postmatchCode) ::= "<super.matchSet(...)>"
+matchSetBang(s,label,elementIndex,terminalOptions,postmatchCode) ::= "<super.matchSet(...)>"

// note there is no matchSetTrack because -> rewrites force sets to be
// plain old blocks of alts: (A|B|...|C)
@@ -115,47 +114,47 @@ matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
-<super.matchSet(..., postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.becomeRoot(<createNodeFromToken(...)>, root_0);})>
+<super.matchSet(postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.becomeRoot(<createNodeFromToken(label,terminalOptions)>, root_0);},...)>
>>

// RULE REF AST

/** rule when output=AST */
ruleRef(rule,label,elementIndex,args,scope) ::= <<
-<super.ruleRef(...)>
+<super.ruleRef(rule,label,elementIndex,args,scope)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.addChild(root_0, <label>.getTree());
>>

/** rule! is same as normal rule ref */
-ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(...)>"
+ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(rule,label,elementIndex,args,scope)>"

/** rule^ */
ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
-<super.ruleRef(...)>
+<super.ruleRef(rule,label,elementIndex,args,scope)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.becomeRoot(<label>.getTree(), root_0);
>>

/** x+=rule when output=AST */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRef(...)>
-<listLabel(elem=label+".getTree()",...)>
+<listLabel(label, {<label>.getTree()})>
>>

/** x+=rule! when output=AST is a rule ref with list addition */
ruleRefBangAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefBang(...)>
-<listLabel(elem=label+".getTree()",...)>
+<ruleRefBang(rule,label,elementIndex,args,scope)>
+<listLabel(label, {<label>.getTree()})>
>>

/** x+=rule^ */
ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRefRuleRoot(...)>
-<listLabel(elem=label+".getTree()",...)>
+<ruleRefRuleRoot(rule,label,elementIndex,args,scope)>
+<listLabel(label, {<label>.getTree()})>
>>

// WILDCARD AST

-wildcard(label,elementIndex) ::= <<
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
<super.wildcard(...)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.create(<label>);
@@ -165,7 +164,7 @@ adaptor.addChild(root_0, <label>_tree);

wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"

-wildcardRuleRoot(label,elementIndex) ::= <<
+wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
<super.wildcard(...)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.create(<label>);
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
index 22ade93..97c1fb4 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
@@ -37,7 +37,6 @@
*  Each combination has its own template except that label/no label
*  is combined into tokenRef, ruleRef, ...
*/
-group ASTTreeParser;

/** Add a variable to track last element matched */
ruleDeclarations() ::= <<
@@ -104,15 +103,15 @@ _last = _save_last_<treeLevel>;
/** ID! and output=AST (same as plain tokenRef) 'cept add
*  setting of _last
*/
-tokenRefBang(token,label,elementIndex) ::= <<
+tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
+<super.tokenRef(token,label,elementIndex,terminalOptions)>
>>

/** ID auto construct */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
+<super.tokenRef(token,label,elementIndex,terminalOptions)>
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(terminalOptions.node)>
@@ -130,14 +129,14 @@ if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;

/** label+=TOKEN auto construct */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRef(...)>
-<listLabel(elem=label,...)>
+<tokenRef(token,label,elementIndex,terminalOptions)>
+<listLabel(label, label)>
>>

/** ^(ID ...) auto construct */
tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
-<super.tokenRef(...)>
+<super.tokenRef(token,label,elementIndex,terminalOptions)>
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(terminalOptions.node)>
@@ -152,8 +151,8 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_<treeLe

/** Match ^(label+=TOKEN ...) auto construct */
tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRefRuleRoot(...)>
-<listLabel(elem=label,...)>
+<tokenRefRuleRoot(token,label,elementIndex,terminalOptions)>
+<listLabel(label, label)>
>>

/** Match . wildcard and auto dup the node/subtree */
@@ -175,7 +174,7 @@ if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;

matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
_last = (<ASTLabelType>)input.LT(1);
-<super.matchSet(..., postmatchCode={
+<super.matchSet(postmatchCode={
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(terminalOptions.node)>
@@ -184,24 +183,24 @@ _last = (<ASTLabelType>)input.LT(1);
<label>_tree = (<ASTLabelType>)adaptor.dupNode(<label>);
<endif><\n>
adaptor.addChild(root_<treeLevel>, <label>_tree);
-<if(backtracking)>}<endif>
+<if(backtracking)>\}<endif>
<endif>
-}
+}, ...
)>
>>

matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
<matchSet(...)>
-<noRewrite()> <! set return tree !>
+<noRewrite(...)> <! set return tree !>
>>

-matchSetBang(s,label,elementIndex,postmatchCode) ::= <<
+matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(...)>
>>

matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
-<super.matchSet(..., postmatchCode={
+<super.matchSet(postmatchCode={
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(terminalOptions.node)>
@@ -210,9 +209,9 @@ matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<label>_tree = (<ASTLabelType>)adaptor.dupNode(<label>);
<endif><\n>
root_<treeLevel> = (<ASTLabelType>)adaptor.becomeRoot(<label>_tree, root_<treeLevel>);
-<if(backtracking)>}<endif>
+<if(backtracking)>\}<endif>
<endif>
-}
+}, ...
)>
>>

@@ -233,7 +232,7 @@ if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>.tree;
/** x+=rule auto construct */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRef(...)>
-<listLabel(elem=label+".getTree()",...)>
+<listLabel(label, {<label>.getTree()})>
>>

/** ^(rule ...) auto construct */
@@ -248,7 +247,7 @@ _last = (<ASTLabelType>)input.LT(1);
/** ^(x+=rule ...) auto construct */
ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRefRuleRoot(...)>
-<listLabel(elem=label+".getTree()",...)>
+<listLabel(label, {<label>.getTree()})>
>>

/** rule when output=AST and tracking for rewrite */
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
index 847b85f..72c8939 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/Dbg.stg
@@ -28,8 +28,6 @@
/** Template overrides to add debugging to normal Java output;
*  If ASTs are built, then you'll also get ASTDbg.stg loaded.
*/
-group Dbg;
-
@outputFile.imports() ::= <<
<@super.imports()>
import org.antlr.runtime.debug.*;
@@ -229,10 +227,10 @@ enterAlt(n) ::= "dbg.enterAlt(<n>);<\n>"

@closureBlock.postdecision() ::= "<exitDecision()>"

-@altSwitchCase.prealt() ::= "<enterAlt(n=i)>"
+@altSwitchCase.prealt() ::= "<enterAlt(altNum)>" // altNum is arg of altSwitchCase

@element.prematch() ::=
-    "dbg.location(<it.line>,<it.pos>);"
+    "dbg.location(<e.line>,<e.pos>);" // e is arg of element

@matchSet.mismatchedSetException() ::=
"dbg.recognitionException(mse);"
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
index 29f7192..1cc0433 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
@@ -25,7 +25,6 @@
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
-group Java;

javaTypeInitMap ::= [
"int":"0",
@@ -82,11 +81,11 @@ import java.util.HashMap;
<recognizer>
>>

-lexer(grammar, name, tokens, scopes, rules, numRules, labelType="CommonToken",
-      filterMode, superClass="Lexer") ::= <<
+lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
+      superClass="Lexer") ::= <<
public class <grammar.recognizerName> extends <@superClassName><superClass><@end> {
-    <tokens:{public static final int <it.name>=<it.type>;}; separator="\n">
-    <scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+    <tokens:{it | public static final int <it.name>=<it.type>;}; separator="\n">
+    <scopes:{it |<if(it.isDynamicGlobalScope)><globalAttributeScope(it)><endif>}>
<actions.lexer.members>

// delegates
@@ -200,15 +199,15 @@ filteringActionGate() ::= "state.backtracking==1"
/** How to generate a parser */
genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
bitsets, inputStreamType, superClass,
-              ASTLabelType="Object", labelType, members, rewriteElementType,
-              filterMode) ::= <<
+              labelType, members, rewriteElementType,
+              filterMode, ASTLabelType="Object") ::= <<
public class <grammar.recognizerName> extends <@superClassName><superClass><@end> {
<if(grammar.grammarIsRoot)>
public static final String[] tokenNames = new String[] {
"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
};<\n>
<endif>
-    <tokens:{public static final int <it.name>=<it.type>;}; separator="\n">
+    <tokens:{it |public static final int <it.name>=<it.type>;}; separator="\n">

// delegates
<grammar.delegates: {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
@@ -221,7 +220,7 @@ public class <grammar.recognizerName> extends <@superClassName><superClass><@end
{g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>

-    <scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+    <scopes:{it |<if(it.isDynamicGlobalScope)><globalAttributeScope(it)><endif>}>

<@members>
<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
@@ -249,15 +248,15 @@ public class <grammar.recognizerName> extends <@superClassName><superClass><@end
appear to be defined in this recognizer. !>
// Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-    public <returnType()> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) throws RecognitionException \{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">
+    public <returnType()> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope()>) throws RecognitionException { <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">

<synpreds:{p | <synpred(p)>}>

<cyclicDFAs:{dfa | protected DFA<dfa.decisionNumber> dfa<dfa.decisionNumber> = new DFA<dfa.decisionNumber>(this);}; separator="\n">
<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>

-    <bitsets:bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
-                    words64=it.bits)>
+    <bitsets:{it | <bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
+                          words64=it.bits)>}>
}
>>

@@ -274,18 +273,24 @@ this.state.ruleMemo = new HashMap[<length(grammar.allImportedRules)>+1];<\n> <!
parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
ASTLabelType="Object", superClass="Parser", labelType="Token",
members={<actions.parser.members>}) ::= <<
-<genericParser(inputStreamType="TokenStream", rewriteElementType="Token", ...)>
+<genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
+              bitsets, "TokenStream", superClass,
+              labelType, members, "Token",
+              false, ASTLabelType)>
>>

/** How to generate a tree parser; same as parser except the input
*  stream is a different type.
*/
treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
-           numRules, bitsets, labelType={<ASTLabelType>}, ASTLabelType="Object",
+           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="Object",
superClass={<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif>},
-           members={<actions.treeparser.members>},
-           filterMode) ::= <<
-<genericParser(inputStreamType="TreeNodeStream", rewriteElementType="Node", ...)>
+           members={<actions.treeparser.members>}
+           ) ::= <<
+<genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
+              bitsets, "TreeNodeStream", superClass,
+              labelType, members, "Node",
+              filterMode, ASTLabelType)>
>>

/** A simpler version of a rule template that is specific to the imaginary
@@ -298,7 +303,7 @@ treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
// $ANTLR start <ruleName>
-public final void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) throws RecognitionException {
+public final void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>) throws RecognitionException {
<ruleLabelDefs()>
<if(trace)>
traceIn("<ruleName>_fragment", <ruleDescriptor.index>);
@@ -363,7 +368,7 @@ rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memo

// $ANTLR start "<ruleName>"
// <fileName>:<description>
-public final <returnType()> <ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) throws RecognitionException {
+public final <returnType()> <ruleName>(<ruleDescriptor.parameterScope:parameterScope()>) throws RecognitionException {
<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
<ruleScopeSetUp()>
<ruleDeclarations()>
@@ -425,25 +430,25 @@ int <ruleDescriptor.name>_StartIndex = input.index();
>>

ruleScopeSetUp() ::= <<
-<ruleDescriptor.useScopes:{<it>_stack.push(new <it>_scope());}; separator="\n">
-<ruleDescriptor.ruleScope:{<it.name>_stack.push(new <it.name>_scope());}; separator="\n">
+<ruleDescriptor.useScopes:{it |<it>_stack.push(new <it>_scope());}; separator="\n">
+<ruleDescriptor.ruleScope:{it |<it.name>_stack.push(new <it.name>_scope());}; separator="\n">
>>

ruleScopeCleanUp() ::= <<
-<ruleDescriptor.useScopes:{<it>_stack.pop();}; separator="\n">
-<ruleDescriptor.ruleScope:{<it.name>_stack.pop();}; separator="\n">
+<ruleDescriptor.useScopes:{it |<it>_stack.pop();}; separator="\n">
+<ruleDescriptor.ruleScope:{it |<it.name>_stack.pop();}; separator="\n">
>>


ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,
ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{<labelType> <it.label.text>=null;}; separator="\n"
+    :{it |<labelType> <it.label.text>=null;}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{List list_<it.label.text>=null;}; separator="\n"
+    :{it |List list_<it.label.text>=null;}; separator="\n"
>
-<ruleDescriptor.ruleLabels:ruleLabelDef(label=it); separator="\n">
+<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
<ruleDescriptor.ruleListLabels:{ll|RuleReturnScope <ll.label.text> = null;}; separator="\n">
>>

@@ -451,16 +456,16 @@ lexerRuleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,
ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleLabels]
-    :{<labelType> <it.label.text>=null;}; separator="\n"
+    :{it |<labelType> <it.label.text>=null;}; separator="\n"
>
-<ruleDescriptor.charLabels:{int <it.label.text>;}; separator="\n">
+<ruleDescriptor.charLabels:{it |int <it.label.text>;}; separator="\n">
<[ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleListLabels]
-    :{List list_<it.label.text>=null;}; separator="\n"
+    :{it |List list_<it.label.text>=null;}; separator="\n"
>
>>

-ruleReturnValue() ::= <<
+ruleReturnValue() ::= <%
<if(!ruleDescriptor.isSynPred)>
<if(ruleDescriptor.hasReturnValue)>
<if(ruleDescriptor.hasSingleReturnValue)>
@@ -470,7 +475,7 @@ retval
<endif>
<endif>
<endif>
->>
+%>

ruleCleanUp() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
@@ -493,7 +498,7 @@ if ( state.backtracking>0 ) { memoize(input, <ruleDescriptor.index>, <ruleDescri
*/
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
// $ANTLR start "<ruleName>"
-public final void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) throws RecognitionException {
+public final void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>) throws RecognitionException {
<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
<ruleScopeSetUp()>
<ruleDeclarations()>
@@ -547,7 +552,7 @@ int alt<decisionNumber>=<maxAlt>;
<@postdecision()>
<@prebranch()>
switch (alt<decisionNumber>) {
-    <alts:altSwitchCase()>
+    <alts:{a | <altSwitchCase(i,a)>}>
}
<@postbranch()>
>>
@@ -561,7 +566,7 @@ int alt<decisionNumber>=<maxAlt>;
<decision>
<@postdecision()>
switch (alt<decisionNumber>) {
-    <alts:altSwitchCase()>
+    <alts:{a | <altSwitchCase(i,a)>}>
}
>>

@@ -595,7 +600,7 @@ do {
<decision>
<@postdecision()>
switch (alt<decisionNumber>) {
-	<alts:altSwitchCase()>
+	<alts:{a | <altSwitchCase(i,a)>}>
default :
if ( cnt<decisionNumber> >= 1 ) break loop<decisionNumber>;
<ruleBacktrackFailure()>
@@ -623,7 +628,7 @@ do {
<decision>
<@postdecision()>
switch (alt<decisionNumber>) {
-	<alts:altSwitchCase()>
+	<alts:{a | <altSwitchCase(i,a)>}>
default :
break loop<decisionNumber>;
}
@@ -644,10 +649,10 @@ optionalBlockSingleAlt ::= block
*  number.  A DFA predicts the alternative and then a simple switch
*  does the jump to the code that actually matches that alternative.
*/
-altSwitchCase() ::= <<
-case <i> :
+altSwitchCase(altNum,alt) ::= <<
+case <altNum> :
<@prealt()>
-    <it>
+    <alt>
break;<\n>
>>

@@ -670,9 +675,9 @@ noRewrite(rewriteBlockLevel, treeLevel) ::= ""
// E L E M E N T S

/** Dump the elements one per line */
-element() ::= <<
+element(e) ::= <<
<@prematch()>
-<it.el><\n>
+<e.el><\n>
>>

/** match a token optionally with a label in front */
@@ -682,8 +687,8 @@ tokenRef(token,label,elementIndex,terminalOptions) ::= <<

/** ids+=ID */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
-<tokenRef(...)>
-<listLabel(elem=label,...)>
+<tokenRef(token,label,elementIndex,terminalOptions)>
+<listLabel(label, label)>
>>

listLabel(label,elem) ::= <<
@@ -708,7 +713,7 @@ matchRange(<a>,<b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,elementIndex,postmatchCode="") ::= <<
+matchSet(s,label,elementIndex,terminalOptions,postmatchCode="") ::= <<
<if(label)>
<if(LEXER)>
<label>= input.LA(1);<\n>
@@ -744,7 +749,7 @@ matchRuleBlockSet ::= matchSet

matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
<matchSet(...)>
-<listLabel(elem=label,...)>
+<listLabel(label, label)>
>>

/** Match a string literal */
@@ -762,16 +767,16 @@ match(<string>); <checkRuleBacktrackFailure()><\n>
<endif>
>>

-wildcard(label,elementIndex) ::= <<
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
matchAny(input); <checkRuleBacktrackFailure()>
>>

-wildcardAndListLabel(label,elementIndex) ::= <<
+wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<wildcard(...)>
-<listLabel(elem=label,...)>
+<listLabel(label, label)>
>>

/** Match . wildcard in lexer */
@@ -783,8 +788,8 @@ matchAny(); <checkRuleBacktrackFailure()>
>>

wildcardCharListLabel(label, elementIndex) ::= <<
-<wildcardChar(...)>
-<listLabel(elem=label,...)>
+<wildcardChar(label, elementIndex)>
+<listLabel(label, label)>
>>

/** Match a rule reference by invoking it possibly with arguments
@@ -802,8 +807,8 @@ state._fsp--;

/** ids+=r */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRef(...)>
-<listLabel(elem=label,...)>
+<ruleRef(rule,label,elementIndex,args,scope)>
+<listLabel(label, label)>
>>

/** A lexer rule reference.
@@ -828,8 +833,8 @@ int <label>StartCharPos<elementIndex> = getCharPositionInLine();

/** i+=INT in lexer */
lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
-<lexerRuleRef(...)>
-<listLabel(elem=label,...)>
+<lexerRuleRef(rule,label,args,elementIndex,scope)>
+<listLabel(label, label)>
>>

/** EOF in the lexer */
@@ -876,7 +881,7 @@ match(input, Token.UP, null); <checkRuleBacktrackFailure()>
*  also hoisted into a prediction expression).
*/
validateSemanticPredicate(pred,description) ::= <<
-if ( !(<evalPredicate(...)>) ) {
+if ( !(<evalPredicate(pred,description)>) ) {
<ruleBacktrackFailure()>
throw new FailedPredicateException(input, "<ruleName>", "<description>");
}
@@ -982,7 +987,7 @@ default:
>>

dfaEdgeSwitch(labels, targetState) ::= <<
-<labels:{case <it>:}; separator="\n">
+<labels:{it |case <it>:}; separator="\n">
{
<targetState>
}
@@ -1125,7 +1130,7 @@ andPredicates(left,right) ::= "(<left>&&<right>)"

orPredicates(operands) ::= "(<first(operands)><rest(operands):{o | ||<o>}>)"

-notPredicate(pred) ::= "!(<evalPredicate(...)>)"
+notPredicate(pred) ::= "!(<evalPredicate(pred,{})>)"

evalPredicate(pred,description) ::= "(<pred>)"

@@ -1138,20 +1143,22 @@ lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
*/
isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

-lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
-(LA<decisionNumber>_<stateNumber>\>=<lower> && LA<decisionNumber>_<stateNumber>\<=<upper>)
->>
+lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
+(LA<decisionNumber>_<stateNumber> >= <lower> && LA<decisionNumber>_<stateNumber> \<= <upper>)
+%>

-isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)\>=<lower> && input.LA(<k>)\<=<upper>)"
+isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>) >= <lower> && input.LA(<k>) \<= <upper>)"

-setTest(ranges) ::= "<ranges; separator=\"||\">"
+setTest(ranges) ::= <<
+<ranges; separator="||">
+>>

// A T T R I B U T E S

globalAttributeScope(scope) ::= <<
<if(scope.attributes)>
protected static class <scope.name>_scope {
-    <scope.attributes:{<it.decl>;}; separator="\n">
+    <scope.attributes:{it |<it.decl>;}; separator="\n">
}
protected Stack <scope.name>_stack = new Stack();<\n>
<endif>
@@ -1160,15 +1167,15 @@ protected Stack <scope.name>_stack = new Stack();<\n>
ruleAttributeScope(scope) ::= <<
<if(scope.attributes)>
protected static class <scope.name>_scope {
-    <scope.attributes:{<it.decl>;}; separator="\n">
+    <scope.attributes:{it |<it.decl>;}; separator="\n">
}
protected Stack <scope.name>_stack = new Stack();<\n>
<endif>
>>

-returnStructName() ::= "<it.name>_return"
+returnStructName(r) ::= "<r.name>_return"

-returnType() ::= <<
+returnType() ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
<else>
@@ -1178,12 +1185,12 @@ returnType() ::= <<
void
<endif>
<endif>
->>
+%>

/** Generate the Java type associated with a single or multiple return
*  values.
*/
-ruleLabelType(referencedRule) ::= <<
+ruleLabelType(referencedRule) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
<referencedRule.grammar.recognizerName>.<referencedRule.name>_return
<else>
@@ -1193,10 +1200,10 @@ ruleLabelType(referencedRule) ::= <<
void
<endif>
<endif>
->>
+%>

-delegateName() ::= <<
-<if(it.label)><it.label><else>g<it.name><endif>
+delegateName(d) ::= <<
+<if(d.label)><d.label><else>g<d.name><endif>
>>

/** Using a type to init value map, try to init a type; if not in table
@@ -1207,9 +1214,10 @@ initValue(typeName) ::= <<
>>

/** Define a rule label including default value */
-ruleLabelDef(label) ::= <<
-<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> = <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;<\n>
->>
+ruleLabelDef(label) ::= <%
+<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> =
+ <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;<\n>
+%>

/** Define a return struct for a rule if the code needs to access its
*  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
@@ -1218,20 +1226,20 @@ ruleLabelDef(label) ::= <<
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
public static class <ruleDescriptor:returnStructName()> extends <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope {
-    <scope.attributes:{public <it.decl>;}; separator="\n">
+    <scope.attributes:{it |public <it.decl>;}; separator="\n">
<@ruleReturnMembers()>
};
<endif>
>>

parameterScope(scope) ::= <<
-<scope.attributes:{<it.decl>}; separator=", ">
+<scope.attributes:{it |<it.decl>}; separator=", ">
>>

parameterAttributeRef(attr) ::= "<attr.name>"
parameterSetAttributeRef(attr,expr) ::= "<attr.name> =<expr>;"

-scopeAttributeRef(scope,attr,index,negIndex) ::= <<
+scopeAttributeRef(scope,attr,index,negIndex) ::= <%
<if(negIndex)>
((<scope>_scope)<scope>_stack.elementAt(<scope>_stack.size()-<negIndex>-1)).<attr.name>
<else>
@@ -1241,9 +1249,9 @@ scopeAttributeRef(scope,attr,index,negIndex) ::= <<
((<scope>_scope)<scope>_stack.peek()).<attr.name>
<endif>
<endif>
->>
+%>

-scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
+scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
<if(negIndex)>
((<scope>_scope)<scope>_stack.elementAt(<scope>_stack.size()-<negIndex>-1)).<attr.name> =<expr>;
<else>
@@ -1253,7 +1261,7 @@ scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
((<scope>_scope)<scope>_stack.peek()).<attr.name> =<expr>;
<endif>
<endif>
->>
+%>

/** $x is either global scope or x is rule with dynamic scope; refers
*  to stack itself not top of stack.  This is useful for predicates
@@ -1262,29 +1270,29 @@ scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
isolatedDynamicScopeRef(scope) ::= "<scope>_stack"

/** reference an attribute of rule; might only have single return value */
-ruleLabelRef(referencedRule,scope,attr) ::= <<
+ruleLabelRef(referencedRule,scope,attr) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
(<scope>!=null?<scope>.<attr.name>:<initValue(attr.type)>)
<else>
<scope>
<endif>
->>
+%>

-returnAttributeRef(ruleDescriptor,attr) ::= <<
+returnAttributeRef(ruleDescriptor,attr) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.<attr.name>
<else>
<attr.name>
<endif>
->>
+%>

-returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <<
+returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.<attr.name> =<expr>;
<else>
<attr.name> =<expr>;
<endif>
->>
+%>

/** How to translate $tokenLabel */
tokenLabelRef(label) ::= "<label>"
@@ -1307,7 +1315,7 @@ tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?Integer.valueOf(<scope
ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.start):null)"
ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.stop):null)"
ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.tree):null)"
-ruleLabelPropertyRef_text(scope,attr) ::= <<
+ruleLabelPropertyRef_text(scope,attr) ::= <%
<if(TREE_PARSER)>
(<scope>!=null?(input.getTokenStream().toString(
input.getTreeAdaptor().getTokenStartIndex(<scope>.start),
@@ -1315,7 +1323,7 @@ ruleLabelPropertyRef_text(scope,attr) ::= <<
<else>
(<scope>!=null?input.toString(<scope>.start,<scope>.stop):null)
<endif>
->>
+%>

ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?<scope>.st:null)"

@@ -1341,7 +1349,7 @@ lexerRuleLabelPropertyRef_int(scope,attr) ::=
rulePropertyRef_start(scope,attr) ::= "((<labelType>)retval.start)"
rulePropertyRef_stop(scope,attr) ::= "((<labelType>)retval.stop)"
rulePropertyRef_tree(scope,attr) ::= "((<ASTLabelType>)retval.tree)"
-rulePropertyRef_text(scope,attr) ::= <<
+rulePropertyRef_text(scope,attr) ::= <%
<if(TREE_PARSER)>
input.getTokenStream().toString(
input.getTreeAdaptor().getTokenStartIndex(retval.start),
@@ -1349,7 +1357,7 @@ input.getTokenStream().toString(
<else>
input.toString(retval.start,input.LT(-1))
<endif>
->>
+%>
rulePropertyRef_st(scope,attr) ::= "retval.st"

lexerRulePropertyRef_text(scope,attr) ::= "getText()"
@@ -1368,7 +1376,7 @@ ruleSetPropertyRef_tree(scope,attr,expr) ::= "retval.tree =<expr>;"
ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.st =<expr>;"

/** How to execute an action (only when not backtracking) */
-execAction(action) ::= <<
+execAction(action) ::= <%
<if(backtracking)>
if ( <actions.(actionScope).synpredgate> ) {
<action>
@@ -1376,7 +1384,7 @@ if ( <actions.(actionScope).synpredgate> ) {
<else>
<action>
<endif>
->>
+%>

/** How to always execute an action even when backtracking */
execForcedAction(action) ::= "<action>"
@@ -1384,10 +1392,10 @@ execForcedAction(action) ::= "<action>"
// M I S C (properties, etc...)

bitset(name, words64) ::= <<
-public static final BitSet <name> = new BitSet(new long[]{<words64:{<it>L};separator=",">});<\n>
+public static final BitSet <name> = new BitSet(new long[]{<words64:{it |<it>L};separator=",">});<\n>
>>

codeFileExtension() ::= ".java"

-true() ::= "true"
-false() ::= "false"
+true_value() ::= "true"
+false_value() ::= "false"
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ST.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ST.stg
index 861e0a5..a898e4d 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ST.stg
@@ -28,7 +28,6 @@
/** Template subgroup to add template rewrite output
*  If debugging, then you'll also get STDbg.stg loaded.
*/
-group ST;

@outputFile.imports() ::= <<
<@super.imports()>
@@ -72,8 +71,8 @@ public static class STAttrMap extends HashMap {

/** x+=rule when output=template */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
-<ruleRef(...)>
-<listLabel(elem=label+".getTemplate()",...)>
+<ruleRef(rule,label,elementIndex,args,scope)>
+<listLabel(label, {<label>.getTemplate()})>
>>

rewriteTemplate(alts) ::= <<
@@ -104,15 +103,15 @@ replaceTextInLine() ::= <<
<endif>
>>

-rewriteTemplateAlt() ::= <<
-// <it.description>
-<if(it.pred)>
-if (<it.pred>) {
-    retval.st = <it.alt>;
+rewriteTemplateAlt(alt) ::= <<
+// <alt.description>
+<if(alt.pred)>
+if (<alt.pred>) {
+    retval.st = <alt.alt>;
}<\n>
<else>
{
-    retval.st = <it.alt>;
+    retval.st = <alt.alt>;
}<\n>
<endif>
>>
@@ -127,25 +126,25 @@ null;
*  an attribute to build a bigger template; you get a self-embedded
*  template.
*/
-rewriteExternalTemplate(name,args) ::= <<
+rewriteExternalTemplate(name,args) ::= <%
templateLib.getInstanceOf("<name>"<if(args)>,
new STAttrMap()<args:{a | .put("<a.name>", <a.value>)}>
<endif>)
->>
+%>

/** expr is a string expression that says what template to load */
-rewriteIndirectTemplate(expr,args) ::= <<
+rewriteIndirectTemplate(expr,args) ::= <%
templateLib.getInstanceOf(<expr><if(args)>,
new STAttrMap()<args:{a | .put("<a.name>", <a.value>)}>
<endif>)
->>
+%>

/** Invoke an inline template with a set of attribute name/value pairs */
-rewriteInlineTemplate(args, template) ::= <<
+rewriteInlineTemplate(args, template) ::= <%
new StringTemplate(templateLib, "<template>"<if(args)>,
new STAttrMap()<args:{a | .put("<a.name>", <a.value>)}>
<endif>)
->>
+%>

/** plain -> {foo} action */
rewriteAction(action) ::= <<
diff --git a/tool/src/main/resources/org/antlr/tool/templates/messages/languages/en.stg b/tool/src/main/resources/org/antlr/tool/templates/messages/languages/en.stg
index 5779807..ea27ddc 100644
--- a/tool/src/main/resources/org/antlr/tool/templates/messages/languages/en.stg
+++ b/tool/src/main/resources/org/antlr/tool/templates/messages/languages/en.stg
@@ -235,7 +235,7 @@ GRAMMAR_NONDETERMINISM(input,conflictingAlts,paths,disabled,hasPredicateBlockedB
<<
<if(paths)>
Decision can match input such as "<input>" using multiple alternatives:
-<paths:{  alt <it.alt> via NFA path <it.states; separator=","><\n>}>
+<paths:{ it |  alt <it.alt> via NFA path <it.states; separator=","><\n>}>
<else>
Decision can match input such as "<input>" using multiple alternatives: <conflictingAlts; separator=", ">
<endif>
@@ -277,7 +277,7 @@ TOKEN_NONDETERMINISM(input,conflictingTokens,paths,disabled,hasPredicateBlockedB
<<
<if(paths)>
Decision can match input such as "<input>" using multiple alternatives:
-<paths:{  alt <it.alt> via NFA path <it.states; separator=","><\n>}>
+<paths:{ it | alt <it.alt> via NFA path <it.states; separator=","><\n>}>
<else>
Multiple token rules can match input such as "<input>": <conflictingTokens; separator=", "><\n>
<endif>
diff --git a/tool/src/test/java/org/antlr/test/BaseTest.java b/tool/src/test/java/org/antlr/test/BaseTest.java
index 896a996..6070f84 100644
--- a/tool/src/test/java/org/antlr/test/BaseTest.java
+++ b/tool/src/test/java/org/antlr/test/BaseTest.java
@@ -33,8 +33,8 @@ import org.antlr.analysis.Label;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.Token;
import org.antlr.runtime.TokenSource;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
import org.antlr.tool.ANTLRErrorListener;
import org.antlr.tool.ErrorManager;
import org.antlr.tool.GrammarSemanticsMessage;
@@ -79,17 +79,11 @@ public abstract class BaseTest {
public void setUp() throws Exception {
lastTestFailed = false; // hope for the best, but set to true in asserts that fail
// new output dir for each test
-        tmpdir = new File(System.getProperty("java.io.tmpdir"), "antlr-"+getClass().getName()+"-"+System.currentTimeMillis()).getAbsolutePath();
+        tmpdir = new File(System.getProperty("java.io.tmpdir"),
+						  "antlr-"+getClass().getName()+"-"+
+						  System.currentTimeMillis()).getAbsolutePath();
ErrorManager.resetErrorState();
-        // force reset of static caches
-        new StringTemplateGroup("") {
-            {
-                StringTemplateGroup.nameToGroupMap = Collections.synchronizedMap(new HashMap());
-                StringTemplateGroup.nameToInterfaceMap = Collections.synchronizedMap(new HashMap());
-            }
-        };
-        StringTemplate.resetTemplateCounter();
-        StringTemplate.defaultGroup = new StringTemplateGroup("defaultGroup", ".");
+        STGroup.defaultGroup = new STGroup();
}

@After
@@ -337,7 +331,7 @@ public abstract class BaseTest {
String lexerName,
boolean debug)
{
-		System.out.println(grammarStr);
+		//System.out.println(grammarStr);
boolean allIsWell =
antlr(grammarFileName, grammarFileName, grammarStr, debug);
if ( lexerName!=null ) {
@@ -394,7 +388,7 @@ public abstract class BaseTest {
output = stdoutVacuum.toString();
if ( stderrVacuum.toString().length()>0 ) {
this.stderrDuringParse = stderrVacuum.toString();
-				//System.err.println("exec stderrVacuum: "+ stderrVacuum);
+				System.err.println("exec stderrVacuum: "+ stderrVacuum);
}
return output;
}
@@ -582,7 +576,7 @@ public abstract class BaseTest {
String parserStartRuleName,
boolean debug)
{
-		StringTemplate outputFileST = new StringTemplate(
+		ST outputFileST = new ST(
"import org.antlr.runtime.*;\n" +
"import org.antlr.runtime.tree.*;\n" +
"import org.antlr.runtime.debug.*;\n" +
@@ -593,32 +587,32 @@ public abstract class BaseTest {
"public class Test {\n" +
"    public static void main(String[] args) throws Exception {\n" +
"        CharStream input = new ANTLRFileStream(args[0]);\n" +
-			"        $lexerName$ lex = new $lexerName$(input);\n" +
+			"        <lexerName> lex = new <lexerName>(input);\n" +
"        CommonTokenStream tokens = new CommonTokenStream(lex);\n" +
-			"        $createParser$\n"+
-			"        parser.$parserStartRuleName$();\n" +
+			"        <createParser>\n"+
+			"        parser.<parserStartRuleName>();\n" +
"    }\n" +
"}"
);
-		StringTemplate createParserST =
-			new StringTemplate(
+		ST createParserST =
+			new ST(
"        Profiler2 profiler = new Profiler2();\n"+
-			"        $parserName$ parser = new $parserName$(tokens,profiler);\n" +
+			"        <parserName> parser = new <parserName>(tokens,profiler);\n" +
"        profiler.setParser(parser);\n");
if ( !debug ) {
createParserST =
-				new StringTemplate(
-				"        $parserName$ parser = new $parserName$(tokens);\n");
+				new ST(
+				"        <parserName> parser = new <parserName>(tokens);\n");
}
-		outputFileST.setAttribute("createParser", createParserST);
-		outputFileST.setAttribute("parserName", parserName);
-		outputFileST.setAttribute("lexerName", lexerName);
-		outputFileST.setAttribute("parserStartRuleName", parserStartRuleName);
-		writeFile(tmpdir, "Test.java", outputFileST.toString());
+		outputFileST.add("createParser", createParserST);
+		outputFileST.add("parserName", parserName);
+		outputFileST.add("lexerName", lexerName);
+		outputFileST.add("parserStartRuleName", parserStartRuleName);
+		writeFile(tmpdir, "Test.java", outputFileST.render());
}

protected void writeLexerTestFile(String lexerName, boolean debug) {
-		StringTemplate outputFileST = new StringTemplate(
+		ST outputFileST = new ST(
"import org.antlr.runtime.*;\n" +
"import org.antlr.runtime.tree.*;\n" +
"import org.antlr.runtime.debug.*;\n" +
@@ -629,14 +623,14 @@ public abstract class BaseTest {
"public class Test {\n" +
"    public static void main(String[] args) throws Exception {\n" +
"        CharStream input = new ANTLRFileStream(args[0]);\n" +
-			"        $lexerName$ lex = new $lexerName$(input);\n" +
+			"        <lexerName> lex = new <lexerName>(input);\n" +
"        CommonTokenStream tokens = new CommonTokenStream(lex);\n" +
"        System.out.println(tokens);\n" +
"    }\n" +
"}"
);
-		outputFileST.setAttribute("lexerName", lexerName);
-		writeFile(tmpdir, "Test.java", outputFileST.toString());
+		outputFileST.add("lexerName", lexerName);
+		writeFile(tmpdir, "Test.java", outputFileST.render());
}

protected void writeTreeTestFile(String parserName,
@@ -646,7 +640,7 @@ public abstract class BaseTest {
String treeParserStartRuleName,
boolean debug)
{
-		StringTemplate outputFileST = new StringTemplate(
+		ST outputFileST = new ST(
"import org.antlr.runtime.*;\n" +
"import org.antlr.runtime.tree.*;\n" +
"import org.antlr.runtime.debug.*;\n" +
@@ -657,41 +651,41 @@ public abstract class BaseTest {
"public class Test {\n" +
"    public static void main(String[] args) throws Exception {\n" +
"        CharStream input = new ANTLRFileStream(args[0]);\n" +
-			"        $lexerName$ lex = new $lexerName$(input);\n" +
+			"        <lexerName> lex = new <lexerName>(input);\n" +
"        TokenRewriteStream tokens = new TokenRewriteStream(lex);\n" +
-			"        $createParser$\n"+
-			"        $parserName$.$parserStartRuleName$_return r = parser.$parserStartRuleName$();\n" +
-			"        $if(!treeParserStartRuleName)$\n" +
+			"        <createParser>\n"+
+			"        <parserName>.<parserStartRuleName>_return r = parser.<parserStartRuleName>();\n" +
+			"        <if(!treeParserStartRuleName)>\n" +
"        if ( r.tree!=null ) {\n" +
"            System.out.println(((Tree)r.tree).toStringTree());\n" +
"            ((CommonTree)r.tree).sanityCheckParentAndChildIndexes();\n" +
"		 }\n" +
-			"        $else$\n" +
+			"        <else>\n" +
"        CommonTreeNodeStream nodes = new CommonTreeNodeStream((Tree)r.tree);\n" +
"        nodes.setTokenStream(tokens);\n" +
-			"        $treeParserName$ walker = new $treeParserName$(nodes);\n" +
-			"        walker.$treeParserStartRuleName$();\n" +
-			"        $endif$\n" +
+			"        <treeParserName> walker = new <treeParserName>(nodes);\n" +
+			"        walker.<treeParserStartRuleName>();\n" +
+			"        <endif>\n" +
"    }\n" +
"}"
);
-		StringTemplate createParserST =
-			new StringTemplate(
+		ST createParserST =
+			new ST(
"        Profiler2 profiler = new Profiler2();\n"+
-			"        $parserName$ parser = new $parserName$(tokens,profiler);\n" +
+			"        <parserName> parser = new <parserName>(tokens,profiler);\n" +
"        profiler.setParser(parser);\n");
if ( !debug ) {
createParserST =
-				new StringTemplate(
-				"        $parserName$ parser = new $parserName$(tokens);\n");
+				new ST(
+				"        <parserName> parser = new <parserName>(tokens);\n");
}
-		outputFileST.setAttribute("createParser", createParserST);
-		outputFileST.setAttribute("parserName", parserName);
-		outputFileST.setAttribute("treeParserName", treeParserName);
-		outputFileST.setAttribute("lexerName", lexerName);
-		outputFileST.setAttribute("parserStartRuleName", parserStartRuleName);
-		outputFileST.setAttribute("treeParserStartRuleName", treeParserStartRuleName);
-		writeFile(tmpdir, "Test.java", outputFileST.toString());
+		outputFileST.add("createParser", createParserST);
+		outputFileST.add("parserName", parserName);
+		outputFileST.add("treeParserName", treeParserName);
+		outputFileST.add("lexerName", lexerName);
+		outputFileST.add("parserStartRuleName", parserStartRuleName);
+		outputFileST.add("treeParserStartRuleName", treeParserStartRuleName);
+		writeFile(tmpdir, "Test.java", outputFileST.render());
}

/** Parser creates trees and so does the tree parser */
@@ -702,7 +696,7 @@ public abstract class BaseTest {
String treeParserStartRuleName,
boolean debug)
{
-		StringTemplate outputFileST = new StringTemplate(
+		ST outputFileST = new ST(
"import org.antlr.runtime.*;\n" +
"import org.antlr.runtime.tree.*;\n" +
"import org.antlr.runtime.debug.*;\n" +
@@ -713,37 +707,37 @@ public abstract class BaseTest {
"public class Test {\n" +
"    public static void main(String[] args) throws Exception {\n" +
"        CharStream input = new ANTLRFileStream(args[0]);\n" +
-			"        $lexerName$ lex = new $lexerName$(input);\n" +
+			"        <lexerName> lex = new <lexerName>(input);\n" +
"        TokenRewriteStream tokens = new TokenRewriteStream(lex);\n" +
-			"        $createParser$\n"+
-			"        $parserName$.$parserStartRuleName$_return r = parser.$parserStartRuleName$();\n" +
+			"        <createParser>\n"+
+			"        <parserName>.<parserStartRuleName>_return r = parser.<parserStartRuleName>();\n" +
"        ((CommonTree)r.tree).sanityCheckParentAndChildIndexes();\n" +
"        CommonTreeNodeStream nodes = new CommonTreeNodeStream((Tree)r.tree);\n" +
"        nodes.setTokenStream(tokens);\n" +
-			"        $treeParserName$ walker = new $treeParserName$(nodes);\n" +
-			"        $treeParserName$.$treeParserStartRuleName$_return r2 = walker.$treeParserStartRuleName$();\n" +
+			"        <treeParserName> walker = new <treeParserName>(nodes);\n" +
+			"        <treeParserName>.<treeParserStartRuleName>_return r2 = walker.<treeParserStartRuleName>();\n" +
"		 CommonTree rt = ((CommonTree)r2.tree);\n" +
"		 if ( rt!=null ) System.out.println(((CommonTree)r2.tree).toStringTree());\n" +
"    }\n" +
"}"
);
-		StringTemplate createParserST =
-			new StringTemplate(
+		ST createParserST =
+			new ST(
"        Profiler2 profiler = new Profiler2();\n"+
-			"        $parserName$ parser = new $parserName$(tokens,profiler);\n" +
+			"        <parserName> parser = new <parserName>(tokens,profiler);\n" +
"        profiler.setParser(parser);\n");
if ( !debug ) {
createParserST =
-				new StringTemplate(
-				"        $parserName$ parser = new $parserName$(tokens);\n");
+				new ST(
+				"        <parserName> parser = new <parserName>(tokens);\n");
}
-		outputFileST.setAttribute("createParser", createParserST);
-		outputFileST.setAttribute("parserName", parserName);
-		outputFileST.setAttribute("treeParserName", treeParserName);
-		outputFileST.setAttribute("lexerName", lexerName);
-		outputFileST.setAttribute("parserStartRuleName", parserStartRuleName);
-		outputFileST.setAttribute("treeParserStartRuleName", treeParserStartRuleName);
-		writeFile(tmpdir, "Test.java", outputFileST.toString());
+		outputFileST.add("createParser", createParserST);
+		outputFileST.add("parserName", parserName);
+		outputFileST.add("treeParserName", treeParserName);
+		outputFileST.add("lexerName", lexerName);
+		outputFileST.add("parserStartRuleName", parserStartRuleName);
+		outputFileST.add("treeParserStartRuleName", treeParserStartRuleName);
+		writeFile(tmpdir, "Test.java", outputFileST.render());
}

protected void writeTemplateTestFile(String parserName,
@@ -751,7 +745,7 @@ public abstract class BaseTest {
String parserStartRuleName,
boolean debug)
{
-		StringTemplate outputFileST = new StringTemplate(
+		ST outputFileST = new ST(
"import org.antlr.runtime.*;\n" +
"import org.antlr.stringtemplate.*;\n" +
"import org.antlr.stringtemplate.language.*;\n" +
@@ -762,19 +756,17 @@ public abstract class BaseTest {
"    public void terminate() { ; }\n" +
"}\n"+
"public class Test {\n" +
-			"    static String templates =\n" +
-			"    		\"group test;\"+" +
-			"    		\"foo(x,y) ::= \\\"<x> <y>\\\"\";\n"+
+			"    static String templates = \"group T; foo(x,y) ::= \\\"\\<x> \\<y>\\\"\";\n" +
"    static StringTemplateGroup group ="+
"    		new StringTemplateGroup(new StringReader(templates)," +
"					AngleBracketTemplateLexer.class);"+
"    public static void main(String[] args) throws Exception {\n" +
"        CharStream input = new ANTLRFileStream(args[0]);\n" +
-			"        $lexerName$ lex = new $lexerName$(input);\n" +
+			"        <lexerName> lex = new <lexerName>(input);\n" +
"        CommonTokenStream tokens = new CommonTokenStream(lex);\n" +
-			"        $createParser$\n"+
+			"        <createParser>\n"+
"		 parser.setTemplateLib(group);\n"+
-			"        $parserName$.$parserStartRuleName$_return r = parser.$parserStartRuleName$();\n" +
+			"        <parserName>.<parserStartRuleName>_return r = parser.<parserStartRuleName>();\n" +
"        if ( r.st!=null )\n" +
"            System.out.print(r.st.toString());\n" +
"	 	 else\n" +
@@ -782,21 +774,21 @@ public abstract class BaseTest {
"    }\n" +
"}"
);
-		StringTemplate createParserST =
-			new StringTemplate(
+		ST createParserST =
+			new ST(
"        Profiler2 profiler = new Profiler2();\n"+
-			"        $parserName$ parser = new $parserName$(tokens,profiler);\n" +
+			"        <parserName> parser = new <parserName>(tokens,profiler);\n" +
"        profiler.setParser(parser);\n");
if ( !debug ) {
createParserST =
-				new StringTemplate(
-				"        $parserName$ parser = new $parserName$(tokens);\n");
+				new ST(
+				"        <parserName> parser = new <parserName>(tokens);\n");
}
-		outputFileST.setAttribute("createParser", createParserST);
-		outputFileST.setAttribute("parserName", parserName);
-		outputFileST.setAttribute("lexerName", lexerName);
-		outputFileST.setAttribute("parserStartRuleName", parserStartRuleName);
-		writeFile(tmpdir, "Test.java", outputFileST.toString());
+		outputFileST.add("createParser", createParserST);
+		outputFileST.add("parserName", parserName);
+		outputFileST.add("lexerName", lexerName);
+		outputFileST.add("parserStartRuleName", parserStartRuleName);
+		writeFile(tmpdir, "Test.java", outputFileST.render());
}

protected void eraseFiles(final String filesEndingWith) {
diff --git a/tool/src/test/java/org/antlr/test/TestAttributes.java b/tool/src/test/java/org/antlr/test/TestAttributes.java
index d4cacde..2a2b189 100644
--- a/tool/src/test/java/org/antlr/test/TestAttributes.java
+++ b/tool/src/test/java/org/antlr/test/TestAttributes.java
@@ -32,9 +32,8 @@ import org.antlr.codegen.CodeGenerator;
import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.grammar.v3.ActionTranslator;
import org.antlr.runtime.CommonToken;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
-import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
import org.antlr.tool.*;
import org.junit.Test;

@@ -58,15 +57,15 @@ public class TestAttributes extends BaseTest {
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
String action = "i<3; '<xmltag>'";
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),0);
+			new CommonToken(ANTLRParser.ACTION,action),0);
String expecting = action;
String rawTranslation =
translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, "<action>");
-		actionST.setAttribute("action", rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, "<action>");
+		actionST.add("action", rawTranslation);
+		String found = actionST.render();
assertEquals(expecting, found);
}

@@ -75,25 +74,19 @@ public class TestAttributes extends BaseTest {
String expecting = "int $n; \"$in string$\"";
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"@members {"+action+"}\n"+
-			"a[User u, int i]\n" +
-			"        : {"+action+"}\n" +
-			"        ;");
+				"@members {"+action+"}\n"+
+				"a[User u, int i]\n" +
+				"        : {"+action+"}\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),0);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),0);
+		String found = translator.translate();		assertEquals(expecting, found);
}

@Test public void testArguments() throws Exception {
@@ -104,29 +97,23 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[User u, int i]\n" +
-			"        : {"+action+"}\n" +
-			"        ;");
+				"a[User u, int i]\n" +
+				"        : {"+action+"}\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}

@Test public void testComplicatedArgParsing() throws Exception {
String action = "x, (*a).foo(21,33), 3.2+1, '\\n', "+
-						"\"a,oo\\nick\", {bl, \"fdkj\"eck}";
+			"\"a,oo\\nick\", {bl, \"fdkj\"eck}";
String expecting = "x, (*a).foo(21,33), 3.2+1, '\\n', \"a,oo\\nick\", {bl, \"fdkj\"eck}";

ErrorQueue equeue = new ErrorQueue();
@@ -135,15 +122,15 @@ public class TestAttributes extends BaseTest {
// now check in actual grammar.
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[User u, int i]\n" +
-			"        : A a["+action+"] B\n" +
-			"        ;");
+				"a[User u, int i]\n" +
+				"        : A a["+action+"] B\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =	translator.translate();
assertEquals(expecting, rawTranslation);

@@ -157,9 +144,9 @@ public class TestAttributes extends BaseTest {
// now check in actual grammar.
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[String[\\] ick, int i]\n" +
-			"        : A \n"+
-			"        ;");
+				"a[String[\\] ick, int i]\n" +
+				"        : A \n"+
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
@@ -188,15 +175,15 @@ public class TestAttributes extends BaseTest {
// now check in actual grammar.
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[User u, int i]\n" +
-			"        : A a["+action+"] B\n" +
-			"        ;");
+				"a[User u, int i]\n" +
+				"        : A a["+action+"] B\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =	translator.translate();
assertEquals(expecting, rawTranslation);

@@ -224,15 +211,15 @@ public class TestAttributes extends BaseTest {
// now check in actual grammar.
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[User u, int i]\n" +
-			"        : A a["+action+"] B\n" +
-			"        ;");
+				"a[User u, int i]\n" +
+				"        : A a["+action+"] B\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =	translator.translate();
assertEquals(expecting, rawTranslation);

@@ -249,15 +236,15 @@ public class TestAttributes extends BaseTest {
// now check in actual grammar.
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[boolean b]\n" +
-			"        : A a["+action+"] B\n" +
-			"        ;");
+				"a[boolean b]\n" +
+				"        : A a["+action+"] B\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
assertEquals(expecting, rawTranslation);
@@ -273,9 +260,9 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
String grammar =
"parser grammar T;\n"+
-			"a[HashMap<String,String> foo]\n" +
-			"        : {"+action+"}\n" +
-			"        ;";
+				"a[HashMap<String,String> foo]\n" +
+				"        : {"+action+"}\n" +
+				"        ;";
Grammar g = new Grammar(grammar);
Rule ra = g.getRule("a");
List<Attribute> attrs = ra.parameterScope.getAttributes();
@@ -288,14 +275,8 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -308,9 +289,9 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
String grammar =
"parser grammar T;\n"+
-			"a[HashMap<String,String> foo, int x, List<String> duh]\n" +
-			"        : {"+action+"}\n" +
-			"        ;";
+				"a[HashMap<String,String> foo, int x, List<String> duh]\n" +
+				"        : {"+action+"}\n" +
+				"        ;";
Grammar g = new Grammar(grammar);
Rule ra = g.getRule("a");
List<Attribute> attrs = ra.parameterScope.getAttributes();
@@ -332,14 +313,8 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -349,7 +324,7 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
String grammar =
"parser grammar T;\n"+
-			"a returns [HashMap<String,String> foo] : ;\n";
+				"a returns [HashMap<String,String> foo] : ;\n";
Grammar g = new Grammar(grammar);
Rule ra = g.getRule("a");
List<Attribute> attrs = ra.returnScope.getAttributes();
@@ -362,7 +337,7 @@ public class TestAttributes extends BaseTest {

@Test public void testComplicatedArgParsingWithTranslation() throws Exception {
String action = "x, $A.text+\"3242\", (*$A).foo(21,33), 3.2+1, '\\n', "+
-						"\"a,oo\\nick\", {bl, \"fdkj\"eck}";
+			"\"a,oo\\nick\", {bl, \"fdkj\"eck}";
String expecting = "x, (A1!=null?A1.getText():null)+\"3242\", (*A1).foo(21,33), 3.2+1, '\\n', \"a,oo\\nick\", {bl, \"fdkj\"eck}";

ErrorQueue equeue = new ErrorQueue();
@@ -371,22 +346,16 @@ public class TestAttributes extends BaseTest {
// now check in actual grammar.
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[User u, int i]\n" +
-			"        : A a["+action+"] B\n" +
-			"        ;");
+				"a[User u, int i]\n" +
+				"        : A a["+action+"] B\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -405,20 +374,15 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a : x=b {"+action+"} ;\n" +
-			"b returns [int foo] : B {$b.start} ;\n");
+				"a : x=b {"+action+"} ;\n" +
+				"b returns [int foo] : B {$b.start} ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -436,33 +400,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a : x=b {###"+action+"!!!} ;\n" +
-			"b : B ;\n");
+				"a : x=b {###"+action+"!!!} ;\n" +
+				"b : B ;\n");
Tool antlr = newTool();

CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need
-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);
-
-/*
-		CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
-		g.setCodeGenerator(generator);
-		generator.genRecognizer(); // forces load of templates
-		ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
-		 */
-
assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}

@@ -474,20 +422,15 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[User u, int i]\n" +
-			"        : {"+action+"}\n" +
-			"        ;");
+				"a[User u, int i]\n" +
+				"        : {"+action+"}\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator,
-																	 "a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			"a",
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_UNKNOWN_SIMPLE_ATTRIBUTE;
@@ -505,24 +448,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a returns [int i]\n" +
-			"        : 'a'\n" +
-			"        ;\n" +
-			"b : x=a {"+action+"} ;\n");
+				"a returns [int i]\n" +
+				"        : 'a'\n" +
+				"        ;\n" +
+				"b : x=a {"+action+"} ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "b",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+				"b",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found =	translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -536,24 +474,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a returns [int i1]\n" +
-			"        : 'a'\n" +
-			"        ;\n" +
-			"b : x=a {"+action+"} ;\n");
+				"a returns [int i1]\n" +
+				"        : 'a'\n" +
+				"        ;\n" +
+				"b : x=a {"+action+"} ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "b",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+				"b",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -567,21 +500,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a returns [User u, int i]\n" +
-			"        : {"+action+"}\n" +
-			"        ;");
+				"a returns [User u, int i]\n" +
+				"        : {"+action+"}\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -598,16 +526,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n" +
-			"rule1 returns [ Object obj ]\n" +
-			":	rule2 { "+action1+" }\n" +
-			"|	rule3 { "+action2+" }\n" +
-			";\n"+
-			"rule2 returns [ Object obj ]\n"+
-			":	foo='foo' { $obj = $foo.text; }\n"+
-			";\n"+
-			"rule3 returns [ Object obj ]\n"+
-			":	bar='bar' { $obj = $bar.text; }\n"+
-			";");
+				"rule1 returns [ Object obj ]\n" +
+				":	rule2 { "+action1+" }\n" +
+				"|	rule3 { "+action2+" }\n" +
+				";\n"+
+				"rule2 returns [ Object obj ]\n"+
+				":	foo='foo' { $obj = $foo.text; }\n"+
+				";\n"+
+				"rule3 returns [ Object obj ]\n"+
+				":	bar='bar' { $obj = $bar.text; }\n"+
+				";");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
@@ -617,13 +545,8 @@ public class TestAttributes extends BaseTest {
String expecting = expecting1;
do {
ActionTranslator translator = new ActionTranslator(generator,"rule1",
-																		 new CommonToken(ANTLRParser.ACTION,action),i+1);
-			String rawTranslation =
-					translator.translate();
-			StringTemplateGroup templates =
-					new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-			StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-			String found = actionST.toString();
+				new CommonToken(ANTLRParser.ACTION,action),i+1);
+			String found = translator.translate();
assertEquals(expecting, found);
action = action2;
expecting = expecting2;
@@ -639,19 +562,14 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a returns [User u, int i]\n" +
-			"        : {"+action+"}\n" +
-			"        ;");
+				"a returns [User u, int i]\n" +
+				"        : {"+action+"}\n" +
+				"        ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_UNKNOWN_SIMPLE_ATTRIBUTE;
@@ -663,28 +581,23 @@ public class TestAttributes extends BaseTest {

@Test public void testTokenLabels() throws Exception {
String action = "$id; $f; $id.text; $id.getText(); $id.dork " +
-						"$id.type; $id.line; $id.pos; " +
-						"$id.channel; $id.index;";
+			"$id.type; $id.line; $id.pos; " +
+			"$id.channel; $id.index;";
String expecting = "id; f; (id!=null?id.getText():null); id.getText(); id.dork (id!=null?id.getType():0); (id!=null?id.getLine():0); (id!=null?id.getCharPositionInLine():0); (id!=null?id.getChannel():0); (id!=null?id.getTokenIndex():0);";

ErrorQueue equeue = new ErrorQueue();
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a : id=ID f=FLOAT {"+action+"}\n" +
-			"  ;");
+				"a : id=ID f=FLOAT {"+action+"}\n" +
+				"  ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -693,25 +606,25 @@ public class TestAttributes extends BaseTest {
@Test public void testRuleLabels() throws Exception {
String action = "$r.x; $r.start;\n $r.stop;\n $r.tree; $a.x; $a.stop;";
String expecting = "(r!=null?r.x:0); (r!=null?((Token)r.start):null);" + newline +
-						   "             (r!=null?((Token)r.stop):null);" + newline +
-						   "             (r!=null?((Object)r.tree):null); (r!=null?r.x:0); (r!=null?((Token)r.stop):null);";
+			"             (r!=null?((Token)r.stop):null);" + newline +
+			"             (r!=null?((Object)r.tree):null); (r!=null?r.x:0); (r!=null?((Token)r.stop):null);";

ErrorQueue equeue = new ErrorQueue();
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a returns [int x]\n" +
-			"  :\n" +
-			"  ;\n"+
-			"b : r=a {###"+action+"!!!}\n" +
-			"  ;");
+				"a returns [int x]\n" +
+				"  :\n" +
+				"  ;\n"+
+				"b : r=a {###"+action+"!!!}\n" +
+				"  ;");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need
-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -723,7 +636,7 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a : A a {$a.text} | B ;");
+				"a : A a {$a.text} | B ;");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -742,20 +655,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"options {TokenLabelType=MYTOKEN;}\n"+
-			"a returns [int x]\n" +
-			"  :\n" +
-			"  ;\n"+
-			"b : r=a {###"+action+"!!!}\n" +
-			"  ;");
+				"options {TokenLabelType=MYTOKEN;}\n"+
+				"a returns [int x]\n" +
+				"  :\n" +
+				"  ;\n"+
+				"b : r=a {###"+action+"!!!}\n" +
+				"  ;");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need

-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -770,18 +683,18 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"b : r=a {###"+action+"!!!}\n" +
-			"  ;\n" +
-			"a returns [int x]\n" +
-			"  : ;\n");
+				"b : r=a {###"+action+"!!!}\n" +
+				"  ;\n" +
+				"a returns [int x]\n" +
+				"  : ;\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need

-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -796,22 +709,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[int z] returns [int x]\n" +
-			"  :\n" +
-			"  ;\n"+
-			"b : r=a[3] {"+action+"}\n" +
-			"  ;");
+				"a[int z] returns [int x]\n" +
+				"  :\n" +
+				"  ;\n"+
+				"b : r=a[3] {"+action+"}\n" +
+				"  ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_INVALID_RULE_PARAMETER_REF;
Object expectedArg = "a";
@@ -829,22 +736,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a\n" +
-			"scope { int n; }\n" +
-			"  :\n" +
-			"  ;\n"+
-			"b : r=a[3] {"+action+"}\n" +
-			"  ;");
+				"a\n" +
+				"scope { int n; }\n" +
+				"  :\n" +
+				"  ;\n"+
+				"b : r=a[3] {"+action+"}\n" +
+				"  ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_INVALID_RULE_SCOPE_ATTRIBUTE_REF;
@@ -863,21 +765,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[int z] returns [int x]\n" +
-			"  :\n" +
-			"  ;\n"+
-			"b : r=a[3] {"+action+"}\n" +
-			"  ;");
+				"a[int z] returns [int x]\n" +
+				"  :\n" +
+				"  ;\n"+
+				"b : r=a[3] {"+action+"}\n" +
+				"  ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_UNKNOWN_RULE_ATTRIBUTE;
@@ -896,15 +793,15 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a[int z] returns [int x]\n" +
-			"  :\n" +
-			"  ;\n"+
-			"b : r=a[3] {"+action+"}\n" +
-			"  ;");
+				"a[int z] returns [int x]\n" +
+				"  :\n" +
+				"  ;\n"+
+				"b : r=a[3] {"+action+"}\n" +
+				"  ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -924,14 +821,14 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a returns [int x]:\n" +
-			"  ;\n"+
-			"b : a {"+action+"}\n" +
-			"  ;");
+				"a returns [int x]:\n" +
+				"  ;\n"+
+				"b : a {"+action+"}\n" +
+				"  ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -950,20 +847,14 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"@members {'+action+'}\n" +
-			"a : ;\n");
+				"@members {'+action+'}\n" +
+				"a : ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator,
-																	 null,
-																	 new CommonToken(ANTLRParser.ACTION,action),0);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			null,
+			new CommonToken(ANTLRParser.ACTION,action),0);
+		String found = translator.translate();		assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE;
Object expectedArg = "x";
@@ -980,19 +871,14 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"@members {'+action+'}\n" +
-			"a : ;\n");
+				"@members {'+action+'}\n" +
+				"a : ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator = new ActionTranslator(generator,
-																	 null,
-																	 new CommonToken(ANTLRParser.ACTION,action),0);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			null,
+			new CommonToken(ANTLRParser.ACTION,action),0);
+		String found = translator.translate();
assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_ATTRIBUTE_REF_NOT_IN_RULE;
@@ -1013,25 +899,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope Symbols {\n" +
-			"  int n;\n" +
-			"  List names;\n" +
-			"}\n" +
-			"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
-			"  ;\n" +
-			"ID : 'a';\n");
+				"scope Symbols {\n" +
+				"  int n;\n" +
+				"  List names;\n" +
+				"}\n" +
+				"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
+				"  ;\n" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1044,15 +925,15 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
-			"  ;\n" +
-			"ID : 'a';\n");
+				"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
+				"  ;\n" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			new CommonToken(ANTLRParser.ACTION,action),1);

assertEquals("unexpected errors: "+equeue, 2, equeue.errors.size());

@@ -1072,25 +953,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope Symbols {\n" +
-			"  int n;\n" +
-			"  List names;\n" +
-			"}\n" +
-			"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
-			"  ;\n" +
-			"ID : 'a';\n");
+				"scope Symbols {\n" +
+				"  int n;\n" +
+				"  List names;\n" +
+				"}\n" +
+				"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
+				"  ;\n" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1105,24 +981,21 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope Symbols {\n" +
-			"  int n;\n" +
-			"  List names;\n" +
-			"}\n" +
-			"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
-			"  ;\n" +
-			"ID : 'a';\n");
+				"scope Symbols {\n" +
+				"  int n;\n" +
+				"  List names;\n" +
+				"}\n" +
+				"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
+				"  ;\n" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		assertEquals(expecting, rawTranslation);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
+		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -1136,24 +1009,21 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope Symbols {\n" +
-			"  int n;\n" +
-			"  List names;\n" +
-			"}\n" +
-			"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
-			"  ;\n" +
-			"ID : 'a';\n");
+				"scope Symbols {\n" +
+				"  int n;\n" +
+				"  List names;\n" +
+				"}\n" +
+				"a scope Symbols; : (id=ID ';' {"+action+"} )+\n" +
+				"  ;\n" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		assertEquals(expecting, rawTranslation);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
+		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -1166,25 +1036,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope foo_bar {\n" +
-			"  int a_b;\n" +
-			"}\n" +
-			"a scope foo_bar; : (ID {"+action+"} )+\n" +
-			"  ;\n" +
-			"ID : 'a';\n");
+				"scope foo_bar {\n" +
+				"  int a_b;\n" +
+				"}\n" +
+				"a scope foo_bar; : (ID {"+action+"} )+\n" +
+				"  ;\n" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1198,28 +1062,23 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope Symbols {\n" +
-			"  String x;\n" +
-			"}\n" +
-			"a\n"+
-			"scope { int y; }\n"+
-			"scope Symbols;\n" +
-			" : b {"+action+"}\n" +
-			" ;\n" +
-			"b : ID {$Symbols::x=$ID.text} ;\n" +
-			"ID : 'a';\n");
+				"scope Symbols {\n" +
+				"  String x;\n" +
+				"}\n" +
+				"a\n"+
+				"scope { int y; }\n"+
+				"scope Symbols;\n" +
+				" : b {"+action+"}\n" +
+				" ;\n" +
+				"b : ID {$Symbols::x=$ID.text} ;\n" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1233,25 +1092,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope Symbols {\n" +
-			"  int n;\n" +
-			"  List names;\n" +
-			"}\n" +
-			"@members {'+action+'}\n" +
-			"a : \n" +
-			"  ;\n");
+				"scope Symbols {\n" +
+				"  int n;\n" +
+				"  List names;\n" +
+				"}\n" +
+				"@members {'+action+'}\n" +
+				"a : \n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1265,25 +1119,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"@members {"+action+"}\n" +
-			"a\n" +
-			"scope { String name; }\n" +
-			"  : {foo();}\n" +
-			"  ;\n");
+				"@members {"+action+"}\n" +
+				"a\n" +
+				"scope { String name; }\n" +
+				"  : {foo();}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
-																	 null,
-																	 new CommonToken(ANTLRParser.ACTION,action),0);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			null,
+			new CommonToken(ANTLRParser.ACTION,action),0);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -1296,23 +1144,18 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a\n" +
-			"scope {\n" +
-			"  int n;\n" +
-			"} : {"+action+"}\n" +
-			"  ;\n");
+				"a\n" +
+				"scope {\n" +
+				"  int n;\n" +
+				"} : {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1326,11 +1169,11 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a\n" +
-			"scope {\n" +
-			"  int n;\n" +
-			"} : {"+action+"}\n" +
-			"  ;\n");
+				"a\n" +
+				"scope {\n" +
+				"  int n;\n" +
+				"} : {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
@@ -1341,7 +1184,7 @@ public class TestAttributes extends BaseTest {
Object expectedArg2 = null;
GrammarSemanticsMessage expectedMessage =
new GrammarSemanticsMessage(expectedMsgID, g, null, expectedArg,
-										expectedArg2);
+				expectedArg2);
checkError(equeue, expectedMessage);
}

@@ -1353,24 +1196,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a\n" +
-			"scope {\n" +
-			"  int n;\n" +
-			"} : b ;\n" +
-			"b : {"+action+"}\n" +
-			"  ;\n");
+				"a\n" +
+				"scope {\n" +
+				"  int n;\n" +
+				"} : b ;\n" +
+				"b : {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1384,24 +1222,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a\n" +
-			"scope {\n" +
-			"  float n;\n" +
-			"} : b ;\n" +
-			"b : {"+action+"}\n" +
-			"  ;\n");
+				"a\n" +
+				"scope {\n" +
+				"  float n;\n" +
+				"} : b ;\n" +
+				"b : {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1415,28 +1248,23 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope Symbols {\n" +
-			"  String x;\n" +
-			"}\n" +
-			"a\n"+
-			"scope { int y; }\n"+
-			"scope Symbols;\n" +
-			" : b {"+action+"}\n" +
-			" ;\n" +
-			"b : ID {$Symbols::x=$ID.text} ;\n" +
-			"ID : 'a';\n");
+				"scope Symbols {\n" +
+				"  String x;\n" +
+				"}\n" +
+				"a\n"+
+				"scope { int y; }\n"+
+				"scope Symbols;\n" +
+				" : b {"+action+"}\n" +
+				" ;\n" +
+				"b : ID {$Symbols::x=$ID.text} ;\n" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1450,25 +1278,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a\n" +
-			"scope {\n" +
-			"  boolean n;\n" +
-			"} : b\n" +
-			"  ;\n" +
-			"b : {"+action+"}\n" +
-			"  ;\n");
+				"a\n" +
+				"scope {\n" +
+				"  boolean n;\n" +
+				"} : b\n" +
+				"  ;\n" +
+				"b : {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1482,21 +1305,15 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a[int i]: {"+action+"}\n" +
-			"  ;\n");
+				"a[int i]: {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -1509,20 +1326,15 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a returns [int i, int j]: {"+action+"}\n" +
-			"  ;\n");
+				"a returns [int i, int j]: {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1536,20 +1348,15 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a returns [int i, int j]: {"+action+"}\n" +
-			"  ;\n");
+				"a returns [int i, int j]: {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1563,8 +1370,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : 'a' {"+action+"}\n" +
-			"  ;\n");
+				"a : 'a' {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
@@ -1575,7 +1382,7 @@ public class TestAttributes extends BaseTest {
Object expectedArg2 = null;
GrammarSemanticsMessage expectedMessage =
new GrammarSemanticsMessage(expectedMsgID, g, null, expectedArg,
-										expectedArg2);
+				expectedArg2);
checkError(equeue, expectedMessage);
}

@@ -1586,9 +1393,9 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : x=b {"+action+"}\n" +
-			"  ;\n" +
-			"b : 'b' ;\n");
+				"a : x=b {"+action+"}\n" +
+				"  ;\n" +
+				"b : 'b' ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
@@ -1620,10 +1427,10 @@ public class TestAttributes extends BaseTest {
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
-			StringTemplateGroup templates =
-				new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-			StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-			String found = actionST.toString();
+			STGroup templates =
+				new STGroup();
+			ST actionST = new ST(templates, rawTranslation);
+			String found = actionST.render();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1645,13 +1452,7 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -1664,21 +1465,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n" +
-			"options {output=template;}\n"+
-			"a : (A->{$A.text}) {"+action+"}\n" +
-			"  ;\n");
+				"options {output=template;}\n"+
+				"a : (A->{$A.text}) {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1692,19 +1488,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n" +
-			"a : b {###"+action+"!!!} ;\n" +
-			"b\n" +
-			"scope {\n" +
-			"  int n;\n" +
-			"} : 'b' \n" +
-			"  ;\n");
+				"a : b {###"+action+"!!!} ;\n" +
+				"b\n" +
+				"scope {\n" +
+				"  int n;\n" +
+				"} : 'b' \n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates

-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -1719,25 +1515,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n" +
-			"s : b ;\n"+
-			"b\n" +
-			"scope {\n" +
-			"  int n;\n" +
-			"} : '(' b ')' {"+action+"}\n" + // refers to current invocation's n
-			"  ;\n");
+				"s : b ;\n"+
+				"b\n" +
+				"scope {\n" +
+				"  int n;\n" +
+				"} : '(' b ')' {"+action+"}\n" + // refers to current invocation's n
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -1750,22 +1540,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n" +
-			"options {output=template;}\n"+
-			"a : {"+action+"}\n" +
-			"  ;\n");
+				"options {output=template;}\n"+
+				"a : {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
}
@@ -1778,15 +1562,15 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n" +
-			"options {output=template;}\n"+
-			"a : {###"+action+"!!!}\n" +
-			"  ;\n");
+				"options {output=template;}\n"+
+				"a : {###"+action+"!!!}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need
-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -1801,16 +1585,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n" +
-			"a : {###"+action+"!!!}\n" +
-			"  ;\n");
+				"a : {###"+action+"!!!}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -1827,36 +1611,24 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ID {"+action+"}\n" +
-			"  | INT {"+action2+"}\n" +
-			"  ;\n" +
-			"ID : 'a';\n" +
-			"INT : '0';\n");
+				"a : ID {"+action+"}\n" +
+				"  | INT {"+action2+"}\n" +
+				"  ;\n" +
+				"ID : 'a';\n" +
+				"INT : '0';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
translator = new ActionTranslator(generator,
-											   "a",
-											   new CommonToken(ANTLRParser.ACTION,action2),2);
-		rawTranslation =
-			translator.translate();
-		templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		actionST = new StringTemplate(templates, rawTranslation);
-		found = actionST.toString();
-
+			"a",
+			new CommonToken(ANTLRParser.ACTION,action2),2);
+		found = translator.translate();
assertEquals(expecting2, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -1872,17 +1644,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : b {###"+action+"!!!}\n" +
-			"  | c {^^^"+action2+"&&&}\n" +
-			"  ;\n" +
-			"b : 'a';\n" +
-			"c : '0';\n");
+				"a : b {###"+action+"!!!}\n" +
+				"  | c {^^^"+action2+"&&&}\n" +
+				"  ;\n" +
+				"b : 'a';\n" +
+				"c : '0';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need
-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);
found = code.substring(code.indexOf("^^^")+3,code.indexOf("&&&"));
@@ -1899,26 +1671,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a\n" +
-			"scope {\n" +
-			"  int n;\n" +
-			"} : {"+action+"}\n" +
-			"  ;\n");
+				"a\n" +
+				"scope {\n" +
+				"  int n;\n" +
+				"} : {"+action+"}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE;
Object expectedArg = "a";
@@ -1936,26 +1702,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"scope Symbols {\n" +
-			"  int n;\n" +
-			"}\n" +
-			"a : {'+action+'}\n" +
-			"  ;\n");
+				"scope Symbols {\n" +
+				"  int n;\n" +
+				"}\n" +
+				"a : {'+action+'}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_UNKNOWN_DYNAMIC_SCOPE_ATTRIBUTE;
Object expectedArg = "Symbols";
@@ -1973,26 +1733,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a\n" +
-			"scope {\n" +
-			"  int n;\n" +
-			"} : b\n" +
-			"  ;\n" +
-			"b : {'+action+'}\n" +
-			"  ;\n");
+				"a\n" +
+				"scope {\n" +
+				"  int n;\n" +
+				"} : b\n" +
+				"  ;\n" +
+				"b : {'+action+'}\n" +
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator =
new ActionTranslator(generator,
-									  "b",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-		assertEquals(expecting, found);
+				"b",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();		assertEquals(expecting, found);

int expectedMsgID = ErrorManager.MSG_UNKNOWN_SIMPLE_ATTRIBUTE;
Object expectedArg = "n";
@@ -2007,9 +1761,9 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : id='foo' id=b\n" +
-			"  ;\n" +
-			"b : ;\n");
+				"a : id='foo' id=b\n" +
+				"  ;\n" +
+				"b : ;\n");
int expectedMsgID = ErrorManager.MSG_LABEL_TYPE_CONFLICT;
Object expectedArg = "id";
Object expectedArg2 = "rule!=token";
@@ -2023,9 +1777,9 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ids+='a' ids='b'\n" +
-			"  ;\n" +
-			"b : ;\n");
+				"a : ids+='a' ids='b'\n" +
+				"  ;\n" +
+				"b : ;\n");
int expectedMsgID = ErrorManager.MSG_LABEL_TYPE_CONFLICT;
Object expectedArg = "ids";
Object expectedArg2 = "token!=token-list";
@@ -2039,10 +1793,10 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n" +
-			"options {output=AST;}\n"+
-			"a : bs+=b bs=b\n" +
-			"  ;\n" +
-			"b : 'b';\n");
+				"options {output=AST;}\n"+
+				"a : bs+=b bs=b\n" +
+				"  ;\n" +
+				"b : 'b';\n");
int expectedMsgID = ErrorManager.MSG_LABEL_TYPE_CONFLICT;
Object expectedArg = "bs";
Object expectedArg2 = "rule!=rule-list";
@@ -2056,10 +1810,10 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a[int i] returns [int x, int i]\n" +
-			"  : \n" +
-			"  ;\n" +
-			"b : ;\n");
+				"a[int i] returns [int x, int i]\n" +
+				"  : \n" +
+				"  ;\n" +
+				"b : ;\n");
int expectedMsgID = ErrorManager.MSG_ARG_RETVAL_CONFLICT;
Object expectedArg = "i";
Object expectedArg2 = "a";
@@ -2076,21 +1830,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"parser grammar t;\n"+
-			"a : ids+=ID ( COMMA ids+=ID {"+action+"})* ;\n");
+				"a : ids+=ID ( COMMA ids+=ID {"+action+"})* ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2104,22 +1853,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ids+='if' ( ',' ids+=ID {"+action+"})* ;" +
-			"ID : 'a';\n");
+				"a : ids+='if' ( ',' ids+=ID {"+action+"})* ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2133,22 +1877,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ids+=('a'|'b') ( ',' ids+=ID {"+action+"})* ;" +
-			"ID : 'a';\n");
+				"a : ids+=('a'|'b') ( ',' ids+=ID {"+action+"})* ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2162,22 +1901,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ids+=. ( ',' ids+=ID {"+action+"})* ;" +
-			"ID : 'a';\n");
+				"a : ids+=. ( ',' ids+=ID {"+action+"})* ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),1);
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2191,24 +1925,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ID {"+action+"} ;" +
-			"ID : 'a';\n");
+				"a : ID {"+action+"} ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");

ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),1);
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2222,16 +1951,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : r {###"+action+"!!!} ;" +
-			"r : 'a';\n");
+				"a : r {###"+action+"!!!} ;" +
+				"r : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer();

-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -2246,16 +1975,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : x=r {###"+action+"!!!} ;" +
-			"r : 'a';\n");
+				"a : x=r {###"+action+"!!!} ;" +
+				"r : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer();

-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -2270,17 +1999,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"options {output=AST;}\n" +
-			"a : x+=r {###"+action+"!!!} ;" +
-			"r : 'a';\n");
+				"options {output=AST;}\n" +
+				"a : x+=r {###"+action+"!!!} ;" +
+				"r : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer();

-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -2295,8 +2024,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : x=ID {"+action+"} ;" +
-			"ID : 'a';\n");
+				"a : x=ID {"+action+"} ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2304,13 +2033,8 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer();

ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2324,8 +2048,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : x+=ID {"+action+"} ;" +
-			"ID : 'a';\n");
+				"a : x+=ID {"+action+"} ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2333,13 +2057,8 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer();

ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2350,10 +2069,10 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar T;\n"+
-			"s : x+=a ;" +
-			"a : 'a';\n"+
-			"b : 'b';\n"+
-			"WS : ' '|'\n';\n");
+				"s : x+=a ;" +
+				"a : 'a';\n"+
+				"b : 'b';\n"+
+				"WS : ' '|'\n';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2371,28 +2090,28 @@ public class TestAttributes extends BaseTest {
@Test public void testRuleLabelOnTwoDifferentRulesAST() throws Exception {
String grammar =
"grammar T;\n"+
-			"options {output=AST;}\n"+
-			"s : x+=a x+=b {System.out.println($x);} ;" +
-			"a : 'a';\n"+
-			"b : 'b';\n"+
-			"WS : (' '|'\\n') {skip();};\n";
+				"options {output=AST;}\n"+
+				"s : x+=a x+=b {System.out.println($x);} ;" +
+				"a : 'a';\n"+
+				"b : 'b';\n"+
+				"WS : (' '|'\\n') {skip();};\n";
String expecting = "[a, b]\na b\n";
String found = execParser("T.g", grammar, "TParser", "TLexer",
-								  "s", "a b", false);
+			"s", "a b", false);
assertEquals(expecting, found);
}

@Test public void testRuleLabelOnTwoDifferentRulesTemplate() throws Exception {
String grammar =
"grammar T;\n"+
-			"options {output=template;}\n"+
-			"s : x+=a x+=b {System.out.println($x);} ;" +
-			"a : 'a' -> {%{\"hi\"}} ;\n"+
-			"b : 'b' -> {%{\"mom\"}} ;\n"+
-			"WS : (' '|'\\n') {skip();};\n";
+				"options {output=template;}\n"+
+				"s : x+=a x+=b {System.out.println($x);} ;" +
+				"a : 'a' -> {%{\"hi\"}} ;\n"+
+				"b : 'b' -> {%{\"mom\"}} ;\n"+
+				"WS : (' '|'\\n') {skip();};\n";
String expecting = "[hi, mom]\n";
String found = execParser("T.g", grammar, "TParser", "TLexer",
-								  "s", "a b", false);
+			"s", "a b", false);
assertEquals(expecting, found);
}

@@ -2401,8 +2120,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : r ;" +
-			"r[int i] : 'a';\n");
+				"a : r ;" +
+				"r[int i] : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2422,8 +2141,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : r[32,34] ;" +
-			"r : 'a';\n");
+				"a : r[32,34] ;" +
+				"r : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2443,8 +2162,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : r ;\n" +
-			"r returns [int x=0] : 'a' {$x = 4;} ;\n");
+				"a : r ;\n" +
+				"r returns [int x=0] : 'a' {$x = 4;} ;\n");
assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());

Rule r = g.getRule("r");
@@ -2462,8 +2181,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : r ;\n" +
-			"r returns [int x=0, int y, String s=new String(\"foo\")] : 'a' {$x = 4;} ;\n");
+				"a : r ;\n" +
+				"r returns [int x=0, int y, String s=new String(\"foo\")] : 'a' {$x = 4;} ;\n");
assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());

Rule r = g.getRule("r");
@@ -2481,8 +2200,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : r ;\n" +
-			"r returns [int (*x)()=NULL] : 'a' ;\n");
+				"a : r ;\n" +
+				"r returns [int (*x)()=NULL] : 'a' ;\n");
assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());

Rule r = g.getRule("r");
@@ -2500,8 +2219,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : r[32,34] ;" +
-			"r[int x, int y=3] : 'a';\n");
+				"a : r[32,34] ;" +
+				"r[int x, int y=3] : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2521,8 +2240,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ID[32,34] ;" +
-			"ID : 'a';\n");
+				"a : ID[32,34] ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2542,8 +2261,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : 'z' ID[32,34] ;" +
-			"ID : 'a';\n");
+				"R : 'z' ID[32,34] ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2565,23 +2284,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : 'z' i=ID {"+action+"};" +
-			"fragment ID : 'a';\n");
+				"R : 'z' i=ID {"+action+"};" +
+				"fragment ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "R",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-
+				"R",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2594,23 +2307,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : 'z' ID {"+action+"};" +
-			"ID : 'a';\n");
+				"R : 'z' ID {"+action+"};" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "R",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-
+				"R",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2623,23 +2330,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : 'z' ID {"+action+"};" +
-			"ID : 'a';\n");
+				"R : 'z' ID {"+action+"};" +
+				"ID : 'a';\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "R",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-
+				"R",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2650,7 +2351,7 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : x='z' ;\n");
+				"R : x='z' ;\n");

Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2665,7 +2366,7 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : x+='z' ;\n");
+				"R : x+='z' ;\n");

Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2679,7 +2380,7 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : x=. ;\n");
+				"R : x=. ;\n");

Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2693,7 +2394,7 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : x+=. ;\n");
+				"R : x+=. ;\n");

Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2707,8 +2408,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"A : R ;" +
-			"R[int i] : 'a';\n");
+				"A : R ;" +
+				"R[int i] : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2731,22 +2432,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : 'r' {"+action+"};\n");
+				"R : 'r' {"+action+"};\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "R",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-
+				"R",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2759,23 +2454,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : a='c' b='hi' c=. d=DUH {"+action+"};\n" +
-			"DUH : 'd' ;\n");
+				"R : a='c' b='hi' c=. d=DUH {"+action+"};\n" +
+				"DUH : 'd' ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "R",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-
+				"R",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2788,22 +2477,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"lexer grammar t;\n"+
-			"R : 'r' {"+action+"};\n");
+				"R : 'r' {"+action+"};\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator =
new ActionTranslator(generator,
-									  "R",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
-
+				"R",
+				new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2814,9 +2497,9 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : R;\n" +
-			"R : 'z' ID[32] ;\n" +
-			"ID : 'a';\n");
+				"a : R;\n" +
+				"R : 'z' ID[32] ;\n" +
+				"ID : 'a';\n");

String lexerGrammarStr = g.getLexerGrammar();
StringReader sr = new StringReader(lexerGrammarStr);
@@ -2847,9 +2530,9 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : R;\n" +
-			"R : 'z' ID ;\n" +
-			"ID[int i] : 'a';\n");
+				"a : R;\n" +
+				"R : 'z' ID ;\n" +
+				"ID[int i] : 'a';\n");

String lexerGrammarStr = g.getLexerGrammar();
StringReader sr = new StringReader(lexerGrammarStr);
@@ -2885,24 +2568,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : id=ID {"+action+"} ;\n" +
-			"ID : 'a';\n");
+				"a : id=ID {"+action+"} ;\n" +
+				"ID : 'a';\n");

Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
ActionTranslator translator =
new ActionTranslator(generator,
-									  "a",
-									  new CommonToken(ANTLRParser.ACTION,action),1);
+				"a",
+				new CommonToken(ANTLRParser.ACTION,action),1);
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -2916,8 +2594,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ID {"+action+"} ;" +
-			"ID : 'a';\n");
+				"a : ID {"+action+"} ;" +
+				"ID : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2925,13 +2603,8 @@ public class TestAttributes extends BaseTest {
generator.genRecognizer();

ActionTranslator translator = new ActionTranslator(generator,"a",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);
}

@@ -2943,8 +2616,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ID ID {"+action+"};" +
-			"ID : 'a';\n");
+				"a : ID ID {"+action+"};" +
+				"ID : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2966,8 +2639,8 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n"+
-			"a : ID ID {"+action+"};" +
-			"ID : 'a';\n");
+				"a : ID ID {"+action+"};" +
+				"ID : 'a';\n");
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
@@ -2989,23 +2662,18 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar a;\n" +
-			"field\n" +
-			"scope { StringTemplate x; }\n" +
-			"    :   'y' {"+action+"}\n" +
-			"    ;\n");
+				"field\n" +
+				"scope { ST x; }\n" +
+				"    :   'y' {"+action+"}\n" +
+				"    ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
-																	 "field",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			"field",
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -3018,22 +2686,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar a;\n" +
-			"rule\n" +
-			"    : 'y' {" + action +"}\n" +
-			"    ;");
+				"rule\n" +
+				"    : 'y' {" + action +"}\n" +
+				"    ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
-																	 "rule",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			"rule",
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -3046,22 +2709,17 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar a;\n" +
-			"rule[int i]\n" +
-			"    : 'y' {" + action +"}\n" +
-			"    ;");
+				"rule[int i]\n" +
+				"    : 'y' {" + action +"}\n" +
+				"    ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
-																	 "rule",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			"rule",
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -3073,16 +2731,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar a;\n" +
-			"rule\n" +
-			"    : 'y' {" + action +"}\n" +
-			"    ;");
+				"rule\n" +
+				"    : 'y' {" + action +"}\n" +
+				"    ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
-																	 "rule",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			"rule",
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -3101,16 +2759,16 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar a;\n" +
-			"rule\n" +
-			"    : 'y' {" + action +"}\n" +
-			"    ;");
+				"rule\n" +
+				"    : 'y' {" + action +"}\n" +
+				"    ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
-																	 "rule",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			"rule",
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -3122,15 +2780,15 @@ public class TestAttributes extends BaseTest {
GrammarSemanticsMessage expectedMessage2 =
new GrammarSemanticsMessage(expectedMsgID, g, null, "stop", "");
expectedErrors.add(expectedMessage2);
-				GrammarSemanticsMessage expectedMessage3 =
+		GrammarSemanticsMessage expectedMessage3 =
new GrammarSemanticsMessage(expectedMsgID, g, null, "text", "");
expectedErrors.add(expectedMessage3);
checkErrors(equeue, expectedErrors);

-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, rawTranslation);
+		String found = actionST.render();
assertEquals(expecting, found);
}

@@ -3140,19 +2798,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar a;\n" +
-			"options { output = AST;}" +
-			"otherrule\n" +
-			"    : 'y' ;" +
-			"rule\n" +
-			"    : other=otherrule {" + action +"}\n" +
-			"    ;");
+				"options { output = AST;}" +
+				"otherrule\n" +
+				"    : 'y' ;" +
+				"rule\n" +
+				"    : other=otherrule {" + action +"}\n" +
+				"    ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
-																	 "rule",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			"rule",
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -3170,18 +2828,18 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar a;\n" +
-			"ID\n" +
-			"    : 'y' ;" +
-			"rule\n" +
-			"    : ID {" + action +"}\n" +
-			"    ;");
+				"ID\n" +
+				"    : 'y' ;" +
+				"rule\n" +
+				"    : ID {" + action +"}\n" +
+				"    ;");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator,
-																	 "rule",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			"rule",
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();

@@ -3200,26 +2858,26 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar a;\n" +
-			"options { output=AST; }" +
-			"rule\n" +
-			"@init {\n" +
-			"   Scope localScope=null;\n" +
-			"}\n" +
-			"@after {\n" +
-			"   ###$tree.scope = localScope;!!!\n" +
-			"}\n" +
-			"   : 'a' -> ^('a')\n" +
-			";");
+				"options { output=AST; }" +
+				"rule\n" +
+				"@init {\n" +
+				"   Scope localScope=null;\n" +
+				"}\n" +
+				"@after {\n" +
+				"   ###$tree.scope = localScope;!!!\n" +
+				"}\n" +
+				"   : 'a' -> ^('a')\n" +
+				";");
Tool antlr = newTool();

CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need
-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);
-
+
}

@Test public void testDoNotTranslateAttributeCompare() throws Exception {
@@ -3228,7 +2886,7 @@ public class TestAttributes extends BaseTest {
ErrorQueue equeue = new ErrorQueue();
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
-				"lexer grammar a;\n" +
+			"lexer grammar a;\n" +
"RULE:\n" +
"     a=ID b=ID {" + action + "}" +
"    ;\n" +
@@ -3239,14 +2897,9 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer();
ActionTranslator translator = new ActionTranslator(generator,
-																	 "RULE",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			"RULE",
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
assertEquals(expecting, found);
}
@@ -3257,7 +2910,7 @@ public class TestAttributes extends BaseTest {
ErrorQueue equeue = new ErrorQueue();
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
-				"grammar a;\n" +
+			"grammar a;\n" +
"rule\n" +
"scope {\n" +
"   String foo;" +
@@ -3274,25 +2927,25 @@ public class TestAttributes extends BaseTest {
g.setCodeGenerator(generator);
generator.genRecognizer();
ActionTranslator translator = new ActionTranslator(generator,
-																	 "twoIDs",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
+			"twoIDs",
+			new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
// check that we didn't use scopeSetAttributeRef int translation!
boolean foundScopeSetAttributeRef = false;
for (int i = 0; i < translator.chunks.size(); i++) {
Object chunk = translator.chunks.get(i);
-			if (chunk instanceof StringTemplate) {
-				if (((StringTemplate)chunk).getName().equals("scopeSetAttributeRef")) {
+			if (chunk instanceof ST) {
+				if (((ST)chunk).getName().equals("scopeSetAttributeRef")) {
foundScopeSetAttributeRef = true;
}
}
}
assertFalse("action translator used scopeSetAttributeRef template in comparison!", foundScopeSetAttributeRef);
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, rawTranslation);
+		String found = actionST.render();
assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
assertEquals(expecting, found);
}
@@ -3305,19 +2958,20 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"tree grammar t;\n" +
-			"options {ASTLabelType=CommonTree;}\n"+
-			"a returns [int x]\n" +
-			"  :\n" +
-			"  ;\n"+
-			"b : r=a {###"+action+"!!!}\n" +
-			"  ;");
+				"options {ASTLabelType=CommonTree;}\n"+
+				"a returns [int x]\n" +
+				"  :\n" +
+				"  ;\n"+
+				"b : r=a {###"+action+"!!!}\n" +
+				"  ;");
+		System.out.println(g.toString());
Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need
-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -3332,25 +2986,25 @@ public class TestAttributes extends BaseTest {

@Test public void testRefToTextAttributeForCurrentTreeRule() throws Exception {
String action = "$text";
-		String expecting = "input.getTokenStream().toString(" + newline +
-						   "              input.getTreeAdaptor().getTokenStartIndex(retval.start)," + newline +
-						   "              input.getTreeAdaptor().getTokenStopIndex(retval.start))";
+		String expecting = "input.getTokenStream().toString(" +
+			"input.getTreeAdaptor().getTokenStartIndex(retval.start)," +
+			"input.getTreeAdaptor().getTokenStopIndex(retval.start))";

ErrorQueue equeue = new ErrorQueue();
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"tree grammar t;\n" +
-			"options {ASTLabelType=CommonTree;}\n" +
-			"a : {###"+action+"!!!}\n" +
-			"  ;\n");
+				"options {ASTLabelType=CommonTree;}\n" +
+				"a : {###"+action+"!!!}\n" +
+				"  ;\n");

Tool antlr = newTool();
antlr.setOutputDirectory(null); // write to /dev/null
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need
-		StringTemplate codeST = generator.getRecognizerST();
-		String code = codeST.toString();
+		ST codeST = generator.getRecognizerST();
+		String code = codeST.render();
String found = code.substring(code.indexOf("###")+3,code.indexOf("!!!"));
assertEquals(expecting, found);

@@ -3365,24 +3019,19 @@ public class TestAttributes extends BaseTest {
ErrorManager.setErrorListener(equeue);
Grammar g = new Grammar(
"grammar t;\n" +
-			"s : b ;\n"+
-			"b\n" +
-			"scope {\n" +
-			"  int n;\n" +
-			"} : '(' b ')' {"+action+"}\n" + // refers to current invocation's n
-			"  ;\n");
+				"s : b ;\n"+
+				"b\n" +
+				"scope {\n" +
+				"  int n;\n" +
+				"} : '(' b ')' {"+action+"}\n" + // refers to current invocation's n
+				"  ;\n");
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // forces load of templates
ActionTranslator translator = new ActionTranslator(generator, "b",
-																	 new CommonToken(ANTLRParser.ACTION,action),1);
-		String rawTranslation =
-			translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+			new CommonToken(ANTLRParser.ACTION,action),1);
+		String found = translator.translate();
assertEquals(expecting, found);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
@@ -3409,7 +3058,7 @@ public class TestAttributes extends BaseTest {
assertTrue("no error; "+expectedMessage.msgID+" expected", equeue.errors.size() > 0);
assertNotNull("couldn't find expected error: "+expectedMessage.msgID+" in "+equeue, foundMsg);
assertTrue("error is not a GrammarSemanticsMessage",
-				   foundMsg instanceof GrammarSemanticsMessage);
+			foundMsg instanceof GrammarSemanticsMessage);
assertEquals(expectedMessage.arg, foundMsg.arg);
assertEquals(expectedMessage.arg2, foundMsg.arg2);
}
@@ -3417,7 +3066,7 @@ public class TestAttributes extends BaseTest {
/** Allow checking for multiple errors in one test */
protected void checkErrors(ErrorQueue equeue,
ArrayList expectedMessages)
-			throws Exception
+		throws Exception
{
ArrayList messageExpected = new ArrayList(equeue.errors.size());
for (int i = 0; i < equeue.errors.size(); i++) {
diff --git a/tool/src/test/java/org/antlr/test/TestLexer.java b/tool/src/test/java/org/antlr/test/TestLexer.java
index 36bbb44..0b2651f 100644
--- a/tool/src/test/java/org/antlr/test/TestLexer.java
+++ b/tool/src/test/java/org/antlr/test/TestLexer.java
@@ -29,7 +29,7 @@ package org.antlr.test;

import org.antlr.Tool;
import org.antlr.codegen.CodeGenerator;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.Grammar;
import org.junit.Test;

@@ -244,8 +244,8 @@ public class TestLexer extends BaseTest {
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
generator.genRecognizer(); // codegen phase sets some vars we need
-        StringTemplate codeST = generator.getRecognizerST();
-        String code = codeST.toString();
+        ST codeST = generator.getRecognizerST();
+        String code = codeST.render();
int m = code.indexOf("match(\"");
String found = code.substring(m,m+expecting.length());

diff --git a/tool/src/test/java/org/antlr/test/TestNFAConstruction.java b/tool/src/test/java/org/antlr/test/TestNFAConstruction.java
index 2ccf508..4ff774e 100644
--- a/tool/src/test/java/org/antlr/test/TestNFAConstruction.java
+++ b/tool/src/test/java/org/antlr/test/TestNFAConstruction.java
@@ -783,7 +783,6 @@ public class TestNFAConstruction extends BaseTest {
String result = g.getLexerGrammar();
String expecting =
"lexer grammar t;" +newline +
-			"" +newline +
"// $ANTLR src \"<string>\" 2"+newline+
"A : '{' ~('}')* '}';";
assertEquals(result, expecting);
diff --git a/tool/src/test/java/org/antlr/test/TestSymbolDefinitions.java b/tool/src/test/java/org/antlr/test/TestSymbolDefinitions.java
index 9d2c0ad..dcf87b9 100644
--- a/tool/src/test/java/org/antlr/test/TestSymbolDefinitions.java
+++ b/tool/src/test/java/org/antlr/test/TestSymbolDefinitions.java
@@ -30,7 +30,7 @@ package org.antlr.test;
import org.antlr.Tool;
import org.antlr.analysis.Label;
import org.antlr.codegen.CodeGenerator;
-import org.antlr.stringtemplate.StringTemplate;
+import org.stringtemplate.v4.ST;
import org.antlr.tool.*;
import org.junit.Test;

@@ -119,7 +119,6 @@ public class TestSymbolDefinitions extends BaseTest {

String implicitLexer =
"lexer grammar t;" + newline +
-			"" + newline +
"T__5 : 'x' ;" + newline +
"" + newline +
"// $ANTLR src \"<string>\" 3" + newline +
@@ -227,8 +226,8 @@ public class TestSymbolDefinitions extends BaseTest {
Tool antlr = newTool();
CodeGenerator generator = new CodeGenerator(antlr, g, "Java");
g.setCodeGenerator(generator);
-		StringTemplate recogST = generator.genRecognizer();
-		String code = recogST.toString();
+		ST recogST = generator.genRecognizer();
+		String code = recogST.render();
assertTrue("not expecting label", code.indexOf("x=b();")<0);

assertEquals("unexpected errors: "+equeue, 0, equeue.errors.size());
diff --git a/tool/src/test/java/org/antlr/test/TestTemplates.java b/tool/src/test/java/org/antlr/test/TestTemplates.java
index 56c7435..8026319 100644
--- a/tool/src/test/java/org/antlr/test/TestTemplates.java
+++ b/tool/src/test/java/org/antlr/test/TestTemplates.java
@@ -32,9 +32,8 @@ import org.antlr.codegen.CodeGenerator;
import org.antlr.grammar.v3.ANTLRParser;
import org.antlr.grammar.v3.ActionTranslator;
import org.antlr.runtime.CommonToken;
-import org.antlr.stringtemplate.StringTemplate;
-import org.antlr.stringtemplate.StringTemplateGroup;
-import org.antlr.stringtemplate.language.AngleBracketTemplateLexer;
+import org.stringtemplate.v4.ST;
+import org.stringtemplate.v4.STGroup;
import org.antlr.tool.ErrorManager;
import org.antlr.tool.Grammar;
import org.antlr.tool.GrammarSemanticsMessage;
@@ -49,7 +48,7 @@ public class TestTemplates extends BaseTest {
public void testTemplateConstructor() throws Exception {
String action = "x = %foo(name={$ID.text});";
String expecting = "x = templateLib.getInstanceOf(\"foo\"," +
-			LINE_SEP + "  new STAttrMap().put(\"name\", (ID1!=null?ID1.getText():null)));";
+			"new STAttrMap().put(\"name\", (ID1!=null?ID1.getText():null)));";

ErrorQueue equeue = new ErrorQueue();
ErrorManager.setErrorListener(equeue);
@@ -73,10 +72,10 @@ public class TestTemplates extends BaseTest {
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, rawTranslation);
+		String found = actionST.render();

assertNoErrors(equeue);

@@ -110,10 +109,10 @@ public class TestTemplates extends BaseTest {
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, rawTranslation);
+		String found = actionST.render();

assertNoErrors(equeue);

@@ -124,7 +123,7 @@ public class TestTemplates extends BaseTest {
public void testIndirectTemplateConstructor() throws Exception {
String action = "x = %({\"foo\"})(name={$ID.text});";
String expecting = "x = templateLib.getInstanceOf(\"foo\"," +
-			LINE_SEP + "  new STAttrMap().put(\"name\", (ID1!=null?ID1.getText():null)));";
+			"new STAttrMap().put(\"name\", (ID1!=null?ID1.getText():null)));";

ErrorQueue equeue = new ErrorQueue();
ErrorManager.setErrorListener(equeue);
@@ -148,10 +147,10 @@ public class TestTemplates extends BaseTest {
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, rawTranslation);
+		String found = actionST.render();

assertNoErrors(equeue);

@@ -183,10 +182,10 @@ public class TestTemplates extends BaseTest {
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, rawTranslation);
+		String found = actionST.render();

assertNoErrors(equeue);

@@ -219,10 +218,10 @@ public class TestTemplates extends BaseTest {
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, rawTranslation);
+		String found = actionST.render();

assertNoErrors(equeue);

@@ -254,10 +253,10 @@ public class TestTemplates extends BaseTest {
new CommonToken(ANTLRParser.ACTION,action),1);
String rawTranslation =
translator.translate();
-		StringTemplateGroup templates =
-			new StringTemplateGroup(".", AngleBracketTemplateLexer.class);
-		StringTemplate actionST = new StringTemplate(templates, rawTranslation);
-		String found = actionST.toString();
+		STGroup templates =
+			new STGroup();
+		ST actionST = new ST(templates, rawTranslation);
+		String found = actionST.render();

assertNoErrors(equeue);

@@ -372,4 +371,4 @@ public class TestTemplates extends BaseTest {
private void assertNoErrors(ErrorQueue equeue) {
assertTrue("unexpected errors: "+equeue, equeue.errors.size()==0);
}
-}
\ No newline at end of file
+}

