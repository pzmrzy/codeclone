commit 28a9eb97bff4586a1aeb5e2e2e00bc7a1ce737c6
Author:     murrayju <murrayju@addpcs.com>
AuthorDate: Thu Feb 14 14:35:35 2013 -0500
Commit:     murrayju <murrayju@addpcs.com>
CommitDate: Thu Feb 14 14:35:35 2013 -0500

I searched for all usages of malloc, realloc, and calloc, and added NULL checks where they were missing.

diff --git a/runtime/C/src/antlr3baserecognizer.c b/runtime/C/src/antlr3baserecognizer.c
index e2eccc6..d3edcc3 100644
--- a/runtime/C/src/antlr3baserecognizer.c
+++ b/runtime/C/src/antlr3baserecognizer.c
@@ -2196,6 +2196,7 @@ getMissingSymbol			(pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM	istre
recognizer->state->tokFactory = antlr3TokenFactoryNew(current->input);
}
token	= recognizer->state->tokFactory->newToken(recognizer->state->tokFactory);
+	if (token == NULL) { return NULL; }

// Set some of the token properties based on the current token
//
diff --git a/runtime/C/src/antlr3bitset.c b/runtime/C/src/antlr3bitset.c
index 4e63c79..4434ed1 100644
--- a/runtime/C/src/antlr3bitset.c
+++ b/runtime/C/src/antlr3bitset.c
@@ -101,14 +101,13 @@ antlr3BitsetNew(ANTLR3_UINT32 numBits)
numelements	= ((numBits -1) >> ANTLR3_BITSET_LOG_BITS) + 1;

bitset->blist.bits    = (pANTLR3_BITWORD) ANTLR3_MALLOC((size_t)(numelements * sizeof(ANTLR3_BITWORD)));
-	memset(bitset->blist.bits, 0, (size_t)(numelements * sizeof(ANTLR3_BITWORD)));
-	bitset->blist.length  = numelements;
-
if	(bitset->blist.bits == NULL)
{
ANTLR3_FREE(bitset);
return	NULL;
}
+	memset(bitset->blist.bits, 0, (size_t)(numelements * sizeof(ANTLR3_BITWORD)));
+	bitset->blist.length  = numelements;

antlr3BitsetSetAPI(bitset);

diff --git a/runtime/C/src/antlr3collections.c b/runtime/C/src/antlr3collections.c
index d9e22e9..2a239df 100644
--- a/runtime/C/src/antlr3collections.c
+++ b/runtime/C/src/antlr3collections.c
@@ -97,7 +97,7 @@ static	ANTLR3_UINT32		antlr3VectorSet		(pANTLR3_VECTOR vector, ANTLR3_UINT32 ent
static	ANTLR3_UINT32		antlr3VectorSize    (pANTLR3_VECTOR vector);
static	ANTLR3_BOOLEAN      antlr3VectorSwap	(pANTLR3_VECTOR vector, ANTLR3_UINT32 entry1, ANTLR3_UINT32 entry2);

-static  void                newPool             (pANTLR3_VECTOR_FACTORY factory);
+static  ANTLR3_BOOLEAN      newPool             (pANTLR3_VECTOR_FACTORY factory);
static  void				closeVectorFactory  (pANTLR3_VECTOR_FACTORY factory);
static	pANTLR3_VECTOR		newVector			(pANTLR3_VECTOR_FACTORY factory);
static	void				returnVector		(pANTLR3_VECTOR_FACTORY factory, pANTLR3_VECTOR vector);
@@ -1285,7 +1285,7 @@ static	void *		antrl3VectorRemove  (pANTLR3_VECTOR vector, ANTLR3_UINT32 entry)
return  element;
}

-static  void
+static  ANTLR3_BOOLEAN
antlr3VectorResize  (pANTLR3_VECTOR vector, ANTLR3_UINT32 hint)
{
ANTLR3_UINT32	newSize;
@@ -1310,7 +1310,13 @@ antlr3VectorResize  (pANTLR3_VECTOR vector, ANTLR3_UINT32 hint)
// We were already larger than the internal size, so we just
// use realloc so that the pointers are copied for us
//
-        vector->elements	= (pANTLR3_VECTOR_ELEMENT)ANTLR3_REALLOC(vector->elements, (sizeof(ANTLR3_VECTOR_ELEMENT)* newSize));
+		pANTLR3_VECTOR_ELEMENT newElements = (pANTLR3_VECTOR_ELEMENT)ANTLR3_REALLOC(vector->elements, (sizeof(ANTLR3_VECTOR_ELEMENT)* newSize));
+		if (newElements == NULL)
+		{
+			// realloc failed, but the old allocation is still there
+			return ANTLR3_FALSE;
+		}
+        vector->elements = newElements;
}
else
{
@@ -1320,10 +1326,16 @@ antlr3VectorResize  (pANTLR3_VECTOR vector, ANTLR3_UINT32 hint)
// is part of the internal or external entries, so we copy the internal ones to the new space
//
vector->elements	= (pANTLR3_VECTOR_ELEMENT)ANTLR3_MALLOC((sizeof(ANTLR3_VECTOR_ELEMENT)* newSize));
+		if (vector->elements == NULL)
+		{
+			// malloc failed
+			return ANTLR3_FALSE;
+		}
ANTLR3_MEMCPY(vector->elements, vector->internal, ANTLR3_VECTOR_INTERNAL_SIZE * sizeof(ANTLR3_VECTOR_ELEMENT));
}

vector->elementsSize	= newSize;
+	return ANTLR3_TRUE;
}

/// Add the supplied pointer and freeing function pointer to the list,
@@ -1335,7 +1347,12 @@ static	ANTLR3_UINT32    antlr3VectorAdd	    (pANTLR3_VECTOR vector, void * eleme
//
if	(vector->count == vector->elementsSize)
{
-		antlr3VectorResize(vector, 0);	    // Give no hint, we let it add 1024 or double it
+		// Give no hint, we let it add 1024 or double it
+		if (!antlr3VectorResize(vector, 0))
+		{
+			// Resize failed
+			return 0;
+		}
}

// Insert the new entry
@@ -1360,7 +1377,12 @@ antlr3VectorSet	    (pANTLR3_VECTOR vector, ANTLR3_UINT32 entry, void * element,
//
if (entry >= vector->elementsSize)
{
-		antlr3VectorResize(vector, entry);	// We will get at least this many
+		// We will get at least this many
+		if (!antlr3VectorResize(vector, entry))
+		{
+			// Resize failed
+			return 0;
+		}
}

// Valid request, replace the current one, freeing any prior entry if told to
@@ -1491,25 +1513,40 @@ returnVector		(pANTLR3_VECTOR_FACTORY factory, pANTLR3_VECTOR vector)
// TODO: remove this line once happy printf("Returned vector %08X to the pool, stack size is %d\n", vector, factory->freeStack->size(factory->freeStack));
}

-static void
+static ANTLR3_BOOLEAN
newPool(pANTLR3_VECTOR_FACTORY factory)
{
+	pANTLR3_VECTOR *newPools;
+
/* Increment factory count
*/
-    factory->thisPool++;
+    ++factory->thisPool;

/* Ensure we have enough pointers allocated
*/
-    factory->pools = (pANTLR3_VECTOR *)
-		     ANTLR3_REALLOC(	(void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
+	newPools = (pANTLR3_VECTOR *)
+		ANTLR3_REALLOC(	(void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
(ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_VECTOR *))	/* Memory for new pool pointers */
);
+	if (newPools == NULL)
+	{
+		// realloc failed, but we still have the old allocation
+		--factory->thisPool;
+		return ANTLR3_FALSE;
+	}
+	factory->pools = newPools;

/* Allocate a new pool for the factory
*/
factory->pools[factory->thisPool]	=
(pANTLR3_VECTOR)
ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_VECTOR) * ANTLR3_FACTORY_VPOOL_SIZE));
+	if (factory->pools[factory->thisPool] == NULL)
+	{
+		// malloc failed
+		--factory->thisPool;
+		return ANTLR3_FALSE;
+	}


/* Reset the counters
@@ -1518,7 +1555,7 @@ newPool(pANTLR3_VECTOR_FACTORY factory)

/* Done
*/
-    return;
+    return ANTLR3_TRUE;
}

static  void
@@ -1641,7 +1678,7 @@ newVector(pANTLR3_VECTOR_FACTORY factory)

// If we have anything on the re claim stack, reuse it
//
-	vector = factory->freeStack->peek(factory->freeStack);
+	vector = (pANTLR3_VECTOR)factory->freeStack->peek(factory->freeStack);

if  (vector != NULL)
{
@@ -1661,7 +1698,11 @@ newVector(pANTLR3_VECTOR_FACTORY factory)
{
// We ran out of vectors in the current pool, so we need a new pool
//
-        newPool(factory);
+        if (!newPool(factory))
+		{
+			// new pool creation failed
+			return NULL;
+		}
}

// Assuming everything went well (we are trying for performance here so doing minimal
@@ -1676,7 +1717,7 @@ newVector(pANTLR3_VECTOR_FACTORY factory)
vector->factoryMade = ANTLR3_TRUE;

// We know that the pool vectors are created at the default size, which means they
-    // will start off using their internal entry pointers. We must intialize our pool vector
+    // will start off using their internal entry pointers. We must initialize our pool vector
// to point to its own internal entry table and not the pre-made one.
//
vector->elements = vector->internal;
@@ -2529,14 +2570,22 @@ sortToArray      (pANTLR3_TOPO topo)
//
if  (topo->edges == NULL)
{
-        return 0;
+        return NULL;
}
// First we need a vector to populate with enough
// entries to accomodate the sorted list and another to accomodate
// the maximum cycle we could detect which is all nodes such as 0->1->2->3->0
//
topo->sorted    = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));
+	if (topo->sorted == NULL)
+	{
+		return NULL;
+	}
topo->cycle     = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));
+	if (topo->cycle == NULL)
+	{
+		return NULL;
+	}

// Next we need an empty bitset to show whether we have visited a node
// or not. This is the bit that gives us linear time of course as we are essentially
@@ -2595,7 +2644,7 @@ sortVector       (pANTLR3_TOPO topo, pANTLR3_VECTOR v)
// we are given. This is just a convenience routine that allows you to
// sort the children of a tree node into topological order before or
// during an AST walk. This can be useful for optimizations that require
-    // dag reorders and also when the input stream defines thigns that are
+    // dag reorders and also when the input stream defines things that are
// interdependent and you want to walk the list of the generated trees
// for those things in topological order so you can ignore the interdependencies
// at that point.
@@ -2621,8 +2670,8 @@ sortVector       (pANTLR3_TOPO topo, pANTLR3_VECTOR v)
}

// Ensure that the vector we are sorting is at least as big as the
-    // the input sequence we were adsked to sort. It does not matter if it is
-    // bigger as thaat probably just means that nodes numbered higher than the
+    // the input sequence we were asked to sort. It does not matter if it is
+    // bigger as that probably just means that nodes numbered higher than the
// limit had no dependencies and so can be left alone.
//
if  (topo->limit > v->count)
@@ -2636,10 +2685,15 @@ sortVector       (pANTLR3_TOPO topo, pANTLR3_VECTOR v)
// We need to know the locations of each of the entries
// in the vector as we don't want to duplicate them in a new vector. We
// just use an indirection table to get the vector entry for a particular sequence
-    // acording to where we moved it last. Then we can just swap vector entries until
+    // according to where we moved it last. Then we can just swap vector entries until
// we are done :-)
//
vIndex = ANTLR3_MALLOC(topo->limit * sizeof(ANTLR3_UINT32));
+	if (vIndex == NULL)
+	{
+		// malloc failed
+		return;
+	}

// Start index, each vector entry is located where you think it is
//
diff --git a/runtime/C/src/antlr3commontoken.c b/runtime/C/src/antlr3commontoken.c
index 2627431..da4ef63 100644
--- a/runtime/C/src/antlr3commontoken.c
+++ b/runtime/C/src/antlr3commontoken.c
@@ -65,7 +65,7 @@ static	void                    factoryReset    (pANTLR3_TOKEN_FACTORY factory);

/* Internal management functions
*/
-static	void			newPool		(pANTLR3_TOKEN_FACTORY factory);
+static	ANTLR3_BOOLEAN			newPool		(pANTLR3_TOKEN_FACTORY factory);
static	pANTLR3_COMMON_TOKEN    newPoolToken	(pANTLR3_TOKEN_FACTORY factory);


@@ -148,30 +148,44 @@ setInputStream	(pANTLR3_TOKEN_FACTORY factory, pANTLR3_INPUT_STREAM input)
}
}

-static void
+static ANTLR3_BOOLEAN
newPool(pANTLR3_TOKEN_FACTORY factory)
{
/* Increment factory count
*/
-    factory->thisPool++;
+    ++(factory->thisPool);

// If we were reusing this token factory then we may already have a pool
-    // allocated. If we exceeded the max avaible then we must allocate a new
+    // allocated. If we exceeded the max available then we must allocate a new
// one.
if  (factory->thisPool > factory->maxPool)
{
/* Ensure we have enough pointers allocated
*/
-        factory->pools = (pANTLR3_COMMON_TOKEN *)
-		         ANTLR3_REALLOC(	(void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
-					    (ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_COMMON_TOKEN *))	/* Memory for new pool pointers */
-					    );
+		pANTLR3_COMMON_TOKEN *newPools = (pANTLR3_COMMON_TOKEN *)
+			ANTLR3_REALLOC((void *)factory->pools,	    /* Current pools pointer (starts at NULL)	*/
+		                   (ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_COMMON_TOKEN *))	/* Memory for new pool pointers */
+			);
+		if (newPools == NULL)
+		{
+			// We are out of memory, but the old allocation is still valid for now
+			--(factory->thisPool);
+			return ANTLR3_FALSE;
+		}
+
+        factory->pools = newPools;

/* Allocate a new pool for the factory
*/
factory->pools[factory->thisPool]	=
(pANTLR3_COMMON_TOKEN)
ANTLR3_CALLOC(1, (size_t)(sizeof(ANTLR3_COMMON_TOKEN) * ANTLR3_FACTORY_POOL_SIZE));
+		if (factory->pools[factory->thisPool] == NULL)
+		{
+			// Allocation failed
+			--(factory->thisPool);
+			return ANTLR3_FALSE;
+		}

// We now have a new pool and can track it as the maximum we have created so far
//
@@ -184,7 +198,7 @@ newPool(pANTLR3_TOKEN_FACTORY factory)

/* Done
*/
-    return;
+    return ANTLR3_TRUE;
}

static pANTLR3_COMMON_TOKEN
@@ -192,6 +206,8 @@ newPoolToken(pANTLR3_TOKEN_FACTORY factory)
{
pANTLR3_COMMON_TOKEN token;

+	if (factory == NULL) { return NULL; }
+
/* See if we need a new token pool before allocating a new
* one
*/
@@ -199,9 +215,16 @@ newPoolToken(pANTLR3_TOKEN_FACTORY factory)
{
/* We ran out of tokens in the current pool, so we need a new pool
*/
-        newPool(factory);
+        if (!newPool(factory))
+		{
+			return NULL;
+		}
}

+	// make sure the factory is sane
+	if (factory->pools == NULL) { return NULL; }
+	if (factory->pools[factory->thisPool] == NULL) { return NULL; }
+
/* Assuming everything went well (we are trying for performance here so doing minimal
* error checking. Then we can work out what the pointer is to the next token.
*/
diff --git a/runtime/C/src/antlr3commontree.c b/runtime/C/src/antlr3commontree.c
index 65de38f..343a4e3 100644
--- a/runtime/C/src/antlr3commontree.c
+++ b/runtime/C/src/antlr3commontree.c
@@ -55,7 +55,7 @@ static void                 reuse                   (pANTLR3_BASE_TREE tree);

// Factory functions for the Arboretum
//
-static void					newPool				(pANTLR3_ARBORETUM factory);
+static ANTLR3_BOOLEAN		newPool				(pANTLR3_ARBORETUM factory);
static pANTLR3_BASE_TREE    newPoolTree			(pANTLR3_ARBORETUM factory);
static pANTLR3_BASE_TREE    newFromTree			(pANTLR3_ARBORETUM factory, pANTLR3_COMMON_TREE tree);
static pANTLR3_BASE_TREE    newFromToken		(pANTLR3_ARBORETUM factory, pANTLR3_COMMON_TOKEN token);
@@ -120,25 +120,40 @@ antlr3ArboretumNew(pANTLR3_STRING_FACTORY strFactory)

}

-static void
+static ANTLR3_BOOLEAN
newPool(pANTLR3_ARBORETUM factory)
{
+	pANTLR3_COMMON_TREE *newPools;
+
// Increment factory count
//
-    factory->thisPool++;
+    ++factory->thisPool;

// Ensure we have enough pointers allocated
//
-    factory->pools = (pANTLR3_COMMON_TREE *)
+    newPools = (pANTLR3_COMMON_TREE *)
ANTLR3_REALLOC(	(void *)factory->pools,										// Current pools pointer (starts at NULL)
(ANTLR3_UINT32)((factory->thisPool + 1) * sizeof(pANTLR3_COMMON_TREE *))	// Memory for new pool pointers
);
+	if (newPools == NULL)
+	{
+		// realloc failed, but we still have the old allocation
+		--factory->thisPool;
+		return ANTLR3_FALSE;
+	}
+	factory->pools = newPools;

// Allocate a new pool for the factory
//
factory->pools[factory->thisPool]	=
(pANTLR3_COMMON_TREE)
ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_COMMON_TREE) * ANTLR3_FACTORY_POOL_SIZE));
+	if (factory->pools[factory->thisPool] == NULL)
+	{
+		// malloc failed
+		--factory->thisPool;
+		return ANTLR3_FALSE;
+	}


// Reset the counters
@@ -147,7 +162,7 @@ newPool(pANTLR3_ARBORETUM factory)

// Done
//
-    return;
+    return ANTLR3_TRUE;
}

static	pANTLR3_BASE_TREE
@@ -157,7 +172,7 @@ newPoolTree	    (pANTLR3_ARBORETUM factory)

// If we have anything on the re claim stack, reuse that sucker first
//
-    tree = factory->nilStack->peek(factory->nilStack);
+    tree = (pANTLR3_COMMON_TREE)factory->nilStack->peek(factory->nilStack);

if  (tree != NULL)
{
@@ -176,7 +191,11 @@ newPoolTree	    (pANTLR3_ARBORETUM factory)
{
// We ran out of tokens in the current pool, so we need a new pool
//
-		newPool(factory);
+		if (!newPool(factory))
+		{
+			// new pool creation failed
+			return NULL;
+		}
}

// Assuming everything went well - we are trying for performance here so doing minimal
@@ -337,7 +356,7 @@ ANTLR3_API pANTLR3_COMMON_TREE
antlr3CommonTreeNew()
{
pANTLR3_COMMON_TREE	tree;
-	tree    = ANTLR3_CALLOC(1, sizeof(ANTLR3_COMMON_TREE));
+	tree = (pANTLR3_COMMON_TREE)ANTLR3_CALLOC(1, sizeof(ANTLR3_COMMON_TREE));

if	(tree == NULL)
{
diff --git a/runtime/C/src/antlr3inputstream.c b/runtime/C/src/antlr3inputstream.c
index e3f1c26..3fb6b4d 100644
--- a/runtime/C/src/antlr3inputstream.c
+++ b/runtime/C/src/antlr3inputstream.c
@@ -451,26 +451,32 @@ antlr38BitMark	(pANTLR3_INT_STREAM is)

/* New mark point
*/
-    input->markDepth++;
+    ++input->markDepth;

/* See if we are revisiting a mark as we can just reuse the vector
* entry if we are, otherwise, we need a new one
*/
if	(input->markDepth > input->markers->count)
{
-	state	= ANTLR3_MALLOC(sizeof(ANTLR3_LEX_STATE));
+		state = (pANTLR3_LEX_STATE)ANTLR3_MALLOC(sizeof(ANTLR3_LEX_STATE));
+		if (state == NULL)
+		{
+			// malloc failed
+			--input->markDepth;
+			return 0;
+		}

-	/* Add it to the table
-	 */
-	input->markers->add(input->markers, state, ANTLR3_FREE_FUNC);	/* No special structure, just free() on delete */
+		/* Add it to the table
+		 */
+		input->markers->add(input->markers, state, ANTLR3_FREE_FUNC);	/* No special structure, just free() on delete */
}
else
{
-	state	= (pANTLR3_LEX_STATE)input->markers->get(input->markers, input->markDepth - 1);
+		state	= (pANTLR3_LEX_STATE)input->markers->get(input->markers, input->markDepth - 1);

-	/* Assume no errors for speed, it will just blow up if the table failed
-	 * for some reasons, hence lots of unit tests on the tables ;-)
-	 */
+		/* Assume no errors for speed, it will just blow up if the table failed
+		 * for some reasons, hence lots of unit tests on the tables ;-)
+		 */
}

/* We have created or retrieved the state, so update it with the current
@@ -522,6 +528,7 @@ antlr38BitRewind	(pANTLR3_INT_STREAM is, ANTLR3_MARKER mark)
/* Find the supplied mark state
*/
state   = (pANTLR3_LEX_STATE)input->markers->get(input->markers, (ANTLR3_UINT32)(mark - 1));
+	if (state == NULL) { return; }

/* Seek input pointer to the requested point (note we supply the void *pointer
* to whatever is implementing the int stream to seek).
diff --git a/runtime/C/src/antlr3lexer.c b/runtime/C/src/antlr3lexer.c
index d981ab7..7b63704 100644
--- a/runtime/C/src/antlr3lexer.c
+++ b/runtime/C/src/antlr3lexer.c
@@ -343,12 +343,12 @@ nextToken	    (pANTLR3_TOKEN_SOURCE toksource)
// stream we just consumed, otherwise we will return EOF
// on the reinstalled input stream, when in actual fact
// there might be more input streams to POP before the
-	// real EOF of the whole logical inptu stream. Hence we
-	// use a while loop here until we find somethign in the stream
+	// real EOF of the whole logical input stream. Hence we
+	// use a while loop here until we find something in the stream
// that isn't EOF or we reach the actual end of the last input
// stream on the stack.
//
-	while	(tok->type == ANTLR3_TOKEN_EOF)
+	while	((tok != NULL) && (tok->type == ANTLR3_TOKEN_EOF))
{
pANTLR3_LEXER   lexer;

@@ -649,6 +649,7 @@ emit	    (pANTLR3_LEXER lexer)
* trying to emit a new token.
*/
token   = lexer->rec->state->tokFactory->newToken(lexer->rec->state->tokFactory);
+	if (token == NULL) { return NULL; }

/* Install the supplied information, and some other bits we already know
* get added automatically, such as the input stream it is associated with
diff --git a/runtime/C/src/antlr3string.c b/runtime/C/src/antlr3string.c
index b29c020..36d0de0 100644
--- a/runtime/C/src/antlr3string.c
+++ b/runtime/C/src/antlr3string.c
@@ -432,9 +432,11 @@ newSize8	(pANTLR3_STRING_FACTORY factory, ANTLR3_UINT32 size)
/* Always add one more byte for a terminator ;-)
*/
string->chars	= (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_UINT8) * (size+1)));
-    *(string->chars)	= '\0';
-    string->size	= size + 1;
-
+	if (string->chars != NULL)
+    {
+		*(string->chars)	= '\0';
+		string->size	= size + 1;
+	}

return string;
}
@@ -460,8 +462,11 @@ newSizeUTF16	(pANTLR3_STRING_FACTORY factory, ANTLR3_UINT32 size)
/* Always add one more byte for a terminator ;-)
*/
string->chars	= (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(sizeof(ANTLR3_UINT16) * (size+1)));
-    *(string->chars)	= '\0';
-    string->size	= size+1;	/* Size is always in characters, as is len */
+    if (string->chars != NULL)
+	{
+		*(string->chars)	= '\0';
+		string->size	= size+1;	/* Size is always in characters, as is len */
+	}

return string;
}
@@ -800,7 +805,12 @@ append8	(pANTLR3_STRING string, const char * newbit)

if	(string->size < (string->len + len + 1))
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= string->len + len + 1;
}

@@ -823,7 +833,12 @@ appendUTF16_8	(pANTLR3_STRING string, const char * newbit)

if	(string->size < (string->len + len + 1))
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)((sizeof(ANTLR3_UINT16)*(string->len + len + 1))));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)((sizeof(ANTLR3_UINT16)*(string->len + len + 1))));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= string->len + len + 1;
}

@@ -857,7 +872,12 @@ appendUTF16_UTF16	(pANTLR3_STRING string, const char * newbit)

if	(string->size < (string->len + len + 1))
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)( sizeof(ANTLR3_UINT16) *(string->len + len + 1) ));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)( sizeof(ANTLR3_UINT16) *(string->len + len + 1) ));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= string->len + len + 1;
}

@@ -877,7 +897,12 @@ set8	(pANTLR3_STRING string, const char * chars)
len = (ANTLR3_UINT32)strlen(chars);
if	(string->size < len + 1)
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(len + 1));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(len + 1));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= len + 1;
}

@@ -900,7 +925,12 @@ setUTF16_8	(pANTLR3_STRING string, const char * chars)
len = (ANTLR3_UINT32)strlen(chars);
if	(string->size < len + 1)
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= len + 1;
}
apPoint = ((pANTLR3_UINT16)string->chars);
@@ -933,7 +963,12 @@ setUTF16_UTF16    (pANTLR3_STRING string, const char * chars)

if	(string->size < len + 1)
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(len + 1)));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= len + 1;
}

@@ -951,7 +986,12 @@ addc8	(pANTLR3_STRING string, ANTLR3_UINT32 c)
{
if	(string->size < string->len + 2)
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + 2));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + 2));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= string->len + 2;
}
*(string->chars + string->len)	= (ANTLR3_UINT8)c;
@@ -968,7 +1008,12 @@ addcUTF16	(pANTLR3_STRING string, ANTLR3_UINT32 c)

if	(string->size < string->len + 2)
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16) * (string->len + 2)));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16) * (string->len + 2)));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= string->len + 2;
}
ptr	= (pANTLR3_UINT16)(string->chars);
@@ -1035,7 +1080,12 @@ insert8	(pANTLR3_STRING string, ANTLR3_UINT32 point, const char * newbit)

if	(string->size < (string->len + len + 1))
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(string->len + len + 1));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= string->len + len + 1;
}

@@ -1073,8 +1123,13 @@ insertUTF16_8	(pANTLR3_STRING string, ANTLR3_UINT32 point, const char * newbit)

if	(string->size < (string->len + len + 1))
{
-	string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));
-	string->size	= string->len + len + 1;
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
+		string->size	= string->len + len + 1;
}

/* Move the characters we are inserting before, including the delimiter
@@ -1120,7 +1175,12 @@ insertUTF16_UTF16	(pANTLR3_STRING string, ANTLR3_UINT32 point, const char * newb

if	(string->size < (string->len + len + 1))
{
-		string->chars	= (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));
+		pANTLR3_UINT8 newAlloc = (pANTLR3_UINT8) ANTLR3_REALLOC((void *)string->chars, (ANTLR3_UINT32)(sizeof(ANTLR3_UINT16)*(string->len + len + 1)));
+		if (newAlloc == NULL)
+		{
+			return NULL;
+		}
+		string->chars	= newAlloc;
string->size	= string->len + len + 1;
}

@@ -1379,24 +1439,27 @@ static	  pANTLR3_STRING    to8_UTF16	(pANTLR3_STRING string)
/* Always add one more byte for a terminator
*/
newStr->chars   = (pANTLR3_UINT8) ANTLR3_MALLOC((size_t)(string->len + 1));
-	newStr->size    = string->len + 1;
-	newStr->len	    = string->len;
-
-	/* Now copy each UTF16 charActer , making it an 8 bit character of
-	* some sort.
-	*/
-	for	(i=0; i<string->len; i++)
+	if (newStr->chars != NULL)
{
-		ANTLR3_UCHAR	c;
+		newStr->size    = string->len + 1;
+		newStr->len	    = string->len;

-		c = *(((pANTLR3_UINT16)(string->chars)) + i);
+		/* Now copy each UTF16 charActer , making it an 8 bit character of
+		* some sort.
+		*/
+		for	(i=0; i<string->len; i++)
+		{
+			ANTLR3_UCHAR	c;

-		*(newStr->chars + i) = (ANTLR3_UINT8)(c > 255 ? '_' : c);
-	}
+			c = *(((pANTLR3_UINT16)(string->chars)) + i);

-	/* Terminate
-	*/
-	*(newStr->chars + newStr->len) = '\0';
+			*(newStr->chars + i) = (ANTLR3_UINT8)(c > 255 ? '_' : c);
+		}
+
+		/* Terminate
+		*/
+		*(newStr->chars + newStr->len) = '\0';
+	}

return newStr;
}

