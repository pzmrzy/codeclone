commit 367a34ecbb2c0bccab20e28da27c8520cb6a53bd
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Sun May 15 13:31:09 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Sun May 15 13:31:09 2011 -0800

(C# 2) CSharp2 target now works for everything except "output=template" and targets the shared runtime from the CSharp3 target

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8516]

diff --git a/tool/src/main/java/org/antlr/codegen/CSharp2Target.java b/tool/src/main/java/org/antlr/codegen/CSharp2Target.java
index 7403787..644721b 100644
--- a/tool/src/main/java/org/antlr/codegen/CSharp2Target.java
+++ b/tool/src/main/java/org/antlr/codegen/CSharp2Target.java
@@ -27,20 +27,6 @@
*/
package org.antlr.codegen;

-import org.antlr.Tool;
-import org.stringtemplate.v4.ST;
-import org.antlr.tool.Grammar;
-
-public class CSharp2Target extends Target
+public class CSharp2Target extends CSharp3Target
{
-    @Override
-    public String encodeIntAsCharEscape(int v) {
-        return "\\x" + Integer.toHexString(v).toUpperCase();
-    }
-
-    @Override
-    public String getTarget64BitStringFromValue(long word) {
-        return "0x" + Long.toHexString(word).toUpperCase();
-    }
}
-
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/AST.stg
index c0c68eb..35fdebd 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/AST.stg
@@ -1,39 +1,41 @@
/*
- [The "BSD license"]
- Copyright (c) 2007-2008 Johannes Luber
- Copyright (c) 2005-2007 Kunle Odutola
- Copyright (c) 2005 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-group AST;
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */

@outputFile.imports() ::= <<
<@super.imports()>
-<if(!TREE_PARSER)><! tree parser would already have imported !>
+
+<if(!TREE_PARSER)>
+<! tree parser would already have imported !>
using Antlr.Runtime.Tree;
-using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;<\n>
+using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
<endif>
>>

@@ -42,26 +44,28 @@ using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;<\n>
<parserMembers()>
>>

-parserCtorBody() ::= <<
-<super.parserCtorBody()>
-ITreeAdaptor treeAdaptor = null;
-CreateTreeAdaptor(ref treeAdaptor);
-TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
->>
+parserCtorBody() ::= <%
+<super.parserCtorBody()><\n>
+TreeAdaptor =
+<if(actions.(actionScope).treeAdaptorInitializer)>
+	<actions.(actionScope).treeAdaptorInitializer>
+<else>
+	new <actions.(actionScope).treeAdaptorType; null="CommonTreeAdaptor">()
+<end>
+;
+%>

/** Add an adaptor property that knows how to build trees */
parserMembers() ::= <<
-// Implement this function in your helper file to use a custom tree adaptor
-void CreateTreeAdaptor(ref ITreeAdaptor adaptor) {}
-
-private ITreeAdaptor adaptor;
+private <treeAdaptorType()> adaptor;

-public ITreeAdaptor TreeAdaptor
+public <treeAdaptorType()> TreeAdaptor
{
get
{
return adaptor;
}
+
set
{
this.adaptor = value;
@@ -70,30 +74,29 @@ public ITreeAdaptor TreeAdaptor
}
>>

-@returnScope.ruleReturnInterfaces() ::= <<
-, IAstRuleReturnScope\<<ASTLabelType>\>
+treeAdaptorType() ::= <<
+<actions.(actionScope).treeAdaptorType; null="ITreeAdaptor">
>>

-@returnScope.ruleReturnMembers() ::= <<
-private <ASTLabelType> _tree;
-public <ASTLabelType> Tree { get { return _tree; } set { _tree = value; } }
->>
+ruleReturnBaseType() ::= <%
+Ast<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<ASTLabelType>, <labelType>>
+%>

/** Add a variable to track rule's return AST */
ruleDeclarations() ::= <<
<super.ruleDeclarations()>
-<ASTLabelType> root_0 = null;<\n>
+<ASTLabelType> root_0 = default(<ASTLabelType>);<\n>
>>

ruleLabelDefs() ::= <<
<super.ruleLabelDefs()>
<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-	:{<ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
-<ruleDescriptor.tokenListLabels:{<ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
+	:{it|<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
+<ruleDescriptor.tokenListLabels:{it|<ASTLabelType> <it.label.text>_tree = default(<ASTLabelType>);}; separator="\n">
<ruleDescriptor.allTokenRefsInAltsWithRewrites
-	:{RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
+	:{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
<ruleDescriptor.allRuleRefsInAltsWithRewrites
-	:{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
>>

/** When doing auto AST construction, we must define some variables;
@@ -105,7 +108,7 @@ ruleLabelDefs() ::= <<
<if(autoAST)>
<if(outerAlt)>
<if(!rewriteMode)>
-root_0 = (<ASTLabelType>)adaptor.Nil();<\n>
+root_0 = (<ASTLabelType>)adaptor.Nil();
<endif>
<endif>
<endif>
@@ -116,7 +119,7 @@ root_0 = (<ASTLabelType>)adaptor.Nil();<\n>
/** ID and track it for use in a rewrite rule */
tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefBang(...)> <! Track implies no auto AST construction!>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<token>.Add(<label>);<\n>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);<\n>
>>

/** ids+=ID and track it for use in a rewrite rule; adds to ids *and*
@@ -124,43 +127,43 @@ tokenRefTrack(token,label,elementIndex,terminalOptions) ::= <<
*/
tokenRefTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefTrack(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** ^(ID ...) track for rewrite */
tokenRefRuleRootTrack(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefBang(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<token>.Add(<label>);<\n>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<token>.Add(<label>);
>>

/** Match ^(label+=TOKEN ...) track for rewrite */
tokenRefRuleRootTrackAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefRuleRootTrack(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** rule when output=AST and tracking for rewrite */
ruleRefTrack(rule,label,elementIndex,args,scope) ::= <<
<super.ruleRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<rule.name>.Add(<label>.Tree);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule.name>.Add(<label>.Tree);
>>

/** x+=rule when output=AST and tracking for rewrite */
ruleRefTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRefTrack(...)>
-<listLabel(elem=label+".Tree",...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
>>

/** ^(rule ...) rewrite */
ruleRefRuleRootTrack(rule,label,elementIndex,args,scope) ::= <<
<ruleRefRuleRoot(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>stream_<rule>.Add(<label>.Tree);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>stream_<rule>.Add(<label>.Tree);
>>

/** ^(x+=rule ...) rewrite */
ruleRefRuleRootTrackAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRefRuleRootTrack(...)>
-<listLabel(elem=label+".Tree",...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
>>

// R e w r i t e
@@ -174,10 +177,8 @@ rewriteCode(
referencedRuleListLabels,
referencedWildcardLabels,
referencedWildcardListLabels,
-	rewriteBlockLevel, enclosingTreeLevel, treeLevel) ::=
-<<
-
-{
+	rewriteBlockLevel, enclosingTreeLevel, treeLevel) ::= <<
+<\n>{
// AST REWRITE
// elements: <referencedElementsDeep; separator=", ">
// token labels: <referencedTokenLabels; separator=", ">
@@ -186,32 +187,26 @@ rewriteCode(
// rule list labels: <referencedRuleListLabels; separator=", ">
// wildcard labels: <[referencedWildcardLabels,referencedWildcardListLabels]; separator=", ">
<if(backtracking)>
-if ( <actions.(actionScope).synpredgate> ) {<\n>
+if (<actions.(actionScope).synpredgate>) {
<endif>
<prevRuleRootRef()>.Tree = root_0;
<rewriteCodeLabels()>
root_0 = (<ASTLabelType>)adaptor.Nil();
<alts:rewriteAlt(); separator="else ">
<! if tree parser and rewrite=true !>
-<if(TREE_PARSER)>
-<if(rewriteMode)>
+<if(TREE_PARSER&&rewriteMode)>
<prevRuleRootRef()>.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
input.ReplaceChildren(adaptor.GetParent(retval.Start),
adaptor.GetChildIndex(retval.Start),
adaptor.GetChildIndex(_last),
retval.Tree);
<endif>
-<endif>
<! if parser or tree-parser && rewrite!=true, we need to set result !>
-<if(!TREE_PARSER)>
-<prevRuleRootRef()>.Tree = root_0;<\n>
-<else>
-<if(!rewriteMode)>
+<if(!TREE_PARSER||!rewriteMode)>
<prevRuleRootRef()>.Tree = root_0;
<endif>
-<endif>
<if(backtracking)>
-}<\n>
+}
<endif>
}

@@ -219,27 +214,27 @@ input.ReplaceChildren(adaptor.GetParent(retval.Start),

rewriteCodeLabels() ::= <<
<referencedTokenLabels
-    :{RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
+    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>",<it>);};
separator="\n"
>
<referencedTokenListLabels
-    :{RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
+    :{it|RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>", list_<it>);};
separator="\n"
>
<referencedWildcardLabels
-	:{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",<it>);};
separator="\n"
>
<referencedWildcardListLabels
-	:{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
+	:{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"wildcard <it>",list_<it>);};
separator="\n"
>
<referencedRuleLabels
-    :{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
+    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.Tree:null);};
separator="\n"
>
<referencedRuleListLabels
-    :{RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
+    :{it|RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"token <it>",list_<it>);};
separator="\n"
>
>>
@@ -254,7 +249,7 @@ rewriteOptionalBlock(
description) ::=
<<
// <fileName>:<description>
-if ( <referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||"> )
+if (<referencedElementsDeep:{el | stream_<el>.HasNext}; separator="||">)
{
<alt>
}
@@ -281,7 +276,7 @@ rewritePositiveClosureBlock(
referencedElements, // elements in immediately block; no nested blocks
description) ::=
<<
-if ( !(<referencedElements:{el | stream_<el>.HasNext}; separator="||">) )
+if (!(<referencedElements:{el | stream_<el>.HasNext}; separator="||">))
{
throw new RewriteEarlyExitException();
}
@@ -298,11 +293,11 @@ rewriteAlt(a) ::= <<
if (<a.pred>)
{
<a.alt>
-}<\n>
+}
<else>
{
<a.alt>
-}<\n>
+}
<endif>
>>

@@ -321,11 +316,11 @@ adaptor.AddChild(root_<enclosingTreeLevel>, root_<treeLevel>);

rewriteElementList(elements) ::= "<elements:rewriteElement()>"

-rewriteElement(e) ::= <<
+rewriteElement(e) ::= <%
<@pregen()>
-DebugLocation(<e.line>, <e.pos>);
+DebugLocation(<e.line>, <e.pos>);<\n>
<e.el>
->>
+%>

/** Gen ID or ID[args] */
rewriteTokenRef(token,elementIndex,terminalOptions,args) ::= <<
@@ -415,16 +410,16 @@ rewriteWildcardLabelRef(label) ::= <<
adaptor.AddChild(root_<treeLevel>, stream_<label>.NextTree());<\n>
>>

-createImaginaryNode(tokenType,terminalOptions,args) ::= <<
+createImaginaryNode(tokenType,terminalOptions,args) ::= <%
<if(terminalOptions.node)>
<! new MethodNode(IDLabel, args) !>
new <terminalOptions.node>(<tokenType><if(args)>, <args; separator=", "><endif>)
<else>
(<ASTLabelType>)adaptor.Create(<tokenType>, <args; separator=", "><if(!args)>"<tokenType>"<endif>)
<endif>
->>
+%>

-createRewriteNodeFromElement(token,terminalOptions,args) ::= <<
+createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
<if(terminalOptions.node)>
new <terminalOptions.node>(stream_<token>.NextToken()<if(args)>, <args; separator=", "><endif>)
<else>
@@ -434,4 +429,4 @@ adaptor.Create(<token>, <args; separator=", ">)
stream_<token>.NextNode()
<endif>
<endif>
->>
+%>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTDbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTDbg.stg
index adf37e2..0d2a441 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTDbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTDbg.stg
@@ -1,41 +1,38 @@
/*
- [The "BSD license"]
- Copyright (c) 2007-2008 Johannes Luber
- Copyright (c) 2005-2007 Kunle Odutola
- Copyright (c) 2005 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2005 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */

/** Template overrides to add debugging to AST stuff.  Dynamic inheritance
*  hierarchy is set up as ASTDbg : AST : Dbg : Java by code generator.
*/
-group ASTDbg;

parserMembers() ::= <<
-// Implement this function in your helper file to use a custom tree adaptor
-void InitializeTreeAdaptor() {}
protected DebugTreeAdaptor adaptor;

public ITreeAdaptor TreeAdaptor
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTParser.stg
index 0c14eb0..6413dfe 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTParser.stg
@@ -1,32 +1,33 @@
/*
- [The "BSD license"]
- Copyright (c) 2007-2008 Johannes Luber
- Copyright (c) 2005-2007 Kunle Odutola
- Copyright (c) 2005-2006 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */

/** Templates for building ASTs during normal parsing.
*
@@ -39,7 +40,6 @@
*  The situation is not too bad as rewrite (->) usage makes ^ and !
*  invalid. There is no huge explosion of combinations.
*/
-group ASTParser;

@rule.setErrorReturnValue() ::= <<
retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);
@@ -51,7 +51,7 @@ retval.Tree = (<ASTLabelType>)adaptor.ErrorNode(input, retval.Start, input.LT(-1
/** ID and output=AST */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
<super.tokenRef(...)>
-<if(backtracking)>if ( state.backtracking==0 ) {<endif>
+<if(backtracking)>if (state.backtracking == 0) {<endif>
<label>_tree = <createNodeFromToken(...)>;
adaptor.AddChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
@@ -63,7 +63,7 @@ tokenRefBang(token,label,elementIndex) ::= "<super.tokenRef(...)>"
/** ID^ and output=AST */
tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
<super.tokenRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = <createNodeFromToken(...)>;
root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
@@ -72,19 +72,19 @@ root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
/** ids+=ID! and output=AST */
tokenRefBangAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefBang(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** label+=TOKEN when output=AST but not rewrite alt */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRef(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** Match label+=TOKEN^ when output=AST but not rewrite alt */
tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
<tokenRefRuleRoot(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

// SET AST
@@ -101,23 +101,23 @@ tokenRefRuleRootAndListLabel(token,label,terminalOptions,elementIndex) ::= <<
// I have more time.

matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
-<super.matchSet(..., postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);})>
+<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <createNodeFromToken(...)>);}, ...)>
>>

matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
<matchSet(...)>
>>

-matchSetBang(s,label,elementIndex,postmatchCode) ::= "<super.matchSet(...)>"
+matchSetBang(s,label,elementIndex,terminalOptions,postmatchCode) ::= "<super.matchSet(...)>"

// note there is no matchSetTrack because -> rewrites force sets to be
// plain old blocks of alts: (A|B|...|C)

matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<if(label)>
-<label>=(<labelType>)input.LT(1);<\n>
+<label>=(<labelType>)input.LT(1);
<endif>
-<super.matchSet(..., postmatchCode={<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);})>
+<super.matchSet(postmatchCode={<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<createNodeFromToken(...)>, root_0);}, ...)>
>>

// RULE REF AST
@@ -125,7 +125,7 @@ matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
/** rule when output=AST */
ruleRef(rule,label,elementIndex,args,scope) ::= <<
<super.ruleRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>adaptor.AddChild(root_0, <label>.Tree);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>adaptor.AddChild(root_0, <label>.Tree);
>>

/** rule! is same as normal rule ref */
@@ -134,32 +134,32 @@ ruleRefBang(rule,label,elementIndex,args,scope) ::= "<super.ruleRef(...)>"
/** rule^ */
ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
<super.ruleRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_0);
>>

/** x+=rule when output=AST */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRef(...)>
-<listLabel(elem=label+".Tree",...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
>>

/** x+=rule! when output=AST is a rule ref with list addition */
ruleRefBangAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRefBang(...)>
-<listLabel(elem=label+".Tree",...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
>>

/** x+=rule^ */
ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRefRuleRoot(...)>
-<listLabel(elem=label+".Tree",...)>
+<listLabelElem(elem={<label>.Tree},elemType=ASTLabelType,...)>
>>

// WILDCARD AST

-wildcard(label,elementIndex) ::= <<
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
<super.wildcard(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
adaptor.AddChild(root_0, <label>_tree);
<if(backtracking)>}<endif>
@@ -167,25 +167,25 @@ adaptor.AddChild(root_0, <label>_tree);

wildcardBang(label,elementIndex) ::= "<super.wildcard(...)>"

-wildcardRuleRoot(label,elementIndex) ::= <<
+wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
<super.wildcard(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.Create(<label>);
root_0 = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_0);
<if(backtracking)>}<endif>
>>

-createNodeFromToken(label,terminalOptions) ::= <<
+createNodeFromToken(label,terminalOptions) ::= <%
<if(terminalOptions.node)>
-new <terminalOptions.node>(<label>) <! new MethodNode(IDLabel) !>
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<else>
-(<ASTLabelType>)adaptor.Create(<label>)
+(<ASTLabelType>)adaptor.Create(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>)
<endif>
->>
+%>

ruleCleanUp() ::= <<
<super.ruleCleanUp()>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<\n><endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
<if(backtracking)>}<endif>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTTreeParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTTreeParser.stg
index e8e5e5c..d749fa6 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTTreeParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ASTTreeParser.stg
@@ -1,32 +1,33 @@
/*
- [The "BSD license"]
- Copyright (c) 2007-2008 Johannes Luber
- Copyright (c) 2005-2007 Kunle Odutola
- Copyright (c) 2005-2006 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */

/** Templates for building ASTs during tree parsing.
*
@@ -39,20 +40,19 @@
*  Each combination has its own template except that label/no label
*  is combined into tokenRef, ruleRef, ...
*/
-group ASTTreeParser;

/** Add a variable to track last element matched */
ruleDeclarations() ::= <<
<super.ruleDeclarations()>
-<ASTLabelType> _first_0 = null;
-<ASTLabelType> _last = null;<\n>
+<ASTLabelType> _first_0 = default(<ASTLabelType>);
+<ASTLabelType> _last = default(<ASTLabelType>);<\n>
>>

/** What to emit when there is no rewrite rule.  For auto build
*  mode, does nothing.
*/
noRewrite(rewriteBlockLevel, treeLevel) ::= <<
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(rewriteMode)>
retval.Tree = (<ASTLabelType>)_first_0;
if (adaptor.GetParent(retval.Tree)!=null && adaptor.IsNil(adaptor.GetParent(retval.Tree)))
@@ -69,22 +69,22 @@ tree(root, actionsAfterRoot, children, nullableChildList,
_last = (<ASTLabelType>)input.LT(1);
{
<ASTLabelType> _save_last_<treeLevel> = _last;
-<ASTLabelType> _first_<treeLevel> = null;
+<ASTLabelType> _first_<treeLevel> = default(<ASTLabelType>);
<if(!rewriteMode)>
<ASTLabelType> root_<treeLevel> = (<ASTLabelType>)adaptor.Nil();
<endif>
<root:element()>
<if(rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
<if(root.el.rule)>
-if ( _first_<enclosingTreeLevel>==null ) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>.Tree;
<else>
-if ( _first_<enclosingTreeLevel>==null ) _first_<enclosingTreeLevel> = <root.el.label>;
+if (_first_<enclosingTreeLevel> == null) _first_<enclosingTreeLevel> = <root.el.label>;
<endif>
<endif>
<actionsAfterRoot:element()>
<if(nullableChildList)>
-if ( input.LA(1)==TokenTypes.Down ) {
+if (input.LA(1) == TokenTypes.Down) {
Match(input, TokenTypes.Down, null); <checkRuleBacktrackFailure()>
<children:element()>
Match(input, TokenTypes.Up, null); <checkRuleBacktrackFailure()>
@@ -106,7 +106,7 @@ _last = _save_last_<treeLevel>;
/** ID! and output=AST (same as plain tokenRef) 'cept add
*  setting of _last
*/
-tokenRefBang(token,label,elementIndex) ::= <<
+tokenRefBang(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
>>
@@ -116,24 +116,24 @@ tokenRef(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<label>);
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<label>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>}<endif>
<else> <! rewrite mode !>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
-if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
<endif>
>>

/** label+=TOKEN auto construct */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRef(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,...)>
>>

/** ^(ID ...) auto construct */
@@ -141,11 +141,11 @@ tokenRefRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.tokenRef(...)>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<label>);
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<label>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
<if(backtracking)>}<endif>
@@ -155,7 +155,7 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLe
/** Match ^(label+=TOKEN ...) auto construct */
tokenRefRuleRootAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRefRuleRoot(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,...)>
>>

/** Match . wildcard and auto dup the node/subtree */
@@ -163,13 +163,13 @@ wildcard(token,label,elementIndex,terminalOptions) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.wildcard(...)>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<label>_tree = (<ASTLabelType>)adaptor.DupTree(<label>);
adaptor.AddChild(root_<treeLevel>, <label>_tree);
<if(backtracking)>}<endif>
<else> <! rewrite mode !>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
-if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>;
<endif>
>>

@@ -177,44 +177,44 @@ if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>;

matchSet(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
_last = (<ASTLabelType>)input.LT(1);
-<super.matchSet(..., postmatchCode={
+<super.matchSet(postmatchCode={
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<label>);
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<label>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
adaptor.AddChild(root_<treeLevel>, <label>_tree);
-<if(backtracking)>}<endif>
+<if(backtracking)>\}<endif>
<endif>
-}
+}, ...
)>
>>

matchRuleBlockSet(s,label,terminalOptions,elementIndex,postmatchCode,treeLevel="0") ::= <<
<matchSet(...)>
-<noRewrite()> <! set return tree !>
+<noRewrite(...)> <! set return tree !>
>>

-matchSetBang(s,label,elementIndex,postmatchCode) ::= <<
+matchSetBang(s,label,terminalOptions,elementIndex,postmatchCode) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.matchSet(...)>
>>

matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
-<super.matchSet(..., postmatchCode={
+<super.matchSet(postmatchCode={
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
<if(terminalOptions.node)>
-<label>_tree = new <terminalOptions.node>(<label>);
+<label>_tree = new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<else>
-<label>_tree = (<ASTLabelType>)adaptor.DupNode(<label>);
+<label>_tree = (<ASTLabelType>)adaptor.DupNode(<if(terminalOptions.type)><terminalOptions.type>,<endif><label><if(terminalOptions.text)>,<terminalOptions.text; format="string"><endif>);
<endif><\n>
root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLevel>);
-<if(backtracking)>}<endif>
+<if(backtracking)>\}<endif>
<endif>
-}
+}, ...
)>
>>

@@ -224,18 +224,18 @@ root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>_tree, root_<treeLe
ruleRef(rule,label,elementIndex,args,scope) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>)<endif>
<if(!rewriteMode)>
adaptor.AddChild(root_<treeLevel>, <label>.Tree);
<else> <! rewrite mode !>
-if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>.Tree;
+if (_first_<treeLevel> == null) _first_<treeLevel> = <label>.Tree;
<endif>
>>

/** x+=rule auto construct */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRef(...)>
-<listLabel(elem=label+".Tree",...)>
+<listLabelElem(elem={<label>.Tree},...)>
>>

/** ^(rule ...) auto construct */
@@ -243,14 +243,14 @@ ruleRefRuleRoot(rule,label,elementIndex,args,scope) ::= <<
_last = (<ASTLabelType>)input.LT(1);
<super.ruleRef(...)>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) <endif>root_<treeLevel> = (<ASTLabelType>)adaptor.BecomeRoot(<label>.Tree, root_<treeLevel>);
<endif>
>>

/** ^(x+=rule ...) auto construct */
ruleRefRuleRootAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRefRuleRoot(...)>
-<listLabel(elem=label+".Tree",...)>
+<listLabelElem(elem={<label>.Tree},...)>
>>

/** rule when output=AST and tracking for rewrite */
@@ -280,18 +280,18 @@ _last = (<ASTLabelType>)input.LT(1);
/** Streams for token refs are tree nodes now; override to
*  change NextToken to NextNode.
*/
-createRewriteNodeFromElement(token,terminalOptions,scope) ::= <<
+createRewriteNodeFromElement(token,terminalOptions,args) ::= <%
<if(terminalOptions.node)>
-new <terminalOptions.node>(stream_<token>.NextNode())
+new <terminalOptions.node>(<if(terminalOptions.type)><terminalOptions.type>,<endif>stream_<token>.NextNode())
<else>
stream_<token>.NextNode()
<endif>
->>
+%>

ruleCleanUp() ::= <<
<super.ruleCleanUp()>
<if(!rewriteMode)>
-<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<\n><endif>
+<if(backtracking)>if (<actions.(actionScope).synpredgate>) {<endif>
retval.Tree = (<ASTLabelType>)adaptor.RulePostProcessing(root_0);
<if(backtracking)>}<endif>
<endif>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
index 9ed0182..8e5d603 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
@@ -1,33 +1,34 @@
/*
- [The "BSD license"]
- Copyright (c) 2007-2008 Johannes Luber
- Copyright (c) 2005-2007 Kunle Odutola
- Copyright (c) 2005 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-group CSharp2;
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
csharpVisibilityMap ::= [
"private":"private",
"protected":"protected",
@@ -36,16 +37,6 @@ csharpVisibilityMap ::= [
default:"private"
]

-// System.Boolean.ToString() returns "True" and "False", but the proper C# literals are "true" and "false"
-// The Java version of Boolean returns "true" and "false", so they map to themselves here.
-booleanLiteral ::= [
-	"True":"true",
-	"False":"false",
-	"true":"true",
-	"false":"false",
-	default:"false"
-]
-
/** The overall file structure of a recognizer; stores methods for rules
*  and cyclic DFAs plus support code.
*/
@@ -57,74 +48,86 @@ outputFile(	LEXER,PARSER,TREE_PARSER, actionScope, actions,
fileName, ANTLRVersion, generatedTimestamp, trace,
scopes, superClass, literals) ::=
<<
+//------------------------------------------------------------------------------
+// \<auto-generated>
+//     This code was generated by a tool.
+//     ANTLR Version: <ANTLRVersion>
+//
+//     Changes to this file may cause incorrect behavior and will be lost if
+//     the code is regenerated.
+// \</auto-generated>
+//------------------------------------------------------------------------------
+
// $ANTLR <ANTLRVersion> <fileName> <generatedTimestamp>

+<if(trace)>
+#define ANTLR_TRACE
+<endif>
<@debugPreprocessor()>
// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
+// Missing XML comment for publicly visible type or member 'Type_or_Member'
+#pragma warning disable 1591

<actions.(actionScope).header>

<@imports>
-using System;
using System.Collections.Generic;
using Antlr.Runtime;
+using Antlr.Runtime.Misc;
<if(TREE_PARSER)>
using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;
<endif>
-using Stack = System.Collections.Generic.Stack\<object>;
-using List = System.Collections.IList;
-using ArrayList = System.Collections.Generic.List\<object>;
-<if(backtracking)>
-using Map = System.Collections.IDictionary;
-using HashMap = System.Collections.Generic.Dictionary\<object, object>;
-<endif>
+using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;
<@end>
-
<if(actions.(actionScope).namespace)>
namespace <actions.(actionScope).namespace>
{
<endif>
-
<docComment>
<recognizer>
<if(actions.(actionScope).namespace)>
-}
+
+} // namespace <actions.(actionScope).namespace>
<endif>
>>

-lexer(grammar, name, tokens, scopes, rules, numRules, labelType="CommonToken",
-      filterMode, superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>}) ::= <<
+lexerInputStreamType() ::= <<
+<actions.(actionScope).inputStreamType; null="ICharStream">
+>>
+
+lexer(grammar, name, tokens, scopes, rules, numRules, filterMode, labelType="CommonToken",
+      superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Lexer<endif>}) ::= <<
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
[System.CLSCompliant(false)]
-public partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
{
-	<tokens:{public const int <it.name>=<it.type>;}; separator="\n">
-	<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">
+	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<actions.lexer.members>

// delegates
<grammar.delegates:
-         {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
+         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
// delegators
<grammar.delegators:
-         {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
-    <last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
+         {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+    <last(grammar.delegators):{g|private <g.recognizerName> gParent;}>

-	public <grammar.recognizerName>()<! needed by subclasses !>
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>()<! needed by subclasses !>
{
OnCreated();
}

-	public <grammar.recognizerName>(ICharStream input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
{
}

-	public <grammar.recognizerName>(ICharStream input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<lexerInputStreamType()> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
: base(input, state)
{
<if(memoize)>
@@ -145,7 +148,7 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e
private static readonly bool[] decisionCanBacktrack = new bool[0];

<if(grammar.hasDelegates)>
-	public override ICharStream CharStream
+	public override <lexerInputStreamType()> CharStream
{
get
{
@@ -167,11 +170,14 @@ public partial class <grammar.recognizerName> : <@superClassName><superClass><@e
<filteringNextToken()>
<endif>

+	[Conditional("ANTLR_TRACE")]
protected virtual void OnCreated() {}
+	[Conditional("ANTLR_TRACE")]
protected virtual void EnterRule(string ruleName, int ruleIndex) {}
+	[Conditional("ANTLR_TRACE")]
protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

-    <rules; separator="\n\n">
+    <rules; separator="\n">

<insertLexerSynpreds(synpreds)>

@@ -258,89 +264,71 @@ public override bool AlreadyParsedRule(IIntStream input, int ruleIndex)
}
>>

-actionGate() ::= "(state.backtracking==0)"
+actionGate() ::= "state.backtracking == 0"

-filteringActionGate() ::= "(state.backtracking == 1)"
+filteringActionGate() ::= "state.backtracking == 1"

/** How to generate a parser */
genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
bitsets, inputStreamType, superClass,
-              ASTLabelType="object", labelType, members, rewriteElementType,
-              filterMode) ::= <<
+              labelType, members, rewriteElementType,
+              filterMode, ASTLabelType="object") ::= <<
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "<ANTLRVersion>")]
[System.CLSCompliant(false)]
-public partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
+<parserModifier(grammar=grammar, actions=actions)> partial class <grammar.recognizerName> : <@superClassName><superClass><@end>
{
<if(grammar.grammarIsRoot)>
internal static readonly string[] tokenNames = new string[] {
"\<invalid>", "\<EOR>", "\<DOWN>", "\<UP>", <tokenNames; separator=", ">
-	};<\n>
+	};
<endif>
-	<tokens:{public const int <it.name>=<it.type>;}; separator="\n">
+	<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">

+<if(grammar.delegates)>
// delegates
<grammar.delegates:
-		 {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
// delegators
<grammar.delegators:
-		 {g|public <g.recognizerName> <g:delegateName()>;}; separator="\n">
-	<last(grammar.delegators):{g|public <g.recognizerName> gParent;}>
-
-	<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
-	<@members>
-#if ANTLR_DEBUG
-	private static readonly bool[] decisionCanBacktrack =
-		new bool[]
-		{
-			false, // invalid decision
-			<grammar.decisions:{d | <booleanLiteral.(d.dfa.hasSynPred)>}; wrap="\n", separator=", ">
-		};
-#else
-	private static readonly bool[] decisionCanBacktrack = new bool[0];
-#endif
-<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
-public <grammar.recognizerName>( <inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
-	: this( input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}> )
-{
-}
-public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
-	: base(input, state)
-{
-	<parserCtorBody()>
-	<grammar.directDelegates:
-	 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
-	<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
-	<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+		 {g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+	<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+<endif>

-	OnCreated();
-}
-	<@end>
+	<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
+	<@members()>

public override string[] TokenNames { get { return <grammar.composite.rootGrammar.recognizerName>.tokenNames; } }
public override string GrammarFileName { get { return "<fileName>"; } }

<members>

-
- 	protected virtual void OnCreated() {}
+	[Conditional("ANTLR_TRACE")]
+	protected virtual void OnCreated() {}
+	[Conditional("ANTLR_TRACE")]
protected virtual void EnterRule(string ruleName, int ruleIndex) {}
+	[Conditional("ANTLR_TRACE")]
protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

-    <rules; separator="\n\n">
+	#region Rules
+	<rules; separator="\n">
+	#endregion Rules
+
<if(grammar.delegatedRules)>
<! generate rule/method definitions for imported rules so they
appear to be defined in this recognizer. !>
#region Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-	public <returnType()> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>) <!throws RecognitionException !>\{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">
-	#endregion Delegated rules<\n>
+	<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope:parameterScope()>) <!throws RecognitionException !>{ <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name; format="id">(<ruleDescriptor.parameterScope.attributes:{a|<a.name; format="id">}; separator=", ">); \}}; separator="\n">
+	#endregion Delegated rules
<endif>

<insertSynpreds(synpreds)>

<if(cyclicDFAs)>
#region DFA
-	<cyclicDFAs:{dfa | DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">
+	<cyclicDFAs:{dfa | private DFA<dfa.decisionNumber> dfa<dfa.decisionNumber>;}; separator="\n">

protected override void InitDFAs()
{
@@ -349,21 +337,59 @@ public <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState s
}

<cyclicDFAs:cyclicDFA()><! dump tables for all DFA !>
-	#endregion DFA<\n>
+	#endregion DFA
<endif>

<if(bitsets)>
#region Follow sets
private static class Follow
{
-		<bitsets:bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>},
-							words64=it.bits)>
+		<bitsets:{it|<bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>}; separator="\n">
}
-	#endregion Follow sets<\n>
+	#endregion Follow sets
<endif>
}
>>

+@genericParser.members() ::= <<
+#if ANTLR_DEBUG
+	private static readonly bool[] decisionCanBacktrack =
+		new bool[]
+		{
+			false, // invalid decision
+			<grammar.decisions:{d | <d.dfa.hasSynPred>}; wrap="\n", separator=", ">
+		};
+#else
+	private static readonly bool[] decisionCanBacktrack = new bool[0];
+#endif
+<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
+{
+}
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: base(input, state)
+{
+	<parserCtorBody()>
+<if(grammar.directDelegates)>
+	<grammar.directDelegates:
+	 {g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+<endif>
+<if(grammar.indirectDelegates)>
+	<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
+	<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
+<endif>
+	OnCreated();
+}
+>>
+
+// imported grammars are 'public' (can't be internal because their return scope classes must be accessible)
+parserModifier(grammar, actions) ::= <<
+<if(grammar.grammarIsRoot)><actions.(actionScope).modifier; null="public"><else>public<endif>
+>>
+
parserCtorBody() ::= <<
<if(memoize)>
<if(grammar.grammarIsRoot)>
@@ -384,10 +410,9 @@ parser(grammar, name, scopes, tokens, tokenNames, rules, numRules, bitsets,
*  stream is a different type.
*/
treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
-           numRules, bitsets, labelType={<ASTLabelType>}, ASTLabelType="object",
-           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter\<<labelType>\><else>TreeFilter<endif><else>TreeParser<endif><endif>},
-           members={<actions.treeparser.members>},
-           filterMode) ::= <<
+           numRules, bitsets, filterMode, labelType={<ASTLabelType>}, ASTLabelType="object",
+           superClass={<if(actions.(actionScope).superClass)><actions.(actionScope).superClass><else>Antlr.Runtime.Tree.<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif><endif>},
+           members={<actions.treeparser.members>}) ::= <<
<genericParser(inputStreamType="ITreeNodeStream", rewriteElementType="Node", ...)>
>>

@@ -400,15 +425,16 @@ treeParser(grammar, name, scopes, tokens, tokenNames, globalAction, rules,
*/
synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
-protected virtual void Enter_<ruleName>_fragment() {}
-protected virtual void Leave_<ruleName>_fragment() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>_fragment() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>_fragment() {}

// $ANTLR start <ruleName>
-public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
+public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:parameterScope()>)
{
<ruleLabelDefs()>
-<if(trace)>
-	Enter_<ruleName>_fragment();
+	EnterRule_<ruleName>_fragment();
EnterRule("<ruleName>_fragment", <ruleDescriptor.index>);
TraceIn("<ruleName>_fragment", <ruleDescriptor.index>);
try
@@ -419,11 +445,8 @@ public <!final !>void <ruleName>_fragment(<ruleDescriptor.parameterScope:paramet
{
TraceOut("<ruleName>_fragment", <ruleDescriptor.index>);
LeaveRule("<ruleName>_fragment", <ruleDescriptor.index>);
-		Leave_<ruleName>_fragment();
+		LeaveRule_<ruleName>_fragment();
}
-<else>
-	<block>
-<endif>
}
// $ANTLR end <ruleName>
>>
@@ -458,7 +481,7 @@ private bool EvaluatePredicate(System.Action fragment)
state.failed=false;
return success;
}
-#endregion Synpreds<\n>
+#endregion Synpreds
<endif>
>>

@@ -483,21 +506,21 @@ ruleBacktrackFailure() ::= <<
*/
rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memoize) ::= <<
<ruleAttributeScope(scope=ruleDescriptor.ruleScope)>
-<returnScope(scope=ruleDescriptor.returnScope)>
+<returnScope(ruleDescriptor.returnScope)>

-protected virtual void Enter_<ruleName>() {}
-protected virtual void Leave_<ruleName>() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>() {}

// $ANTLR start "<ruleName>"
// <fileName>:<description>
[GrammarRule("<ruleName>")]
-<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> <returnType()> <ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> <returnType(ruleDescriptor)> <ruleName; format="id">(<ruleDescriptor.parameterScope:parameterScope()>)
{
-<if(trace)>
-	Enter_<ruleName>();
+	EnterRule_<ruleName>();
EnterRule("<ruleName>", <ruleDescriptor.index>);
TraceIn("<ruleName>", <ruleDescriptor.index>);
-<endif>
<ruleScopeSetUp()>
<ruleDeclarations()>
<ruleLabelDefs()>
@@ -524,17 +547,15 @@ protected virtual void Leave_<ruleName>() {}
ReportError(re);
Recover(input,re);
<@setErrorReturnValue()>
-	}<\n>
+	}
<endif>
<endif>
<endif>
finally
{
-    <if(trace)>
TraceOut("<ruleName>", <ruleDescriptor.index>);
LeaveRule("<ruleName>", <ruleDescriptor.index>);
-		Leave_<ruleName>();
-	<endif>
+		LeaveRule_<ruleName>();
<memoize()>
<ruleScopeCleanUp()>
<finally>
@@ -547,6 +568,16 @@ protected virtual void Leave_<ruleName>() {}
// $ANTLR end "<ruleName>"
>>

+// imported grammars need to have internal rules
+ruleModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>internal<endif>
+>>
+
+// imported grammars need to have public return scopes
+returnScopeModifier(grammar,ruleDescriptor) ::= <<
+<if(grammar.grammarIsRoot)><csharpVisibilityMap.(ruleDescriptor.modifier); null="private"><else>public<endif>
+>>
+
catch(decl,action) ::= <<
catch (<e.decl>)
{
@@ -556,11 +587,11 @@ catch (<e.decl>)

ruleDeclarations() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-<returnType()> retval = new <returnType()>();
-retval.Start = (<labelType>)input.LT(1);<\n>
+<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>();
+retval.Start = (<labelType>)input.LT(1);
<else>
<ruleDescriptor.returnScope.attributes:{ a |
-<a.type> <a.name> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
+<a.type> <a.name; format="id"> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
}>
<endif>
<if(memoize)>
@@ -569,57 +600,66 @@ int <ruleDescriptor.name>_StartIndex = input.Index;
>>

ruleScopeSetUp() ::= <<
-<ruleDescriptor.useScopes:{<it>_stack.Push(new <it>_scope());<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
-<ruleDescriptor.ruleScope:{<it.name>_stack.Push(new <it.name>_scope());<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
+<ruleDescriptor.useScopes:{it|<it>_stack.Push(new <it>_scope());<it>_scopeInit(<it>_stack.Peek());}; separator="\n">
+<ruleDescriptor.ruleScope:{it|<it.name>_stack.Push(new <it.name>_scope());<it.name>_scopeInit(<it.name>_stack.Peek());}; separator="\n">
>>

ruleScopeCleanUp() ::= <<
-<ruleDescriptor.useScopes:{<it>_scopeAfter(<it>_stack.Peek());<it>_stack.Pop();}; separator="\n">
-<ruleDescriptor.ruleScope:{<it.name>_scopeAfter(<it.name>_stack.Peek());<it.name>_stack.Pop();}; separator="\n">
+<ruleDescriptor.useScopes:{it|<it>_scopeAfter(<it>_stack.Peek());<it>_stack.Pop();}; separator="\n">
+<ruleDescriptor.ruleScope:{it|<it.name>_scopeAfter(<it.name>_stack.Peek());<it.name>_stack.Pop();}; separator="\n">
>>

ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels,ruleDescriptor.wildcardTreeLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{<labelType> <it.label.text>=null;}; separator="\n"
+    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<ruleDescriptor.tokenListLabels
+    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
>
-<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
-    :{List list_<it.label.text>=null;}; separator="\n"
+<[ruleDescriptor.ruleListLabels,ruleDescriptor.wildcardTreeListLabels]
+    :{it|List\<<ASTLabelType>\> list_<it.label.text> = null;}; separator="\n"
>
-<ruleDescriptor.ruleLabels:ruleLabelDef(label=it); separator="\n">
-<ruleDescriptor.ruleListLabels:ruleLabelDef(label=it); separator="\n">
+<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
+<ruleDescriptor.ruleListLabels:ruleLabelDef(); separator="\n">
>>

lexerRuleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,
ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleLabels]
-    :{<labelType> <it.label.text>=null;}; separator="\n"
+    :{it|<labelType> <it.label.text> = default(<labelType>);}; separator="\n"
+>
+<[ruleDescriptor.charListLabels,
+  ruleDescriptor.charLabels]
+	:{it|int <it.label.text> = 0;}; separator="\n"
>
-<ruleDescriptor.charLabels:{int <it.label.text>;}; separator="\n">
<[ruleDescriptor.tokenListLabels,
ruleDescriptor.ruleListLabels]
-    :{List list_<it.label.text>=null;}; separator="\n"
+    :{it|List\<<labelType>\> list_<it.label.text> = null;}; separator="\n"
+>
+<ruleDescriptor.charListLabels:{it|List\<int\> list_<it.label.text> = null;}; separator="\n"
>
>>

-returnFromRule() ::= <<
-return<if(!ruleDescriptor.isSynPred)>
+returnFromRule() ::= <%
+return
+<if(!ruleDescriptor.isSynPred)>
<if(ruleDescriptor.hasReturnValue)>
<if(ruleDescriptor.hasSingleReturnValue)>
<! This comment is a hack to make sure the following
single space appears in the output. !> <ruleDescriptor.singleValueReturnName>
<else>
- retval
+<!!> retval
<endif>
<endif>
<endif>
;
->>
+%>

ruleCleanUp() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
<if(!TREE_PARSER)>
-retval.Stop = (<labelType>)input.LT(-1);<\n>
+retval.Stop = (<labelType>)input.LT(-1);
<endif>
<endif>
>>
@@ -636,18 +676,19 @@ if (state.backtracking > 0) { Memoize(input, <ruleDescriptor.index>, <ruleDescri
*  fragment rules.
*/
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
-protected virtual void Enter_<ruleName>() {}
-protected virtual void Leave_<ruleName>() {}
+
+[Conditional("ANTLR_TRACE")]
+protected virtual void EnterRule_<ruleName>() {}
+[Conditional("ANTLR_TRACE")]
+protected virtual void LeaveRule_<ruleName>() {}

// $ANTLR start "<ruleName>"
[GrammarRule("<ruleName>")]
-<csharpVisibilityMap.(ruleDescriptor.modifier); null="private"> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope(scope=it)>)
+<ruleModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> void m<ruleName>(<ruleDescriptor.parameterScope:parameterScope()>)
{
-<if(trace)>
-	Enter_<ruleName>();
+	EnterRule_<ruleName>();
EnterRule("<ruleName>", <ruleDescriptor.index>);
TraceIn("<ruleName>", <ruleDescriptor.index>);
-<endif>
<ruleScopeSetUp()>
<ruleDeclarations()>
try
@@ -656,7 +697,7 @@ protected virtual void Leave_<ruleName>() {}
<ruleMemoization(name=ruleName)>
<lexerRuleLabelDefs()>
<ruleDescriptor.actions.init>
-		<block><\n>
+		<block>
<else>
int _type = <ruleName>;
int _channel = DefaultTokenChannel;
@@ -672,11 +713,9 @@ protected virtual void Leave_<ruleName>() {}
}
finally
{
-    <if(trace)>
TraceOut("<ruleName>", <ruleDescriptor.index>);
LeaveRule("<ruleName>", <ruleDescriptor.index>);
-		Leave_<ruleName>();
-	<endif>
+		LeaveRule_<ruleName>();
<ruleScopeCleanUp()>
<memoize()>
}
@@ -688,6 +727,7 @@ protected virtual void Leave_<ruleName>() {}
*  that chooses between lexer rules.
*/
tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
+
public override void mTokens()
{
<block><\n>
@@ -710,7 +750,7 @@ try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>
<@prebranch()>
switch (alt<decisionNumber>)
{
-<alts:altSwitchCase()>
+<alts:{a|<altSwitchCase(i,a)>}>
}
} finally { DebugExitSubRule(<decisionNumber>); }
<@postbranch()>
@@ -728,7 +768,7 @@ try { DebugEnterDecision(<decisionNumber>, decisionCanBacktrack[<decisionNumber>
<@postdecision()>
switch (alt<decisionNumber>)
{
-<alts:altSwitchCase()>
+<alts:{a|<altSwitchCase(i,a)>}>
}
>>

@@ -768,7 +808,7 @@ while (true)
<@postdecision()>
switch (alt<decisionNumber>)
{
-	<alts:altSwitchCase()>
+	<alts:{a|<altSwitchCase(i,a)>}>
default:
if (cnt<decisionNumber> >= 1)
goto loop<decisionNumber>;
@@ -806,7 +846,7 @@ while (true)
<@postdecision()>
switch ( alt<decisionNumber> )
{
-	<alts:altSwitchCase()>
+	<alts:{a|<altSwitchCase(i,a)>}>
default:
goto loop<decisionNumber>;
}
@@ -832,11 +872,11 @@ optionalBlockSingleAlt ::= block
*  number.  A DFA predicts the alternative and then a simple switch
*  does the jump to the code that actually matches that alternative.
*/
-altSwitchCase() ::= <<
-case <i>:
+altSwitchCase(altNum,alt) ::= <<
+case <altNum>:
<@prealt()>
-	DebugEnterAlt(<i>);
-	<it>
+	DebugEnterAlt(<altNum>);
+	<alt>
break;<\n>
>>

@@ -859,11 +899,11 @@ noRewrite(rewriteBlockLevel, treeLevel) ::= ""
// E L E M E N T S

/** Dump the elements one per line */
-element() ::= <<
+element(it) ::= <%
<@prematch()>
-DebugLocation(<it.line>, <it.pos>);
+DebugLocation(<it.line>, <it.pos>);<\n>
<it.el><\n>
->>
+%>

/** match a token optionally with a label in front */
tokenRef(token,label,elementIndex,terminalOptions) ::= <<
@@ -873,11 +913,11 @@ tokenRef(token,label,elementIndex,terminalOptions) ::= <<
/** ids+=ID */
tokenRefAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<tokenRef(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

-listLabel(label,elem) ::= <<
-if (list_<label>==null) list_<label>=new ArrayList();
+listLabelElem(label,elem,elemType) ::= <<
+if (list_<label>==null) list_<label>=new List\<<elemType; null={<labelType>}>\>();
list_<label>.Add(<elem>);<\n>
>>

@@ -898,22 +938,15 @@ MatchRange(<a>,<b>); <checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
-matchSet(s,label,elementIndex,postmatchCode="") ::= <<
+matchSet(s,label,terminalOptions,elementIndex,postmatchCode="") ::= <<
<if(label)>
-<if(LEXER)>
-<label>= input.LA(1);<\n>
-<else>
-<label>=(<labelType>)input.LT(1);<\n>
-<endif>
+<matchSetLabel()>
<endif>
if (<s>)
{
input.Consume();
<postmatchCode>
-<if(!LEXER)>
-	state.errorRecovery=false;
-<endif>
-	<if(backtracking)>state.failed=false;<endif>
+	<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
}
else
{
@@ -933,54 +966,57 @@ else
}<\n>
>>

-matchSetUnchecked(s,label,elementIndex,postmatchCode="") ::= <<
+matchSetUnchecked(s,label,elementIndex,postmatchCode=false) ::= <%
<if(label)>
-<if(LEXER)>
-<label>= input.LA(1);<\n>
-<else>
-<label>=(<labelType>)input.LT(1);<\n>
+<matchSetLabel()><\n>
<endif>
+input.Consume();<\n>
+<if(postmatchCode)>
+<postmatchCode><\n>
<endif>
-input.Consume();
-<postmatchCode>
-<if(!LEXER)>
-	state.errorRecovery=false;
+<if(!LEXER)>state.errorRecovery=false;<endif><if(backtracking)>state.failed=false;<endif>
+%>
+
+matchSetLabel() ::= <%
+<if(LEXER)>
+<label>= input.LA(1);
+<else>
+<label>=(<labelType>)input.LT(1);
<endif>
-	<if(backtracking)>state.failed=false;<endif>
->>
+%>

matchRuleBlockSet ::= matchSet

matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
<matchSet(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** Match a string literal */
-lexerStringRef(string,label,elementIndex) ::= <<
+lexerStringRef(string,label,elementIndex) ::= <%
<if(label)>
-int <label>Start = CharIndex;
-Match(<string>); <checkRuleBacktrackFailure()>
-int <label>StartLine<elementIndex> = Line;
-int <label>StartCharPos<elementIndex> = CharPositionInLine;
-<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start, CharIndex-1);
-<label>.Line = <label>StartLine<elementIndex>;
+int <label>Start = CharIndex;<\n>
+Match(<string>); <checkRuleBacktrackFailure()><\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
<else>
Match(<string>); <checkRuleBacktrackFailure()><\n>
<endif>
->>
+%>

-wildcard(label,elementIndex) ::= <<
+wildcard(token,label,elementIndex,terminalOptions) ::= <<
<if(label)>
<label>=(<labelType>)input.LT(1);<\n>
<endif>
MatchAny(input); <checkRuleBacktrackFailure()>
>>

-wildcardAndListLabel(label,elementIndex) ::= <<
+wildcardAndListLabel(token,label,elementIndex,terminalOptions) ::= <<
<wildcard(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** Match . wildcard in lexer */
@@ -993,7 +1029,7 @@ MatchAny(); <checkRuleBacktrackFailure()>

wildcardCharListLabel(label, elementIndex) ::= <<
<wildcardChar(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** Match a rule reference by invoking it possibly with arguments
@@ -1004,7 +1040,7 @@ wildcardCharListLabel(label, elementIndex) ::= <<
*/
ruleRef(rule,label,elementIndex,args,scope) ::= <<
PushFollow(Follow._<rule.name>_in_<ruleName><elementIndex>);
-<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name>(<args; separator=", ">);
+<if(label)><label>=<endif><if(scope)><scope:delegateName()>.<endif><rule.name; format="id">(<args; separator=", ">);
PopFollow();
<checkRuleBacktrackFailure()>
>>
@@ -1012,7 +1048,7 @@ PopFollow();
/** ids+=r */
ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
<ruleRef(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType={<ASTLabelType>},...)>
>>

/** A lexer rule reference.
@@ -1021,40 +1057,40 @@ ruleRefAndListLabel(rule,label,elementIndex,args,scope) ::= <<
*  is type Rule, whose toString is same: the rule name.
*  Now though you can access full rule descriptor stuff.
*/
-lexerRuleRef(rule,label,args,elementIndex,scope) ::= <<
+lexerRuleRef(rule,label,args,elementIndex,scope) ::= <%
<if(label)>
-int <label>Start<elementIndex> = CharIndex;
-int <label>StartLine<elementIndex> = Line;
-int <label>StartCharPos<elementIndex> = CharPositionInLine;
-<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
-<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);
-<label>.Line = <label>StartLine<elementIndex>;
+int <label>Start<elementIndex> = CharIndex;<\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()><\n>
+<label> = new <labelType>(input, TokenTypes.Invalid, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
<else>
<if(scope)><scope:delegateName()>.<endif>m<rule.name>(<args; separator=", ">); <checkRuleBacktrackFailure()>
<endif>
->>
+%>

/** i+=INT in lexer */
lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
<lexerRuleRef(...)>
-<listLabel(elem=label,...)>
+<listLabelElem(elem=label,elemType=labelType,...)>
>>

/** EOF in the lexer */
-lexerMatchEOF(label,elementIndex) ::= <<
+lexerMatchEOF(label,elementIndex) ::= <%
<if(label)>
-int <label>Start<elementIndex> = CharIndex;
-int <label>StartLine<elementIndex> = Line;
-int <label>StartCharPos<elementIndex> = CharPositionInLine;
-Match(EOF); <checkRuleBacktrackFailure()>
-<labelType> <label> = new <labelType>(input, EOF, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);
-<label>.Line = <label>StartLine<elementIndex>;
+int <label>Start<elementIndex> = CharIndex;<\n>
+int <label>StartLine<elementIndex> = Line;<\n>
+int <label>StartCharPos<elementIndex> = CharPositionInLine;<\n>
+Match(EOF); <checkRuleBacktrackFailure()><\n>
+<labelType> <label> = new <labelType>(input, EOF, TokenChannels.Default, <label>Start<elementIndex>, CharIndex-1);<\n>
+<label>.Line = <label>StartLine<elementIndex>;<\n>
<label>.CharPositionInLine = <label>StartCharPos<elementIndex>;
<else>
Match(EOF); <checkRuleBacktrackFailure()>
<endif>
->>
+%>

// used for left-recursive rules
recRuleDefArg()                       ::= "int <recRuleArg()>"
@@ -1101,13 +1137,13 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
else
{
<if(eotPredictsAlt)>
-	alt<decisionNumber>=<eotPredictsAlt>;
+	alt<decisionNumber> = <eotPredictsAlt>;
<else>
<ruleBacktrackFailure()>
-	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
+	NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);
DebugRecognitionException(nvae);
<@noViableAltException()>
-	throw nvae;<\n>
+	throw nvae;
<endif>
}
>>
@@ -1133,18 +1169,18 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
<if(!edges)>
-alt<decisionNumber>=<eotPredictsAlt>; <! if no edges, don't gen ELSE !>
+alt<decisionNumber> = <eotPredictsAlt>;<! if no edges, don't gen ELSE !>
<else>
else
{
-	alt<decisionNumber>=<eotPredictsAlt>;
+	alt<decisionNumber> = <eotPredictsAlt>;
}<\n>
<endif>
<endif>
>>

/** An accept state indicates a unique alternative has been predicted */
-dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>;"
+dfaAcceptState(alt) ::= "alt<decisionNumber> = <alt>;"

/** A simple edge with an expression.  If the expression is satisfied,
*  enter to the target state.  To handle gated productions, we may
@@ -1173,11 +1209,11 @@ default:
<else>
{
<ruleBacktrackFailure()>
-		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);<\n>
+		NoViableAltException nvae = new NoViableAltException("<description>", <decisionNumber>, <stateNumber>, input);
DebugRecognitionException(nvae);
<@noViableAltException()>
throw nvae;
-	}<\n>
+	}
<endif>
}<\n>
>>
@@ -1192,7 +1228,7 @@ switch (input.LA(<k>))
dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
switch (input.LA(<k>))
{
-<edges; separator="\n"><\n>
+<edges; separator="\n">
<if(eotPredictsAlt)>
default:
alt<decisionNumber>=<eotPredictsAlt>;
@@ -1202,7 +1238,7 @@ default:
>>

dfaEdgeSwitch(labels, targetState) ::= <<
-<labels:{case <it>:}; separator="\n">
+<labels:{it|case <it>:}; separator="\n">
{
<targetState>
}
@@ -1275,7 +1311,7 @@ private class DFA<dfa.decisionNumber> : DFA

public DFA<dfa.decisionNumber>( BaseRecognizer recognizer<if(dfa.specialStateSTs)>, SpecialStateTransitionHandler specialStateTransition<endif> )
<if(dfa.specialStateSTs)>
-		: base(specialStateTransition)<\n>
+		: base(specialStateTransition)
<endif>
{
this.recognizer = recognizer;
@@ -1316,12 +1352,12 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
<state>}; separator="\n">
}
<if(backtracking)>
-	if (state.backtracking > 0) {state.failed=true; return -1;}<\n>
+	if (state.backtracking > 0) {state.failed=true; return -1;}
<endif>
NoViableAltException nvae = new NoViableAltException(dfa.Description, <dfa.decisionNumber>, _s, input);
dfa.Error(nvae);
throw nvae;
-}<\n>
+}
<endif>
>>

@@ -1330,16 +1366,18 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
*/
cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
int LA<decisionNumber>_<stateNumber> = input.LA(1);<\n>
-<if(semPredState)><! get next lookahead symbol to test edges, then rewind !>
-int index<decisionNumber>_<stateNumber> = input.Index;
-input.Rewind();<\n>
+<if(semPredState)>
+<! get next lookahead symbol to test edges, then rewind !>
+<\n>int index<decisionNumber>_<stateNumber> = input.Index;
+input.Rewind();
<endif>
s = -1;
<edges; separator="\nelse ">
-<if(semPredState)><! return input cursor to state before we rewound !>
-input.Seek(index<decisionNumber>_<stateNumber>);<\n>
+<if(semPredState)>
+<! return input cursor to state before we rewound !>
+<\n>input.Seek(index<decisionNumber>_<stateNumber>);
<endif>
-if ( s>=0 ) return s;
+if (s >= 0) return s;
break;
>>

@@ -1347,7 +1385,7 @@ break;
*  state to jump to next if successful.
*/
cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
-if ( (<labelExpr>) <if(predicates)>&& (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
+if ((<labelExpr>)<if(predicates)> && (<predicates>)<endif>) {s = <targetStateNumber>;}<\n>
>>

/** An edge pointing at end-of-token; essentially matches any char;
@@ -1377,39 +1415,44 @@ lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
*/
isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

-lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
-(LA<decisionNumber>_<stateNumber>\>=<lower> && LA<decisionNumber>_<stateNumber>\<=<upper>)
->>
+lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
+(LA<decisionNumber>_<stateNumber><ge()><lower> && LA<decisionNumber>_<stateNumber><le()><upper>)
+%>
+
+isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"

-isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)\>=<lower> && input.LA(<k>)\<=<upper>)"
+le() ::= "\<="
+ge() ::= ">="

-setTest(ranges) ::= "<ranges; separator=\"||\">"
+setTest(ranges) ::= <<
+<ranges; separator="||">
+>>

// A T T R I B U T E S

attributeScope(scope) ::= <<
<if(scope.attributes)>
-protected class <scope.name>_scope
+protected sealed partial class <scope.name>_scope
{
-	<scope.attributes:{public <it.decl>;}; separator="\n">
+	<scope.attributes:{it|public <it.decl>;}; separator="\n">
}
<if(scope.actions.scopeinit)>
protected void <scope.name>_scopeInit( <scope.name>_scope scope )
{
<scope.actions.scopeinit>
-}<\n>
+}
<else>
-void <scope.name>_scopeInit( <scope.name>_scope scope ) {}<\n>
+protected virtual void <scope.name>_scopeInit( <scope.name>_scope scope ) {}
<endif>
<if(scope.actions.scopeafter)>
protected void <scope.name>_scopeAfter( <scope.name>_scope scope )
{
<scope.actions.scopeafter>
-}<\n>
+}
<else>
-void <scope.name>_scopeAfter( <scope.name>_scope scope ) {}<\n>
+protected virtual void <scope.name>_scopeAfter( <scope.name>_scope scope ) {}
<endif>
-protected Stack\<<scope.name>_scope\> <scope.name>_stack = new Stack\<<scope.name>_scope\>();<\n>
+protected readonly ListStack\<<scope.name>_scope\> <scope.name>_stack = new ListStack\<<scope.name>_scope\>();
<endif>
>>

@@ -1421,36 +1464,36 @@ ruleAttributeScope(scope) ::= <<
<attributeScope(...)>
>>

-returnStructName() ::= "<it.name>_return"
+returnStructName(it) ::= "<it.name>_return"

-returnType() ::= <<
-<if(ruleDescriptor.hasMultipleReturnValues)>
-<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
-<else>
-<if(ruleDescriptor.hasSingleReturnValue)>
-<ruleDescriptor.singleValueReturnType>
+returnType(ruleDescriptor) ::= <%
+<if(ruleDescriptor.returnScope.attributes && ruleDescriptor.hasMultipleReturnValues)>
+	<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
+<elseif(ruleDescriptor.hasMultipleReturnValues)>
+	<ruleReturnBaseType()>
+<elseif(ruleDescriptor.hasSingleReturnValue)>
+	<ruleDescriptor.singleValueReturnType>
<else>
-void
+	void
<endif>
-<endif>
->>
+%>

/** Generate the C# type associated with a single or multiple return
*  values.
*/
-ruleLabelType(referencedRule) ::= <<
-<if(referencedRule.hasMultipleReturnValues)>
-<referencedRule.grammar.recognizerName>.<referencedRule.name>_return
-<else>
-<if(referencedRule.hasSingleReturnValue)>
-<referencedRule.singleValueReturnType>
+ruleLabelType(referencedRule) ::= <%
+<if(referencedRule.returnScope.attributes&&referencedRule.hasMultipleReturnValues)>
+	<referencedRule.grammar.recognizerName>.<referencedRule:returnStructName()>
+<elseif(referencedRule.hasMultipleReturnValues)>
+	<ruleReturnBaseType()>
+<elseif(referencedRule.hasSingleReturnValue)>
+	<referencedRule.singleValueReturnType>
<else>
-void
+	void
<endif>
-<endif>
->>
+%>

-delegateName() ::= <<
+delegateName(it) ::= <<
<if(it.label)><it.label><else>g<it.name><endif>
>>

@@ -1462,85 +1505,97 @@ default(<typeName>)
>>

/** Define a rule label including default value */
-ruleLabelDef(label) ::= <<
+ruleLabelDef(label) ::= <%
<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text> = <initValue(typeName=ruleLabelType(referencedRule=label.referencedRule))>;
->>
+%>

/** Define a return struct for a rule if the code needs to access its
*  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
*  subgroups to stick in members.
*/
returnScope(scope) ::= <<
-<if(ruleDescriptor.hasMultipleReturnValues)>
-public class <ruleDescriptor:returnStructName()> : <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>\><@ruleReturnInterfaces()>
+<if(scope.attributes && ruleDescriptor.hasMultipleReturnValues)>
+<returnScopeModifier(grammar=grammar,ruleDescriptor=ruleDescriptor)> sealed partial class <ruleDescriptor:returnStructName()> : <ruleReturnBaseType()><@ruleReturnInterfaces()>
{
-	<scope.attributes:{public <it.decl>;}; separator="\n">
+	<scope.attributes:{it|public <it.decl>;}; separator="\n">
<@ruleReturnMembers()>
}
<endif>
>>

+ruleReturnBaseType() ::= <%
+<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope\<<labelType>>
+%>
+
+@returnScope.ruleReturnMembers() ::= <<
+>>
+
parameterScope(scope) ::= <<
-<scope.attributes:{<it.decl>}; separator=", ">
+<scope.attributes:{it|<it.decl>}; separator=", ">
>>

-parameterAttributeRef(attr) ::= "<attr.name>"
-parameterSetAttributeRef(attr,expr) ::= "<attr.name> =<expr>;"
+parameterAttributeRef(attr) ::= <<
+<attr.name; format="id">
+>>
+
+parameterSetAttributeRef(attr,expr) ::= <<
+<attr.name; format="id"> =<expr>;
+>>

-scopeAttributeRef(scope,attr,index,negIndex) ::= <<
+scopeAttributeRef(scope,attr,index,negIndex) ::= <%
<if(negIndex)>
-((<scope>_scope)<scope>_stack.elementAt(<scope>_stack.size()-<negIndex>-1)).<attr.name>
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id">
<else>
<if(index)>
-((<scope>_scope)<scope>_stack.elementAt(<index>)).<attr.name>
+<scope>_stack[<index>].<attr.name; format="id">
<else>
-((<scope>_scope)<scope>_stack.Peek()).<attr.name>
+<scope>_stack.Peek().<attr.name; format="id">
<endif>
<endif>
->>
+%>

-scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
+scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <%
<if(negIndex)>
-((<scope>_scope)<scope>_stack.elementAt(<scope>_stack.size()-<negIndex>-1)).<attr.name> =<expr>;
+<scope>_stack[<scope>_stack.Count - <negIndex> - 1].<attr.name; format="id"> = <expr>;
<else>
<if(index)>
-((<scope>_scope)<scope>_stack.elementAt(<index>)).<attr.name> =<expr>;
+<scope>_stack[<index>].<attr.name; format="id"> = <expr>;
<else>
-((<scope>_scope)<scope>_stack.Peek()).<attr.name> =<expr>;
+<scope>_stack.Peek().<attr.name; format="id"> = <expr>;
<endif>
<endif>
->>
+%>

/** $x is either global scope or x is rule with dynamic scope; refers
*  to stack itself not top of stack.  This is useful for predicates
- *  like {$function.size()>0 && $function::name.equals("foo")}?
+ *  like {$function.Count>0 && $function::name.Equals("foo")}?
*/
isolatedDynamicScopeRef(scope) ::= "<scope>_stack"

/** reference an attribute of rule; might only have single return value */
-ruleLabelRef(referencedRule,scope,attr) ::= <<
+ruleLabelRef(referencedRule,scope,attr) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
-(<scope>!=null?<scope>.<attr.name>:<initValue(attr.type)>)
+(<scope>!=null?<scope>.<attr.name; format="id">:<initValue(attr.type)>)
<else>
<scope>
<endif>
->>
+%>

-returnAttributeRef(ruleDescriptor,attr) ::= <<
+returnAttributeRef(ruleDescriptor,attr) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
-retval.<attr.name>
+retval.<attr.name; format="id">
<else>
-<attr.name>
+<attr.name; format="id">
<endif>
->>
+%>

-returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <<
+returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
-retval.<attr.name> =<expr>;
+retval.<attr.name; format="id"> =<expr>;
<else>
-<attr.name> =<expr>;
+<attr.name; format="id"> =<expr>;
<endif>
->>
+%>

/** How to translate $tokenLabel */
tokenLabelRef(label) ::= "<label>"
@@ -1560,10 +1615,10 @@ tokenLabelPropertyRef_index(scope,attr) ::= "(<scope>!=null?<scope>.TokenIndex:0
tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>_tree"
tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?int.Parse(<scope>.Text):0)"

-ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):null)"
-ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):null)"
-ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):null)"
-ruleLabelPropertyRef_text(scope,attr) ::= <<
+ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Start):default(<labelType>))"
+ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.Stop):default(<labelType>))"
+ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.Tree):default(<ASTLabelType>))"
+ruleLabelPropertyRef_text(scope,attr) ::= <%
<if(TREE_PARSER)>
(<scope>!=null?(input.TokenStream.ToString(
input.TreeAdaptor.GetTokenStartIndex(<scope>.Start),
@@ -1571,7 +1626,7 @@ ruleLabelPropertyRef_text(scope,attr) ::= <<
<else>
(<scope>!=null?input.ToString(<scope>.Start,<scope>.Stop):null)
<endif>
->>
+%>

ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?<scope>.Template:null)"

@@ -1603,7 +1658,7 @@ lexerRuleLabelPropertyRef_int(scope,attr) ::=
rulePropertyRef_start(scope,attr) ::= "retval.Start"
rulePropertyRef_stop(scope,attr) ::= "retval.Stop"
rulePropertyRef_tree(scope,attr) ::= "retval.Tree"
-rulePropertyRef_text(scope,attr) ::= <<
+rulePropertyRef_text(scope,attr) ::= <%
<if(TREE_PARSER)>
input.TokenStream.ToString(
input.TreeAdaptor.GetTokenStartIndex(retval.Start),
@@ -1611,7 +1666,7 @@ input.TokenStream.ToString(
<else>
input.ToString(retval.Start,input.LT(-1))
<endif>
->>
+%>
rulePropertyRef_st(scope,attr) ::= "retval.Template"

lexerRulePropertyRef_text(scope,attr) ::= "Text"
@@ -1630,15 +1685,19 @@ ruleSetPropertyRef_tree(scope,attr,expr) ::= "retval.Tree = <expr>;"
ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.Template =<expr>;"

/** How to execute an action (only when not backtracking) */
-execAction(action) ::= <<
+execAction(action) ::= <%
<if(backtracking)>
-if ( <actions.(actionScope).synpredgate> )
-{
-	<action>
+if (<actions.(actionScope).synpredgate>)<\n>
+{<\n>
+<@indentedAction()><\n>
}
<else>
<action>
<endif>
+%>
+
+@execAction.indentedAction() ::= <<
+	<action>
>>

/** How to always execute an action even when backtracking */
@@ -1647,10 +1706,10 @@ execForcedAction(action) ::= "<action>"
// M I S C (properties, etc...)

bitset(name, words64) ::= <<
-public static readonly BitSet <name> = new BitSet(new ulong[]{<words64:{<it>UL};separator=",">});<\n>
+public static readonly BitSet <name> = new BitSet(new ulong[]{<words64:{it|<it>UL};separator=",">});
>>

codeFileExtension() ::= ".cs"

-true() ::= "true"
-false() ::= "false"
+true_value() ::= "true"
+false_value() ::= "false"
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/Dbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/Dbg.stg
index 33e827c..efad5b5 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/Dbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/Dbg.stg
@@ -1,36 +1,36 @@
/*
- [The "BSD license"]
- Copyright (c) 2007-2008 Johannes Luber
- Copyright (c) 2005-2007 Kunle Odutola
- Copyright (c) 2005 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
/** Template overrides to add debugging to normal Java output;
*  If ASTs are built, then you'll also get ASTDbg.stg loaded.
*/
-group Dbg;

@outputFile.debugPreprocessor() ::= "#define ANTLR_DEBUG"

@@ -88,11 +88,11 @@ protected virtual bool EvalPredicate( bool result, string predicate )
ctorForRootGrammar() ::= <<
<! bug: can't use <@super.members()> cut-n-paste instead !>
<! Same except we add port number and profile stuff if root grammar !>
-public <name>( <inputStreamType> input )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
{
}
-public <name>( <inputStreamType> input, int port, RecognizerSharedState state )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, int port, RecognizerSharedState state )
: base( input, state )
{
<parserCtorBody()>
@@ -104,11 +104,11 @@ public <name>( <inputStreamType> input, int port, RecognizerSharedState state )

ctorForProfilingRootGrammar() ::= <<
<! bug: can't use <@super.members()> cut-n-paste instead !>
-public <name>( <inputStreamType> input )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input )
: this( input, new Profiler(null), new RecognizerSharedState() )
{
}
-public <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state )
: base( input, dbg, state )
{
Profiler p = (Profiler)dbg;
@@ -123,7 +123,7 @@ public <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerShare

/** Basically we don't want to set any dbg listeners are root will have it. */
ctorForDelegateGrammar() ::= <<
-public <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
: base( input, dbg, state )
{
<parserCtorBody()>
@@ -133,7 +133,7 @@ public <name>( <inputStreamType> input, IDebugEventListener dbg, RecognizerShare
>>

ctorForPredefinedListener() ::= <<
-public <name>( <inputStreamType> input, IDebugEventListener dbg )
+<actions.(actionScope).ctorModifier; null="public"> <name>( <inputStreamType> input, IDebugEventListener dbg )
<@superClassRef>: base( input, dbg, new RecognizerSharedState() )<@end>
{
<if(profile)>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ST.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ST.stg
index bf80ce6..d6dd973 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/ST.stg
@@ -1,36 +1,36 @@
/*
- [The "BSD license"]
- Copyright (c) 2007-2008 Johannes Luber
- Copyright (c) 2005-2007 Kunle Odutola
- Copyright (c) 2005 Terence Parr
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without
- modification, are permitted provided that the following conditions
- are met:
- 1. Redistributions of source code must retain the above copyright
-    notice, this list of conditions and the following disclaimer.
- 2. Redistributions in binary form must reproduce the above copyright
-    notice, this list of conditions and the following disclaimer in the
-    documentation and/or other materials provided with the distribution.
- 3. The name of the author may not be used to endorse or promote products
-    derived from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
- IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
- OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
+ * [The "BSD license"]
+ * Copyright (c) 2007-2008 Johannes Luber
+ * Copyright (c) 2005-2007 Kunle Odutola
+ * Copyright (c) 2011 Sam Harwell
+ * Copyright (c) 2011 Terence Parr
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
/** Template subgroup to add template rewrite output
*  If debugging, then you'll also get STDbg.stg loaded.
*/
-group ST;

@outputFile.imports() ::= <<
<@super.imports()>

