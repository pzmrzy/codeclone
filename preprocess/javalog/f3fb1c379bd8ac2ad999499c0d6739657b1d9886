commit f3fb1c379bd8ac2ad999499c0d6739657b1d9886
Author:     acondit <acondit@parrt.spork>
AuthorDate: Sat May 7 08:18:20 2011 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Sat May 7 08:18:20 2011 -0800

Changes to match ANTLR3.4 revision.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8421]

diff --git a/runtime/ObjC/Framework/examples/treerewrite/TreeRewrite.tokens b/runtime/ObjC/Framework/examples/treerewrite/TreeRewrite.tokens
index eb18cc6..97819e8 100644
--- a/runtime/ObjC/Framework/examples/treerewrite/TreeRewrite.tokens
+++ b/runtime/ObjC/Framework/examples/treerewrite/TreeRewrite.tokens
@@ -1,2 +1,2 @@
-WS=5
INT=4
+WS=5
diff --git a/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteLexer.h b/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteLexer.h
index 297fe40..f51686c 100644
--- a/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteLexer.h
+++ b/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteLexer.h
@@ -1,10 +1,10 @@
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 TreeRewrite.g 2010-08-24 14:18:09
+// $ANTLR ${project.version} ${buildNumber} TreeRewrite.g 2011-05-06 18:56:28

/* =============================================================================
* Standard antlr3 OBJC runtime definitions
*/
#import <Cocoa/Cocoa.h>
-#import "antlr3.h"
+#import <ANTLR/ANTLR.h>
/* End of standard antlr3 runtime definitions
* =============================================================================
*/
@@ -14,17 +14,24 @@
#pragma mark Rule return scopes start
#pragma mark Rule return scopes end
#pragma mark Tokens
+#ifdef EOF
+#undef EOF
+#endif
+#define EOF -1
#define INT 4
#define WS 5
-#define EOF -1
+/* interface lexer class */
@interface TreeRewriteLexer : ANTLRLexer { // line 283
-// start of actions.lexer.memVars
-// start of action-actionScope-memVars
+/* ObjC start of actions.lexer.memVars */
+/* ObjC end of actions.lexer.memVars */
}
++ (void) initialize;
+ (TreeRewriteLexer *)newTreeRewriteLexerWithCharStream:(id<ANTLRCharStream>)anInput;
-
-- (void)mINT;
-- (void)mWS;
-- (void)mTokens;
+/* ObjC start actions.lexer.methodsDecl */
+/* ObjC end actions.lexer.methodsDecl */
+- (void) mINT ;
+- (void) mWS ;
+- (void) mTokens ;

@end /* end of TreeRewriteLexer interface */
+
diff --git a/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteLexer.m b/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteLexer.m
index 2ede464..0d9d31a 100644
--- a/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteLexer.m
+++ b/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteLexer.m
@@ -1,43 +1,18 @@
/** \file
- *  This OBJC source file was generated by $ANTLR version 3.2 Aug 24, 2010 10:45:57
+ *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
*
*     -  From the grammar source file : TreeRewrite.g
- *     -                            On : 2010-08-24 14:18:09
- *     -                 for the lexer : TreeRewriteLexerLexer *
- * Editing it, at least manually, is not wise.
+ *     -                            On : 2011-05-06 18:56:28
+ *     -                 for the lexer : TreeRewriteLexerLexer
+ *
+ * Editing it, at least manually, is not wise.
*
* ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
*
*
*/
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 TreeRewrite.g 2010-08-24 14:18:09
+// $ANTLR ${project.version} ${buildNumber} TreeRewrite.g 2011-05-06 18:56:28
+

/* -----------------------------------------
* Include the ANTLR3 generated header file.
@@ -47,12 +22,10 @@


/* ============================================================================= */
-
/* =============================================================================
* Start of recognizer
*/

-
/** As per Terence: No returns for lexer rules! */
@implementation TreeRewriteLexer // line 330

@@ -73,8 +46,8 @@

- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
{
-    if ((self = [super initWithCharStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:3+1]]) != nil) {
-
+    self = [super initWithCharStream:anInput State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:3+1] retain]];
+    if ( self != nil ) {
}
return self;
}
@@ -84,15 +57,18 @@
[super dealloc];
}

-/* Start of actions.lexer.methods */
-/* start methods() */
+/* ObjC Start of actions.lexer.methods */
+/* ObjC end of actions.lexer.methods */
+/* ObjC start methods() */
+/* ObjC end methods() */

/* Start of Rules */
// $ANTLR start "INT"
- (void) mINT
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = INT;
@@ -101,55 +77,65 @@
// TreeRewrite.g:15:7: ( '0' .. '9' )+ // alt
{
// TreeRewrite.g:15:7: ( '0' .. '9' )+ // positiveClosureBlock
-        NSInteger cnt1=0;
+        NSInteger cnt1 = 0;
do {
-            NSInteger alt1=2;
+            NSInteger alt1 = 2;
NSInteger LA1_0 = [input LA:1];
-            if ( ((LA1_0>='0' && LA1_0<='9')) ) {
+            if ( ((LA1_0 >= '0' && LA1_0 <= '9')) ) {
alt1=1;
}


switch (alt1) {
case 1 : ;
-                    // TreeRewrite.g:15:8: '0' .. '9' // alt
+                    // TreeRewrite.g: // alt
{
-                    [self matchRangeFromChar:'0' to:'9'];   /* element() */
-                     /* elements */
+                    if ((([input LA:1] >= '0') && ([input LA:1] <= '9'))) {
+                        [input consume];
+                    } else {
+                        ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
+                        [self recover:mse];
+                        @throw mse;
+                    }
+
+
}
break;

default :
if ( cnt1 >= 1 )
goto loop1;
-                    ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:1];
+                    ANTLREarlyExitException *eee =
+                        [ANTLREarlyExitException newException:input decisionNumber:1];
@throw eee;
}
cnt1++;
} while (YES);
loop1: ;
-          /* element() */
-         /* elements */
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "INT"
+/* $ANTLR end "INT" */

// $ANTLR start "WS"
- (void) mWS
{
//
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

@try {
NSInteger _type = WS;
@@ -158,23 +144,26 @@
// TreeRewrite.g:18:9: ' ' // alt
{
[self matchChar:' '];
-          /* element() */
-        _channel=99;  /* element() */
-         /* elements */
+
+
+        _channel=HIDDEN;
+
+
}

// token+rule list labels

-        [state setType:_type];
-
+        state.type = _type;
state.channel = _channel;
}
@finally {
//
+        /* Terence's stuff */
+
}
return;
}
-// $ANTLR end "WS"
+/* $ANTLR end "WS" */

- (void) mTokens
{
@@ -182,31 +171,35 @@
NSInteger alt2=2;
NSInteger LA2_0 = [input LA:1];

-    if ( ((LA2_0>='0' && LA2_0<='9')) ) {
+    if ( ((LA2_0 >= '0' && LA2_0 <= '9')) ) {
alt2=1;
}
else if ( (LA2_0==' ') ) {
alt2=2;
}
else {
-        ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newANTLRNoViableAltException:2 state:0 stream:input];
+        ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:2 state:0 stream:input];
+        nvae.c = LA2_0;
@throw nvae;
+
}
switch (alt2) {
case 1 : ;
// TreeRewrite.g:1:10: INT // alt
{
-                [self mINT];
-              /* element() */
-             /* elements */
+            [self mINT];
+
+
+
}
break;
case 2 : ;
// TreeRewrite.g:1:14: WS // alt
{
-                [self mWS];
-              /* element() */
-             /* elements */
+            [self mWS];
+
+
+
}
break;

@@ -214,8 +207,4 @@

}

-@end /* end of TreeRewriteLexer implementation line 397 */
-
-/* End of code
- * =============================================================================
- */
+@end /* end of TreeRewriteLexer implementation line 397 */
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteParser.h b/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteParser.h
index 1b20be6..f587cdd 100644
--- a/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteParser.h
+++ b/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteParser.h
@@ -1,76 +1,124 @@
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 TreeRewrite.g 2010-08-24 14:18:09
+// $ANTLR ${project.version} ${buildNumber} TreeRewrite.g 2011-05-06 18:56:28

/* =============================================================================
* Standard antlr3 OBJC runtime definitions
*/
#import <Cocoa/Cocoa.h>
-#import "antlr3.h"
+#import <ANTLR/ANTLR.h>
/* End of standard antlr3 runtime definitions
* =============================================================================
*/

/* parserHeaderFile */
+#ifndef ANTLR3TokenTypeAlreadyDefined
+#define ANTLR3TokenTypeAlreadyDefined
+typedef enum {
+    ANTLR_EOF = -1,
+    INVALID,
+    EOR,
+    DOWN,
+    UP,
+    MIN
+} ANTLR3TokenType;
+#endif
+
#pragma mark Tokens
-#define WS 5
-#define INT 4
+#ifdef EOF
+#undef EOF
+#endif
#define EOF -1
+#define INT 4
+#define WS 5
#pragma mark Dynamic Global Scopes
#pragma mark Dynamic Rule Scopes
#pragma mark Rule Return Scopes start
-/* returnScopeInterface */
-@interface TreeRewriteParser_rule_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+/* returnScopeInterface TreeRewriteParser_rule_return */
+@interface TreeRewriteParser_rule_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (TreeRewriteParser_rule_return *)newTreeRewriteParser_rule_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */
-/* returnScopeInterface */
-@interface TreeRewriteParser_subrule_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1806 */
+
+
+
+/* returnScopeInterface TreeRewriteParser_subrule_return */
+@interface TreeRewriteParser_subrule_return :ANTLRParserRuleReturnScope { /* returnScopeInterface line 1838 */
/* AST returnScopeInterface.memVars */
-ANTLRCommonTree *tree; /* start of memVars() */
+ANTLRCommonTree *tree; /* ObjC start of memVars() */
}
+/* start properties */
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree; /* start properties */
+@property (retain, getter=getTree, setter=setTree:) ANTLRCommonTree *tree;
+ (TreeRewriteParser_subrule_return *)newTreeRewriteParser_subrule_return;
/* this is start of set and get methods */
-/* AST returnScopeInterface.methodsdecl */
+/* AST returnScopeInterface.methodsDecl */
- (ANTLRCommonTree *)getTree;
+
- (void) setTree:(ANTLRCommonTree *)aTree;
/* methodsDecl */
@end /* end of returnScopeInterface interface */

-#pragma mark Rule return scopes end
+
+
+
+/* Interface grammar class */
@interface TreeRewriteParser : ANTLRParser { /* line 572 */
-// start of globalAttributeScopeMemVar
+/* ObjC start of ruleAttributeScopeMemVar */


-// start of action-actionScope-memVars
-// start of ruleAttributeScopeMemVar
+/* ObjC end of ruleAttributeScopeMemVar */
+/* ObjC start of globalAttributeScopeMemVar */


-// Start of memVars
+/* ObjC end of globalAttributeScopeMemVar */
+/* ObjC start of actions.(actionScope).memVars */
+/* ObjC end of actions.(actionScope).memVars */
+/* ObjC start of memVars */
/* AST parserHeaderFile.memVars */
-/* AST parsermemVars */
-id<ANTLRTreeAdaptor> treeAdaptor;
+NSInteger ruleLevel;
+NSArray *ruleNames;
+  /* AST super.memVars */
+/* AST parserMemVars */
+id<ANTLRTreeAdaptor> treeAdaptor;   /* AST parserMemVars */
+/* ObjC end of memVars */

}

-// start of action-actionScope-methodsDecl
+/* ObjC start of actions.(actionScope).properties */
+/* ObjC end of actions.(actionScope).properties */
+/* ObjC start of properties */
+/* AST parserHeaderFile.properties */
+  /* AST super.properties */
+/* AST parserProperties */
+@property (retain, getter=getTreeAdaptor, setter=setTreeAdaptor:) id<ANTLRTreeAdaptor> treeAdaptor;   /* AST parserproperties */
+/* ObjC end of properties */
+
++ (void) initialize;
++ (id) newTreeRewriteParser:(id<ANTLRTokenStream>)aStream;
+/* ObjC start of actions.(actionScope).methodsDecl */
+/* ObjC end of actions.(actionScope).methodsDecl */

-/* AST parserHeaderFile.methodsdecl */
+/* ObjC start of methodsDecl */
+/* AST parserHeaderFile.methodsDecl */
+  /* AST super.methodsDecl */
/* AST parserMethodsDecl */
- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)theTreeAdaptor;
+- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)theTreeAdaptor;   /* AST parsermethodsDecl */
+/* ObjC end of methodsDecl */

- (TreeRewriteParser_rule_return *)rule;
- (TreeRewriteParser_subrule_return *)subrule;


@end /* end of TreeRewriteParser interface */
+
diff --git a/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteParser.m b/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteParser.m
index 4dcb7da..9340e6e 100644
--- a/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteParser.m
+++ b/runtime/ObjC/Framework/examples/treerewrite/TreeRewriteParser.m
@@ -1,43 +1,18 @@
/** \file
- *  This OBJC source file was generated by $ANTLR version 3.2 Aug 24, 2010 10:45:57
+ *  This OBJC source file was generated by $ANTLR version ${project.version} ${buildNumber}
*
*     -  From the grammar source file : TreeRewrite.g
- *     -                            On : 2010-08-24 14:18:09
- *     -                for the parser : TreeRewriteParserParser *
- * Editing it, at least manually, is not wise.
+ *     -                            On : 2011-05-06 18:56:28
+ *     -                for the parser : TreeRewriteParserParser
+ *
+ * Editing it, at least manually, is not wise.
*
* ObjC language generator and runtime by Alan Condit, acondit|hereisanat|ipns|dotgoeshere|com.
*
*
*/
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-//
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-// $ANTLR 3.2 Aug 24, 2010 10:45:57 TreeRewrite.g 2010-08-24 14:18:09
+// $ANTLR ${project.version} ${buildNumber} TreeRewrite.g 2011-05-06 18:56:28
+

/* -----------------------------------------
* Include the ANTLR3 generated header file.
@@ -47,13 +22,10 @@


/* ============================================================================= */
-
/* =============================================================================
* Start of recognizer
*/

-
-
#pragma mark Bitsets
static ANTLRBitSet *FOLLOW_INT_in_rule26;
static const unsigned long long FOLLOW_INT_in_rule26_data[] = { 0x0000000000000010LL};
@@ -67,8 +39,7 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000

#pragma mark Dynamic Rule Scopes

-#pragma mark Rule return scopes start
-/* returnScope */
+#pragma mark Rule Return Scopes start
@implementation TreeRewriteParser_rule_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -77,6 +48,12 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
return [[[TreeRewriteParser_rule_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -94,16 +71,15 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */

-/* returnScope */
+
@implementation TreeRewriteParser_subrule_return /* returnScope */
/* AST returnScope.synthesize */
@synthesize tree; /* start of synthesize -- OBJC-Line 1837 */
@@ -112,6 +88,12 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
return [[[TreeRewriteParser_subrule_return alloc] init] retain];
}

+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
/* AST returnScope.methods */
- (ANTLRCommonTree *)getTree
{
@@ -129,19 +111,36 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000

- (void) dealloc
{
-    [self setTree:nil];
+    self.tree = nil;
[super dealloc];
}



-
@end /* end of returnScope implementation */


+//#pragma mark Rule return scopes start
+//
+
+#pragma mark Rule return scopes start

@implementation TreeRewriteParser  // line 637

+/* ObjC start of ruleAttributeScope */
+#pragma mark Dynamic Rule Scopes
+/* ObjC end of ruleAttributeScope */
+#pragma mark global Attribute Scopes
+/* ObjC start globalAttributeScope */
+/* ObjC end globalAttributeScope */
+/* ObjC start actions.(actionScope).synthesize */
+/* ObjC end actions.(actionScope).synthesize */
+/* ObjC start synthesize() */
+/* AST genericParser.synthesize */
+/* AST parserProperties */
+@synthesize treeAdaptor;
+/* ObjC end synthesize() */
+
+ (void) initialize
{
#pragma mark Bitsets
@@ -149,26 +148,28 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
FOLLOW_subrule_in_rule28 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_subrule_in_rule28_data Count:(NSUInteger)1] retain];
FOLLOW_INT_in_subrule53 = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)FOLLOW_INT_in_subrule53_data Count:(NSUInteger)1] retain];

-    [ANTLRBaseRecognizer setTokenNames:[[[NSArray alloc] initWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>",
+    [ANTLRBaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"<invalid>", @"<EOR>", @"<DOWN>", @"<UP>",
@"INT", @"WS", nil] retain]];
+    [ANTLRBaseRecognizer setGrammarFileName:@"TreeRewrite.g"];
}

+ (TreeRewriteParser *)newTreeRewriteParser:(id<ANTLRTokenStream>)aStream
{
return [[TreeRewriteParser alloc] initWithTokenStream:aStream];

+
}

- (id) initWithTokenStream:(id<ANTLRTokenStream>)aStream
{
-    if ((self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:2+1] retain]]) != nil) {
-
+    self = [super initWithTokenStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:2+1] retain]];
+    if ( self != nil ) {


/* start of actions-actionScope-init */
/* start of init */
/* AST genericParser.init */
-        [self setTreeAdaptor:[[ANTLRCommonTreeAdaptor newANTLRCommonTreeAdaptor] retain]];
+        [self setTreeAdaptor:[[ANTLRCommonTreeAdaptor newTreeAdaptor] retain]];
}
return self;
}
@@ -180,8 +181,12 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000

[super dealloc];
}
-// start actions.actionScope.methods
-// start methods()
+
+/* ObjC start members */
+/* ObjC end members */
+/* ObjC start actions.(actionScope).methods */
+/* ObjC end actions.(actionScope).methods */
+/* ObjC start methods() */
/* AST genericParser.methods */
/* AST parserMethods */
- (id<ANTLRTreeAdaptor>) getTreeAdaptor
@@ -195,32 +200,35 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
treeAdaptor = aTreeAdaptor;
}
}
-// start rules
+/* ObjC end methods() */
+/* ObjC start rules */
/*
* $ANTLR start rule
* TreeRewrite.g:8:1: rule : INT subrule -> ^( subrule INT ) ;
*/
- (TreeRewriteParser_rule_return *) rule
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
TreeRewriteParser_rule_return * retval = [TreeRewriteParser_rule_return newTreeRewriteParser_rule_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
/* AST ruleLabelDefs */
ANTLRCommonToken *INT1 = nil;
-        TreeRewriteParser_subrule_return * subrule2 = nil;
-
+         TreeRewriteParser_subrule_return * subrule2 = nil ;
+

ANTLRCommonTree *INT1_tree=nil;
-        ANTLRRewriteRuleTokenStream *stream_INT =
+        ANTLRRewriteRuleTokenStream *stream_INT =
[[ANTLRRewriteRuleTokenStream newANTLRRewriteRuleTokenStream:treeAdaptor
description:@"token INT"] retain];
-        ANTLRRewriteRuleSubtreeStream *stream_subrule =
+        ANTLRRewriteRuleSubtreeStream *stream_subrule =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
description:@"rule subrule"] retain];
// TreeRewrite.g:8:5: ( INT subrule -> ^( subrule INT ) ) // ruleBlockSingleAlt
@@ -228,14 +236,16 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
{
INT1=(ANTLRCommonToken *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_rule26];
[stream_INT addElement:INT1];
-          /* element() */
+
+
+        /* ruleRef */
[self pushFollow:FOLLOW_subrule_in_rule28];
subrule2 = [self subrule];
+
[self popFollow];


-        [stream_subrule addElement:[subrule2 getTree]];  /* element() */
-         /* elements */
+        [stream_subrule addElement:[subrule2 getTree]];

// AST REWRITE
// elements: subrule, INT
@@ -244,14 +254,11 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
// token list labels:
// rule list labels:
// wildcard labels:
-         [retval setTree:root_0];
-
retval.tree = root_0;

ANTLRRewriteRuleSubtreeStream *stream_retval =
[[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
-                                                                description:@"token retval"
-                                                                    element:retval!=nil?[retval getTree]:nil] retain];
+                description:@"token retval" element:retval!=nil?[retval getTree]:nil] retain];

root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

@@ -260,19 +267,22 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
// TreeRewrite.g:8:22: ^( subrule INT )
{
ANTLRCommonTree *root_1 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];
-                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:(id<ANTLRTree>)[stream_subrule nextNode]
-                                                                         old:root_1];
+                root_1 = (ANTLRCommonTree *)[treeAdaptor becomeRoot:(id<ANTLRTree>)[stream_subrule nextNode] old:root_1];

// TODO: args:
-                [treeAdaptor addChild:[stream_INT nextNode] toTree:root_1];
+                [treeAdaptor addChild:
+                            [stream_INT nextNode]
+                 toTree:root_1];

[treeAdaptor addChild:root_1 toTree:root_0];
}

}

+
retval.tree = root_0;

+
}

/* ASTParser ruleCleanUp */
@@ -280,36 +290,44 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
// token+rule list labels
[retval setStop:[input LT:-1]];

+
[stream_INT release];
[stream_subrule release];

retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end rule */
+
/*
* $ANTLR start subrule
* TreeRewrite.g:11:1: subrule : INT ;
*/
- (TreeRewriteParser_subrule_return *) subrule
{
-    /* ruleScopeSetUp */
+    /* my ruleScopeSetUp */
+    /* Terence's stuff */

/* AST ruleDeclarations */
TreeRewriteParser_subrule_return * retval = [TreeRewriteParser_subrule_return newTreeRewriteParser_subrule_return];
[retval setStart:[input LT:1]];

+
ANTLRCommonTree *root_0 = nil;

@try {
@@ -323,13 +341,15 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
{
root_0 = (ANTLRCommonTree *)[[[treeAdaptor class] newEmptyTree] retain];

+
/* ASTParser tokenRef */
INT3=(ANTLRCommonToken *)[self match:input TokenType:INT Follow:FOLLOW_INT_in_subrule53];
INT3_tree = /* ASTParser createNodeFromToken */
-        (ANTLRCommonTree *)[[treeAdaptor createTree:INT3] retain];
+        (ANTLRCommonTree *)[[treeAdaptor create:INT3] retain]
+        ;
[treeAdaptor addChild:INT3_tree  toTree:root_0];
-          /* element() */
-         /* elements */
+
+
}

/* ASTParser ruleCleanUp */
@@ -338,25 +358,26 @@ static const unsigned long long FOLLOW_INT_in_subrule53_data[] = { 0x00000000000
[retval setStop:[input LT:-1]];


+
retval.tree = (ANTLRCommonTree *)[treeAdaptor rulePostProcessing:root_0];
-            [treeAdaptor setTokenBoundaries:retval.tree From:retval.startToken To:retval.stopToken];
+            [treeAdaptor setTokenBoundaries:retval.tree From:retval.start To:retval.stopToken];

}
@catch (ANTLRRecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
/* ASTParser rule.setErrorReturnValue */
-        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.startToken To:[input LT:-1] Exception:re];
+        retval.tree = (ANTLRCommonTree *)[treeAdaptor errorNode:input From:retval.start To:[input LT:-1] Exception:re];
+
+    }
+
+    @finally {
+        /* Terence's stuff */

-    }    @finally {
}
return retval;
}
/* $ANTLR end subrule */
+/* ObjC end rules */

@end /* end of TreeRewriteParser implementation line 692 */
-
-
-/* End of code
- * =============================================================================
- */

