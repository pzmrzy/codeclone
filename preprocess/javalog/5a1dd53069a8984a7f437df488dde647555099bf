commit 5a1dd53069a8984a7f437df488dde647555099bf
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Wed Apr 13 13:29:51 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Wed Apr 13 13:29:51 2011 -0800

(C# 3) Clean up some whitespace in generated code.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8198]

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/AST.stg
index 7faa975..89fa83d 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/AST.stg
@@ -49,9 +49,7 @@ parserCtorBody() ::= <<
<super.parserCtorBody()>
<treeAdaptorType()> treeAdaptor = default(<treeAdaptorType()>);
CreateTreeAdaptor(ref treeAdaptor);
-
TreeAdaptor = treeAdaptor<if(!actions.(actionScope).treeAdaptorType)> ?? new CommonTreeAdaptor()<endif>;
-
>>

/** Add an adaptor property that knows how to build trees */
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
index 0cb37ec..074bc2c 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
@@ -38,16 +38,6 @@ csharpVisibilityMap ::= [
default:"private"
]

-// System.Boolean.ToString() returns "True" and "False", but the proper C# literals are "true" and "false"
-// The Java version of Boolean returns "true" and "false", so they map to themselves here.
-booleanLiteral ::= [
-	"True":"true",
-	"False":"false",
-	"true":"true",
-	"false":"false",
-	default:"false"
-]
-
/** The overall file structure of a recognizer; stores methods for rules
*  and cyclic DFAs plus support code.
*/
@@ -285,13 +275,17 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
<endif>
<tokens:{it|public const int <it.name; format="id">=<it.type>;}; separator="\n">

+<if(grammar.delegates)>
// delegates
<grammar.delegates:
{g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
// delegators
<grammar.delegators:
{g|private <g.recognizerName> <g:delegateName()>;}; separator="\n">
<last(grammar.delegators):{g|private <g.recognizerName> gParent;}>
+<endif>

<scopes:{it|<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>
<@members()>
@@ -338,8 +332,7 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,
#region Follow sets
private static class Follow
{
-		<bitsets:{it|<bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>},
-							words64=it.bits)>}>
+		<bitsets:{it|<bitset(name={_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>}; separator="\n">
}
#endregion Follow sets
<endif>
@@ -348,19 +341,24 @@ genericParser(grammar, name, scopes, tokens, tokenNames, rules, numRules,

@genericParser.members() ::= <<
<! WARNING. bug in ST: this is cut-n-paste into Dbg.stg !>
-<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>( <inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}> )
-	: this( input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}> )
+<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
+	: this(input, new RecognizerSharedState()<grammar.delegators:{g|, <g:delegateName()>}>)
{
}
<actions.(actionScope).ctorModifier; null="public"> <grammar.recognizerName>(<inputStreamType> input, RecognizerSharedState state<grammar.delegators:{g|, <g.recognizerName> <g:delegateName()>}>)
: base(input, state)
{
<parserCtorBody()>
+<if(grammar.directDelegates)>
<grammar.directDelegates:
{g|<g:delegateName()> = new <g.recognizerName>(input, state<trunc(g.delegators):{p|, <p:delegateName()>}>, this);}; separator="\n">
+<endif>
+<if(grammar.indirectDelegates)>
<grammar.indirectDelegates:{g | <g:delegateName()> = <g.delegator:delegateName()>.<g:delegateName()>;}; separator="\n">
+<endif>
+<if(grammar.delegators)>
<last(grammar.delegators):{g|gParent = <g:delegateName()>;}>
-
+<endif>
OnCreated();
}
>>
@@ -719,7 +717,7 @@ int alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
try { DebugEnterSubRule(<decisionNumber>);
-try { DebugEnterDecision(<decisionNumber>, false<!<booleanLiteral.(decision.dfa.hasSynPred)>!>);
+try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
<decision>
} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
@@ -738,7 +736,7 @@ ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK
int alt<decisionNumber>=<maxAlt>;
<decls>
<@predecision()>
-try { DebugEnterDecision(<decisionNumber>, false<!<booleanLiteral.(decision.dfa.hasSynPred)>!>);
+try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
<decision>
} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
@@ -778,7 +776,7 @@ while (true)
{
int alt<decisionNumber>=<maxAlt>;
<@predecision()>
-	try { DebugEnterDecision(<decisionNumber>, false<!<booleanLiteral.(decision.dfa.hasSynPred)>!>);
+	try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
<decision>
} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>
@@ -816,7 +814,7 @@ while (true)
{
int alt<decisionNumber>=<maxAlt>;
<@predecision()>
-	try { DebugEnterDecision(<decisionNumber>, false<!<booleanLiteral.(decision.dfa.hasSynPred)>!>);
+	try { DebugEnterDecision(<decisionNumber>, false<!<decision.dfa.hasSynPred>!>);
<decision>
} finally { DebugExitDecision(<decisionNumber>); }
<@postdecision()>

