commit 3a90f31398470c1c172eedd740746b8899cd78e3
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Tue Mar 25 06:30:23 2014 -0500
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Tue Mar 25 06:44:04 2014 -0500

Fix many javadoc errors and warnings

diff --git a/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java b/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java
index bf2c3c6..5a315da 100644
--- a/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java
+++ b/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java
@@ -56,7 +56,7 @@ public class Antlr3ErrorLog implements ANTLRErrorListener {

/**
* Sends an informational message to the Maven log sink.
-     * @param s The message to send to Maven
+     * @param message The message to send to Maven
*/
public void info(String message) {
log.info(message);
diff --git a/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3Mojo.java b/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3Mojo.java
index a17d96b..6c18c55 100644
--- a/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3Mojo.java
+++ b/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3Mojo.java
@@ -167,10 +167,10 @@ public class Antlr3Mojo
* the generate phase of the plugin. Note that the plugin is smart enough to
* realize that imported grammars should be included but not acted upon
* directly by the ANTLR Tool.
-     * <p/>
+     * <p>
* A set of Ant-like inclusion patterns used to select files from the source
* directory for processing. By default, the pattern <code>**&#47;*.g</code>
-     * is used to select grammar files.
+     * is used to select grammar files.</p>
*
* @parameter
*/
@@ -403,8 +403,6 @@ public class Antlr3Mojo
*
* @param sourceDirectory
* @param outputDirectory
-     * @throws TokenStreamException
-     * @throws RecognitionException
* @throws IOException
* @throws InclusionScanException
*/
diff --git a/gunit-maven-plugin/src/main/java/org/antlr/mojo/antlr3/GUnitExecuteMojo.java b/gunit-maven-plugin/src/main/java/org/antlr/mojo/antlr3/GUnitExecuteMojo.java
index fbee5f7..a7e2317 100644
--- a/gunit-maven-plugin/src/main/java/org/antlr/mojo/antlr3/GUnitExecuteMojo.java
+++ b/gunit-maven-plugin/src/main/java/org/antlr/mojo/antlr3/GUnitExecuteMojo.java
@@ -104,8 +104,8 @@ public class GUnitExecuteMojo extends AbstractMojo {

/**
* Should gUnit functionality be completely by-passed?
-	 * <p/>
-	 * By default we skip gUnit tests if the user requested that all testing be skipped using 'maven.test.skip'
+	 * <p>
+	 * By default we skip gUnit tests if the user requested that all testing be skipped using 'maven.test.skip'</p>
*
* @parameter expression="${maven.test.skip}"
*/
diff --git a/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java b/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java
index dcfdfb3..dcad501 100644
--- a/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java
+++ b/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java
@@ -31,7 +31,7 @@ import java.io.*;
import java.util.HashMap;

/**
- * Class loader for parser & lexer generated by antlr.
+ * Class loader for parser &amp; lexer generated by antlr.
* @author Shaoting
*/
public class ParserLoader extends ClassLoader {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java b/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
index fc8e7d4..bdba790 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
@@ -476,7 +476,7 @@ public abstract class BaseRecognizer {
*  given the current call chain.  Contrast this with the
*  definition of plain FOLLOW for rule r:
*
-	 *   FOLLOW(r)={x | S=>*alpha r beta in G and x in FIRST(beta)}
+	 *   FOLLOW(r)={x | S=&gt;*alpha r beta in G and x in FIRST(beta)}
*
*  where x in T* and alpha, beta in V*; T is set of terminals and
*  V is the set of terminals and nonterminals.  In other words,
@@ -500,16 +500,16 @@ public abstract class BaseRecognizer {
*  FOLLOW sets are precisely what could follow a rule reference.
*  For input input "i=(3);", here is the derivation:
*
-	 *  stat => ID '=' expr ';'
-	 *       => ID '=' atom ('+' atom)* ';'
-	 *       => ID '=' '(' expr ')' ('+' atom)* ';'
-	 *       => ID '=' '(' atom ')' ('+' atom)* ';'
-	 *       => ID '=' '(' INT ')' ('+' atom)* ';'
-	 *       => ID '=' '(' INT ')' ';'
+	 *  stat =&gt; ID '=' expr ';'
+	 *       =&gt; ID '=' atom ('+' atom)* ';'
+	 *       =&gt; ID '=' '(' expr ')' ('+' atom)* ';'
+	 *       =&gt; ID '=' '(' atom ')' ('+' atom)* ';'
+	 *       =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
+	 *       =&gt; ID '=' '(' INT ')' ';'
*
*  At the "3" token, you'd have a call chain of
*
-	 *    stat -> expr -> atom -> expr -> atom
+	 *    stat &rarr; expr &rarr; atom &rarr; expr &rarr; atom
*
*  What can follow that specific nested ref to atom?  Exactly ')'
*  as you can see by looking at the derivation of this specific
@@ -573,12 +573,12 @@ public abstract class BaseRecognizer {
*  ')'.  When the parser returns from the nested call to expr, it
*  will have call chain:
*
-	 *    stat -> expr -> atom
+	 *    stat &rarr; expr &rarr; atom
*
*  and it will be trying to match the ')' at this point in the
*  derivation:
*
-	 *       => ID '=' '(' INT ')' ('+' atom)* ';'
+	 *       =&gt; ID '=' '(' INT ')' ('+' atom)* ';'
*                          ^
*  match() will see that ';' doesn't match ')' and report a
*  mismatched token error.  To recover, it sees that LA(1)==';'
@@ -702,7 +702,7 @@ public abstract class BaseRecognizer {
state.following[++state._fsp] = fset;
}

-	/** Return List<String> of the rules in your parser instance
+	/** Return List&lt;String&gt; of the rules in your parser instance
*  leading up to a call to this method.  You could override if
*  you want more details such as the file/line info of where
*  in the parser java code a rule is invoked.
@@ -769,7 +769,7 @@ public abstract class BaseRecognizer {
public abstract String getSourceName();

/** A convenience method for use most often with template rewrites.
-	 *  Convert a List<Token> to List<String>
+	 *  Convert a List&lt;Token&gt; to List&lt;String&gt;
*/
public List<String> toStrings(List<? extends Token> tokens) {
if ( tokens==null ) return null;
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java b/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java
index beffc75..90d218b 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java
@@ -36,8 +36,8 @@ import java.util.NoSuchElementException;
*  lexer. Useful when the parser or lexer has to set context/mode info before
*  proper lexing of future tokens. The ST template parser needs this,
*  for example, because it has to constantly flip back and forth between
- *  inside/output templates. E.g., <names:{hi, <it>}> has to parse names
- *  as part of an expression but "hi, <it>" as a nested template.
+ *  inside/output templates. E.g., {@code <names:{hi, <it>}>} has to parse names
+ *  as part of an expression but {@code "hi, <it>"} as a nested template.
*
*  You can't use this stream if you pass whitespace or other off-channel
*  tokens to the parser. The stream can't ignore off-channel tokens.
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/CommonToken.java b/runtime/Java/src/main/java/org/antlr/runtime/CommonToken.java
index 325f63a..2647fe8 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/CommonToken.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/CommonToken.java
@@ -42,7 +42,7 @@ public class CommonToken implements Token, Serializable {
*/
protected String text;

-	/** What token number is this from 0..n-1 tokens; < 0 implies invalid index */
+	/** What token number is this from 0..n-1 tokens; &lt; 0 implies invalid index */
protected int index = -1;

/** The char position into the input buffer where this token starts */
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java b/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java
index 176f2da..2c84969 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java
@@ -44,10 +44,10 @@ public class LegacyCommonTokenStream implements TokenStream {
*/
protected List<Token> tokens;

-	/** Map<tokentype, channel> to override some Tokens' channel numbers */
+	/** Map&lt;tokentype, channel&gt; to override some Tokens' channel numbers */
protected Map<Integer, Integer> channelOverrideMap;

-	/** Set<tokentype>; discard any tokens with this type */
+	/** Set&lt;tokentype&gt;; discard any tokens with this type */
protected Set<Integer> discardSet;

/** Skip tokens on any channel but this one; this is how we skip whitespace... */
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/RecognizerSharedState.java b/runtime/Java/src/main/java/org/antlr/runtime/RecognizerSharedState.java
index f78ec41..c6cd1a4 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/RecognizerSharedState.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/RecognizerSharedState.java
@@ -67,11 +67,11 @@ public class RecognizerSharedState {
public int syntaxErrors = 0;

/** If 0, no backtracking is going on.  Safe to exec actions etc...
-	 *  If >0 then it's the level of backtracking.
+	 *  If &gt;0 then it's the level of backtracking.
*/
public int backtracking = 0;

-	/** An array[size num rules] of Map<Integer,Integer> that tracks
+	/** An array[size num rules] of Map&lt;Integer,Integer&gt; that tracks
*  the stop token index for each rule.  ruleMemo[ruleIndex] is
*  the memoization table for ruleIndex.  For key ruleStartIndex, you
*  get back the stop token for associated rule or MEMO_RULE_FAILED.
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java b/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java
index 7a73adc..f444210 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java
@@ -161,11 +161,11 @@ public class TokenRewriteStream extends CommonTokenStream {

/** You may have multiple, named streams of rewrite operations.
*  I'm calling these things "programs."
-	 *  Maps String (name) -> rewrite (List)
+	 *  Maps String (name) &rarr; rewrite (List)
*/
protected Map<String, List<RewriteOperation>> programs = null;

-	/** Map String (program name) -> Integer index */
+	/** Map String (program name) &rarr; Integer index */
protected Map<String, Integer> lastRewriteTokenIndexes = null;

public TokenRewriteStream() {
@@ -448,7 +448,7 @@ public class TokenRewriteStream extends CommonTokenStream {
* 		3. throw exception if index in same range as previous replace
*
*  Don't actually delete; make op null in list. Easier to walk list.
-	 *  Later we can throw as we add to index -> op map.
+	 *  Later we can throw as we add to index &rarr; op map.
*
*  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
*  inserted stuff would be before the replace range.  But, if you
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java b/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java
index 7d419ae..94b25d4 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java
@@ -30,8 +30,8 @@ package org.antlr.runtime;
/** A stream of tokens accessing tokens from a TokenSource */
public interface TokenStream extends IntStream {
/** Get Token at current input pointer + i ahead where i=1 is next Token.
-	 *  i<0 indicates tokens in the past.  So -1 is previous token and -2 is
-	 *  two tokens ago. LT(0) is undefined.  For i>=n, return Token.EOFToken.
+	 *  i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is
+	 *  two tokens ago. LT(0) is undefined.  For i&gt;=n, return Token.EOFToken.
*  Return null for LT(0) and any index that results in an absolute address
*  that is negative.
*/
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java b/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java
index 14260be..4b4a1c5 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java
@@ -176,7 +176,7 @@ public interface DebugEventListener {
*		enterAlt1
*		location 7 5
*		LT(1)
-	 *		consumeToken [c/<4>,1:0]
+	 *		consumeToken [c/&lt;4&gt;,1:0]
*		location 7 7
*		enterSubRule 2
*		enter decision 2
@@ -187,7 +187,7 @@ public interface DebugEventListener {
*		exitSubRule 2
*		beginResync
*		LT(1)
-	 *		consumeToken [c/<4>,1:1]
+	 *		consumeToken [c/&lt;4&gt;,1:1]
*		LT(1)
*		endResync
*		LT(-1)
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugTreeAdaptor.java b/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugTreeAdaptor.java
index 3bc2d82..fc5f77f 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugTreeAdaptor.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugTreeAdaptor.java
@@ -38,10 +38,10 @@ import org.antlr.runtime.tree.TreeAdaptor;
*  in generated rules.  Debugging events are triggered *after* invoking
*  tree adaptor routines.
*
- *  Trees created with actions in rewrite actions like "-> ^(ADD {foo} {bar})"
+ *  Trees created with actions in rewrite actions like "-&gt; ^(ADD {foo} {bar})"
*  cannot be tracked as they might not use the adaptor to create foo, bar.
*  The debug listener has to deal with tree node IDs for which it did
- *  not see a createNode event.  A single <unknown> node is sufficient even
+ *  not see a createNode event.  A single &lt;unknown&gt; node is sufficient even
*  if it represents a whole tree.
*/
public class DebugTreeAdaptor implements TreeAdaptor {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java b/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java
index 28e80bc..d76e28f 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java
@@ -281,7 +281,7 @@ public class Profiler extends BlankDebugEventListener {
d.decision.ruleName+"-"+d.decision.decision+" start index "+d.startIndex);
}

-	/** The parser is in a decision if the decision depth > 0.  This
+	/** The parser is in a decision if the decision depth &gt; 0.  This
*  works for backtracking also, which can have nested decisions.
*/
public boolean inDecision() {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java b/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java
index af597fd..02c92e6 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java
@@ -100,7 +100,7 @@ public abstract class LookaheadStream<T> extends FastQueue<T> {

/** Make sure we have 'need' elements from current position p. Last valid
*  p index is data.size()-1.  p+need-1 is the data index 'need' elements
-     *  ahead.  If we need 1 element, (p+1-1)==p must be < data.size().
+     *  ahead.  If we need 1 element, (p+1-1)==p must be &lt; data.size().
*/
protected void syncAhead(int need) {
int n = (p+need-1) - data.size() + 1; // how many more elements we need?
@@ -160,11 +160,11 @@ public abstract class LookaheadStream<T> extends FastQueue<T> {
/**
* Seek to a 0-indexed absolute token index. Normally used to seek backwards
* in the buffer. Does not force loading of nodes.
-	 * <p/>
+	 * <p>
* To preserve backward compatibility, this method allows seeking past the
* end of the currently buffered data. In this case, the input pointer will
* be moved but the data will only actually be loaded upon the next call to
-	 * {@link #consume} or {@link #LT} for {@code k>0}.
+	 * {@link #consume} or {@link #LT} for {@code k>0}.</p>
*
* @throws IllegalArgumentException if {@code index} is less than 0
* @throws UnsupportedOperationException if {@code index} lies before the
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java
index 9bd079d..486682e 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java
@@ -289,7 +289,7 @@ public abstract class BaseTreeAdaptor implements TreeAdaptor {
*  an actual real input token.  Typically this is for converting '{'
*  tokens to BLOCK etc...  You'll see
*
-	 *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
+	 *    r : lc='{' ID+ '}' -&gt; ^(BLOCK[$lc] ID+) ;
*
*  If you care what the token payload objects' type is, you should
*  override this method and any other createToken variant.
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTree.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTree.java
index 6a258d6..82353c8 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTree.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTree.java
@@ -143,7 +143,7 @@ public class CommonTree extends BaseTree {

/** For every node in this subtree, make sure it's start/stop token's
*  are set.  Walk depth first, visit bottom up.  Only updates nodes
-     *  with at least one token index < 0.
+     *  with at least one token index &lt; 0.
*/
public void setUnknownTokenBoundaries() {
if ( children==null ) {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java
index 417a554..c4f1661 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java
@@ -80,7 +80,7 @@ public class CommonTreeAdaptor extends BaseTreeAdaptor {
*  an actual real input token.  Typically this is for converting '{'
*  tokens to BLOCK etc...  You'll see
*
-	 *    r : lc='{' ID+ '}' -> ^(BLOCK[$lc] ID+) ;
+	 *    r : lc='{' ID+ '}' -&gt; ^(BLOCK[$lc] ID+) ;
*
*  If you care what the token payload objects' type is, you should
*  override this method and any other createToken variant.
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
index 5188f68..9d2e6f7 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java
@@ -108,10 +108,10 @@ public class DOTTreeGenerator {
*   node [shape=plaintext, fixedsize=true, fontsize=11, fontname="Courier",
*         width=.4, height=.2];
*   edge [arrowsize=.7]
-	 *   "+"->3
-	 *   "+"->"*"
-	 *   "*"->4
-	 *   "*"->5
+	 *   "+"-&gt;3
+	 *   "+"-&gt;"*"
+	 *   "*"-&gt;4
+	 *   "*"-&gt;5
* }
*
* Return the ST not a string in case people want to alter.
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java
index cba0d71..bcbaeae 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java
@@ -31,7 +31,7 @@ import java.util.ArrayList;
import java.util.List;

/** A generic list of elements tracked in an alternative to be used in
- *  a -> rewrite rule.  We need to subclass to fill in the next() method,
+ *  a -&gt; rewrite rule.  We need to subclass to fill in the next() method,
*  which returns either an AST node wrapped around a token payload or
*  an existing subtree.
*
@@ -148,8 +148,8 @@ public abstract class RewriteRuleElementStream {

/** do the work of getting the next element, making sure that it's
*  a tree node or subtree.  Deal with the optimization of single-
-	 *  element list versus list of size > 1.  Throw an exception
-	 *  if the stream is empty or we're out of elements and size>1.
+	 *  element list versus list of size &gt; 1.  Throw an exception
+	 *  if the stream is empty or we're out of elements and size&gt;1.
*  protected so you can override in a subclass if necessary.
*/
protected Object _next() {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleNodeStream.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleNodeStream.java
index 1bfdab4..e41b745 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleNodeStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleNodeStream.java
@@ -29,7 +29,7 @@ package org.antlr.runtime.tree;

import java.util.List;

-/** Queues up nodes matched on left side of -> in a tree parser. This is
+/** Queues up nodes matched on left side of -&gt; in a tree parser. This is
*  the analog of RewriteRuleTokenStream for normal parsers.
*/
public class RewriteRuleNodeStream extends RewriteRuleElementStream {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java
index bde9ef5..4e8cb55 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java
@@ -46,10 +46,10 @@ public interface TreeNodeStream extends IntStream {
* provide results for {@code k < -1}. {@code LT(0)} is undefined. For
* {@code k<=n}, return {@code null}. Return {@code null} for {@code LT(0)}
* and any index that results in an absolute address that is negative.
-	 * <p/>
+	 * <p>
* This is analogous to {@link TokenStream#LT}, but this returns a tree node
* instead of a {@link Token}. Makes code generation identical for both
-	 * parser and tree grammars.
+	 * parser and tree grammars.</p>
*/
public Object LT(int k);

@@ -104,10 +104,10 @@ public interface TreeNodeStream extends IntStream {
* it is walking the tree and might need to know you are monkeying with the
* underlying tree. Also, it might be able to modify the node stream to
* avoid restreaming for future phases.
-	 * <p/>
+	 * <p>
* If {@code parent} is {@code null}, don't do anything; must be at root of
* overall tree. Can't replace whatever points to the parent externally. Do
-	 * nothing.
+	 * nothing.</p>
*/
public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t);
}
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java
index 27e72f2..a89112d 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java
@@ -41,7 +41,7 @@ import java.util.Map;
*
*  In order to create nodes and navigate, this class needs a TreeAdaptor.
*
- *  This class can build a token type -> node index for repeated use or for
+ *  This class can build a token type &rarr; node index for repeated use or for
*  iterating over the various nodes with a particular type.
*
*  This class works in conjunction with the TreeAdaptor rather than moving
@@ -140,7 +140,7 @@ public class TreeWizard {
this(new CommonTreeAdaptor(), tokenNames);
}

-	/** Compute a Map<String, Integer> that is an inverted index of
+	/** Compute a Map&lt;String, Integer&gt; that is an inverted index of
*  tokenNames (which maps int token types to names).
*/
public Map<String, Integer> computeTokenTypes(String[] tokenNames) {
@@ -169,7 +169,7 @@ public class TreeWizard {

/** Walk the entire tree and make a node name to nodes mapping.
*  For now, use recursion but later nonrecursive version may be
-	 *  more efficient.  Returns Map<Integer, List> where the List is
+	 *  more efficient.  Returns Map&lt;Integer, List&gt; where the List is
*  of your AST node type.  The Integer is the token type of the node.
*
*  TODO: save this index so that find and visit are faster
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLR.g b/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLR.g
index 1ab7ff6..a501458 100644
--- a/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLR.g
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/ANTLR.g
@@ -339,7 +339,7 @@ protected GrammarAST createBlockFromDupAlt(GrammarAST alt) {
}

/** Rewrite alt to have a synpred as first element;
- *  (xxx)=>xxx
+ *  (xxx)=&gt;xxx
*  but only if they didn't specify one manually.
*/
protected void prefixWithSynPred( GrammarAST alt ) {
diff --git a/tool/src/main/antlr3/org/antlr/grammar/v3/AssignTokenTypesWalker.g b/tool/src/main/antlr3/org/antlr/grammar/v3/AssignTokenTypesWalker.g
index 276a163..15ed503 100644
--- a/tool/src/main/antlr3/org/antlr/grammar/v3/AssignTokenTypesWalker.g
+++ b/tool/src/main/antlr3/org/antlr/grammar/v3/AssignTokenTypesWalker.g
@@ -68,15 +68,15 @@
*  1. Finds a list of all literals and token names.
*  2. Finds a list of all token name rule definitions;
*     no token rules implies pure parser.
- *  3. Finds a list of all simple token rule defs of form "<NAME> : <literal>;"
+ *  3. Finds a list of all simple token rule defs of form "&lt;NAME&gt; : &lt;literal&gt;;"
*     and aliases them.
*  4. Walks token names table and assign types to any unassigned
*  5. Walks aliases and assign types to referenced literals
*  6. Walks literals, assigning types if untyped
*  4. Informs the Grammar object of the type definitions such as:
- *     g.defineToken(<charliteral>, ttype);
- *     g.defineToken(<stringliteral>, ttype);
- *     g.defineToken(<tokenID>, ttype);
+ *     g.defineToken(&lt;charliteral&gt;, ttype);
+ *     g.defineToken(&lt;stringliteral&gt;, ttype);
+ *     g.defineToken(&lt;tokenID&gt;, ttype);
*     where some of the ttype values will be the same for aliases tokens.
*/
tree grammar AssignTokenTypesWalker;
diff --git a/tool/src/main/java/org/antlr/Tool.java b/tool/src/main/java/org/antlr/Tool.java
index a096b36..0d8709b 100644
--- a/tool/src/main/java/org/antlr/Tool.java
+++ b/tool/src/main/java/org/antlr/Tool.java
@@ -88,7 +88,7 @@ public class Tool {
/**
* A list of dependency generators that are accumulated aaaas (and if) the
* tool is required to sort the provided grammars into build dependency order.
-    protected Map<String, BuildDependencyGenerator> buildDependencyGenerators;
+    protected Map&lt;String, BuildDependencyGenerator&gt; buildDependencyGenerators;
*/

public static void main(String[] args) {
diff --git a/tool/src/main/java/org/antlr/analysis/DFA.java b/tool/src/main/java/org/antlr/analysis/DFA.java
index 04def78..5cc1556 100644
--- a/tool/src/main/java/org/antlr/analysis/DFA.java
+++ b/tool/src/main/java/org/antlr/analysis/DFA.java
@@ -78,7 +78,7 @@ public class DFA {

/** A set of all uniquely-numbered DFA states.  Maps hash of DFAState
*  to the actual DFAState object.  We use this to detect
-     *  existing DFA states.  Map<DFAState,DFAState>.  Use Map so
+     *  existing DFA states.  Map&lt;DFAState,DFAState&gt;.  Use Map so
*  we can get old state back (Set only allows you to see if it's there).
*  Not used during fixed k lookahead as it's a waste to fill it with
*  a dup of states array.
@@ -88,7 +88,7 @@ public class DFA {
/** Maps the state number to the actual DFAState.  Use a Vector as it
*  grows automatically when I set the ith element.  This contains all
*  states, but the states are not unique.  s3 might be same as s1 so
-	 *  s3 -> s1 in this table.  This is how cycles occur.  If fixed k,
+	 *  s3 &rarr; s1 in this table.  This is how cycles occur.  If fixed k,
*  then these states will all be unique as states[i] always points
*  at state i when no cycles exist.
*
@@ -146,7 +146,7 @@ public class DFA {
protected DFAState[] altToAcceptState;

/** Track whether an alt discovers recursion for each alt during
-	 *  NFA to DFA conversion; >1 alt with recursion implies nonregular.
+	 *  NFA to DFA conversion; &gt;1 alt with recursion implies nonregular.
*/
public IntSet recursiveAltSet = new IntervalSet();

@@ -212,7 +212,7 @@ public class DFA {
public Vector<Integer> max;
public Vector<Integer> special;
public Vector<Vector<Integer>> transition;
-	/** just the Vector<Integer> indicating which unique edge table is at
+	/** just the Vector&lt;Integer&gt; indicating which unique edge table is at
*  position i.
*/
public Vector<Integer> transitionEdgeTables; // not used by java yet
@@ -345,7 +345,7 @@ public class DFA {
*  that GIF files use.  Transition tables are heavily compressed by
*  this technique.  I got the idea from JFlex http://jflex.de/
*
-	 *  Return List<String> where each string is either \xyz for 8bit char
+	 *  Return List&lt;String&gt; where each string is either \xyz for 8bit char
*  and \uFFFF for 16bit.  Hideous and specific to Java, but it is the
*  only target bad enough to need it.
*/
@@ -802,16 +802,16 @@ public class DFA {
/** Count all disambiguating syn preds (ignore synpred tests
*  for gated edges, which occur for nonambig input sequences).
*  E.g.,
-	 *  x  : (X)=> (X|Y)\n" +
+	 *  x  : (X)=&gt; (X|Y)\n" +
*     | X\n" +
*     ;
*
*  gives
*
-	 * .s0-X->.s1
-	 * .s0-Y&&{synpred1_t}?->:s2=>1
-	 * .s1-{synpred1_t}?->:s2=>1
-	 * .s1-{true}?->:s3=>2
+	 * .s0-X-&gt;.s1
+	 * .s0-Y&amp;&amp;{synpred1_t}?-&gt;:s2=&gt;1
+	 * .s1-{synpred1_t}?-&gt;:s2=&gt;1
+	 * .s1-{true}?-&gt;:s3=&gt;2
*/
public boolean hasSynPred() {
boolean has = _hasSynPred(startState, new HashSet<DFAState>());
diff --git a/tool/src/main/java/org/antlr/analysis/DFAOptimizer.java b/tool/src/main/java/org/antlr/analysis/DFAOptimizer.java
index 494e54d..ab7fba9 100644
--- a/tool/src/main/java/org/antlr/analysis/DFAOptimizer.java
+++ b/tool/src/main/java/org/antlr/analysis/DFAOptimizer.java
@@ -41,7 +41,7 @@ import java.util.Set;
*  loop exit branches are unreachable if you prune exit branches
*  during DFA construction and before determinism checks.
*
- *  In general, ANTLR's NFA->DFA->codegen pipeline seems very robust
+ *  In general, ANTLR's NFA&rarr;DFA&rarr;codegen pipeline seems very robust
*  to me which I attribute to a uniform and consistent set of data
*  structures.  Regardless of what I want to "say"/implement, I do so
*  within the confines of, for example, a DFA.  The code generator
@@ -99,7 +99,7 @@ import java.util.Set;
*  state.  This is a waste and messes up my code generation. ;)  If
*  Tokens rule DFA goes
*
- * 		s0 -'='-> s3 -EOT-> s5 (accept)
+ * 		s0 -'='-&gt; s3 -EOT-&gt; s5 (accept)
*
*  then s5 should be pruned and s3 should be made an accept.  Do NOT do this
*  for keyword versus ID as the state with EOT edge emanating from it will
diff --git a/tool/src/main/java/org/antlr/analysis/DFAState.java b/tool/src/main/java/org/antlr/analysis/DFAState.java
index 5610b18..541d81a 100644
--- a/tool/src/main/java/org/antlr/analysis/DFAState.java
+++ b/tool/src/main/java/org/antlr/analysis/DFAState.java
@@ -42,7 +42,7 @@ import java.util.*;
*  input a1a2..an, the DFA is in a state that represents the
*  subset T of the states of the NFA that are reachable from the
*  NFA's start state along some path labeled a1a2..an."
- *  In conventional NFA->DFA conversion, therefore, the subset T
+ *  In conventional NFA&rarr;DFA conversion, therefore, the subset T
*  would be a bitset representing the set of states the
*  NFA could be in.  We need to track the alt predicted by each
*  state as well, however.  More importantly, we need to maintain
@@ -84,7 +84,7 @@ public class DFAState extends State {
*/
protected int k;

-    /** The NFA->DFA algorithm may terminate leaving some states
+    /** The NFA&rarr;DFA algorithm may terminate leaving some states
*  without a path to an accept state, implying that upon certain
*  input, the decision is not deterministic--no decision about
*  predicting a unique alternative can be made.  Recall that an
@@ -205,7 +205,7 @@ public class DFAState extends State {
}

/** Add an NFA configuration to this DFA node.  Add uniquely
-     *  an NFA state/alt/syntactic&semantic context (chain of invoking state(s)
+     *  an NFA state/alt/syntactic&amp;semantic context (chain of invoking state(s)
*  and semantic predicate contexts).
*
*  I don't see how there could be two configurations with same
@@ -294,7 +294,7 @@ public class DFAState extends State {
*
*  The idea for adding a new set, t, is to look for overlap with the
*  elements of existing list s.  Upon overlap, replace
-     *  existing set s[i] with two new disjoint sets, s[i]-t and s[i]&t.
+     *  existing set s[i] with two new disjoint sets, s[i]-t and s[i]&amp;t.
*  (if s[i]-t is nil, don't add).  The remainder is t-s[i], which is
*  what you want to add to the set minus what was already there.  The
*  remainder must then be compared against the i+1..n elements in s
@@ -691,7 +691,7 @@ public class DFAState extends State {
*  predicate implies we should evaluate the predicate to true. This
*  means the whole edge has to be ungated. Consider:
*
-	 *	 X : ('a' | {p}?=> 'a')
+	 *	 X : ('a' | {p}?=&gt; 'a')
*	   | 'a' 'b'
*	   ;
*
@@ -701,7 +701,7 @@ public class DFAState extends State {
*  can't test p.  You can get to the same place with and w/o the context.
*  Therefore, it is never ok to test p in this situation.
*
-	 *  TODO: cache this as it's called a lot; or at least set bit if >1 present in state
+	 *  TODO: cache this as it's called a lot; or at least set bit if &gt;1 present in state
*/
public SemanticContext getGatedPredicatesInNFAConfigurations() {
SemanticContext unionOfPredicatesFromAllAlts = null;
diff --git a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
index eaad8f6..625728b 100644
--- a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
+++ b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
@@ -40,7 +40,7 @@ import java.util.*;
/** Collection of information about what is wrong with a decision as
*  discovered while building the DFA predictor.
*
- *  The information is collected during NFA->DFA conversion and, while
+ *  The information is collected during NFA&rarr;DFA conversion and, while
*  some of this is available elsewhere, it is nice to have it all tracked
*  in one spot so a great error message can be easily had.  I also like
*  the fact that this object tracks it all for later perusing to make an
@@ -118,7 +118,7 @@ public class DecisionProbe {
*/
protected Set<Integer> altsWithProblem = new HashSet<Integer>();

-	/** If decision with > 1 alt has recursion in > 1 alt, it's (likely) nonregular
+	/** If decision with &gt; 1 alt has recursion in &gt; 1 alt, it's (likely) nonregular
*  lookahead.  The decision cannot be made with a DFA.
*  the alts are stored in altsWithProblem.
*/
@@ -156,7 +156,7 @@ public class DecisionProbe {
*  an input sequence.  Tracks the input position
*  we were at the last time at this node.  If same input position, then
*  we'd have reached same state without consuming input...probably an
-	 *  infinite loop.  Stop.  Set<String>.  The strings look like
+	 *  infinite loop.  Stop.  Set&lt;String&gt;.  The strings look like
*  stateNumber_labelIndex.
*/
protected Set<String> statesVisitedAtInputDepth;
@@ -219,7 +219,7 @@ public class DecisionProbe {
return stateToRecursionOverflowConfigurationsMap.size()>0;
}

-	/** Found recursion in > 1 alt */
+	/** Found recursion in &gt; 1 alt */
public boolean isNonLLStarDecision() {
return nonLLStarDecision;
}
@@ -291,7 +291,7 @@ public class DecisionProbe {
stateToRecursionOverflowConfigurationsMap.remove(stateI);
}

-	/** Return a List<Label> indicating an input sequence that can be matched
+	/** Return a List&lt;Label&gt; indicating an input sequence that can be matched
*  from the start state of the DFA to the targetState (which is known
*  to have a problem).
*/
@@ -309,7 +309,7 @@ public class DecisionProbe {
return labels;
}

-	/** Given List<Label>, return a String with a useful representation
+	/** Given List&lt;Label&gt;, return a String with a useful representation
*  of the associated input string.  One could show something different
*  for lexers and parsers, for example.
*/
@@ -334,13 +334,13 @@ public class DecisionProbe {
*  The first NFA state for all NFA paths will be the same: the starting
*  NFA state of the first nondeterministic alt.  Imagine (A|B|A|A):
*
-	 * 	5->9-A->o
+	 * 	5-&gt;9-A-&gt;o
*  |
-	 *  6->10-B->o
+	 *  6-&gt;10-B-&gt;o
*  |
-	 *  7->11-A->o
+	 *  7-&gt;11-A-&gt;o
*  |
-	 *  8->12-A->o
+	 *  8-&gt;12-A-&gt;o
*
*  There are 3 nondeterministic alts.  The paths should be:
*  5 9 ...
@@ -757,7 +757,7 @@ public class DecisionProbe {
/** Given a start state and a final state, find a list of edge labels
*  between the two ignoring epsilon.  Limit your scan to a set of states
*  passed in.  This is used to show a sample input sequence that is
-	 *  nondeterministic with respect to this decision.  Return List<Label> as
+	 *  nondeterministic with respect to this decision.  Return List&lt;Label&gt; as
*  a parameter.  The incoming states set must be all states that lead
*  from startState to targetState and no others so this algorithm doesn't
*  take a path that eventually leads to a state other than targetState.
diff --git a/tool/src/main/java/org/antlr/analysis/LL1DFA.java b/tool/src/main/java/org/antlr/analysis/LL1DFA.java
index 3120b2a..55f0f8c 100644
--- a/tool/src/main/java/org/antlr/analysis/LL1DFA.java
+++ b/tool/src/main/java/org/antlr/analysis/LL1DFA.java
@@ -43,9 +43,9 @@ public class LL1DFA extends DFA {
/** From list of lookahead sets (one per alt in decision), create
*  an LL(1) DFA.  One edge per set.
*
-	 *  s0-{alt1}->:o=>1
+	 *  s0-{alt1}-&gt;:o=&gt;1
*  | \
-	 *  |  -{alt2}->:o=>2
+	 *  |  -{alt2}-&gt;:o=&gt;2
*  |
*  ...
*/
@@ -70,8 +70,8 @@ public class LL1DFA extends DFA {
}
}

-	/** From a set of edgeset->list-of-alts mappings, create a DFA
-	 *  that uses syn preds for all |list-of-alts|>1.
+	/** From a set of edgeset&rarr;list-of-alts mappings, create a DFA
+	 *  that uses syn preds for all |list-of-alts|&gt;1.
*/
@SuppressWarnings("OverridableMethodCallInConstructor")
public LL1DFA(int decisionNumber,
diff --git a/tool/src/main/java/org/antlr/analysis/Label.java b/tool/src/main/java/org/antlr/analysis/Label.java
index e8e67bd..edd0c19 100644
--- a/tool/src/main/java/org/antlr/analysis/Label.java
+++ b/tool/src/main/java/org/antlr/analysis/Label.java
@@ -35,7 +35,7 @@ import org.antlr.tool.Grammar;
*  label such as a token or character.  A label can be a set of char or
*  tokens.  It can be an epsilon transition.  It can be a semantic predicate
*  (which assumes an epsilon transition) or a tree of predicates (in a DFA).
- *  Special label types have to be < 0 to avoid conflict with char.
+ *  Special label types have to be &lt; 0 to avoid conflict with char.
*/
public class Label implements Comparable<Label>, Cloneable {
public static final int INVALID = -7;
@@ -60,9 +60,9 @@ public class Label implements Comparable<Label>, Cloneable {
*
*  yields a DFA predictor:
*
-     *  o-a->o-b->1   predict alt 1
+     *  o-a-&gt;o-b-&gt;1   predict alt 1
*       |
-     *       |-EOT->o predict alt 2
+     *       |-EOT-&gt;o predict alt 2
*
*  To generate code for EOT, treat it as the "default" path, which
*  implies there is no way to mismatch a char for the state from
diff --git a/tool/src/main/java/org/antlr/analysis/MachineProbe.java b/tool/src/main/java/org/antlr/analysis/MachineProbe.java
index e5da266..2c2dc7e 100644
--- a/tool/src/main/java/org/antlr/analysis/MachineProbe.java
+++ b/tool/src/main/java/org/antlr/analysis/MachineProbe.java
@@ -94,7 +94,7 @@ public class MachineProbe {
}

/**
-	 * Given List<IntSet>, return a String with a useful representation of the
+	 * Given List&lt;IntSet&gt;, return a String with a useful representation of the
* associated input string. One could show something different for lexers
* and parsers, for example.
*/
diff --git a/tool/src/main/java/org/antlr/analysis/NFAConfiguration.java b/tool/src/main/java/org/antlr/analysis/NFAConfiguration.java
index adc814f..6ed9326 100644
--- a/tool/src/main/java/org/antlr/analysis/NFAConfiguration.java
+++ b/tool/src/main/java/org/antlr/analysis/NFAConfiguration.java
@@ -48,7 +48,7 @@ public class NFAConfiguration {
/** The set of semantic predicates associated with this NFA
*  configuration.  The predicates were found on the way to
*  the associated NFA state in this syntactic context.
-     *  Set<AST>: track nodes in grammar containing the predicate
+     *  Set&lt;AST&gt;: track nodes in grammar containing the predicate
*  for error messages and such (nice to know where the predicate
*  came from in case of duplicates etc...).  By using a set,
*  the equals() method will correctly show {pred1,pred2} as equals()
@@ -75,7 +75,7 @@ public class NFAConfiguration {
protected boolean resolveWithPredicate;

/** Lots of NFA states have only epsilon edges (1 or 2).  We can
-     *  safely consider only n>0 during closure.
+     *  safely consider only n&gt;0 during closure.
*/
protected int numberEpsilonTransitionsEmanatingFromState;

diff --git a/tool/src/main/java/org/antlr/analysis/NFAContext.java b/tool/src/main/java/org/antlr/analysis/NFAContext.java
index 16002a2..ac15f14 100644
--- a/tool/src/main/java/org/antlr/analysis/NFAContext.java
+++ b/tool/src/main/java/org/antlr/analysis/NFAContext.java
@@ -62,7 +62,7 @@ public class NFAContext {
*  you could chase your tail forever if somebody said "s : e '.' | e ';' ;"
*  This constant prevents new states from being created after a stack gets
*  "too big".  Actually (12/14/2007) I realize that this example is
-	 *  trapped by the non-LL(*) detector for recursion in > 1 alt.  Here is
+	 *  trapped by the non-LL(*) detector for recursion in &gt; 1 alt.  Here is
*  an example that trips stack overflow:
*
*	  s : a Y | A A A A A X ; // force recursion past m=4
@@ -168,7 +168,7 @@ public class NFAContext {
*  This is used in relation to checking conflicts associated with a
*  single NFA state's configurations within a single DFA state.
*  If there are configurations s and t within a DFA state such that
-	 *  s.state=t.state && s.alt != t.alt && s.ctx conflicts t.ctx then
+	 *  s.state=t.state &amp;&amp; s.alt != t.alt &amp;&amp; s.ctx conflicts t.ctx then
*  the DFA state predicts more than a single alt--it's nondeterministic.
*  Two contexts conflict if they are the same or if one is a suffix
*  of the other.
diff --git a/tool/src/main/java/org/antlr/analysis/NFAState.java b/tool/src/main/java/org/antlr/analysis/NFAState.java
index 9700d27..4f27545 100644
--- a/tool/src/main/java/org/antlr/analysis/NFAState.java
+++ b/tool/src/main/java/org/antlr/analysis/NFAState.java
@@ -47,7 +47,7 @@ public class NFAState extends State {
int numTransitions = 0;
public Transition[] transition = new Transition[MAX_TRANSITIONS];

-	/** For o-A->o type NFA tranitions, record the label that leads to this
+	/** For o-A-&gt;o type NFA tranitions, record the label that leads to this
*  state.  Useful for creating rich error messages when we find
*  insufficiently (with preds) covered states.
*/
@@ -73,7 +73,7 @@ public class NFAState extends State {
*  the DFA will always report alt n+1 as the exit branch for n real
*  alts, so I need to translate that depending on the decision state.
*
-	 *  If decisionNumber>0 then this var tells you what kind of decision
+	 *  If decisionNumber&gt;0 then this var tells you what kind of decision
*  state it is.
*/
public int decisionStateType;
diff --git a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
index b027c69..f4b8538 100644
--- a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
+++ b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
@@ -193,7 +193,7 @@ public class NFAToDFAConverter {
return startState;
}

-	/** From this node, add a d--a-->t transition for all
+	/** From this node, add a d--a--&gt;t transition for all
*  labels 'a' where t is a DFA node created
*  from the set of NFA states reachable from any NFA
*  state in DFA state d.
@@ -356,14 +356,14 @@ public class NFAToDFAConverter {
*
*  The normal decision to predict alts 1, 2, 3 is:
*
-	 *  if ( (input.LA(1)>='1' && input.LA(1)&lt;='9') ) {
+	 *  if ( (input.LA(1)&gt;='1' &amp;&amp; input.LA(1)&lt;='9') ) {
*       alt7=1;
*  }
*  else if ( input.LA(1)=='0' ) {
*      if ( input.LA(2)=='X'||input.LA(2)=='x' ) {
*          alt7=2;
*      }
-     *      else if ( (input.LA(2)>='0' && input.LA(2)&lt;='7') ) {
+     *      else if ( (input.LA(2)&gt;='0' &amp;&amp; input.LA(2)&lt;='7') ) {
*           alt7=3;
*      }
*      else if ( input.LA(2)=='L'||input.LA(2)=='l' ) {
@@ -381,7 +381,7 @@ public class NFAToDFAConverter {
*
*  A better decision is as follows:
*
-	 *  if ( (input.LA(1)>='1' && input.LA(1)&lt;='9') ) {
+	 *  if ( (input.LA(1)&gt;='1' &amp;&amp; input.LA(1)&lt;='9') ) {
*      alt7=1;
*  }
*  else if ( input.LA(1)=='0' ) {
@@ -514,7 +514,7 @@ public class NFAToDFAConverter {
*
*   3. Like case 2, we reach an NFA state associated with the end of a
*      rule, r, in the grammar from which NFA was built.  In this case,
-	 *      however, we realize that during this NFA->DFA conversion, no state
+	 *      however, we realize that during this NFA&rarr;DFA conversion, no state
*      invoked the current rule's NFA.  There is no choice but to add
*      all NFA states that follow references to r's start state.  This is
*      analogous to computing the FOLLOW(r) in the LL(k) world.  By
@@ -581,7 +581,7 @@ public class NFAToDFAConverter {
*        ;
*
*      Input L ID R is ambiguous but to figure this out, ANTLR
-	 *      needs to go a->b->a->b to find the L ID sequence.
+	 *      needs to go a-&gt;b-&gt;a-&gt;b to find the L ID sequence.
*
*      Do not allow closure to add a configuration that would
*      allow too much recursion.
@@ -910,7 +910,7 @@ public class NFAToDFAConverter {
*  That would mean that two NFA configurations could reach the
*  end of the token with possibly different predicted alts.
*  Seems like that would be rare or impossible.  Perhaps convert
-	 *  this routine to find all such configs and give error if >1.
+	 *  this routine to find all such configs and give error if &gt;1.
*/
protected void convertToEOTAcceptState(DFAState d) {
Label eot = new Label(Label.EOT);
@@ -938,7 +938,7 @@ public class NFAToDFAConverter {
/** Add a new DFA state to the DFA if not already present.
*  If the DFA state uniquely predicts a single alternative, it
*  becomes a stop state; don't add to work list.  Further, if
-     *  there exists an NFA state predicted by > 1 different alternatives
+     *  there exists an NFA state predicted by &gt; 1 different alternatives
*  and with the same syn and sem context, the DFA is nondeterministic for
*  at least one input sequence reaching that NFA state.
*/
@@ -1024,7 +1024,7 @@ public class NFAToDFAConverter {
return d;
}

-	/** If > 1 NFA configurations within this DFA state have identical
+	/** If &gt; 1 NFA configurations within this DFA state have identical
*  NFA state and context, but differ in their predicted
*  TODO update for new context suffix stuff 3-9-2005
*  alternative then a single input sequence predicts multiple alts.
@@ -1079,13 +1079,13 @@ public class NFAToDFAConverter {
*
*  Here is a (slightly reduced) NFA of this grammar:
*
-	 *  (1)-A->(2)-B->(end)-EOF->(8)
+	 *  (1)-A-&gt;(2)-B-&gt;(end)-EOF-&gt;(8)
*   |              ^
-	 *  (2)-A->(3)-C----|
+	 *  (2)-A-&gt;(3)-C----|
*   |              ^
-	 *  (4)-A->(5)------|
+	 *  (4)-A-&gt;(5)------|
*   |              ^
-	 *  (6)-A->(7)------|
+	 *  (6)-A-&gt;(7)------|
*
*  where (n) is NFA state n.  To begin DFA conversion, the start
*  state is created:
@@ -1114,9 +1114,9 @@ public class NFAToDFAConverter {
*  {(1|1),(2|2),(4|3),(6|4)}
*              |
*              v
-	 *  {(2|1),(3|2),(5|3),(7|4),(end|3),(end|4)} -B-> (end|1)
+	 *  {(2|1),(3|2),(5|3),(7|4),(end|3),(end|4)} -B-&gt; (end|1)
*              |                        |
-	 *              C                        ----EOF-> (8,3)
+	 *              C                        ----EOF-&gt; (8,3)
*              |
*              v
*           (end|2)
@@ -1160,7 +1160,7 @@ public class NFAToDFAConverter {
*  it uniquely predicts one alt. :)  Problem
*  states will look like this during conversion:
*
-	 *  DFA 1:{9|1, 19|2, 14|3, 20|2, 23|2, 24|2, ...}-<EOT>->5:{41|3, 42|2}
+	 *  DFA 1:{9|1, 19|2, 14|3, 20|2, 23|2, 24|2, ...}-&lt;EOT&gt;-&gt;5:{41|3, 42|2}
*
*  Worse, when you have two identical literal rules, you will see 3 alts
*  in the EOT state (one for ID and one each for the identical rules).
diff --git a/tool/src/main/java/org/antlr/analysis/SemanticContext.java b/tool/src/main/java/org/antlr/analysis/SemanticContext.java
index c78ce72..4f43b5a 100644
--- a/tool/src/main/java/org/antlr/analysis/SemanticContext.java
+++ b/tool/src/main/java/org/antlr/analysis/SemanticContext.java
@@ -38,10 +38,10 @@ import java.util.*;

/** A binary tree structure used to record the semantic context in which
*  an NFA configuration is valid.  It's either a single predicate or
- *  a tree representing an operation tree such as: p1&&p2 or p1||p2.
+ *  a tree representing an operation tree such as: p1&amp;&amp;p2 or p1||p2.
*
- *  For NFA o-p1->o-p2->o, create tree AND(p1,p2).
- *  For NFA (1)-p1->(2)
+ *  For NFA o-p1-&gt;o-p2-&gt;o, create tree AND(p1,p2).
+ *  For NFA (1)-p1-&gt;(2)
*           |       ^
*           |       |
*          (3)-p2----
@@ -65,8 +65,8 @@ public abstract class SemanticContext {
public static final SemanticContext EMPTY_SEMANTIC_CONTEXT = new Predicate(Predicate.INVALID_PRED_VALUE);

/** Given a semantic context expression tree, return a tree with all
-	 *  nongated predicates set to true and then reduced.  So p&&(q||r) would
-	 *  return p&&r if q is nongated but p and r are gated.
+	 *  nongated predicates set to true and then reduced.  So p&amp;&amp;(q||r) would
+	 *  return p&amp;&amp;r if q is nongated but p and r are gated.
*/
public abstract SemanticContext getGatedPredicateContext();

@@ -88,7 +88,7 @@ public abstract class SemanticContext {
/** The AST node in tree created from the grammar holding the predicate */
public GrammarAST predicateAST;

-		/** Is this a {...}?=> gating predicate or a normal disambiguating {..}?
+		/** Is this a {...}?=&gt; gating predicate or a normal disambiguating {..}?
*  If any predicate in expression is gated, then expression is considered
*  gated.
*
diff --git a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
index 57495b2..b279bd5 100644
--- a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
+++ b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
@@ -744,7 +744,7 @@ public class CodeGenerator {
}

/** For intervals such as [3..3, 30..35], generate an expression that
-	 *  tests the lookahead similar to LA(1)==3 || (LA(1)>=30&&LA(1)<=35)
+	 *  tests the lookahead similar to LA(1)==3 || (LA(1)&gt;=30&amp;&amp;LA(1)&lt;=35)
*/
public ST genSetExpr(STGroup templates,
IntSet set,
@@ -931,7 +931,7 @@ public class CodeGenerator {

/** Translate an action like [3,"foo",a[3]] and return a List of the
*  translated actions.  Because actions are themselves translated to a list
-	 *  of chunks, must cat together into a ST>.  Don't translate
+	 *  of chunks, must cat together into a ST&gt;.  Don't translate
*  to strings early as we need to eval templates in context.
*/
public List<ST> translateArgAction(String ruleName,
@@ -1340,7 +1340,7 @@ public class CodeGenerator {
/** Create a label to track a token / rule reference's result.
*  Technically, this is a place where I break model-view separation
*  as I am creating a variable name that could be invalid in a
-	 *  target language, however, label ::= <ID><INT> is probably ok in
+	 *  target language, however, label ::= &lt;ID&gt;&lt;INT&gt; is probably ok in
*  all languages we care about.
*/
public String createUniqueLabel(String name) {
diff --git a/tool/src/main/java/org/antlr/codegen/ObjCTarget.java b/tool/src/main/java/org/antlr/codegen/ObjCTarget.java
index 0f34011..c20f76e 100644
--- a/tool/src/main/java/org/antlr/codegen/ObjCTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/ObjCTarget.java
@@ -65,7 +65,7 @@ public class ObjCTarget extends Target {

/** Convert from an ANTLR string literal found in a grammar file to
*  an equivalent string literal in the target language.  For Java, this
-	*  is the translation 'a\n"' -> "a\n\"".  Expect single quotes
+	*  is the translation 'a\n"' &rarr; "a\n\"".  Expect single quotes
*  around the incoming literal.  Just flip the quotes and replace
*  double quotes with \"
*/
diff --git a/tool/src/main/java/org/antlr/codegen/RubyTarget.java b/tool/src/main/java/org/antlr/codegen/RubyTarget.java
index a1a558c..cb2107f 100644
--- a/tool/src/main/java/org/antlr/codegen/RubyTarget.java
+++ b/tool/src/main/java/org/antlr/codegen/RubyTarget.java
@@ -134,11 +134,11 @@ public class RubyTarget extends Target
*
* example -- aGUIWhatNot
*   c   c+1 c+2  action
-         *   a   G        << 'a' << '_'  // a lower-upper word edge
-         *   G   U   I    << 'g'
-         *   U   I   W    << 'w'
-         *   I   W   h    << 'i' << '_'  // the last character in an acronym run of uppers
-         *   W   h        << 'w'
+         *   a   G        &lt;&lt; 'a' &lt;&lt; '_'  // a lower-upper word edge
+         *   G   U   I    &lt;&lt; 'g'
+         *   U   I   W    &lt;&lt; 'w'
+         *   I   W   h    &lt;&lt; 'i' &lt;&lt; '_'  // the last character in an acronym run of uppers
+         *   W   h        &lt;&lt; 'w'
*   ... and so on
*/
private String snakecase( String value ) {
diff --git a/tool/src/main/java/org/antlr/codegen/Target.java b/tool/src/main/java/org/antlr/codegen/Target.java
index 08d6f8c..0a88326 100644
--- a/tool/src/main/java/org/antlr/codegen/Target.java
+++ b/tool/src/main/java/org/antlr/codegen/Target.java
@@ -199,7 +199,7 @@ public class Target {

/** Convert from an ANTLR string literal found in a grammar file to
*  an equivalent string literal in the target language.  For Java, this
-	 *  is the translation 'a\n"' -> "a\n\"".  Expect single quotes
+	 *  is the translation 'a\n"' &rarr; "a\n\"".  Expect single quotes
*  around the incoming literal.  Just flip the quotes and replace
*  double quotes with \"
*
diff --git a/tool/src/main/java/org/antlr/misc/Graph.java b/tool/src/main/java/org/antlr/misc/Graph.java
index 73ffcac..5df5ac1 100644
--- a/tool/src/main/java/org/antlr/misc/Graph.java
+++ b/tool/src/main/java/org/antlr/misc/Graph.java
@@ -73,7 +73,7 @@ public class Graph<T> {
*  For sorting, I'm not following convention here since ANTLR
*  needs the opposite.  Here's what I assume for sorting:
*
-     *    If there exists an edge u -> v then u depends on v and v
+     *    If there exists an edge u &rarr; v then u depends on v and v
*    must happen before u.
*
*  So if this gives nonreversed postorder traversal, I get the order
diff --git a/tool/src/main/java/org/antlr/misc/IntervalSet.java b/tool/src/main/java/org/antlr/misc/IntervalSet.java
index 0dd14c1..15ec943 100644
--- a/tool/src/main/java/org/antlr/misc/IntervalSet.java
+++ b/tool/src/main/java/org/antlr/misc/IntervalSet.java
@@ -87,7 +87,7 @@ public class IntervalSet implements IntSet {
}

/** Add interval; i.e., add all integers from a to b to set.
-     *  If b<a, do nothing.
+     *  If b&lt;a, do nothing.
*  Keep list in sorted order (by left range value).
*  If overlap, combine ranges.  For example,
*  If this is {1..5, 10..20}, adding 6..7 yields
@@ -258,7 +258,7 @@ public class IntervalSet implements IntSet {
return compl;
}

-	/** Compute this-other via this&~other.
+	/** Compute this-other via this&amp;~other.
*  Return a new set containing all elements in this but not in other.
*  other is assumed to be a subset of this;
*  anything that is in other but not in this will be ignored.
@@ -533,7 +533,7 @@ public class IntervalSet implements IntSet {
return last.b;
}

-	/** Return minimum element >= 0 */
+	/** Return minimum element &gt;= 0 */
public int getMinElement() {
if ( isNil() ) {
return Label.INVALID;
diff --git a/tool/src/main/java/org/antlr/tool/ErrorManager.java b/tool/src/main/java/org/antlr/tool/ErrorManager.java
index d3223ae..82e69e8 100644
--- a/tool/src/main/java/org/antlr/tool/ErrorManager.java
+++ b/tool/src/main/java/org/antlr/tool/ErrorManager.java
@@ -244,7 +244,7 @@ public class ErrorManager {
};

/** Only one error can be emitted for any entry in this table.
-	 *  Map<String,Set> where the key is a method name like danglingState.
+	 *  Map&lt;String,Set&gt; where the key is a method name like danglingState.
*  The set is whatever that method accepts or derives like a DFA.
*/
public static final Map<String, Set<String>> emitSingleError = new HashMap<String, Set<String>>() {
diff --git a/tool/src/main/java/org/antlr/tool/FASerializer.java b/tool/src/main/java/org/antlr/tool/FASerializer.java
index 39b0e4a..4e601d8 100644
--- a/tool/src/main/java/org/antlr/tool/FASerializer.java
+++ b/tool/src/main/java/org/antlr/tool/FASerializer.java
@@ -50,7 +50,7 @@ public class FASerializer {

/** Rather than add a new instance variable to NFA and DFA just for
*  serializing machines, map old state numbers to new state numbers
-     *  by a State object -> Integer new state number HashMap.
+     *  by a State object &rarr; Integer new state number HashMap.
*/
protected Map<State, Integer> stateNumberTranslator;

diff --git a/tool/src/main/java/org/antlr/tool/Grammar.java b/tool/src/main/java/org/antlr/tool/Grammar.java
index 91bbad9..667ebb2 100644
--- a/tool/src/main/java/org/antlr/tool/Grammar.java
+++ b/tool/src/main/java/org/antlr/tool/Grammar.java
@@ -306,7 +306,7 @@ public class Grammar {

// Token options are here to avoid contaminating Token object in runtime

-	/** Legal options for terminal refs like ID<node=MyVarNode> */
+	/** Legal options for terminal refs like ID&lt;node=MyVarNode&gt; */
public static final Set<String> legalTokenOptions =
new HashSet<String>() {
{
@@ -326,7 +326,7 @@ public class Grammar {
protected int global_k = -1;

/** Map a scope to a map of name:action pairs.
-	 *  Map<String, Map<String,GrammarAST>>
+	 *  Map&lt;String, Map&lt;String,GrammarAST&gt;&gt;
*  The code generator will use this to fill holes in the output files.
*  I track the AST node for the action in case I need the line number
*  for errors.
@@ -452,7 +452,7 @@ public class Grammar {

/** An AST that records entire input grammar with all rules.  A simple
*  grammar with one rule, "grammar t; a : A | B ;", looks like:
-	 * ( grammar t ( rule a ( BLOCK ( ALT A ) ( ALT B ) ) <end-of-rule> ) )
+	 * ( grammar t ( rule a ( BLOCK ( ALT A ) ( ALT B ) ) &lt;end-of-rule&gt; ) )
*/
protected GrammarAST grammarTree = null;

@@ -504,7 +504,7 @@ public class Grammar {
/** How long in ms did it take to build DFAs for this grammar?
*  If this grammar is a combined grammar, it only records time for
*  the parser grammar component.  This only records the time to
-	 *  do the LL(*) work; NFA->DFA conversion.
+	 *  do the LL(*) work; NFA&rarr;DFA conversion.
*/
public long DFACreationWallClockTimeInMS;

@@ -1880,7 +1880,7 @@ outer:
}
}

-	/** Given a set of all rewrite elements on right of ->, filter for
+	/** Given a set of all rewrite elements on right of -&gt;, filter for
*  label types such as Grammar.TOKEN_LABEL, Grammar.TOKEN_LIST_LABEL, ...
*  Return a displayable token type name computed from the GrammarAST.
*/
@@ -2352,7 +2352,7 @@ outer:
delegateGrammar.composite = this.composite;
}

-	/** Load a vocab file <vocabName>.tokens and return max token type found. */
+	/** Load a vocab file &lt;vocabName&gt;.tokens and return max token type found. */
public int importTokenVocabulary(GrammarAST tokenVocabOptionAST,
String vocabName)
{
@@ -2851,7 +2851,7 @@ outer:
*  ANTLRWorks has to give the *exact* location which
*  is not easy from the user point of view).
*
-	 *  This is not particularly fast as it walks entire line:col->DFA map
+	 *  This is not particularly fast as it walks entire line:col&rarr;DFA map
*  looking for a prefix of "line:".
*/
public List<Integer> getLookaheadDFAColumnsForLineInFile(int line) {
@@ -3095,9 +3095,9 @@ outer:
*  an invalid alt is requested.  I must count in to find the right
*  alternative number.  For (A|B), you get NFA structure (roughly):
*
-	 *  o->o-A->o
+	 *  o-&gt;o-A-&gt;o
*  |
-	 *  o->o-B->o
+	 *  o-&gt;o-B-&gt;o
*
*  This routine returns the leftmost state for each alt.  So alt=1, returns
*  the upperleft most state in this structure.
@@ -3171,7 +3171,7 @@ outer:
}

/** given a token type and the text of the literal, come up with a
-	 *  decent token type label.  For now it's just T<type>.  Actually,
+	 *  decent token type label.  For now it's just T&lt;type&gt;.  Actually,
*  if there is an aliased name from tokens like PLUS='+', use it.
*/
public String computeTokenNameFromLiteral(int tokenType, String literal) {
diff --git a/tool/src/main/java/org/antlr/tool/GrammarSanity.java b/tool/src/main/java/org/antlr/tool/GrammarSanity.java
index a3d612a..5678950 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSanity.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSanity.java
@@ -157,7 +157,7 @@ public class GrammarSanity {
/** enclosingRuleName calls targetRuleName, find the cycle containing
*  the target and add the caller.  Find the cycle containing the caller
*  and add the target.  If no cycles contain either, then create a new
-	 *  cycle.  listOfRecursiveCycles is List<Set<String>> that holds a list
+	 *  cycle.  listOfRecursiveCycles is List&lt;Set&lt;String&gt;&gt; that holds a list
*  of cycles (sets of rule names).
*/
protected void addRulesToCycle(Rule targetRule,
@@ -252,12 +252,12 @@ public class GrammarSanity {
}
}

-	/** Rules in tree grammar that use -> rewrites and are spitting out
+	/** Rules in tree grammar that use -&gt; rewrites and are spitting out
*  templates via output=template and then use rewrite=true must only
-	 *  use -> on alts that are simple nodes or trees or single rule refs
+	 *  use -&gt; on alts that are simple nodes or trees or single rule refs
*  that match either nodes or trees.  The altAST is the ALT node
*  for an ALT.  Verify that its first child is simple.  Must be either
-	 *  ( ALT ^( A B ) <end-of-alt> ) or ( ALT A <end-of-alt> ) or
+	 *  ( ALT ^( A B ) &lt;end-of-alt&gt; ) or ( ALT A &lt;end-of-alt&gt; ) or
*  other element.
*
*  Ignore predicates in front and labels.
diff --git a/tool/src/main/java/org/antlr/tool/GrammarSerializerFoo.java b/tool/src/main/java/org/antlr/tool/GrammarSerializerFoo.java
index 28a4555..d66f51e 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSerializerFoo.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSerializerFoo.java
@@ -36,10 +36,10 @@ import java.io.*;
*  only the info needed to recognize sentences.
*  FORMAT:
*
- *  file ::= $ANTLR<version:byte><grammartype:byte><name:string>;<numRules:short><rules>
- *  rule ::= R<rulename:string>;B<nalts:short><alts>.
- *  alt  ::= A<elems>;
- *  elem ::= t<tokentype:short> | r<ruleIndex:short> | -<char:uchar><char:uchar> | ~<tokentype> | w
+ *  file ::= $ANTLR&lt;version:byte&gt;&lt;grammartype:byte&gt;&lt;name:string&gt;;&lt;numRules:short&gt;&lt;rules&gt;
+ *  rule ::= R&lt;rulename:string&gt;;B&lt;nalts:short&gt;&lt;alts&gt;.
+ *  alt  ::= A&lt;elems&gt;;
+ *  elem ::= t&lt;tokentype:short&gt; | r&lt;ruleIndex:short&gt; | -&lt;char:uchar&gt;&lt;char:uchar&gt; | ~&lt;tokentype&gt; | w
*/
public class GrammarSerializerFoo {
protected DataOutputStream out;
diff --git a/tool/src/main/java/org/antlr/tool/GrammarSpelunker.java b/tool/src/main/java/org/antlr/tool/GrammarSpelunker.java
index 4b5314b..ddde27f 100644
--- a/tool/src/main/java/org/antlr/tool/GrammarSpelunker.java
+++ b/tool/src/main/java/org/antlr/tool/GrammarSpelunker.java
@@ -187,7 +187,7 @@ public class GrammarSpelunker {
return null;
}

-        /** NAME : LETTER+ ; // NAME is sequence of >=1 letter */
+        /** NAME : LETTER+ ; // NAME is sequence of &gt;=1 letter */
String ID() throws IOException {
StringBuilder buf = new StringBuilder();
while ( c!=EOF && isID_LETTER() ) { buf.append((char)c); consume(); }
diff --git a/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java b/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
index 7422de2..61e1891 100644
--- a/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
+++ b/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java
@@ -108,7 +108,7 @@ public class LeftRecursiveRuleAnalyzer extends LeftRecursiveRuleWalker {
//System.out.println("binaryAlt " + alt + ": " + altText + ", rewrite=" + rewriteText);
}

-	/** Convert e ? e : e  ->  ? e : e_[nextPrec] */
+	/** Convert e ? e : e  &rarr;  ? e : e_[nextPrec] */
@Override
public void ternaryAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {
altTree = GrammarAST.dupTree(altTree);
diff --git a/tool/src/main/java/org/antlr/tool/NFAFactory.java b/tool/src/main/java/org/antlr/tool/NFAFactory.java
index 9cb0eb3..93db958 100644
--- a/tool/src/main/java/org/antlr/tool/NFAFactory.java
+++ b/tool/src/main/java/org/antlr/tool/NFAFactory.java
@@ -41,7 +41,7 @@ import java.util.List;
*
*  TODO: add an optimization that reduces number of states and transitions
*  will help with speed of conversion and make it easier to view NFA.  For
- *  example, o-A->o-->o-B->o should be o-A->o-B->o
+ *  example, o-A-&gt;o--&gt;o-B-&gt;o should be o-A-&gt;o-B-&gt;o
*/
public class NFAFactory {
/** This factory is attached to a specifc NFA that it is building.
@@ -114,7 +114,7 @@ public class NFAFactory {
}
}

-	/** From label A build Graph o-A->o */
+	/** From label A build Graph o-A-&gt;o */
public StateCluster build_Atom(int label, GrammarAST associatedAST) {
NFAState left = newState();
NFAState right = newState();
@@ -130,7 +130,7 @@ public class NFAFactory {
return build_Atom(tokenType, atomAST);
}

-	/** From set build single edge graph o->o-set->o.  To conform to
+	/** From set build single edge graph o-&gt;o-set-&gt;o.  To conform to
*  what an alt block looks like, must have extra state on left.
*/
public StateCluster build_Set(IntSet set, GrammarAST associatedAST) {
@@ -170,14 +170,14 @@ public class NFAFactory {
return g;
}

-	/** From char 'c' build StateCluster o-intValue(c)->o
+	/** From char 'c' build StateCluster o-intValue(c)-&gt;o
*/
public StateCluster build_CharLiteralAtom(GrammarAST charLiteralAST) {
int c = Grammar.getCharValueFromGrammarCharLiteral(charLiteralAST.getText());
return build_Atom(c, charLiteralAST);
}

-	/** From char 'c' build StateCluster o-intValue(c)->o
+	/** From char 'c' build StateCluster o-intValue(c)-&gt;o
*  can include unicode spec likes '\u0024' later.  Accepts
*  actual unicode 16-bit now, of course, by default.
*  TODO not supplemental char clean!
@@ -191,7 +191,7 @@ public class NFAFactory {
/** For a non-lexer, just build a simple token reference atom.
*  For a lexer, a string is a sequence of char to match.  That is,
*  "fog" is treated as 'f' 'o' 'g' not as a single transition in
-     *  the DFA.  Machine== o-'f'->o-'o'->o-'g'->o and has n+1 states
+     *  the DFA.  Machine== o-'f'-&gt;o-'o'-&gt;o-'g'-&gt;o and has n+1 states
*  for n characters.
*/
public StateCluster build_StringLiteralAtom(GrammarAST stringLiteralAST) {
@@ -217,16 +217,16 @@ public class NFAFactory {

/** For reference to rule r, build
*
-     *  o-e->(r)  o
+     *  o-e-&gt;(r)  o
*
*  where (r) is the start of rule r and the trailing o is not linked
*  to from rule ref state directly (it's done thru the transition(0)
*  RuleClosureTransition.
*
*  If the rule r is just a list of tokens, it's block will be just
-     *  a set on an edge o->o->o-set->o->o->o, could inline it rather than doing
+     *  a set on an edge o-&gt;o-&gt;o-set-&gt;o-&gt;o-&gt;o, could inline it rather than doing
*  the rule reference, but i'm not doing this yet as I'm not sure
-     *  it would help much in the NFA->DFA construction.
+     *  it would help much in the NFA&rarr;DFA construction.
*
*  TODO add to codegen: collapse alt blks that are sets into single matchSet
*/
@@ -242,7 +242,7 @@ public class NFAFactory {
return g;
}

-    /** From an empty alternative build StateCluster o-e->o */
+    /** From an empty alternative build StateCluster o-e-&gt;o */
public StateCluster build_Epsilon() {
NFAState left = newState();
NFAState right = newState();
@@ -327,7 +327,7 @@ public class NFAFactory {
endNFAState.addTransition(toEnd);
}

-    /** From A B build A-e->B (that is, build an epsilon arc from right
+    /** From A B build A-e-&gt;B (that is, build an epsilon arc from right
*  of A to left of B).
*
*  As a convenience, return B if A is null or return A if B is null.
@@ -346,7 +346,7 @@ public class NFAFactory {

/** From a set ('a'|'b') build
*
-     *  o->o-'a'..'b'->o->o (last NFAState is blockEndNFAState pointed to by all alts)
+     *  o-&gt;o-'a'..'b'-&gt;o-&gt;o (last NFAState is blockEndNFAState pointed to by all alts)
*/
public StateCluster build_AlternativeBlockFromSet(StateCluster set) {
if ( set==null ) {
@@ -362,13 +362,13 @@ public class NFAFactory {

/** From A|B|..|Z alternative block build
*
-     *  o->o-A->o->o (last NFAState is blockEndNFAState pointed to by all alts)
+     *  o-&gt;o-A-&gt;o-&gt;o (last NFAState is blockEndNFAState pointed to by all alts)
*  |          ^
-     *  o->o-B->o--|
+     *  o-&gt;o-B-&gt;o--|
*  |          |
*  ...        |
*  |          |
-     *  o->o-Z->o--|
+     *  o-&gt;o-Z-&gt;o--|
*
*  So every alternative gets begin NFAState connected by epsilon
*  and every alt right side points at a block end NFAState.  There is a
@@ -379,7 +379,7 @@ public class NFAFactory {
*  begin/end.
*
*  Special case: if just a list of tokens/chars/sets, then collapse
-     *  to a single edge'd o-set->o graph.
+     *  to a single edge'd o-set-&gt;o graph.
*
*  Set alt number (1..n) in the left-Transition NFAState.
*/
@@ -442,9 +442,9 @@ public class NFAFactory {

/** From (A)? build either:
*
-	 *  o--A->o
+	 *  o--A-&gt;o
*  |     ^
-	 *  o---->|
+	 *  o----&gt;|
*
*  or, if A is a block, just add an empty alt to the end of the block
*/
@@ -496,7 +496,7 @@ public class NFAFactory {
*
*     |---|    (Transition 2 from A.right points at alt 1)
*     v   |    (follow of loop is Transition 1)
-     *  o->o-A-o->o
+     *  o-&gt;o-A-o-&gt;o
*
*  Meaning that the last NFAState in A points back to A's left Transition NFAState
*  and we add a new begin/end NFAState.  A can be single alternative or
@@ -538,7 +538,7 @@ public class NFAFactory {
*
*     |---|
*     v   |
-	 *  o->o-A-o--o (Transition 2 from block end points at alt 1; follow is Transition 1)
+	 *  o-&gt;o-A-o--o (Transition 2 from block end points at alt 1; follow is Transition 1)
*  |         ^
*  o---------| (optional branch is 2nd alt of optional block containing A+)
*
diff --git a/tool/src/main/java/org/antlr/tool/Rule.java b/tool/src/main/java/org/antlr/tool/Rule.java
index cf0bee4..915c215 100644
--- a/tool/src/main/java/org/antlr/tool/Rule.java
+++ b/tool/src/main/java/org/antlr/tool/Rule.java
@@ -130,7 +130,7 @@ public class Rule {

public int numberOfAlts;

-	/** Each alt has a Map<tokenRefName,List<tokenRefAST>>; range 1..numberOfAlts.
+	/** Each alt has a Map&lt;tokenRefName,List&lt;tokenRefAST&gt;&gt;; range 1..numberOfAlts.
*  So, if there are 3 ID refs in a rule's alt number 2, you'll have
*  altToTokenRef[2].get("ID").size()==3.  This is used to see if $ID is ok.
*  There must be only one ID reference in the alt for $ID to be ok in
@@ -143,7 +143,7 @@ public class Rule {
*/
protected Map<String, List<GrammarAST>>[] altToTokenRefMap;

-	/** Each alt has a Map<ruleRefName,List<ruleRefAST>>; range 1..numberOfAlts
+	/** Each alt has a Map&lt;ruleRefName,List&lt;ruleRefAST&gt;&gt;; range 1..numberOfAlts
*  So, if there are 3 expr refs in a rule's alt number 2, you'll have
*  altToRuleRef[2].get("expr").size()==3.  This is used to see if $expr is ok.
*  There must be only one expr reference in the alt for $expr to be ok in
diff --git a/tool/src/test/java/org/antlr/test/TestIntervalSet.java b/tool/src/test/java/org/antlr/test/TestIntervalSet.java
index d6fea65..0e92a52 100644
--- a/tool/src/test/java/org/antlr/test/TestIntervalSet.java
+++ b/tool/src/test/java/org/antlr/test/TestIntervalSet.java
@@ -345,8 +345,8 @@ public class TestIntervalSet extends BaseTest {
/**
* This case is responsible for antlr/antlr4#153.
* https://github.com/antlr/antlr4/issues/153
-	 * <p/>
-	 * Resolution back-ported from V4.
+	 * <p>
+	 * Resolution back-ported from V4.</p>
*/
@Test public void testMergeWhereAdditionMergesThreeExistingIntervals() throws Exception {
IntervalSet s = new IntervalSet();
@@ -387,7 +387,7 @@ public class TestIntervalSet extends BaseTest {
}

/** The following was broken:
-	    {'\u0000'..'s', 'u'..'\uFFFE'} & {'\u0000'..'q', 's'..'\uFFFE'}=
+	    {'\u0000'..'s', 'u'..'\uFFFE'} &amp; {'\u0000'..'q', 's'..'\uFFFE'}=
{'\u0000'..'q', 's'}!!!! broken...
'q' is 113 ascii
'u' is 117
diff --git a/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java b/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
index 4fbd7f2..0ad540c 100644
--- a/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
+++ b/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
@@ -636,7 +636,7 @@ public class TestSemanticPredicates extends BaseTest {
*  "pinching" together into a single NFA state.
*
*  This test also demonstrates that just because B D could predict
-	 *  alt 1 in rule 'a', it is unnecessary to continue NFA->DFA
+	 *  alt 1 in rule 'a', it is unnecessary to continue NFA&rarr;DFA
*  conversion to include an edge for D.  Alt 1 is the only possible
*  prediction because we resolve the ambiguity by choosing alt 1.
*/

