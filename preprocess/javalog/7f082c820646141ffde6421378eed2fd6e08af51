commit 7f082c820646141ffde6421378eed2fd6e08af51
Author:     Sam Harwell <sam@tunnelvisionlabs.com>
AuthorDate: Tue Feb 21 20:25:07 2012 -0600
Commit:     Sam Harwell <sam@tunnelvisionlabs.com>
CommitDate: Wed Feb 22 12:25:38 2012 -0600

Remove unused and unnecessary initializations

diff --git a/runtime/Java/src/main/java/org/antlr/runtime/ANTLRReaderStream.java b/runtime/Java/src/main/java/org/antlr/runtime/ANTLRReaderStream.java
index 24d51ad..21881a4 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/ANTLRReaderStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/ANTLRReaderStream.java
@@ -70,7 +70,7 @@ public class ANTLRReaderStream extends ANTLRStringStream {
// alloc initial buffer size.
data = new char[size];
// read all the data in chunks of readChunkSize
-			int numRead=0;
+			int numRead;
int p = 0;
do {
if ( p+readChunkSize > data.length ) { // overflow?
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java b/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java
index 9a9bece..82e3c25 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java
@@ -159,7 +159,7 @@ public class ANTLRStringStream implements CharStream {
markers.add(null); // depth 0 means no backtracking, leave blank
}
markDepth++;
-		CharStreamState state = null;
+		CharStreamState state;
if ( markDepth>=markers.size() ) {
state = new CharStreamState();
markers.add(state);
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java b/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
index 667664d..4292e96 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java
@@ -220,7 +220,7 @@ public abstract class BaseRecognizer {
String msg = e.getMessage();
if ( e instanceof UnwantedTokenException ) {
UnwantedTokenException ute = (UnwantedTokenException)e;
-			String tokenName="<unknown>";
+			String tokenName;
if ( ute.expecting== Token.EOF ) {
tokenName = "EOF";
}
@@ -232,7 +232,7 @@ public abstract class BaseRecognizer {
}
else if ( e instanceof MissingTokenException ) {
MissingTokenException mte = (MissingTokenException)e;
-			String tokenName="<unknown>";
+			String tokenName;
if ( mte.expecting== Token.EOF ) {
tokenName = "EOF";
}
@@ -243,7 +243,7 @@ public abstract class BaseRecognizer {
}
else if ( e instanceof MismatchedTokenException ) {
MismatchedTokenException mte = (MismatchedTokenException)e;
-			String tokenName="<unknown>";
+			String tokenName;
if ( mte.expecting== Token.EOF ) {
tokenName = "EOF";
}
@@ -255,7 +255,7 @@ public abstract class BaseRecognizer {
}
else if ( e instanceof MismatchedTreeNodeException ) {
MismatchedTreeNodeException mtne = (MismatchedTreeNodeException)e;
-			String tokenName="<unknown>";
+			String tokenName;
if ( mtne.expecting==Token.EOF ) {
tokenName = "EOF";
}
@@ -727,7 +727,7 @@ public abstract class BaseRecognizer {
{
List rules = new ArrayList();
StackTraceElement[] stack = e.getStackTrace();
-		int i = 0;
+		int i;
for (i=stack.length-1; i>=0; i--) {
StackTraceElement t = stack[i];
if ( t.getClassName().startsWith("org.antlr.runtime.") ) {
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java b/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java
index 3f359d9..a6ea223 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java
@@ -271,7 +271,7 @@ public abstract class Lexer extends BaseRecognizer implements TokenSource {

@Override
public String getErrorMessage(RecognitionException e, String[] tokenNames) {
-		String msg = null;
+		String msg;
if ( e instanceof MismatchedTokenException ) {
MismatchedTokenException mte = (MismatchedTokenException)e;
msg = "mismatched character "+getCharErrorDisplay(e.c)+" expecting "+getCharErrorDisplay(mte.expecting);
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/Parser.java b/runtime/Java/src/main/java/org/antlr/runtime/Parser.java
index aca0cce..7e719f6 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/Parser.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/Parser.java
@@ -64,7 +64,7 @@ public class Parser extends BaseRecognizer {
int expectedTokenType,
BitSet follow)
{
-		String tokenText = null;
+		String tokenText;
if ( expectedTokenType==Token.EOF ) tokenText = "<missing EOF>";
else tokenText = "<missing "+getTokenNames()[expectedTokenType]+">";
CommonToken t = new CommonToken(expectedTokenType, tokenText);
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java b/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java
index 031e26b..9092278 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java
@@ -355,7 +355,7 @@ public class RemoteDebugEventSocketListener implements Runnable {
String indexS = elements[2];
String lineS = elements[3];
String posS = elements[4];
-			Class excClass = null;
+			Class excClass;
try {
excClass = Class.forName(excName);
RecognitionException e =
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java
index 52f6e94..ee22d28 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java
@@ -199,7 +199,7 @@ public abstract class BaseTree implements Tree {
int replacingHowMany = stopChildIndex - startChildIndex + 1;
int replacingWithHowMany;
BaseTree newTree = (BaseTree)t;
-		List newChildren = null;
+		List newChildren;
// normalize to a list of children to add: newChildren
if ( newTree.isNil() ) {
newChildren = newTree.children;
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java
index 80fb3d8..242e407 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java
@@ -190,7 +190,7 @@ public class BufferedTreeNodeStream implements TreeNodeStream {
*  so instantiate new ones when uniqueNavigationNodes is true.
*/
protected void addNavigationNode(final int ttype) {
-		Object navNode = null;
+		Object navNode;
if ( ttype==Token.DOWN ) {
if ( hasUniqueNavigationNodes() ) {
navNode = adaptor.create(Token.DOWN, "DOWN");
@@ -469,7 +469,7 @@ public class BufferedTreeNodeStream implements TreeNodeStream {
return tokens.toString(beginTokenIndex, endTokenIndex);
}
// walk nodes looking for start
-		Object t = null;
+		Object t;
int i = 0;
for (; i < nodes.size(); i++) {
t = nodes.get(i);
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonErrorNode.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonErrorNode.java
index 4c27487..c0fc41c 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonErrorNode.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonErrorNode.java
@@ -68,7 +68,7 @@ public class CommonErrorNode extends CommonTree {

@Override
public String getText() {
-		String badText = null;
+		String badText;
if ( start instanceof Token ) {
int i = ((Token)start).getTokenIndex();
int j = ((Token)stop).getTokenIndex();
diff --git a/tool/src/main/java/org/antlr/Tool.java b/tool/src/main/java/org/antlr/Tool.java
index b336baf..7aa776a 100644
--- a/tool/src/main/java/org/antlr/Tool.java
+++ b/tool/src/main/java/org/antlr/Tool.java
@@ -104,7 +104,7 @@ public class Tool {
* variables that must be initialized from it, such as the version of ANTLR.
*/
private void loadResources() {
-        InputStream in = null;
+        InputStream in;
in = this.getClass().getResourceAsStream("antlr.properties");

// If we found the resource, then load it, otherwise revert to the
@@ -407,7 +407,7 @@ public class Tool {

public void process() {
boolean exceptionWhenWritingLexerFile = false;
-        String lexerGrammarFileName = null;		// necessary at this scope to have access in the catch below
+        String lexerGrammarFileName;		// necessary at this scope to have access in the catch below

// Have to be tricky here when Maven or build tools call in and must new Tool()
// before setting options. The banner won't display that way!
@@ -599,8 +599,8 @@ public class Tool {
CompositeGrammar composite = new CompositeGrammar();
Grammar grammar = new Grammar(this, grammarFileName, composite);
composite.setDelegationRoot(grammar);
-        FileReader fr = null;
-        File f = null;
+        FileReader fr;
+        File f;

if (haveInputDir) {
f = new File(inputDirectory, grammarFileName);
@@ -883,7 +883,7 @@ public class Tool {
*/
public File getOutputDirectory(String fileNameWithPath) {

-        File outputDir = new File(getOutputDirectory());
+        File outputDir;
String fileDirectory;

// Some files are given to us without a PATH but should should
diff --git a/tool/src/main/java/org/antlr/analysis/DFA.java b/tool/src/main/java/org/antlr/analysis/DFA.java
index 8440cd6..93e5dd5 100644
--- a/tool/src/main/java/org/antlr/analysis/DFA.java
+++ b/tool/src/main/java/org/antlr/analysis/DFA.java
@@ -416,7 +416,7 @@ public class DFA {
transitionEdgeTables.setSize(this.getNumberOfStates());

// for each state in the DFA, fill relevant tables.
-		Iterator it = null;
+		Iterator it;
if ( getUserMaxLookahead()>0 ) {
it = states.iterator();
}
diff --git a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
index 0e4d393..efba97d 100644
--- a/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
+++ b/tool/src/main/java/org/antlr/analysis/DecisionProbe.java
@@ -506,7 +506,7 @@ public class DecisionProbe {
GrammarAST blockAST =
dfa.nfa.grammar.getDecisionBlockAST(dfa.decisionNumber);
//System.out.println("block with error = "+blockAST.toStringTree());
-		GrammarAST lastAltAST = null;
+		GrammarAST lastAltAST;
if ( blockAST.getChild(0).getType()==ANTLRParser.OPTIONS ) {
// if options, skip first child: ( options { ( = greedy false ) )
lastAltAST = (GrammarAST)blockAST.getChild(lastAlt.intValue());
diff --git a/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java b/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java
index c3f4432..a88b913 100644
--- a/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java
+++ b/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java
@@ -420,7 +420,7 @@ public class LL1Analyzer {
}

SemanticContext p = null;
-		SemanticContext p0 = null;
+		SemanticContext p0;
SemanticContext p1 = null;
if ( transition0.label.isSemanticPredicate() ) {
//System.out.println("pred "+transition0.label);
diff --git a/tool/src/main/java/org/antlr/analysis/LL1DFA.java b/tool/src/main/java/org/antlr/analysis/LL1DFA.java
index d8f6759..aeea5ea 100644
--- a/tool/src/main/java/org/antlr/analysis/LL1DFA.java
+++ b/tool/src/main/java/org/antlr/analysis/LL1DFA.java
@@ -138,7 +138,7 @@ public class LL1DFA extends DFA {
}

protected Label getLabelForSet(IntervalSet edgeSet) {
-		Label e = null;
+		Label e;
int atom = edgeSet.getSingleElement();
if ( atom != Label.INVALID ) {
e = new Label(atom);
diff --git a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
index e6d2050..3c926aa 100644
--- a/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
+++ b/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java
@@ -1234,7 +1234,7 @@ public class NFAToDFAConverter {
}

protected int resolveByChoosingFirstAlt(DFAState d, Set nondeterministicAlts) {
-		int winningAlt = 0;
+		int winningAlt;
if ( dfa.isGreedy() ) {
winningAlt = resolveByPickingMinAlt(d,nondeterministicAlts);
}
@@ -1271,7 +1271,7 @@ public class NFAToDFAConverter {
*  Return the min alt found.
*/
protected int resolveByPickingMinAlt(DFAState d, Set nondeterministicAlts) {
-		int min = Integer.MAX_VALUE;
+		int min;
if ( nondeterministicAlts!=null ) {
min = getMinAlt(nondeterministicAlts);
}
@@ -1384,7 +1384,7 @@ public class NFAToDFAConverter {
org.antlr.misc.BitSet ndSet = org.antlr.misc.BitSet.of(nondeterministicAlts);
org.antlr.misc.BitSet predSet = org.antlr.misc.BitSet.of(altToPredMap);
int nakedAlt = ndSet.subtract(predSet).getSingleElement();
-			SemanticContext nakedAltPred = null;
+			SemanticContext nakedAltPred;
if ( nakedAlt == max(nondeterministicAlts) ) {
// the naked alt is the last nondet alt and will be the default clause
nakedAltPred = new SemanticContext.TruePredicate();
diff --git a/tool/src/main/java/org/antlr/analysis/SemanticContext.java b/tool/src/main/java/org/antlr/analysis/SemanticContext.java
index 160a08e..0c59585 100644
--- a/tool/src/main/java/org/antlr/analysis/SemanticContext.java
+++ b/tool/src/main/java/org/antlr/analysis/SemanticContext.java
@@ -175,7 +175,7 @@ public abstract class SemanticContext {
STGroup templates,
DFA dfa)
{
-			ST eST = null;
+			ST eST;
if ( templates!=null ) {
if ( synpred ) {
eST = templates.getInstanceOf("evalSynPredicate");
@@ -458,7 +458,7 @@ public abstract class SemanticContext {
if (result == null)
result = operand.genExpr(generator, templates, dfa);

-				ST eST = null;
+				ST eST;
if ( templates!=null ) {
eST = templates.getInstanceOf("andPredicates");
}
@@ -508,7 +508,7 @@ public abstract class SemanticContext {
STGroup templates,
DFA dfa)
{
-			ST eST = null;
+			ST eST;
if ( templates!=null ) {
eST = templates.getInstanceOf("orPredicates");
}
@@ -553,7 +553,7 @@ public abstract class SemanticContext {
STGroup templates,
DFA dfa)
{
-			ST eST = null;
+			ST eST;
if ( templates!=null ) {
eST = templates.getInstanceOf("notPredicate");
}
diff --git a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
index 916b1fa..ac6a9f6 100644
--- a/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
+++ b/tool/src/main/java/org/antlr/codegen/CodeGenerator.java
@@ -202,7 +202,7 @@ public class CodeGenerator {
baseTemplates = dbgTemplates;
STGroup astTemplates = new STGroupFile(langDir+"/AST.stg");
astTemplates.importTemplates(dbgTemplates);
-				STGroup astParserTemplates = astTemplates;
+				STGroup astParserTemplates;
if ( grammar.type==Grammar.TREE_PARSER ) {
astParserTemplates = new STGroupFile(langDir+"/ASTTreeParser.stg");
astParserTemplates.importTemplates(astTemplates);
@@ -221,7 +221,7 @@ public class CodeGenerator {
else {
STGroup astTemplates = new STGroupFile(langDir+"/AST.stg");
astTemplates.importTemplates(coreTemplates);
-				STGroup astParserTemplates = astTemplates;
+				STGroup astParserTemplates;
if ( grammar.type==Grammar.TREE_PARSER ) {
astParserTemplates = new STGroupFile(langDir+"/ASTTreeParser.stg");
astParserTemplates.importTemplates(astTemplates);
@@ -582,8 +582,8 @@ public class CodeGenerator {
}
//System.out.println(" "+follow);

-        List tokenTypeList = null;
-        long[] words = null;
+        List tokenTypeList;
+        long[] words;
if ( follow.tokenTypeSet==null ) {
words = new long[1];
tokenTypeList = new ArrayList();
diff --git a/tool/src/main/java/org/antlr/tool/DOTGenerator.java b/tool/src/main/java/org/antlr/tool/DOTGenerator.java
index 4e906a3..98f1113 100644
--- a/tool/src/main/java/org/antlr/tool/DOTGenerator.java
+++ b/tool/src/main/java/org/antlr/tool/DOTGenerator.java
@@ -69,7 +69,7 @@ public class DOTGenerator {
return null;
}
// The output DOT graph for visualization
-		ST dot = null;
+		ST dot;
markedStates = new HashSet();
if ( startState instanceof DFAState ) {
dot = stlib.getInstanceOf("dfa");
@@ -203,7 +203,7 @@ public class DOTGenerator {
}

// make a DOT edge for each transition
-		ST edgeST = null;
+		ST edgeST;
for (int i = 0; i < s.getNumberOfTransitions(); i++) {
Transition edge = (Transition) s.transition(i);
if ( edge instanceof RuleClosureTransition ) {
@@ -296,7 +296,7 @@ public class DOTGenerator {
SemanticContext preds =
((DFAState)target).getGatedPredicatesInNFAConfigurations();
if ( preds!=null ) {
-				String predsStr = "";
+				String predsStr;
predsStr = "&&{"+
preds.genExpr(grammar.generator,
grammar.generator.getTemplates(), null).toString()
diff --git a/tool/src/main/java/org/antlr/tool/ErrorManager.java b/tool/src/main/java/org/antlr/tool/ErrorManager.java
index edea1c5..1119fe8 100644
--- a/tool/src/main/java/org/antlr/tool/ErrorManager.java
+++ b/tool/src/main/java/org/antlr/tool/ErrorManager.java
@@ -843,7 +843,7 @@ public class ErrorManager {
}
String templateName =
fieldName.substring("MSG_".length(),fieldName.length());
-			int msgID = 0;
+			int msgID;
try {
// get the constant value from this class object
msgID = f.getInt(ErrorManager.class);
diff --git a/tool/src/main/java/org/antlr/tool/Grammar.java b/tool/src/main/java/org/antlr/tool/Grammar.java
index fcb6ab3..443f96a 100644
--- a/tool/src/main/java/org/antlr/tool/Grammar.java
+++ b/tool/src/main/java/org/antlr/tool/Grammar.java
@@ -583,7 +583,7 @@ public class Grammar {
String onlyFileName = saneFile.substring(lastSlash+1, fileName.length());
if ( !builtFromString ) {
int lastDot = onlyFileName.lastIndexOf('.');
-			String onlyFileNameNoSuffix = null;
+			String onlyFileNameNoSuffix;
if ( lastDot < 0 ) {
ErrorManager.error(ErrorManager.MSG_FILENAME_EXTENSION_ERROR, fileName);
onlyFileNameNoSuffix = onlyFileName+GRAMMAR_FILE_EXTENSION;
@@ -610,7 +610,7 @@ public class Grammar {
public void parseAndBuildAST()
throws IOException
{
-		FileReader fr = null;
+		FileReader fr;
BufferedReader br = null;
try {
fr = new FileReader(fileName);
@@ -852,7 +852,7 @@ public class Grammar {
List<String> ruleNames,
List<String> delegateNames,
boolean filterMode) {
-		ST matchTokenRuleST = null;
+		ST matchTokenRuleST;
if ( filterMode ) {
matchTokenRuleST = new ST(
ARTIFICIAL_TOKENS_RULENAME+
@@ -1304,7 +1304,7 @@ outer:

//System.out.println("createLookaheadDFA(): "+enclosingRule+" dec "+decision+"; synprednames prev used "+synPredNamesUsedInDFA);
NFAState decisionStartState = getDecisionNFAStartState(decision);
-		long startDFA=0,stopDFA=0;
+		long startDFA=0,stopDFA;
if ( composite.watchNFAConversion ) {
System.out.println("--------------------\nbuilding lookahead DFA (d="
+decisionStartState.getDecisionNumber()+") for "+
@@ -2076,7 +2076,7 @@ outer:
}

public int getTokenType(String tokenName) {
-		Integer I = null;
+		Integer I;
if ( tokenName.charAt(0)=='\'') {
I = (Integer)composite.stringLiteralToTypeMap.get(tokenName);
}
@@ -2242,7 +2242,7 @@ outer:
String fullName = tool.getLibraryFile(gname);
FileReader fr = new FileReader(fullName);
br = new BufferedReader(fr);
-			Grammar delegateGrammar = null;
+			Grammar delegateGrammar;
delegateGrammar = new Grammar(tool, gname, composite);
delegateGrammar.label = label;

@@ -2411,8 +2411,8 @@ outer:
*  char vocabulary, compute an ANTLR-valid (possibly escaped) char literal.
*/
public String getTokenDisplayName(int ttype) {
-		String tokenName = null;
-		int index=0;
+		String tokenName;
+		int index;
// inside any target's char range and is lexer grammar?
if ( this.type==LEXER &&
ttype >= Label.MIN_CHAR_VALUE && ttype <= Label.MAX_CHAR_VALUE )
@@ -2996,7 +2996,7 @@ outer:
*  are both valid sets themselves, else we must tree like a BLOCK
*/
public boolean isValidSet(TreeToNFAConverter nfabuilder, GrammarAST t) {
-		boolean valid = true;
+		boolean valid;
try {
//System.out.println("parse BLOCK as set tree: "+t.toStringTree());
int alts = nfabuilder.testBlockAsSet(t);
@@ -3026,7 +3026,7 @@ outer:
if ( r==null ) {
return null;
}
-		IntSet elements = null;
+		IntSet elements;
//System.out.println("parsed tree: "+r.tree.toStringTree());
elements = nfabuilder.setRule(r.tree);
//System.out.println("elements="+elements);
@@ -3148,7 +3148,7 @@ outer:
}

public String grammarTreeToString(GrammarAST t, boolean showActions) {
-		String s = null;
+		String s;
try {
s = t.getLine()+":"+(t.getCharPositionInLine()+1)+": ";
s += new ANTLRTreePrinter(new CommonTreeNodeStream(t)).toString(this, showActions);
diff --git a/tool/src/main/java/org/antlr/tool/NFAFactory.java b/tool/src/main/java/org/antlr/tool/NFAFactory.java
index de52287..259a2b7 100644
--- a/tool/src/main/java/org/antlr/tool/NFAFactory.java
+++ b/tool/src/main/java/org/antlr/tool/NFAFactory.java
@@ -386,7 +386,7 @@ public class NFAFactory {
*/
public StateCluster build_AlternativeBlock(List alternativeStateClusters)
{
-        StateCluster result = null;
+        StateCluster result;
if ( alternativeStateClusters==null || alternativeStateClusters.size()==0 ) {
return null;
}
@@ -451,7 +451,7 @@ public class NFAFactory {
*  or, if A is a block, just add an empty alt to the end of the block
*/
public StateCluster build_Aoptional(StateCluster A) {
-        StateCluster g = null;
+        StateCluster g;
int n = nfa.grammar.getNumberOfAltsForDecisionNFA(A.left);
if ( n==1 ) {
// no decision, just wrap in an optional path
@@ -460,7 +460,7 @@ public class NFAFactory {
decisionState.setDescription("only alt of ()? block");
NFAState emptyAlt = newState();
emptyAlt.setDescription("epsilon path of ()? block");
-            NFAState blockEndNFAState = null;
+            NFAState blockEndNFAState;
blockEndNFAState = newState();
transitionBetweenStates(A.right, blockEndNFAState, Label.EPSILON);
blockEndNFAState.setDescription("end ()? block");
diff --git a/tool/src/main/java/org/antlr/tool/Rule.java b/tool/src/main/java/org/antlr/tool/Rule.java
index 8dbe300..541c035 100644
--- a/tool/src/main/java/org/antlr/tool/Rule.java
+++ b/tool/src/main/java/org/antlr/tool/Rule.java
@@ -420,7 +420,7 @@ public class Rule {
// no code?  must not have gen'd yet; forward ref
return null;
}
-		String labelName = null;
+		String labelName;
String existingLabelName =
(String)uniqueRefAST.code.getAttribute("label");
// reuse any label or list label if it exists
diff --git a/tool/src/main/java/org/antlr/tool/Strip.java b/tool/src/main/java/org/antlr/tool/Strip.java
index fcf7366..da2fb5e 100644
--- a/tool/src/main/java/org/antlr/tool/Strip.java
+++ b/tool/src/main/java/org/antlr/tool/Strip.java
@@ -56,7 +56,7 @@ public class Strip {

public void parseAndRewrite() throws Exception {
processArgs(args);
-        CharStream input = null;
+        CharStream input;
if ( filename!=null ) input = new ANTLRFileStream(filename);
else input = new ANTLRInputStream(System.in);
// BUILD AST
diff --git a/tool/src/test/java/org/antlr/test/BaseTest.java b/tool/src/test/java/org/antlr/test/BaseTest.java
index 5725149..ac7c821 100644
--- a/tool/src/test/java/org/antlr/test/BaseTest.java
+++ b/tool/src/test/java/org/antlr/test/BaseTest.java
@@ -377,7 +377,7 @@ public abstract class BaseTest {
process.waitFor();
stdoutVacuum.join();
stderrVacuum.join();
-			String output = null;
+			String output;
output = stdoutVacuum.toString();
if ( stderrVacuum.toString().length()>0 ) {
this.stderrDuringParse = stderrVacuum.toString();

