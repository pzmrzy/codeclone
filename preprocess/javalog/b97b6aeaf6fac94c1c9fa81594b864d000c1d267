commit b97b6aeaf6fac94c1c9fa81594b864d000c1d267
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Wed Mar 30 19:51:12 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Wed Mar 30 19:51:12 2011 -0800

Tokens appear in alphabetical order, and token types are assigned in numerical order to those ordered tokens

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8008]

diff --git a/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java b/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
index 4a88981..fba4f0e 100644
--- a/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
+++ b/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java
@@ -39,9 +39,9 @@ public class AssignTokenTypesBehavior extends AssignTokenTypesWalker {
protected static final Integer UNASSIGNED = Utils.integer(-1);
protected static final Integer UNASSIGNED_IN_PARSER_RULE = Utils.integer(-2);

-	protected Map<String,Integer> stringLiterals = new LinkedHashMap();
-	protected Map<String,Integer> tokens = new LinkedHashMap();
-	protected Map<String,String> aliases = new LinkedHashMap();
+	protected Map<String,Integer> stringLiterals = new TreeMap<String, Integer>();
+	protected Map<String,Integer> tokens = new TreeMap<String, Integer>();
+	protected Map<String,String> aliases = new TreeMap<String, String>();
protected Map<String,String> aliasesReverseIndex = new HashMap<String,String>();

/** Track actual lexer rule defs so we don't get repeated token defs in
diff --git a/tool/src/test/java/org/antlr/test/TestCompositeGrammars.java b/tool/src/test/java/org/antlr/test/TestCompositeGrammars.java
index c5c59f5..cb13bff 100644
--- a/tool/src/test/java/org/antlr/test/TestCompositeGrammars.java
+++ b/tool/src/test/java/org/antlr/test/TestCompositeGrammars.java
@@ -286,9 +286,9 @@ public class TestCompositeGrammars extends BaseTest {
g.parseAndBuildAST();
g.composite.assignTokenTypes();

-		String expectedTokenIDToTypeMap = "[A=4, WS=6, X=5]";
+		String expectedTokenIDToTypeMap = "[A=4, WS=5, X=6]";
String expectedStringLiteralToTypeMap = "{'a'=4}";
-		String expectedTypeToTokenList = "[A, X, WS]";
+		String expectedTypeToTokenList = "[A, WS, X]";

assertEquals(expectedTokenIDToTypeMap,
realElements(g.composite.tokenIDToTypeMap).toString());
@@ -770,9 +770,9 @@ public class TestCompositeGrammars extends BaseTest {
g.composite.assignTokenTypes();
g.composite.defineGrammarSymbols();

-		String expectedTokenIDToTypeMap = "[M=6, S=5, T=4]";
+		String expectedTokenIDToTypeMap = "[M=4, S=5, T=6]";
String expectedStringLiteralToTypeMap = "{}";
-		String expectedTypeToTokenList = "[T, S, M]";
+		String expectedTypeToTokenList = "[M, S, T]";

assertEquals(expectedTokenIDToTypeMap,
realElements(g.composite.tokenIDToTypeMap).toString());
@@ -833,9 +833,9 @@ public class TestCompositeGrammars extends BaseTest {
g.composite.assignTokenTypes();
g.composite.defineGrammarSymbols();

-		String expectedTokenIDToTypeMap = "[A=8, B=6, C=7, M=9, S=5, T=4]";
+		String expectedTokenIDToTypeMap = "[A=4, B=5, C=6, M=7, S=8, T=9]";
String expectedStringLiteralToTypeMap = "{}";
-		String expectedTypeToTokenList = "[T, S, B, C, A, M]";
+		String expectedTypeToTokenList = "[A, B, C, M, S, T]";

assertEquals(expectedTokenIDToTypeMap,
realElements(g.composite.tokenIDToTypeMap).toString());
@@ -879,9 +879,9 @@ public class TestCompositeGrammars extends BaseTest {
g.composite.assignTokenTypes();
g.composite.defineGrammarSymbols();

-		String expectedTokenIDToTypeMap = "[M=6, S=5, T=4]";
+		String expectedTokenIDToTypeMap = "[M=4, S=5, T=6]";
String expectedStringLiteralToTypeMap = "{}";
-		String expectedTypeToTokenList = "[T, S, M]";
+		String expectedTypeToTokenList = "[M, S, T]";

assertEquals(expectedTokenIDToTypeMap,
realElements(g.composite.tokenIDToTypeMap).toString());
diff --git a/tool/src/test/java/org/antlr/test/TestDFAConversion.java b/tool/src/test/java/org/antlr/test/TestDFAConversion.java
index c5d07ae..387b328 100644
--- a/tool/src/test/java/org/antlr/test/TestDFAConversion.java
+++ b/tool/src/test/java/org/antlr/test/TestDFAConversion.java
@@ -360,7 +360,7 @@ public class TestDFAConversion extends BaseTest {
"    ;");
String expecting =
".s0-ID->.s1\n" +
-			".s0-INT..FLOAT->:s3=>2\n" +
+			".s0-{FLOAT, INT}->:s3=>2\n" +
".s1-{synpred1_t}?->:s2=>1\n" +
".s1-{true}?->:s3=>2\n";
int[] unreachableAlts = null;
@@ -393,7 +393,7 @@ public class TestDFAConversion extends BaseTest {
"    ;");
String expecting =
".s0-ID->.s1\n" +
-			".s0-INT..FLOAT->:s3=>2\n" +
+			".s0-{FLOAT, INT}->:s3=>2\n" +
".s1-{synpred1_t}?->:s2=>1\n" +
".s1-{true}?->:s3=>2\n";
int[] unreachableAlts = null;
@@ -427,7 +427,7 @@ public class TestDFAConversion extends BaseTest {
"    ;");
String expecting =
".s0-ID->.s1\n" +
-			".s0-INT..FLOAT->:s4=>2\n" +
+			".s0-{FLOAT, INT}->:s4=>2\n" +
".s1-L->.s2\n" +
".s2-{synpred1_t}?->:s3=>1\n" +
".s2-{true}?->:s4=>2\n";
@@ -1100,7 +1100,7 @@ public class TestDFAConversion extends BaseTest {
"c : CASE E ;\n");
String expecting =
".s0-CASE->:s2=>1\n" +
-			".s0-LCURLY..E->:s1=>2\n";
+			".s0-E..RCURLY->:s1=>2\n";
int[] unreachableAlts = null;
int[] nonDetAlts = new int[] {1,2};
String ambigInput = "CASE";
@@ -1232,11 +1232,11 @@ As a result, alternative(s) 2 were disabled for that input
"type : I | F;");
// nondeterministic from left edge; no stop state
String expecting =
-			".s0-I..F->.s1\n" +
+			".s0-F..I->.s1\n" +
".s1-ID->:s2=>1\n";
int[] unreachableAlts = new int[] {2,3,4};
int[] nonDetAlts = new int[] {1,2,3,4};
-		String ambigInput = "I..F ID";
+		String ambigInput = "F..I ID";
int[] danglingAlts = null;
int numWarnings = 2;
checkDecision(g, 1, expecting, unreachableAlts,
@@ -1253,9 +1253,9 @@ As a result, alternative(s) 2 were disabled for that input
"\n" +
"esc : SLASH ( N | D03 (D07)? ) ;");
String expecting =
+			".s0-D03..N->:s2=>2\n" +
".s0-R->:s3=>3\n" +
-			".s0-SLASH->:s1=>1\n" +
-			".s0-{L, N..D07}->:s2=>2\n";
+			".s0-SLASH->:s1=>1\n";
int[] unreachableAlts = null;
int[] nonDetAlts = new int[] {1,2};
String ambigInput = "D07";
diff --git a/tool/src/test/java/org/antlr/test/TestInterpretedParsing.java b/tool/src/test/java/org/antlr/test/TestInterpretedParsing.java
index 3030bd4..a575139 100644
--- a/tool/src/test/java/org/antlr/test/TestInterpretedParsing.java
+++ b/tool/src/test/java/org/antlr/test/TestInterpretedParsing.java
@@ -105,7 +105,7 @@ public class TestInterpretedParsing extends BaseTest {
ParseTree t = parseEngine.parse("prog");
String result = t.toStringTree();
String expecting =
-			"(<grammar p> (prog while x { (assign i = (expr 1) MismatchedTokenException(5!=9))))";
+			"(<grammar p> (prog while x { (assign i = (expr 1) MismatchedTokenException(6!=10))))";
assertEquals(expecting, result);
}

@@ -140,7 +140,7 @@ public class TestInterpretedParsing extends BaseTest {
ParseTree t = parseEngine.parse("prog");
String result = t.toStringTree();
String expecting =
-			"(<grammar p> (prog while x { (assign i = (expr MismatchedSetException(9!={5,10,11})))))";
+			"(<grammar p> (prog while x { (assign i = (expr MismatchedSetException(10!={5,6,7})))))";
assertEquals(expecting, result);
}

@@ -175,7 +175,7 @@ public class TestInterpretedParsing extends BaseTest {
ParseTree t = parseEngine.parse("prog");
String result = t.toStringTree();
String expecting =
-			"(<grammar p> (prog while x { (assign i = (expr NoViableAltException(9@[4:1: expr : ( INT | FLOAT | ID );])))))";
+			"(<grammar p> (prog while x { (assign i = (expr NoViableAltException(10@[4:1: expr : ( INT | FLOAT | ID );])))))";
assertEquals(expecting, result);
}

diff --git a/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java b/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
index 279b9a3..7b2d77b 100644
--- a/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
+++ b/tool/src/test/java/org/antlr/test/TestSemanticPredicates.java
@@ -108,8 +108,9 @@ public class TestSemanticPredicates extends BaseTest {
"a : ( {p1}? A )+ (A)+;");
String expecting =
".s0-A->.s1\n" +
-			".s1-{!(p1)}?->:s2=>1\n" +
-			".s1-{p1}?->:s3=>2\n";       // loop back
+			".s1-{p1}?->:s2=>1\n" +
+			".s1-{true}?->:s3=>2\n";       // loop back
+        checkDecision(g, 1, expecting, null, null, null, null, null, 0, false);
}

@Test public void testAndPredicates() throws Exception {

