commit 6afe2da1b0abe2b9ad5ec360ff843ef9615c2d02
Author:     acondit <acondit@parrt.spork>
AuthorDate: Thu Jan 26 14:26:10 2012 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Thu Jan 26 14:26:10 2012 -0800

More changes resulting from File renaming to match Java src names.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 9907]

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/AST.stg
index 4e9215e..6a5ba1c 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/AST.stg
@@ -61,7 +61,7 @@ NSArray *ruleNames;
@genericParser.init() ::= <<
/* AST genericParser.init */
<@super.init()>
-[self setTreeAdaptor:[[ANTLRCommonTreeAdaptor newTreeAdaptor] retain]];
+[self setTreeAdaptor:[[CommonTreeAdaptor newTreeAdaptor] retain]];
>>

@genericParser.dealloc() ::= <<
@@ -73,20 +73,20 @@ NSArray *ruleNames;
/* Add an adaptor property that knows how to build trees */
parserMemVars() ::= <<
/* AST parserMemVars */
-id\<ANTLRTreeAdaptor> treeAdaptor;
+id\<TreeAdaptor> treeAdaptor;
>>

/* Add an adaptor property that knows how to build trees */
parserProperties() ::= <<
/* AST parserProperties */
-@property (retain, getter=getTreeAdaptor, setter=setTreeAdaptor:) id\<ANTLRTreeAdaptor> treeAdaptor;
+@property (retain, getter=getTreeAdaptor, setter=setTreeAdaptor:) id\<TreeAdaptor> treeAdaptor;
>>

/** Declaration of additional tree support methods - go in interface of parserHeaderFile() */
parserMethodsDecl() ::= <<
/* AST parserMethodsDecl */
-- (id\<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void) setTreeAdaptor:(id\<ANTLRTreeAdaptor>)theTreeAdaptor;
+- (id\<TreeAdaptor>) getTreeAdaptor;
+- (void) setTreeAdaptor:(id\<TreeAdaptor>)theTreeAdaptor;
>>

/* Add an adaptor property that knows how to build trees */
@@ -98,12 +98,12 @@ parserSynthesize() ::= <<
/** Definition of addition tree support methods - go in implementation of genericParser() */
parserMethods() ::= <<
/* AST parserMethods */
-- (id\<ANTLRTreeAdaptor>) getTreeAdaptor
+- (id\<TreeAdaptor>) getTreeAdaptor
{
return treeAdaptor;
}

-- (void) setTreeAdaptor:(id\<ANTLRTreeAdaptor>)aTreeAdaptor
+- (void) setTreeAdaptor:(id\<TreeAdaptor>)aTreeAdaptor
{
if (aTreeAdaptor != treeAdaptor) {
treeAdaptor = aTreeAdaptor;
@@ -114,20 +114,20 @@ parserMethods() ::= <<
/** addition memVars for returnscopes */
@returnScopeInterface.memVars() ::= <<
/* AST returnScopeInterface.memVars */
-<recognizer.ASTLabelType; null="ANTLRCommonTree"> *tree;
+<recognizer.ASTLabelType; null="CommonTree"> *tree;
>>

/** the interface of returnScope properties */
@returnScopeInterface.properties() ::= <<
/* AST returnScopeInterface.properties */
-@property (retain, getter=getTree, setter=setTree:) <recognizer.ASTLabelType; null="ANTLRCommonTree"> *tree;
+@property (retain, getter=getTree, setter=setTree:) <recognizer.ASTLabelType; null="CommonTree"> *tree;
>>

/** the interface of returnScope methodsDecl */
@returnScopeInterface.methodsDecl() ::= <<
/* AST returnScopeInterface.methodsDecl */
-- (<recognizer.ASTLabelType; null="ANTLRCommonTree"> *)getTree;<\n>
-- (void) setTree:(<recognizer.ASTLabelType; null="ANTLRCommonTree"> *)aTree;<\n>
+- (<recognizer.ASTLabelType; null="CommonTree"> *)getTree;<\n>
+- (void) setTree:(<recognizer.ASTLabelType; null="CommonTree"> *)aTree;<\n>
>>

/** the implementation of returnScope synthesize */
@@ -147,8 +147,8 @@ parserMethods() ::= <<
- (void) setTree:(<ASTLabelType> *)aTree
{
if (tree != aTree) {
-        if ( tree ) [tree release];
-        if ( aTree ) [aTree retain];
+        if (tree != nil) [tree release];
+        if (aTree != nil) [aTree retain];
tree = aTree;
}
}
@@ -174,11 +174,11 @@ ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,
ruleDescriptor.wildcardTreeListLabels]:{it | <ASTLabelType> *<it.label.text>_tree=nil;}; separator="\n">
<ruleDescriptor.tokenListLabels:{it | <ASTLabelType> *<it.label.text>_tree = nil;}; separator="\n">
-<ruleDescriptor.allTokenRefsInAltsWithRewrites:{it | ANTLRRewriteRuleTokenStream *stream_<it> =
-    [[ANTLRRewriteRule<rewriteElementType>Stream newANTLRRewriteRule<rewriteElementType>Stream:treeAdaptor
+<ruleDescriptor.allTokenRefsInAltsWithRewrites:{it | RewriteRuleTokenStream *stream_<it> =
+    [[RewriteRule<rewriteElementType>Stream newRewriteRule<rewriteElementType>Stream:treeAdaptor
description:@"token <it>"] retain];}; separator="\n">
-<ruleDescriptor.allRuleRefsInAltsWithRewrites:{it | ANTLRRewriteRuleSubtreeStream *stream_<it> =
-    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
+<ruleDescriptor.allRuleRefsInAltsWithRewrites:{it | RewriteRuleSubtreeStream *stream_<it> =
+    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
description:@"rule <it>"] retain];}; separator="\n">
>>

@@ -338,32 +338,32 @@ root_0 = (<ASTLabelType> *)[[[treeAdaptor class] newEmptyTree] retain];<\n>

rewriteCodeLabels() ::= <<
<referencedTokenLabels
-    :{it | ANTLRRewriteRule<rewriteElementType>Stream *stream_<it> =
-    [[ANTLRRewriteRule<rewriteElementType>Stream newANTLRRewriteRule<rewriteElementType>Stream:treeAdaptor description:@"token <it>" element:<it>] retain];};
+    :{it | RewriteRule<rewriteElementType>Stream *stream_<it> =
+    [[RewriteRule<rewriteElementType>Stream newRewriteRule<rewriteElementType>Stream:treeAdaptor description:@"token <it>" element:<it>] retain];};
separator="\n"
>
-<referencedTokenListLabels:{it | ANTLRRewriteRule<rewriteElementType>Stream *stream_<it> =
-    [[ANTLRRewriteRule<rewriteElementType>Stream newANTLRRewriteRule<rewriteElementType>Stream:treeAdaptor
+<referencedTokenListLabels:{it | RewriteRule<rewriteElementType>Stream *stream_<it> =
+    [[RewriteRule<rewriteElementType>Stream newRewriteRule<rewriteElementType>Stream:treeAdaptor
description:@"token <it>" elements:list_<it>] retain];};
separator="\n"
>
<referencedWildcardLabels:{it | RewriteRuleSubtreeStream stream_<it> =
-    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
+    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
description:"wildcard <it>" element:<it>] retain];};
separator="\n"
>
<referencedWildcardListLabels:{it | RewriteRuleSubtreeStream stream_<it> =
-    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
+    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
descriptor:"wildcard <it>" elements:list_<it>] retain];};
separator="\n"
>
-<referencedRuleLabels:{it | ANTLRRewriteRuleSubtreeStream *stream_<it> =
-    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
+<referencedRuleLabels:{it | RewriteRuleSubtreeStream *stream_<it> =
+    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
description:@"token <it>" element:<it>!=nil?[<it> getTree]:nil] retain];};
separator="\n"
>
-<referencedRuleListLabels:{it | ANTLRRewriteRuleSubtreeStream *stream_<it> =
-    [[ANTLRRewriteRuleSubtreeStream newANTLRRewriteRuleSubtreeStream:treeAdaptor
+<referencedRuleListLabels:{it | RewriteRuleSubtreeStream *stream_<it> =
+    [[RewriteRuleSubtreeStream newRewriteRuleSubtreeStream:treeAdaptor
description:@"token <it>" elements:list_<it>] retain];};
separator="\n"
>
@@ -407,7 +407,7 @@ rewritePositiveClosureBlock(
// <fileName>:<description>
{
if ( !(<referencedElements:{el | [stream_<el> hasNext]}; separator=" || ">) ) {
-    @throw [ANTLRRewriteEarlyExitException newException];
+    @throw [RewriteEarlyExitException newException];
}
while ( <referencedElements:{el | [stream_<el> hasNext]}; separator=" || "> ) {
<alt>
@@ -503,7 +503,7 @@ rewriteRuleRef(rule) ::= <<
>>

rewriteRuleRefRoot(rule) ::= <<
-root_<treeLevel> = (<ASTLabelType> *)[treeAdaptor becomeRoot:(id\<ANTLRTree>)[stream_<rule> nextNode] old:root_<treeLevel>];<\n>
+root_<treeLevel> = (<ASTLabelType> *)[treeAdaptor becomeRoot:(id\<Tree>)[stream_<rule> nextNode] old:root_<treeLevel>];<\n>
>>

rewriteNodeAction(action) ::= <<
@@ -543,9 +543,9 @@ createImaginaryNode(tokenType,terminalOptions,args) ::= <<
[<terminalOptions.node> new<terminalOptions.node>:<tokenType> <if(args)>, <args; separator=", "><endif>]
<else>
<if(args)>
-        [[treeAdaptor createTree:<tokenType> <if(first(args))>FromToken:<first(args)><endif> <if(first(rest(args)))>Text:<first(rest(args))><else>Text:@"<tokenType>"<endif>] retain]
+        [treeAdaptor createTree:<tokenType> <if(first(args))>FromToken:<first(args)><endif> <if(first(rest(args)))>Text:<first(rest(args))><else>Text:@"<tokenType>"<endif>]
<else>
-        [[treeAdaptor createTree:<tokenType> Text:@"<tokenType>"] retain]
+        [treeAdaptor createTree:<tokenType> Text:@"<tokenType>"]
<endif>
<endif>
>>
@@ -555,7 +555,7 @@ createRewriteNodeFromElement(token,terminalOptions,args) ::= <<
[<terminalOptions.node> new<terminalOptions.node>:[stream_<token> nextToken]<if(args)>, <args; separator=", "><endif>]
<else>
<if(args)> <! must create new node from old !>
-        [[treeAdaptor createTree:<token> Text:<first(rest(args))> <args; separator=", ">] retain]
+        [treeAdaptor createTree:<token> Text:<first(rest(args))> <args; separator=", ">]
<else>
[stream_<token> nextNode]
<endif>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTDbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTDbg.stg
index 8756fa5..210cfcd 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTDbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTDbg.stg
@@ -30,21 +30,21 @@
*  hierarchy is set up as ASTDbg : AST : Dbg : Java by code generator.
*/
parserMembers() ::= <<
-ANTLRDebugTreeAdaptor *adaptor = [ANTLRDebugTreeAdaptor newTreeAdaptor:(id)dbg Adaptor:[ANTLRCommonTreeAdaptor newTreeAdaptor]];
+DebugTreeAdaptor *adaptor = [DebugTreeAdaptor newTreeAdaptor:(id)dbg Adaptor:[CommonTreeAdaptor newTreeAdaptor]];

// fix this
-- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+- (void) setTreeAdaptor:(id<TreeAdaptor>)anAdaptor
{
-    adaptor = [ANTLRDebugTreeAdaptor newTreeAdaptor:dbg Adaptor:anAdaptor];
+    adaptor = [DebugTreeAdaptor newTreeAdaptor:dbg Adaptor:anAdaptor];
<if(grammar.grammarIsRoot)>
-    adaptor = [ANTLRDebugTreeAdaptor newTreeAdaptor:adaptor withDBG:dbg];
+    adaptor = [DebugTreeAdaptor newTreeAdaptor:adaptor withDBG:dbg];
<else>
-    adaptor = (ANTLRDebugTreeAdaptor *)adaptor; // delegator sends dbg adaptor
+    adaptor = (DebugTreeAdaptor *)adaptor; // delegator sends dbg adaptor
<endif><\n>
<grammar.directDelegates:{g|[<g:delegateName()> setTreeAdaptor:adaptor];}>
}

-- (id<ANTLRTreeAdaptor>)getTreeAdaptor
+- (id<TreeAdaptor>)getTreeAdaptor
{
return adaptor;
}<\n>
@@ -55,10 +55,10 @@ parserCtorBody() ::= <<
>>

createListenerAndHandshake() ::= <<
-ANTLRDebugEventSocketProxy proxy =
-    [ANTLRDebugEventSocketProxy newANTLRDebugEventSocketProxy:self, port, <if(TREE_PARSER)>[input getTreeAdaptor]<else>adaptor<endif>];
+DebugEventSocketProxy proxy =
+    [DebugEventSocketProxy newDebugEventSocketProxy:self, port, <if(TREE_PARSER)>[input getTreeAdaptor]<else>adaptor<endif>];
[self setDebugListener:proxy];
-[self set<inputStreamType>:[ANTLRANTLRDebug<inputStreamType> newANTLRDebug<inputStreamType>:input with:proxy]];
+[self set<inputStreamType>:[Debug<inputStreamType> newDebug<inputStreamType>:input with:proxy]];
try {
[proxy handshake];
}
@@ -68,13 +68,13 @@ try {
>>

@ctorForRootGrammar.finally() ::= <<
-ANTLRCommonTreeAdaptor *adap = [ANTLRCommonTreeAdaptor newTreeAdaptor];
+CommonTreeAdaptor *adap = [CommonTreeAdaptor newTreeAdaptor];
[self setTreeAdaptor:adap];
[proxy setTreeAdaptor:adap];
>>

@ctorForProfilingRootGrammar.finally() ::=<<
-ANTLRCommonTreeAdaptor *adap = [ANTLRCommonTreeAdaptor newTreeAdaptor];
+CommonTreeAdaptor *adap = [CommonTreeAdaptor newTreeAdaptor];
[self setTreeAdaptor:adap];
[proxy setTreeAdaptor:adap];
>>
@@ -83,11 +83,11 @@ ANTLRCommonTreeAdaptor *adap = [ANTLRCommonTreeAdaptor newTreeAdaptor];

@ctorForPredefinedListener.finally() ::=<<
<if(grammar.grammarIsRoot)> <! don't create new adaptor for delegates !>
-ANTLRCommonTreeAdaptor *adap = [ANTLRCommonTreeAdaptor newTreeAdaptor];
+CommonTreeAdaptor *adap = [CommonTreeAdaptor newTreeAdaptor];
[self setTreeAdaptor:adap];<\n>
<endif>
>>

-@treeParserHeaderFile.superClassName ::= "ANTLRDebugTreeParser"
+@treeParserHeaderFile.superClassName ::= "DebugTreeParser"

@rewriteElement.pregen() ::= "[debugListener locationLine:<e.line> column:<e.pos>];"
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTParser.stg
index 036d53e..4eed274 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTParser.stg
@@ -193,7 +193,7 @@ wildcardRuleRoot(token,label,elementIndex,terminalOptions) ::= <<
createNodeFromToken(label,terminalOptions) ::= <<
/* ASTParser createNodeFromToken */
<if(terminalOptions.node)>
-[ANTLR<terminalOptions.node> newANTLR<terminalOptions.node>:<label>] <! new MethodNode(IDLabel) !>
+[<terminalOptions.node> new<terminalOptions.node>:<label>] <! new MethodNode(IDLabel) !>
<else>
(<ASTLabelType> *)[[treeAdaptor create:<label>] retain]
<endif>
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTTreeParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTTreeParser.stg
index 56959a3..9eb45dd 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTTreeParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ASTTreeParser.stg
@@ -41,14 +41,14 @@
/* addition memVars for returnscopes */
@returnScopeInterface.memVars() ::= <<
/* ASTTreeParser returnScopeInterface.memVars */
-<recognizer.ASTLabelType; null="ANTLRCommonTree"> *tree;
+<recognizer.ASTLabelType; null="CommonTree"> *tree;
>>

/** the interface of returnScope methodsDecl */
@returnScopeInterface.methodsDecl() ::= <<
/* ASTTreeParser returnScopeInterface.methodsDecl */
-- (<recognizer.ASTLabelType; null="ANTLRCommonTree"> *)getTree;
-- (void) setTree:(<recognizer.ASTLabelType; null="ANTLRCommonTree"> *)aTree;<\n>
+- (<recognizer.ASTLabelType; null="CommonTree"> *)getTree;
+- (void) setTree:(<recognizer.ASTLabelType; null="CommonTree"> *)aTree;<\n>
>>

/** the implementation of returnScope methods */
@@ -62,8 +62,8 @@
- (void) setTree:(<ASTLabelType> *)aTree
{
if (tree != aTree) {
-        if ( tree ) [tree release];
-        if ( aTree ) [aTree retain];
+        if (tree != nil) [tree release];
+        if (aTree != nil) [aTree retain];
tree = aTree;
}
}
@@ -78,7 +78,7 @@
>>

@returnScopeProperties() ::= <<
-@property (retain) <recognizer.ASTLabelType; null="ANTLRCommonTree"> *tree;
+@property (retain) <recognizer.ASTLabelType; null="CommonTree"> *tree;
>>

/** Add a variable to track last element matched */
@@ -127,15 +127,15 @@ if ( _first_<enclosingTreeLevel>==nil ) _first_<enclosingTreeLevel> = <root.el.l
<endif>
<actionsAfterRoot:element()>
<if(nullableChildList)>
-if ( [input LA:1] == ANTLRTokenTypeDOWN ) {
-    [self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; <checkRuleBacktrackFailure()>
+if ( [input LA:1] == TokenTypeDOWN ) {
+    [self match:input TokenType:TokenTypeDOWN Follow:nil]; <checkRuleBacktrackFailure()>
<children:element()>
-    [self match:input TokenType:ANTLRTokenTypeUP Follow:nil]; <checkRuleBacktrackFailure()>
+    [self match:input TokenType:TokenTypeUP Follow:nil]; <checkRuleBacktrackFailure()>
}
<else>
-[self match:input TokenType:ANTLRTokenTypeDOWN Follow:nil]; <checkRuleBacktrackFailure()>
+[self match:input TokenType:TokenTypeDOWN Follow:nil]; <checkRuleBacktrackFailure()>
<children:element()>
-[self match:input TokenType:ANTLRTokenTypeUP Follow:nil]; <checkRuleBacktrackFailure()>
+[self match:input TokenType:TokenTypeUP Follow:nil]; <checkRuleBacktrackFailure()>
<endif>
<if(!rewriteMode)>
[treeAdaptor addChild:root_<treeLevel> toTree:root_<enclosingTreeLevel>];
@@ -163,7 +163,7 @@ _last = (<ASTLabelType> *)[input LT:1];
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(terminalOptions.node)>
-    <label>_tree = [ANTLR<terminalOptions.node> newANTLR<terminalOptions.node>:<label>];
+    <label>_tree = [<terminalOptions.node> new<terminalOptions.node>:<label>];
<else>
<label>_tree = (<ASTLabelType> *)[treeAdaptor dupNode:<label>];
<endif><\n>
@@ -190,7 +190,7 @@ _last = (<ASTLabelType> *)[input LT:1];
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(terminalOptions.node)>
-<label>_tree = [ANTLR<terminalOptions.node> newANTLR<terminalOptions.node>:<label>];
+<label>_tree = [<terminalOptions.node> new<terminalOptions.node>:<label>];
<else>
<label>_tree = (<ASTLabelType> *)[treeAdaptor dupNode:<label>];
<endif><\n>
@@ -231,7 +231,7 @@ _last = (<ASTLabelType> *)[input LT:1];
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(terminalOptions.node)>
-<label>_tree = [ANTLR<terminalOptions.node> newANTLR<terminalOptions.node>:<label>];
+<label>_tree = [<terminalOptions.node> new<terminalOptions.node>:<label>];
<else>
<label>_tree = (<ASTLabelType> *)[adaptor dupNode:<label>];
<endif><\n>
@@ -260,7 +260,7 @@ matchSetRuleRoot(s,label,terminalOptions,elementIndex,debug) ::= <<
<if(!rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> ) {<endif>
<if(terminalOptions.node)>
-<label>_tree = [ANTLR<terminalOptions.node> newANTLR<terminalOptions.node>:<label>];
+<label>_tree = [<terminalOptions.node> new<terminalOptions.node>:<label>];
<else>
<label>_tree = (<ASTLabelType> *)[adaptor dupNode:<label>];
<endif><\n>
@@ -347,7 +347,7 @@ createRewriteNodeFromElement(token,terminalOptions,scope) ::= <<
/* ASTTreeParser createRewriteNodeFromElement */
<if(terminalOptions.node)>
<! new <terminalOptions.node>(stream_<token>.nextNode()) !>
-[[[ANTLR<terminalOptions.node>(stream_<token> alloc] init] nextNode];
+[[[<terminalOptions.node>(stream_<token> alloc] init] nextNode];
<else>
<! stream_<token>.nextNode() !>
[stream_<token> nextNode]
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/Dbg.stg b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/Dbg.stg
index 6c8b42d..5bad893 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/Dbg.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/Dbg.stg
@@ -30,7 +30,7 @@
*/
@headerFile.imports() ::= <<
<@super.imports()>
-#import \<ANTLR/ANTLRDebug.h>
+#import \<ANTLR/Debug.h>
>>

@parserHeaderFile.memVars() ::= <<
@@ -81,7 +81,7 @@ AMutableArray *ruleNames = [AMutableArray arrayWithArray:{
[(Profiler)dbg examineRuleMemoization:input, ruleIndex, <grammar.composite.rootGrammar.recognizerName>.ruleNames objectAtIndex:ruleIndex];
return super.alreadyParsedRule(input, ruleIndex);
}<\n>
-- (void) memoize:(id<ANTLRIntStream>)input RuleIndex:(NSInteger)ruleIndex StartIndex:(NSInteger)ruleStartIndex
+- (void) memoize:(id<IntStream>)input RuleIndex:(NSInteger)ruleIndex StartIndex:(NSInteger)ruleStartIndex
{
[((Profiler)dbg) memoize:input RuleIndex:ruleIndex StartIndex:ruleStartIndex [<grammar.composite.rootGrammar.recognizerName> ruleNames[ruleIndex]];
[super memoize:input RuleIndex:ruleIndex StartIndex:ruleStartIndex];
@@ -111,7 +111,7 @@ ruleNames = [NSArray arrayWithObjects:<rules:{rST | @"<rST.ruleName>"}; separato
>>

/* bug: can't use @super.superClassName()> */
-@parserHeaderFile.superClassName() ::= "ANTLRDebug<if(TREE_PARSER)>Tree<endif>Parser"
+@parserHeaderFile.superClassName() ::= "Debug<if(TREE_PARSER)>Tree<endif>Parser"

@rule.preamble() ::= <<
@try { [debugListener enterRule:@"<ruleName>"];
@@ -209,14 +209,14 @@ dfaDecision(decisionNumber,description) ::= <<
// isCyclicDecision = YES;
<super.dfaDecision(...)>
}
-@catch (ANTLRNoViableAltException *nvae) {
+@catch (NoViableAltException *nvae) {
[debugListener recognitionException:nvae];
@throw nvae;
}
>>

@cyclicDFA.errorMethod() ::= <<
--(void) error:(ANTLRNoViableAltException *)nvae
+-(void) error:(NoViableAltException *)nvae
{
[[recognizer debugListener] recognitionException:nvae];
}
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ObjC.stg b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ObjC.stg
index dbba0ff..07c1561 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ObjC.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ObjC.stg
@@ -230,7 +230,7 @@ lexerHeaderFile( LEXER,
generatedTimestamp,
trace,
scopes,
-            superClass="ANTLRLexer"
+            superClass="Lexer"
) ::=
<<

@@ -265,7 +265,7 @@ lexerHeaderFile( LEXER,
/* ObjC end of actions.lexer.memVars */
}
+ (void) initialize;
-+ (<className()> *)new<className()>WithCharStream:(id\<ANTLRCharStream>)anInput;
++ (<className()> *)new<className()>WithCharStream:(id\<CharStream>)anInput;
/* ObjC start actions.lexer.methodsDecl */
<actions.lexer.methodsDecl>
/* ObjC end actions.lexer.methodsDecl */
@@ -294,8 +294,8 @@ lexer(  grammar,
rules,
numRules,
filterMode,
-        labelType="ANTLRCommonToken",
-        superClass="ANTLRLexer"
+        labelType="CommonToken",
+        superClass="Lexer"
) ::= <<
<cyclicDFAs:cyclicDFA()>

@@ -311,7 +311,7 @@ lexer(  grammar,

+ (void) initialize
{
-    [ANTLRBaseRecognizer setGrammarFileName:@"<fileName>"];
+    [BaseRecognizer setGrammarFileName:@"<fileName>"];
}

+ (NSString *) tokenNameForType:(NSInteger)aTokenType
@@ -319,24 +319,24 @@ lexer(  grammar,
return [[self getTokenNames] objectAtIndex:aTokenType];
}

-+ (<grammar.recognizerName> *)new<grammar.recognizerName>WithCharStream:(id\<ANTLRCharStream>)anInput
++ (<grammar.recognizerName> *)new<grammar.recognizerName>WithCharStream:(id\<CharStream>)anInput
{
return [[<grammar.recognizerName> alloc] initWithCharStream:anInput];
}

-- (id) initWithCharStream:(id\<ANTLRCharStream>)anInput
+- (id) initWithCharStream:(id\<CharStream>)anInput
{
-    self = [super initWithCharStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:<numRules>+1]];
+    self = [super initWithCharStream:anInput State:[RecognizerSharedState newRecognizerSharedStateWithRuleLen:<numRules>+1]];
if ( self != nil ) {
<if(memoize)>
if ( state.ruleMemo == nil ) {
-            state.ruleMemo = [[ANTLRRuleStack newANTLRRuleStackWithSize:<numRules>+1] retain];
+            state.ruleMemo = [[RuleStack newRuleStackWithSize:<numRules>+1] retain];
}
if ( [state.ruleMemo count] == 0 ) {
// initialize the memoization cache - the indices are 1-based in the runtime code!
<! [state.ruleMemo addObject:[NSNull null]];     /* dummy entry to ensure 1-basedness. */ !>
for (NSInteger i = 0; i \< <numRules>; i++) {
-                [state.ruleMemo addObject:[ANTLRHashRule newANTLRHashRuleWithLen:17]];
+                [state.ruleMemo addObject:[HashRule newHashRuleWithLen:17]];
}
}
<endif>
@@ -385,14 +385,14 @@ lexer(  grammar,
*  at backtracking==1.
*/
filteringNextToken() ::= <<
-- (id\<ANTLRToken>) nextToken
+- (id\<Token>) nextToken
{
while (YES) {
-        if ( [input LA:1] == ANTLRCharStreamEOF ) {
+        if ( [input LA:1] == CharStreamEOF ) {
return [<labelType> eofToken];
}
state.token = nil;
-        state.channel = ANTLRTokenChannelDefault;
+        state.channel = TokenChannelDefault;
state.tokenStartCharIndex = input.index;
state.tokenStartCharPositionInLine = input.charPositionInLine;
state.tokenStartLine = input.line;
@@ -413,7 +413,7 @@ filteringNextToken() ::= <<
return state.token;
}
}
-        @catch (ANTLRRecognitionException *re) {
+        @catch (RecognitionException *re) {
// shouldn't happen in backtracking mode, but...
[self reportError:re];
[self recover:re];
@@ -421,14 +421,14 @@ filteringNextToken() ::= <<
}
}

-- (void)memoize:(id\<ANTLRIntStream\>)anInput
+- (void)memoize:(id\<IntStream\>)anInput
RuleIndex:(NSInteger)ruleIndex
StartIndex:(NSInteger)ruleStartIndex
{
if ( state.backtracking > 1 ) [super memoize:anInput RuleIndex:ruleIndex StartIndex:ruleStartIndex];
}

-- (BOOL)alreadyParsedRule:(id\<ANTLRIntStream\>)anInput RuleIndex:(NSInteger)ruleIndex
+- (BOOL)alreadyParsedRule:(id\<IntStream\>)anInput RuleIndex:(NSInteger)ruleIndex
{
if ( state.backtracking > 1 ) return [super alreadyParsedRule:anInput RuleIndex:ruleIndex];
return NO;
@@ -464,10 +464,10 @@ parserHeaderFile( LEXER,
trace,
scopes,
literals,
-            superClass="ANTLRParser"
+            superClass="Parser"
) ::= <<
/* parserHeaderFile */
-<genericParserHeaderFile(inputStreamType="id\<ANTLRTokenStream>",...)>
+<genericParserHeaderFile(inputStreamType="id\<TokenStream>",...)>
>>

treeParserHeaderFile( LEXER,
@@ -495,10 +495,10 @@ treeParserHeaderFile( LEXER,
trace,
scopes,
literals,
-            superClass="ANTLRTreeParser"
+            superClass="TreeParser"
) ::= <<
/* treeParserHeaderFile */
-<genericParserHeaderFile(inputStreamType="id\<ANTLRTreeNodeStream>",...)>
+<genericParserHeaderFile(inputStreamType="id\<TreeNodeStream>",...)>
>>

genericParserHeaderFile( LEXER,
@@ -614,12 +614,12 @@ parser( grammar,
rules,
numRules,
bitsets,
-        ASTLabelType="ANTLRCommonTree",
-        superClass="ANTLRParser",
-        labelType="ANTLRCommonToken",
+        ASTLabelType="CommonTree",
+        superClass="Parser",
+        labelType="CommonToken",
members={<actions.parser.members>}
) ::= <<
-<genericParser(inputStreamType="id\<ANTLRTokenStream>", rewriteElementType="Token", ...)>
+<genericParser(inputStreamType="id\<TokenStream>", rewriteElementType="Token", ...)>
>>

/** How to generate a tree parser; same as parser except the input
@@ -636,11 +636,11 @@ treeParser( grammar,
bitsets,
filterMode,
labelType={<ASTLabelType>},
-        ASTLabelType="ANTLRCommonTree",
-        superClass={<if(filterMode)><if(buildAST)>ANTLRTreeRewriter<else>ANTLRTreeFilter<endif><else>ANTLRTreeParser<endif>},
+        ASTLabelType="CommonTree",
+        superClass={<if(filterMode)><if(buildAST)>TreeRewriter<else>TreeFilter<endif><else>TreeParser<endif>},
members={<actions.treeparser.members>}
) ::= <<
-<genericParser(inputStreamType="id\<ANTLRTreeNodeStream>", rewriteElementType="Node", ...)>
+<genericParser(inputStreamType="id\<TreeNodeStream>", rewriteElementType="Node", ...)>
>>

/** How to generate a parser */
@@ -691,8 +691,8 @@ genericParser(  grammar,
{
#pragma mark Bitsets
<bitsets:{it | <bitsetInit(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>}, words64=it.bits)>}>
-    [ANTLRBaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"\<invalid>", @"\<EOR>", @"\<DOWN>", @"\<UP>", <tokenNames:{it | @<it>}; separator=", ", wrap="\n ">, nil] retain]];
-    [ANTLRBaseRecognizer setGrammarFileName:@"<fileName>"];
+    [BaseRecognizer setTokenNames:[[AMutableArray arrayWithObjects:@"\<invalid>", @"\<EOR>", @"\<DOWN>", @"\<UP>", <tokenNames:{it | @<it>}; separator=", ", wrap="\n ">, nil] retain]];
+    [BaseRecognizer setGrammarFileName:@"<fileName>"];
<synpreds:{pred | <synpred(pred)>}>
}

@@ -708,12 +708,12 @@ genericParser(  grammar,
<if(PARSER)>
- (id) initWithTokenStream:(<inputStreamType>)aStream
{
-    self = [super initWithTokenStream:aStream State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:<numRules>+1]];
+    self = [super initWithTokenStream:aStream State:[RecognizerSharedState newRecognizerSharedStateWithRuleLen:<numRules>+1]];
if ( self != nil ) {
<else><! TREE_PARSER !>
- (id) initWithStream:(<inputStreamType>)aStream
{
-    self = [super initWithStream:aStream State:[[ANTLRRecognizerSharedState newANTLRRecognizerSharedStateWithRuleLen:<numRules>+1] retain]];
+    self = [super initWithStream:aStream State:[[RecognizerSharedState newRecognizerSharedStateWithRuleLen:<numRules>+1] retain]];
if ( self != nil ) {
<endif>
<! <parserCtorBody()> !>
@@ -753,7 +753,7 @@ genericParser(  grammar,
parserCtorBody() ::= <<
<if(memoize)> /* parserCtorBody */
<if(grammar.grammarIsRoot)>
-state.ruleMemo = [[ANTLRRuleStack newANTLRRuleStack:<numRules>+1] retain];<\n> <! index from 1..n !>
+state.ruleMemo = [[RuleStack newRuleStack:<numRules>+1] retain];<\n> <! index from 1..n !>
<endif>
<endif>
<grammar.delegators:
@@ -798,7 +798,7 @@ SEL <name>Selector = @selector(<name>_fragment);
@try {
[self <name>_fragment]; // can never throw exception
}
-    @catch (ANTLRRecognitionException *re) {
+    @catch (RecognitionException *re) {
NSLog(@"impossible: %@\n", re.name);
}
BOOL success = (state.failed == NO);
@@ -859,7 +859,7 @@ rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memo
<else><if(!emptyRule)><if(actions.(actionScope).rulecatch)>
<actions.(actionScope).rulecatch>
<else>
-    @catch (ANTLRRecognitionException *re) {
+    @catch (RecognitionException *re) {
[self reportError:re];
[self recover:input Exception:re];
<@setErrorReturnValue()>
@@ -924,7 +924,7 @@ ruleLabelDefs() ::= <<
:{it | AMutableArray *list_<it.label.text> = nil;}; separator="\n"
>
<ruleDescriptor.ruleLabels:ruleLabelDef(); separator="\n">
-<ruleDescriptor.ruleListLabels:{ll|ANTLRParserRuleReturnScope *<ll.label.text> = nil;}; separator="\n">
+<ruleDescriptor.ruleListLabels:{ll|ParserRuleReturnScope *<ll.label.text> = nil;}; separator="\n">
>>

lexerRuleLabelDefs() ::= <<
@@ -991,7 +991,7 @@ lexerRule(ruleName, nakedBlock, ruleDescriptor, block, memoize) ::= <<
<block><\n>
<else>
NSInteger _type = <ruleName>;
-        NSInteger _channel = ANTLRTokenChannelDefault;
+        NSInteger _channel = TokenChannelDefault;
<ruleMemoization(name=ruleName)>
<lexerRuleLabelDefs()>
<ruleDescriptor.actions.init>
@@ -1089,8 +1089,8 @@ do {
if ( cnt<decisionNumber> >= 1 )
goto loop<decisionNumber>;
<ruleBacktrackFailure()>
-            ANTLREarlyExitException *eee =
-                [ANTLREarlyExitException newException:input decisionNumber:<decisionNumber>];
+            EarlyExitException *eee =
+                [EarlyExitException newException:input decisionNumber:<decisionNumber>];
<@earlyExitException()>
@throw eee;
}
@@ -1207,7 +1207,7 @@ if (<s>) {
<if(backtracking)>state.failed = NO;<\n><endif>
} else {
<ruleBacktrackFailure()>
-    ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException newException:nil stream:input];
+    MismatchedSetException *mse = [MismatchedSetException newException:nil stream:input];
<@mismatchedSetException()>
<if(LEXER)>
<if(label)>
@@ -1237,7 +1237,7 @@ NSInteger <label>Start = input.index;
[self matchString:<string>]; <checkRuleBacktrackFailure()>
NSInteger StartLine<elementIndex> = self.line;
NSInteger <label>StartCharPos<elementIndex> = self.charPositionInLine;
-<label> = [[<labelType> newToken:input Type:ANTLRTokenTypeInvalid Channel:ANTLRTokenChannelDefault Start:<label>Start Stop:input.index] retain];
+<label> = [[<labelType> newToken:input Type:TokenTypeInvalid Channel:TokenChannelDefault Start:<label>Start Stop:input.index] retain];
[self setLine:<label>StartLine<elementIndex>];
[self setCharPositionInLine:<label>StartCharPos<elementIndex>];
<else>
@@ -1300,7 +1300,7 @@ lexerRuleRef(rule,label,args,elementIndex,scope) ::= <<
<if(label)>
NSInteger <label>Start<elementIndex> = input.index;
[self m<rule.name><if(args)>:<args; separator=" :"><endif>]; <checkRuleBacktrackFailure()><\n>
-<label> = [[<labelType> newToken:input Type:ANTLRTokenTypeInvalid Channel:ANTLRTokenChannelDefault Start:<label>Start<elementIndex> Stop:input.index-1] retain];
+<label> = [[<labelType> newToken:input Type:TokenTypeInvalid Channel:TokenChannelDefault Start:<label>Start<elementIndex> Stop:input.index-1] retain];
<label>.line = self.line;
<else>
[self <if(scope)><scope:delegateName()>.<endif>m<rule.name><if(args)>:<args; separator=" :"><endif>]; <checkRuleBacktrackFailure()><\n>
@@ -1317,11 +1317,11 @@ lexerRuleRefAndListLabel(rule,label,args,elementIndex,scope) ::= <<
lexerMatchEOF(label,elementIndex) ::= <<
<if(label)>
NSInteger <label>Start<elementIndex> = input.index;
-[self matchChar:ANTLRCharStreamEOF]; <checkRuleBacktrackFailure()><\n>
-<labelType> <label> = [[<labelType> newToken:input Type:ANTLRTokenTypeEOF Channel:ANTLRTokenChannelDefault Start:<label>Start<elementIndex> Stop:input.index-1] retain];
+[self matchChar:CharStreamEOF]; <checkRuleBacktrackFailure()><\n>
+<labelType> <label> = [[<labelType> newToken:input Type:TokenTypeEOF Channel:TokenChannelDefault Start:<label>Start<elementIndex> Stop:input.index-1] retain];
<label>.line = self.line;
<else>
-[self matchChar:ANTLRCharStreamEOF]; <checkRuleBacktrackFailure()><\n>
+[self matchChar:CharStreamEOF]; <checkRuleBacktrackFailure()><\n>
<endif>
>>

@@ -1355,7 +1355,7 @@ if ( [input LA:1] == DOWN ) {
validateSemanticPredicate(pred,description) ::= <<
if ( !(<evalPredicate(...)>) ) {
<ruleBacktrackFailure()>
-    @throw [ANTLRFailedPredicateException newException:@"<ruleName>" predicate:@"<description>" stream:input];
+    @throw [FailedPredicateException newException:@"<ruleName>" predicate:@"<description>" stream:input];
}
>>

@@ -1369,7 +1369,7 @@ else {
alt<decisionNumber> = <eotPredictsAlt>;
<else>
<ruleBacktrackFailure()>
-    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:<decisionNumber> state:<stateNumber> stream:input];
+    NoViableAltException *nvae = [NoViableAltException newException:<decisionNumber> state:<stateNumber> stream:input];
nvae.c = LA<decisionNumber>_<stateNumber>;
<@noViableAltException()>
@throw nvae;<\n>
@@ -1433,7 +1433,7 @@ default: ;
alt<decisionNumber> = <eotPredictsAlt>;
<else>
<ruleBacktrackFailure()>
-    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:<decisionNumber> state:<stateNumber> stream:input];
+    NoViableAltException *nvae = [NoViableAltException newException:<decisionNumber> state:<stateNumber> stream:input];
nvae.c = charLA<decisionNumber>;
<@noViableAltException()>
@throw nvae;<\n>
@@ -1479,10 +1479,10 @@ alt<decisionNumber> = [dfa<decisionNumber> predict:input];
/** Used in headerFile */
cyclicDFAInterface(dfa) ::= <<
#pragma mark Cyclic DFA interface start DFA<dfa.decisionNumber>
-@interface DFA<dfa.decisionNumber> : ANTLRDFA {
+@interface DFA<dfa.decisionNumber> : DFA {
}
-+ newDFA<dfa.decisionNumber>WithRecognizer:(ANTLRBaseRecognizer *)theRecognizer;
-- initWithRecognizer:(ANTLRBaseRecognizer *)recognizer;
++ newDFA<dfa.decisionNumber>WithRecognizer:(BaseRecognizer *)theRecognizer;
+- initWithRecognizer:(BaseRecognizer *)recognizer;
@end /* end of DFA<dfa.decisionNumber> interface  */<\n>
#pragma mark Cyclic DFA interface end DFA<dfa.decisionNumber><\n>
>>
@@ -1516,12 +1516,12 @@ const static NSInteger dfa<dfa.decisionNumber>_transition[] = {};
const static NSInteger dfa<dfa.decisionNumber>_transition<i0>[] = {<table; separator=", ", wrap="\n ", null="-1">\};
}; null="">

-+ (id) newDFA<dfa.decisionNumber>WithRecognizer:(ANTLRBaseRecognizer *)aRecognizer
++ (id) newDFA<dfa.decisionNumber>WithRecognizer:(BaseRecognizer *)aRecognizer
{
return [[[DFA<dfa.decisionNumber> alloc] initWithRecognizer:aRecognizer] retain];
}

-- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
+- (id) initWithRecognizer:(BaseRecognizer *) theRecognizer
{
self = [super initWithRecognizer:theRecognizer];
if ( self != nil ) {
@@ -1544,16 +1544,16 @@ const static NSInteger dfa<dfa.decisionNumber>_transition<i0>[] = {<table; separ

<if(dfa.specialStateSTs)>
/* start dfa.specialStateSTs */
-- (NSInteger) specialStateTransition:(NSInteger)s Stream:(id\<ANTLRIntStream\>)anInput
+- (NSInteger) specialStateTransition:(NSInteger)s Stream:(id\<IntStream\>)anInput
{
<if(LEXER)>
-    id\<ANTLRIntStream\> input = anInput;<\n>
+    id\<IntStream\> input = anInput;<\n>
<endif>
<if(PARSER)>
-    id\<ANTLRTokenStream\> input = (id\<ANTLRTokenStream\>)anInput;<\n>
+    id\<TokenStream\> input = (id\<TokenStream\>)anInput;<\n>
<endif>
<if(TREE_PARSER)>
-    id\<ANTLRTreeNodeStream\> input = (id\<ANTLRTreeNodeStream\>)anInput;<\n>
+    id\<TreeNodeStream\> input = (id\<TreeNodeStream\>)anInput;<\n>
<endif>
switch (s) {
<dfa.specialStateSTs:{state |
@@ -1563,7 +1563,7 @@ const static NSInteger dfa<dfa.decisionNumber>_transition<i0>[] = {<table; separ
<if(backtracking)>
if ( [recognizer getBacktrackingLevel] > 0 ) { [recognizer setFailed:YES]; return -1; }<\n>
<endif>
-    ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException newException:<dfa.decisionNumber> state:s stream:recognizer.input];
+    NoViableAltException *nvae = [NoViableAltException newException:<dfa.decisionNumber> state:s stream:recognizer.input];
// nvae.c = s;
/* [self error:nvae]; */ <! for debugger - do later !>
@throw nvae;
@@ -1638,7 +1638,7 @@ evalPredicate(pred,description) ::= "(<pred>)"
*
* synpreds are broken in cyclic DFA special states
*  Damn! For now, work around with using the selectors directly, and by providing a trampoline evalSynPred method in
- *  ANTLRDFA
+ *  DFA
*/
/* evalSynPredicate(pred,description) ::= "[self evaluateSyntacticPredicate:<pred>Selector stream:input]" */
evalSynPredicate(pred,description) ::= "[self evaluateSyntacticPredicate:@selector(<pred>_fragment)]"
@@ -1681,7 +1681,7 @@ methods(scope) ::= <%

globalAttributeScopeInterface(scope) ::= <%
/* globalAttributeScopeInterface */<\n>
-@interface <scope.name>_Scope : ANTLRSymbolsScope {<\n>
+@interface <scope.name>_Scope : SymbolsScope {<\n>
<if(scope.attributes)>
<memVars(scope)>
<endif>
@@ -1704,7 +1704,7 @@ globalAttributeScopeInterface(scope) ::= <%

globalAttributeScopeMemVar(scope) ::= <%
/* globalAttributeScopeMemVar */<\n>
-ANTLRSymbolStack *<scope.name>_stack;<\n>
+SymbolStack *<scope.name>_stack;<\n>
<scope.name>_Scope *<scope.name>_scope;<\n>
%>

@@ -1737,7 +1737,7 @@ globalAttributeScopeImplementation(scope) ::= <%
globalAttributeScopeInit(scope) ::= <<
/* globalAttributeScopeInit */<\n>
<scope.name>_scope = [<scope.name>_Scope new<scope.name>_Scope];<\n>
-<scope.name>_stack = [ANTLRSymbolStack newANTLRSymbolStackWithLen:30];<\n>
+<scope.name>_stack = [SymbolStack newSymbolStackWithLen:30];<\n>
>>

globalAttributeScopeDealloc(scope) ::= << [<scope.name>_stack release];<\n> >>
@@ -1754,7 +1754,7 @@ ruleAttributeScopeMemVar(scope) ::= <%
ruleAttributeScopeInterface(scope) ::= <%
<if(scope.attributes)>
/* start of ruleAttributeScopeInterface */<\n>
-@interface <scope.name>_Scope : ANTLRSymbolsScope {<\n>
+@interface <scope.name>_Scope : SymbolsScope {<\n>
<memVars(scope)><\n>
}<\n>
<\n>
@@ -1794,7 +1794,7 @@ ruleAttributeScopeImplementation(scope) ::= <%
ruleAttributeScopeInit(scope) ::= <%
/* ruleAttributeScopeInit */<\n>
<scope.name>_scope = [<scope.name>_Scope new<scope.name>_Scope];<\n>
-<scope.name>_stack = [ANTLRSymbolStack newANTLRSymbolStackWithLen:30];<\n>
+<scope.name>_stack = [SymbolStack newSymbolStackWithLen:30];<\n>
%>

ruleAttributeScopeDealloc(scope) ::= <% [<scope.name>_Scope release];<\n> %>
@@ -1802,7 +1802,7 @@ ruleAttributeScopeDealloc(scope) ::= <% [<scope.name>_Scope release];<\n> %>
ruleAttributeScope(scope) ::= <%
<if(scope.attributes)>
/* ruleAttributeScope */<\n>
-static ANTLRSymbolStack *<scope.name>_stack;<\n>
+static SymbolStack *<scope.name>_stack;<\n>
<endif>
%>

@@ -1859,7 +1859,7 @@ ruleLabelDef(label) ::= << <ruleLabelType(referencedRule=label.referencedRule)>
returnScopeInterface(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
/* returnScopeInterface <ruleDescriptor:returnStructName()> */
-@interface <ruleDescriptor:returnStructName()> : ANTLR<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope { /* returnScopeInterface line 1838 */
+@interface <ruleDescriptor:returnStructName()> : <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope { /* returnScopeInterface line 1838 */
<@memVars()> /* ObjC start of memVars() */<\n>
<if(scope.attributes)>
<memVars(scope)><\n>
@@ -2099,7 +2099,7 @@ static const unsigned long long <name>_data[] = { <words64:{it | <it>LL};separat
>>

bitsetInit(name, words64) ::= <<
-<name> = [[ANTLRBitSet newANTLRBitSetWithBits:(const unsigned long long *)<name>_data Count:(NSUInteger)<length(words64)>] retain];<\n>
+<name> = [[ANTLRBitSet newBitSetWithBits:(const unsigned long long *)<name>_data Count:(NSUInteger)<length(words64)>] retain];<\n>
>>

codeFileExtension() ::= ".m"
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ST.stg b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ST.stg
index 8350477..398d34f 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/ObjC/ST.stg
@@ -51,7 +51,7 @@ ST *st;

@returnScopeInterface() ::= <<
/* ST returnScopeInterface */
-@interface <returnScopeInterface.name> : ANTLRReturnScope {
+@interface <returnScopeInterface.name> : ReturnScope {
<returnScopeInterface.memVars()>
}
<returnScopeInterface.properties()>
@@ -173,7 +173,7 @@ static class STAttrMap extends HashMap {

@STAttrMap.interface() ::= <<
/* -------- ST start STAttrMap.interface ------------ */
-@interface STAttrMap : ANTLRHashMap {
+@interface STAttrMap : HashMap {
/*    <@STAttrMap.memVars()> */
STGroup *templateLib;
}
@@ -284,13 +284,13 @@ if ( <actions.(actionScope).synpredgate> ) {
replaceTextInLine() ::= <<
/* -------- ST start replaceTextInLine ------------ */
<if(TREE_PARSER)>
-[[(ANTLRTokenRewriteStream *)input getTokenStream]
+[[(TokenRewriteStream *)input getTokenStream]
replaceFromIndex:[[input getTreeAdaptor] getTokenStartIndex:retval.start]
ToIndex:[[input getTreeAdaptor] getTokenStopIndex:retval.start]
Text:retval.st];
<else>
-[(ANTLRTokenRewriteStream *)input)
-        replaceFromIndex:[((ANTLRCommonToken *)retval.start) getTokenIndex]
+[(TokenRewriteStream *)input)
+        replaceFromIndex:[((CommonToken *)retval.start) getTokenIndex]
ToIndex:[[input LT:-1] getTokenIndex]
Text:retval.st];
<endif>

