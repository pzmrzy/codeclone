commit 0911e8bceab4fedfce2cb43610a770af1dfcefb3
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Aug 4 15:15:42 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Aug 4 15:15:42 2011 -0800

(C# 2, 3) Optimize local variables in SpecialStateTransition methods

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 9004]

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
index b4c7e54..c5e1fd8 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp2/CSharp2.stg
@@ -1174,7 +1174,7 @@ if (!(<evalPredicate(...)>))
// F i x e d  D F A  (if-then-else)

dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
else
{
@@ -1196,7 +1196,7 @@ else
*  expect "if ( LA(1)==X ) match(X);" and that's it.
*/
dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
>>

@@ -1207,7 +1207,7 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
*  anything other than 'a' predicts exiting.
*/
dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
<if(!edges)>
@@ -1387,12 +1387,22 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
ITreeNodeStream input = (ITreeNodeStream)_input;
<endif>
int _s = s;
-	switch (s)
+	s = -1;
+	<! pull these outside the switch cases to save space on locals !>
+	int LA<dfa.decisionNumber>_1 = input.LA(1);
+	int index<dfa.decisionNumber>_1 = input.Index;
+	switch (_s)
{
-	<dfa.specialStateSTs:{state |
-	case <i0>:<! compressed special state numbers 0..n-1 !>
-		<state>}; separator="\n">
+	<dfa.specialStateSTs:{state |case <i0>:<! compressed special state numbers 0..n-1 !>
+	<state>}; separator="\n">
+
+	default:
+		break;
}
+
+	if (s >= 0)
+		return s;
+
<if(backtracking)>
if (state.backtracking > 0) {state.failed=true; return -1;}
<endif>
@@ -1407,20 +1417,18 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
*  state.
*/
cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(1);<\n>
+{
<if(semPredState)>
-<! get next lookahead symbol to test edges, then rewind !>
-<\n>int index<decisionNumber>_<stateNumber> = input.Index;
-input.Rewind();
+	<! get next lookahead symbol to test edges, then rewind !>
+	input.Rewind();
<endif>
-s = -1;
-<edges; separator="\nelse ">
+	<edges; separator="\nelse ">
<if(semPredState)>
-<! return input cursor to state before we rewound !>
-<\n>input.Seek(index<decisionNumber>_<stateNumber>);
+	<! return input cursor to state before we rewound !>
+	input.Seek(index<decisionNumber>_1);
<endif>
-if (s >= 0) return s;
-break;
+	break;
+}
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
@@ -1450,7 +1458,7 @@ evalPredicate(pred,description) ::= "(<pred>)"

evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"

-lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
+lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<k>==<atom>"

/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
*  somewhere.  Must ask for the lookahead directly.
@@ -1458,7 +1466,7 @@ lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
-(LA<decisionNumber>_<stateNumber><ge()><lower> && LA<decisionNumber>_<stateNumber><le()><upper>)
+(LA<decisionNumber>_<k><ge()><lower> && LA<decisionNumber>_<k><le()><upper>)
%>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
index a789e8a..bf7ca36 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/CSharp3/CSharp3.stg
@@ -1153,7 +1153,7 @@ if (!(<evalPredicate(...)>))
// F i x e d  D F A  (if-then-else)

dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
else
{
@@ -1175,7 +1175,7 @@ else
*  expect "if ( LA(1)==X ) match(X);" and that's it.
*/
dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse ">
>>

@@ -1186,7 +1186,7 @@ int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
*  anything other than 'a' predicts exiting.
*/
dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(<k>);<\n>
+int LA<decisionNumber>_<k> = input.LA(<k>);<\n>
<edges; separator="\nelse "><\n>
<if(eotPredictsAlt)>
<if(!edges)>
@@ -1366,12 +1366,22 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
ITreeNodeStream input = (ITreeNodeStream)_input;
<endif>
int _s = s;
-	switch (s)
+	s = -1;
+	<! pull these outside the switch cases to save space on locals !>
+	int LA<dfa.decisionNumber>_1 = input.LA(1);
+	int index<dfa.decisionNumber>_1 = input.Index;
+	switch (_s)
{
-	<dfa.specialStateSTs:{state |
-	case <i0>:<! compressed special state numbers 0..n-1 !>
-		<state>}; separator="\n">
+	<dfa.specialStateSTs:{state |case <i0>:<! compressed special state numbers 0..n-1 !>
+	<state>}; separator="\n">
+
+	default:
+		break;
}
+
+	if (s >= 0)
+		return s;
+
<if(backtracking)>
if (state.backtracking > 0) {state.failed=true; return -1;}
<endif>
@@ -1386,20 +1396,18 @@ private int SpecialStateTransition<dfa.decisionNumber>(DFA dfa, int s, IIntStrea
*  state.
*/
cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
-int LA<decisionNumber>_<stateNumber> = input.LA(1);<\n>
+{
<if(semPredState)>
-<! get next lookahead symbol to test edges, then rewind !>
-<\n>int index<decisionNumber>_<stateNumber> = input.Index;
-input.Rewind();
+	<! get next lookahead symbol to test edges, then rewind !>
+	input.Rewind();
<endif>
-s = -1;
-<edges; separator="\nelse ">
+	<edges; separator="\nelse ">
<if(semPredState)>
-<! return input cursor to state before we rewound !>
-<\n>input.Seek(index<decisionNumber>_<stateNumber>);
+	<! return input cursor to state before we rewound !>
+	input.Seek(index<decisionNumber>_1);
<endif>
-if (s >= 0) return s;
-break;
+	break;
+}
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
@@ -1429,7 +1437,7 @@ evalPredicate(pred,description) ::= "(<pred>)"

evalSynPredicate(pred,description) ::= "EvaluatePredicate(<pred>_fragment)"

-lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
+lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<k>==<atom>"

/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
*  somewhere.  Must ask for the lookahead directly.
@@ -1437,7 +1445,7 @@ lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber>==<atom>"
isolatedLookaheadTest(atom,k,atomAsInt) ::= "input.LA(<k>)==<atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <%
-(LA<decisionNumber>_<stateNumber><ge()><lower> && LA<decisionNumber>_<stateNumber><le()><upper>)
+(LA<decisionNumber>_<k><ge()><lower> && LA<decisionNumber>_<k><le()><upper>)
%>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(input.LA(<k>)<ge()><lower> && input.LA(<k>)<le()><upper>)"

