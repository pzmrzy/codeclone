commit 37ddc338ca6f4ab9d9c39721fdcf37a2eeba923a
Author:     sharwell <sharwell@pixelminegames.com>
AuthorDate: Thu Oct 27 09:28:00 2011 -0800
Commit:     sharwell <sharwell@pixelminegames.com>
CommitDate: Thu Oct 27 09:28:00 2011 -0800

v3: Support label optimization (if the tool also supports it)

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 9213]

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
index 2f6671a..5b41343 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/AST.stg
@@ -66,10 +66,17 @@ ruleLabelDefs() ::= <<
<[ruleDescriptor.tokenLabels,ruleDescriptor.wildcardTreeLabels,
ruleDescriptor.wildcardTreeListLabels]:{it | <ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
<ruleDescriptor.tokenListLabels:{it | <ASTLabelType> <it.label.text>_tree=null;}; separator="\n">
+<if(ruleDescriptor.supportsLabelOptimization)>
+<ruleDescriptor.allTokenRefsInRewrites
+    :{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
+<ruleDescriptor.allRuleRefsInRewrites
+    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
+<else>
<ruleDescriptor.allTokenRefsInAltsWithRewrites
:{it | RewriteRule<rewriteElementType>Stream stream_<it>=new RewriteRule<rewriteElementType>Stream(adaptor,"token <it>");}; separator="\n">
<ruleDescriptor.allRuleRefsInAltsWithRewrites
:{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>");}; separator="\n">
+<endif>
>>

/** When doing auto AST construction, we must define some variables;
@@ -208,7 +215,7 @@ rewriteCodeLabels() ::= <<
separator="\n"
>
<referencedRuleLabels
-    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.tree:null);};
+    :{it | RewriteRuleSubtreeStream stream_<it>=new RewriteRuleSubtreeStream(adaptor,"rule <it>",<it>!=null?<it>.getTree():null);};
separator="\n"
>
<referencedRuleListLabels
diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
index 1f86683..305dca4 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/ASTTreeParser.stg
@@ -74,8 +74,8 @@ _last = (<ASTLabelType>)input.LT(1);
<if(rewriteMode)>
<if(backtracking)>if ( <actions.(actionScope).synpredgate> )<endif>
<if(root.el.rule)>
-if ( _first_<enclosingTreeLevel>==null ) _first_<enclosingTreeLevel> = <root.el.label>.tree;
-<else>
+if ( _first_<enclosingTreeLevel>==null ) _first_<enclosingTreeLevel> = (<ASTLabelType>)<root.el.label>.getTree();
+<elseif(root.el.label)>
if ( _first_<enclosingTreeLevel>==null ) _first_<enclosingTreeLevel> = <root.el.label>;
<endif>
<endif>
@@ -225,7 +225,7 @@ _last = (<ASTLabelType>)input.LT(1);
<if(!rewriteMode)>
adaptor.addChild(root_<treeLevel>, <label>.getTree());
<else> <! rewrite mode !>
-if ( _first_<treeLevel>==null ) _first_<treeLevel> = <label>.tree;
+if ( _first_<treeLevel>==null ) _first_<treeLevel> = (<ASTLabelType>)<label>.getTree();
<endif>
>>

diff --git a/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg b/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
index c8ef58c..877ca6f 100644
--- a/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
+++ b/tool/src/main/resources/org/antlr/codegen/templates/Java/Java.stg
@@ -248,7 +248,7 @@ public class <grammar.recognizerName> extends <@superClassName><superClass><@end
appear to be defined in this recognizer. !>
// Delegated rules
<grammar.delegatedRules:{ruleDescriptor|
-    public <returnType()> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec; separator=", "> { <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">
+    public <returnType(ruleDescriptor)> <ruleDescriptor.name>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec; separator=", "> { <if(ruleDescriptor.hasReturnValue)>return <endif><ruleDescriptor.grammar:delegateName()>.<ruleDescriptor.name>(<ruleDescriptor.parameterScope.attributes:{a|<a.name>}; separator=", ">); \}}; separator="\n">

<synpreds:{p | <synpred(p)>}>

@@ -368,7 +368,7 @@ rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,finally,memo

// $ANTLR start "<ruleName>"
// <fileName>:<description>
-public final <returnType()> <ruleName>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec:{x|<x>}; separator=", "> {
+public final <returnType(ruleDescriptor)> <ruleName>(<ruleDescriptor.parameterScope:parameterScope()>) throws <ruleDescriptor.throwsSpec:{x|<x>}; separator=", "> {
<if(trace)>traceIn("<ruleName>", <ruleDescriptor.index>);<endif>
<ruleScopeSetUp()>
<ruleDeclarations()>
@@ -417,7 +417,7 @@ catch (<e.decl>) {

ruleDeclarations() ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-<returnType()> retval = new <returnType()>();
+<returnType(ruleDescriptor)> retval = new <returnType(ruleDescriptor)>();
retval.start = input.LT(1);<\n>
<else>
<ruleDescriptor.returnScope.attributes:{ a |
@@ -1175,16 +1175,14 @@ protected Stack <scope.name>_stack = new Stack();<\n>

returnStructName(r) ::= "<r.name>_return"

-returnType() ::= <%
+returnType(ruleDescriptor) ::= <%
<if(ruleDescriptor.hasMultipleReturnValues)>
<ruleDescriptor.grammar.recognizerName>.<ruleDescriptor:returnStructName()>
-<else>
-<if(ruleDescriptor.hasSingleReturnValue)>
+<elseif(ruleDescriptor.hasSingleReturnValue)>
<ruleDescriptor.singleValueReturnType>
<else>
void
<endif>
-<endif>
%>

/** Generate the Java type associated with a single or multiple return
@@ -1192,14 +1190,12 @@ void
*/
ruleLabelType(referencedRule) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
-<referencedRule.grammar.recognizerName>.<referencedRule.name>_return
-<else>
-<if(referencedRule.hasSingleReturnValue)>
+<returnScopeBaseType()>
+<elseif(referencedRule.hasSingleReturnValue)>
<referencedRule.singleValueReturnType>
<else>
void
<endif>
-<endif>
%>

delegateName(d) ::= <<
@@ -1225,13 +1221,17 @@ ruleLabelDef(label) ::= <%
*/
returnScope(scope) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
-public static class <ruleDescriptor:returnStructName()> extends <if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope {
+public static class <ruleDescriptor:returnStructName()> extends <returnScopeBaseType()> {
<scope.attributes:{it |public <it.decl>;}; separator="\n">
<@ruleReturnMembers()>
};
<endif>
>>

+returnScopeBaseType() ::= <%
+<if(TREE_PARSER)>Tree<else>Parser<endif>RuleReturnScope
+%>
+
parameterScope(scope) ::= <<
<scope.attributes:{it |<it.decl>}; separator=", ">
>>
@@ -1272,7 +1272,7 @@ isolatedDynamicScopeRef(scope) ::= "<scope>_stack"
/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= <%
<if(referencedRule.hasMultipleReturnValues)>
-(<scope>!=null?<scope>.<attr.name>:<initValue(attr.type)>)
+(<scope>!=null?((<returnType(referencedRule)>)<scope>).<attr.name>:<initValue(attr.type)>)
<else>
<scope>
<endif>
@@ -1314,7 +1314,7 @@ tokenLabelPropertyRef_int(scope,attr) ::= "(<scope>!=null?Integer.valueOf(<scope

ruleLabelPropertyRef_start(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.start):null)"
ruleLabelPropertyRef_stop(scope,attr) ::= "(<scope>!=null?((<labelType>)<scope>.stop):null)"
-ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.tree):null)"
+ruleLabelPropertyRef_tree(scope,attr) ::= "(<scope>!=null?((<ASTLabelType>)<scope>.getTree()):null)"
ruleLabelPropertyRef_text(scope,attr) ::= <%
<if(TREE_PARSER)>
(<scope>!=null?(input.getTokenStream().toString(
@@ -1325,7 +1325,7 @@ ruleLabelPropertyRef_text(scope,attr) ::= <%
<endif>
%>

-ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?<scope>.st:null)"
+ruleLabelPropertyRef_st(scope,attr) ::= "(<scope>!=null?((StringTemplate)<scope>.getTemplate()):null)"

/** Isolated $RULE ref ok in lexer as it's a Token */
lexerRuleLabel(label) ::= "<label>"

