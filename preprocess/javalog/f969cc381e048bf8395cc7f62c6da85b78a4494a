commit f969cc381e048bf8395cc7f62c6da85b78a4494a
Author:     parrt <parrt@antlr.org>
AuthorDate: Thu Jul 14 17:40:33 2011 -0800
Commit:     parrt <parrt@antlr.org>
CommitDate: Thu Jul 14 17:40:33 2011 -0800

* Added BaesTree.freshenParentAndChildIndexesDeeply() to recursively
walk tree and set ptrs.

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 8859]

diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java
index ebffdb3..07e911a 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java
@@ -44,7 +44,7 @@ public abstract class BaseTree implements Tree {

/** Create a new node from an existing node does nothing for BaseTree
*  as there are no fields other than the children list, which cannot
-	 *  be copied as the children are not considered part of this node.
+	 *  be copied as the children are not considered part of this node.
*/
public BaseTree(Tree node) {
}
@@ -69,7 +69,7 @@ public abstract class BaseTree implements Tree {
if ( t.getType()==type ) {
return t;
}
-		}
+		}
return null;
}

@@ -150,7 +150,7 @@ public abstract class BaseTree implements Tree {
t.setParent(this);
t.setChildIndex(i);
}
-
+
public Object deleteChild(int i) {
if ( children==null ) {
return null;
@@ -250,6 +250,20 @@ public abstract class BaseTree implements Tree {
}
}

+	public void freshenParentAndChildIndexesDeeply() {
+		freshenParentAndChildIndexesDeeply(0);
+	}
+
+	public void freshenParentAndChildIndexesDeeply(int offset) {
+		int n = getChildCount();
+		for (int c = offset; c < n; c++) {
+			BaseTree child = (BaseTree)getChild(c);
+			child.setChildIndex(c);
+			child.setParent(this);
+			child.freshenParentAndChildIndexesDeeply();
+		}
+	}
+
public void sanityCheckParentAndChildIndexes() {
sanityCheckParentAndChildIndexes(null, -1);
}
diff --git a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java
index 05dbbdd..dcdbdd5 100644
--- a/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java
+++ b/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java
@@ -51,7 +51,7 @@ public class CommonTreeNodeStream extends LookaheadStream<Object> implements Tre
protected TreeIterator it;

/** Stack of indexes used for push/pop calls */
-    protected IntArray calls;
+    protected IntArray calls;

/** Tree (nil A B C) trees like flat A B C streams */
protected boolean hasNilRoot = false;
@@ -76,7 +76,7 @@ public class CommonTreeNodeStream extends LookaheadStream<Object> implements Tre
level = 0;
if ( calls != null ) calls.clear();
}
-
+
/** Pull elements from tree iterator.  Track tree level 0..max_level.
*  If nil rooted tree, don't give initial nil and DOWN nor final UP.
*/
@@ -137,7 +137,7 @@ public class CommonTreeNodeStream extends LookaheadStream<Object> implements Tre
int ret = calls.pop();
seek(ret);
return ret;
-    }
+    }

// TREE REWRITE INTERFACE

diff --git a/tool/CHANGES.txt b/tool/CHANGES.txt
index c680f57..99f4fd0 100644
--- a/tool/CHANGES.txt
+++ b/tool/CHANGES.txt
@@ -7,6 +7,11 @@ University of San Francisco

CHANGES

+July 14, 2011
+
+* Added BaesTree.freshenParentAndChildIndexesDeeply() to recursively
+  walk tree and set ptrs.
+
July 6, 2011

* reset() for token stream didn't skip initial off-channel tokens.
diff --git a/tool/src/test/java/org/antlr/test/TestTreeNodeStream.java b/tool/src/test/java/org/antlr/test/TestTreeNodeStream.java
index 450bbae..747fc3a 100644
--- a/tool/src/test/java/org/antlr/test/TestTreeNodeStream.java
+++ b/tool/src/test/java/org/antlr/test/TestTreeNodeStream.java
@@ -320,9 +320,43 @@ public class TestTreeNodeStream extends BaseTest {
String v = toNodesOnlyString(stream); // scan all
stream.reset();
String v2 = toNodesOnlyString(stream); // scan all
-        assertEquals(v,v2);
+        assertEquals(v, v2);
}

+	@Test public void testDeepTree() throws Exception {
+		// ^(10 100 101 ^(20 ^(30 40 (50 (60 70)))) (80 90)))
+		// stream has 8 real + 10 nav nodes
+		int n = 9;
+		CommonTree[] nodes = new CommonTree[n];
+		for (int i=0; i< n; i++) {
+			nodes[i] = new CommonTree(new CommonToken((i+1)*10));
+		}
+		Tree g = nodes[0];
+		Tree rules = nodes[1];
+		Tree rule1 = nodes[2];
+		Tree id = nodes[3];
+		Tree block = nodes[4];
+		Tree alt = nodes[5];
+		Tree s = nodes[6];
+		Tree rule2 = nodes[7];
+		Tree id2 = nodes[8];
+		g.addChild(new CommonTree(new CommonToken(100)));
+		g.addChild(new CommonTree(new CommonToken(101)));
+		g.addChild(rules);
+		rules.addChild(rule1);
+		rule1.addChild(id);
+		rule1.addChild(block);
+		block.addChild(alt);
+		alt.addChild(s);
+		rules.addChild(rule2);
+		rule2.addChild(id2);
+
+		TreeNodeStream stream = newStream(g);
+		String expecting = " 10 2 100 101 20 2 30 2 40 50 2 60 2 70 3 3 3 80 2 90 3 3 3";
+		String found = toTokenTypeString(stream);
+		assertEquals(expecting, found);
+	}
+
public String toNodesOnlyString(TreeNodeStream nodes) {
TreeAdaptor adaptor = nodes.getTreeAdaptor();
StringBuffer buf = new StringBuffer();

