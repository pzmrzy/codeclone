commit 96a9dae84d4095a7adb169fde23757b47a539666
Author:     acondit <acondit@parrt.spork>
AuthorDate: Thu Jan 26 08:48:39 2012 -0800
Commit:     acondit <acondit@parrt.spork>
CommitDate: Thu Jan 26 08:48:39 2012 -0800

Continuing Rename of File to match Java src

[git-p4: depot-paths = "//depot/code/antlr/antlr3-main/": change = 9900]

diff --git a/runtime/ObjC/Framework/ANTLRFastQueue.h b/runtime/ObjC/Framework/ANTLRFastQueue.h
deleted file mode 100644
index f5ba582..0000000
--- a/runtime/ObjC/Framework/ANTLRFastQueue.h
+++ /dev/null
@@ -1,64 +0,0 @@
-//
-//  ANTLRFastQueue.h
-//  ANTLR
-//
-//  Created by Ian Michell on 26/04/2010.
-// [The "BSD licence"]
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "AMutableArray.h"
-
-@interface ANTLRFastQueue : NSObject <NSCopying>
-{
-    __strong AMutableArray *data;
-    NSUInteger p;
-    NSUInteger range;
-}
-
-@property (retain) AMutableArray *data;
-@property (assign) NSUInteger p;
-@property (assign) NSUInteger range;
-
-+ (id) newANTLRFastQueue;
-
-- (id) init;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (void) reset;
-- (id) remove;
-- (void) addObject:(id) obj;
-- (NSUInteger) count;
-- (NSUInteger) size;
-- (NSUInteger) range;
-- (id) head;
-- (id) objectAtIndex:(NSUInteger) i;
-- (void) clear;
-- (NSString *) toString;
-- (NSString *) description;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRFastQueue.m b/runtime/ObjC/Framework/ANTLRFastQueue.m
deleted file mode 100644
index 6944b6d..0000000
--- a/runtime/ObjC/Framework/ANTLRFastQueue.m
+++ /dev/null
@@ -1,174 +0,0 @@
-//
-//  ANTLRFastQueue.m
-//  ANTLR
-//
-//  Created by Ian Michell on 26/04/2010.
-// [The "BSD licence"]
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRFastQueue.h"
-#import "ANTLRError.h"
-#import "ANTLRRuntimeException.h"
-
-@implementation ANTLRFastQueue
-
-//@synthesize pool;
-@synthesize data;
-@synthesize p;
-@synthesize range;
-
-+ (id) newANTLRFastQueue
-{
-    return [[ANTLRFastQueue alloc] init];
-}
-
-- (id) init
-{
-	self = [super init];
-	if ( self != nil ) {
-		data = [[AMutableArray arrayWithCapacity:100] retain];
-		p = 0;
-		range = -1;
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRFastQueue" );
-#endif
-	if ( data ) [data release];
-	[super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRFastQueue *copy;
-
-    copy = [[[self class] allocWithZone:aZone] init];
-    copy.data = [data copyWithZone:nil];
-    copy.p = p;
-    copy.range = range;
-    return copy;
-}
-
-// FIXME: Java code has this, it doesn't seem like it needs to be there... Then again a lot of the code in the java runtime is not great...
-- (void) reset
-{
-	[self clear];
-}
-
-- (void) clear
-{
-	p = 0;
-    if ( [data count] )
-        [data removeAllObjects];
-}
-
-- (id) remove
-{
-	id obj = [self objectAtIndex:0];
-	p++;
-	// check to see if we have hit the end of the buffer
-	if ( p == [data count] ) {
-		// if we have, then we need to clear it out
-		[self clear];
-	}
-	return obj;
-}
-
-- (void) addObject:(id) obj
-{
-    [data addObject:obj];
-}
-
-- (NSUInteger) count
-{
-	return [data count];
-}
-
-- (NSUInteger) size
-{
-	return [data count] - p;
-}
-
-- (NSUInteger) range
-{
-    return range;
-}
-
-- (id) head
-{
-	return [self objectAtIndex:0];
-}
-
-- (id) objectAtIndex:(NSUInteger) i
-{
-    NSUInteger absIndex;
-
-    absIndex = p + i;
-	if ( absIndex >= [data count] ) {
-		@throw [ANTLRNoSuchElementException newException:[NSString stringWithFormat:@"queue index %d > last index %d", absIndex, [data count]-1]];
-	}
-	if ( absIndex < 0 ) {
-	    @throw [ANTLRNoSuchElementException newException:[NSString stringWithFormat:@"queue index %d < 0", absIndex]];
-	}
-	if ( absIndex > range ) range = absIndex;
-	return [data objectAtIndex:absIndex];
-}
-
-- (NSString *) toString
-{
-    return [self description];
-}
-
-- (NSString *) description
-{
-	NSMutableString *buf = [NSMutableString stringWithCapacity:30];
-	NSInteger n = [self size];
-	for (NSInteger i = 0; i < n; i++) {
-		[buf appendString:[[self objectAtIndex:i] description]];
-		if ((i + 1) < n) {
-			[buf appendString:@" "];
-		}
-	}
-	return buf;
-}
-
-#ifdef DONTUSENOMO
-- (NSAutoreleasePool *)getPool
-{
-    return pool;
-}
-
-- (void)setPool:(NSAutoreleasePool *)aPool
-{
-    pool = aPool;
-}
-#endif
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRHashMap.h b/runtime/ObjC/Framework/ANTLRHashMap.h
deleted file mode 100644
index 113cb65..0000000
--- a/runtime/ObjC/Framework/ANTLRHashMap.h
+++ /dev/null
@@ -1,110 +0,0 @@
-//
-//  ANTLRHashMap.h
-//  ANTLR
-//
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRLinkBase.h"
-#import "ANTLRMapElement.h"
-
-#define GLOBAL_SCOPE       0
-#define LOCAL_SCOPE        1
-#define HASHSIZE         101
-#define HBUFSIZE      0x2000
-
-@interface ANTLRHashMap : ANTLRLinkBase {
-    //    TStringPool *fPool;
-    NSInteger Scope;
-    NSInteger LastHash;
-    NSInteger BuffSize;
-    NSUInteger count;
-    NSUInteger ptr;
-    __strong NSMutableData *buffer;
-    __strong ANTLRMapElement **ptrBuffer;
-    NSInteger mode;
-}
-
-// Contruction/Destruction
-+ (id)newANTLRHashMap;
-+ (id)newANTLRHashMapWithLen:(NSInteger)aBuffSize;
-- (id)init;
-- (id)initWithLen:(NSInteger)aBuffSize;
-- (void)dealloc;
-- (ANTLRHashMap *)PushScope:( ANTLRHashMap **)map;
-- (ANTLRHashMap *)PopScope:( ANTLRHashMap **)map;
-
-- (NSInteger)count;
-- (NSInteger)size;
-
-// Instance Methods
-/*    form hash value for string s */
-- (NSInteger)hash:(NSString *)s;
-/*   look for s in ptrBuffer  */
-- (ANTLRHashMap *)findscope:(int)level;
-/*   look for s in ptrBuffer  */
-- (id)lookup:(NSString *)s Scope:(int)scope;
-/*   look for s in ptrBuffer  */
-- (id)install:(ANTLRMapElement *)sym Scope:(int)scope;
-/*   look for s in ptrBuffer  */
-- (void)deleteANTLRHashMap:(ANTLRMapElement *)np;
-- (int)RemoveSym:(NSString *)s;
-- (void)delete_chain:(ANTLRMapElement *)np;
-#ifdef DONTUSEYET
-- (int)bld_symtab:(KW_TABLE *)toknams;
-#endif
-- (ANTLRMapElement **)getptrBuffer;
-- (ANTLRMapElement *)getptrBufferEntry:(int)idx;
-- (void)setptrBuffer:(ANTLRMapElement *)np Index:(int)idx;
-- (NSInteger)getScope;
-- (void)setScope:(NSInteger)i;
-- (ANTLRMapElement *)getTType:(NSString *)name;
-- (ANTLRMapElement *)getNameInList:(NSInteger)ttype;
-- (void)putNode:(NSString *)name TokenType:(NSInteger)ttype;
-- (NSInteger)getMode;
-- (void)setMode:(NSInteger)aMode;
-- (void) insertObject:(id)aRule atIndex:(NSInteger)idx;
-- (id) objectAtIndex:(NSInteger)idx;
-- (void) setObject:(id)aRule atIndex:(NSInteger)idx;
-- (void)addObject:(id)anObject;
-- (ANTLRMapElement *) getName:(NSString *)aName;
-- (void) putName:(NSString *)name Node:(id)aNode;
-
-- (NSEnumerator *)objectEnumerator;
-- (BOOL) hasNext;
-- (ANTLRMapElement *)nextObject;
-
-//@property (copy) TStringPool *fPool;
-@property (getter=getScope, setter=setScope:) NSInteger Scope;
-@property (getter=getLastHash, setter=setLastHash:) NSInteger LastHash;
-
-@property (getter=getMode,setter=setMode:) NSInteger mode;
-@property NSInteger BuffSize;
-@property (getter=getCount, setter=setCount:) NSUInteger count;
-@property (assign) NSUInteger ptr;
-@property (retain, getter=getBuffer, setter=setBuffer:) NSMutableData *buffer;
-@property (assign, getter=getPtrBuffer, setter=setPtrBuffer:) ANTLRMapElement **ptrBuffer;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRHashMap.m b/runtime/ObjC/Framework/ANTLRHashMap.m
deleted file mode 100644
index ab025a9..0000000
--- a/runtime/ObjC/Framework/ANTLRHashMap.m
+++ /dev/null
@@ -1,529 +0,0 @@
-//
-//  ANTLRHashMap.m
-//  ANTLR
-//
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#define SUCCESS (0)
-#define FAILURE (-1)
-
-#import "ANTLRHashMap.h"
-
-static NSInteger itIndex;
-
-/*
- * Start of ANTLRHashMap
- */
-@implementation ANTLRHashMap
-
-@synthesize Scope;
-@synthesize LastHash;
-
-+(id)newANTLRHashMap
-{
-    return [[ANTLRHashMap alloc] init];
-}
-
-+(id)newANTLRHashMapWithLen:(NSInteger)aBuffSize
-{
-    return [[ANTLRHashMap alloc] initWithLen:aBuffSize];
-}
-
--(id)init
-{
-    NSInteger idx;
-
-    if ((self = [super init]) != nil) {
-        fNext = nil;
-        Scope = 0;
-        ptr = 0;
-        BuffSize = HASHSIZE;
-        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
-        ptrBuffer = (ANTLRMapElement **) [buffer mutableBytes];
-        if ( fNext != nil ) {
-            Scope = ((ANTLRHashMap *)fNext)->Scope+1;
-            for( idx = 0; idx < BuffSize; idx++ ) {
-                ptrBuffer[idx] = ((ANTLRHashMap *)fNext)->ptrBuffer[idx];
-            }
-        }
-        mode = 0;
-    }
-    return( self );
-}
-
--(id)initWithLen:(NSInteger)aBuffSize
-{
-    NSInteger idx;
-
-    if ((self = [super init]) != nil) {
-        fNext = nil;
-        BuffSize = aBuffSize;
-        Scope = 0;
-        ptr = 0;
-        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
-        ptrBuffer = (ANTLRMapElement **) [buffer mutableBytes];
-        if ( fNext != nil ) {
-            Scope = ((ANTLRHashMap *)fNext)->Scope+1;
-            for( idx = 0; idx < BuffSize; idx++ ) {
-                ptrBuffer[idx] = ((ANTLRHashMap *)fNext)->ptrBuffer[idx];
-            }
-        }
-        mode = 0;
-    }
-    return( self );
-}
-
--(void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRHashMap" );
-#endif
-    ANTLRMapElement *tmp, *rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            tmp = ptrBuffer[idx];
-            while ( tmp && tmp != [((ANTLRHashMap *)fNext) getptrBufferEntry:idx] ) {
-                rtmp = tmp;
-                // tmp = [tmp getfNext];
-                tmp = (ANTLRMapElement *)tmp.fNext;
-                [rtmp release];
-            }
-        }
-    }
-    if ( buffer ) [buffer release];
-    [super dealloc];
-}
-
-- (NSInteger)count
-{
-    NSInteger aCnt = 0;
-
-    for (NSInteger i = 0; i < BuffSize; i++) {
-        if ( ptrBuffer[i] != nil ) {
-            aCnt++;
-        }
-    }
-    return aCnt;
-}
-
-- (NSInteger) size
-{
-    NSInteger aSize = 0;
-
-    for (NSInteger i = 0; i < BuffSize; i++) {
-        if ( ptrBuffer[i] != nil ) {
-            aSize += sizeof(id);
-        }
-    }
-    return aSize;
-}
-
-
--(void)deleteANTLRHashMap:(ANTLRMapElement *)np
-{
-    ANTLRMapElement *tmp, *rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            tmp = ptrBuffer[idx];
-            while ( tmp && tmp != (ANTLRLinkBase *)[((ANTLRHashMap *)fNext) getptrBufferEntry:idx] ) {
-                rtmp = tmp;
-                tmp = [tmp getfNext];
-                [rtmp release];
-            }
-        }
-    }
-}
-
--(ANTLRHashMap *)PushScope:(ANTLRHashMap **)map
-{
-    NSInteger idx;
-    ANTLRHashMap *htmp;
-
-    htmp = [ANTLRHashMap newANTLRHashMap];
-    if ( *map != nil ) {
-        ((ANTLRHashMap *)htmp)->fNext = *map;
-        [htmp setScope:[((ANTLRHashMap *)htmp->fNext) getScope]+1];
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            htmp->ptrBuffer[idx] = ((ANTLRHashMap *)htmp->fNext)->ptrBuffer[idx];
-        }
-    }
-    //    gScopeLevel++;
-    *map = htmp;
-    return( htmp );
-}
-
--(ANTLRHashMap *)PopScope:(ANTLRHashMap **)map
-{
-    NSInteger idx;
-    ANTLRMapElement *tmp;
-    ANTLRHashMap *htmp;
-
-    htmp = *map;
-    if ( (*map)->fNext != nil ) {
-        *map = (ANTLRHashMap *)htmp->fNext;
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            if ( htmp->ptrBuffer[idx] == nil ||
-                htmp->ptrBuffer[idx] == (*map)->ptrBuffer[idx] ) {
-                break;
-            }
-            tmp = htmp->ptrBuffer[idx];
-            /*
-             * must deal with parms, locals and labels at some point
-             * can not forget the debuggers
-             */
-            htmp->ptrBuffer[idx] = [tmp getfNext];
-            [tmp release];
-        }
-        *map = (ANTLRHashMap *)htmp->fNext;
-        //        gScopeLevel--;
-    }
-    return( htmp );
-}
-
-#ifdef USERDOC
-/*
- *  HASH        hash entry to get index to table
- *  NSInteger hash( ANTLRHashMap *self, char *s );
- *
- *     Inputs:  char *s             string to find
- *
- *     Returns: NSInteger                 hashed value
- *
- *  Last Revision 9/03/90
- */
-#endif
--(NSInteger)hash:(NSString *)s       /*    form hash value for string s */
-{
-    NSInteger hashval;
-    const char *tmp;
-
-    tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
-    for( hashval = 0; *tmp != '\0'; )
-        hashval += *tmp++;
-    self->LastHash = hashval % BuffSize;
-    return( self->LastHash );
-}
-
-#ifdef USERDOC
-/*
- *  FINDSCOPE  search hashed list for entry
- *  ANTLRHashMap *findscope( ANTLRHashMap *self, NSInteger scope );
- *
- *     Inputs:  NSInteger       scope -- scope level to find
- *
- *     Returns: ANTLRHashMap   pointer to ptrBuffer of proper scope level
- *
- *  Last Revision 9/03/90
- */
-#endif
--(ANTLRHashMap *)findscope:(NSInteger)scope
-{
-    if ( self->Scope == scope ) {
-        return( self );
-    }
-    else if ( fNext ) {
-        return( [((ANTLRHashMap *)fNext) findscope:scope] );
-    }
-    return( nil );              /*   not found      */
-}
-
-#ifdef USERDOC
-/*
- *  LOOKUP  search hashed list for entry
- *  ANTLRMapElement *lookup( ANTLRHashMap *self, char *s, NSInteger scope );
- *
- *     Inputs:  char     *s          string to find
- *
- *     Returns: ANTLRMapElement  *           pointer to entry
- *
- *  Last Revision 9/03/90
- */
-#endif
--(id)lookup:(NSString *)s Scope:(NSInteger)scope
-{
-    ANTLRMapElement *np;
-
-    for( np = self->ptrBuffer[[self hash:s]]; np != nil; np = [np getfNext] ) {
-        if ( [s isEqualToString:[np getName]] ) {
-            return( np );        /*   found it       */
-        }
-    }
-    return( nil );              /*   not found      */
-}
-
-#ifdef USERDOC
-/*
- *  INSTALL search hashed list for entry
- *  NSInteger install( ANTLRHashMap *self, ANTLRMapElement *sym, NSInteger scope );
- *
- *     Inputs:  ANTLRMapElement    *sym   -- symbol ptr to install
- *              NSInteger         scope -- level to find
- *
- *     Returns: Boolean     TRUE   if installed
- *                          FALSE  if already in table
- *
- *  Last Revision 9/03/90
- */
-#endif
--(ANTLRMapElement *)install:(ANTLRMapElement *)sym Scope:(NSInteger)scope
-{
-    ANTLRMapElement *np;
-
-    np = [self lookup:[sym getName] Scope:scope ];
-    if ( np == nil ) {
-        [sym retain];
-        [sym setFNext:self->ptrBuffer[ self->LastHash ]];
-        self->ptrBuffer[ self->LastHash ] = sym;
-        return( self->ptrBuffer[ self->LastHash ] );
-    }
-    return( nil );            /*   not found      */
-}
-
-#ifdef USERDOC
-/*
- *  RemoveSym  search hashed list for entry
- *  NSInteger RemoveSym( ANTLRHashMap *self, char *s );
- *
- *     Inputs:  char     *s          string to find
- *
- *     Returns: NSInteger      indicator of SUCCESS OR FAILURE
- *
- *  Last Revision 9/03/90
- */
-#endif
--(NSInteger)RemoveSym:(NSString *)s
-{
-    ANTLRMapElement *np, *tmp;
-    NSInteger idx;
-
-    idx = [self hash:s];
-    for ( tmp = self->ptrBuffer[idx], np = self->ptrBuffer[idx]; np != nil; np = [np getfNext] ) {
-        if ( [s isEqualToString:[np getName]] ) {
-            tmp = [np getfNext];             /* get the next link  */
-            [np release];
-            return( SUCCESS );            /* report SUCCESS     */
-        }
-        tmp = [np getfNext];              //  BAD!!!!!!
-    }
-    return( FAILURE );                    /*   not found      */
-}
-
--(void)delete_chain:(ANTLRMapElement *)np
-{
-    if ( [np getfNext] != nil )
-        [self delete_chain:[np getfNext]];
-    [np dealloc];
-}
-
-#ifdef DONTUSEYET
--(NSInteger)bld_symtab:(KW_TABLE *)toknams
-{
-    NSInteger i;
-    ANTLRMapElement *np;
-
-    for( i = 0; *(toknams[i].name) != '\0'; i++ ) {
-        // install symbol in ptrBuffer
-        np = [ANTLRMapElement newANTLRMapElement:[NSString stringWithFormat:@"%s", toknams[i].name]];
-        //        np->fType = toknams[i].toknum;
-        [self install:np Scope:0];
-    }
-    return( SUCCESS );
-}
-#endif
-
--(ANTLRMapElement *)getptrBufferEntry:(NSInteger)idx
-{
-    return( ptrBuffer[idx] );
-}
-
--(ANTLRMapElement **)getptrBuffer
-{
-    return( ptrBuffer );
-}
-
--(void)setptrBuffer:(ANTLRMapElement *)np Index:(NSInteger)idx
-{
-    if ( idx < BuffSize ) {
-        [np retain];
-        ptrBuffer[idx] = np;
-    }
-}
-
--(NSInteger)getScope
-{
-    return( Scope );
-}
-
--(void)setScopeScope:(NSInteger)i
-{
-    Scope = i;
-}
-
-- (ANTLRMapElement *)getTType:(NSString *)name
-{
-    return [self lookup:name Scope:0];
-}
-
-/*
- * works only for maplist indexed not by name but by TokenNumber
- */
-- (ANTLRMapElement *)getNameInList:(NSInteger)ttype
-{
-    ANTLRMapElement *np;
-    NSInteger aTType;
-
-    aTType = ttype % BuffSize;
-    for( np = self->ptrBuffer[aTType]; np != nil; np = [np getfNext] ) {
-        if ( [(NSNumber *)np.node integerValue] == ttype ) {
-            return( np );        /*   found it       */
-        }
-    }
-    return( nil );              /*   not found      */
-}
-
-- (ANTLRLinkBase *)getName:(NSString *)name
-{
-    return [self lookup:name Scope:0]; /*  nil if not found      */
-}
-
-- (void)putNode:(NSString *)name TokenType:(NSInteger)ttype
-{
-    ANTLRMapElement *np;
-
-    // install symbol in ptrBuffer
-    np = [ANTLRMapElement newANTLRMapElementWithName:[NSString stringWithString:name] Type:ttype];
-    //        np->fType = toknams[i].toknum;
-    [self install:np Scope:0];
-}
-
-- (NSInteger)getMode
-{
-    return mode;
-}
-
-- (void)setMode:(NSInteger)aMode
-{
-    mode = aMode;
-}
-
-- (void) addObject:(id)aRule
-{
-    NSInteger idx;
-
-    idx = [self count];
-    if ( idx >= BuffSize ) {
-        idx %= BuffSize;
-    }
-    ptrBuffer[idx] = aRule;
-}
-
-/* this may have to handle linking into the chain
- */
-- (void) insertObject:(id)aRule atIndex:(NSInteger)idx
-{
-    if ( idx >= BuffSize ) {
-        idx %= BuffSize;
-    }
-    if ( aRule != ptrBuffer[idx] ) {
-        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
-        [aRule retain];
-    }
-    ptrBuffer[idx] = aRule;
-}
-
-- (id)objectAtIndex:(NSInteger)idx
-{
-    if ( idx >= BuffSize ) {
-        idx %= BuffSize;
-    }
-    return ptrBuffer[idx];
-}
-
-/* this will never link into the chain
- */
-- (void) setObject:(id)aRule atIndex:(NSInteger)idx
-{
-    if ( idx >= BuffSize ) {
-        idx %= BuffSize;
-    }
-    if ( aRule != ptrBuffer[idx] ) {
-        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
-        [aRule retain];
-    }
-    ptrBuffer[idx] = aRule;
-}
-
-- (void)putName:(NSString *)name Node:(id)aNode
-{
-    ANTLRMapElement *np;
-
-    np = [self lookup:name Scope:0 ];
-    if ( np == nil ) {
-        np = [ANTLRMapElement newANTLRMapElementWithName:name Node:aNode];
-        if ( ptrBuffer[LastHash] )
-            [ptrBuffer[LastHash] release];
-        [np retain];
-        np.fNext = ptrBuffer[ LastHash ];
-        ptrBuffer[ LastHash ] = np;
-    }
-    return;
-}
-
-- (NSEnumerator *)objectEnumerator
-{
-#pragma mark fix this its broken
-    NSEnumerator *anEnumerator;
-
-    itIndex = 0;
-    return anEnumerator;
-}
-
-- (BOOL)hasNext
-{
-    if (self && [self count] < BuffSize-1) {
-        return YES;
-    }
-    return NO;
-}
-
-- (ANTLRMapElement *)nextObject
-{
-    if (self && itIndex < BuffSize-1) {
-        return ptrBuffer[itIndex];
-    }
-    return nil;
-}
-
-@synthesize BuffSize;
-@synthesize count;
-@synthesize ptr;
-@synthesize ptrBuffer;
-@synthesize buffer;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRHashRule.h b/runtime/ObjC/Framework/ANTLRHashRule.h
deleted file mode 100644
index 75ef581..0000000
--- a/runtime/ObjC/Framework/ANTLRHashRule.h
+++ /dev/null
@@ -1,70 +0,0 @@
-//
-//  ANTLRHashRule.h
-//  ANTLR
-//
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRuleMemo.h"
-#import "ANTLRPtrBuffer.h"
-
-#define GLOBAL_SCOPE       0
-#define LOCAL_SCOPE        1
-#define HASHSIZE         101
-#define HBUFSIZE      0x2000
-
-@interface ANTLRHashRule : ANTLRPtrBuffer {
-    //    TStringPool *fPool;
-    NSInteger LastHash;
-    NSInteger mode;
-}
-
-// Contruction/Destruction
-+ (id)newANTLRHashRule;
-+ (id)newANTLRHashRuleWithLen:(NSInteger)aBuffSize;
-- (id)init;
-- (id)initWithLen:(NSInteger)aBuffSize;
-- (void)dealloc;
-
-- (NSInteger)count;
-- (NSInteger)length;
-- (NSInteger)size;
-
-// Instance Methods
-- (void)deleteANTLRHashRule:(ANTLRRuleMemo *)np;
-- (void)delete_chain:(ANTLRRuleMemo *)np;
-- (ANTLRRuleMemo **)getPtrBuffer;
-- (void)setPtrBuffer:(ANTLRRuleMemo **)np;
-- (NSNumber *)getRuleMemoStopIndex:(NSInteger)aStartIndex;
-- (void)putRuleMemoAtStartIndex:(NSInteger)aStartIndex StopIndex:(NSInteger)aStopIndex;
-- (NSInteger)getMode;
-- (void)setMode:(NSInteger)aMode;
-- (void) insertObject:(ANTLRRuleMemo *)aRule atIndex:(NSInteger)Index;
-- (ANTLRRuleMemo *) objectAtIndex:(NSInteger)Index;
-
-@property (getter=getLastHash, setter=setLastHash:) NSInteger LastHash;
-@property (getter=getMode,setter=setMode:) NSInteger mode;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRHashRule.m b/runtime/ObjC/Framework/ANTLRHashRule.m
deleted file mode 100644
index 3bca78f..0000000
--- a/runtime/ObjC/Framework/ANTLRHashRule.m
+++ /dev/null
@@ -1,279 +0,0 @@
-//
-//  ANTLRHashRule.m
-//  ANTLR
-//
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#define SUCCESS (0)
-#define FAILURE (-1)
-#define ANTLR_MEMO_RULE_UNKNOWN -1
-
-#import "ANTLRHashRule.h"
-
-/*
- * Start of ANTLRHashRule
- */
-@implementation ANTLRHashRule
-
-@synthesize LastHash;
-
-+(id)newANTLRHashRule
-{
-    return [[ANTLRHashRule alloc] init];
-}
-
-+(id)newANTLRHashRuleWithLen:(NSInteger)aBuffSize
-{
-    return [[ANTLRHashRule alloc] initWithLen:aBuffSize];
-}
-
--(id)init
-{
-    self = [super initWithLen:HASHSIZE];
-    if ( self != nil ) {
-    }
-    return( self );
-}
-
--(id)initWithLen:(NSInteger)aBuffSize
-{
-    self = [super initWithLen:aBuffSize];
-    if ( self != nil ) {
-        mode = 0;
-    }
-    return( self );
-}
-
--(void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRHashRule" );
-#endif
-    ANTLRRuleMemo *tmp, *rtmp;
-    int Index;
-
-    if ( self.fNext != nil ) {
-        for( Index = 0; Index < BuffSize; Index++ ) {
-            tmp = ptrBuffer[Index];
-            while ( tmp && tmp != ptrBuffer[Index] ) {
-                rtmp = tmp;
-                if ([tmp isKindOfClass:[ANTLRLinkBase class]])
-                    tmp = (ANTLRRuleMemo *)tmp.fNext;
-                else
-                    tmp = nil;
-                [rtmp dealloc];
-            }
-        }
-    }
-    [super dealloc];
-}
-
-- (NSInteger)count
-{
-    NSInteger aCnt = 0;
-
-    for (int i = 0; i < BuffSize; i++) {
-        if ( ptrBuffer[i] != nil ) {
-            aCnt++;
-        }
-    }
-    return aCnt;
-}
-
-- (NSInteger) length
-{
-    return BuffSize;
-}
-
-- (NSInteger) size
-{
-    NSInteger aSize = 0;
-
-    for (int i = 0; i < BuffSize; i++) {
-        if ( ptrBuffer[i] != nil ) {
-            aSize += sizeof(id);
-        }
-    }
-    return aSize;
-}
-
-
--(void)deleteANTLRHashRule:(ANTLRRuleMemo *)np
-{
-    ANTLRRuleMemo *tmp, *rtmp;
-    int Index;
-
-    if ( self.fNext != nil ) {
-        for( Index = 0; Index < BuffSize; Index++ ) {
-            tmp = ptrBuffer[Index];
-            while ( tmp && tmp != ptrBuffer[Index ] ) {
-                rtmp = tmp;
-                if ([tmp isKindOfClass:[ANTLRLinkBase class]])
-                    tmp = (ANTLRRuleMemo *)tmp.fNext;
-                else
-                    tmp = nil;
-                [rtmp release];
-            }
-        }
-    }
-}
-
--(void)delete_chain:(ANTLRRuleMemo *)np
-{
-    if ( np.fNext != nil )
-        [self delete_chain:np.fNext];
-    [np dealloc];
-}
-
--(ANTLRRuleMemo **)getPtrBuffer
-{
-    return( ptrBuffer );
-}
-
--(void)setPtrBuffer:(ANTLRRuleMemo **)np
-{
-    ptrBuffer = np;
-}
-
-- (NSNumber *)getRuleMemoStopIndex:(NSInteger)aStartIndex
-{
-    ANTLRRuleMemo *aRule;
-    NSNumber *stopIndex;
-    NSInteger anIndex;
-
-    anIndex = ( aStartIndex >= BuffSize ) ? aStartIndex % BuffSize : aStartIndex;
-    if ((aRule = ptrBuffer[anIndex]) == nil) {
-        return nil;
-    }
-    stopIndex = [aRule getStopIndex:aStartIndex];
-    return stopIndex;
-}
-
-- (void)putRuleMemo:(ANTLRRuleMemo *)aRule AtStartIndex:(NSInteger)aStartIndex
-{
-    NSInteger anIndex;
-
-    anIndex = (aStartIndex >= BuffSize) ? aStartIndex %= BuffSize : aStartIndex;
-    if ( ptrBuffer[anIndex] == nil ) {
-        ptrBuffer[anIndex] = aRule;
-        [aRule retain];
-    }
-    else {
-        do {
-            if ( [aRule.startIndex integerValue] == aStartIndex ) {
-                [aRule setStartIndex:aRule.stopIndex];
-                return;
-            }
-            aRule = aRule.fNext;
-        } while ( aRule != nil );
-    }
-}
-
-- (void)putRuleMemoAtStartIndex:(NSInteger)aStartIndex StopIndex:(NSInteger)aStopIndex
-{
-    ANTLRRuleMemo *aRule, *newRule;
-    NSInteger anIndex;
-    NSInteger aMatchIndex;
-
-    anIndex = (aStartIndex >= BuffSize) ? aStartIndex % BuffSize : aStartIndex;
-    aRule = ptrBuffer[anIndex];
-    if ( aRule == nil ) {
-        aRule = [ANTLRRuleMemo newANTLRRuleMemoWithStartIndex:[NSNumber numberWithInteger:aStartIndex]
-                                                    StopIndex:[NSNumber numberWithInteger:aStopIndex]];
-        [aRule retain];
-        ptrBuffer[anIndex] = aRule;
-    }
-    else {
-        aMatchIndex = [aRule.startIndex integerValue];
-        if ( aStartIndex > aMatchIndex ) {
-            if ( aRule != ptrBuffer[anIndex] ) {
-                [aRule retain];
-            }
-            aRule.fNext = ptrBuffer[anIndex];
-            ptrBuffer[anIndex] = aRule;
-            return;
-        }
-        while (aRule.fNext != nil) {
-            aMatchIndex = [((ANTLRRuleMemo *)aRule.fNext).startIndex integerValue];
-            if ( aStartIndex > aMatchIndex ) {
-                newRule = [ANTLRRuleMemo newANTLRRuleMemoWithStartIndex:[NSNumber numberWithInteger:aStartIndex]
-                                                              StopIndex:[NSNumber numberWithInteger:aStopIndex]];
-                [newRule retain];
-                newRule.fNext = aRule.fNext;
-                aRule.fNext = newRule;
-                return;
-            }
-            if ( aMatchIndex == aStartIndex ) {
-                [aRule setStartIndex:aRule.stopIndex];
-                return;
-            }
-            aRule = aRule.fNext;
-        }
-    }
-}
-
-- (NSInteger)getLastHash
-{
-    return LastHash;
-}
-
-- (void)setLastHash:(NSInteger)aHash
-{
-    LastHash = aHash;
-}
-
-- (NSInteger)getMode
-{
-    return mode;
-}
-
-- (void)setMode:(NSInteger)aMode
-{
-    mode = aMode;
-}
-
-- (void) insertObject:(ANTLRRuleMemo *)aRule atIndex:(NSInteger)anIndex
-{
-    NSInteger Index;
-
-    Index = ( anIndex >= BuffSize ) ? anIndex % BuffSize : anIndex;
-    if (aRule != ptrBuffer[Index]) {
-        if ( ptrBuffer[Index] ) [ptrBuffer[Index] release];
-        [aRule retain];
-    }
-    ptrBuffer[Index] = aRule;
-}
-
-- (ANTLRRuleMemo *)objectAtIndex:(NSInteger)anIndex
-{
-    NSInteger anIdx;
-
-    anIdx = ( anIndex >= BuffSize ) ? anIndex % BuffSize : anIndex;
-    return ptrBuffer[anIdx];
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRIntArray.h b/runtime/ObjC/Framework/ANTLRIntArray.h
deleted file mode 100644
index 9182377..0000000
--- a/runtime/ObjC/Framework/ANTLRIntArray.h
+++ /dev/null
@@ -1,74 +0,0 @@
-//
-//  ANTLRIntArray.h
-//  ANTLR
-//
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-
-#define ANTLR_INT_ARRAY_INITIAL_SIZE 10
-
-@interface ANTLRIntArray : NSObject
-{
-    NSUInteger BuffSize;
-    NSUInteger count;
-    NSInteger idx;
-    NSMutableData *buffer;
-    __strong NSInteger *intBuffer;
-    BOOL SPARSE;
-}
-
-+ (ANTLRIntArray *)newArray;
-+ (ANTLRIntArray *)newArrayWithLen:(NSUInteger)aLen;
-
-- (id) init;
-- (id) initWithLen:(NSUInteger)aLen;
-
-- (void) dealloc;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (void) addInteger:(NSInteger) value;
-- (NSInteger) pop;
-- (void) push:(NSInteger) value;
-- (NSInteger) integerAtIndex:(NSUInteger) index;
-- (void) insertInteger:(NSInteger)anInteger AtIndex:(NSUInteger) anIndex;
-- (NSInteger)removeIntegerAtIndex:(NSUInteger) anIndex;
-- (void)replaceInteger:(NSInteger)aValue AtIndex:(NSUInteger)anIndex;
-- (void) reset;
-
-- (NSUInteger) count;
-- (NSUInteger) size;
-- (void) ensureCapacity:(NSUInteger) anIndex;
-
-@property (assign) NSUInteger BuffSize;
-@property (assign) NSUInteger count;
-@property (assign) NSInteger idx;
-@property (retain) NSMutableData *buffer;
-@property (assign) NSInteger *intBuffer;
-@property (assign) BOOL SPARSE;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRIntArray.m b/runtime/ObjC/Framework/ANTLRIntArray.m
deleted file mode 100644
index f715372..0000000
--- a/runtime/ObjC/Framework/ANTLRIntArray.m
+++ /dev/null
@@ -1,199 +0,0 @@
-//
-//  ANTLRIntArray.m
-//  ANTLR
-//
-//  Created by Ian Michell on 27/04/2010.
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRIntArray.h"
-#import "ANTLRRuntimeException.h"
-
-@implementation ANTLRIntArray
-
-@synthesize BuffSize;
-@synthesize count;
-@synthesize idx;
-@synthesize buffer;
-@synthesize intBuffer;
-@synthesize SPARSE;
-
-+ (ANTLRIntArray *)newArray
-{
-    return [[ANTLRIntArray alloc] init];
-}
-
-+ (ANTLRIntArray *)newArrayWithLen:(NSUInteger)aLen
-{
-    return [[ANTLRIntArray alloc] initWithLen:aLen];
-}
-
-- (id)init
-{
-    self = [super init];
-    if ( self != nil ) {
-        BuffSize  = (ANTLR_INT_ARRAY_INITIAL_SIZE * (sizeof(NSInteger)/sizeof(id)));
-        count = 0;
-        idx = -1;
-        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
-        intBuffer = (NSInteger *)[buffer mutableBytes];
-        SPARSE = NO;
-    }
-    return self;
-}
-
-- (id)initWithLen:(NSUInteger)aLen
-{
-    self = [super init];
-    if ( self != nil ) {
-        BuffSize  = (ANTLR_INT_ARRAY_INITIAL_SIZE * (sizeof(NSInteger)/sizeof(id)));
-        count = 0;
-        idx = -1;
-        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
-        intBuffer = (NSInteger *)[buffer mutableBytes];
-        SPARSE = NO;
-    }
-    return self;
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRIntArray" );
-#endif
-    if ( buffer ) [buffer release];
-    [super dealloc];
-}
-
-- (id)copyWithZone:(NSZone *)aZone
-{
-    ANTLRIntArray *copy;
-
-    copy = [[[self class] alloc] initWithLen:BuffSize];
-    copy.idx = self.idx;
-    NSInteger anIndex;
-    for ( anIndex = 0; anIndex < BuffSize; anIndex++ ) {
-        [copy addInteger:intBuffer[anIndex]];
-    }
-    return copy;
-}
-
-- (NSUInteger)count
-{
-    return count;
-}
-
-// FIXME: Java runtime returns p, I'm not so sure it's right so have added p + 1 to show true size!
-- (NSUInteger)size
-{
-    if ( count > 0 )
-        return ( count * sizeof(NSInteger));
-    return 0;
-}
-
-- (void)addInteger:(NSInteger) value
-{
-    [self ensureCapacity:idx+1];
-    intBuffer[++idx] = (NSInteger) value;
-    count++;
-}
-
-- (NSInteger)pop
-{
-    if ( idx < 0 ) {
-        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Nothing to pop, count = %d", count]];
-    }
-    NSInteger value = (NSInteger) intBuffer[idx--];
-    count--;
-    return value;
-}
-
-- (void)push:(NSInteger)aValue
-{
-    [self addInteger:aValue];
-}
-
-- (NSInteger)integerAtIndex:(NSUInteger) anIndex
-{
-    if ( SPARSE==NO  && anIndex > idx ) {
-        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than count %d", anIndex, count]];
-    }
-    else if ( SPARSE == YES && anIndex >= BuffSize ) {
-        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than BuffSize %d", anIndex, BuffSize]];
-    }
-    return intBuffer[anIndex];
-}
-
-- (void)insertInteger:(NSInteger)aValue AtIndex:(NSUInteger)anIndex
-{
-    [self replaceInteger:aValue AtIndex:anIndex];
-    count++;
-}
-
-- (NSInteger)removeIntegerAtIndex:(NSUInteger) anIndex
-{
-    if ( SPARSE==NO && anIndex > idx ) {
-        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than count %d", anIndex, count]];
-        return (NSInteger)-1;
-    } else if ( SPARSE==YES && anIndex >= BuffSize ) {
-        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than BuffSize %d", anIndex, BuffSize]];
-    }
-    count--;
-    return intBuffer[anIndex];
-}
-
-- (void)replaceInteger:(NSInteger)aValue AtIndex:(NSUInteger)anIndex
-{
-    if ( SPARSE == NO && anIndex > idx ) {
-        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than count %d", anIndex, count]];
-    }
-    else if ( SPARSE == YES && anIndex >= BuffSize ) {
-        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than BuffSize %d", anIndex, BuffSize]];
-    }
-    intBuffer[anIndex] = aValue;
-}
-
--(void) reset
-{
-    count = 0;
-    idx = -1;
-}
-
-- (void) ensureCapacity:(NSUInteger) anIndex
-{
-    if ( (anIndex * sizeof(NSUInteger)) >= [buffer length] )
-    {
-        NSUInteger newSize = ([buffer length] / sizeof(NSInteger)) * 2;
-        if (anIndex > newSize) {
-            newSize = anIndex + 1;
-        }
-        BuffSize = newSize;
-        [buffer setLength:(BuffSize * sizeof(NSUInteger))];
-        intBuffer = (NSInteger *)[buffer mutableBytes];
-    }
-}
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRLexer.h b/runtime/ObjC/Framework/ANTLRLexer.h
deleted file mode 100644
index cd985cc..0000000
--- a/runtime/ObjC/Framework/ANTLRLexer.h
+++ /dev/null
@@ -1,90 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTokenSource.h"
-#import "ANTLRBaseRecognizer.h"
-#import "ANTLRRecognizerSharedState.h"
-#import "ANTLRCharStream.h"
-#import "ANTLRToken.h"
-#import "ANTLRCommonToken.h"
-#import "ANTLRRecognitionException.h"
-#import "ANTLRMismatchedTokenException.h"
-#import "ANTLRMismatchedRangeException.h"
-
-@interface ANTLRLexer : ANTLRBaseRecognizer <ANTLRTokenSource> {
-	id<ANTLRCharStream> input;      ///< The character stream we pull tokens out of.
-	NSUInteger ruleNestingLevel;
-}
-
-@property (retain, getter=input, setter=setInput:) id<ANTLRCharStream> input;
-@property (getter=getRuleNestingLevel, setter=setRuleNestingLevel:) NSUInteger ruleNestingLevel;
-
-#pragma mark Initializer
-- (id) initWithCharStream:(id<ANTLRCharStream>) anInput;
-- (id) initWithCharStream:(id<ANTLRCharStream>)anInput State:(ANTLRRecognizerSharedState *)state;
-
-- (id) copyWithZone:(NSZone *)zone;
-
-- (void) reset;
-
-// - (ANTLRRecognizerSharedState *) state;
-
-#pragma mark Tokens
-- (id<ANTLRToken>)getToken;
-- (void) setToken: (id<ANTLRToken>) aToken;
-- (id<ANTLRToken>) nextToken;
-- (void) mTokens;		// abstract, defined in generated sources
-- (void) skip;
-- (id<ANTLRCharStream>) input;
-- (void) setInput:(id<ANTLRCharStream>)aCharStream;
-
-- (void) emit;
-- (void) emit:(id<ANTLRToken>)aToken;
-
-#pragma mark Matching
-- (void) matchString:(NSString *)aString;
-- (void) matchAny;
-- (void) matchChar:(unichar) aChar;
-- (void) matchRangeFromChar:(unichar)fromChar to:(unichar)toChar;
-
-#pragma mark Informational
-- (NSUInteger) line;
-- (NSUInteger) charPositionInLine;
-- (NSInteger) index;
-- (NSString *) text;
-- (void) setText:(NSString *) theText;
-
-// error handling
-- (void) reportError:(ANTLRRecognitionException *)e;
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)tokenNames;
-- (NSString *)getCharErrorDisplay:(NSInteger)c;
-- (void) recover:(ANTLRRecognitionException *)e;
-- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex;
-- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLexer.m b/runtime/ObjC/Framework/ANTLRLexer.m
deleted file mode 100644
index de1a0a3..0000000
--- a/runtime/ObjC/Framework/ANTLRLexer.m
+++ /dev/null
@@ -1,428 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <ANTLR/antlr.h>
-#import "ANTLRLexer.h"
-
-@implementation ANTLRLexer
-
-@synthesize input;
-@synthesize ruleNestingLevel;
-#pragma mark Initializer
-
-- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
-{
-	self = [super initWithState:[[ANTLRRecognizerSharedState alloc] init]];
-	if ( self != nil ) {
-        input = [anInput retain];
-        if (state.token != nil)
-            [((ANTLRCommonToken *)state.token) setInput:anInput];
-		ruleNestingLevel = 0;
-	}
-	return self;
-}
-
-- (id) initWithCharStream:(id<ANTLRCharStream>)anInput State:(ANTLRRecognizerSharedState *)aState
-{
-	self = [super initWithState:aState];
-	if ( self != nil ) {
-        input = [anInput retain];
-        if (state.token != nil)
-            [((ANTLRCommonToken *)state.token) setInput:anInput];
-		ruleNestingLevel = 0;
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-    if ( input ) [input release];
-    [super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRLexer *copy;
-
-    copy = [[[self class] allocWithZone:aZone] init];
-    //    copy = [super copyWithZone:aZone]; // allocation occurs here
-    if ( input != nil )
-        copy.input = input;
-    copy.ruleNestingLevel = ruleNestingLevel;
-    return copy;
-}
-
-- (void) reset
-{
-    [super reset]; // reset all recognizer state variables
-                   // wack Lexer state variables
-    if ( input != nil ) {
-        [input seek:0]; // rewind the input
-    }
-    if ( state == nil ) {
-        return; // no shared state work to do
-    }
-    state.token = nil;
-    state.type = ANTLRCommonToken.INVALID_TOKEN_TYPE;
-    state.channel = ANTLRCommonToken.DEFAULT_CHANNEL;
-    state.tokenStartCharIndex = -1;
-    state.tokenStartCharPositionInLine = -1;
-    state.tokenStartLine = -1;
-    state.text = nil;
-}
-
-// token stuff
-#pragma mark Tokens
-
-- (id<ANTLRToken>)getToken
-{
-    return [state getToken];
-}
-
-- (void) setToken: (id<ANTLRToken>) aToken
-{
-    if (state.token != aToken) {
-        [aToken retain];
-        state.token = aToken;
-    }
-}
-
-
-// this method may be overridden in the generated lexer if we generate a filtering lexer.
-- (id<ANTLRToken>) nextToken
-{
-	while (YES) {
-        [self setToken:nil];
-        state.channel = ANTLRCommonToken.DEFAULT_CHANNEL;
-        state.tokenStartCharIndex = input.index;
-        state.tokenStartCharPositionInLine = input.charPositionInLine;
-        state.tokenStartLine = input.line;
-        state.text = nil;
-
-        // [self setText:[self text]];
-		if ([input LA:1] == ANTLRCharStreamEOF) {
-            ANTLRCommonToken *eof = [ANTLRCommonToken newToken:input
-                                                          Type:ANTLRTokenTypeEOF
-                                                       Channel:ANTLRCommonToken.DEFAULT_CHANNEL
-                                                         Start:input.index
-                                                          Stop:input.index];
-            [eof setLine:input.line];
-            [eof setCharPositionInLine:input.charPositionInLine];
-			return eof;
-		}
-		@try {
-			[self mTokens];
-            // SEL aMethod = @selector(mTokens);
-            // [[self class] instancesRespondToSelector:aMethod];
-            if ( state.token == nil)
-                [self emit];
-            else if ( state.token == [ANTLRCommonToken skipToken] ) {
-                continue;
-            }
-			return state.token;
-		}
-		@catch (ANTLRNoViableAltException *nva) {
-			[self reportError:nva];
-			[self recover:nva];
-		}
-		@catch (ANTLRRecognitionException *e) {
-			[self reportError:e];
-		}
-	}
-}
-
-- (void) mTokens
-{   // abstract, defined in generated source as a starting point for matching
-    [self doesNotRecognizeSelector:_cmd];
-}
-
-- (void) skip
-{
-    state.token = [ANTLRCommonToken skipToken];
-}
-
-- (id<ANTLRCharStream>) input
-{
-    return input;
-}
-
-- (void) setInput:(id<ANTLRCharStream>) anInput
-{
-    if ( anInput != input ) {
-        if ( input ) [input release];
-    }
-    input = nil;
-    [self reset];
-    input = anInput;
-    [input retain];
-}
-
-/** Currently does not support multiple emits per nextToken invocation
- *  for efficiency reasons.  Subclass and override this method and
- *  nextToken (to push tokens into a list and pull from that list rather
- *  than a single variable as this implementation does).
- */
-- (void) emit:(id<ANTLRToken>)aToken
-{
-	state.token = aToken;
-}
-
-/** The standard method called to automatically emit a token at the
- *  outermost lexical rule.  The token object should point into the
- *  char buffer start..stop.  If there is a text override in 'text',
- *  use that to set the token's text.  Override this method to emit
- *  custom Token objects.
- *
- *  If you are building trees, then you should also override
- *  Parser or TreeParser.getMissingSymbol().
- */
-- (void) emit
-{
-	id<ANTLRToken> aToken = [ANTLRCommonToken newToken:input
-                                                  Type:state.type
-                                               Channel:state.channel
-                                                 Start:state.tokenStartCharIndex
-                                                  Stop:input.index-1];
-	[aToken setLine:state.tokenStartLine];
-    aToken.text = [self text];
-	[aToken setCharPositionInLine:state.tokenStartCharPositionInLine];
-    [aToken retain];
-	[self emit:aToken];
-	// [aToken release];
-}
-
-// matching
-#pragma mark Matching
-- (void) matchString:(NSString *)aString
-{
-    unichar c;
-	unsigned int i = 0;
-	unsigned int stringLength = [aString length];
-	while ( i < stringLength ) {
-		c = [input LA:1];
-        if ( c != [aString characterAtIndex:i] ) {
-			if ([state getBacktracking] > 0) {
-				state.failed = YES;
-				return;
-			}
-			ANTLRMismatchedTokenException *mte = [ANTLRMismatchedTokenException newExceptionChar:[aString characterAtIndex:i] Stream:input];
-            mte.c = c;
-			[self recover:mte];
-			@throw mte;
-		}
-		i++;
-		[input consume];
-		state.failed = NO;
-	}
-}
-
-- (void) matchAny
-{
-	[input consume];
-}
-
-- (void) matchChar:(unichar) aChar
-{
-	// TODO: -LA: is returning an int because it sometimes is used in the generated parser to compare lookahead with a tokentype.
-	//		 try to change all those occurrences to -LT: if possible (i.e. if ANTLR can be made to generate LA only for lexer code)
-    unichar charLA;
-	charLA = [input LA:1];
-	if ( charLA != aChar) {
-		if ([state getBacktracking] > 0) {
-			state.failed = YES;
-			return;
-		}
-		ANTLRMismatchedTokenException  *mte = [ANTLRMismatchedTokenException newExceptionChar:aChar Stream:input];
-        mte.c = charLA;
-		[self recover:mte];
-		@throw mte;
-	}
-	[input consume];
-	state.failed = NO;
-}
-
-- (void) matchRangeFromChar:(unichar)fromChar to:(unichar)toChar
-{
-	unichar charLA = (unichar)[input LA:1];
-	if ( charLA < fromChar || charLA > toChar ) {
-		if ([state getBacktracking] > 0) {
-			state.failed = YES;
-			return;
-		}
-		ANTLRMismatchedRangeException  *mre = [ANTLRMismatchedRangeException
-					newException:NSMakeRange((NSUInteger)fromChar,(NSUInteger)toChar)
-							   stream:input];
-        mre.c = charLA;
-		[self recover:mre];
-		@throw mre;
-	}
-	[input consume];
-	state.failed = NO;
-}
-
-	// info
-#pragma mark Informational
-
-- (NSUInteger) line
-{
-	return input.line;
-}
-
-- (NSUInteger) charPositionInLine
-{
-	return input.charPositionInLine;
-}
-
-- (NSInteger) index
-{
-    return 0;
-}
-
-- (NSString *) text
-{
-    if (state.text != nil) {
-        return state.text;
-    }
-	return [input substringWithRange:NSMakeRange(state.tokenStartCharIndex, input.index-state.tokenStartCharIndex)];
-}
-
-- (void) setText:(NSString *) theText
-{
-    state.text = theText;
-}
-
-	// error handling
-- (void) reportError:(ANTLRRecognitionException *)e
-{
-    /** TODO: not thought about recovery in lexer yet.
-     *
-     // if we've already reported an error and have not matched a token
-     // yet successfully, don't report any errors.
-     if ( errorRecovery ) {
-     //System.err.print("[SPURIOUS] ");
-     return;
-     }
-     errorRecovery = true;
-     */
-
-    [self displayRecognitionError:[self getTokenNames] Exception:e];
-}
-
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)tokenNames
-{
-/*    NSString *msg = [NSString stringWithFormat:@"Gotta fix getErrorMessage in ANTLRLexer.m--%@\n",
-                     e.name];
- */
-    NSString *msg = nil;
-    if ( [e isKindOfClass:[ANTLRMismatchedTokenException class]] ) {
-        ANTLRMismatchedTokenException *mte = (ANTLRMismatchedTokenException *)e;
-        msg = [NSString stringWithFormat:@"mismatched character \"%@\" expecting \"%@\"",
-               [self getCharErrorDisplay:mte.c], [self getCharErrorDisplay:mte.expecting]];
-    }
-    else if ( [e isKindOfClass:[ANTLRNoViableAltException class]] ) {
-        ANTLRNoViableAltException *nvae = (ANTLRNoViableAltException *)e;
-        // for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
-        // and "(decision="+nvae.decisionNumber+") and
-        // "state "+nvae.stateNumber
-        msg = [NSString stringWithFormat:@"no viable alternative at character \"%@\"",
-               [self getCharErrorDisplay:(nvae.c)]];
-    }
-    else if ( [e isKindOfClass:[ANTLREarlyExitException class]] ) {
-        ANTLREarlyExitException *eee = (ANTLREarlyExitException *)e;
-        // for development, can add "(decision="+eee.decisionNumber+")"
-        msg = [NSString stringWithFormat:@"required (...)+ loop did not match anything at character \"%@\"",
-               [self getCharErrorDisplay:(eee.c)]];
-    }
-    else if ( [e isKindOfClass:[ANTLRMismatchedNotSetException class]] ) {
-        ANTLRMismatchedNotSetException *mse = (ANTLRMismatchedNotSetException *)e;
-        msg = [NSString stringWithFormat:@"mismatched character \"%@\"  expecting set \"%@\"",
-               [self getCharErrorDisplay:(mse.c)], mse.expecting];
-    }
-    else if ( [e isKindOfClass:[ANTLRMismatchedSetException class]] ) {
-        ANTLRMismatchedSetException *mse = (ANTLRMismatchedSetException *)e;
-        msg = [NSString stringWithFormat:@"mismatched character \"%@\" expecting set \"%@\"",
-               [self getCharErrorDisplay:(mse.c)], mse.expecting];
-    }
-    else if ( [e isKindOfClass:[ANTLRMismatchedRangeException class]] ) {
-        ANTLRMismatchedRangeException *mre = (ANTLRMismatchedRangeException *)e;
-        msg = [NSString stringWithFormat:@"mismatched character \"%@\" \"%@..%@\"",
-               [self getCharErrorDisplay:(mre.c)], [self getCharErrorDisplay:(mre.range.location)],
-               [self getCharErrorDisplay:(mre.range.location+mre.range.length-1)]];
-    }
-    else {
-        msg = [super getErrorMessage:e TokenNames:[self getTokenNames]];
-    }
-    return msg;
-}
-
-- (NSString *)getCharErrorDisplay:(NSInteger)c
-{
-    NSString *s;
-    switch ( c ) {
-        case ANTLRTokenTypeEOF :
-            s = @"<EOF>";
-            break;
-        case '\n' :
-            s = @"\\n";
-            break;
-        case '\t' :
-            s = @"\\t";
-            break;
-        case '\r' :
-            s = @"\\r";
-            break;
-        default:
-            s = [NSString stringWithFormat:@"%c", (char)c];
-            break;
-    }
-    return s;
-}
-
-/** Lexers can normally match any char in it's vocabulary after matching
- *  a token, so do the easy thing and just kill a character and hope
- *  it all works out.  You can instead use the rule invocation stack
- *  to do sophisticated error recovery if you are in a fragment rule.
- */
-- (void)recover:(ANTLRRecognitionException *)re
-{
-    //System.out.println("consuming char "+(char)input.LA(1)+" during recovery");
-    //re.printStackTrace();
-    [input consume];
-}
-
-- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex
-{
-    NSString *inputSymbol = [NSString stringWithFormat:@"%c line=%d:%d\n", [input LT:1], input.line, input.charPositionInLine];
-    [super traceIn:ruleName Index:ruleIndex Object:inputSymbol];
-}
-
-- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex
-{
-    NSString *inputSymbol = [NSString stringWithFormat:@"%c line=%d:%d\n", [input LT:1], input.line, input.charPositionInLine];
-    [super traceOut:ruleName Index:ruleIndex Object:inputSymbol];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLexerRuleReturnScope.h b/runtime/ObjC/Framework/ANTLRLexerRuleReturnScope.h
deleted file mode 100644
index 27b8abc..0000000
--- a/runtime/ObjC/Framework/ANTLRLexerRuleReturnScope.h
+++ /dev/null
@@ -1,43 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-
-@interface ANTLRLexerRuleReturnScope : NSObject {
-	NSInteger start;
-	NSInteger stopToken;
-}
-
-- (NSInteger) getStart;
-- (void) setStart: (NSInteger) aStart;
-
-- (NSInteger) getStop;
-- (void) setStop: (NSInteger) aStop;
-
-@property (assign, getter=getStart, setter=setStart:) NSInteger start;
-@property (getter=getStop,setter=setStop:) NSInteger stopToken;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLexerRuleReturnScope.m b/runtime/ObjC/Framework/ANTLRLexerRuleReturnScope.m
deleted file mode 100644
index ac69380..0000000
--- a/runtime/ObjC/Framework/ANTLRLexerRuleReturnScope.m
+++ /dev/null
@@ -1,62 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRLexerRuleReturnScope.h"
-
-
-@implementation ANTLRLexerRuleReturnScope
-
-@synthesize start;
-
-//----------------------------------------------------------
-//  start
-//----------------------------------------------------------
-- (NSInteger) getStart
-{
-    return start;
-}
-
-- (void) setStart: (NSInteger) aStart
-{
-    start = aStart;
-}
-
-//----------------------------------------------------------
-//  stop
-//----------------------------------------------------------
-- (NSInteger) getStop
-{
-    return stopToken;
-}
-
-- (void) setStop: (NSInteger) aStop
-{
-    stopToken = aStop;
-}
-
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLexerState.h b/runtime/ObjC/Framework/ANTLRLexerState.h
deleted file mode 100644
index 7132a48..0000000
--- a/runtime/ObjC/Framework/ANTLRLexerState.h
+++ /dev/null
@@ -1,57 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRToken.h"
-#import "ANTLRRecognizerSharedState.h"
-
-@interface ANTLRLexerState : ANTLRRecognizerSharedState {
-}
-
-- (void) reset;
-
-- (id<ANTLRToken>) getToken;
-- (void) setToken:(id<ANTLRToken>) theToken;
-
-- (NSUInteger) getTokenType;
-- (void) setTokenType:(unsigned int) theTokenType;
-
-- (NSUInteger) channel;
-- (void) setChannel:(unsigned int) theChannel;
-
-- (NSUInteger) getTokenStartLine;
-- (void) setTokenStartLine:(unsigned int) theTokenStartLine;
-
-- (NSUInteger) getTokenCharPositionInLine;
-- (void) setTokenCharPositionInLine:(unsigned int) theCharPosition;
-
-- (NSInteger) getTokenStartCharIndex;
-- (void) setTokenStartCharIndex:(int) theTokenStartCharIndex;
-
-- (NSString *) text;
-- (void) setText:(NSString *) theText;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLexerState.m b/runtime/ObjC/Framework/ANTLRLexerState.m
deleted file mode 100644
index 88284b7..0000000
--- a/runtime/ObjC/Framework/ANTLRLexerState.m
+++ /dev/null
@@ -1,139 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRLexerState.h"
-
-
-@implementation ANTLRLexerState
-
-- (id) init
-{
-	self = [super init];
-	if (self) {
-		[self reset];
-	}
-	return self;
-}
-
-- (void) reset
-{
-	[self setToken:nil];
-	type = 0;
-	channel = 0;
-	tokenStartLine = 0;
-	tokenStartCharPositionInLine = 0;
-	tokenStartCharIndex = -1;
-	[self setText:nil];
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRLexerState" );
-#endif
-	[self setText:nil];
-	[self setToken:nil];
-	[super dealloc];
-}
-
-- (id<ANTLRToken>) getToken
-{
-	return token;
-}
-
-- (void) setToken:(id<ANTLRToken>) theToken
-{
-	if (theToken != token) {
-		if ( token ) [token release];
-		token = [theToken retain];
-	}
-}
-
-
-- (NSUInteger) getTokenType
-{
-	return type;
-}
-
-- (void) setTokenType:(NSUInteger) theTokenType
-{
-	type = theTokenType;
-}
-
-- (NSUInteger)channel
-{
-	return channel;
-}
-
-- (void) setChannel:(NSUInteger) theChannel
-{
-	channel = theChannel;
-}
-
-- (NSUInteger) getTokenStartLine
-{
-	return tokenStartLine;
-}
-
-- (void) setTokenStartLine:(NSUInteger) theTokenStartLine
-{
-	tokenStartLine = theTokenStartLine;
-}
-
-- (unsigned int) getTokenCharPositionInLine
-{
-	return tokenStartCharPositionInLine;
-}
-
-- (void) setTokenCharPositionInLine:(unsigned int) theCharPosition
-{
-	tokenStartCharPositionInLine = theCharPosition;
-}
-
-- (int) getTokenStartCharIndex
-{
-	return tokenStartCharIndex;
-}
-
-- (void) setTokenStartCharIndex:(int) theTokenStartCharIndex
-{
-	tokenStartCharIndex = theTokenStartCharIndex;
-}
-
-- (NSString *) text
-{
-	return text;
-}
-
-- (void) setText:(NSString *) theText
-{
-	if (text != theText) {
-		if ( text ) [text release];
-		text = [theText retain];
-	}
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLinkBase.h b/runtime/ObjC/Framework/ANTLRLinkBase.h
deleted file mode 100644
index f4c337e..0000000
--- a/runtime/ObjC/Framework/ANTLRLinkBase.h
+++ /dev/null
@@ -1,80 +0,0 @@
-//
-//  ANTLRLinkBase.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/14/10.
-//  [The "BSD licence"]
-//  Copyright (c) 2010 Alan Condit
-//  All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-
-#ifndef DEBUG_DEALLOC
-#define DEBUG_DEALLOC
-#endif
-
-@protocol ANTLRLinkList <NSObject>
-
-+ (id<ANTLRLinkList>)newANTLRLinkBase;
-+ (id<ANTLRLinkList>)newANTLRLinkBase:(id<ANTLRLinkList>)np Prev:(id<ANTLRLinkList>)pp;
-
-- (void) dealloc;
-
-- (id<ANTLRLinkList>) append:(id<ANTLRLinkList>)node;
-- (id<ANTLRLinkList>) insert:(id<ANTLRLinkList>)node;
-
-- (id<ANTLRLinkList>) getfNext;
-- (void) setFNext:(id<ANTLRLinkList>)np;
-- (id<ANTLRLinkList>)getfPrev;
-- (void) setFPrev:(id<ANTLRLinkList>)pp;
-
-@property (retain) id<ANTLRLinkList> fPrev;
-@property (retain) id<ANTLRLinkList> fNext;
-@end
-
-@interface ANTLRLinkBase : NSObject <ANTLRLinkList> {
-	id<ANTLRLinkList> fPrev;
-	id<ANTLRLinkList> fNext;
-}
-
-@property (retain) id<ANTLRLinkList> fPrev;
-@property (retain) id<ANTLRLinkList> fNext;
-
-+ (id<ANTLRLinkList>)newANTLRLinkBase;
-+ (id<ANTLRLinkList>)newANTLRLinkBase:(id<ANTLRLinkList>)np Prev:(id<ANTLRLinkList>)pp;
-- (id<ANTLRLinkList>)init;
-- (id<ANTLRLinkList>)initWithPtr:(id)np Prev:(id)pp;
-- (void)dealloc;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (id<ANTLRLinkList>)append:(id<ANTLRLinkList>)node;
-- (id<ANTLRLinkList>)insert:(id<ANTLRLinkList>)node;
-
-- (id<ANTLRLinkList>)getfNext;
-- (void)setfNext:(id<ANTLRLinkList>) np;
-- (id<ANTLRLinkList>)getfPrev;
-- (void)setfPrev:(id<ANTLRLinkList>) pp;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLinkBase.m b/runtime/ObjC/Framework/ANTLRLinkBase.m
deleted file mode 100644
index d352993..0000000
--- a/runtime/ObjC/Framework/ANTLRLinkBase.m
+++ /dev/null
@@ -1,127 +0,0 @@
-//
-//  ANTLRLinkBase.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/14/10.
-//  [The "BSD licence"]
-//  Copyright (c) 2010 Alan Condit
-//  All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRLinkBase.h"
-
-@implementation ANTLRLinkBase
-
-@synthesize fPrev;
-@synthesize fNext;
-
-+(id<ANTLRLinkList>)newANTLRLinkBase
-{
-	return [[ANTLRLinkBase alloc] init];
-}
-
-+(id<ANTLRLinkList>)newANTLRLinkBase:(id<ANTLRLinkList>)np Prev:(id<ANTLRLinkList>)pp
-{
-	return [[ANTLRLinkBase alloc] initWithPtr:np Prev:pp];
-}
-
--(id<ANTLRLinkList>)init
-{
-	if ((self = [super init]) != nil) {
-		fNext = nil;
-		fPrev = nil;
-	}
-	return(self);
-}
-
--(id<ANTLRLinkList>)initWithPtr:(id<ANTLRLinkList>)np Prev:(id<ANTLRLinkList>)pp
-{
-	if ((self = [super init]) != nil) {
-		fNext = np;
-		fPrev = pp;
-	}
-	return(self);
-}
-
--(void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRLinkBase" );
-#endif
-	if (fNext) [fNext dealloc];
-	if (fPrev) [fPrev dealloc];
-	[super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRLinkBase *copy;
-
-    copy = [[self class] allocWithZone:aZone];
-    copy.fPrev = fPrev;
-    copy.fNext = fNext;
-    return( copy );
-}
-
--(id<ANTLRLinkList>)append:(id<ANTLRLinkList>)node
-{
-	node.fPrev = (id<ANTLRLinkList>)self;
-	node.fNext = (id<ANTLRLinkList>)self.fNext;
-	if (node.fNext != nil)
-        node.fNext.fPrev = node;
-    self.fNext = node;
-    return( node );
-}
-
--(id<ANTLRLinkList>)insert:(id<ANTLRLinkList>)node
-{
-	node.fNext = self;
-	node.fPrev = self.fPrev;
-    if (node.fPrev != nil)
-        node.fPrev.fNext = node;
-	self.fPrev = node;
-	return( node );
-}
-
--(id<ANTLRLinkList>)getfNext
-{
-	return(fNext);
-}
-
--(void)setfNext:(id<ANTLRLinkList>)np
-{
-	fNext = np;
-}
-
--(id<ANTLRLinkList>)getfPrev
-{
-	return(fPrev);
-}
-
--(void)setfPrev:(id<ANTLRLinkList>)pp
-{
-	fPrev = pp;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLookaheadStream.h b/runtime/ObjC/Framework/ANTLRLookaheadStream.h
deleted file mode 100644
index 3ec121e..0000000
--- a/runtime/ObjC/Framework/ANTLRLookaheadStream.h
+++ /dev/null
@@ -1,77 +0,0 @@
-//
-//  ANTLRLookaheadStream.h
-//  ANTLR
-//
-//  Created by Ian Michell on 26/04/2010.
-//  [The "BSD licence"]
-//  Copyright (c) 2010 Ian Michell 2010 Alan Condit
-//  All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRFastQueue.h"
-
-#define UNITIALIZED_EOF_ELEMENT_INDEX NSIntegerMax
-
-@interface ANTLRLookaheadStream : ANTLRFastQueue
-{
-    NSInteger index;
-	NSInteger eofElementIndex;
-	NSInteger lastMarker;
-	NSInteger markDepth;
-	id prevElement;
-	id eof;
-}
-
-@property (readwrite, retain, getter=getEof, setter=setEof:) id eof;
-@property (assign) NSInteger index;
-@property (assign, getter=getEofElementIndex, setter=setEofElementIndex:) NSInteger eofElementIndex;
-@property (assign, getter=getLastMarker, setter=setLastMarker:) NSInteger lastMarker;
-@property (assign, getter=getMarkDepth, setter=setMarkDepth:) NSInteger markDepth;
-@property (retain) id prevElement;
-
-- (id) initWithEOF:(id) obj;
-- (id) nextElement;
-- (id) remove;
-- (void) consume;
-- (void) sync:(NSInteger) need;
-- (void) fill:(NSInteger) n;
-- (id) LT:(NSInteger) i;
-- (id) LB:(NSInteger) i;
-- (id) getCurrentSymbol;
-- (NSInteger) mark;
-- (void) release:(NSInteger) marker;
-- (void) rewind:(NSInteger) marker;
-- (void) rewind;
-- (void) seek:(NSInteger) i;
-- (id) getEof;
-- (void) setEof:(id) anID;
-- (NSInteger) getEofElementIndex;
-- (void) setEofElementIndex:(NSInteger) anInt;
-- (NSInteger) getLastMarker;
-- (void) setLastMarker:(NSInteger) anInt;
-- (NSInteger) getMarkDepth;
-- (void) setMarkDepth:(NSInteger) anInt;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRLookaheadStream.m b/runtime/ObjC/Framework/ANTLRLookaheadStream.m
deleted file mode 100644
index 57e489e..0000000
--- a/runtime/ObjC/Framework/ANTLRLookaheadStream.m
+++ /dev/null
@@ -1,229 +0,0 @@
-//
-//  ANTLRLookaheadStream.m
-//  ANTLR
-//
-//  Created by Ian Michell on 26/04/2010.
-// [The "BSD licence"]
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRLookaheadStream.h"
-#import "ANTLRError.h"
-#import "ANTLRRecognitionException.h"
-#import "ANTLRCommonToken.h"
-#import "ANTLRRuntimeException.h"
-
-@implementation ANTLRLookaheadStream
-
-@synthesize eof;
-@synthesize index;
-@synthesize eofElementIndex;
-@synthesize lastMarker;
-@synthesize markDepth;
-@synthesize prevElement;
-
--(id) init
-{
-	self = [super init];
-	if ( self != nil ) {
-        eof = [[ANTLRCommonToken eofToken] retain];
-		eofElementIndex = UNITIALIZED_EOF_ELEMENT_INDEX;
-		markDepth = 0;
-        index = 0;
-	}
-	return self;
-}
-
--(id) initWithEOF:(id)obj
-{
-	if ((self = [super init]) != nil) {
-		self.eof = obj;
-        if ( self.eof ) [self.eof retain];
-	}
-	return self;
-}
-
-- (void) reset
-{
-	[super reset];
-    index = 0;
-    p = 0;
-    prevElement = nil;
-	eofElementIndex = UNITIALIZED_EOF_ELEMENT_INDEX;
-}
-
--(id) nextElement
-{
-//	[self doesNotRecognizeSelector:_cmd];
-	return nil;
-}
-
-- (id) remove
-{
-    id obj = [self objectAtIndex:0];
-    p++;
-    // have we hit end of buffer and not backtracking?
-    if ( p == [data count] && markDepth==0 ) {
-        // if so, it's an opportunity to start filling at index 0 again
-        [self clear]; // size goes to 0, but retains memory
-    }
-    [obj release];
-    return obj;
-}
-
--(void) consume
-{
-	[self sync:1];
-	prevElement = [self remove];
-    index++;
-}
-
--(void) sync:(NSInteger) need
-{
-	NSInteger n = (p + need - 1) - [data count] + 1;
-	if ( n > 0 ) {
-		[self fill:n];
-	}
-}
-
--(void) fill:(NSInteger) n
-{
-    id obj;
-	for (NSInteger i = 1; i <= n; i++) {
-		obj = [self nextElement];
-		if ( obj == eof ) {
-			[data addObject:self.eof];
-			eofElementIndex = [data count] - 1;
-		}
-		else {
-			[data addObject:obj];
-		}
-	}
-}
-
--(NSUInteger) count
-{
-	@throw [NSException exceptionWithName:@"ANTLRUnsupportedOperationException" reason:@"Streams have no defined size" userInfo:nil];
-}
-
--(id) LT:(NSInteger) k
-{
-	if (k == 0) {
-		return nil;
-	}
-	if (k < 0) {
-		return [self LB:-k];
-	}
-	if ((p + k - 1) >= eofElementIndex) {
-		return self.eof;
-	}
-	[self sync:k];
-	return [self objectAtIndex:(k - 1)];
-}
-
--(id) LB:(NSInteger) k
-{
-	if (k == 1) {
-		return prevElement;
-	}
-	@throw [ANTLRNoSuchElementException newException:@"can't look backwards more than one token in this stream"];
-}
-
--(id) getCurrentSymbol
-{
-	return [self LT:1];
-}
-
--(NSInteger) mark
-{
-	markDepth++;
-	lastMarker = p;
-	return lastMarker;
-}
-
--(void) release:(NSInteger) marker
-{
-	// no resources to release
-}
-
--(void) rewind:(NSInteger) marker
-{
-	markDepth--;
-	[self seek:marker];
-//    if (marker == 0) [self reset];
-}
-
--(void) rewind
-{
-	[self seek:lastMarker];
-//    if (lastMarker == 0) [self reset];
-}
-
--(void) seek:(NSInteger) anIndex
-{
-	p = anIndex;
-}
-
-- (id) getEof
-{
-    return eof;
-}
-
-- (void) setEof:(id) anID
-{
-    eof = anID;
-}
-
-- (NSInteger) getEofElementIndex
-{
-    return eofElementIndex;
-}
-
-- (void) setEofElementIndex:(NSInteger) anInt
-{
-    eofElementIndex = anInt;
-}
-
-- (NSInteger) getLastMarker
-{
-    return lastMarker;
-}
-
-- (void) setLastMarker:(NSInteger) anInt
-{
-    lastMarker = anInt;
-}
-
-- (NSInteger) getMarkDepthlastMarker
-{
-    return markDepth;
-}
-
-- (void) setMarkDepth:(NSInteger) anInt
-{
-    markDepth = anInt;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMap.h b/runtime/ObjC/Framework/ANTLRMap.h
deleted file mode 100644
index 80ad486..0000000
--- a/runtime/ObjC/Framework/ANTLRMap.h
+++ /dev/null
@@ -1,82 +0,0 @@
-//
-//  ANTLRMap.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRPtrBuffer.h"
-#import "ANTLRMapElement.h"
-
-//#define GLOBAL_SCOPE      0
-//#define LOCAL_SCOPE       1
-#define HASHSIZE            101
-#define HBUFSIZE            0x2000
-
-@interface ANTLRMap : ANTLRPtrBuffer {
-	//ANTLRMap *fNext; // found in superclass
-    // TStringPool *fPool;
-    NSInteger lastHash;
-}
-
-//@property (copy) ANTLRMap *fNext;
-@property (getter=getLastHash, setter=setLastHash:) NSInteger lastHash;
-
-// Contruction/Destruction
-+ (id)newANTLRMap;
-+ (id)newANTLRMapWithLen:(NSInteger)aHashSize;
-
-- (id)init;
-- (id)initWithLen:(NSInteger)cnt;
-- (void)dealloc;
-// Instance Methods
-- (NSInteger)count;
-- (NSInteger)length;
-- (NSInteger)size;
-/* clear -- reinitialize the maplist array */
-- (void) clear;
-/* form hash value for string s */
--(NSInteger)hash:(NSString *)s;
-/*   look for s in ptrBuffer  */
--(id)lookup:(NSString *)s;
-/* look for s in ptrBuffer  */
--(id)install:(ANTLRMapElement *)sym;
-/*
- * delete entry from list
- */
-- (void)deleteANTLRMap:(ANTLRMapElement *)np;
-- (NSInteger)RemoveSym:(NSString *)s;
-- (void)delete_chain:(ANTLRMapElement *)np;
-- (ANTLRMapElement *)getTType:(NSString *)name;
-- (ANTLRMapElement *)getName:(NSInteger)ttype;
-- (NSInteger)getNode:(ANTLRMapElement *)aNode;
-- (void)putNode:(NSInteger)aTType Node:(id)aNode;
-- (void)putName:(NSString *)name TType:(NSInteger)ttype;
-- (void)putName:(NSString *)name Node:(id)aNode;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMap.m b/runtime/ObjC/Framework/ANTLRMap.m
deleted file mode 100644
index 6bfb088..0000000
--- a/runtime/ObjC/Framework/ANTLRMap.m
+++ /dev/null
@@ -1,362 +0,0 @@
-//
-//  ANTLRMap.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#define SUCCESS (0)
-#define FAILURE (-1)
-
-#import "ANTLRMap.h"
-#import "ANTLRBaseTree.h"
-
-/*
- * Start of ANTLRMap
- */
-@implementation ANTLRMap
-
-@synthesize lastHash;
-
-+(id)newANTLRMap
-{
-    return [[ANTLRMap alloc] init];
-}
-
-+(id)newANTLRMapWithLen:(NSInteger)aBuffSize
-{
-    return [[ANTLRMap alloc] initWithLen:aBuffSize];
-}
-
--(id)init
-{
-    NSInteger idx;
-
-	self = [super initWithLen:HASHSIZE];
-    if ( self != nil ) {
-		fNext = nil;
-        for( idx = 0; idx < HASHSIZE; idx++ ) {
-            ptrBuffer[idx] = nil;
-        }
-	}
-    return( self );
-}
-
--(id)initWithLen:(NSInteger)aBuffSize
-{
-	self = [super initWithLen:aBuffSize];
-    if ( self != nil ) {
-	}
-    return( self );
-}
-
--(void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRMMap" );
-#endif
-    ANTLRMapElement *tmp, *rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            tmp = ptrBuffer[idx];
-            while ( tmp ) {
-                rtmp = tmp;
-                tmp = (ANTLRMapElement *)tmp.fNext;
-                [rtmp release];
-            }
-        }
-    }
-	[super dealloc];
-}
-
--(void)deleteANTLRMap:(ANTLRMapElement *)np
-{
-    ANTLRMapElement *tmp, *rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            tmp = ptrBuffer[idx];
-            while ( tmp ) {
-                rtmp = tmp;
-                tmp = [tmp getfNext];
-                [rtmp release];
-            }
-        }
-    }
-}
-
-- (void)clear
-{
-    ANTLRMapElement *tmp, *rtmp;
-    NSInteger idx;
-
-    for( idx = 0; idx < BuffSize; idx++ ) {
-        tmp = ptrBuffer[idx];
-        while ( tmp ) {
-            rtmp = tmp;
-            tmp = [tmp getfNext];
-            [rtmp dealloc];
-        }
-        ptrBuffer[idx] = nil;
-    }
-}
-
-- (NSInteger)count
-{
-    NSInteger aCnt = 0;
-
-    for (int i = 0; i < BuffSize; i++) {
-        if (ptrBuffer[i] != nil) {
-            aCnt++;
-        }
-    }
-    return aCnt;
-}
-
-- (NSInteger)length
-{
-    return BuffSize;
-}
-
-- (NSInteger)size
-{
-    ANTLRMapElement *anElement;
-    NSInteger aSize = 0;
-
-    for (int i = 0; i < BuffSize; i++) {
-        if ((anElement = ptrBuffer[i]) != nil) {
-            aSize += (NSInteger)[anElement size];
-        }
-    }
-    return aSize;
-}
-
-#ifdef USERDOC
-/*
- *  HASH        hash entry to get index to table
- *  NSInteger hash( ANTLRMap *self, char *s );
- *
- *     Inputs:  NSString *s         string to find
- *
- *     Returns: NSInteger                 hashed value
- *
- *  Last Revision 9/03/90
- */
-#endif
--(NSInteger)hash:(NSString *)s       /*    form hash value for string s */
-{
-	NSInteger hashval;
-	const char *tmp;
-
-	tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
-	for( hashval = 0; *tmp != '\0'; )
-        hashval += *tmp++;
-	self->lastHash = hashval % HASHSIZE;
-	return( self->lastHash );
-}
-
-#ifdef USERDOC
-/*
- *  LOOKUP  search hashed list for entry
- *  ANTLRMapElement *lookup:(NSString *)s;
- *
- *     Inputs:  NSString  *s       string to find
- *
- *     Returns: ANTLRMapElement  *        pointer to entry
- *
- *  Last Revision 9/03/90
- */
-#endif
--(id)lookup:(NSString *)s
-{
-    ANTLRMapElement *np;
-
-    for( np = self->ptrBuffer[[self hash:s]]; np != nil; np = [np getfNext] ) {
-        if ( [s isEqualToString:[np getName]] ) {
-            return( np );        /*   found it       */
-        }
-    }
-    return( nil );              /*   not found      */
-}
-
-#ifdef USERDOC
-/*
- *  INSTALL search hashed list for entry
- *  NSInteger install( ANTLRMap *self, ANTLRMapElement *sym );
- *
- *     Inputs:  ANTLRMapElement    *sym   -- symbol ptr to install
- *              NSInteger         scope -- level to find
- *
- *     Returns: Boolean     TRUE   if installed
- *                          FALSE  if already in table
- *
- *  Last Revision 9/03/90
- */
-#endif
--(ANTLRMapElement *)install:(ANTLRMapElement *)sym
-{
-    ANTLRMapElement *np;
-
-    np = [self lookup:[sym getName]];
-    if ( np == nil ) {
-        [sym setFNext:ptrBuffer[ lastHash ]];
-        ptrBuffer[ lastHash ] = sym;
-        [sym retain];
-        return( ptrBuffer[ lastHash ] );
-    }
-    return( nil );            /*   not found      */
-}
-
-#ifdef USERDOC
-/*
- *  RemoveSym  search hashed list for entry
- *  NSInteger RemoveSym( ANTLRMap *self, char *s );
- *
- *     Inputs:  char     *s          string to find
- *
- *     Returns: NSInteger      indicator of SUCCESS OR FAILURE
- *
- *  Last Revision 9/03/90
- */
-#endif
--(NSInteger)RemoveSym:(NSString *)s
-{
-    ANTLRMapElement *np, *tmp;
-    NSInteger idx;
-
-    idx = [self hash:s];
-    for ( tmp = self->ptrBuffer[idx], np = self->ptrBuffer[idx]; np != nil; np = [np getfNext] ) {
-        if ( [s isEqualToString:[np getName]] ) {
-            tmp = [np getfNext];             /* get the next link  */
-            [np release];
-            return( SUCCESS );            /* report SUCCESS     */
-        }
-        tmp = [np getfNext];              //  BAD!!!!!!
-    }
-    return( FAILURE );                    /*   not found      */
-}
-
--(void)delete_chain:(ANTLRMapElement *)np
-{
-    if ( [np getfNext] != nil )
-		[self delete_chain:[np getfNext]];
-	[np release];
-}
-
-#ifdef DONTUSEYET
--(NSInteger)bld_symtab:(KW_TABLE *)toknams
-{
-    NSInteger i;
-    ANTLRMapElement *np;
-
-    for( i = 0; *(toknams[i].name) != '\0'; i++ ) {
-        // install symbol in ptrBuffer
-        np = [ANTLRMapElement newANTLRMapElement:[NSString stringWithFormat:@"%s", toknams[i].name]];
-        //        np->fType = toknams[i].toknum;
-        [self install:np Scope:0];
-    }
-    return( SUCCESS );
-}
-#endif
-
-/*
- * works only for maplist indexed not by name but by TokenNumber
- */
-- (ANTLRMapElement *)getName:(NSInteger)ttype
-{
-    ANTLRMapElement *np;
-    NSInteger aTType;
-
-    aTType = ttype % HASHSIZE;
-    for( np = self->ptrBuffer[ttype]; np != nil; np = [np getfNext] ) {
-        if ( [(NSNumber *)np.node integerValue] == ttype ) {
-            return( np );        /*   found it       */
-        }
-    }
-    return( nil );              /*   not found      */
-}
-
-- (NSInteger)getNode:(id<ANTLRBaseTree>)aNode
-{
-    ANTLRMapElement *np;
-    NSInteger idx;
-
-    idx = [(id<ANTLRBaseTree>)aNode type];
-    idx %= HASHSIZE;
-    np = ptrBuffer[idx];
-    return( [(NSNumber *)np.node integerValue] );
-}
-
-- (ANTLRMapElement *)getTType:(NSString *)name
-{
-    return [self lookup:name];
-}
-
-// create node and install node in ptrBuffer
-- (void)putName:(NSString *)name TType:(NSInteger)ttype
-{
-    ANTLRMapElement *np;
-
-    np = [ANTLRMapElement newANTLRMapElementWithName:[NSString stringWithString:name] Type:ttype];
-    [self install:np];
-}
-
-// create node and install node in ptrBuffer
-- (void)putName:(NSString *)name Node:(id)aNode
-{
-    ANTLRMapElement *np, *np1;
-    NSInteger idx;
-
-    idx = [self hash:name];
-    np1 = [ANTLRMapElement newANTLRMapElementWithName:[NSString stringWithString:name] Type:idx];
-    np = [self lookup:name];
-    if ( np == nil ) {
-        [np1 setFNext:self->ptrBuffer[ self->lastHash ]];
-        self->ptrBuffer[ self->lastHash ] = np1;
-        [np1 retain];
-    }
-    else {
-        // ptrBuffer[idx] = np;
-    }
-    return;
-}
-
-// create node and install node in ptrBuffer
-- (void)putNode:(NSInteger)aTType Node:(id)aNode
-{
-    ANTLRMapElement *np;
-    NSInteger ttype;
-
-    ttype = aTType % HASHSIZE;
-    np = [ANTLRMapElement newANTLRMapElementWithNode:ttype Node:(id)aNode];
-    ptrBuffer[ttype] = np;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMapElement.h b/runtime/ObjC/Framework/ANTLRMapElement.h
deleted file mode 100644
index e20d01c..0000000
--- a/runtime/ObjC/Framework/ANTLRMapElement.h
+++ /dev/null
@@ -1,65 +0,0 @@
-//
-//  ANTLRMapElement.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/8/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseMapElement.h"
-
-@interface ANTLRMapElement : ANTLRBaseMapElement {
-    NSString *name;
-    id        node;
-}
-@property (retain, getter=getName, setter=setName:) NSString *name;
-@property (retain, getter=getNode, setter=setNode:) id node;
-
-+ (id) newANTLRMapElement;
-+ (id) newANTLRMapElementWithName:(NSString *)aName Type:(NSInteger)aTType;
-+ (id) newANTLRMapElementWithNode:(NSInteger)aTType Node:(id)aNode;
-+ (id) newANTLRMapElementWithName:(NSString *)aName Node:(id)aNode;
-+ (id) newANTLRMapElementWithObj1:(id)anObj1 Obj2:(id)anObj2;
-- (id) init;
-- (id) initWithName:(NSString *)aName Type:(NSInteger)aTType;
-- (id) initWithNode:(NSInteger)aTType Node:(id)aNode;
-- (id) initWithName:(NSString *)aName Node:(id)aNode;
-- (id) initWithObj1:(id)anObj1 Obj2:(id)anObj2;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (NSInteger) count;
-- (NSInteger) size;
-- (NSString *)getName;
-- (void)setName:(NSString *)aName;
-- (id)getNode;
-- (void)setNode:(id)aNode;
-- (void)putNode:(id)aNode;
-- (void)putNode:(id)aNode With:(NSInteger)uniqueID;
-//- (void)setObject:(id)aNode atIndex:anIndex;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMapElement.m b/runtime/ObjC/Framework/ANTLRMapElement.m
deleted file mode 100644
index bce1c9f..0000000
--- a/runtime/ObjC/Framework/ANTLRMapElement.m
+++ /dev/null
@@ -1,207 +0,0 @@
-//
-//  ANTLRMapElement.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/8/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRMapElement.h"
-
-
-@implementation ANTLRMapElement
-
-@synthesize name;
-@synthesize node;
-
-+ (id) newANTLRMapElement
-{
-    return [[ANTLRMapElement alloc] init];
-}
-
-+ (id) newANTLRMapElementWithName:(NSString *)aName Type:(NSInteger)aTType
-{
-    return [[ANTLRMapElement alloc] initWithName:aName Type:aTType];
-}
-
-+ (id) newANTLRMapElementWithNode:(NSInteger)aTType Node:(id)aNode
-{
-    return [[ANTLRMapElement alloc] initWithNode:aTType Node:aNode];
-}
-
-+ (id) newANTLRMapElementWithName:(NSString *)aName Node:(id)aNode
-{
-    return [[ANTLRMapElement alloc] initWithName:aName Node:aNode];
-}
-
-+ (id) newANTLRMapElementWithObj1:(id)anObj1 Obj2:(id)anObj2
-{
-    return [[ANTLRMapElement alloc] initWithObj1:anObj1 Obj2:anObj2];
-}
-
-- (id) init
-{
-    self = [super init];
-    if ( self != nil ) {
-        index = nil;
-        name  = nil;
-    }
-    return self;
-}
-
-- (id) initWithName:(NSString *)aName Type:(NSInteger)aTType
-{
-    self = [super init];
-    if ( self != nil ) {
-        index = [[NSNumber numberWithInteger: aTType] retain];
-        name  = [[NSString stringWithString:aName] retain];
-    }
-    return self;
-}
-
-- (id) initWithNode:(NSInteger)aTType Node:(id)aNode
-{
-    self = [super initWithAnIndex:[NSNumber numberWithInteger:aTType]];
-    if ( self != nil ) {
-        node  = aNode;
-        if ( node ) [node retain];
-    }
-    return self;
-}
-
-- (id) initWithName:(NSString *)aName Node:(id)aNode
-{
-    self = [super init];
-    if ( self != nil ) {
-        name  = [[NSString stringWithString:aName] retain];
-        node = aNode;
-        if ( node ) [node retain];
-    }
-    return self;
-}
-
-- (id) initWithObj1:(id)anIndex Obj2:(id)aNode
-{
-    self = [super initWithAnIndex:anIndex];
-    if ( self != nil ) {
-        node = aNode;
-        if ( node ) [node retain];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRMapElement" );
-#endif
-    if ( name ) [name release];
-    if ( node ) [node release];
-    [super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRMapElement *copy;
-
-    copy = [super copyWithZone:aZone];
-    if (name) copy.name = name;
-    if (node) copy.node = node;
-    return( copy );
-}
-
-- (NSInteger) count
-{
-    NSInteger aCnt = 0;
-    if (name != nil) aCnt++;;
-    if (node != nil) aCnt++;;
-    return aCnt;
-}
-
-- (NSInteger)size
-{
-    NSInteger aSize = 0;
-    if ( name ) aSize += sizeof(id);
-    if ( node ) aSize += sizeof(id);
-    return aSize;
-}
-
-
-- (NSString *)getName
-{
-    return name;
-}
-
-- (void)setName:(NSString *)aName
-{
-    if ( aName != name ) {
-        if ( name ) [name release];
-        [aName retain];
-    }
-    name = aName;
-}
-
-- (id)getNode
-{
-    return node;
-}
-
-- (void)setNode:(id)aNode
-{   if ( aNode != node ) {
-        if ( node ) [node release];
-        [aNode retain];
-    }
-    node = aNode;
-}
-
-- (void)putNode:(id)aNode
-{
-    index = ((ANTLRMapElement *)aNode).index;
-    if (((ANTLRMapElement *)aNode).name) {
-        name = [((ANTLRMapElement *)aNode).name retain];
-        node = nil;
-    }
-    if (((ANTLRMapElement *)aNode).node) {
-        name = nil;
-        node = [((ANTLRMapElement *)aNode).node retain];
-    }
-}
-
-- (void)putNode:(id)aNode With:(NSInteger)uniqueID
-{
-    index = ((ANTLRMapElement *)aNode).index;
-    if (((ANTLRMapElement *)aNode).name) {
-        name = [((ANTLRMapElement *)aNode).name retain];
-        node = nil;
-    }
-    if (((ANTLRMapElement *)aNode).node) {
-        name = nil;
-        node = [((ANTLRMapElement *)aNode).node retain];
-    }
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.h b/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.h
deleted file mode 100644
index 95d191d..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.h
+++ /dev/null
@@ -1,51 +0,0 @@
-//
-//  ANTLRMismatchedNotSetException.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/13/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRecognitionException.h"
-#import "ANTLRBitSet.h"
-
-@interface ANTLRMismatchedNotSetException : ANTLRRecognitionException
-{
-    NSString *expecting;
-}
-@property (retain, getter=getExpecting, setter=setExpecting:) NSString *expecting;
-
-- (ANTLRMismatchedNotSetException *)newException;
-- (ANTLRMismatchedNotSetException *)newException:(id<ANTLRIntStream>)anInput
-                                                               Follow:(NSString *)expecting;
-
-- (id) init;
-- (id) initWithStream:(id<ANTLRIntStream>)anInput Follow:(NSString *)expecting;
-
-- (NSString *)toString;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.m b/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.m
deleted file mode 100644
index e43e1b1..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedNotSetException.m
+++ /dev/null
@@ -1,69 +0,0 @@
-//
-//  ANTLRMismatchedNotSetException.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/13/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRMismatchedNotSetException.h"
-
-@implementation ANTLRMismatchedNotSetException
-
-@synthesize expecting;
-
-- (ANTLRMismatchedNotSetException *)newException
-{
-    return [[ANTLRMismatchedNotSetException alloc] init];
-}
-
-- (ANTLRMismatchedNotSetException *)newException:(id<ANTLRIntStream>)anInput
-                                                               Follow:(NSString *)expected
-{
-    return [[ANTLRMismatchedNotSetException alloc] initWithStream:anInput Follow:(NSString *)expected];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil ) {
-    }
-    return(self);
-}
-
-- (id) initWithStream:(id<ANTLRIntStream>)anInput Follow:(NSString *)expected
-{
-    if ((self = [super initWithStream:anInput]) != nil ) {
-        expecting = expected;
-    }
-    return(self);
-}
-
-- (NSString *)toString
-{
-    return [NSString stringWithFormat:@"MismatchedNotSetException( %d != %@ )", [self unexpectedType], expecting];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedRangeException.h b/runtime/ObjC/Framework/ANTLRMismatchedRangeException.h
deleted file mode 100644
index 678af61..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedRangeException.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRecognitionException.h"
-
-@protocol ANTLRIntStream;
-
-
-@interface ANTLRMismatchedRangeException : ANTLRRecognitionException {
-	NSRange range;
-}
-
-@property (assign) NSRange range;
-
-+ (id) newException:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput;
-- (id) initWithRange:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedRangeException.m b/runtime/ObjC/Framework/ANTLRMismatchedRangeException.m
deleted file mode 100644
index 0647254..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedRangeException.m
+++ /dev/null
@@ -1,55 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRMismatchedRangeException.h"
-
-
-@implementation ANTLRMismatchedRangeException
-
-@synthesize range;
-
-+ (id) newException:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput
-{
-	return [[ANTLRMismatchedRangeException alloc] initWithRange:aRange stream:theInput];
-}
-
-- (id) initWithRange:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput
-{
-	if ((self = [super initWithStream:theInput]) != nil) {
-		range = aRange;
-	}
-	return self;
-}
-
-- (NSString *) description
-{
-	NSMutableString *desc = (NSMutableString *)[super description];
-	[desc appendFormat:@" range:%@", NSStringFromRange(range)];
-	return desc;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedSetException.h b/runtime/ObjC/Framework/ANTLRMismatchedSetException.h
deleted file mode 100644
index 0610973..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedSetException.h
+++ /dev/null
@@ -1,44 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRecognitionException.h"
-
-@interface ANTLRMismatchedSetException : ANTLRRecognitionException {
-	NSString *expecting;
-}
-
-@property (retain, getter=getExpecting, setter=setExpecting:) NSString *expecting;
-
-+ (id) newException:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream;
-- (id) initWithSet:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream;
-
-- (NSString *) getExpecting;
-- (void) setExpecting: (NSString *) anExpectedSet;
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedSetException.m b/runtime/ObjC/Framework/ANTLRMismatchedSetException.m
deleted file mode 100644
index b5248d2..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedSetException.m
+++ /dev/null
@@ -1,79 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRMismatchedSetException.h"
-
-
-@implementation ANTLRMismatchedSetException
-
-@synthesize expecting;
-
-+ (id) newException:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream
-{
-	return [[ANTLRMismatchedSetException alloc] initWithSet:theExpectedSet stream:theStream];
-}
-
-- (id) initWithSet:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream
-{
-	if ((self = [super initWithStream:theStream]) != nil) {
-		[self setExpecting:theExpectedSet];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-	[self setExpecting:nil];
-	[super dealloc];
-}
-
-- (NSString *) description
-{
-	NSMutableString *desc =(NSMutableString *)[super description];
-	[desc appendFormat:@" set:%@", expecting];
-	return desc;
-}
-
-
-//----------------------------------------------------------
-//  expectedSet
-//----------------------------------------------------------
-- (NSString *) getExpecting
-{
-    return expecting;
-}
-
-- (void) setExpecting: (NSString *) anExpectedSet
-{
-    if ( expecting != anExpectedSet ) {
-        if ( expecting ) [expecting release];
-        [anExpectedSet retain];
-        expecting = anExpectedSet;
-    }
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedTokenException.h b/runtime/ObjC/Framework/ANTLRMismatchedTokenException.h
deleted file mode 100644
index 8e28dcc..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedTokenException.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRecognitionException.h"
-#import "ANTLRBitSet.h"
-
-@protocol ANTLRIntStream;
-
-@interface ANTLRMismatchedTokenException : ANTLRRecognitionException {
-	NSInteger expecting;
-	unichar expectingChar;
-	BOOL isTokenType;
-}
-
-@property (assign, getter=getExpecting, setter=setExpecting:) NSInteger expecting;
-@property (assign, getter=getExpectingChar, setter=setExpectingChar:) unichar expectingChar;
-@property (assign, getter=getIsTokenType, setter=setIsTokenType:) BOOL isTokenType;
-
-+ (id) newException:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput;
-+ (id) newExceptionMissing:(NSInteger)expectedTokenType
-                                        Stream:(id<ANTLRIntStream>)anInput
-                                         Token:(id<ANTLRToken>)inserted;
-+ (id) newExceptionChar:(unichar)expectedCharacter Stream:(id<ANTLRIntStream>)anInput;
-+ (id) newExceptionStream:(id<ANTLRIntStream>)anInput
-                                    Exception:(NSException *)e
-                                       Follow:(ANTLRBitSet *)follow;
-- (id) initWithTokenType:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput;
--(id) initWithTokenType:(NSInteger)expectedTokenType
-                 Stream:(id<ANTLRIntStream>)anInput
-                  Token:(id<ANTLRToken>)inserted;
-- (id) initWithCharacter:(unichar)expectedCharacter Stream:(id<ANTLRIntStream>)anInput;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedTokenException.m b/runtime/ObjC/Framework/ANTLRMismatchedTokenException.m
deleted file mode 100644
index a8807fa..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedTokenException.m
+++ /dev/null
@@ -1,99 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRMismatchedTokenException.h"
-
-
-@implementation ANTLRMismatchedTokenException
-
-@synthesize expecting;
-@synthesize expectingChar;
-@synthesize isTokenType;
-
-
-+ (id) newException:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput
-{
-	return [[ANTLRMismatchedTokenException alloc] initWithTokenType:expectedTokenType Stream:anInput];
-}
-
-+ (id) newExceptionMissing:(NSInteger)expectedTokenType
-                                        Stream:(id<ANTLRIntStream>)anInput
-                                         Token:(id<ANTLRToken>)inserted
-{
-	return [[ANTLRMismatchedTokenException alloc] initWithTokenType:expectedTokenType Stream:anInput Token:inserted];
-}
-
-+ (id) newExceptionChar:(unichar) expectedCharacter Stream:(id<ANTLRIntStream>)anInput
-{
-	return [[ANTLRMismatchedTokenException alloc] initWithCharacter:expectedCharacter Stream:anInput];
-}
-
-+ (id) newExceptionStream:(id<ANTLRIntStream>)anInput Exception:(NSException *)e Follow:(ANTLRBitSet *) follow
-{
-	return [[ANTLRMismatchedTokenException alloc] initWithStream:anInput];
-}
-
--(id) initWithTokenType:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput
-{
-	if ((self = [super initWithStream:anInput]) != nil) {
-		expecting = expectedTokenType;
-		isTokenType = YES;
-	}
-	return self;
-}
-
--(id) initWithTokenType:(NSInteger)expectedTokenType
-                 Stream:(id<ANTLRIntStream>)anInput
-                  Token:(id<ANTLRToken>)inserted
-{
-	if ((self = [super initWithStream:anInput]) != nil) {
-		expecting = expectedTokenType;
-		isTokenType = YES;
-	}
-	return self;
-}
-
-- (id) initWithCharacter:(unichar) expectedCharacter Stream:(id<ANTLRIntStream>)anInput
-{
-	if ((self = [super initWithStream:anInput]) != nil) {
-		expectingChar = expectedCharacter;
-		isTokenType = NO;
-	}
-	return self;
-}
-
-- (NSString *) description
-{
-	NSMutableString *desc = (NSMutableString *)[super description];
-	if (isTokenType) {
-		[desc appendFormat:@" expected:%d got:%d", expecting, [self unexpectedType]];
-	} else {
-		[desc appendFormat:@" expected:%c got:%c", expectingChar, (unichar)[self unexpectedType]];
-	}
-	return desc;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedTreeNodeException.h b/runtime/ObjC/Framework/ANTLRMismatchedTreeNodeException.h
deleted file mode 100644
index 3528cba..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedTreeNodeException.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRecognitionException.h"
-
-@protocol ANTLRIntStream;
-
-@interface ANTLRMismatchedTreeNodeException : ANTLRRecognitionException {
-	NSInteger expecting;
-}
-
-@property (getter=getExpecting, setter=setExpecting:) NSInteger expecting;
-
-+ (id) newException:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput;
-- (id) initWithTokenType:(NSInteger) expectedTokenType Stream:(id<ANTLRIntStream>)anInput;
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMismatchedTreeNodeException.m b/runtime/ObjC/Framework/ANTLRMismatchedTreeNodeException.m
deleted file mode 100644
index 60d5184..0000000
--- a/runtime/ObjC/Framework/ANTLRMismatchedTreeNodeException.m
+++ /dev/null
@@ -1,54 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRMismatchedTreeNodeException.h"
-
-
-@implementation ANTLRMismatchedTreeNodeException
-
-@synthesize expecting;
-
-+ (id) newException:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput
-{
-	return [[ANTLRMismatchedTreeNodeException alloc] initWithTokenType:expectedTokenType Stream:anInput];
-}
-
--(id) initWithTokenType:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput
-{
-	if ((self = [super initWithStream:anInput]) != nil) {
-		expecting = expectedTokenType;
-	}
-	return self;
-}
-
-- (NSString *) description
-{
-	NSMutableString *desc = (NSMutableString *)[super description];
-	[desc appendFormat:@" expected:%d got:%d", expecting, [self unexpectedType]];
-	return desc;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMissingTokenException.h b/runtime/ObjC/Framework/ANTLRMissingTokenException.h
deleted file mode 100644
index 1ae8103..0000000
--- a/runtime/ObjC/Framework/ANTLRMissingTokenException.h
+++ /dev/null
@@ -1,52 +0,0 @@
-//
-//  ANTLRMissingTokenException.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/8/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRMismatchedTokenException.h"
-#import "ANTLRToken.h"
-
-@interface ANTLRMissingTokenException : ANTLRMismatchedTokenException {
-    id<ANTLRToken> inserted;
-}
-/** Used for remote debugger deserialization */
-+ (id) newException;
-+ (id) newException:(NSInteger)expected
-             Stream:(id<ANTLRIntStream>)anInput
-               With:(id<ANTLRToken>)insertedToken;
-- (id) init;
-- (id) init:(NSInteger)expected Stream:(id<ANTLRIntStream>)anInput With:(id<ANTLRToken>)insertedToken;
-
-- (NSInteger) getMissingType;
-
-- (NSString *)toString;
-
-@property (retain) id<ANTLRToken> inserted;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRMissingTokenException.m b/runtime/ObjC/Framework/ANTLRMissingTokenException.m
deleted file mode 100644
index 35bd130..0000000
--- a/runtime/ObjC/Framework/ANTLRMissingTokenException.m
+++ /dev/null
@@ -1,83 +0,0 @@
-//
-//  ANTLRMissingTokenException.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/8/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRMissingTokenException.h"
-
-
-@implementation ANTLRMissingTokenException
-/** Used for remote debugger deserialization */
-+ (id) newException
-{
-    return [[ANTLRMissingTokenException alloc] init];
-}
-
-+ (id) newException:(NSInteger)expected
-             Stream:(id<ANTLRIntStream>)anInput
-               With:(id<ANTLRToken>)insertedToken
-{
-    return [[ANTLRMissingTokenException alloc] init:expected Stream:anInput With:insertedToken];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil) {
-    }
-    return self;
-}
-
-- (id) init:(NSInteger)expected Stream:(id<ANTLRIntStream>)anInput With:(id<ANTLRToken>)insertedToken
-{
-    if ((self = [super initWithStream:anInput]) != nil) {
-        expecting = expected;
-        input = anInput;
-        inserted = insertedToken;
-    }
-    return self;
-}
-
-- (NSInteger) getMissingType
-{
-    return expecting;
-}
-
-- (NSString *)toString
-{
-    if ( inserted != nil && token != nil ) {
-        return [NSString stringWithFormat:@"MissingTokenException(inserted %@ at %@)", inserted, token.text];
-    }
-    if ( token!=nil ) {
-        return [NSString stringWithFormat:@"MissingTokenException(at %@)", token.text ];
-    }
-    return @"MissingTokenException";
-}
-
-@synthesize inserted;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRNoViableAltException.h b/runtime/ObjC/Framework/ANTLRNoViableAltException.h
deleted file mode 100644
index 9b2e521..0000000
--- a/runtime/ObjC/Framework/ANTLRNoViableAltException.h
+++ /dev/null
@@ -1,45 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRecognitionException.h"
-#import "ANTLRIntStream.h"
-
-@interface ANTLRNoViableAltException : ANTLRRecognitionException {
-	int decisionNumber;
-	int stateNumber;
-}
-
-+ (ANTLRNoViableAltException *) newException:(NSInteger)theDecisionNumber state:(NSInteger)theStateNumber stream:(id<ANTLRIntStream>)theStream;
-- (ANTLRNoViableAltException *) initWithDecision:(NSInteger)theDecisionNumber state:(NSInteger)theStateNumber stream:(id<ANTLRIntStream>)theStream;
-
-- (void)setDecisionNumber:(NSInteger)decisionNumber;
-- (void)setStateNumber:(NSInteger)stateNumber;
-
-
-@property (getter=decisionNumber,setter=setDecisionNumber:) NSInteger decisionNumber;
-@property (getter=stateNumber,setter=setStateNumber:) NSInteger stateNumber;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRNoViableAltException.m b/runtime/ObjC/Framework/ANTLRNoViableAltException.m
deleted file mode 100644
index e519581..0000000
--- a/runtime/ObjC/Framework/ANTLRNoViableAltException.m
+++ /dev/null
@@ -1,83 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRNoViableAltException.h"
-
-
-@implementation ANTLRNoViableAltException
-
-
-+ (ANTLRNoViableAltException *) newException:(NSInteger)theDecisionNumber state:(NSInteger)theStateNumber stream:(id<ANTLRIntStream>)theStream
-{
-	return [[self alloc] initWithDecision:theDecisionNumber state:theStateNumber stream:theStream];
-}
-
-
-- (ANTLRNoViableAltException *) initWithDecision:(NSInteger)theDecisionNumber state:(NSInteger)theStateNumber stream:(id<ANTLRIntStream>)theStream
-{
-	if ((self = [super initWithStream:theStream]) != nil) {
-		decisionNumber = theDecisionNumber;
-		stateNumber = theStateNumber;
-	}
-	return self;
-}
-
-- (NSString *) description
-{
-	NSMutableString *desc = (NSMutableString *)[super description];
-	[desc appendFormat:@" decision:%d state:%d", decisionNumber, stateNumber];
-	return desc;
-}
-
-//----------------------------------------------------------
-//  decisionNumber
-//----------------------------------------------------------
-- (NSInteger) decisionNumber
-{
-    return decisionNumber;
-}
-
-- (void) setDecisionNumber: (NSInteger) aDecisionNumber
-{
-    decisionNumber = aDecisionNumber;
-}
-
-//----------------------------------------------------------
-//  stateNumber
-//----------------------------------------------------------
-- (NSInteger) stateNumber
-{
-    return stateNumber;
-}
-
-- (void) setStateNumber: (NSInteger) aStateNumber
-{
-    stateNumber = aStateNumber;
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRNodeMapElement.h b/runtime/ObjC/Framework/ANTLRNodeMapElement.h
deleted file mode 100644
index 3bbf7b7..0000000
--- a/runtime/ObjC/Framework/ANTLRNodeMapElement.h
+++ /dev/null
@@ -1,56 +0,0 @@
-//
-//  ANTLRRuleMapElement.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseMapElement.h"
-#import "ANTLRBaseTree.h"
-
-@interface ANTLRNodeMapElement : ANTLRBaseMapElement {
-    id<ANTLRBaseTree> node;
-}
-
-@property (retain, getter=getNode, setter=setNode:) id<ANTLRBaseTree> node;
-
-+ (void)initialize;
-
-+ (id) newANTLRNodeMapElement;
-+ (id) newANTLRNodeMapElementWithIndex:(id)anIndex Node:(id<ANTLRBaseTree>)aNode;
-- (id) init;
-- (id) initWithAnIndex:(id)anIndex Node:(id)aNode;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (id<ANTLRBaseTree>)getNode;
-- (void)setNode:(id<ANTLRBaseTree>)aNode;
-
-- (NSInteger)size;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRNodeMapElement.m b/runtime/ObjC/Framework/ANTLRNodeMapElement.m
deleted file mode 100644
index 06f35cc..0000000
--- a/runtime/ObjC/Framework/ANTLRNodeMapElement.m
+++ /dev/null
@@ -1,108 +0,0 @@
-//
-//  ANTLRNodeMapElement.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRNodeMapElement.h"
-
-static NSInteger _aUniqueID;
-
-@implementation ANTLRNodeMapElement
-
-@synthesize node;
-
-+ (void)initialize
-{
-    _aUniqueID = 0;
-}
-
-+ (ANTLRNodeMapElement *)newANTLRNodeMapElement
-{
-    return [[ANTLRNodeMapElement alloc] init];
-}
-
-+ (ANTLRNodeMapElement *)newANTLRNodeMapElementWithIndex:(id)anIndex Node:(id<ANTLRBaseTree>)aNode
-{
-    return [[ANTLRNodeMapElement alloc] initWithAnIndex:anIndex Node:aNode];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil ) {
-        index = nil;
-        node = nil;
-    }
-    return (self);
-}
-
-- (id) initWithAnIndex:(id)anIndex Node:(id)aNode
-{
-    self = [super initWithAnIndex:anIndex];
-    if ( self ) {
-        if ( aNode != node ) {
-            if ( node ) [node release];
-            [aNode retain];
-        }
-        node = aNode;
-    }
-    return (self);
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRNodeMapElement *copy;
-
-    copy = [super copyWithZone:aZone];
-    copy.node = node;
-    return( copy );
-}
-
-- (id<ANTLRBaseTree>)getNode
-{
-    return node;
-}
-
-- (void)setNode:(id<ANTLRBaseTree>)aNode
-{
-    if ( aNode != node ) {
-        if ( node ) [node release];
-        [aNode retain];
-    }
-    node = aNode;
-}
-
-- (NSInteger)size
-{
-    NSInteger aSize = 0;
-    if (node != nil) aSize += sizeof(id);
-    if (index != nil) aSize += sizeof(id);
-    return( aSize );
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRParseTree.h b/runtime/ObjC/Framework/ANTLRParseTree.h
deleted file mode 100644
index 5331005..0000000
--- a/runtime/ObjC/Framework/ANTLRParseTree.h
+++ /dev/null
@@ -1,64 +0,0 @@
-//
-//  ANTLRParseTree.h
-//  ANTLR
-//
-//  Created by Alan Condit on 7/12/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseTree.h"
-#import "ANTLRCommonToken.h"
-#import "AMutableArray.h"
-
-@interface ANTLRParseTree : ANTLRBaseTree <ANTLRBaseTree> {
-	__strong id<ANTLRToken> payload;
-	__strong AMutableArray *hiddenTokens;
-}
-/** A record of the rules used to match a token sequence.  The tokens
- *  end up as the leaves of this tree and rule nodes are the interior nodes.
- *  This really adds no functionality, it is just an alias for CommonTree
- *  that is more meaningful (specific) and holds a String to display for a node.
- */
-+ (id<ANTLRBaseTree>)newANTLRParseTree:(id<ANTLRToken>)label;
-- (id)initWithLabel:(id<ANTLRToken>)label;
-
-- (id<ANTLRBaseTree>)dupNode;
-- (NSInteger)type;
-- (NSString *)text;
-- (NSInteger)getTokenStartIndex;
-- (void)setTokenStartIndex:(NSInteger)index;
-- (NSInteger)getTokenStopIndex;
-- (void)setTokenStopIndex:(NSInteger)index;
-- (NSString *)description;
-- (NSString *)toString;
-- (NSString *)toStringWithHiddenTokens;
-- (NSString *)toInputString;
-- (void)_toStringLeaves:(NSMutableString *)buf;
-
-@property (retain) id<ANTLRToken> payload;
-@property (retain) AMutableArray *hiddenTokens;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRParseTree.m b/runtime/ObjC/Framework/ANTLRParseTree.m
deleted file mode 100644
index 8339640..0000000
--- a/runtime/ObjC/Framework/ANTLRParseTree.m
+++ /dev/null
@@ -1,149 +0,0 @@
-//
-//  ANTLRParseTree.m
-//  ANTLR
-//
-//  Created by Alan Condit on 7/12/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRParseTree.h"
-
-/** A record of the rules used to match a token sequence.  The tokens
- *  end up as the leaves of this tree and rule nodes are the interior nodes.
- *  This really adds no functionality, it is just an alias for CommonTree
- *  that is more meaningful (specific) and holds a String to display for a node.
- */
-@implementation ANTLRParseTree
-+ (ANTLRParseTree *)newANTLRParseTree:(id<ANTLRToken>)label
-{
-    return [[ANTLRParseTree alloc] initWithLabel:label];
-}
-
-- (id)initWithLabel:(id<ANTLRToken>)label
-{
-    self = [super init];
-    if ( self != nil) {
-        payload = [label retain];
-    }
-    return self;
-}
-
-- (id<ANTLRBaseTree>)dupNode
-{
-    return nil;
-}
-
-- (NSInteger)type
-{
-    return 0;
-}
-
-- (NSString *)text
-{
-    return [self toString];
-}
-
-- (NSInteger)getTokenStartIndex
-{
-    return 0;
-}
-
-- (void)setTokenStartIndex:(NSInteger)anIndex
-{
-}
-
-- (NSInteger)getTokenStopIndex
-{
-    return 0;
-}
-
-- (void)setTokenStopIndex:(NSInteger)anIndex
-{
-}
-
-- (NSString *)description
-{
-    if ( [payload isKindOfClass:[ANTLRCommonToken class]] ) {
-        id<ANTLRToken> t = (id<ANTLRToken>)payload;
-        if ( t.type == ANTLRTokenTypeEOF ) {
-            return @"<EOF>";
-        }
-        return [t text];
-    }
-    return [payload description];
-}
-
-- (NSString *)toString
-{
-    return [self description];
-}
-
-/** Emit a token and all hidden nodes before.  EOF node holds all
- *  hidden tokens after last real token.
- */
-- (NSString *)toStringWithHiddenTokens
-{
-    NSMutableString *buf = [NSMutableString stringWithCapacity:25];
-    if ( hiddenTokens!=nil ) {
-        for (NSUInteger i = 0; i < [hiddenTokens count]; i++) {
-            id<ANTLRToken>  hidden = (id<ANTLRToken> ) [hiddenTokens objectAtIndex:i];
-            [buf appendString:[hidden text]];
-        }
-    }
-    NSString *nodeText = [self toString];
-    if ( ![nodeText isEqualTo:@"<EOF>"] )
-        [buf appendString:nodeText];
-    return buf;
-}
-
-/** Print out the leaves of this tree, which means printing original
- *  input back out.
- */
-- (NSString *)toInputString
-{
-    NSMutableString *buf = [NSMutableString stringWithCapacity:25];
-    [self _toStringLeaves:buf];
-    return buf;
-}
-
-- (void)_toStringLeaves:(NSMutableString *)buf
-{
-    if ( [payload isKindOfClass:[ANTLRCommonToken class]] ) { // leaf node token?
-        [buf appendString:[self toStringWithHiddenTokens]];
-        return;
-    }
-    for (int i = 0; children!=nil && i < [children count]; i++) {
-        ANTLRParseTree *t = (ANTLRParseTree *) [children objectAtIndex:i];
-        [t _toStringLeaves:buf];
-    }
-}
-
-@synthesize payload;
-@synthesize hiddenTokens;
-@synthesize children;
-@synthesize anException;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRParser.h b/runtime/ObjC/Framework/ANTLRParser.h
deleted file mode 100644
index 067b313..0000000
--- a/runtime/ObjC/Framework/ANTLRParser.h
+++ /dev/null
@@ -1,59 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseRecognizer.h"
-#import "ANTLRCommonToken.h"
-#import "ANTLRTokenStream.h"
-
-@interface ANTLRParser : ANTLRBaseRecognizer {
-	id<ANTLRTokenStream> input;
-}
-+ (ANTLRParser *)newANTLRParser:(id<ANTLRTokenStream>)anInput;
-+ (ANTLRParser *)newANTLRParser:(id<ANTLRTokenStream>)anInput State:(ANTLRRecognizerSharedState *)aState;
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream;
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream State:(ANTLRRecognizerSharedState *)aState;
-
-- (id<ANTLRTokenStream>) input;
-- (void) setInput: (id<ANTLRTokenStream>) anInput;
-
-- (void) reset;
-
-- (id) getCurrentInputSymbol:(id<ANTLRTokenStream>)anInput;
-- (ANTLRCommonToken *)getMissingSymbol:(id<ANTLRTokenStream>)input
-                             Exception:(ANTLRRecognitionException *)e
-                                 TType:(NSInteger)expectedTokenType
-                                BitSet:(ANTLRBitSet *)follow;
-- (void) setTokenStream:(id<ANTLRTokenStream>)anInput;
-- (id<ANTLRTokenStream>)getTokenStream;
-- (NSString *)getSourceName;
-
-- (void) traceIn:(NSString *)ruleName Index:(int)ruleIndex;
-- (void) traceOut:(NSString *)ruleName Index:(NSInteger) ruleIndex;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRParser.m b/runtime/ObjC/Framework/ANTLRParser.m
deleted file mode 100644
index df559b2..0000000
--- a/runtime/ObjC/Framework/ANTLRParser.m
+++ /dev/null
@@ -1,147 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRParser.h"
-
-
-@implementation ANTLRParser
-
-+ (ANTLRParser *)newANTLRParser:(id<ANTLRTokenStream>)anInput
-{
-    return [[ANTLRParser alloc] initWithTokenStream:anInput];
-}
-
-+ (ANTLRParser *)newANTLRParser:(id<ANTLRTokenStream>)anInput State:(ANTLRRecognizerSharedState *)aState
-{
-    return [[ANTLRParser alloc] initWithTokenStream:anInput State:aState];
-}
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
-{
-	if ((self = [super init]) != nil) {
-		input = theStream;
-	}
-	return self;
-}
-
-- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream State:(ANTLRRecognizerSharedState *)aState
-{
-	if ((self = [super initWithState:aState]) != nil) {
-        input = theStream;
-	}
-	return self;
-}
-
-- (void) reset
-{
-    [super reset]; // reset all recognizer state variables
-    if ( input!=nil ) {
-        [input seek:0]; // rewind the input
-    }
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRParser" );
-#endif
-	[self setInput:nil];
-	[super dealloc];
-}
-
-//----------------------------------------------------------
-//  input
-//----------------------------------------------------------
-- (id<ANTLRTokenStream>) input
-{
-    return input;
-}
-
-- (void) setInput: (id<ANTLRTokenStream>) anInput
-{
-    if (input != anInput) {
-        if ( input ) [input release];
-        [anInput retain];
-    }
-    input = anInput;
-}
-
-- (id) getCurrentInputSymbol:(id<ANTLRTokenStream>)anInput
-{
-    state.token = [input LT:1];
-    return state.token;
-}
-
-- (ANTLRCommonToken *)getMissingSymbol:(id<ANTLRTokenStream>)anInput
-                             Exception:(ANTLRRecognitionException *)e
-                                 TType:(NSInteger)expectedTokenType
-                                BitSet:(ANTLRBitSet *)follow
-{
-    NSString *tokenText = nil;
-    if ( expectedTokenType == ANTLRTokenTypeEOF )
-        tokenText = @"<missing EOF>";
-    else
-        tokenText = [NSString stringWithFormat:@"<missing %@>\n",[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:expectedTokenType]];
-    ANTLRCommonToken *t = [[ANTLRCommonToken newToken:expectedTokenType Text:tokenText] retain];
-    ANTLRCommonToken *current = [anInput LT:1];
-    if ( current.type == ANTLRTokenTypeEOF ) {
-        current = [anInput LT:-1];
-    }
-    t.line = current.line;
-    t.charPositionInLine = current.charPositionInLine;
-    t.channel = ANTLRTokenChannelDefault;
-    return t;
-}
-
-/** Set the token stream and reset the parser */
-- (void) setTokenStream:(id<ANTLRTokenStream>)anInput
-{
-    input = nil;
-    [self reset];
-    input = anInput;
-}
-
-- (id<ANTLRTokenStream>)getTokenStream
-{
-    return input;
-}
-
-- (NSString *)getSourceName
-{
-    return [input getSourceName];
-}
-
-- (void) traceIn:(NSString *)ruleName Index:(int)ruleIndex
-{
-    [super traceIn:ruleName Index:ruleIndex Object:[input LT:1]];
-}
-
-- (void) traceOut:(NSString *)ruleName Index:(NSInteger) ruleIndex
-{
-    [super traceOut:ruleName Index:ruleIndex Object:[input LT:1]];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.h b/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.h
deleted file mode 100644
index d788c21..0000000
--- a/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.h
+++ /dev/null
@@ -1,46 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRToken.h"
-#import "ANTLRRuleReturnScope.h"
-
-@interface ANTLRParserRuleReturnScope : ANTLRRuleReturnScope {
-	id<ANTLRToken> start;
-	id<ANTLRToken> stopToken;
-}
-@property (retain, getter=getStart, setter=setStart:) id<ANTLRToken> start;
-@property (retain, getter=getStop, setter=setStop:)   id<ANTLRToken> stopToken;
-
-- (id<ANTLRToken>) getStart;
-- (void) setStart: (id<ANTLRToken>) aStart;
-
-- (id<ANTLRToken>) getStop;
-- (void) setStop: (id<ANTLRToken>) aStop;
-
-- (id) copyWithZone:(NSZone *)theZone;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.m b/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.m
deleted file mode 100644
index 2bc2392..0000000
--- a/runtime/ObjC/Framework/ANTLRParserRuleReturnScope.m
+++ /dev/null
@@ -1,80 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRParserRuleReturnScope.h"
-
-
-@implementation ANTLRParserRuleReturnScope
-
-@synthesize start;
-@synthesize stopToken;
-
-- (void) dealloc
-{
-    [self setStart:nil];
-    [self setStop:nil];
-    [super dealloc];
-}
-
-- (id<ANTLRToken>) getStart
-{
-    return start;
-}
-
-- (void) setStart: (id<ANTLRToken>) aStart
-{
-    if (start != aStart) {
-        [aStart retain];
-        if ( start ) [start release];
-        start = aStart;
-    }
-}
-
-- (id<ANTLRToken>) getStop
-{
-    return stopToken;
-}
-
-- (void) setStop: (id<ANTLRToken>) aStop
-{
-    if (stopToken != aStop) {
-        [aStop retain];
-        if ( stopToken ) [stopToken release];
-        stopToken = aStop;
-    }
-}
-
-// create a copy, including the text if available
-// the input stream is *not* copied!
-- (id) copyWithZone:(NSZone *)theZone
-{
-    ANTLRParserRuleReturnScope *copy = [super copyWithZone:theZone];
-    copy.start = start;
-    copy.stopToken = stopToken;
-    return copy;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRPtrBuffer.h b/runtime/ObjC/Framework/ANTLRPtrBuffer.h
deleted file mode 100644
index baf929b..0000000
--- a/runtime/ObjC/Framework/ANTLRPtrBuffer.h
+++ /dev/null
@@ -1,93 +0,0 @@
-//
-//  ANTLRPtrBuffer.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRLinkBase.h"
-
-//#define GLOBAL_SCOPE       0
-//#define LOCAL_SCOPE        1
-#define BUFFSIZE         101
-
-@interface ANTLRPtrBuffer : ANTLRLinkBase {
-    NSUInteger BuffSize;
-    NSUInteger count;
-    NSUInteger ptr;
-    __strong NSMutableData *buffer;
-    __strong id *ptrBuffer;
-}
-
-@property (getter=getBuffSize, setter=setBuffSize:) NSUInteger BuffSize;
-@property (getter=getCount, setter=setCount:) NSUInteger count;
-@property (getter=getPtr, setter=setPtr:) NSUInteger ptr;
-@property (retain, getter=getBuffer, setter=setBuffer:) NSMutableData *buffer;
-@property (assign, getter=getPtrBuffer, setter=setPtrBuffer:) id *ptrBuffer;
-
-// Contruction/Destruction
-+(ANTLRPtrBuffer *)newANTLRPtrBuffer;
-+(ANTLRPtrBuffer *)newANTLRPtrBufferWithLen:(NSInteger)cnt;
--(id)init;
--(id)initWithLen:(NSUInteger)cnt;
--(void)dealloc;
-
-// Instance Methods
-- (id) copyWithZone:(NSZone *)aZone;
-/* clear -- reinitialize the maplist array */
-- (void) clear;
-
-- (NSUInteger)count;
-- (NSUInteger)length;
-- (NSUInteger)size;
-
-- (NSMutableData *)getBuffer;
-- (void)setBuffer:(NSMutableData *)np;
-- (NSUInteger)getCount;
-- (void)setCount:(NSUInteger)aCount;
-- (id *)getPtrBuffer;
-- (void)setPtrBuffer:(id *)np;
-- (NSUInteger)getPtr;
-- (void)setPtr:(NSUInteger)np;
-
-- (void) push:(id) v;
-- (id) pop;
-- (id) peek;
-
-- (void) addObject:(id) v;
-- (void) addObjectsFromArray:(ANTLRPtrBuffer *)anArray;
-- (void) insertObject:(id)aRule atIndex:(NSUInteger)idx;
-- (id)   objectAtIndex:(NSUInteger)idx;
-- (void) removeAllObjects;
-- (void)removeObjectAtIndex:(NSInteger)idx;
-
-- (void) ensureCapacity:(NSUInteger) index;
-- (NSString *) description;
-- (NSString *) toString;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRPtrBuffer.m b/runtime/ObjC/Framework/ANTLRPtrBuffer.m
deleted file mode 100644
index 392a7b7..0000000
--- a/runtime/ObjC/Framework/ANTLRPtrBuffer.m
+++ /dev/null
@@ -1,353 +0,0 @@
-//
-//  ANTLRPtrBuffer.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#define SUCCESS (0)
-#define FAILURE (-1)
-
-#import "ANTLRPtrBuffer.h"
-#import "ANTLRTree.h"
-
-/*
- * Start of ANTLRPtrBuffer
- */
-@implementation ANTLRPtrBuffer
-
-@synthesize BuffSize;
-@synthesize buffer;
-@synthesize ptrBuffer;
-@synthesize count;
-@synthesize ptr;
-
-+(ANTLRPtrBuffer *)newANTLRPtrBuffer
-{
-    return [[ANTLRPtrBuffer alloc] init];
-}
-
-+(ANTLRPtrBuffer *)newANTLRPtrBufferWithLen:(NSInteger)cnt
-{
-    return [[ANTLRPtrBuffer alloc] initWithLen:cnt];
-}
-
--(id)init
-{
-    NSUInteger idx;
-
-    self = [super init];
-    if ( self != nil ) {
-        BuffSize  = BUFFSIZE;
-        ptr = 0;
-        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
-        ptrBuffer = (id *) [buffer mutableBytes];
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            ptrBuffer[idx] = nil;
-        }
-        count = 0;
-    }
-    return( self );
-}
-
--(id)initWithLen:(NSUInteger)cnt
-{
-    NSUInteger idx;
-
-    self = [super init];
-    if ( self != nil ) {
-        BuffSize  = cnt;
-        ptr = 0;
-        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
-        ptrBuffer = (id *)[buffer mutableBytes];
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            ptrBuffer[idx] = nil;
-        }
-        count = 0;
-    }
-    return( self );
-}
-
--(void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRPtrBuffer" );
-#endif
-    ANTLRLinkBase *tmp, *rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            tmp = ptrBuffer[idx];
-            while ( tmp ) {
-                rtmp = tmp;
-                if ([tmp isKindOfClass:[ANTLRLinkBase class]])
-                    tmp = (id)tmp.fNext;
-                else
-                    tmp = nil;
-                [rtmp release];
-            }
-        }
-    }
-    [buffer release];
-    [super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRPtrBuffer *copy;
-
-    copy = [[[self class] allocWithZone:aZone] init];
-    if ( buffer )
-        copy.buffer = [buffer copyWithZone:aZone];
-    copy.ptrBuffer = ptrBuffer;
-    copy.ptr = ptr;
-    return copy;
-}
-
-- (void)clear
-{
-    ANTLRLinkBase *tmp, *rtmp;
-    NSInteger idx;
-
-    for( idx = 0; idx < BuffSize; idx++ ) {
-        tmp = ptrBuffer[idx];
-        while ( tmp ) {
-            rtmp = tmp;
-            if ([tmp isKindOfClass:[ANTLRLinkBase class]])
-                tmp = (id)tmp.fNext;
-            else
-                tmp = nil;
-            [rtmp dealloc];
-        }
-        ptrBuffer[idx] = nil;
-    }
-    count = 0;
-}
-
-- (NSMutableData *)getBuffer
-{
-    return( buffer );
-}
-
-- (void)setBuffer:(NSMutableData *)np
-{
-    buffer = np;
-}
-
-- (NSUInteger)getCount
-{
-    return( count );
-}
-
-- (void)setCount:(NSUInteger)aCount
-{
-    count = aCount;
-}
-
-- (id *)getPtrBuffer
-{
-    return( ptrBuffer );
-}
-
-- (void)setPtrBuffer:(id *)np
-{
-    ptrBuffer = np;
-}
-
-- (NSUInteger)getPtr
-{
-    return( ptr );
-}
-
-- (void)setPtr:(NSUInteger)aPtr
-{
-    ptr = aPtr;
-}
-
-- (void) addObject:(id) v
-{
-    [self ensureCapacity:ptr];
-    if ( v ) [v retain];
-    ptrBuffer[ptr++] = v;
-    count++;
-}
-
-- (void) push:(id) v
-{
-    if ( ptr >= BuffSize - 1 ) {
-        [self ensureCapacity:ptr];
-    }
-    if ( v ) [v retain];
-    ptrBuffer[ptr++] = v;
-    count++;
-}
-
-- (id) pop
-{
-    id v = nil;
-    if ( ptr > 0 ) {
-        v = ptrBuffer[--ptr];
-        ptrBuffer[ptr] = nil;
-    }
-    count--;
-    if ( v ) [v release];
-    return v;
-}
-
-- (id) peek
-{
-    id v = nil;
-    if ( ptr > 0 ) {
-        v = ptrBuffer[ptr-1];
-    }
-    return v;
-}
-
-- (NSUInteger)count
-{
-#ifdef DONTUSENOMO
-    int cnt = 0;
-
-    for (NSInteger i = 0; i < BuffSize; i++ ) {
-        if ( ptrBuffer[i] != nil ) {
-            cnt++;
-        }
-    }
-    if ( cnt != count ) count = cnt;
-#endif
-    return count;
-}
-
-- (NSUInteger)length
-{
-    return BuffSize;
-}
-
-- (NSUInteger)size
-{
-    NSUInteger aSize = 0;
-    for (int i = 0; i < BuffSize; i++ ) {
-        if (ptrBuffer[i] != nil) {
-            aSize += sizeof(id);
-        }
-    }
-    return aSize;
-}
-
-- (void) insertObject:(id)aRule atIndex:(NSUInteger)idx
-{
-    if ( idx >= BuffSize ) {
-        [self ensureCapacity:idx];
-    }
-    if ( aRule != ptrBuffer[idx] ) {
-        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
-        if ( aRule ) [aRule retain];
-    }
-    ptrBuffer[idx] = aRule;
-    count++;
-}
-
-- (id)objectAtIndex:(NSUInteger)idx
-{
-    if ( idx < BuffSize ) {
-        return ptrBuffer[idx];
-    }
-    return nil;
-}
-
-- (void)addObjectsFromArray:(ANTLRPtrBuffer *)anArray
-{
-    NSInteger cnt, i;
-    cnt = [anArray count];
-    for( i = 0; i < cnt; i++) {
-        id tmp = [anArray objectAtIndex:i];
-        if ( tmp ) [tmp retain];
-        [self insertObject:tmp atIndex:i];
-    }
-    count += cnt;
-    return;
-}
-
-- (void)removeAllObjects
-{
-    int i;
-    for ( i = 0; i < BuffSize; i++ ) {
-        if ( ptrBuffer[i] ) [ptrBuffer[i] release];
-        ptrBuffer[i] = nil;
-    }
-    count = 0;
-    ptr = 0;
-}
-
-- (void)removeObjectAtIndex:(NSInteger)idx
-{
-    int i;
-    if ( idx >= 0 && idx < count ) {
-        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
-        for ( i = idx; i < count-1; i++ ) {
-            ptrBuffer[i] = ptrBuffer[i+1];
-        }
-        ptrBuffer[i] = nil;
-        count--;
-    }
-}
-
-- (void) ensureCapacity:(NSUInteger) anIndex
-{
-    if ((anIndex * sizeof(id)) >= [buffer length])
-    {
-        NSInteger newSize = ([buffer length] / sizeof(id)) * 2;
-        if (anIndex > newSize) {
-            newSize = anIndex + 1;
-        }
-        BuffSize = newSize;
-        [buffer setLength:(BuffSize * sizeof(id))];
-        ptrBuffer = [buffer mutableBytes];
-    }
-}
-
-- (NSString *) description
-{
-    NSMutableString *str;
-    NSInteger idx, cnt;
-    cnt = [self count];
-    str = [NSMutableString stringWithCapacity:30];
-    [str appendString:@"["];
-    for (idx = 0; idx < cnt; idx++ ) {
-        [str appendString:[[self objectAtIndex:idx] description]];
-    }
-    [str appendString:@"]"];
-    return str;
-}
-
-- (NSString *) toString
-{
-    return [self description];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRPtrStack.h b/runtime/ObjC/Framework/ANTLRPtrStack.h
deleted file mode 100644
index 7aa65a9..0000000
--- a/runtime/ObjC/Framework/ANTLRPtrStack.h
+++ /dev/null
@@ -1,51 +0,0 @@
-//
-//  ANTLRPtrStack.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-//  Copyright 2010 Alan's MachineWorks. All rights reserved.
-//ptrBuffer
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseStack.h"
-#import "ANTLRRuleMemo.h"
-
-//#define GLOBAL_SCOPE       0
-//#define LOCAL_SCOPE        1
-#define HASHSIZE         101
-#define HBUFSIZE      0x2000
-
-@interface ANTLRPtrStack : ANTLRBaseStack {
-	//ANTLRPtrStack *fNext;
-    // TStringPool *fPool;
-}
-
-//@property (copy) ANTLRPtrStack *fNext;
-//@property (copy) TStringPool *fPool;
-
-// Contruction/Destruction
-+ (ANTLRPtrStack *)newANTLRPtrStack;
-+ (ANTLRPtrStack *)newANTLRPtrStack:(NSInteger)cnt;
-- (id)init;
-- (id)initWithLen:(NSInteger)aLen;
-- (void)dealloc;
-
-// Instance Methods
-- (id) copyWithZone:(NSZone *)aZone;
-/* clear -- reinitialize the maplist array */
-
-#ifdef DONTUSENOMO
-/* form hash value for string s */
-- (NSInteger)hash:(NSString *)s;
-/*   look for s in ptrBuffer  */
-- (id)lookup:(NSString *)s;
-/* look for s in ptrBuffer  */
-- (id)install:(id)sym;
-#endif
-
-#ifdef DONTUSENOMO
-- (id)getTType:(NSString *)name;
-- (id)getName:(NSInteger)ttype;
-#endif
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRPtrStack.m b/runtime/ObjC/Framework/ANTLRPtrStack.m
deleted file mode 100644
index 5b180f2..0000000
--- a/runtime/ObjC/Framework/ANTLRPtrStack.m
+++ /dev/null
@@ -1,191 +0,0 @@
-//
-//  ANTLRPtrStack.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-//  Copyright 2010 Alan's MachineWorks. All rights reserved.
-//
-#define SUCCESS (0)
-#define FAILURE (-1)
-
-#import "ANTLRPtrStack.h"
-#import "ANTLRTree.h"
-
-/*
- * Start of ANTLRPtrStack
- */
-@implementation ANTLRPtrStack
-
-+(ANTLRPtrStack *)newANTLRPtrStack
-{
-    return [[ANTLRPtrStack alloc] init];
-}
-
-+(ANTLRPtrStack *)newANTLRPtrStack:(NSInteger)cnt
-{
-    return [[ANTLRPtrStack alloc] initWithLen:cnt];
-}
-
--(id)init
-{
-	self = [super initWithLen:HASHSIZE];
-	if ( self != nil ) {
-	}
-    return( self );
-}
-
--(id)initWithLen:(NSInteger)cnt
-{
-	self = [super initWithLen:cnt];
-	if ( self != nil ) {
-	}
-    return( self );
-}
-
--(void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRPtrStack" );
-#endif
-	[super dealloc];
-}
-
--(void)deleteANTLRPtrStack:(ANTLRPtrStack *)np
-{
-    ANTLRLinkBase *tmp, *rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < BuffSize; idx++ ) {
-            tmp = ptrBuffer[idx];
-            while ( tmp ) {
-                rtmp = tmp;
-                tmp = [tmp getfNext];
-                [rtmp release];
-            }
-        }
-    }
-}
-
-#ifdef DONTUSENOMO
-#ifdef USERDOC
-/*
- *  HASH        hash entry to get index to table
- *  NSInteger hash( ANTLRPtrStack *self, char *s );
- *
- *     Inputs:  NSString *s         string to find
- *
- *     Returns: NSInteger                 hashed value
- *
- *  Last Revision 9/03/90
- */
-#endif
--(NSInteger)hash:(NSString *)s       /*    form hash value for string s */
-{
-	NSInteger hashval;
-	const char *tmp;
-
-	tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
-	for( hashval = 0; *tmp != '\0'; )
-        hashval += *tmp++;
-	LastHash = hashval % HashSize;
-	return( LastHash );
-}
-
-#ifdef USERDOC
-/*
- *  LOOKUP  search hashed list for entry
- *  id lookup:(NSString *)s;
- *
- *     Inputs:  NSString  *s       string to find
- *
- *     Returns: ANTLRRuleMemo  *        pointer to entry
- *
- *  Last Revision 9/03/90
- */
-#endif
--(id)lookup:(NSString *)s
-{
-    ANTLRLinkBase *np;
-
-    for( np = ptrBuffer[[self hash:s]]; np != nil; np = [np getfNext] ) {
-        if ( [s isEqualToString:[np getName]] ) {
-            return( np );        /*   found it       */
-        }
-    }
-    return( nil );              /*   not found      */
-}
-
-#ifdef USERDOC
-/*
- *  INSTALL search hashed list for entry
- *  NSInteger install( ANTLRPtrStack *self, id sym );
- *
- *     Inputs:  ANTLRRuleMemo    *sym   -- symbol ptr to install
- *              NSInteger         scope -- level to find
- *
- *     Returns: Boolean     TRUE   if installed
- *                          FALSE  if already in table
- *
- *  Last Revision 9/03/90
- */
-#endif
--(id)install:(id)sym
-{
-    ANTLRLinkBase *np;
-
-    np = [self lookup:[sym getName]];
-    if ( np == nil ) {
-        [sym setFNext:ptrBuffer[ LastHash ]];
-        ptrBuffer[ LastHash ] = [sym retain];
-        return( ptrBuffer[ LastHash ] );
-    }
-    return( nil );            /*   not found      */
-}
-#endif
-
--(id)getptrBufferEntry:(NSInteger)idx
-{
-	return( ptrBuffer[idx] );
-}
-
--(id *)getptrBuffer
-{
-	return( ptrBuffer );
-}
-
--(void)setptrBuffer:(id *)np
-{
-    ptrBuffer = np;
-}
-
-#ifdef DONTUSENOMO
-/*
- * works only for maplist indexed not by name but by TokenNumber
- */
-- (id)getName:(NSInteger)ttype
-{
-    id np;
-    NSInteger aTType;
-
-    aTType = ttype % HashSize;
-    for( np = ptrBuffer[ttype]; np != nil; np = [np getfNext] ) {
-        if ( np.index == ttype ) {
-            return( np );        /*   found it       */
-        }
-    }
-    return( nil );              /*   not found      */
-}
-
-- (id)getTType:(NSString *)name
-{
-    return [self lookup:name];
-}
-#endif
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    return [super copyWithZone:aZone];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRecognitionException.h b/runtime/ObjC/Framework/ANTLRRecognitionException.h
deleted file mode 100644
index 9bd799d..0000000
--- a/runtime/ObjC/Framework/ANTLRRecognitionException.h
+++ /dev/null
@@ -1,74 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRuntimeException.h"
-#import "ANTLRToken.h"
-#import "ANTLRIntStream.h"
-#import "ANTLRBaseTree.h"
-
-@interface ANTLRRecognitionException : ANTLRRuntimeException {
-	id<ANTLRIntStream> input;
-	NSInteger index;
-	id<ANTLRToken> token;
-	id<ANTLRBaseTree> node;
-	unichar c;
-	NSUInteger line;
-	NSUInteger charPositionInLine;
-}
-
-@property (retain, getter=getStream, setter=setStream:) id<ANTLRIntStream> input;
-@property (assign) NSInteger index;
-@property (retain, getter=getToken, setter=setToken:) id<ANTLRToken>token;
-@property (retain, getter=getNode, setter=setNode:) id<ANTLRBaseTree>node;
-@property (assign) unichar c;
-@property (assign) NSUInteger line;
-@property (assign) NSUInteger charPositionInLine;
-
-+ (id) newException;
-+ (id) newException:(id<ANTLRIntStream>) anInputStream;
-- (id) init;
-- (id) initWithStream:(id<ANTLRIntStream>)anInputStream;
-- (id) initWithStream:(id<ANTLRIntStream>)anInputStream reason:(NSString *)aReason;
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-- (NSInteger) unexpectedType;
-- (id<ANTLRToken>)getUnexpectedToken;
-
-- (id<ANTLRIntStream>) getStream;
-- (void) setStream: (id<ANTLRIntStream>) aStream;
-
-- (id<ANTLRToken>) getToken;
-- (void) setToken: (id<ANTLRToken>) aToken;
-
-- (id<ANTLRBaseTree>) getNode;
-- (void) setNode: (id<ANTLRBaseTree>) aNode;
-
-- (NSString *)getMessage;
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRecognitionException.m b/runtime/ObjC/Framework/ANTLRRecognitionException.m
deleted file mode 100644
index 0d0e11f..0000000
--- a/runtime/ObjC/Framework/ANTLRRecognitionException.m
+++ /dev/null
@@ -1,215 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRecognitionException.h"
-#import "ANTLRTokenStream.h"
-#import "ANTLRTreeNodeStream.h"
-
-@implementation ANTLRRecognitionException
-
-@synthesize input;
-@synthesize token;
-@synthesize node;
-@synthesize line;
-@synthesize charPositionInLine;
-
-+ (id) newException
-{
-	return [[ANTLRRecognitionException alloc] init];
-}
-
-+ (id) newException:(id<ANTLRIntStream>) anInputStream
-{
-	return [[ANTLRRecognitionException alloc] initWithStream:anInputStream];
-}
-
-+ (id) newException:(id<ANTLRIntStream>) anInputStream reason:(NSString *)aReason
-{
-	return [[ANTLRRecognitionException alloc] initWithStream:anInputStream reason:aReason];
-}
-
-- (id) init
-{
-	self = [super initWithName:@"Recognition Exception" reason:@"Recognition Exception" userInfo:nil];
-	if ( self != nil ) {
-	}
-	return self;
-}
-
-- (id) initWithStream:(id<ANTLRIntStream>)anInputStream reason:(NSString *)aReason
-{
-	self = [super initWithName:NSStringFromClass([self class]) reason:aReason userInfo:nil];
-	if ( self != nil ) {
-		[self setStream:anInputStream];
-		index = input.index;
-
-		Class inputClass = [input class];
-		if ([inputClass conformsToProtocol:@protocol(ANTLRTokenStream)]) {
-			[self setToken:[(id<ANTLRTokenStream>)input LT:1]];
-			line = token.line;
-			charPositionInLine = token.charPositionInLine;
-		} else if ([inputClass conformsToProtocol:@protocol(ANTLRCharStream)]) {
-			c = (unichar)[input LA:1];
-			line = ((id<ANTLRCharStream>)input).line;
-			charPositionInLine = ((id<ANTLRCharStream>)input).charPositionInLine;
-		} else if ([inputClass conformsToProtocol:@protocol(ANTLRTreeNodeStream)]) {
-			[self setNode:[(id<ANTLRTreeNodeStream>)input LT:1]];
-			line = [node line];
-			charPositionInLine = [node charPositionInLine];
-		} else {
-			c = (unichar)[input LA:1];
-		}
-	}
-	return self;
-}
-
-- (id) initWithStream:(id<ANTLRIntStream>)anInputStream
-{
-	self = [super initWithName:NSStringFromClass([self class]) reason:@"Runtime Exception" userInfo:nil];
-	if ( self != nil ) {
-	}
-	return self;
-}
-
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-	self = [super initWithName:aName reason:aReason userInfo:aUserInfo];
-	if ( self != nil ) {
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRRecognitionException" );
-#endif
-	if ( input ) [input release];
-	if ( token ) [token release];
-	if ( node ) [node release];
-	[super dealloc];
-}
-
-- (NSInteger) unexpectedType
-{
-	if (token) {
-		return token.type;
-    } else if (node) {
-        return [node type];
-	} else {
-		return c;
-	}
-}
-
-- (id<ANTLRToken>)getUnexpectedToken
-{
-    return token;
-}
-
-- (NSString *) description
-{
-	//NSMutableString *desc = [[NSMutableString alloc] initWithString:NSStringFromClass([self class])];
-	NSMutableString *desc = [NSMutableString stringWithString:[self className]];
-	if (token) {
-		[desc appendFormat:@" token:%@", token];
-	} else if (node) {
-		[desc appendFormat:@" node:%@", node];
-	} else {
-		[desc appendFormat:@" char:%c", c];
-	}
-	[desc appendFormat:@" line:%d position:%d", line, charPositionInLine];
-	return desc;
-}
-
-//----------------------------------------------------------
-//  input
-//----------------------------------------------------------
-- (id<ANTLRIntStream>) getStream
-{
-    return input;
-}
-
-- (void) setStream: (id<ANTLRIntStream>) aStream
-{
-    if ( input != aStream ) {
-        if ( input ) [input release];
-        if ( aStream ) [aStream retain];
-        input = aStream;
-    }
-}
-
-//----------------------------------------------------------
-//  token
-//----------------------------------------------------------
-- (id<ANTLRToken>) getToken
-{
-    return token;
-}
-
-- (void) setToken: (id<ANTLRToken>) aToken
-{
-    if (token != aToken) {
-        if ( token ) [token release];
-        if ( aToken ) [aToken retain];
-        token = aToken;
-    }
-}
-
-//----------------------------------------------------------
-//  node
-//----------------------------------------------------------
-- (id<ANTLRBaseTree>) getNode
-{
-    return node;
-}
-
-- (void) setNode: (id<ANTLRBaseTree>) aNode
-{
-    if (node != aNode) {
-        if ( node ) [node release];
-        if ( aNode ) [aNode retain];
-        node = aNode;
-    }
-}
-
-- (NSString *)getMessage
-{
-    return @"Fix getMessage in ANTLRRecognitionException";
-}
-
-- (NSUInteger)charPositionInLine
-{
-    return charPositionInLine;
-}
-
-- (void)setCharPositionInLine:(NSUInteger)aPos
-{
-    charPositionInLine = aPos;
-}
-
-@synthesize index;
-@synthesize c;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRecognizerSharedState.h b/runtime/ObjC/Framework/ANTLRRecognizerSharedState.h
deleted file mode 100755
index 0878dba..0000000
--- a/runtime/ObjC/Framework/ANTLRRecognizerSharedState.h
+++ /dev/null
@@ -1,117 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRToken.h"
-#import "ANTLRBitSet.h"
-#import "ANTLRRuleStack.h"
-#import "AMutableArray.h"
-
-@interface ANTLRRecognizerSharedState : NSObject {
-	__strong AMutableArray *following;  // a stack of FOLLOW bitsets used for context sensitive prediction and recovery
-    NSInteger _fsp;                     // Follow stack pointer
-	BOOL errorRecovery;                 // are we recovering?
-	NSInteger lastErrorIndex;
-	BOOL failed;                        // indicate that some match failed
-    NSInteger syntaxErrors;
-	NSInteger backtracking;             // the level of backtracking
-	__strong ANTLRRuleStack *ruleMemo;	// store previous results of matching rules so we don't have to do it again. Hook in incremental stuff here, too.
-
-	__strong id<ANTLRToken> token;
-	NSInteger  tokenStartCharIndex;
-	NSUInteger tokenStartLine;
-	NSUInteger tokenStartCharPositionInLine;
-	NSUInteger channel;
-	NSUInteger type;
-	NSString   *text;
-}
-
-@property (retain, getter=getFollowing, setter=setFollowing:) AMutableArray *following;
-@property (assign) NSInteger _fsp;
-@property (assign) BOOL errorRecovery;
-@property (assign) NSInteger lastErrorIndex;
-@property (assign, getter=getFailed, setter=setFailed:) BOOL failed;
-@property (assign) NSInteger syntaxErrors;
-@property (assign, getter=getBacktracking, setter=setBacktracking:) NSInteger backtracking;
-@property (retain, getter=getRuleMemo, setter=setRuleMemo:) ANTLRRuleStack *ruleMemo;
-@property (copy, getter=getToken, setter=setToken:) id<ANTLRToken> token;
-@property (getter=type,setter=setType:) NSUInteger type;
-@property (getter=channel,setter=setChannel:) NSUInteger channel;
-@property (getter=getTokenStartLine,setter=setTokenStartLine:) NSUInteger tokenStartLine;
-@property (getter=charPositionInLine,setter=setCharPositionInLine:) NSUInteger tokenStartCharPositionInLine;
-@property (getter=getTokenStartCharIndex,setter=setTokenStartCharIndex:) NSInteger tokenStartCharIndex;
-@property (retain, getter=text, setter=setText:) NSString *text;
-
-+ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState;
-+ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedStateWithRuleLen:(NSInteger)aLen;
-+ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState:(ANTLRRecognizerSharedState *)aState;
-
-- (id) init;
-- (id) initWithRuleLen:(NSInteger)aLen;
-- (id) initWithState:(ANTLRRecognizerSharedState *)state;
-
-- (id<ANTLRToken>) getToken;
-- (void) setToken:(id<ANTLRToken>) theToken;
-
-- (NSUInteger)type;
-- (void) setType:(NSUInteger) theTokenType;
-
-- (NSUInteger)channel;
-- (void) setChannel:(NSUInteger) theChannel;
-
-- (NSUInteger) getTokenStartLine;
-- (void) setTokenStartLine:(NSUInteger) theTokenStartLine;
-
-- (NSUInteger) charPositionInLine;
-- (void) setCharPositionInLine:(NSUInteger) theCharPosition;
-
-- (NSInteger) getTokenStartCharIndex;
-- (void) setTokenStartCharIndex:(NSInteger) theTokenStartCharIndex;
-
-- (NSString *)text;
-- (void) setText:(NSString *) theText;
-
-
-- (AMutableArray *) getFollowing;
-- (void)setFollowing:(AMutableArray *)aFollow;
-- (ANTLRRuleStack *) getRuleMemo;
-- (void)setRuleMemo:(ANTLRRuleStack *)aRuleMemo;
-- (BOOL) isErrorRecovery;
-- (void) setIsErrorRecovery: (BOOL) flag;
-
-- (BOOL) getFailed;
-- (void) setFailed: (BOOL) flag;
-
-- (NSInteger)  getBacktracking;
-- (void) setBacktracking:(NSInteger) value;
-- (void) increaseBacktracking;
-- (void) decreaseBacktracking;
-- (BOOL) isBacktracking;
-
-- (NSInteger) lastErrorIndex;
-- (void) setLastErrorIndex:(NSInteger) value;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRecognizerSharedState.m b/runtime/ObjC/Framework/ANTLRRecognizerSharedState.m
deleted file mode 100755
index 79dda2d..0000000
--- a/runtime/ObjC/Framework/ANTLRRecognizerSharedState.m
+++ /dev/null
@@ -1,331 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRecognizerSharedState.h"
-#import "ANTLRCharStream.h"
-#import "ANTLRCommonToken.h"
-#import "ANTLRMismatchedTokenException.h"
-#import "ANTLRMismatchedRangeException.h"
-
-@implementation ANTLRRecognizerSharedState
-
-@synthesize following;
-@synthesize _fsp;
-@synthesize errorRecovery;
-@synthesize lastErrorIndex;
-@synthesize failed;
-@synthesize syntaxErrors;
-@synthesize backtracking;
-@synthesize ruleMemo;
-@synthesize token;
-@synthesize type;
-@synthesize channel;
-@synthesize tokenStartLine;
-@synthesize tokenStartCharPositionInLine;
-@synthesize tokenStartCharIndex;
-@synthesize text;
-
-+ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState
-{
-    return [[[ANTLRRecognizerSharedState alloc] init] retain];
-}
-
-+ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedStateWithRuleLen:(NSInteger)aLen
-{
-    return [[[ANTLRRecognizerSharedState alloc] initWithRuleLen:aLen] retain];
-}
-
-+ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState:(ANTLRRecognizerSharedState *)aState
-{
-    return [[[ANTLRRecognizerSharedState alloc] initWithState:aState] retain];
-}
-
-- (id) init
-{
-    ANTLRHashRule *aHashRule;
-	if ((self = [super init]) != nil ) {
-        following = [[AMutableArray arrayWithCapacity:10] retain];
-        _fsp = -1;
-        errorRecovery = NO;			// are we recovering?
-        lastErrorIndex = -1;
-        failed = NO;				// indicate that some match failed
-        syntaxErrors = 0;
-        backtracking = 0;			// the level of backtracking
-        tokenStartCharIndex = -1;
-        tokenStartLine = 0;
-        int cnt = 200;
-		ruleMemo = [[ANTLRRuleStack newANTLRRuleStack:cnt] retain];
-        for (int i = 0; i < cnt; i++ ) {
-            aHashRule = [[ANTLRHashRule newANTLRHashRuleWithLen:17] retain];
-            [ruleMemo addObject:aHashRule];
-        }
-#ifdef DONTUSEYET
-        token = state.token;
-        tokenStartCharIndex = state.tokenStartCharIndex;
-        tokenStartCharPositionInLine = state.tokenStartCharPositionInLine;
-        channel = state.channel;
-        type = state.type;
-        text = state.text;
-#endif
-	}
-	return self;
-}
-
-- (id) initWithRuleLen:(NSInteger)aLen
-{
-    ANTLRHashRule *aHashRule;
-	if ((self = [super init]) != nil ) {
-        following = [[AMutableArray arrayWithCapacity:10] retain];
-        _fsp = -1;
-        errorRecovery = NO;			// are we recovering?
-        lastErrorIndex = -1;
-        failed = NO;				// indicate that some match failed
-        syntaxErrors = 0;
-        backtracking = 0;			// the level of backtracking
-        tokenStartCharIndex = -1;
-        tokenStartLine = 0;
-		ruleMemo = [[ANTLRRuleStack newANTLRRuleStack:aLen] retain];
-        for (int i = 0; i < aLen; i++ ) {
-            aHashRule = [[ANTLRHashRule newANTLRHashRuleWithLen:17] retain];
-            [ruleMemo addObject:aHashRule];
-        }
-#ifdef DONTUSEYET
-        token = state.token;
-        tokenStartCharIndex = state.tokenStartCharIndex;
-        tokenStartCharPositionInLine = state.tokenStartCharPositionInLine;
-        channel = state.channel;
-        type = state.type;
-        text = state.text;
-#endif
-	}
-	return self;
-}
-
-- (id) initWithState:(ANTLRRecognizerSharedState *)aState
-{
-    ANTLRHashRule *aHashRule;
-    if ( [following count] < [aState.following count] ) {
-        //        following = new BitSet[state.following.size];
-    }
-    [following setArray:aState.following];
-    _fsp = aState._fsp;
-    errorRecovery = aState.errorRecovery;
-    lastErrorIndex = aState.lastErrorIndex;
-    failed = aState.failed;
-    syntaxErrors = aState.syntaxErrors;
-    backtracking = aState.backtracking;
-    if ( aState.ruleMemo == nil ) {
-        int cnt = 200;
-        ruleMemo = [[ANTLRRuleStack newANTLRRuleStack:cnt] retain];
-        for (int i = 0; i < cnt; i++ ) {
-            aHashRule = [[ANTLRHashRule newANTLRHashRuleWithLen:17] retain];
-            [ruleMemo addObject:aHashRule];
-        }
-    }
-    else {
-        ruleMemo = aState.ruleMemo;
-        if ( [ruleMemo count] == 0 ) {
-            int cnt = [ruleMemo length];
-            for (int i = 0; i < cnt; i++ ) {
-                [ruleMemo addObject:[[ANTLRHashRule newANTLRHashRuleWithLen:17] retain]];
-            }
-        }
-        else {
-            [ruleMemo addObjectsFromArray:aState.ruleMemo];
-        }
-    }
-    token = aState.token;
-    tokenStartCharIndex = aState.tokenStartCharIndex;
-    tokenStartCharPositionInLine = aState.tokenStartCharPositionInLine;
-    tokenStartLine = aState.tokenStartLine;
-    channel = aState.channel;
-    type = aState.type;
-    text = aState.text;
-    return( self );
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRRecognizerSharedState" );
-#endif
-    if ( token ) [token release];
-	if ( following ) [following release];
-	if ( ruleMemo ) [ruleMemo release];
-	[super dealloc];
-}
-
-// token stuff
-#pragma mark Tokens
-
-- (id<ANTLRToken>)getToken
-{
-    return token;
-}
-
-- (void) setToken: (id<ANTLRToken>) aToken
-{
-    if (token != aToken) {
-        [aToken retain];
-        if ( token ) [token release];
-        token = aToken;
-    }
-}
-
-- (NSUInteger)channel
-{
-    return channel;
-}
-
-- (void) setChannel:(NSUInteger) theChannel
-{
-    channel = theChannel;
-}
-
-- (NSUInteger) getTokenStartLine
-{
-    return tokenStartLine;
-}
-
-- (void) setTokenStartLine:(NSUInteger) theTokenStartLine
-{
-    tokenStartLine = theTokenStartLine;
-}
-
-- (NSUInteger) charPositionInLine
-{
-    return tokenStartCharPositionInLine;
-}
-
-- (void) setCharPositionInLine:(NSUInteger) theCharPosition
-{
-    tokenStartCharPositionInLine = theCharPosition;
-}
-
-- (NSInteger) getTokenStartCharIndex;
-{
-    return tokenStartCharIndex;
-}
-
-- (void) setTokenStartCharIndex:(NSInteger) theTokenStartCharIndex
-{
-    tokenStartCharIndex = theTokenStartCharIndex;
-}
-
-// error handling
-- (void) reportError:(ANTLRRecognitionException *)e
-{
-	NSLog(@"%@", e.name);
-}
-
-- (AMutableArray *) getFollowing
-{
-	return following;
-}
-
-- (void)setFollowing:(AMutableArray *)aFollow
-{
-    if ( following != aFollow ) {
-        if ( following ) [following release];
-        [aFollow retain];
-    }
-    following = aFollow;
-}
-
-- (ANTLRRuleStack *) getRuleMemo
-{
-	return ruleMemo;
-}
-
-- (void)setRuleMemo:(ANTLRRuleStack *)aRuleMemo
-{
-    if ( ruleMemo != aRuleMemo ) {
-        if ( ruleMemo ) [ruleMemo release];
-        [aRuleMemo retain];
-    }
-    ruleMemo = aRuleMemo;
-}
-
-- (BOOL) isErrorRecovery
-{
-	return errorRecovery;
-}
-
-- (void) setIsErrorRecovery: (BOOL) flag
-{
-	errorRecovery = flag;
-}
-
-
-- (BOOL) getFailed
-{
-	return failed;
-}
-
-- (void) setFailed:(BOOL)flag
-{
-	failed = flag;
-}
-
-
-- (NSInteger) backtracking
-{
-	return backtracking;
-}
-
-- (void) setBacktracking:(NSInteger) value
-{
-	backtracking = value;
-}
-
-- (void) increaseBacktracking
-{
-	backtracking++;
-}
-
-- (void) decreaseBacktracking
-{
-	backtracking--;
-}
-
-- (BOOL) isBacktracking
-{
-	return backtracking > 0;
-}
-
-
-- (NSInteger) lastErrorIndex
-{
-    return lastErrorIndex;
-}
-
-- (void) setLastErrorIndex:(NSInteger) value
-{
-	lastErrorIndex = value;
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.h b/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.h
deleted file mode 100644
index 46e0190..0000000
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.h
+++ /dev/null
@@ -1,82 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTreeAdaptor.h"
-
-// TODO: this should be separated into stream and enumerator classes
-@interface ANTLRRewriteRuleElementStream : NSObject {
-    NSInteger cursor;
-    BOOL dirty;        ///< indicates whether the stream should return copies of its elements, set to true after a call to -reset
-    BOOL isSingleElement;
-    id singleElement;
-    __strong AMutableArray *elements;
-
-    __strong NSString *elementDescription;
-    __strong id<ANTLRTreeAdaptor> treeAdaptor;
-}
-
-@property (assign) NSInteger cursor;
-@property (assign) BOOL dirty;
-@property (assign) BOOL isSingleElement;
-@property (assign) id singleElement;
-@property (assign) AMutableArray *elements;
-@property (assign) NSString *elementDescription;
-@property (retain) id<ANTLRTreeAdaptor> treeAdaptor;
-
-+ (ANTLRRewriteRuleElementStream*) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                        description:(NSString *)anElementDescription;
-+ (ANTLRRewriteRuleElementStream*) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                        description:(NSString *)anElementDescription
-                                                            element:(id)anElement;
-+ (ANTLRRewriteRuleElementStream*) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                        description:(NSString *)anElementDescription
-                                                           elements:(NSArray *)theElements;
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
-
-- (void)reset;
-
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor;
-
-- (void) addElement:(id)anElement;
-- (NSInteger) size;
-
-- (BOOL) hasNext;
-- (id<ANTLRBaseTree>) nextTree;
-- (id<ANTLRBaseTree>) _next;       // internal: TODO: redesign if necessary. maybe delegate
-
-- (id) copyElement:(id)element;
-- (id) toTree:(id)element;
-
-- (NSString *) getDescription;
-- (void) setDescription:(NSString *)description;
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.m b/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.m
deleted file mode 100644
index 138163c..0000000
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleElementStream.m
+++ /dev/null
@@ -1,258 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRewriteRuleElementStream.h"
-
-@implementation ANTLRRewriteRuleElementStream
-
-@synthesize cursor;
-@synthesize dirty;
-@synthesize isSingleElement;
-@synthesize singleElement;
-@synthesize elements;
-@synthesize elementDescription;
-@synthesize treeAdaptor;
-
-+ (ANTLRRewriteRuleElementStream *) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                         description:(NSString *)anElementDescription
-{
-    return [[ANTLRRewriteRuleElementStream alloc] initWithTreeAdaptor:aTreeAdaptor
-                                                          description:anElementDescription];
-}
-
-+ (ANTLRRewriteRuleElementStream *) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                         description:(NSString *)anElementDescription
-                                                             element:(id)anElement
-{
-    return [[ANTLRRewriteRuleElementStream alloc] initWithTreeAdaptor:aTreeAdaptor
-                                                          description:anElementDescription
-                                                              element:anElement];
-}
-
-+ (ANTLRRewriteRuleElementStream *) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                         description:(NSString *)anElementDescription
-                                                            elements:(NSArray *)theElements;
-{
-    return [[ANTLRRewriteRuleElementStream alloc] initWithTreeAdaptor:aTreeAdaptor
-                                                          description:anElementDescription
-                                                             elements:theElements];
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription
-{
-    if ((self = [super init]) != nil) {
-        cursor = 0;
-        dirty = NO;
-        [self setDescription:anElementDescription];
-        [self setTreeAdaptor:aTreeAdaptor];
-        dirty = NO;
-        isSingleElement = YES;
-        singleElement = nil;
-        elements = nil;
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement
-{
-    if ((self = [super init]) != nil) {
-        cursor = 0;
-        dirty = NO;
-        [self setDescription:anElementDescription];
-        [self setTreeAdaptor:aTreeAdaptor];
-        dirty = NO;
-        isSingleElement = YES;
-        singleElement = nil;
-        elements = nil;
-        [self addElement:anElement];
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements
-{
-    self = [super init];
-    if (self) {
-        cursor = 0;
-        dirty = NO;
-        [self setDescription:anElementDescription];
-        [self setTreeAdaptor:aTreeAdaptor];
-        dirty = NO;
-        singleElement = nil;
-        isSingleElement = NO;
-        elements = [[AMutableArray arrayWithArray:theElements] retain];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRRewriteRuleElementStream" );
-#endif
-    if ( singleElement && isSingleElement ) [singleElement release];
-    else if ( elements && !isSingleElement ) [elements release];
-    [self setDescription:nil];
-    [self setTreeAdaptor:nil];
-    [super dealloc];
-}
-
-- (void)reset
-{
-    cursor = 0;
-    dirty = YES;
-}
-
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor
-{
-    return treeAdaptor;
-}
-
-- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-{
-    if (treeAdaptor != aTreeAdaptor) {
-        if ( treeAdaptor ) [treeAdaptor release];
-        treeAdaptor = aTreeAdaptor;
-        [treeAdaptor retain];
-    }
-}
-
-- (void) addElement: (id)anElement
-{
-    if (anElement == nil)
-        return;
-    if (elements != nil) {
-        [elements addObject:anElement];
-        return;
-        }
-    if (singleElement == nil) {
-        singleElement = anElement;
-        singleElement = [anElement retain];
-        return;
-    }
-    isSingleElement = NO;
-    elements = [[AMutableArray arrayWithCapacity:5] retain];
-    [elements addObject:singleElement];
-    singleElement = nil;  // balance previous retain in initializer/addElement
-    [elements addObject:anElement];
-}
-
-- (void) setElement: (id)anElement
-{
-    if (anElement == nil)
-        return;
-    if (elements != nil) {
-        [elements addObject:anElement];
-        return;
-        }
-    if (singleElement == nil) {
-        singleElement = anElement;
-        singleElement = [anElement retain];
-        return;
-    }
-    isSingleElement = NO;
-    elements = [[AMutableArray arrayWithCapacity:5] retain];
-    [elements addObject:singleElement];
-    singleElement = nil;  // balance previous retain in initializer/addElement
-    [elements addObject:anElement];
-}
-
-- (id<ANTLRBaseTree>) nextTree
-{
-    NSInteger n = [self size];
-    if ( dirty && (cursor >= 0 && n == 1)) {
-        // if out of elements and size is 1, dup
-        id element = [self _next];
-        return [self copyElement:element];
-    }
-    // test size above then fetch
-    id element = [self _next];
-    return element;
-}
-
-- (id) _next       // internal: TODO: redesign if necessary. maybe delegate
-{
-    NSInteger n = [self size];
-    if (n == 0) {
-        @throw [NSException exceptionWithName:@"RewriteEmptyStreamException" reason:nil userInfo:nil];// TODO: fill in real exception
-    }
-    if ( cursor >= n ) {
-        if ( n == 1 ) {
-            return [self toTree:singleElement]; // will be dup'ed in -next
-        }
-        @throw [NSException exceptionWithName:@"RewriteCardinalityException" reason:nil userInfo:nil];// TODO: fill in real exception
-    }
-    if (singleElement != nil) {
-        cursor++;
-        return [self toTree:singleElement];
-    }
-    id el = [elements objectAtIndex:cursor];
-    cursor++;
-    return [self toTree:el];
-}
-
-- (BOOL) hasNext
-{
-    return (singleElement != nil && cursor < 1) ||
-            (elements != nil && cursor < [elements count]);
-}
-
-- (NSInteger) size
-{
-    NSInteger n = 0;
-    if (singleElement != nil)
-        n = 1;
-    if (elements != nil)
-        return [elements count];
-    return n;
-}
-
-- (id) copyElement:(id)element
-{
-    [self doesNotRecognizeSelector:_cmd];   // subclass responsibility
-    return nil;
-}
-
-- (id<ANTLRBaseTree>) toTree:(id)element
-{
-    return element;
-}
-
-- (NSString *) getDescription
-{
-    return elementDescription;
-}
-
-- (void) setDescription:(NSString *) description
-{
-    if ( description != nil && description != elementDescription ) {
-        if (elementDescription != nil) [elementDescription release];
-        elementDescription = [NSString stringWithString:description];
-        [elementDescription retain];
-    }
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleNodeStream.h b/runtime/ObjC/Framework/ANTLRRewriteRuleNodeStream.h
deleted file mode 100755
index 2789e45..0000000
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleNodeStream.h
+++ /dev/null
@@ -1,46 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRewriteRuleElementStream.h"
-
-@interface ANTLRRewriteRuleNodeStream : ANTLRRewriteRuleElementStream {
-
-}
-
-+ (ANTLRRewriteRuleNodeStream *) newANTLRRewriteRuleNodeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
-+ (ANTLRRewriteRuleNodeStream *) newANTLRRewriteRuleNodeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
-+ (ANTLRRewriteRuleNodeStream *) newANTLRRewriteRuleNode:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
-
-- (id) nextNode;
-- (id) toTree:(id<ANTLRBaseTree>)element;
-- (id) dup:(id)element;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleNodeStream.m b/runtime/ObjC/Framework/ANTLRRewriteRuleNodeStream.m
deleted file mode 100755
index 8dfedd7..0000000
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleNodeStream.m
+++ /dev/null
@@ -1,74 +0,0 @@
-//
-//  ANTLRRewriteRuleNodeStream.m
-//  ANTLR
-//
-//  Created by Kay Röpke on 7/16/07.
-//  Copyright 2007 classDump. All rights reserved.
-//
-
-#import "ANTLRRewriteRuleNodeStream.h"
-#import "ANTLRRuntimeException.h"
-
-@implementation ANTLRRewriteRuleNodeStream
-
-+ (ANTLRRewriteRuleNodeStream*) newANTLRRewriteRuleNodeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
-{
-    return [[ANTLRRewriteRuleNodeStream alloc] initWithTreeAdaptor:aTreeAdaptor description:anElementDescription];
-}
-
-+ (ANTLRRewriteRuleNodeStream*) newANTLRRewriteRuleNodeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
-{
-    return [[ANTLRRewriteRuleNodeStream alloc] initWithTreeAdaptor:aTreeAdaptor description:anElementDescription element:anElement];
-}
-
-+ (ANTLRRewriteRuleNodeStream*) newANTLRRewriteRuleNode:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
-{
-    return [[ANTLRRewriteRuleNodeStream alloc] initWithTreeAdaptor:aTreeAdaptor description:anElementDescription elements:theElements];
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription
-{
-    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription]) != nil) {
-        dirty = NO;
-        isSingleElement = YES;
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement
-{
-    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription element:anElement]) != nil) {
-        dirty = NO;
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements
-{
-    if ((self = [super init]) != nil) {
-        dirty = NO;
-    }
-    return self;
-}
-
-
-- (id) nextNode
-{
-    if (dirty || (cursor >= [self size] && [self size] == 1))
-        return [treeAdaptor dupNode:[self _next]];
-    else
-        return [self _next];
-}
-
-- (id<ANTLRBaseTree>) toTree:(id<ANTLRBaseTree>)element
-{
-    return [treeAdaptor dupNode:element];
-}
-
-- (id) dup:(id)element
-{
-    return [treeAdaptor dupTree:element];
-    @throw [ANTLRRuntimeException newException:@"ANTLRUnsupportedOperationException" reason:@"dup can't be called for a node stream."];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleSubtreeStream.h b/runtime/ObjC/Framework/ANTLRRewriteRuleSubtreeStream.h
deleted file mode 100644
index 1d18b24..0000000
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleSubtreeStream.h
+++ /dev/null
@@ -1,50 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRewriteRuleElementStream.h"
-
-@interface ANTLRRewriteRuleSubtreeStream : ANTLRRewriteRuleElementStream {
-
-}
-
-+ (ANTLRRewriteRuleSubtreeStream *) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                         description:(NSString *)anElementDescription;
-+ (ANTLRRewriteRuleSubtreeStream *) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                         description:(NSString *)anElementDescription
-                                                             element:(id)anElement;
-+ (ANTLRRewriteRuleSubtreeStream *) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                         description:(NSString *)anElementDescription
-                                                            elements:(NSArray *)theElements;
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
-
-- (id) nextNode;
-- (id) dup:(id)element;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleSubtreeStream.m b/runtime/ObjC/Framework/ANTLRRewriteRuleSubtreeStream.m
deleted file mode 100644
index 48910bd..0000000
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleSubtreeStream.m
+++ /dev/null
@@ -1,101 +0,0 @@
-//
-//  ANTLRRewriteRuleSubtreeStream.m
-//  ANTLR
-//
-//  Created by Kay Röpke on 7/16/07.
-// [The "BSD licence"]
-// Copyright (c) 2007 Kay Röpke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRewriteRuleSubtreeStream.h"
-
-
-@implementation ANTLRRewriteRuleSubtreeStream
-
-+ (ANTLRRewriteRuleSubtreeStream*) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                        description:(NSString *)anElementDescription;
-{
-    return [[ANTLRRewriteRuleSubtreeStream alloc] initWithTreeAdaptor:aTreeAdaptor
-                                                          description:anElementDescription];
-}
-
-+ (ANTLRRewriteRuleSubtreeStream*) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                        description:(NSString *)anElementDescription
-                                                            element:(id)anElement;
-{
-    return [[ANTLRRewriteRuleSubtreeStream alloc] initWithTreeAdaptor:aTreeAdaptor
-                                                          description:anElementDescription
-                                                              element:anElement];
-}
-
-+ (ANTLRRewriteRuleSubtreeStream*) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-                                                        description:(NSString *)anElementDescription
-                                                           elements:(NSArray *)theElements;
-{
-    return [[ANTLRRewriteRuleSubtreeStream alloc] initWithTreeAdaptor:aTreeAdaptor
-                                                          description:anElementDescription
-                                                             elements:theElements];
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription
-{
-    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription]) != nil) {
-        dirty = NO;
-        isSingleElement = YES;
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement
-{
-    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription element:anElement]) != nil) {
-        dirty = NO;
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements
-{
-    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription elements:theElements]) != nil) {
-        dirty = NO;
-    }
-    return self;
-}
-
-
-- (id) nextNode
-{
-    if (dirty || (cursor >= [self size] && [self size] == 1))
-        return [treeAdaptor dupNode:[self _next]];
-    else
-        return [self _next];
-}
-
-- (id) dup:(id)element
-{
-    return [treeAdaptor dupTree:element];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.h b/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.h
deleted file mode 100644
index 620a0bd..0000000
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.h
+++ /dev/null
@@ -1,66 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRewriteRuleElementStream.h"
-
-
-@interface ANTLRRewriteRuleTokenStream : ANTLRRewriteRuleElementStream {
-
-}
-
-+ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)anAdaptor
-                          description:(NSString *)elementDescription;
-/** Create a stream with one element */
-+ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
-                          description:(NSString *)elementDescription
-                              element:(id) oneElement;
-/** Create a stream, but feed off an existing list */
-+ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
-                          description:(NSString *)elementDescription
-                             elements:(AMutableArray *)elements;
-
-- (id) init;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-               description:(NSString *)aDescription;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-               description:(NSString *)aDescription
-                   element:(id)element;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-               description:(NSString *)aDescription
-                  elements:(AMutableArray *)elements;
-
-/** Get next token from stream and make a node for it */
-- (id) nextNode;
-
-- (id) nextToken;
-
-/** Don't convert to a tree unless they explicitly call nextTree.
- *  This way we can do hetero tree nodes in rewrite.
- */
-- (id<ANTLRBaseTree>) toTree:(id<ANTLRToken>)element;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.m b/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.m
deleted file mode 100644
index 5aea3f8..0000000
--- a/runtime/ObjC/Framework/ANTLRRewriteRuleTokenStream.m
+++ /dev/null
@@ -1,128 +0,0 @@
-//
-//  ANTLRRewriteRuleTokenStream.m
-//  ANTLR
-//
-//  Created by Kay Röpke on 7/16/07.
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRewriteRuleTokenStream.h"
-#import "ANTLRRuntimeException.h"
-#import "ANTLRHashMap.h"
-#import "ANTLRMapElement.h"
-
-@implementation ANTLRRewriteRuleTokenStream
-
-+ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)anAdaptor
-                          description:(NSString *)elementDescription
-{
-    return [[ANTLRRewriteRuleTokenStream alloc] initWithTreeAdaptor:anAdaptor
-                                                        description:elementDescription];
-}
-
-/** Create a stream with one element */
-+ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
-                          description:(NSString *)elementDescription
-                              element:(id) oneElement
-{
-    return [[ANTLRRewriteRuleTokenStream alloc] initWithTreeAdaptor:adaptor
-                                                        description:elementDescription
-                                                            element:oneElement];
-}
-
-/** Create a stream, but feed off an existing list */
-+ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
-                          description:(NSString *)elementDescription
-                             elements:(AMutableArray *)elements
-{
-    return [[ANTLRRewriteRuleTokenStream alloc] initWithTreeAdaptor:adaptor
-                                                        description:elementDescription
-                                                           elements:elements];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil ) {
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-               description:(NSString *)aDescription
-{
-    if ((self = [super initWithTreeAdaptor:anAdaptor
-                               description:aDescription]) != nil ) {
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-               description:(NSString *)aDescription
-                   element:(id)anElement
-{
-    if ((self = [super initWithTreeAdaptor:anAdaptor
-                               description:aDescription
-                                   element:anElement]) != nil ) {
-    }
-    return self;
-}
-
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-               description:(NSString *)aDescription
-                  elements:(AMutableArray *)elementList
-{
-    if ((self = [super initWithTreeAdaptor:anAdaptor
-                               description:aDescription
-                                  elements:elementList]) != nil ) {
-    }
-    return self;
-}
-
-- (id<ANTLRBaseTree>) nextNode
-{
-    id<ANTLRToken> t = [self _next];
-    return [treeAdaptor create:t];
-}
-
-- (id) nextToken
-{
-    return [self _next];
-}
-
-/** Don't convert to a tree unless they explicitly call nextTree.
- *  This way we can do hetero tree nodes in rewrite.
- */
-- (id<ANTLRBaseTree>) toTree:(id<ANTLRToken>)element
-{
-    return element;
-}
-
-- (id) copyElement:(id)element
-{
-    @throw [ANTLRRuntimeException newException:@"copy can't be called for a token stream."];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuleMapElement.h b/runtime/ObjC/Framework/ANTLRRuleMapElement.h
deleted file mode 100644
index e040b18..0000000
--- a/runtime/ObjC/Framework/ANTLRRuleMapElement.h
+++ /dev/null
@@ -1,55 +0,0 @@
-//
-//  ANTLRRuleMapElement.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseMapElement.h"
-
-@interface ANTLRRuleMapElement : ANTLRBaseMapElement {
-    NSNumber *ruleNum;
-}
-
-@property (retain, getter=getRuleNum, setter=setRuleNum:) NSNumber *ruleNum;
-
-+ (ANTLRRuleMapElement *) newANTLRRuleMapElement;
-+ (ANTLRRuleMapElement *) newANTLRRuleMapElementWithIndex:(NSNumber *)anIdx;
-+ (ANTLRRuleMapElement *) newANTLRRuleMapElementWithIndex:(NSNumber *)anIdx RuleNum:(NSNumber *)aRuleNum;
-- (id) init;
-- (id) initWithAnIndex:(NSNumber *)anIdx;
-- (id) initWithAnIndex:(NSNumber *)anIdx RuleNum:(NSNumber *)aRuleNum;
-
-- (id) copyWithZone:(NSZone *)aZone;
-
-- (NSNumber *)getRuleNum;
-- (void)setRuleNum:(NSNumber *)aRuleNum;
-
-- (NSInteger)size;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuleMapElement.m b/runtime/ObjC/Framework/ANTLRRuleMapElement.m
deleted file mode 100644
index 0e8c463..0000000
--- a/runtime/ObjC/Framework/ANTLRRuleMapElement.m
+++ /dev/null
@@ -1,111 +0,0 @@
-//
-//  ANTLRRuleMapElement.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRuleMapElement.h"
-
-
-@implementation ANTLRRuleMapElement
-
-@synthesize ruleNum;
-
-+ (ANTLRRuleMapElement *)newANTLRRuleMapElement
-{
-    return [[ANTLRRuleMapElement alloc] init];
-}
-
-+ (ANTLRRuleMapElement *)newANTLRRuleMapElementWithIndex:(NSNumber *)aNumber
-{
-    return [[ANTLRRuleMapElement alloc] initWithAnIndex:(NSNumber *)aNumber];
-}
-
-+ (ANTLRRuleMapElement *)newANTLRRuleMapElementWithIndex:(NSNumber *)aNumber RuleNum:(NSNumber *)aRuleNum
-{
-    return [[ANTLRRuleMapElement alloc] initWithAnIndex:aNumber RuleNum:aRuleNum];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil ) {
-        index = nil;
-        ruleNum = nil;
-    }
-    return (self);
-}
-
-- (id) initWithAnIndex:(NSNumber *)aNumber
-{
-    if ((self = [super initWithAnIndex:aNumber]) != nil ) {
-        ruleNum = nil;
-    }
-    return (self);
-}
-
-- (id) initWithAnIndex:(NSNumber *)aNumber RuleNum:(NSNumber *)aRuleNum
-{
-    if ((self = [super initWithAnIndex:aNumber]) != nil ) {
-        [aRuleNum retain];
-        ruleNum = aRuleNum;
-    }
-    return (self);
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRRuleMapElement *copy;
-
-    copy = [super copyWithZone:aZone];
-    copy.ruleNum = ruleNum;
-    return( copy );
-}
-
-- (id)getRuleNum
-{
-    return ruleNum;
-}
-
-- (void)setRuleNum:(id)aRuleNum
-{
-    if ( aRuleNum != ruleNum ) {
-        if ( ruleNum ) [ruleNum release];
-        [aRuleNum retain];
-    }
-    ruleNum = aRuleNum;
-}
-
-- (NSInteger)size
-{
-    NSInteger aSize = 0;
-    if (ruleNum != nil) aSize++;
-    if (index != nil) aSize++;
-    return( aSize );
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuleMemo.h b/runtime/ObjC/Framework/ANTLRRuleMemo.h
deleted file mode 100644
index ed95af6..0000000
--- a/runtime/ObjC/Framework/ANTLRRuleMemo.h
+++ /dev/null
@@ -1,60 +0,0 @@
-//
-//  ANTLRRuleMemo.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRLinkBase.h"
-
-@interface ANTLRRuleMemo : ANTLRLinkBase {
-    NSNumber *startIndex;
-    NSNumber *stopIndex;
-}
-
-@property (retain, getter=getStartIndex, setter=setStartIndex:) NSNumber *startIndex;
-@property (retain, getter=getStopIndex, setter=setStopIndex:) NSNumber *stopIndex;
-
-+ (ANTLRRuleMemo *)newANTLRRuleMemo;
-+ (ANTLRRuleMemo *)newANTLRRuleMemoWithStartIndex:(NSNumber *)aStartIndex StopIndex:(NSNumber *)aStopIndex;
-
-- (id) init;
-- (id) initWithStartIndex:(NSNumber *)aStartIndex StopIndex:(NSNumber *)aStopIndex;
-
-- (NSInteger)count;
-- (NSInteger)size;
-
-- (ANTLRRuleMemo *)getRuleWithStartIndex:(NSInteger)aStartIndex;
-- (NSNumber *)getStartIndex:(NSInteger)aStartIndex;
-- (NSNumber *)getStopIndex:(NSInteger)aStartIndex;
-- (NSNumber *)getStartIndex;
-- (void)setStartIndex:(NSNumber *)aStartIndex;
-- (NSNumber *)getStopIndex;
-- (void)setStopIndex:(NSNumber *)aStopIndex;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuleMemo.m b/runtime/ObjC/Framework/ANTLRRuleMemo.m
deleted file mode 100644
index 836d355..0000000
--- a/runtime/ObjC/Framework/ANTLRRuleMemo.m
+++ /dev/null
@@ -1,158 +0,0 @@
-//
-//  ANTLRRuleMemo.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/16/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRuleMemo.h"
-
-
-@implementation ANTLRRuleMemo
-
-@synthesize startIndex;
-@synthesize stopIndex;
-
-+ (ANTLRRuleMemo *)newANTLRRuleMemo
-{
-    return [[ANTLRRuleMemo alloc] init];
-}
-
-+ (ANTLRRuleMemo *)newANTLRRuleMemoWithStartIndex:(NSNumber *)anIndex StopIndex:(NSNumber *)aStopIndex
-{
-    return [[ANTLRRuleMemo alloc] initWithStartIndex:anIndex StopIndex:aStopIndex];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil ) {
-        startIndex = nil;
-        stopIndex = nil;
-    }
-    return (self);
-}
-
-- (id) initWithStartIndex:(NSNumber *)aStartIndex StopIndex:(NSNumber *)aStopIndex
-{
-    if ((self = [super init]) != nil ) {
-        [aStartIndex retain];
-        startIndex = aStartIndex;
-        [aStopIndex retain];
-        stopIndex = aStopIndex;
-    }
-    return (self);
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    ANTLRRuleMemo *copy;
-
-    copy = [super copyWithZone:aZone];
-    copy.startIndex = startIndex;
-    copy.stopIndex = stopIndex;
-    return( copy );
-}
-
-- (NSInteger)count
-{
-    NSInteger aCnt = 0;
-
-    if (startIndex != nil) aCnt++;
-    if (stopIndex != nil) aCnt++;
-    return aCnt;
-}
-
-- (NSInteger) size
-{
-    return (2 * sizeof(id));
-}
-
-- (ANTLRRuleMemo *)getRuleWithStartIndex:(NSInteger)aStartIndex
-{
-    ANTLRRuleMemo *aMatchMemo = self;
-    do {
-        if (aStartIndex == [aMatchMemo.startIndex integerValue] ) {
-            return aMatchMemo;
-        }
-        aMatchMemo = aMatchMemo.fNext;
-    } while ( aMatchMemo != nil );
-    return nil;
-}
-
-- (NSNumber *)getStartIndex:(NSInteger)aStartIndex
-{
-    ANTLRRuleMemo *aMatchMemo = self;
-    do {
-        if (aStartIndex == [aMatchMemo.startIndex integerValue] ) {
-            return aMatchMemo.stopIndex;
-        }
-        aMatchMemo = aMatchMemo.fNext;
-    } while ( aMatchMemo != nil );
-    return nil;
-}
-
-- (NSNumber *)getStopIndex:(NSInteger)aStartIndex
-{
-    ANTLRRuleMemo *aMatchMemo = self;
-    do {
-        if (aStartIndex == [aMatchMemo.startIndex integerValue] ) {
-            return aMatchMemo.stopIndex;
-        }
-        aMatchMemo = aMatchMemo.fNext;
-    } while ( aMatchMemo != nil );
-    return nil;
-}
-
-- (NSNumber *)getStartIndex;
-{
-    return startIndex;
-}
-
-- (void)setStartIndex:(NSNumber *)aStartIndex
-{
-    if ( aStartIndex != startIndex ) {
-        if ( startIndex ) [startIndex release];
-        [aStartIndex retain];
-    }
-    startIndex = aStartIndex;
-}
-
-- (NSNumber *)getStopIndex;
-{
-    return stopIndex;
-}
-
-- (void)setStopIndex:(NSNumber *)aStopIndex
-{
-    if ( aStopIndex != stopIndex ) {
-        if ( stopIndex ) [stopIndex release];
-        [aStopIndex retain];
-    }
-    stopIndex = aStopIndex;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuleReturnScope.h b/runtime/ObjC/Framework/ANTLRRuleReturnScope.h
deleted file mode 100644
index b9313ed..0000000
--- a/runtime/ObjC/Framework/ANTLRRuleReturnScope.h
+++ /dev/null
@@ -1,55 +0,0 @@
-//
-//  ANTLRRuleReturnScope.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/17/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRToken.h"
-
-@interface ANTLRRuleReturnScope : NSObject <NSCopying> {
-
-}
-
-/** Return the start token or tree */
-- (id<ANTLRToken>) getStart;
-
-/** Return the stop token or tree */
-- (id<ANTLRToken>) getStop;
-
-/** Has a value potentially if output=AST; */
-- (id) getTree;
-
-/** Has a value potentially if output=template; Don't use StringTemplate
- *  type as it then causes a dependency with ST lib.
- */
-- (id) getTemplate;
-
-- (id) copyWithZone:(NSZone *)theZone;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuleReturnScope.m b/runtime/ObjC/Framework/ANTLRRuleReturnScope.m
deleted file mode 100644
index 70878a3..0000000
--- a/runtime/ObjC/Framework/ANTLRRuleReturnScope.m
+++ /dev/null
@@ -1,71 +0,0 @@
-//
-//  ANTLRRuleReturnScope.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/17/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRuleReturnScope.h"
-
-
-@implementation ANTLRRuleReturnScope
-
-/** Return the start token or tree */
-- (id) getStart
-{
-    return nil;
-}
-
-/** Return the stop token or tree */
-- (id) getStop
-{
-    return nil;
-}
-
-/** Has a value potentially if output=AST; */
-- (id) getTree
-{
-    return nil;
-}
-
-/** Has a value potentially if output=template; Don't use StringTemplate
- *  type as it then causes a dependency with ST lib.
- */
-- (id) getTemplate
-{
-    return nil;
-}
-
-// create a copy, including the text if available
-// the input stream is *not* copied!
-- (id) copyWithZone:(NSZone *)theZone
-{
-    ANTLRRuleReturnScope *copy = [[[self class] allocWithZone:theZone] init];
-    return copy;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuleStack.h b/runtime/ObjC/Framework/ANTLRRuleStack.h
deleted file mode 100644
index 12d450b..0000000
--- a/runtime/ObjC/Framework/ANTLRRuleStack.h
+++ /dev/null
@@ -1,63 +0,0 @@
-//
-//  ANTLRRuleStack.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseStack.h"
-#import "ANTLRHashRule.h"
-
-//#define GLOBAL_SCOPE       0
-//#define LOCAL_SCOPE        1
-#define HASHSIZE         101
-#define HBUFSIZE      0x2000
-
-@interface ANTLRRuleStack : ANTLRBaseStack {
-}
-
-// Contruction/Destruction
-+(ANTLRRuleStack *)newANTLRRuleStack;
-+(ANTLRRuleStack *)newANTLRRuleStack:(NSInteger)cnt;
--(id)init;
--(id)initWithLen:(NSInteger)cnt;
--(void)dealloc;
-
-// Instance Methods
-- (id) copyWithZone:(NSZone *)aZone;
-/* clear -- reinitialize the maplist array */
-
-- (NSInteger)count;
-- (NSInteger)size;
-
-- (ANTLRHashRule *) pop;
-
-- (void) insertObject:(ANTLRHashRule *)aHashRule atIndex:(NSInteger)idx;
-- (ANTLRHashRule *)objectAtIndex:(NSInteger)idx;
-- (void)putHashRuleAtRuleIndex:(NSInteger)aRuleIndex StartIndex:(NSInteger)aStartIndex StopIndex:(NSInteger)aStopIndex;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuleStack.m b/runtime/ObjC/Framework/ANTLRRuleStack.m
deleted file mode 100644
index 39e93b2..0000000
--- a/runtime/ObjC/Framework/ANTLRRuleStack.m
+++ /dev/null
@@ -1,152 +0,0 @@
-//
-//  ANTLRRuleStack.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#define SUCCESS (0)
-#define FAILURE (-1)
-
-extern NSInteger debug;
-
-#import "ANTLRRuleStack.h"
-#import "ANTLRTree.h"
-
-/*
- * Start of ANTLRRuleStack
- */
-@implementation ANTLRRuleStack
-
-+ (ANTLRRuleStack *)newANTLRRuleStack
-{
-    return [[ANTLRRuleStack alloc] init];
-}
-
-+ (ANTLRRuleStack *)newANTLRRuleStack:(NSInteger)cnt
-{
-    return [[ANTLRRuleStack alloc] initWithLen:cnt];
-}
-
-- (id)init
-{
-	if ((self = [super init]) != nil) {
-	}
-    return( self );
-}
-
-- (id)initWithLen:(NSInteger)cnt
-{
-	if ((self = [super initWithLen:cnt]) != nil) {
-	}
-    return( self );
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRRuleStack" );
-#endif
-	[super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    return [super copyWithZone:aZone];
-}
-
-- (NSInteger)count
-{
-    ANTLRRuleMemo *anElement;
-    NSInteger aCnt = 0;
-    for( int i = 0; i < BuffSize; i++ ) {
-        if ((anElement = ptrBuffer[i]) != nil)
-            aCnt++;
-    }
-    return aCnt;
-}
-
-- (NSInteger)size
-{
-    ANTLRRuleMemo *anElement;
-    NSInteger aSize = 0;
-    for( int i = 0; i < BuffSize; i++ ) {
-        if ((anElement = ptrBuffer[i]) != nil) {
-            aSize++;
-        }
-    }
-    return aSize;
-}
-
-- (ANTLRHashRule *)pop
-{
-    return (ANTLRHashRule *)[super pop];
-}
-
-- (void) insertObject:(ANTLRHashRule *)aRule atIndex:(NSInteger)idx
-{
-    if ( idx >= BuffSize ) {
-        if ( debug > 2 ) NSLog( @"In ANTLRRuleStack attempting to insert aRule at Index %d, but Buffer is only %d long\n", idx, BuffSize );
-        [self ensureCapacity:idx];
-    }
-    if ( aRule != ptrBuffer[idx] ) {
-        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
-        [aRule retain];
-    }
-    ptrBuffer[idx] = aRule;
-}
-
-- (ANTLRHashRule *)objectAtIndex:(NSInteger)idx
-{
-    if (idx < BuffSize) {
-        return ptrBuffer[idx];
-    }
-    return nil;
-}
-
-- (void)putHashRuleAtRuleIndex:(NSInteger)aRuleIndex StartIndex:(NSInteger)aStartIndex StopIndex:(NSInteger)aStopIndex
-{
-    ANTLRHashRule *aHashRule;
-    ANTLRRuleMemo *aRuleMemo;
-
-    if (aRuleIndex >= BuffSize) {
-        if ( debug) NSLog( @"putHashRuleAtRuleIndex attempting to insert aRule at Index %d, but Buffer is only %d long\n", aRuleIndex, BuffSize );
-        [self ensureCapacity:aRuleIndex];
-    }
-    if ((aHashRule = ptrBuffer[aRuleIndex]) == nil) {
-        aHashRule = [[ANTLRHashRule newANTLRHashRuleWithLen:17] retain];
-        ptrBuffer[aRuleIndex] = aHashRule;
-    }
-    if (( aRuleMemo = [aHashRule objectAtIndex:aStartIndex] ) == nil ) {
-        aRuleMemo = [[ANTLRRuleMemo newANTLRRuleMemo] retain];
-        [aHashRule insertObject:aRuleMemo atIndex:aStartIndex];
-    }
-    [aRuleMemo setStartIndex:[NSNumber numberWithInteger:aStartIndex]];
-    [aRuleMemo setStopIndex:[NSNumber numberWithInteger:aStopIndex]];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRRuntimeException.h b/runtime/ObjC/Framework/ANTLRRuntimeException.h
deleted file mode 100644
index 47834d2..0000000
--- a/runtime/ObjC/Framework/ANTLRRuntimeException.h
+++ /dev/null
@@ -1,111 +0,0 @@
-//
-//  ANTLRRuntimeException.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/5/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-
-@interface ANTLRRuntimeException : NSException {
-}
-
-+ (ANTLRRuntimeException *) newException;
-+ (ANTLRRuntimeException *) newException:(NSString *)aReason;
-+ (ANTLRRuntimeException *) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-+ (ANTLRRuntimeException *) newException:(NSString *)aName reason:(NSString *)aReason;
-+ (ANTLRRuntimeException *) newException:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-- (id) init;
-- (id) init:(NSString *)aReason;
-- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason;
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-- (NSString *) Description;
-- (id) stackTrace:(NSException *)e;
-
-@end
-
-@interface ANTLRIllegalArgumentException : ANTLRRuntimeException {
-}
-
-+ (id) newException;
-+ (id) newException:(NSString *)aReason;
-+ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-- (id) init;
-- (id)init:(NSString *)aReason;
-- (id)init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-@end
-
-@interface ANTLRIllegalStateException : ANTLRRuntimeException {
-}
-
-+ (id) newException;
-+ (id) newException:(NSString *)aReason;
-+ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-- (id) init;
-- (id)init:(NSString *)aReason;
-- (id)init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-@end
-
-@interface ANTLRNoSuchElementException : ANTLRRuntimeException {
-}
-
-+ (id) newException;
-+ (id) newException:(NSString *)aReason;
-+ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-- (id) init;
-- (id) init:(NSString *)aReason;
-- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-@end
-
-@interface ANTLRRewriteEarlyExitException : ANTLRRuntimeException {
-}
-
-+ (id) newException;
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-
-@end
-
-@interface ANTLRUnsupportedOperationException : ANTLRRuntimeException {
-}
-
-+ (id) newException:(NSString *)aReason;
-
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason;
-- (id) initWithName:(NSString *)aMsg reason:(NSString *)aCause userInfo:(NSDictionary *)userInfo;
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRRuntimeException.m b/runtime/ObjC/Framework/ANTLRRuntimeException.m
deleted file mode 100644
index 827fc43..0000000
--- a/runtime/ObjC/Framework/ANTLRRuntimeException.m
+++ /dev/null
@@ -1,279 +0,0 @@
-//
-//  ANTLRRuntimeException.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/5/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRRuntimeException.h"
-
-
-@implementation ANTLRRuntimeException
-
-+ (id) newException
-{
-    return [[ANTLRRuntimeException alloc] init];
-}
-
-+ (id) newException:(NSString *)aReason
-{
-    return [[ANTLRRuntimeException alloc] init:aReason];
-}
-
-+ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    return [[ANTLRRuntimeException alloc] init:aReason userInfo:aUserInfo];
-}
-
-+ (id) newException:(NSString *)aName reason:(NSString *)aReason;
-{
-    return [[ANTLRRuntimeException alloc] initWithName:aName reason:aReason];
-}
-
-+ (id) newException:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
-{
-    return [[ANTLRRuntimeException alloc] initWithName:aName reason:aReason userInfo:aUserInfo];
-}
-
-
-- (id) init
-{
-    self = [super initWithName:@"ANTLRRuntimeException" reason:@"UnknownException" userInfo:nil];
-    return(self);
-}
-
-- (id) init:(NSString *)aReason
-{
-    self = [super initWithName:(NSString *)@"ANTLRRuntimeException" reason:(NSString *)aReason userInfo:(NSDictionary *)nil];
-    return(self);
-}
-
-- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    self = [super initWithName:@"ANTLRRuntimeException" reason:aReason userInfo:aUserInfo];
-    return(self);
-}
-
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason
-{
-    self = [super initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)nil];
-    return(self);
-}
-
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    self = [super initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo];
-    return(self);
-}
-
-- (NSString *) Description
-{
-    return [super reason];
-}
-
-- (id) stackTrace:(NSException *)e
-{
-    NSArray *addrs = [e callStackReturnAddresses];
-    NSArray *trace = [e callStackSymbols];
-
-    for (NSString *traceStr in trace) {
-        NSLog( @"%@", traceStr);
-        // TODO: remove special after testing
-        if ([traceStr hasPrefix:@"main("] > 0)
-            return traceStr;
-        if (![traceStr hasPrefix:@"org.stringtemplate"])
-            return traceStr;
-    }
-    return trace;
-}
-
-@end
-
-@implementation ANTLRIllegalArgumentException
-
-+ (id) newException
-{
-    return [[ANTLRIllegalArgumentException alloc] init];
-}
-
-+ (id) newException:(NSString *)aReason
-{
-    return [[ANTLRIllegalArgumentException alloc] init:aReason];
-}
-
-+ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    return [[ANTLRIllegalArgumentException alloc] init:aReason userInfo:aUserInfo];
-}
-
-- (id) init
-{
-    self = [super initWithName:@"ANTLRIllegalArgumentException" reason:@"UnknownException" userInfo:nil];
-    return(self);
-}
-
-- (id) init:(NSString *)aReason
-{
-    self = [super initWithName:@"ANTLRIllegalArgumentException" reason:(NSString *)aReason userInfo:nil];
-    return(self);
-}
-
-- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    self = [super initWithName:@"ANTLRIllegalArgumentException" reason:aReason userInfo:aUserInfo];
-    return(self);
-}
-
-@end
-
-@implementation ANTLRIllegalStateException
-
-+ (id) newException
-{
-    return [[ANTLRIllegalStateException alloc] init];
-}
-
-+ (id) newException:(NSString *)aReason
-{
-    return [[ANTLRIllegalStateException alloc] init:aReason];
-}
-
-+ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    return [[ANTLRIllegalStateException alloc] init:aReason userInfo:aUserInfo];
-}
-
-- (id) init
-{
-    self = [super initWithName:@"ANTLRIllegalStateException" reason:@"UnknownException" userInfo:nil];
-    return(self);
-}
-
-- (id) init:(NSString *)aReason
-{
-    self = [super initWithName:@"ANTLRIllegalStateException" reason:(NSString *)aReason userInfo:nil];
-    return(self);
-}
-
-- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    self = [super initWithName:@"ANTLRIllegalStateException" reason:aReason userInfo:aUserInfo];
-    return(self);
-}
-
-@end
-
-@implementation ANTLRNoSuchElementException
-
-+ (id) newException
-{
-    return [[ANTLRNoSuchElementException alloc] init];
-}
-
-+ (id) newException:(NSString *)aReason
-{
-    return [[ANTLRNoSuchElementException alloc] init:aReason];
-}
-
-+ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    return [[ANTLRNoSuchElementException alloc] init:aReason userInfo:(NSDictionary *)aUserInfo];
-}
-
-- (id) init
-{
-    self = [super initWithName:@"ANTLRNoSuchElementException" reason:@"UnknownException" userInfo:nil];
-    return(self);
-}
-
-- (id) init:(NSString *)aReason
-{
-    self = [super initWithName:@"ANTLRNoSuchElementException" reason:(NSString *)aReason userInfo:(NSDictionary *)nil];
-    return(self);
-}
-
-- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    self = [super initWithName:@"ANTLRNoSuchElementException" reason:aReason userInfo:aUserInfo];
-    return(self);
-}
-
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    self = [super initWithName:aName reason:aReason userInfo:aUserInfo];
-    return(self);
-}
-
-@end
-
-@implementation ANTLRRewriteEarlyExitException
-
-+ (id) newException
-{
-	return [[self alloc] init];
-}
-
-- (id) init
-{
-	self = [super initWithName:@"RewriteEarlyExitException" reason:nil userInfo:nil];
-	return self;
-}
-
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
-{
-    self = [super initWithName:aName reason:aReason userInfo:aUserInfo];
-    return(self);
-}
-
-- (NSString *) description
-{
-	return [self name];
-}
-
-@end
-
-@implementation ANTLRUnsupportedOperationException
-
-+ (id) newException:(NSString *)aReason
-{
-    return [[ANTLRRuntimeException alloc] initWithName:@"Unsupported Operation Exception" reason:aReason userInfo:nil];
-}
-
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason
-{
-    self=[super initWithName:aName reason:aReason userInfo:nil];
-    return self;
-}
-
-- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)userInfo
-{
-    self=[super initWithName:aName reason:aReason userInfo:userInfo];
-    return self;
-}
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRStreamEnumerator.h b/runtime/ObjC/Framework/ANTLRStreamEnumerator.h
deleted file mode 100644
index 9e102f2..0000000
--- a/runtime/ObjC/Framework/ANTLRStreamEnumerator.h
+++ /dev/null
@@ -1,48 +0,0 @@
-//
-//  ANTLRStreamEnumertor.h
-//  ANTLR
-//
-//  Created by Ian Michell on 29/04/2010.
-// [The "BSD licence"]
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "AMutableArray.h"
-
-@interface ANTLRStreamEnumerator : NSEnumerator
-{
-	NSInteger i;
-	id eof;
-	AMutableArray *nodes;
-}
-
--(id) initWithNodes:(AMutableArray *) n andEOF:(id) obj;
--(BOOL) hasNext;
-
-@property NSInteger i;
-@property (retain) id eof;
-@property (retain) AMutableArray *nodes;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRStreamEnumerator.m b/runtime/ObjC/Framework/ANTLRStreamEnumerator.m
deleted file mode 100644
index 103646e..0000000
--- a/runtime/ObjC/Framework/ANTLRStreamEnumerator.m
+++ /dev/null
@@ -1,77 +0,0 @@
-//
-//  ANTLRStreamEnumertor.m
-//  ANTLR
-//
-//  Created by Ian Michell on 29/04/2010.
-// [The "BSD licence"]
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRStreamEnumerator.h"
-
-
-@implementation ANTLRStreamEnumerator
-
--(id) init
-{
-	self = [super init];
-	if (self)
-	{
-		i = 0;
-	}
-	return self;
-}
-
--(id) initWithNodes:(AMutableArray *) n andEOF:(id) obj
-{
-	self = [self init];
-	if (self)
-	{
-		nodes = n;
-		eof = obj;
-	}
-	return self;
-}
-
--(BOOL) hasNext
-{
-	return i < [nodes count];
-}
-
--(id) nextObject
-{
-	NSUInteger current = i;
-	i++;
-	if (current < [nodes count])
-	{
-		return [nodes objectAtIndex:current];
-	}
-	return eof;
-}
-
-@synthesize i;
-@synthesize eof;
-@synthesize nodes;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRStringStreamState.h b/runtime/ObjC/Framework/ANTLRStringStreamState.h
deleted file mode 100644
index eda483b..0000000
--- a/runtime/ObjC/Framework/ANTLRStringStreamState.h
+++ /dev/null
@@ -1,58 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRCharStream.h"
-
-// encapsulates a stream's state, so we can put it into an NSArray.
-// No magic is happening here.
-
-@interface ANTLRCharStreamState : NSObject <ANTLRCharStream>
-{
-	NSUInteger index;
-	NSUInteger line;
-	NSUInteger charPositionInLine;
-}
-
-+ newANTLRCharStreamState;
-
-- (id) init;
-
-- (NSUInteger) getIndex;
-- (void) setIndex: (NSUInteger) anIndex;
-
-- (NSUInteger) getLine;
-- (void) setLine: (NSUInteger) aLine;
-
-- (NSUInteger) getCharPositionInLine;
-- (void) setCharPositionInLine: (NSUInteger) aCharPositionInLine;
-
-
-@property (assign) NSUInteger index;
-@property (assign) NSUInteger line;
-@property (assign) NSUInteger charPositionInLine;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRSymbolStack.h b/runtime/ObjC/Framework/ANTLRSymbolStack.h
deleted file mode 100644
index 169df9f..0000000
--- a/runtime/ObjC/Framework/ANTLRSymbolStack.h
+++ /dev/null
@@ -1,75 +0,0 @@
-//
-//  ANTLRSymbolStack.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseStack.h"
-// #import "ANTLRSymbolScope.h"
-
-//#define GLOBAL_SCOPE       0
-//#define LOCAL_SCOPE        1
-#define HASHSIZE         101
-#define HBUFSIZE      0x2000
-
-@interface ANTLRSymbolsScope : NSObject
-{
-
-}
-
-+ (ANTLRSymbolsScope *)newANTLRSymbolsScope;
-
-- (id)init;
-@end
-
-
-@interface ANTLRSymbolStack : ANTLRBaseStack {
-}
-
-// Contruction/Destruction
-+(ANTLRSymbolStack *)newANTLRSymbolStack;
-+(ANTLRSymbolStack *)newANTLRSymbolStackWithLen:(NSInteger)cnt;
--(id)init;
--(id)initWithLen:(NSInteger)cnt;
--(void)dealloc;
-
-// Instance Methods
-- (id) copyWithZone:(NSZone *)aZone;
-/* clear -- reinitialize the maplist array */
-
--(ANTLRSymbolsScope *)getHashMapEntry:(NSInteger)idx;
-
--(ANTLRSymbolsScope **)getHashMap;
-
--(ANTLRSymbolsScope *) pop;
-
-- (void) insertObject:(ANTLRSymbolsScope *)aScope atIndex:(NSInteger)idx;
-- (ANTLRSymbolsScope *)objectAtIndex:(NSInteger)idx;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRSymbolStack.m b/runtime/ObjC/Framework/ANTLRSymbolStack.m
deleted file mode 100644
index 3c43ebb..0000000
--- a/runtime/ObjC/Framework/ANTLRSymbolStack.m
+++ /dev/null
@@ -1,126 +0,0 @@
-//
-//  ANTLRSymbolStack.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/9/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#define SUCCESS (0)
-#define FAILURE (-1)
-
-#import "ANTLRSymbolStack.h"
-#import "ANTLRTree.h"
-
-
-@implementation ANTLRSymbolsScope
-
-+ (ANTLRSymbolsScope *)newANTLRSymbolsScope
-{
-    return( [[ANTLRSymbolsScope alloc] init] );
-}
-
-- (id)init
-{
-    if ((self = [super init]) != nil) {
-    }
-    return (self);
-}
-
-@end
-
-/*
- * Start of ANTLRSymbolStack
- */
-@implementation ANTLRSymbolStack
-
-+(ANTLRSymbolStack *)newANTLRSymbolStack
-{
-    return [[ANTLRSymbolStack alloc] initWithLen:30];
-}
-
-+(ANTLRSymbolStack *)newANTLRSymbolStackWithLen:(NSInteger)cnt
-{
-    return [[ANTLRSymbolStack alloc] initWithLen:cnt];
-}
-
--(id)init
-{
-	if ((self = [super init]) != nil) {
-	}
-    return( self );
-}
-
--(id)initWithLen:(NSInteger)cnt
-{
-	if ((self = [super initWithLen:cnt]) != nil) {
-	}
-    return( self );
-}
-
--(void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRSymbolStack" );
-#endif
-	[super dealloc];
-}
-
-- (id) copyWithZone:(NSZone *)aZone
-{
-    return [super copyWithZone:aZone];
-}
-
--(ANTLRSymbolsScope *)getHashMapEntry:(NSInteger)idx
-{
-	return( (ANTLRSymbolsScope *)[super objectAtIndex:idx] );
-}
-
--(ANTLRSymbolsScope **)getHashMap
-{
-	return( (ANTLRSymbolsScope **)ptrBuffer );
-}
-
--(ANTLRSymbolsScope *) pop
-{
-    return (ANTLRSymbolsScope *)[super pop];
-}
-
-- (void) insertObject:(ANTLRSymbolsScope *)aRule atIndex:(NSInteger)idx
-{
-    if ( aRule != ptrBuffer[idx] ) {
-        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
-        [aRule retain];
-    }
-    ptrBuffer[idx] = aRule;
-}
-
-- (ANTLRSymbolsScope *)objectAtIndex:(NSInteger)idx
-{
-    return (ANTLRSymbolsScope *)[super objectAtIndex:idx];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.h b/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.h
deleted file mode 100644
index 659e763..0000000
--- a/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.h
+++ /dev/null
@@ -1,41 +0,0 @@
-//
-//  ANTLRToken+DebuggerSupport.h
-//  ANTLR
-//
-//  Created by Kay Röpke on 03.12.2006.
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-//
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRToken.h"
-#import "ANTLRCommonToken.h"
-
-@interface ANTLRCommonToken(DebuggerSupport)
-
-- (NSString *)debuggerDescription;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.m b/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.m
deleted file mode 100644
index 114b236..0000000
--- a/runtime/ObjC/Framework/ANTLRToken+DebuggerSupport.m
+++ /dev/null
@@ -1,61 +0,0 @@
-//
-//  ANTLRToken+DebuggerSupport.m
-//  ANTLR
-//
-//  Created by Kay Röpke on 03.12.2006.
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRToken+DebuggerSupport.h"
-
-
-@implementation ANTLRCommonToken(DebuggerSupport)
-
-- (NSString *)debuggerDescription
-{
-	NSString *_text = self.text;
-	NSMutableString *escapedText;
-	if (_text) {
-		escapedText = [_text copyWithZone:nil];
-		NSRange wholeString = NSMakeRange(0,[escapedText length]);
-		[escapedText replaceOccurrencesOfString:@"%" withString:@"%25" options:0 range:wholeString];
-		[escapedText replaceOccurrencesOfString:@"\n" withString:@"%0A" options:0 range:wholeString];
-		[escapedText replaceOccurrencesOfString:@"\r" withString:@"%0D" options:0 range:wholeString];
-	} else {
-		escapedText = [NSMutableString stringWithString:@""];
-	}
-	// format is tokenIndex, type, channel, line, col, (escaped)text
-	return [NSString stringWithFormat:@"%u %d %u %u %u \"%@",
-		[self getTokenIndex],
-		self.type,
-		self.channel,
-		self.line,
-		self.charPositionInLine,
-		escapedText
-		];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRToken.h b/runtime/ObjC/Framework/ANTLRToken.h
deleted file mode 100644
index 04724bd..0000000
--- a/runtime/ObjC/Framework/ANTLRToken.h
+++ /dev/null
@@ -1,89 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-
-#ifndef DEBUG_DEALLOC
-#define DEBUG_DEALLOC
-#endif
-
-typedef enum {
-    ANTLRTokenTypeEOF = -1,
-    ANTLRTokenTypeInvalid,
-    ANTLRTokenTypeEOR,
-    ANTLRTokenTypeDOWN,
-    ANTLRTokenTypeUP,
-    ANTLRTokenTypeMIN
-} ANTLRTokenType;
-
-typedef enum {
-    ANTLRTokenChannelDefault = 0,
-    ANTLRTokenChannelHidden = 99
-} ANTLRTokenChannel;
-
-#define HIDDEN 99
-
-@protocol ANTLRToken < NSObject, NSCopying >
-
-@property (retain, getter = text, setter = setText:) NSString *text;
-@property (assign) NSInteger type;
-@property (assign) NSUInteger line;
-@property (assign) NSUInteger charPositionInLine;
-
-// The singleton eofToken instance.
-+ (id<ANTLRToken>) eofToken;
-// The default channel for this class of Tokens
-+ (ANTLRTokenChannel) defaultChannel;
-
-// provide hooks to explicitely set the text as opposed to use the indices into the CharStream
-- (NSString *) text;
-- (void) setText:(NSString *)theText;
-
-- (NSInteger)type;
-- (void) setType: (NSInteger) aType;
-
-// ANTLR v3 provides automatic line and position tracking. Subclasses do not need to
-// override these, if they do not want to store line/pos tracking information
-- (NSUInteger)line;
-- (void) setLine: (NSUInteger) aLine;
-
-- (NSUInteger)charPositionInLine;
-- (void) setCharPositionInLine:(NSUInteger)aCharPositionInLine;
-
-// explicitely change the channel this Token is on. The default parser implementation
-// just sees the defaultChannel
-// Common idiom is to put whitespace tokens on channel 99.
-- (NSUInteger)channel;
-- (void) setChannel: (NSUInteger) aChannel;
-
-// the index of this Token into the TokenStream
-- (NSInteger) getTokenIndex;
-- (void) setTokenIndex: (NSInteger) aTokenIndex;
-- (NSString *)toString;
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRTokenRewriteStream.h b/runtime/ObjC/Framework/ANTLRTokenRewriteStream.h
deleted file mode 100644
index 7b97168..0000000
--- a/runtime/ObjC/Framework/ANTLRTokenRewriteStream.h
+++ /dev/null
@@ -1,170 +0,0 @@
-//
-//  ANTLRTokenRewriteStream.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/19/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRCommonTokenStream.h"
-#import "ANTLRLinkBase.h"
-#import "ANTLRHashMap.h"
-#import "ANTLRMapElement.h"
-#import "ANTLRTokenSource.h"
-
-// Define the rewrite operation hierarchy
-
-@interface ANTLRRewriteOperation : ANTLRCommonTokenStream
-{
-/** What rwIndex into rewrites List are we? */
-NSInteger instructionIndex;
-/** Token buffer rwIndex. */
-NSInteger rwIndex;
-NSString *text;
-}
-
-@property (getter=getInstructionIndex, setter=setInstructionIndex:) NSInteger instructionIndex;
-@property (assign) NSInteger rwIndex;
-@property (retain, getter=text, setter=setText:) NSString *text;
-
-+ (ANTLRRewriteOperation *) newANTLRRewriteOperation:(NSInteger)anIndex Text:(NSString *)text;
-
-- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText;
-
-/** Execute the rewrite operation by possibly adding to the buffer.
- *  Return the rwIndex of the next token to operate on.
- */
-- (NSInteger) execute:(NSString *)buf;
-
-- (NSString *)toString;
-- (NSInteger) indexOf:(char)aChar inString:(NSString *)aString;
-@end
-
-@interface ANTLRInsertBeforeOp : ANTLRRewriteOperation {
-}
-
-+ (ANTLRInsertBeforeOp *) newANTLRInsertBeforeOp:(NSInteger)anIndex Text:(NSString *)theText;
-- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText;
-
-@end
-
-/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
- *  instructions.
- */
-@interface ANTLRReplaceOp : ANTLRRewriteOperation {
-    NSInteger lastIndex;
-}
-
-@property (assign) NSInteger lastIndex;
-
-+ (ANTLRReplaceOp *) newANTLRReplaceOp:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString*)theText;
-- (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText;
-
-- (NSInteger) execute:(NSString *)buf;
-- (NSString *)toString;
-
-@end
-
-@interface ANTLRDeleteOp : ANTLRReplaceOp {
-}
-+ (ANTLRDeleteOp *) newANTLRDeleteOp:(NSInteger)from ToIndex:(NSInteger)to;
-
-- (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to;
-
-- (NSString *)toString;
-
-@end
-
-
-@interface ANTLRTokenRewriteStream : ANTLRCommonTokenStream {
-/** You may have multiple, named streams of rewrite operations.
- *  I'm calling these things "programs."
- *  Maps String (name) -> rewrite (List)
- */
-ANTLRHashMap *programs;
-
-/** Map String (program name) -> Integer rwIndex */
-ANTLRHashMap *lastRewriteTokenIndexes;
-}
-
-@property (retain, getter=getPrograms, setter=setPrograms:) ANTLRHashMap *programs;
-@property (retain, getter=getLastRewriteTokenIndexes, setter=setLastRewriteTokenIndexes:) ANTLRHashMap *lastRewriteTokenIndexes;
-
-+ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream;
-+ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream:(id<ANTLRTokenSource>) aTokenSource;
-+ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream:(id<ANTLRTokenSource>) aTokenSource Channel:(NSInteger)aChannel;
-
-- (id) init;
-- (id)initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource;
-- (id)initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource Channel:(NSInteger)aChannel;
-
-- (ANTLRHashMap *)getPrograms;
-- (void)setPrograms:(ANTLRHashMap *)aProgList;
-
-- (void) rollback:(NSInteger)instructionIndex;
-- (void) rollback:(NSString *)programName Index:(NSInteger)anInstructionIndex;
-- (void) deleteProgram;
-- (void) deleteProgram:(NSString *)programName;
-- (void) insertAfterToken:(id<ANTLRToken>)t Text:(NSString *)theText;
-- (void) insertAfterIndex:(NSInteger)anIndex Text:(NSString *)theText;
-- (void) insertAfterProgNam:(NSString *)programName Index:(NSInteger)anIndex Text:(NSString *)theText;
-
-
-- (void) insertBeforeToken:(id<ANTLRToken>)t Text:(NSString *)theText;
-- (void) insertBeforeIndex:(NSInteger)anIndex Text:(NSString *)theText;
-- (void) insertBeforeProgName:(NSString *)programName Index:(NSInteger)anIndex Text:(NSString *)theText;
-- (void) replaceFromIndex:(NSInteger)anIndex Text:(NSString *)theText;
-- (void) replaceFromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText;
-- (void) replaceFromToken:(id<ANTLRToken>)indexT Text:(NSString *)theText;
-- (void) replaceFromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to Text:(NSString *)theText;
-- (void) replaceProgNam:(NSString *)programName Token:(id<ANTLRToken>)from Token:(id<ANTLRToken>)to Text:(NSString *)theText;
-- (void) replaceProgNam:(NSString *)programName FromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText;
-- (void) delete:(NSInteger)anIndex;
-- (void) delete:(NSInteger)from ToIndex:(NSInteger)to;
-- (void) deleteToken:(id<ANTLRToken>)indexT;
-- (void) deleteFromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to;
-- (void) delete:(NSString *)programName FromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to;
-- (void) delete:(NSString *)programName FromIndex:(NSInteger)from ToIndex:(NSInteger)to;
-- (NSInteger)getLastRewriteTokenIndex;
-- (NSInteger)getLastRewriteTokenIndex:(NSString *)programName;
-- (void)setLastRewriteTokenIndex:(NSString *)programName Index:(NSInteger)anInt;
-- (ANTLRHashMap *) getProgram:(NSString *)name;
-- (ANTLRHashMap *) initializeProgram:(NSString *)name;
-- (NSString *)toOriginalString;
-- (NSString *)toOriginalString:(NSInteger)start End:(NSInteger)end;
-- (NSString *)toString;
-- (NSString *)toString:(NSString *)programName;
-- (NSString *)toStringFromStart:(NSInteger)start ToEnd:(NSInteger)end;
-- (NSString *)toString:(NSString *)programName FromStart:(NSInteger)start ToEnd:(NSInteger)end;
-- (ANTLRHashMap *)reduceToSingleOperationPerIndex:(ANTLRHashMap *)rewrites;
-- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind;
-- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind Index:(NSInteger)before;
-- (NSString *)catOpText:(id)a PrevText:(id)b;
-- (NSMutableString *)toDebugString;
-- (NSMutableString *)toDebugStringFromStart:(NSInteger)start ToEnd:(NSInteger)end;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTokenRewriteStream.m b/runtime/ObjC/Framework/ANTLRTokenRewriteStream.m
deleted file mode 100644
index e94f885..0000000
--- a/runtime/ObjC/Framework/ANTLRTokenRewriteStream.m
+++ /dev/null
@@ -1,692 +0,0 @@
-//
-//  ANTLRTokenRewriteStream.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/19/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTokenRewriteStream.h"
-#import "ANTLRRuntimeException.h"
-
-static NSString *DEFAULT_PROGRAM_NAME = @"default";
-static NSInteger PROGRAM_INIT_SIZE = 100;
-static NSInteger MIN_TOKEN_INDEX = 0;
-
-extern NSInteger debug;
-
-// Define the rewrite operation hierarchy
-
-@implementation ANTLRRewriteOperation
-
-@synthesize instructionIndex;
-@synthesize rwIndex;
-@synthesize text;
-
-+ (ANTLRRewriteOperation *) newANTLRRewriteOperation:(NSInteger)anIndex Text:(NSString *)theText
-{
-    return [[ANTLRRewriteOperation alloc] initWithIndex:anIndex Text:theText];
-}
-
-- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText
-{
-    if ((self = [super init]) != nil) {
-        rwIndex = anIndex;
-        text = theText;
-    }
-    return self;
-}
-
-/** Execute the rewrite operation by possibly adding to the buffer.
- *  Return the rwIndex of the next token to operate on.
- */
-- (NSInteger) execute:(NSString *)buf
-{
-    return rwIndex;
-}
-
-- (NSString *)toString
-{
-    NSString *opName = [self className];
-    int $index = [self indexOf:'$' inString:opName];
-    opName = [opName substringWithRange:NSMakeRange($index+1, [opName length])];
-    return [NSString stringWithFormat:@"<%@%d:\"%@\">", opName, rwIndex, opName];
-}
-
-- (NSInteger) indexOf:(char)aChar inString:(NSString *)aString
-{
-    char indexedChar;
-
-    for( int i = 0; i < [aString length]; i++ ) {
-        indexedChar = [aString characterAtIndex:i];
-        if (indexedChar == aChar) {
-            return i;
-        }
-    }
-    return -1;
-}
-
-@end
-
-@implementation ANTLRInsertBeforeOp
-
-+ (ANTLRInsertBeforeOp *) newANTLRInsertBeforeOp:(NSInteger) anIndex Text:(NSString *)theText
-{
-    return [[ANTLRInsertBeforeOp alloc] initWithIndex:anIndex Text:theText];
-}
-
-- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText
-{
-    if ((self = [super initWithIndex:anIndex Text:theText]) != nil) {
-        rwIndex = anIndex;
-        text = theText;
-    }
-    return self;
-}
-
-
-- (NSInteger) execute:(NSMutableString *)buf
-{
-    [buf appendString:text];
-    if ( ((ANTLRCommonToken *)[tokens objectAtIndex:rwIndex]).type != ANTLRTokenTypeEOF ) {
-        [buf appendString:[[tokens objectAtIndex:rwIndex] text]];
-    }
-    return rwIndex+1;
-}
-
-@end
-
-/** I'm going to try replacing range from x..y with (y-x)+1 ANTLRReplaceOp
- *  instructions.
- */
-@implementation ANTLRReplaceOp
-
-@synthesize lastIndex;
-
-+ (ANTLRReplaceOp *) newANTLRReplaceOp:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString*)theText
-{
-    return [[ANTLRReplaceOp alloc] initWithIndex:from ToIndex:to Text:theText];
-}
-
-- (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText
-{
-    if ((self = [super initWithIndex:from Text:theText]) != nil) {
-        lastIndex = to;
-    }
-    return self;
-}
-
-
-- (NSInteger) execute:(NSMutableString *)buf
-{
-    if ( text!=nil ) {
-        [buf appendString:text];
-    }
-        return lastIndex+1;
-}
-
-- (NSString *)toString
-{
-    return [NSString stringWithFormat:@"<ANTLRReplaceOp@ %d..%d :>%@\n", rwIndex, lastIndex, text];
-}
-
-@end
-
-@implementation ANTLRDeleteOp
-
-+ (ANTLRDeleteOp *) newANTLRDeleteOp:(NSInteger)from ToIndex:(NSInteger)to
-{
-    // super(from To:to, null);
-    return [[ANTLRDeleteOp alloc] initWithIndex:from ToIndex:to];
-}
-
- - (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to
-{
-    if ((self = [super initWithIndex:from ToIndex:to Text:nil]) != nil) {
-        lastIndex = to;
-    }
-    return self;
-}
-
-- (NSString *)toString
-{
-    return [NSString stringWithFormat:@"<DeleteOp@ %d..%d\n",  rwIndex, lastIndex];
-}
-
-@end
-
-
-@implementation ANTLRTokenRewriteStream
-
-@synthesize programs;
-@synthesize lastRewriteTokenIndexes;
-
-+ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream
-{
-    return [[ANTLRTokenRewriteStream alloc] init];
-}
-
-+ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream:(id<ANTLRTokenSource>) aTokenSource
-{
-    return [[ANTLRTokenRewriteStream alloc] initWithTokenSource:aTokenSource];
-}
-
-+ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream:(id<ANTLRTokenSource>) aTokenSource Channel:(NSInteger)aChannel
-{
-    return [[ANTLRTokenRewriteStream alloc] initWithTokenSource:aTokenSource Channel:aChannel];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil) {
-        programs = [ANTLRHashMap newANTLRHashMap];
-        [programs addObject:[ANTLRMapElement newANTLRMapElementWithName:DEFAULT_PROGRAM_NAME Node:[ANTLRHashMap newANTLRHashMapWithLen:PROGRAM_INIT_SIZE]]];
-        lastRewriteTokenIndexes = [ANTLRHashMap newANTLRHashMap];
-    }
-    return self;
-}
-
-- (id)initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource
-{
-    if ((self = [super init]) != nil) {
-        programs = [ANTLRHashMap newANTLRHashMap];
-        [programs addObject:[ANTLRMapElement newANTLRMapElementWithName:DEFAULT_PROGRAM_NAME Node:[ANTLRHashMap newANTLRHashMapWithLen:PROGRAM_INIT_SIZE]]];
-        lastRewriteTokenIndexes = [ANTLRHashMap newANTLRHashMap];
-        tokenSource = aTokenSource;
-    }
-    return self;
-}
-
-- (id)initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource Channel:(NSInteger)aChannel
-{
-    if ((self = [super init]) != nil) {
-        programs = [ANTLRHashMap newANTLRHashMap];
-        [programs addObject:[ANTLRMapElement newANTLRMapElementWithName:DEFAULT_PROGRAM_NAME Node:[ANTLRHashMap newANTLRHashMapWithLen:PROGRAM_INIT_SIZE]]];
-        lastRewriteTokenIndexes = [ANTLRHashMap newANTLRHashMap];
-        tokenSource = aTokenSource;
-        channel = aChannel;
-    }
-    return self;
-}
-
-- (ANTLRHashMap *)getPrograms
-{
-    return programs;
-}
-
-- (void)setPrograms:(ANTLRHashMap *)aProgList
-{
-    programs = aProgList;
-}
-
-- (void) rollback:(NSInteger)instructionIndex
-{
-    [self rollback:DEFAULT_PROGRAM_NAME Index:instructionIndex];
-}
-
-/** Rollback the instruction stream for a program so that
- *  the indicated instruction (via instructionIndex) is no
- *  longer in the stream.  UNTESTED!
- */
-- (void) rollback:(NSString *)programName Index:(NSInteger)anInstructionIndex
-{
-    id object;
-    ANTLRHashMap *is;
-
-    //    AMutableArray *is = [programs get(programName)];
-    is = [self getPrograms];
-    object = [is getName:programName];
-    if ( is != nil ) {
-#pragma warning this has to be fixed
-        [programs insertObject:programName  atIndex:anInstructionIndex];
-    }
-}
-
-- (void) deleteProgram
-{
-    [self deleteProgram:DEFAULT_PROGRAM_NAME];
-}
-
-/** Reset the program so that no instructions exist */
-- (void) deleteProgram:(NSString *)programName
-{
-    [self rollback:programName Index:MIN_TOKEN_INDEX];
-}
-
-- (void) insertAfterToken:(id<ANTLRToken>)t Text:(NSString *)theText
-{
-    [self insertAfterProgNam:DEFAULT_PROGRAM_NAME Index:[t getTokenIndex] Text:theText];
-}
-
-- (void) insertAfterIndex:(NSInteger)anIndex Text:(NSString *)theText
-{
-    [self insertAfterProgNam:DEFAULT_PROGRAM_NAME Index:(NSInteger)anIndex Text:(NSString *)theText];
-}
-
-- (void) insertAfterProgNam:(NSString *)programName Index:(NSInteger)anIndex Text:(NSString *)theText
-{
-    // to insert after, just insert before next rwIndex (even if past end)
-    [self insertBeforeProgName:programName Index:anIndex+1 Text:theText];
-    //addToSortedRewriteList(programName, new InsertAfterOp(rwIndex,text));
-}
-
-
-
-
-
-
-
-
-
-- (void) insertBeforeToken:(id<ANTLRToken>)t Text:(NSString *)theText
-{
-    [self insertBeforeProgName:DEFAULT_PROGRAM_NAME Index:[t getTokenIndex] Text:theText];
-}
-
-- (void) insertBeforeIndex:(NSInteger)anIndex Text:(NSString *)theText
-{
-    [self insertBeforeProgName:DEFAULT_PROGRAM_NAME Index:anIndex Text:theText];
-}
-
-- (void) insertBeforeProgName:(NSString *)programName Index:(NSInteger)rwIndex Text:(NSString *)theText
-{
-    //addToSortedRewriteList(programName, new ANTLRInsertBeforeOp(rwIndex,text));
-    ANTLRRewriteOperation *op = [ANTLRInsertBeforeOp newANTLRInsertBeforeOp:rwIndex Text:theText];
-    ANTLRHashMap *rewrites = [self getProgram:programName];
-    op.instructionIndex = [rewrites count];
-    [rewrites addObject:op];
-}
-
-- (void) replaceFromIndex:(NSInteger)anIndex Text:(NSString *)theText
-{
-    [self replaceProgNam:DEFAULT_PROGRAM_NAME FromIndex:anIndex ToIndex:anIndex Text:theText];
-}
-
-- (void) replaceFromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText
-{
-    [self replaceProgNam:DEFAULT_PROGRAM_NAME FromIndex:from ToIndex:to Text:theText];
-}
-
-- (void) replaceFromToken:(id<ANTLRToken>)anIndexT Text:(NSString *)theText
-{
-    [self replaceProgNam:DEFAULT_PROGRAM_NAME FromIndex:[anIndexT getTokenIndex] ToIndex:[anIndexT getTokenIndex] Text:theText];
-}
-
-- (void) replaceFromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to Text:(NSString *)theText
-{
-    [self replaceProgNam:DEFAULT_PROGRAM_NAME FromIndex:[from getTokenIndex] ToIndex:[to getTokenIndex] Text:theText];
-}
-
-- (void) replaceProgNam:(NSString *)programName Token:(id<ANTLRToken>)from Token:(id<ANTLRToken>)to Text:(NSString *)theText
-{
-    [self replaceProgNam:programName FromIndex:[from getTokenIndex] ToIndex:[to getTokenIndex] Text:theText];
-}
-
-- (void) replaceProgNam:(NSString *)programName FromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText
-{
-    if ( from > to || from < 0 || to < 0 || to >= [tokens count] ) {
-        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"replace: range invalid: %d..%d size=%d\n", from, to, [tokens count]]];
-    }
-    ANTLRRewriteOperation *op = [ANTLRReplaceOp newANTLRReplaceOp:from ToIndex:to Text:theText];
-    ANTLRHashMap *rewrites = (ANTLRHashMap *)[lastRewriteTokenIndexes getName:programName];
-    op.instructionIndex = [rewrites count];
-    [rewrites addObject:op];
-}
-
-- (void) delete:(NSInteger)anIndex
-{
-    [self delete:DEFAULT_PROGRAM_NAME  FromIndex:(NSInteger)anIndex  ToIndex:(NSInteger)anIndex];
-}
-
-- (void) delete:(NSInteger)from ToIndex:(NSInteger)to
-{
-    [self delete:DEFAULT_PROGRAM_NAME FromIndex:from ToIndex:to];
-}
-
-- (void) deleteToken:(id<ANTLRToken>)anIndexT
-{
-    [self delete:DEFAULT_PROGRAM_NAME FromIndex:[anIndexT getTokenIndex] ToIndex:[anIndexT getTokenIndex]];
-}
-
-- (void) deleteFromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to
-{
-    [self delete:DEFAULT_PROGRAM_NAME FromIndex:[from getTokenIndex] ToIndex:[to getTokenIndex]];
-}
-
-- (void) delete:(NSString *)programName FromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to
-{
-    [self replaceProgNam:programName FromIndex:[from getTokenIndex] ToIndex:[to getTokenIndex] Text:nil];
-}
-
-- (void) delete:(NSString *)programName FromIndex:(NSInteger)from ToIndex:(NSInteger)to
-{
-    [self replaceProgNam:programName FromIndex:from ToIndex:to Text:nil];
-}
-
-- (NSInteger)getLastRewriteTokenIndex
-{
-    return [self getLastRewriteTokenIndex:DEFAULT_PROGRAM_NAME];
-}
-
-- (NSInteger)getLastRewriteTokenIndex:(NSString *)programName
-{
-#pragma warning fix this to look up the hashed name
-    NSInteger anInt = -1;
-    ANTLRMapElement *node = [lastRewriteTokenIndexes lookup:programName Scope:0];
-    if ( node != nil ) {
-        anInt = [lastRewriteTokenIndexes hash:programName];
-    }
-    return anInt;
-}
-
-- (void)setLastRewriteTokenIndex:(NSString *)programName Index:(NSInteger)anInt
-{
-    [lastRewriteTokenIndexes insertObject:programName atIndex:anInt];
-}
-
--(ANTLRHashMap *) getProgram:(NSString *)name
-{
-   ANTLRHashMap *is = (ANTLRHashMap *)[programs getName:name];
-    if ( is == nil ) {
-        is = [self initializeProgram:name];
-    }
-    return is;
-}
-
--(ANTLRHashMap *) initializeProgram:(NSString *)name
-{
-    ANTLRHashMap *is = [ANTLRHashMap newANTLRHashMapWithLen:PROGRAM_INIT_SIZE];
-    [is putName:name Node:nil];
-    return is;
-}
-
-- (NSString *)toOriginalString
-{
-    [super fill];
-    return [self toOriginalString:MIN_TOKEN_INDEX End:[tokens count]-1];
-}
-
-- (NSString *)toOriginalString:(NSInteger)start End:(NSInteger)end
-{
-    NSMutableString *buf = [NSMutableString stringWithCapacity:100];
-    for (int i = start; i >= MIN_TOKEN_INDEX && i <= end && i< [tokens count]; i++) {
-        if ( [[lastRewriteTokenIndexes objectAtIndex:i] type] != ANTLRTokenTypeEOF )
-            [buf appendString:[[tokens objectAtIndex:i] text]];
-    }
-    return [NSString stringWithString:buf];
-}
-
-- (NSString *)toString
-{
-    [super fill];
-    return [self toStringFromStart:MIN_TOKEN_INDEX ToEnd:[tokens count]-1];
-}
-
-- (NSString *)toString:(NSString *)programName
-{
-    [super fill];
-    return [self toString:programName FromStart:MIN_TOKEN_INDEX ToEnd:[[programs objectAtIndex:MIN_TOKEN_INDEX] count]-1];
-}
-
-- (NSString *)toStringFromStart:(NSInteger)start ToEnd:(NSInteger)end
-{
-    return [self toString:DEFAULT_PROGRAM_NAME FromStart:start ToEnd:end];
-}
-
-- (NSString *)toString:(NSString *)programName FromStart:(NSInteger)start ToEnd:(NSInteger)end
-{
-    ANTLRHashMap *rewrites = (ANTLRHashMap *)[programs getName:programName];
-
-    // ensure start/end are in range
-    if ( end > [tokens count]-1 ) end = [tokens count]-1;
-    if ( start < 0 )
-        start = 0;
-
-    if ( rewrites == nil || [rewrites count] == 0 ) {
-        return [self toOriginalString:start End:end]; // no instructions to execute
-    }
-    NSMutableString *buf = [NSMutableString stringWithCapacity:100];
-
-    // First, optimize instruction stream
-    ANTLRHashMap *indexToOp = [self reduceToSingleOperationPerIndex:rewrites];
-
-    // Walk buffer, executing instructions and emitting tokens
-    int i = start;
-    while ( i <= end && i < [tokens count] ) {
-        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[indexToOp objectAtIndex:i];
-        [indexToOp setObject:nil atIndex:i]; // remove so any left have rwIndex size-1
-        id<ANTLRToken>t = (id<ANTLRToken>) [tokens objectAtIndex:i];
-        if ( op == nil ) {
-            // no operation at that rwIndex, just dump token
-            if ( t.type != ANTLRTokenTypeEOF )
-                [buf appendString:t.text];
-            i++; // move to next token
-        }
-        else {
-            i = [op execute:buf]; // execute operation and skip
-        }
-    }
-
-    // include stuff after end if it's last rwIndex in buffer
-    // So, if they did an insertAfter(lastValidIndex, "foo"), include
-    // foo if end==lastValidIndex.
-    //if ( end == [tokens size]-1 ) {
-    if ( end == [tokens count]-1 ) {
-        // Scan any remaining operations after last token
-        // should be included (they will be inserts).
-        int i2 = 0;
-        while ( i2 < [indexToOp count] - 1 ) {
-            ANTLRRewriteOperation *op = [indexToOp objectAtIndex:i2];
-            if ( op.rwIndex >= [tokens count]-1 ) {
-                [buf appendString:op.text];
-            }
-        }
-    }
-    return [NSString stringWithString:buf];
-}
-
-/** We need to combine operations and report invalid operations (like
- *  overlapping replaces that are not completed nested).  Inserts to
- *  same rwIndex need to be combined etc...   Here are the cases:
- *
- *  I.i.u I.j.v								leave alone, nonoverlapping
- *  I.i.u I.i.v								combine: Iivu
- *
- *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
- *  R.i-j.u R.i-j.v							delete first R
- *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
- *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
- *
- *  I.i.u R.x-y.v | i in x-y				delete I
- *  I.i.u R.x-y.v | i not in x-y			leave alone, nonoverlapping
- *  R.x-y.v I.i.u | i in x-y				ERROR
- *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
- *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
- *
- *  I.i.u = insert u before op @ rwIndex i
- *  R.x-y.u = replace x-y indexed tokens with u
- *
- *  First we need to examine replaces.  For any replace op:
- *
- * 		1. wipe out any insertions before op within that range.
- *		2. Drop any replace op before that is contained completely within
- *         that range.
- *		3. Throw exception upon boundary overlap with any previous replace.
- *
- *  Then we can deal with inserts:
- *
- * 		1. for any inserts to same rwIndex, combine even if not adjacent.
- * 		2. for any prior replace with same left boundary, combine this
- *         insert with replace and delete this replace.
- * 		3. throw exception if rwIndex in same range as previous replace
- *
- *  Don't actually delete; make op null in list. Easier to walk list.
- *  Later we can throw as we add to rwIndex -> op map.
- *
- *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
- *  inserted stuff would be before the replace range.  But, if you
- *  add tokens in front of a method body '{' and then delete the method
- *  body, I think the stuff before the '{' you added should disappear too.
- *
- *  Return a map from token rwIndex to operation.
- */
-- (ANTLRHashMap *)reduceToSingleOperationPerIndex:(ANTLRHashMap *)rewrites
-{
-    //System.out.println("rewrites="+rewrites);
-    if (debug > 1) NSLog(@"rewrites=%@\n", [rewrites getName:DEFAULT_PROGRAM_NAME]);
-    // WALK REPLACES
-    for (int i = 0; i < [rewrites count]; i++) {
-        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
-        if ( op==nil )
-            continue;
-        if ( !([[op class] isKindOfClass:[ANTLRReplaceOp class]]) )
-            continue;
-        ANTLRReplaceOp *rop = (ANTLRReplaceOp *)[rewrites objectAtIndex:i];
-        // Wipe prior inserts within range
-        //List inserts = getKindOfOps(rewrites, ANTLRInsertBeforeOp.class, i);
-        ANTLRHashMap *inserts = [self getKindOfOps:rewrites KindOfClass:[ANTLRInsertBeforeOp class] Index:i];
-        for (int j = 0; j < [inserts size]; j++) {
-            ANTLRInsertBeforeOp *iop = (ANTLRInsertBeforeOp *)[inserts objectAtIndex:j];
-            if ( iop.rwIndex >= rop.rwIndex && iop.rwIndex <= rop.lastIndex ) {
-                // delete insert as it's a no-op.
-                [rewrites insertObject:nil atIndex:iop.instructionIndex];
-            }
-        }
-        // Drop any prior replaces contained within
-        ANTLRHashMap *prevReplaces = [self getKindOfOps:rewrites KindOfClass:[ANTLRReplaceOp class] Index:i];
-        for (int j = 0; j < [prevReplaces count]; j++) {
-            ANTLRReplaceOp *prevRop = (ANTLRReplaceOp *) [prevReplaces objectAtIndex:j];
-            if ( prevRop.rwIndex>=rop.rwIndex && prevRop.lastIndex <= rop.lastIndex ) {
-                // delete replace as it's a no-op.
-                [rewrites setObject:nil atIndex:prevRop.instructionIndex];
-                continue;
-            }
-            // throw exception unless disjoint or identical
-            BOOL disjoint = prevRop.lastIndex<rop.rwIndex || prevRop.rwIndex > rop.lastIndex;
-            BOOL same = prevRop.rwIndex==rop.rwIndex && prevRop.lastIndex==rop.lastIndex;
-            if ( !disjoint && !same ) {
-                @throw [ANTLRIllegalArgumentException newException:
-                        [NSString stringWithFormat:@"replace op boundaries of %@, overlap with previous %@\n", rop, prevRop]];
-            }
-        }
-    }
-
-    // WALK INSERTS
-    for (int i = 0; i < [rewrites count]; i++) {
-        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
-        if ( op == nil )
-            continue;
-        if ( !([[op class] isKindOfClass:[ANTLRInsertBeforeOp class]]) )
-            continue;
-        ANTLRInsertBeforeOp *iop = (ANTLRInsertBeforeOp *)[rewrites objectAtIndex:i];
-        // combine current insert with prior if any at same rwIndex
-        ANTLRHashMap *prevInserts = (ANTLRHashMap *)[self getKindOfOps:rewrites KindOfClass:[ANTLRInsertBeforeOp class] Index:i];
-        for (int j = 0; j < [prevInserts count]; j++) {
-            ANTLRInsertBeforeOp *prevIop = (ANTLRInsertBeforeOp *) [prevInserts objectAtIndex:j];
-            if ( prevIop.rwIndex == iop.rwIndex ) { // combine objects
-                                                // convert to strings...we're in process of toString'ing
-                                                // whole token buffer so no lazy eval issue with any templates
-                iop.text = [self catOpText:iop.text PrevText:prevIop.text];
-                // delete redundant prior insert
-                [rewrites setObject:nil atIndex:prevIop.instructionIndex];
-            }
-        }
-        // look for replaces where iop.rwIndex is in range; error
-        ANTLRHashMap *prevReplaces = (ANTLRHashMap *)[self getKindOfOps:rewrites KindOfClass:[ANTLRReplaceOp class] Index:i];
-        for (int j = 0; j < [prevReplaces count]; j++) {
-            ANTLRReplaceOp *rop = (ANTLRReplaceOp *) [prevReplaces objectAtIndex:j];
-            if ( iop.rwIndex == rop.rwIndex ) {
-                rop.text = [self catOpText:iop.text PrevText:rop.text];
-                [rewrites setObject:nil atIndex:i];  // delete current insert
-                continue;
-            }
-            if ( iop.rwIndex >= rop.rwIndex && iop.rwIndex <= rop.lastIndex ) {
-                @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"insert op %d within boundaries of previous %d", iop, rop]];
-            }
-        }
-    }
-    // System.out.println("rewrites after="+rewrites);
-    ANTLRHashMap *m = [ANTLRHashMap newANTLRHashMapWithLen:15];
-    for (int i = 0; i < [rewrites count]; i++) {
-        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
-        if ( op == nil )
-            continue; // ignore deleted ops
-        if ( [m objectAtIndex:op.rwIndex] != nil ) {
-            @throw [ANTLRRuntimeException newException:@"should only be one op per rwIndex\n"];
-        }
-        //[m put(new Integer(op.rwIndex), op);
-        [m setObject:op atIndex:op.rwIndex];
-    }
-    //System.out.println("rwIndex to op: "+m);
-    if (debug > 1) NSLog(@"rwIndex to  op %d\n", (NSInteger)m);
-    return m;
-}
-
-- (NSString *)catOpText:(id)a PrevText:(id)b
-{
-    NSString *x = @"";
-    NSString *y = @"";
-    if ( a != nil )
-        x = [a toString];
-    if ( b != nil )
-        y = [b toString];
-    return [NSString stringWithFormat:@"%@%@",x, y];
-}
-
-- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind
-{
-    return [self getKindOfOps:rewrites KindOfClass:kind Index:[rewrites count]];
-}
-
-/** Get all operations before an rwIndex of a particular kind */
-- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind Index:(NSInteger)before
-{
-    ANTLRHashMap *ops = [ANTLRHashMap newANTLRHashMapWithLen:15];
-    for (int i = 0; i < before && i < [rewrites count]; i++) {
-        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
-        if ( op == nil )
-            continue; // ignore deleted
-        if ( [op isKindOfClass:(Class)kind] )
-            [ops addObject:op];
-    }
-    return ops;
-}
-
-- (NSMutableString *)toDebugString
-{
-    return [self toDebugStringFromStart:MIN_TOKEN_INDEX ToEnd:[tokens count]-1];
-}
-
-- (NSMutableString *)toDebugStringFromStart:(NSInteger)start ToEnd:(NSInteger)end
-{
-    NSMutableString *buf = [NSMutableString stringWithCapacity:100];
-    for (int i = start; i >= MIN_TOKEN_INDEX && i <= end && i < [tokens count]; i++) {
-        [buf appendString:[[tokens objectAtIndex:i] text]];
-    }
-    return [NSString stringWithString:buf];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTokenSource.h b/runtime/ObjC/Framework/ANTLRTokenSource.h
deleted file mode 100644
index ca1fa2b..0000000
--- a/runtime/ObjC/Framework/ANTLRTokenSource.h
+++ /dev/null
@@ -1,38 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRToken.h"
-
-// Anything that responds to -nextToken can be treated as a lexer.
-// For instance this can be a flex lexer or a handwritten one or even
-// a proxy for a remotely running token source (database, lexer, whatever).
-@protocol ANTLRTokenSource <NSObject, NSCopying>
-
-- (id<ANTLRToken>) nextToken;
-- (NSString *)getSourceName;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTokenStream.h b/runtime/ObjC/Framework/ANTLRTokenStream.h
deleted file mode 100644
index c104578..0000000
--- a/runtime/ObjC/Framework/ANTLRTokenStream.h
+++ /dev/null
@@ -1,62 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRIntStream.h"
-#import "ANTLRToken.h"
-
-@protocol ANTLRTokenStream < ANTLRIntStream >
-
-// Get Token at current input pointer + i ahead where i=1 is next Token.
-// i<0 indicates tokens in the past.  So -1 is previous token and -2 is
-// two tokens ago. LT:0 is undefined.  For i>=n, return Token.EOFToken.
-// Return null for LT:0 and any index that results in an absolute address
-// that is negative.
-
-- (id<ANTLRToken>) LT:(NSInteger) i;
-
-- (id<ANTLRToken>) getToken:(NSUInteger) i;
-
-- (id) getTokenSource;
-
-- (NSString *) toString;
-/** Return the text of all tokens from start to stop, inclusive.
- *  If the stream does not buffer all the tokens then it can just
- *  return "" or null;  Users should not access $ruleLabel.text in
- *  an action of course in that case.
- */
-- (NSString *)toStringFromStart:(NSInteger)startIdx ToEnd:(NSInteger)stopIdx;
-
-/** Because the user is not required to use a token with an index stored
- *  in it, we must provide a means for two token objects themselves to
- *  indicate the start/end location.  Most often this will just delegate
- *  to the other toString(int,int).  This is also parallel with
- *  the TreeNodeStream.toString(Object,Object).
- */
-- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken;
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTree.h b/runtime/ObjC/Framework/ANTLRTree.h
deleted file mode 100644
index 32f603a..0000000
--- a/runtime/ObjC/Framework/ANTLRTree.h
+++ /dev/null
@@ -1,129 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#ifndef DEBUG_DEALLOC
-#define DEBUG_DEALLOC
-#endif
-
-#import "AMutableArray.h"
-
-@protocol ANTLRTree < NSObject, NSCopying >
-
-//+ (id<ANTLRTree>) invalidNode;
-
-- (id<ANTLRTree>) getChild:(NSUInteger)index;
-- (NSUInteger) getChildCount;
-
-// Tree tracks parent and child index now > 3.0
-
-- (id<ANTLRTree>)getParent;
-
-- (void) setParent:(id<ANTLRTree>)t;
-
-/** Is there is a node above with token type ttype? */
-- (BOOL) hasAncestor:(NSInteger)ttype;
-
-/** Walk upwards and get first ancestor with this token type. */
-- (id<ANTLRTree>) getAncestor:(NSInteger) ttype;
-
-/** Return a list of all ancestors of this node.  The first node of
- *  list is the root and the last is the parent of this node.
- */
-- (AMutableArray *) getAncestors;
-
-/** This node is what child index? 0..n-1 */
-- (NSInteger) getChildIndex;
-
-- (void) setChildIndex:(NSInteger) index;
-
-/** Set the parent and child index values for all children */
-- (void) freshenParentAndChildIndexes;
-
-/** Add t as a child to this node.  If t is null, do nothing.  If t
- *  is nil, add all children of t to this' children.
- */
-- (void) addChild:(id<ANTLRTree>) t;
-
-/** Set ith child (0..n-1) to t; t must be non-null and non-nil node */
-- (void) setChild:(NSInteger)i With:(id<ANTLRTree>) t;
-
-- (id) deleteChild:(NSInteger) i;
-
-/** Delete children from start to stop and replace with t even if t is
- *  a list (nil-root tree).  num of children can increase or decrease.
- *  For huge child lists, inserting children can force walking rest of
- *  children to set their childindex; could be slow.
- */
-- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t;
-
-- (NSArray *) children;
-// Add t as a child to this node.  If t is null, do nothing.  If t
-//  is nil, add all children of t to this' children.
-
-- (void) addChildren:(NSArray *) theChildren;
-//- (void) removeAllChildren;
-
-// Indicates the node is a nil node but may still have children, meaning
-// the tree is a flat list.
-
-- (BOOL) isNil;
-
-/**  What is the smallest token index (indexing from 0) for this node
- *   and its children?
- */
-- (NSInteger) getTokenStartIndex;
-
-- (void) setTokenStartIndex:(NSInteger) index;
-
-/**  What is the largest token index (indexing from 0) for this node
- *   and its children?
- */
-- (NSInteger) getTokenStopIndex;
-- (void) setTokenStopIndex:(NSInteger) index;
-
-- (id<ANTLRTree>) dupNode;
-
-- (NSString *) toString;
-
-#pragma mark Copying
-- (id) copyWithZone:(NSZone *)aZone;	// the children themselves are not copied here!
-- (id) deepCopy;					// performs a deepCopyWithZone: with the default zone
-- (id) deepCopyWithZone:(NSZone *)aZone;
-
-#pragma mark Tree Parser support
-- (NSInteger)type;
-- (NSString *)text;
-// In case we don't have a token payload, what is the line for errors?
-- (NSUInteger)line;
-- (NSUInteger)charPositionInLine;
-- (void) setCharPositionInLine:(NSUInteger)pos;
-
-#pragma mark Informational
-- (NSString *) treeDescription;
-- (NSString *) description;
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRTree.m b/runtime/ObjC/Framework/ANTLRTree.m
deleted file mode 100644
index 4d9edaa..0000000
--- a/runtime/ObjC/Framework/ANTLRTree.m
+++ /dev/null
@@ -1,149 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTree.h"
-#import "ANTLRToken.h"
-// TODO: this shouldn't be here...but needed for invalidNode
-#import "ANTLRCommonTree.h"
-
-@implementation ANTLRTree
-
-@synthesize isEmpty;
-@synthesize isEmptyNode;
-@synthesize invalidNode;
-@synthesize children;
-
-#pragma mark ANTLRTree protocol conformance
-
-+ (id<ANTLRTree>) invalidNode
-{
-	static id<ANTLRTree> invalidNode = nil;
-	if (!invalidNode) {
-		invalidNode = [[ANTLRCommonTree alloc] initWithTokenType:ANTLRTokenTypeInvalid];
-	}
-	return invalidNode;
-}
-
-- (id<ANTLRTree>) init
-{
-	self = [super init];
-	if ( self != nil ) {
-		isEmptyNode = NO;
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-	[super dealloc];
-}
-
-- (id<ANTLRTree>) getChild:(NSUInteger) index
-{
-	return nil;
-}
-
-- (NSUInteger) getChildCount
-{
-	return 0;
-}
-
-- (NSArray *) getChildren
-{
-	return nil;
-}
-
-	// Add tree as a child to this node.  If tree is nil, do nothing.  If tree
-	// is an empty node, add all children of tree to our children.
-
-- (void) addChild:(id<ANTLRTree>) tree
-{
-}
-
-- (void) addChildren:(NSArray *) theChildren
-{
-}
-
-- (void) removeAllChildren
-{
-}
-
-	// Indicates the node is an empty node but may still have children, meaning
-	// the tree is a flat list.
-
-- (BOOL) isEmpty
-{
-	return isEmptyNode;
-}
-
-- (void) setIsEmpty:(BOOL)emptyFlag
-{
-	isEmptyNode = emptyFlag;
-}
-
-#pragma mark ANTLRTree abstract base class
-
-	// Return a token type; needed for tree parsing
-- (NSInteger) getType
-{
-	return 0;
-}
-
-- (NSString *) getText
-{
-	return [self description];
-}
-
-	// In case we don't have a token payload, what is the line for errors?
-- (NSInteger) getLine
-{
-	return 0;
-}
-
-- (NSInteger) getCharPositionInLine
-{
-	return 0;
-}
-
-- (NSString *) treeDescription
-{
-	return @"";
-}
-
-- (NSString *) description
-{
-	return @"";
-}
-
-- (void) _createChildrenList
-{
-	if ( children == nil )
-		children = [[NSMutableArray alloc] init];
-}
-
-@end
-
-@end
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/ANTLRTreeAdaptor.h b/runtime/ObjC/Framework/ANTLRTreeAdaptor.h
deleted file mode 100644
index e0d94e0..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeAdaptor.h
+++ /dev/null
@@ -1,157 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRToken.h"
-#import "ANTLRBaseTree.h"
-#import "ANTLRTokenStream.h"
-
-#pragma warning tree/node diction is broken.
-
-@protocol ANTLRTreeAdaptor <NSObject, NSCopying>
-
-#pragma mark Construction
-
-#pragma mark ANTLRTreeAdaptor implementation
-- (id)dupNode:(id)aNode;	// copies just the node
-- (id)dupTree:(id)aTree;	// copies the entire subtree, recursively
-
-/** Return a nil node (an empty but non-null node) that can hold
- *  a list of element as the children.  If you want a flat tree (a list)
- *  use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
- */
-- (id) emptyNode;
-
-/** Return a tree node representing an error.  This node records the
- *  tokens consumed during error recovery.  The start token indicates the
- *  input symbol at which the error was detected.  The stop token indicates
- *  the last symbol consumed during recovery.
- *
- *  You must specify the input stream so that the erroneous text can
- *  be packaged up in the error node.  The exception could be useful
- *  to some applications; default implementation stores ptr to it in
- *  the CommonErrorNode.
- *
- *  This only makes sense during token parsing, not tree parsing.
- *  Tree parsing should happen only when parsing and tree construction
- *  succeed.
- */
-- (id) errorNode:(id<ANTLRTokenStream>)anInput
-            From:(id<ANTLRToken>)aStartToken
-              To:(id<ANTLRToken>)aStopToken
-       Exception:(NSException *) e;
-
-/** Is tree considered a nil node used to make lists of child nodes? */
-- (BOOL) isNil:(id)aTree;
-
-
-- (void) addChild:(id)child toTree:(id)aTree;
-
-/** If oldRoot is a nil root, just copy or move the children to newRoot.
- *  If not a nil root, make oldRoot a child of newRoot.
- *
- *    old=^(nil a b c), new=r yields ^(r a b c)
- *    old=^(a b c), new=r yields ^(r ^(a b c))
- *
- *  If newRoot is a nil-rooted single child tree, use the single
- *  child as the new root node.
- *
- *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
- *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
- *
- *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
- *
- *    old=null, new=r yields r
- *    old=null, new=^(nil r) yields ^(nil r)
- *
- *  Return newRoot.  Throw an exception if newRoot is not a
- *  simple node or nil root with a single child node--it must be a root
- *  node.  If newRoot is ^(nil x) return x as newRoot.
- *
- *  Be advised that it's ok for newRoot to point at oldRoot's
- *  children; i.e., you don't have to copy the list.  We are
- *  constructing these nodes so we should have this control for
- *  efficiency.
- */
-- (id) becomeRoot:(id)newRoot old:(id)oldRoot;
-
-- (id) rulePostProcessing:(id)root;
-
-#pragma mark Rewrite Rules
-
-- (NSUInteger) getUniqueID:(id)aNode;
-
-- (id) create:(id<ANTLRToken>)payload;
-- (id) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken;
-- (id) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text;
-- (id) createTree:(NSInteger)tokenType Text:(NSString *)text;
-
-#pragma mark Content
-
-- (id)dupNode:(id)aNode;
-- (id)dupTree:(id)aTree;
-
-- (NSInteger) getType:(id)aNode;
-- (void) setType:(id)aNode Type:(NSInteger)tokenType;
-
-- (NSString *) getText:(id)aNode;
-- (void) setText:(id)aNode Text:(NSString *)tokenText;
-
-//- (id<ANTLRToken>) getToken:(id)t;
-
-- (void) setTokenBoundaries:(id)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
-- (NSInteger) getTokenStartIndex:(id)aTree;
-- (NSInteger) getTokenStopIndex:(id)aTree;
-
-#pragma mark Navigation / Tree Parsing
-
-/** Get a child 0..n-1 node */
-- (id) getChild:(id)aNode At:(NSInteger) i;
-/** Set ith child (0..n-1) to t; t must be non-null and non-nil node */
-- (void) setChild:(id)aTree At:(NSInteger)index Child:(id)child;
-/** Remove ith child and shift children down from right. */
-- (id) deleteChild:(id)t Index:(NSInteger)index;
-
-/** How many children?  If 0, then this is a leaf node */
-- (NSInteger) getChildCount:(id) aTree;
-
-/** Who is the parent node of this node; if null, implies node is root.
- *  If your node type doesn't handle this, it's ok but the tree rewrites
- *  in tree parsers need this functionality.
- */
-- (id)getParent:(id)t;
-- (void) setParent:(id)t With:(id)parent;
-
-/** What index is this node in the child list? Range: 0..n-1
- *  If your node type doesn't handle this, it's ok but the tree rewrites
- *  in tree parsers need this functionality.
- */
-- (NSInteger) getChildIndex:(id)t;
-- (void) setChildIndex:(id)t With:(NSInteger)index;
-
-- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t;
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRTreeAdaptor.m b/runtime/ObjC/Framework/ANTLRTreeAdaptor.m
deleted file mode 100644
index ce64b13..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeAdaptor.m
+++ /dev/null
@@ -1,238 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreeAdaptor.h"
-#import "ANTLRTreeException.h"
-#import "ANTLRBaseTree.h"
-
-@implementation ANTLRTreeAdaptor
-
-
-+ (id<ANTLRBaseTree>) newEmptyTree
-{
-	return [ANTLRTreeAdaptor newTreeWithToken:nil];
-}
-
-+ (id) newAdaptor
-{
-    return [[ANTLRTreeAdaptor alloc] init];
-}
-
-- (id) init
-{
-    self = [super init];
-    return self;
-}
-
-- (id) initWithPayload:(id<ANTLRToken>)payload
-{
-    self = [super init];
-    return self;
-}
-
-#pragma mark Rewrite Rules
-
-/** Create a tree node from Token object; for CommonTree type trees,
- *  then the token just becomes the payload.  This is the most
- *  common create call.
- *
- *  Override if you want another kind of node to be built.
- */
-- (id<ANTLRBaseTree>) create:(id<ANTLRToken>) payload
-{
-    return nil;
-}
-
-/** Create a new node derived from a token, with a new token type.
- *  This is invoked from an imaginary node ref on right side of a
- *  rewrite rule as IMAG[$tokenLabel].
- *
- *  This should invoke createToken(Token).
- */
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType fromToken:(id<ANTLRToken>)fromToken
-{
-	id<ANTLRToken> newToken = [self createToken:fromToken];
-	[newToken setType:tokenType];
-
-	id<ANTLRBaseTree> newTree = [self create:newToken];
-	[newToken release];
-	return newTree;
-}
-
-/** Create a new node derived from a token, with a new token type.
- *  This is invoked from an imaginary node ref on right side of a
- *  rewrite rule as IMAG[$tokenLabel].
- *
- *  This should invoke createToken(Token).
- */
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType fromToken:(id<ANTLRToken>)fromToken text:(NSString *)tokenText
-{
-	id<ANTLRToken> newToken = [self createToken:fromToken];
-	[newToken setText:tokenText];
-
-	id<ANTLRBaseTree> newTree = [self create:newToken];
-	[newToken release];
-	return newTree;
-}
-
-/** Create a new node derived from a token, with a new token type.
- *  This is invoked from an imaginary node ref on right side of a
- *  rewrite rule as IMAG["IMAG"].
- *
- *  This should invoke createToken(int,String).
- */
-- (id<ANTLRBaseTree>) createTree:(NSInteger)tokenType text:(NSString *)tokenText
-{
-	id<ANTLRToken> newToken = [self createToken:tokenType text:tokenText];
-
-	id<ANTLRBaseTree> newTree = [self create:newToken];
-	[newToken release];
-	return newTree;
-}
-
-- (id) copyNode:(id<ANTLRBaseTree>)aNode
-{
-	return [aNode copyWithZone:nil];	// not -copy: to silence warnings
-}
-
-- (id) copyTree:(id<ANTLRBaseTree>)aTree
-{
-	return [aTree deepCopy];
-}
-
-
-- (void) addChild:(id<ANTLRBaseTree>)child toTree:(id<ANTLRBaseTree>)aTree
-{
-	[aTree addChild:child];
-}
-
-- (id) makeNode:(id<ANTLRBaseTree>)newRoot parentOf:(id<ANTLRBaseTree>)oldRoot
-{
-	id<ANTLRBaseTree> newRootNode = newRoot;
-
-	if (oldRoot == nil)
-		return newRootNode;
-    // handles ^(nil real-node) case
-	if ([newRootNode isNil]) {
-		if ([newRootNode getChildCount] > 1) {
-#warning TODO: Find a way to the current input stream here!
-			@throw [ANTLRTreeException exceptionWithOldRoot:oldRoot newRoot:newRootNode stream:nil];
-		}
-#warning TODO: double check memory management with respect to code generation
-		// remove the empty node, placing its sole child in its role.
-		id<ANTLRBaseTree> tmpRootNode = [[newRootNode childAtIndex:0] retain];
-		[newRootNode release];
-		newRootNode = tmpRootNode;
-	}
-	// the handling of an empty node at the root of oldRoot happens in addChild:
-	[newRootNode addChild:oldRoot];
-    // this release relies on the fact that the ANTLR code generator always assigns the return value of this method
-    // to the variable originally holding oldRoot. If we don't release we leak the reference.
-    // FIXME: this is totally non-obvious. maybe do it in calling code by comparing pointers and conditionally releasing
-    // the old object
-    [oldRoot release];
-
-    // what happens to newRootNode's retain count? Should we be autoreleasing this one? Probably.
-	return [newRootNode retain];
-}
-
-
-- (id<ANTLRBaseTree>) postProcessTree:(id<ANTLRBaseTree>)aTree
-{
-	id<ANTLRBaseTree> processedNode = aTree;
-	if (aTree != nil && [aTree isNil] != NO && [aTree getChildCount] == 1) {
-		processedNode = [aTree childAtIndex:0];
-	}
-	return processedNode;
-}
-
-
-- (NSUInteger) uniqueIdForTree:(id<ANTLRBaseTree>)aNode
-{
-	// TODO: is hash appropriate here?
-	return [aNode hash];
-}
-
-
-#pragma mark Content
-
-- (NSInteger) tokenTypeForNode:(id<ANTLRBaseTree>)aNode
-{
-	return [aNode getType];
-}
-
-- (void) setTokenType:(NSInteger)tokenType forNode:(id)aNode
-{
-	// currently unimplemented
-}
-
-
-- (NSString *) textForNode:(id<ANTLRBaseTree>)aNode
-{
-	return [aNode getText];
-}
-
-- (void) setText:(NSString *)tokenText forNode:(id<ANTLRBaseTree>)aNode
-{
-	// currently unimplemented
-}
-
-
-#pragma mark Navigation / Tree Parsing
-
-- (id<ANTLRBaseTree>) childForNode:(id<ANTLRBaseTree>) aNode atIndex:(NSInteger) i
-{
-	// currently unimplemented
-	return nil;
-}
-
-- (NSInteger) childCountForTree:(id<ANTLRBaseTree>) aTree
-{
-	// currently unimplemented
-	return 0;
-}
-
-#pragma mark Subclass Responsibilties
-
-- (void) setBoundariesForTree:(id<ANTLRBaseTree>)aTree fromToken:(id<ANTLRToken>)startToken toToken:(id<ANTLRToken>)stopToken
-{
-	// subclass responsibility
-}
-
-- (NSInteger) tokenStartIndexForTree:(id<ANTLRBaseTree>)aTree
-{
-	// subclass responsibility
-	return 0;
-}
-
-- (NSInteger) tokenStopIndexForTree:(id<ANTLRBaseTree>)aTree
-{
-	// subclass responsibility
-	return 0;
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeException.h b/runtime/ObjC/Framework/ANTLRTreeException.h
deleted file mode 100644
index 28330af..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeException.h
+++ /dev/null
@@ -1,42 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTree.h"
-#import "ANTLRRecognitionException.h"
-
-@interface ANTLRTreeException : ANTLRRecognitionException {
-	id<ANTLRBaseTree> oldRoot;
-	id<ANTLRBaseTree> newRoot;
-}
-
-+ (id) newException:(id<ANTLRBaseTree>)theOldRoot newRoot:(id<ANTLRBaseTree>)theNewRoot stream:(id<ANTLRIntStream>)aStream;
-- (id) initWithOldRoot:(id<ANTLRBaseTree>)theOldRoot newRoot:(id<ANTLRBaseTree>)theNewRoot stream:(id<ANTLRIntStream>)aStream;
-
-- (void) setOldRoot:(id<ANTLRBaseTree>)aTree;
-- (void) setNewRoot:(id<ANTLRBaseTree>)aTree;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeException.m b/runtime/ObjC/Framework/ANTLRTreeException.m
deleted file mode 100644
index b61d29c..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeException.m
+++ /dev/null
@@ -1,85 +0,0 @@
-//
-//  ANTLRTreeException.m
-//  ANTLR
-//
-//  Created by Kay Röpke on 24.10.2006.
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRTreeException.h"
-
-
-@implementation ANTLRTreeException
-
-+ (id) newException:(id<ANTLRBaseTree>)theOldRoot newRoot:(id<ANTLRBaseTree>)theNewRoot stream:(id<ANTLRIntStream>)aStream;
-{
-	return [[ANTLRTreeException alloc] initWithOldRoot:theOldRoot newRoot:theNewRoot stream:aStream];
-}
-
-- (id) initWithOldRoot:(id<ANTLRBaseTree>)theOldRoot newRoot:(id<ANTLRBaseTree>)theNewRoot stream:(id<ANTLRIntStream>)aStream;
-{
-	if ((self = [super initWithStream:aStream reason:@"The new root has more than one child. Cannot make it the root node."]) != nil ) {
-		[self setOldRoot:theOldRoot];
-		[self setNewRoot:theNewRoot];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreeException" );
-#endif
-	[self setOldRoot:nil];
-	[self setNewRoot:nil];
-	[super dealloc];
-}
-
-- (void) setNewRoot:(id<ANTLRBaseTree>)aTree
-{
-	if (newRoot != aTree) {
-		[aTree retain];
-		if ( newRoot ) [newRoot release];
-		newRoot = aTree;
-	}
-}
-
-- (void) setOldRoot:(id<ANTLRBaseTree>)aTree
-{
-	if (oldRoot != aTree) {
-		[aTree retain];
-		if ( oldRoot ) [oldRoot release];
-		oldRoot = aTree;
-	}
-}
-
-- (NSString *) description
-{
-	 return [NSMutableString stringWithFormat:@"%@ old root: <%@> new root: <%@>", [super description], [oldRoot treeDescription], [newRoot treeDescription]];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeIterator.h b/runtime/ObjC/Framework/ANTLRTreeIterator.h
deleted file mode 100644
index b5cf8c3..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeIterator.h
+++ /dev/null
@@ -1,72 +0,0 @@
-//
-//  ANTLRTreeIterator.h
-//  ANTLR
-//
-//  Created by Ian Michell on 26/04/2010.
-// [The "BSD licence"]
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRCommonTreeAdaptor.h"
-#import "ANTLRFastQueue.h"
-#import "ANTLRTreeAdaptor.h"
-#import "ANTLRTree.h"
-
-@interface ANTLRTreeIterator : NSObject
-{
-	BOOL firstTime;
-	__strong id<ANTLRTreeAdaptor> adaptor;
-	__strong id<ANTLRBaseTree> root;
-	__strong id<ANTLRBaseTree> tree;
-
-	__strong ANTLRFastQueue *nodes;
-	__strong id<ANTLRBaseTree> up;
-	__strong id<ANTLRBaseTree> down;
-	__strong id<ANTLRBaseTree> eof;
-}
-
-@property BOOL firstTime;
-@property(retain) id<ANTLRTreeAdaptor> adaptor;
-@property(retain) id<ANTLRBaseTree> root;
-@property(retain) id<ANTLRBaseTree> tree;
-@property(retain) ANTLRFastQueue *nodes;
-@property(retain, readwrite) id<ANTLRBaseTree> up;
-@property(retain, readwrite) id<ANTLRBaseTree> down;
-@property(retain, readwrite) id<ANTLRBaseTree> eof;
-
-+ newANTRLTreeIterator;
-+ (ANTLRTreeIterator *) newANTRLTreeIteratorWithAdaptor:(ANTLRCommonTreeAdaptor *)adaptor
-                                                andTree:(id<ANTLRBaseTree>)tree;
-- (id) init;
-- (id) initWithTree:(id<ANTLRBaseTree>) t;
-- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>) a andTree:(id<ANTLRBaseTree>) t;
-
-- (void) reset;
-- (BOOL) hasNext;
-- (id) nextObject;
-- (NSArray *) allObjects;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeIterator.m b/runtime/ObjC/Framework/ANTLRTreeIterator.m
deleted file mode 100644
index b760f88..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeIterator.m
+++ /dev/null
@@ -1,202 +0,0 @@
-//
-//  ANTLRTreeIterator.m
-//  ANTLR
-//
-//  Created by Ian Michell on 26/04/2010.
-// Copyright (c) 2010 Ian Michell 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRTreeIterator.h"
-#import "ANTLRCommonTreeAdaptor.h"
-
-@implementation ANTLRTreeIterator
-
-+ (ANTLRTreeIterator *) newANTRLTreeIterator
-{
-    return [[ANTLRTreeIterator alloc] init];
-}
-
-+ (ANTLRTreeIterator *) newANTRLTreeIteratorWithAdaptor:(ANTLRCommonTreeAdaptor *)adaptor
-                                                andTree:(id<ANTLRBaseTree>)tree
-{
-    return [[ANTLRTreeIterator alloc] initWithTreeAdaptor:adaptor andTree:tree];
-}
-
-- (id) init
-{
-    self = [super init];
-    if ( self != nil ) {
-        firstTime = YES;
-        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
-        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-        tree = eof;
-        root = eof;
-    }
-    return self;
-}
-
--(id) initWithTree:(id<ANTLRBaseTree>) t
-{
-    self = [super init];
-    if ( self != nil ) {
-        firstTime = YES;
-        adaptor = [[ANTLRCommonTreeAdaptor newTreeAdaptor] retain];
-        tree = [t retain];
-        root = t;
-        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
-        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-    }
-    return self;
-}
-
--(id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)a andTree:(id<ANTLRBaseTree>)t
-{
-    self = [super init];
-    if ( self != nil ) {
-        firstTime = YES;
-        adaptor = [a retain];
-        tree = [t retain];
-        root = t;
-        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
-        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
-        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
-        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
-    }
-    return self;
-}
-
-- (void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreeIterator" );
-#endif
-    if ( adaptor ) [adaptor release];
-    if ( nodes ) [nodes release];
-    if ( tree && tree != eof ) [tree release];
-    if ( root && root != eof && root != tree ) [root release];
-    if ( down ) [down release];
-    if ( up ) [up release];
-    if ( eof ) [eof release];
-    [super dealloc];
-}
-
-- (void)reset
-{
-    firstTime = YES;
-    tree = root;
-    [nodes clear];
-}
-
--(BOOL) hasNext
-{
-    if ( firstTime ) {
-        return root != nil;
-    }
-    if ( nodes && [nodes size] > 0) {
-        return YES;
-    }
-    if ( tree == nil ) {
-        return NO;
-    }
-    if ( [adaptor getChildCount:tree] > 0 ) {
-        return YES;
-    }
-    return [adaptor getParent:tree] != nil;
-}
-
--(id) nextObject
-{
-    // is this the first time we are using this method?
-    if ( firstTime ) {
-        firstTime = NO;
-        if ( [adaptor getChildCount:tree] == 0 ) {
-            [nodes addObject:eof];
-            return tree;
-        }
-        return tree;
-    }
-    // do we have any objects queued up?
-    if ( nodes && [nodes size] > 0 ) {
-        return [nodes remove];
-    }
-    // no nodes left?
-    if ( tree == nil ) {
-        return eof;
-    }
-    if ( [adaptor getChildCount:tree] > 0 ) {
-        tree = [adaptor getChild:tree At:0];
-        [nodes addObject:tree]; // real node is next after down
-        return self.down;
-    }
-    // if no children, look for next sibling of ancestor
-    id<ANTLRBaseTree> parent = [adaptor getParent:tree];
-    while (parent != nil && ([adaptor getChildIndex:tree] + 1) >= [adaptor getChildCount:parent]) {
-        [nodes addObject:up];
-        tree = parent;
-        parent = [adaptor getParent:tree];
-    }
-    if ( parent == nil ) {
-        tree = nil;
-        [nodes addObject:self.eof];
-        return [nodes remove];
-    }
-    // must have found a node with an unvisited sibling
-    // move to it and return it
-    NSInteger nextSiblingIndex = [adaptor getChildIndex:tree] + 1;
-    tree = [adaptor getChild:parent At:nextSiblingIndex];
-    [nodes addObject:tree];
-    return [nodes remove];
-}
-
--(NSArray *) allObjects
-{
-    AMutableArray *array = [AMutableArray arrayWithCapacity:10];
-    while ( [self hasNext] ) {
-        [array addObject:[self nextObject]];
-    }
-    return array;
-}
-
-- (void)remove
-{
-    @throw [ANTLRRuntimeException newException:@"ANTLRUnsupportedOperationException"];
-}
-
-@synthesize firstTime;
-@synthesize adaptor;
-@synthesize root;
-@synthesize tree;
-@synthesize nodes;
-
-@synthesize up;
-@synthesize down;
-@synthesize eof;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeNodeStream.h b/runtime/ObjC/Framework/ANTLRTreeNodeStream.h
deleted file mode 100644
index 8d10aaa..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeNodeStream.h
+++ /dev/null
@@ -1,52 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRIntStream.h"
-#import "ANTLRCharStream.h"
-#import "ANTLRTokenStream.h"
-#import "ANTLRCommonTree.h"
-#import "ANTLRCommonTreeAdaptor.h"
-
-@protocol ANTLRTreeNodeStream < ANTLRIntStream >
-
-- (id) initWithTree:(ANTLRCommonTree *)theTree;
-
-- (id) getTree:(NSInteger) idx;
-- (id) LT:(NSInteger)k;
-- (id) getTreeSource;
-- (id<ANTLRTokenStream>) getTokenStream;
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void) setUniqueNavigationNodes:(BOOL)flag;
-- (void) reset;
-
-- (NSString *) toStringFromNode:(id)startNode ToNode:(id)stopNode;
-
-- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeParser.h b/runtime/ObjC/Framework/ANTLRTreeParser.h
deleted file mode 100644
index 9d2d5c6..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeParser.h
+++ /dev/null
@@ -1,87 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRBaseRecognizer.h"
-#import "ANTLRTreeNodeStream.h"
-#import "ANTLRCommonTreeAdaptor.h"
-#import "ANTLRMismatchedTreeNodeException.h"
-
-@interface ANTLRTreeParser : ANTLRBaseRecognizer {
-	id<ANTLRTreeNodeStream> input;
-}
-
-@property (retain, getter=input, setter=setInput:) id<ANTLRTreeNodeStream> input;
-
-+ (id) newANTLRTreeParser:(id<ANTLRTreeNodeStream>)anInput;
-+ (id) newANTLRTreeParser:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)state;
-
-- (id) initWithStream:(id<ANTLRTreeNodeStream>)theInput;
-- (id) initWithStream:(id<ANTLRTreeNodeStream>)theInput
-                State:(ANTLRRecognizerSharedState *)state;
-
-
-- (id<ANTLRTreeNodeStream>)input;
-- (void) setInput:(id<ANTLRTreeNodeStream>)anInput;
-
-- (void) setTreeNodeStream:(id<ANTLRTreeNodeStream>) anInput;
-- (id<ANTLRTreeNodeStream>) getTreeNodeStream;
-
-- (NSString *)getSourceName;
-
-- (id) getCurrentInputSymbol:(id<ANTLRIntStream>) anInput;
-
-- (id) getMissingSymbol:(id<ANTLRIntStream>)input
-              Exception:(ANTLRRecognitionException *) e
-          ExpectedToken:(NSInteger) expectedTokenType
-                 BitSet:(ANTLRBitSet *)follow;
-
-/** Match '.' in tree parser has special meaning.  Skip node or
- *  entire tree if node has children.  If children, scan until
- *  corresponding UP node.
- */
-- (void) matchAny:(id<ANTLRIntStream>)ignore;
-
-/** We have DOWN/UP nodes in the stream that have no line info; override.
- *  plus we want to alter the exception type.  Don't try to recover
- *  from tree parser errors inline...
- */
-- (id) recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput
-                             Type:(NSInteger)ttype
-                           Follow:(ANTLRBitSet *)follow;
-
-/** Prefix error message with the grammar name because message is
- *  always intended for the programmer because the parser built
- *  the input tree not the user.
- */
-- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e;
-
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *) tokenNames;
-
-- (void) traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex;
-- (void) traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeParser.m b/runtime/ObjC/Framework/ANTLRTreeParser.m
deleted file mode 100644
index 599ec7c..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeParser.m
+++ /dev/null
@@ -1,192 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreeParser.h"
-
-@implementation ANTLRTreeParser
-
-@synthesize input;
-
-+ (id) newANTLRTreeParser:(id<ANTLRTreeNodeStream>)anInput
-{
-    return [[ANTLRTreeParser alloc] initWithStream:anInput];
-}
-
-+ (id) newANTLRTreeParser:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)theState
-{
-    return [[ANTLRTreeParser alloc] initWithStream:anInput State:theState];
-}
-
-- (id) initWithStream:(id<ANTLRTreeNodeStream>)theInput
-{
-	if ((self = [super init]) != nil) {
-		[self setInput:theInput];
-	}
-	return self;
-}
-
-- (id) initWithStream:(id<ANTLRTreeNodeStream>)theInput State:(ANTLRRecognizerSharedState *)theState
-{
-	if ((self = [super init]) != nil) {
-		[self setInput:theInput];
-        state = theState;
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreeParser" );
-#endif
-	if ( input ) [input release];
-	[super dealloc];
-}
-
-- (void) reset
-{
-    [super reset]; // reset all recognizer state variables
-    if ( input != nil ) {
-        [input seek:0]; // rewind the input
-    }
-}
-
-- (void) mismatch:(id<ANTLRIntStream>)aStream tokenType:(ANTLRTokenType)aTType follow:(ANTLRBitSet *)aBitset
-{
-	ANTLRMismatchedTreeNodeException *mte = [ANTLRMismatchedTreeNodeException newException:aTType Stream:aStream];
-    [mte setNode:[((id<ANTLRTreeNodeStream>)aStream) LT:1]];
-	[self recoverFromMismatchedToken:aStream Type:aTType Follow:aBitset];
-}
-
-- (void) setTreeNodeStream:(id<ANTLRTreeNodeStream>) anInput
-{
-    input = anInput;
-}
-
-- (id<ANTLRTreeNodeStream>) getTreeNodeStream
-{
-    return input;
-}
-
-- (NSString *)getSourceName
-{
-    return [input getSourceName];
-}
-
-- (id) getCurrentInputSymbol:(id<ANTLRIntStream>) anInput
-{
-    return [(id<ANTLRTreeNodeStream>)anInput LT:1];
-}
-
-- (id) getMissingSymbol:(id<ANTLRIntStream>)anInput
-              Exception:(ANTLRRecognitionException *)e
-          ExpectedToken:(NSInteger)expectedTokenType
-                 BitSet:(ANTLRBitSet *)follow
-{
-    NSString *tokenText =[NSString stringWithFormat:@"<missing %@ %d>", [self getTokenNames], expectedTokenType];
-    //id<ANTLRTreeAdaptor> anAdaptor = (id<ANTLRTreeAdaptor>)[((id<ANTLRTreeNodeStream>)e.input) getTreeAdaptor];
-    //return [anAdaptor createToken:expectedTokenType Text:tokenText];
-    return [ANTLRCommonToken newToken:expectedTokenType Text:tokenText];
-}
-
-/** Match '.' in tree parser has special meaning.  Skip node or
- *  entire tree if node has children.  If children, scan until
- *  corresponding UP node.
- */
-- (void) matchAny:(id<ANTLRIntStream>)ignore
-{ // ignore stream, copy of input
-    state.errorRecovery = NO;
-    state.failed = NO;
-    id look = [input LT:1];
-    if ( [((ANTLRCommonTreeAdaptor *)[input getTreeAdaptor]) getChildCount:look] == 0) {
-        [input consume]; // not subtree, consume 1 node and return
-        return;
-    }
-    // current node is a subtree, skip to corresponding UP.
-    // must count nesting level to get right UP
-    int level=0;
-    int tokenType = [((id<ANTLRTreeAdaptor>)[input getTreeAdaptor]) getType:look];
-    while ( tokenType != ANTLRTokenTypeEOF && !( tokenType == ANTLRTokenTypeUP && level == 0) ) {
-        [input consume];
-        look = [input LT:1];
-        tokenType = [((id<ANTLRTreeAdaptor>)[input getTreeAdaptor]) getType:look];
-        if ( tokenType == ANTLRTokenTypeDOWN ) {
-            level++;
-        }
-        else if ( tokenType == ANTLRTokenTypeUP ) {
-            level--;
-        }
-    }
-    [input consume]; // consume UP
-}
-
-/** We have DOWN/UP nodes in the stream that have no line info; override.
- *  plus we want to alter the exception type.  Don't try to recover
- *  from tree parser errors inline...
- */
-- (id) recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput Type:(NSInteger)ttype Follow:(ANTLRBitSet *)follow
-{
-    @throw [ANTLRMismatchedTreeNodeException newException:ttype Stream:anInput];
-}
-
-/** Prefix error message with the grammar name because message is
- *  always intended for the programmer because the parser built
- *  the input tree not the user.
- */
-- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e
-{
-     return [NSString stringWithFormat:@"%@: node after line %@:%@",
-            [self getGrammarFileName], e.line, e.charPositionInLine];
-}
-
-/** Tree parsers parse nodes they usually have a token object as
- *  payload. Set the exception token and do the default behavior.
- */
-- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e  TokenNames:(AMutableArray *) theTokNams
-{
-    if ( [self isKindOfClass:[ANTLRTreeParser class]] ) {
-        ANTLRCommonTreeAdaptor *adaptor = (ANTLRCommonTreeAdaptor *)[((id<ANTLRTreeNodeStream>)e.input) getTreeAdaptor];
-        e.token = [adaptor getToken:((id<ANTLRBaseTree>)e.node)];
-        if ( e.token == nil ) { // could be an UP/DOWN node
-            e.token = [ANTLRCommonToken newToken:[adaptor getType:e.node]
-                                                        Text:[adaptor getText:e.node]];
-        }
-    }
-    return [super getErrorMessage:e TokenNames:theTokNams];
-}
-
-- (void) traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex
-{
-    [super traceIn:ruleName Index:ruleIndex Object:[input LT:1]];
-}
-
-- (void) traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex
-{
-    [super traceOut:ruleName Index:ruleIndex  Object:[input LT:1]];
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreePatternLexer.h b/runtime/ObjC/Framework/ANTLRTreePatternLexer.h
deleted file mode 100644
index 430bc83..0000000
--- a/runtime/ObjC/Framework/ANTLRTreePatternLexer.h
+++ /dev/null
@@ -1,89 +0,0 @@
-//
-//  ANTLRTreePatternLexer.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-
-typedef enum {
-	ANTLRLexerTokenTypeEOF = -1,
-	ANTLRLexerTokenTypeInvalid,
-	ANTLRLexerTokenTypeBEGIN,
-	ANTLRLexerTokenTypeEND,
-	ANTLRLexerTokenTypeID,
-	ANTLRLexerTokenTypeARG,
-	ANTLRLexerTokenTypePERCENT,
-	ANTLRLexerTokenTypeCOLON,
-	ANTLRLexerTokenTypeDOT,
-} ANTLRLexerTokenType;
-
-
-@interface ANTLRTreePatternLexer : NSObject {
-
-/** The tree pattern to lex like "(A B C)" */
-NSString *pattern;
-
-/** Index into input string */
-NSInteger p;
-
-/** Current char */
-NSInteger c;
-
-/** How long is the pattern in char? */
-NSInteger n;
-
-/** Set when token type is ID or ARG (name mimics Java's StreamTokenizer) */
-NSMutableData *sval;
-__strong char *data;
-
-BOOL error;
-
-}
-
-@property (retain) NSString *pattern;
-@property (assign) NSInteger p;
-@property (assign) NSInteger c;
-@property (assign) NSInteger n;
-@property (retain, getter=getSval, setter=setSval:) NSMutableData *sval;
-@property (assign) char *data;
-@property (assign) BOOL error;
-
-+ (ANTLRTreePatternLexer *)newANTLRTreePatternLexer:(NSString *)aPattern;
-- (id) init;
-- (id) initWithPattern:(NSString *)aPattern;
-
-- (void) dealloc;
-- (NSInteger) nextToken;
-- (void) consume;
-- (NSString *)toString;
-
-- (NSMutableData *)getSval;
-- (void) setSval:(NSMutableData *)aSval;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreePatternLexer.m b/runtime/ObjC/Framework/ANTLRTreePatternLexer.m
deleted file mode 100644
index cdf969f..0000000
--- a/runtime/ObjC/Framework/ANTLRTreePatternLexer.m
+++ /dev/null
@@ -1,191 +0,0 @@
-//
-//  ANTLRTreePatternLexer.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreePatternLexer.h"
-
-@implementation ANTLRTreePatternLexer
-
-@synthesize pattern;
-@synthesize p;
-@synthesize c;
-@synthesize n;
-@synthesize sval;
-@synthesize data;
-@synthesize error;
-
-+ (ANTLRTreePatternLexer *)newANTLRTreePatternLexer:(NSString *)aPattern
-{
-    return [[ANTLRTreePatternLexer alloc] initWithPattern:aPattern];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil ) {
-        p = -1;
-        n = 0;
-        error = NO;
-        sval = [[NSMutableData dataWithLength:1000] retain];
-        data = [sval mutableBytes];
-        pattern = @"";
-        n = [pattern length];
-        if ( pattern ) [pattern retain];
-        [self consume];
-    }
-    return self;
-}
-
-- (id) initWithPattern:(NSString *)aPattern
-{
-    if ((self = [super init]) != nil ) {
-        p = -1;
-        n = 0;
-        error = NO;
-        sval = [[NSMutableData dataWithLength:1000] retain];
-        data = [sval mutableBytes];
-        pattern = [aPattern retain];
-        n = [pattern length];
-        [self consume];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreePatternLexer" );
-#endif
-	if ( pattern ) [pattern release];
-	if ( sval ) [sval release];
-	[super dealloc];
-}
-
-- (NSInteger) nextToken
-{
-    n = 0; // reset, but reuse buffer
-    while ( c != ANTLRLexerTokenTypeEOF ) {
-        if ( c==' ' || c=='\n' || c=='\r' || c=='\t' ) {
-            [self consume];
-            continue;
-        }
-        if ( (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='_' ) {
-            data[n++] = (char)c;
-            [self consume];
-            while ( (c>='a' && c<='z') || (c>='A' && c<='Z') ||
-                   (c>='0' && c<='9') || c=='_' )
-            {
-                data[n++] = (char)c;
-                [self consume];
-            }
-            return ANTLRLexerTokenTypeID;
-        }
-        if ( c == '(' ) {
-            [self consume];
-            return ANTLRLexerTokenTypeBEGIN;
-        }
-        if ( c==')' ) {
-            [self consume];
-            return ANTLRLexerTokenTypeEND;
-        }
-        if ( c=='%' ) {
-            [self consume];
-            return ANTLRLexerTokenTypePERCENT;
-        }
-        if ( c==':' ) {
-            [self consume];
-            return ANTLRLexerTokenTypeCOLON;
-        }
-        if ( c=='.' ) {
-            [self consume];
-            return ANTLRLexerTokenTypeDOT;
-        }
-        if ( c=='[' ) { // grab [x] as a string, returning x
-            [self consume];
-            while ( c!=']' ) {
-                if ( c=='\\' ) {
-                    [self consume];
-                    if ( c!=']' ) {
-                        data[n++] = (char)'\\';
-                    }
-                    data[n++] = (char)c;
-                }
-                else {
-                    data[n++] = (char)c;
-                }
-                [self consume];
-            }
-            [self consume];
-            return ANTLRLexerTokenTypeARG;
-        }
-        [self consume];
-        error = true;
-        return ANTLRLexerTokenTypeEOF;
-    }
-    return ANTLRLexerTokenTypeEOF;
-}
-
-- (void) consume
-{
-    p++;
-    if ( p >= n ) {
-        c = ANTLRLexerTokenTypeEOF;
-    }
-    else {
-        c = [pattern characterAtIndex:p];
-    }
-}
-
-- (NSString *)toString
-{
-    char buf[100];
-
-    NSInteger idx = 0;
-    for( NSInteger i = p; i < n; i++ ){
-        buf[idx++] = data[i];
-    }
-    buf[idx] = '\0';
-    return [NSString stringWithFormat:@"%s", buf];
-}
-
-- (NSMutableData *)getSval
-{
-    return sval;
-}
-
-- (void)setSval:(NSMutableData *)aSval
-{
-    if ( sval != aSval ) {
-        if ( sval ) [sval release];
-        [aSval retain];
-    }
-    sval = aSval;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreePatternParser.h b/runtime/ObjC/Framework/ANTLRTreePatternParser.h
deleted file mode 100644
index 2051b5e..0000000
--- a/runtime/ObjC/Framework/ANTLRTreePatternParser.h
+++ /dev/null
@@ -1,63 +0,0 @@
-//
-//  ANTLRTreePatternParser.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTreePatternLexer.h"
-#import "ANTLRTreeWizard.h"
-#import "ANTLRTreeAdaptor.h"
-
-@interface ANTLRTreePatternParser : NSObject {
-
-ANTLRTreePatternLexer *tokenizer;
-NSInteger ttype;
-ANTLRTreeWizard *wizard;
-id<ANTLRTreeAdaptor> adaptor;
-
-}
-
-+ (ANTLRTreePatternParser *)newANTLRTreePatternParser:(ANTLRTreePatternLexer *)aTokenizer
-                                               Wizard:(ANTLRTreeWizard *)aWizard
-                                              Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
-- (id) init;
-- (id) initWithTokenizer:(ANTLRTreePatternLexer *)tokenizer
-                  Wizard:(ANTLRTreeWizard *)aWizard
-                 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
-
-- (void) dealloc;
-- (id<ANTLRBaseTree>) pattern;
-- (id<ANTLRBaseTree>) parseTree;
-- (id<ANTLRBaseTree>) parseNode;
-
-@property (retain) ANTLRTreePatternLexer *tokenizer;
-@property NSInteger ttype;
-@property (retain) ANTLRTreeWizard *wizard;
-@property (retain) id<ANTLRTreeAdaptor> adaptor;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreePatternParser.m b/runtime/ObjC/Framework/ANTLRTreePatternParser.m
deleted file mode 100644
index c95d995..0000000
--- a/runtime/ObjC/Framework/ANTLRTreePatternParser.m
+++ /dev/null
@@ -1,197 +0,0 @@
-//
-//  ANTLRTreePatternParser.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreePatternParser.h"
-#import "ANTLRTreePatternLexer.h"
-
-@implementation ANTLRTreePatternParser
-
-+ (ANTLRTreePatternParser *)newANTLRTreePatternParser:(ANTLRTreePatternLexer *)aTokenizer
-                                               Wizard:(ANTLRTreeWizard *)aWizard
-                                              Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    return [[ANTLRTreePatternParser alloc] initWithTokenizer:aTokenizer Wizard:aWizard Adaptor:anAdaptor];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil) {
-        //tokenizer = aTokenizer;
-        //wizard = aWizard;
-        //adaptor = anAdaptor;
-        //ttype = [tokenizer nextToken]; // kickstart
-    }
-    return self;
-}
-
-- (id) initWithTokenizer:(ANTLRTreePatternLexer *)aTokenizer
-                  Wizard:(ANTLRTreeWizard *)aWizard
-                 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    if ((self = [super init]) != nil) {
-        adaptor = anAdaptor;
-        if ( adaptor ) [adaptor retain];
-        tokenizer = aTokenizer;
-        if ( tokenizer ) [tokenizer retain];
-        wizard = aWizard;
-        if ( wizard ) [wizard retain];
-        ttype = [aTokenizer nextToken]; // kickstart
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreePatternParser" );
-#endif
-	if ( adaptor ) [adaptor release];
-	if ( tokenizer ) [tokenizer release];
-	if ( wizard ) [wizard release];
-	[super dealloc];
-}
-
-- (id<ANTLRBaseTree>)pattern
-{
-    if ( ttype==ANTLRLexerTokenTypeBEGIN ) {
-        return [self parseTree];
-    }
-    else if ( ttype==ANTLRLexerTokenTypeID ) {
-        id<ANTLRBaseTree> node = [self parseNode];
-        if ( ttype==ANTLRLexerTokenTypeEOF ) {
-            return node;
-        }
-        return nil; // extra junk on end
-    }
-    return nil;
-}
-
-- (id<ANTLRBaseTree>) parseTree
-{
-    if ( ttype != ANTLRLexerTokenTypeBEGIN ) {
-        @throw [ANTLRRuntimeException newException:@"no BEGIN"];
-    }
-    ttype = [tokenizer nextToken];
-    id<ANTLRBaseTree> root = [self parseNode];
-    if ( root==nil ) {
-        return nil;
-    }
-    while ( ttype==ANTLRLexerTokenTypeBEGIN  ||
-           ttype==ANTLRLexerTokenTypeID      ||
-           ttype==ANTLRLexerTokenTypePERCENT ||
-           ttype==ANTLRLexerTokenTypeDOT )
-    {
-        if ( ttype==ANTLRLexerTokenTypeBEGIN ) {
-            id<ANTLRBaseTree> subtree = [self parseTree];
-            [adaptor addChild:subtree toTree:root];
-        }
-        else {
-            id<ANTLRBaseTree> child = [self parseNode];
-            if ( child == nil ) {
-                return nil;
-            }
-            [adaptor addChild:child toTree:root];
-        }
-    }
-    if ( ttype != ANTLRLexerTokenTypeEND ) {
-        @throw [ANTLRRuntimeException newException:@"no END"];
-    }
-    ttype = [tokenizer nextToken];
-    return root;
-}
-
-- (id<ANTLRBaseTree>) parseNode
-{
-    // "%label:" prefix
-    NSString *label = nil;
-    ANTLRTreePattern *node;
-    if ( ttype == ANTLRLexerTokenTypePERCENT ) {
-        ttype = [tokenizer nextToken];
-        if ( ttype != ANTLRLexerTokenTypeID ) {
-            return nil;
-        }
-        label = [tokenizer toString];
-        ttype = [tokenizer nextToken];
-        if ( ttype != ANTLRLexerTokenTypeCOLON ) {
-            return nil;
-        }
-        ttype = [tokenizer nextToken]; // move to ID following colon
-    }
-
-    // Wildcard?
-    if ( ttype == ANTLRLexerTokenTypeDOT ) {
-        ttype = [tokenizer nextToken];
-        id<ANTLRToken> wildcardPayload = [ANTLRCommonToken newToken:0 Text:@"."];
-        node = [ANTLRWildcardTreePattern newANTLRWildcardTreePattern:wildcardPayload];
-        if ( label != nil ) {
-            node.label = label;
-        }
-        return node;
-    }
-
-    // "ID" or "ID[arg]"
-    if ( ttype != ANTLRLexerTokenTypeID ) {
-        return nil;
-    }
-    NSString *tokenName = [tokenizer toString];
-    ttype = [tokenizer nextToken];
-    if ( [tokenName isEqualToString:@"nil"] ) {
-        return [adaptor emptyNode];
-    }
-    NSString *text = tokenName;
-    // check for arg
-    NSString *arg = nil;
-    if ( ttype == ANTLRLexerTokenTypeARG ) {
-        arg = [tokenizer toString];
-        text = arg;
-        ttype = [tokenizer nextToken];
-    }
-
-    // create node
-    int treeNodeType = [wizard getTokenType:tokenName];
-    if ( treeNodeType==ANTLRTokenTypeInvalid ) {
-        return nil;
-    }
-    node = [adaptor createTree:treeNodeType Text:text];
-    if ( label!=nil && [node class] == [ANTLRTreePattern class] ) {
-        ((ANTLRTreePattern *)node).label = label;
-    }
-    if ( arg!=nil && [node class] == [ANTLRTreePattern class] ) {
-        ((ANTLRTreePattern *)node).hasTextArg = YES;
-    }
-    return node;
-}
-
-@synthesize tokenizer;
-@synthesize ttype;
-@synthesize wizard;
-@synthesize adaptor;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeRewriter.h b/runtime/ObjC/Framework/ANTLRTreeRewriter.h
deleted file mode 100644
index 5ab5700..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeRewriter.h
+++ /dev/null
@@ -1,78 +0,0 @@
-//
-//  ANTLRTreeRewriter.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/17/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTreeParser.h"
-
-@interface ANTLRfptr : NSObject {
-    id  actor;
-    SEL ruleSEL;
-}
-
-+ (ANTLRfptr *)newANTLRfptrWithRule:(SEL)aRuleAction withObject:(id)anObject;
--initWithRule:(SEL)ruleAction withObject:(id)anObject;
-
-- (id)rule;
-
-@property (retain) id  actor;
-@property SEL ruleSEL;
-@end
-
-@interface ANTLRTreeRewriter : ANTLRTreeParser {
-    BOOL showTransformations;
-    id<ANTLRTokenStream> originalTokenStream;
-    id<ANTLRTreeAdaptor> originalAdaptor;
-    ANTLRfptr *rule;
-    ANTLRfptr *topdown_fptr;
-    ANTLRfptr *bottomup_ftpr;
-}
-
-+ (ANTLRTreeRewriter *) newANTLRTreeRewriter:(id<ANTLRTreeNodeStream>)anInput;
-+ (ANTLRTreeRewriter *) newANTLRTreeRewriter:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)aState;
-- (id)initWithStream:(id<ANTLRTreeNodeStream>)anInput;
-- (id)initWithStream:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)aState;
-- (id) applyOnce:(ANTLRCommonTree *)t Rule:(ANTLRfptr *)whichRule;
-- (id) applyRepeatedly:(ANTLRCommonTree *)t Rule:(ANTLRfptr *)whichRule;
-- (id) downup:(ANTLRCommonTree *)t;
-- (id) pre:(ANTLRCommonTree *)t;
-- (id) post:(ANTLRCommonTree *)t;
-- (id) downup:(ANTLRCommonTree *)t XForm:(BOOL)aShowTransformations;
-- (void)reportTransformation:(ANTLRCommonTree *)oldTree Tree:(ANTLRCommonTree *)newTree;
-- (id) topdown_fptr;
-- (id) bottomup_ftpr;
-- (id) topdown;
-- (id) bottomup;
-
-@property BOOL showTransformations;
-@property (retain) id<ANTLRTokenStream> originalTokenStream;
-@property (retain) id<ANTLRTreeAdaptor> originalAdaptor;
-@property (retain) ANTLRfptr *rule;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeRewriter.m b/runtime/ObjC/Framework/ANTLRTreeRewriter.m
deleted file mode 100644
index 8495436..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeRewriter.m
+++ /dev/null
@@ -1,250 +0,0 @@
-//
-//  ANTLRTreeRewriter.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/17/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreeRewriter.h"
-#import "ANTLRCommonTreeNodeStream.h"
-#import "ANTLRTreeRuleReturnScope.h"
-#import "ANTLRCommonTreeAdaptor.h"
-#import "ANTLRTreeVisitor.h"
-
-@implementation ANTLRfptr
-
-+ (ANTLRfptr *)newANTLRfptrWithRule:(SEL)aRuleAction withObject:(id)anObject
-{
-    return [[ANTLRfptr alloc] initWithRule:aRuleAction withObject:(id)anObject];
-}
-
--initWithRule:(SEL)aRuleAction withObject:(id)anObject
-{
-    if ((self = [super init]) != nil) {
-        actor = anObject;
-        ruleSEL = aRuleAction;
-    }
-    return self;
-}
-
-- (id)rule
-{
-	if ( [actor respondsToSelector:ruleSEL] )
-		return [actor performSelector:ruleSEL];
-    else
-        @throw [ANTLRRuntimeException newException:@"Unknown Rewrite exception"];
-    return nil;
-}
-
-@synthesize actor;
-@synthesize ruleSEL;
-@end
-
-@implementation ANTLRTreeRewriter
-
-+ (ANTLRTreeRewriter *) newANTLRTreeRewriter:(id<ANTLRTreeNodeStream>)anInput
-{
-    return [[ANTLRTreeRewriter alloc] initWithStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedState]];
-}
-
-+ (ANTLRTreeRewriter *) newANTLRTreeRewriter:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)aState
-{
-    return [[ANTLRTreeRewriter alloc] initWithStream:anInput State:aState];
-}
-
-- (id)initWithStream:(id<ANTLRTreeNodeStream>)anInput
-{
-    SEL aRuleSel;
-
-    if ((self = [super initWithStream:anInput]) != nil) {
-        showTransformations = NO;
-        state = [[ANTLRRecognizerSharedState newANTLRRecognizerSharedState] retain];
-        originalAdaptor = [input getTreeAdaptor];
-        if ( originalAdaptor ) [originalAdaptor retain];
-        originalTokenStream = [input getTokenStream];
-        if ( originalTokenStream ) [originalTokenStream retain];
-        aRuleSel = @selector(topdown);
-        topdown_fptr = [ANTLRfptr newANTLRfptrWithRule:(SEL)aRuleSel withObject:self];
-        aRuleSel = @selector(bottomup);
-        bottomup_ftpr = [ANTLRfptr newANTLRfptrWithRule:(SEL)aRuleSel withObject:self];
-    }
-    return self;
-}
-
-- (id)initWithStream:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)aState
-{
-    SEL aRuleSel;
-
-    if ((self = [super initWithStream:anInput]) != nil) {
-        showTransformations = NO;
-        state = aState;
-        if ( state ) [state retain];
-        originalAdaptor = [input getTreeAdaptor];
-        if ( originalAdaptor ) [originalAdaptor retain];
-        originalTokenStream = [input getTokenStream];
-        if ( originalTokenStream ) [originalTokenStream retain];
-        aRuleSel = @selector(topdown);
-        topdown_fptr = [ANTLRfptr newANTLRfptrWithRule:(SEL)aRuleSel withObject:self];
-        aRuleSel = @selector(bottomup);
-        bottomup_ftpr = [ANTLRfptr newANTLRfptrWithRule:(SEL)aRuleSel withObject:self];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreeRewriter" );
-#endif
-	if ( state ) [state release];
-	if ( originalAdaptor ) [originalAdaptor release];
-	if ( originalTokenStream ) [originalTokenStream release];
-	[super dealloc];
-}
-
-- (id) applyOnce:(ANTLRCommonTree *)t Rule:(ANTLRfptr *)whichRule
-{
-    if ( t == nil ) return nil;
-    @try {
-        // share TreeParser object but not parsing-related state
-        state = [ANTLRRecognizerSharedState newANTLRRecognizerSharedState];
-        input = [ANTLRCommonTreeNodeStream newANTLRCommonTreeNodeStream:(ANTLRCommonTreeAdaptor *)originalAdaptor Tree:t];
-        [(ANTLRCommonTreeNodeStream *)input setTokenStream:originalTokenStream];
-        [self setBacktrackingLevel:1];
-        ANTLRTreeRuleReturnScope *r = [(ANTLRfptr *)whichRule rule];
-        [self setBacktrackingLevel:0];
-        if ( [self getFailed] )
-            return t;
-        if ( showTransformations &&
-            r != nil && !(t == r.start) && r.start != nil ) {
-            [self reportTransformation:t Tree:r.start];
-        }
-        if ( r != nil && r.start != nil )
-            return r.start;
-        else
-            return t;
-    }
-    @catch (ANTLRRecognitionException *e) {
-        return t;
-    }
-    return t;
-}
-
-- (id) applyRepeatedly:(ANTLRCommonTree *)t Rule:(ANTLRfptr *)whichRule
-{
-    BOOL treeChanged = true;
-    while ( treeChanged ) {
-        ANTLRTreeRewriter *u = [self applyOnce:t Rule:whichRule];
-        treeChanged = !(t == u);
-        t = u;
-    }
-    return t;
-}
-
-- (id) downup:(ANTLRCommonTree *)t
-{
-    return [self downup:t XForm:NO];
-}
-
-- (id) pre:(ANTLRCommonTree *)t
-{
-    return [self applyOnce:t Rule:topdown_fptr];
-}
-
-- (id)post:(ANTLRCommonTree *)t
-{
-    return [self applyRepeatedly:t Rule:bottomup_ftpr];
-}
-
-#ifdef DONTUSENOMO
-public Object downup(Object t, boolean showTransformations) {
-    this.showTransformations = showTransformations;
-    TreeVisitor v = new TreeVisitor(new CommonTreeAdaptor());
-    TreeVisitorAction actions = new TreeVisitorAction() {
-        public Object pre(Object t)  { return applyOnce(t, topdown_fptr); }
-        public Object post(Object t) { return applyRepeatedly(t, bottomup_ftpr); }
-    };
-    t = v.visit(t, actions);
-    return t;
-}
-#endif
-
-- (id) downup:(ANTLRCommonTree *)t XForm:(BOOL)aShowTransformations
-{
-    showTransformations = aShowTransformations;
-    ANTLRTreeVisitor *v = [ANTLRTreeVisitor newANTLRTreeVisitor:[[originalAdaptor class] newTreeAdaptor]];
-    ANTLRTreeVisitorAction *actions = [ANTLRTreeVisitorAction newANTLRTreeVisitorAction];
-    {
-        //public Object pre(Object t)  { return applyOnce(t, topdown_fptr); }
-        [self pre:t];
-        //public Object post(Object t) { return applyRepeatedly(t, bottomup_ftpr); }
-        [self post:t];
-    };
-    t = [v visit:t Action:actions];
-    return t;
-}
-
-/** Override this if you need transformation tracing to go somewhere
- *  other than stdout or if you're not using Tree-derived trees.
- */
-- (void)reportTransformation:(ANTLRCommonTree *)oldTree Tree:(ANTLRCommonTree *)newTree
-{
-    //System.out.println(((Tree)oldTree).toStringTree()+" -> "+ ((Tree)newTree).toStringTree());
-}
-
-- (id)topdown_fptr
-{
-    return [self topdown];
-}
-
-- (id)bottomup_ftpr
-{
-    return [self bottomup];
-}
-
-// methods the downup strategy uses to do the up and down rules.
-// to override, just define tree grammar rule topdown and turn on
-// filter=true.
-- (id) topdown
-// @throws RecognitionException
-{
-    @throw [ANTLRRecognitionException newException:@"TopDown exception"];
-    return nil;
-}
-
-- (id) bottomup
-//@throws RecognitionException
-{
-    @throw [ANTLRRecognitionException newException:@"BottomUp exception"];
-    return nil;
-}
-
-@synthesize showTransformations;
-@synthesize originalTokenStream;
-@synthesize originalAdaptor;
-@synthesize rule;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeRuleReturnScope.h b/runtime/ObjC/Framework/ANTLRTreeRuleReturnScope.h
deleted file mode 100644
index 9937052..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeRuleReturnScope.h
+++ /dev/null
@@ -1,52 +0,0 @@
-//
-//  ANTLRTreeRuleReturnScope.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/17/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRuleReturnScope.h"
-#import "ANTLRCommonTree.h"
-
-@interface ANTLRTreeRuleReturnScope : ANTLRRuleReturnScope {
-    ANTLRCommonTree *start;
-}
-
-@property (retain, getter=getStart, setter=setStart:) ANTLRCommonTree *start;
-
-/** First node or root node of tree matched for this rule. */
-
-+ (id) newReturnScope;
-- (id) init;
-- (void) dealloc;
-- (ANTLRCommonTree *)getStart;
-- (void)setStart:(ANTLRCommonTree *)aStart;
-
-- (id) copyWithZone:(NSZone *)theZone;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeRuleReturnScope.m b/runtime/ObjC/Framework/ANTLRTreeRuleReturnScope.m
deleted file mode 100644
index 0043314..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeRuleReturnScope.m
+++ /dev/null
@@ -1,81 +0,0 @@
-//
-//  ANTLRTreeRuleReturnScope.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/17/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreeRuleReturnScope.h"
-
-
-@implementation ANTLRTreeRuleReturnScope
-@synthesize start;
-
-+ (id) newReturnScope
-{
-    return [[ANTLRTreeRuleReturnScope alloc] init];
-}
-
-- (id) init
-{
-    self = [super init];
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreeRuleReturnScope" );
-#endif
-	if ( start ) [start release];
-	[super dealloc];
-}
-
-- (ANTLRCommonTree *)getStart
-{
-    return start;
-}
-
-- (void)setStart:(ANTLRCommonTree *)aStart
-{
-    if ( start != aStart ) {
-        if ( start ) [start release];
-        [aStart retain];
-    }
-    start = aStart;
-}
-
-// create a copy, including the text if available
-// the input stream is *not* copied!
-- (id) copyWithZone:(NSZone *)theZone
-{
-    ANTLRTreeRuleReturnScope *copy = [super copyWithZone:theZone];
-    copy.start = start;
-    return copy;
-}
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeVisitor.h b/runtime/ObjC/Framework/ANTLRTreeVisitor.h
deleted file mode 100644
index e8af0d0..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeVisitor.h
+++ /dev/null
@@ -1,47 +0,0 @@
-//
-//  ANTLRTreeVisitor.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTreeAdaptor.h"
-#import "ANTLRTreeVisitorAction.h"
-
-@interface ANTLRTreeVisitor : NSObject {
-   id<ANTLRTreeAdaptor> adaptor;
-}
-+ (ANTLRTreeVisitor *)newANTLRTreeVisitor:(id<ANTLRTreeAdaptor>) anAdaptor;
-+ (ANTLRTreeVisitor *)newANTLRTreeVisitor;
-- (id)init;
-- (id)initWithAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
-- (void) dealloc;
-- (ANTLRTreeVisitor *)visit:(id<ANTLRBaseTree>)t Action:(ANTLRTreeVisitorAction *)action;
-
-@property (retain) id<ANTLRTreeAdaptor> adaptor;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeVisitor.m b/runtime/ObjC/Framework/ANTLRTreeVisitor.m
deleted file mode 100644
index f500d6d..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeVisitor.m
+++ /dev/null
@@ -1,103 +0,0 @@
-//
-//  ANTLRTreeVisitor.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreeVisitor.h"
-#import "ANTLRCommonTreeAdaptor.h"
-
-@implementation ANTLRTreeVisitor
-
-+ (ANTLRTreeVisitor *)newANTLRTreeVisitor:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    return [[ANTLRTreeVisitor alloc] initWithAdaptor:anAdaptor];
-}
-
-+ (ANTLRTreeVisitor *)newANTLRTreeVisitor
-{
-    return [[ANTLRTreeVisitor alloc] init];
-}
-
-
-- (id)init
-{
-    if ((self = [super init]) != nil) {
-        adaptor = [[ANTLRCommonTreeAdaptor newTreeAdaptor] retain];
-    }
-    return self;
-}
-
-- (id)initWithAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    if ((self = [super init]) != nil) {
-        adaptor = [anAdaptor retain];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreeVisitor" );
-#endif
-    if ( adaptor ) [adaptor release];
-    [super dealloc];
-}
-
-/** Visit every node in tree t and trigger an action for each node
- *  before/after having visited all of its children.
- *  Execute both actions even if t has no children.
- *  If a child visit yields a new child, it can update its
- *  parent's child list or just return the new child.  The
- *  child update code works even if the child visit alters its parent
- *  and returns the new tree.
- *
- *  Return result of applying post action to this node.
- */
-- (ANTLRTreeVisitor *)visit:(ANTLRCommonTree *)t Action:(ANTLRTreeVisitorAction *)action
-{
-    // System.out.println("visit "+((Tree)t).toStringTree());
-    BOOL isNil = [adaptor isNil:t];
-    if ( action != nil && !isNil ) {
-        t = [action pre:(ANTLRTreeVisitorAction *)t]; // if rewritten, walk children of new t
-    }
-    for (int i=0; i < [adaptor getChildCount:t]; i++) {
-        ANTLRCommonTree *child = [adaptor getChild:t At:i];
-        ANTLRCommonTree *visitResult = [self visit:child Action:action];
-        ANTLRCommonTree *childAfterVisit = [adaptor getChild:t At:i];
-        if ( visitResult !=  childAfterVisit ) { // result & child differ?
-            [adaptor setChild:t At:i Child:visitResult];
-        }
-    }
-    if ( action != nil && !isNil ) t = [action post:(ANTLRTreeVisitorAction *)t];
-    return t;
-}
-
-@synthesize adaptor;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeVisitorAction.h b/runtime/ObjC/Framework/ANTLRTreeVisitorAction.h
deleted file mode 100644
index c9c0856..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeVisitorAction.h
+++ /dev/null
@@ -1,56 +0,0 @@
-//
-//  ANTLRTreeVisitorAction.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-
-
-@interface ANTLRTreeVisitorAction : NSObject
-{
-
-}
-
-+ (ANTLRTreeVisitorAction *)newANTLRTreeVisitorAction;
-- (id) init;
-
-/** Execute an action before visiting children of t.  Return t or
- *  a rewritten t.  It is up to the visitor to decide what to do
- *  with the return value.  Children of returned value will be
- *  visited if using TreeVisitor.visit().
- */
-- (ANTLRTreeVisitorAction *)pre:(ANTLRTreeVisitorAction *) t;
-
-/** Execute an action after visiting children of t.  Return t or
- *  a rewritten t.  It is up to the visitor to decide what to do
- *  with the return value.
- */
-- (ANTLRTreeVisitorAction *)post:(ANTLRTreeVisitorAction *) t;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeVisitorAction.m b/runtime/ObjC/Framework/ANTLRTreeVisitorAction.m
deleted file mode 100644
index 09a5920..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeVisitorAction.m
+++ /dev/null
@@ -1,69 +0,0 @@
-//
-//  ANTLRTreeVisitorAction.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreeVisitorAction.h"
-
-
-@implementation ANTLRTreeVisitorAction
-
-+ (ANTLRTreeVisitorAction *)newANTLRTreeVisitorAction
-{
-    return [[ANTLRTreeVisitorAction alloc] init];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil ) {
-    }
-    return self;
-}
-
-/** Execute an action before visiting children of t.  Return t or
- *  a rewritten t.  It is up to the visitor to decide what to do
- *  with the return value.  Children of returned value will be
- *  visited if using TreeVisitor.visit().
- */
-- (ANTLRTreeVisitorAction *)pre:(ANTLRTreeVisitorAction *) t
-{
-    return nil;
-}
-
-/** Execute an action after visiting children of t.  Return t or
- *  a rewritten t.  It is up to the visitor to decide what to do
- *  with the return value.
- */
-- (ANTLRTreeVisitorAction *)post:(ANTLRTreeVisitorAction *) t
-{
-    return nil;
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRTreeWizard.h b/runtime/ObjC/Framework/ANTLRTreeWizard.h
deleted file mode 100644
index 7a57c1e..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeWizard.h
+++ /dev/null
@@ -1,136 +0,0 @@
-//
-//  ANTLRTreeWizard.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRCommonTreeAdaptor.h"
-#import "ANTLRCommonTree.h"
-#import "ANTLRMapElement.h"
-#import "ANTLRMap.h"
-#import "AMutableArray.h"
-
-@class ANTLRVisitor;
-
-@protocol ANTLRContextVisitor <NSObject>
-// TODO: should this be called visit or something else?
-- (void) visit:(ANTLRCommonTree *)t Parent:(ANTLRCommonTree *)parent ChildIndex:(NSInteger)childIndex Map:(ANTLRMap *)labels;
-
-@end
-
-@interface ANTLRVisitor : NSObject <ANTLRContextVisitor> {
-    NSInteger action;
-    id actor;
-    id object1;
-    id object2;
-}
-+ (ANTLRVisitor *)newANTLRVisitor:(NSInteger)anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2;
-- (id) initWithAction:(NSInteger)anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2;
-
-- (void) visit:(ANTLRCommonTree *)t;
-- (void) visit:(ANTLRCommonTree *)t Parent:(ANTLRCommonTree *)parent ChildIndex:(NSInteger)childIndex Map:(ANTLRMap *)labels;
-
-@property NSInteger action;
-@property (retain) id actor;
-@property (retain) id object1;
-@property (retain) id object2;
-@end
-
-/** When using %label:TOKENNAME in a tree for parse(), we must
- *  track the label.
- */
-@interface ANTLRTreePattern : ANTLRCommonTree {
-    NSString *label;
-    BOOL      hasTextArg;
-}
-@property (retain, getter=getLabel, setter=setLabel:) NSString *label;
-@property (assign, getter=getHasTextArg, setter=setHasTextArg:) BOOL hasTextArg;
-
-+ (ANTLRCommonTree *)newANTLRTreePattern:(id<ANTLRToken>)payload;
-
-- (id) initWithToken:(id<ANTLRToken>)payload;
-- (NSString *)toString;
-@end
-
-@interface ANTLRWildcardTreePattern : ANTLRTreePattern {
-}
-
-+ (ANTLRWildcardTreePattern *)newANTLRWildcardTreePattern:(id<ANTLRToken>)payload;
-- (id) initWithToken:(id<ANTLRToken>)payload;
-@end
-
-/** This adaptor creates TreePattern objects for use during scan() */
-@interface ANTLRTreePatternTreeAdaptor : ANTLRCommonTreeAdaptor {
-}
-+ (ANTLRTreePatternTreeAdaptor *)newTreeAdaptor;
-- (id) init;
-- (ANTLRCommonTree *)createTreePattern:(id<ANTLRToken>)payload;
-
-@end
-
-@interface ANTLRTreeWizard : NSObject {
-	id<ANTLRTreeAdaptor> adaptor;
-	ANTLRMap *tokenNameToTypeMap;
-}
-+ (ANTLRTreeWizard *) newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)anAdaptor;
-+ (ANTLRTreeWizard *)newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)adaptor Map:(ANTLRMap *)aTokenNameToTypeMap;
-+ (ANTLRTreeWizard *)newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)adaptor TokenNames:(NSArray *)theTokNams;
-+ (ANTLRTreeWizard *)newANTLRTreeWizardWithTokenNames:(NSArray *)theTokNams;
-- (id) init;
-- (id) initWithAdaptor:(id<ANTLRTreeAdaptor>)adaptor;
-- (id) initWithAdaptor:(id<ANTLRTreeAdaptor>)adaptor Map:(ANTLRMap *)tokenNameToTypeMap;
-- (id) initWithTokenNames:(NSArray *)theTokNams;
-- (id) initWithTokenNames:(id<ANTLRTreeAdaptor>)anAdaptor TokenNames:(NSArray *)theTokNams;
-- (void) dealloc;
-- (ANTLRMap *)computeTokenTypes:(NSArray *)theTokNams;
-- (NSInteger)getTokenType:(NSString *)tokenName;
-- (ANTLRMap *)index:(ANTLRCommonTree *)t;
-- (void) _index:(ANTLRCommonTree *)t Map:(ANTLRMap *)m;
-- (AMutableArray *)find:(ANTLRCommonTree *) t Pattern:(NSString *)pattern;
-- (ANTLRTreeWizard *)findFirst:(ANTLRCommonTree *) t Type:(NSInteger)ttype;
-- (ANTLRTreeWizard *)findFirst:(ANTLRCommonTree *) t Pattern:(NSString *)pattern;
-- (void) visit:(ANTLRCommonTree *)t Type:(NSInteger)ttype Visitor:(ANTLRVisitor *)visitor;
-- (void) _visit:(ANTLRCommonTree *)t
-         Parent:(ANTLRCommonTree *)parent
-     ChildIndex:(NSInteger)childIndex
-           Type:(NSInteger)ttype
-        Visitor:(ANTLRVisitor *)visitor;
-- (void)visit:(ANTLRCommonTree *)t Pattern:(NSString *)pattern Visitor:(ANTLRVisitor *)visitor;
-- (BOOL)parse:(ANTLRCommonTree *)t Pattern:(NSString *)pattern Map:(ANTLRMap *)labels;
-- (BOOL) parse:(ANTLRCommonTree *) t Pattern:(NSString *)pattern;
-- (BOOL) _parse:(ANTLRCommonTree *)t1 Pattern:(ANTLRCommonTree *)tpattern Map:(ANTLRMap *)labels;
-- (ANTLRCommonTree *) createTree:(NSString *)pattern;
-- (BOOL)equals:(id)t1 O2:(id)t2 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
-- (BOOL)equals:(id)t1 O2:(id)t2;
-- (BOOL) _equals:(id)t1 O2:(id)t2 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
-
-@property (retain) id<ANTLRTreeAdaptor> adaptor;
-@property (retain) ANTLRMap *tokenNameToTypeMap;
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRTreeWizard.m b/runtime/ObjC/Framework/ANTLRTreeWizard.m
deleted file mode 100644
index 78131a8..0000000
--- a/runtime/ObjC/Framework/ANTLRTreeWizard.m
+++ /dev/null
@@ -1,735 +0,0 @@
-//
-//  ANTLRTreeWizard.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/18/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRTreeWizard.h"
-#import "ANTLRTreePatternLexer.h"
-#import "ANTLRTreePatternParser.h"
-#import "ANTLRIntArray.h"
-
-@implementation ANTLRVisitor
-
-+ (ANTLRVisitor *)newANTLRVisitor:(NSInteger)anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2
-{
-    return [[ANTLRVisitor alloc] initWithAction:anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2];
-}
-
-- (id) initWithAction:(NSInteger)anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2
-{
-    if ((self = [super init]) != nil) {
-        action = anAction;
-        actor = anActor;
-        if ( actor ) [actor retain];
-        object1 = anObject1;
-        if ( object1 ) [object1 retain];
-        object2 = anObject2;
-        if ( object2 ) [object2 retain];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRVisitor" );
-#endif
-    if ( actor ) [actor release];
-    if ( object1 ) [object1 release];
-    if ( object2 ) [object2 release];
-    [super dealloc];
-}
-
-- (void) visit:(ANTLRCommonTree *)t Parent:(ANTLRCommonTree *)parent ChildIndex:(NSInteger)childIndex Map:(ANTLRMap *)labels
-{
-    switch (action) {
-        case 0:
-            [(ANTLRMap *)object2 /* labels */ clear];
-            if ( [(ANTLRTreeWizard *)actor _parse:t Pattern:object1/* tpattern */ Map:object2 /* labels */] ) {
-                [self visit:t Parent:parent ChildIndex:childIndex Map:object2 /* labels */];
-            }
-            break;
-        case 1:
-            if ( [(ANTLRTreeWizard *)actor _parse:t Pattern:object1/* tpattern */ Map:nil] ) {
-                [(AMutableArray *)object2/* subtrees */ addObject:t];
-            }
-            break;
-    }
-    // [self visit:t];
-    return;
-}
-
-- (void) visit:(ANTLRCommonTree *)t
-{
-    [object1 addObject:t];
-    return;
-}
-
-@synthesize action;
-@synthesize actor;
-@synthesize object1;
-@synthesize object2;
-@end
-
-/** When using %label:TOKENNAME in a tree for parse(), we must
- *  track the label.
- */
-@implementation ANTLRTreePattern
-
-@synthesize label;
-@synthesize hasTextArg;
-
-+ (ANTLRCommonTree *)newANTLRTreePattern:(id<ANTLRToken>)payload
-{
-    return (ANTLRCommonTree *)[[ANTLRTreePattern alloc] initWithToken:payload];
-}
-
-- (id) initWithToken:(id<ANTLRToken>)payload
-{
-    self = [super initWithToken:payload];
-    if ( self != nil ) {
-    }
-    return (ANTLRCommonTree *)self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreePattern" );
-#endif
-    if ( label ) [label release];
-    [super dealloc];
-}
-
-- (NSString *)toString
-{
-    if ( label != nil ) {
-        return [NSString stringWithFormat:@"\% %@ : %@", label, [super toString]];
-    }
-    else {
-        return [super toString];
-    }
-}
-
-@end
-
-@implementation ANTLRWildcardTreePattern
-
-+ (ANTLRWildcardTreePattern *)newANTLRWildcardTreePattern:(id<ANTLRToken>)payload
-{
-    return(ANTLRWildcardTreePattern *)[[ANTLRWildcardTreePattern alloc] initWithToken:(id<ANTLRToken>)payload];
-}
-
-- (id) initWithToken:(id<ANTLRToken>)payload
-{
-    self = [super initWithToken:payload];
-    if ( self != nil ) {
-    }
-    return self;
-}
-
-@end
-
-/** This adaptor creates TreePattern objects for use during scan() */
-@implementation ANTLRTreePatternTreeAdaptor
-
-+ (ANTLRTreePatternTreeAdaptor *)newTreeAdaptor
-{
-    return [[ANTLRTreePatternTreeAdaptor alloc] init];
-}
-
-- (id) init
-{
-    self = [super init];
-    if ( self != nil ) {
-    }
-    return self;
-}
-
-- (ANTLRCommonTree *)createTreePattern:(id<ANTLRToken>)payload
-{
-    return (ANTLRCommonTree *)[super create:payload];
-}
-
-@end
-
-@implementation ANTLRTreeWizard
-
-// TODO: build indexes for the wizard
-
-/** During fillBuffer(), we can make a reverse index from a set
- *  of token types of interest to the list of indexes into the
- *  node stream.  This lets us convert a node pointer to a
- *  stream index semi-efficiently for a list of interesting
- *  nodes such as function definition nodes (you'll want to seek
- *  to their bodies for an interpreter).  Also useful for doing
- *  dynamic searches; i.e., go find me all PLUS nodes.
- protected Map tokenTypeToStreamIndexesMap;
-
- ** If tokenTypesToReverseIndex set to INDEX_ALL then indexing
- *  occurs for all token types.
- public static final Set INDEX_ALL = new HashSet();
-
- ** A set of token types user would like to index for faster lookup.
- *  If this is INDEX_ALL, then all token types are tracked.  If nil,
- *  then none are indexed.
- protected Set tokenTypesToReverseIndex = nil;
- */
-
-+ (ANTLRTreeWizard *) newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    return [[ANTLRTreeWizard alloc] initWithAdaptor:anAdaptor];
-}
-
-+ (ANTLRTreeWizard *)newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)anAdaptor Map:(ANTLRMap *)aTokenNameToTypeMap
-{
-    return [[ANTLRTreeWizard alloc] initWithAdaptor:anAdaptor Map:aTokenNameToTypeMap];
-}
-
-+ (ANTLRTreeWizard *)newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)anAdaptor TokenNames:(NSArray *)theTokNams
-{
-    return [[ANTLRTreeWizard alloc] initWithTokenNames:anAdaptor TokenNames:theTokNams];
-}
-
-+ (ANTLRTreeWizard *)newANTLRTreeWizardWithTokenNames:(NSArray *)theTokNams
-{
-    return [[ANTLRTreeWizard alloc] initWithTokenNames:theTokNams];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil) {
-    }
-    return self;
-}
-
-- (id) initWithAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    if ((self = [super init]) != nil) {
-        adaptor = anAdaptor;
-        if ( adaptor ) [adaptor retain];
-    }
-    return self;
-}
-
-- (id) initWithAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor Map:(ANTLRMap *)aTokenNameToTypeMap
-{
-    if ((self = [super init]) != nil) {
-        adaptor = anAdaptor;
-        if ( adaptor ) [adaptor retain];
-        tokenNameToTypeMap = aTokenNameToTypeMap;
-   }
-    return self;
-}
-
-- (id) initWithTokenNames:(NSArray *)theTokNams
-{
-    if ((self = [super init]) != nil) {
-#pragma warning Fix initWithTokenNames.
-        // adaptor = anAdaptor;
-        //tokenNameToTypeMap = aTokenNameToTypeMap;
-        tokenNameToTypeMap = [[self computeTokenTypes:theTokNams] retain];
-    }
-    return self;
-}
-
-- (id) initWithTokenNames:(id<ANTLRTreeAdaptor>)anAdaptor TokenNames:(NSArray *)theTokNams
-{
-    if ((self = [super init]) != nil) {
-        adaptor = anAdaptor;
-        if ( adaptor ) [adaptor retain];
-        // tokenNameToTypeMap = aTokenNameToTypeMap;
-        tokenNameToTypeMap = [[self computeTokenTypes:theTokNams] retain];
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRTreePatternTreeAdaptor" );
-#endif
-    if ( adaptor ) [adaptor release];
-    if ( tokenNameToTypeMap ) [tokenNameToTypeMap release];
-    [super dealloc];
-}
-
-/** Compute a Map<String, Integer> that is an inverted index of
- *  tokenNames (which maps int token types to names).
- */
-- (ANTLRMap *)computeTokenTypes:(NSArray *)theTokNams
-{
-    ANTLRMap *m = [ANTLRMap newANTLRMap];
-    if ( theTokNams == nil ) {
-        return m;
-    }
-    for (int ttype = ANTLRTokenTypeMIN; ttype < [theTokNams count]; ttype++) {
-        NSString *name = (NSString *) [theTokNams objectAtIndex:ttype];
-        [m putName:name TType:ttype];
-    }
-    return m;
-}
-
-/** Using the map of token names to token types, return the type. */
-- (NSInteger)getTokenType:(NSString *)tokenName
-{
-    if ( tokenNameToTypeMap == nil ) {
-        return ANTLRTokenTypeInvalid;
-    }
-    NSInteger aTType = (NSInteger)[tokenNameToTypeMap getTType:tokenName];
-    if ( aTType != -1 ) {
-        return aTType;
-    }
-    return ANTLRTokenTypeInvalid;
-}
-
-/** Walk the entire tree and make a node name to nodes mapping.
- *  For now, use recursion but later nonrecursive version may be
- *  more efficient.  Returns Map<Integer, List> where the List is
- *  of your AST node type.  The Integer is the token type of the node.
- *
- *  TODO: save this index so that find and visit are faster
- */
-- (ANTLRMap *)index:(ANTLRCommonTree *)t
-{
-    ANTLRMap *m = [ANTLRMap newANTLRMap];
-    [self _index:t Map:m];
-    return m;
-}
-
-/** Do the work for index */
-- (void) _index:(ANTLRCommonTree *)t Map:(ANTLRMap *)m
-{
-    if ( t==nil ) {
-        return;
-    }
-#pragma warning Fix _index use of ANTLRMap.
-    NSInteger ttype = [adaptor getType:t];
-    ANTLRMap *elements = (ANTLRMap *)[m getName:ttype];
-    if ( elements == nil ) {
-        elements = [ANTLRMap newANTLRMapWithLen:100];
-        [m putNode:ttype Node:elements];
-    }
-    [elements addObject:t];
-    int n = [adaptor getChildCount:t];
-    for (int i=0; i<n; i++) {
-        ANTLRCommonTree * child = [adaptor getChild:t At:i];
-        [self _index:child Map:m];
-    }
-}
-
-/** Return a List of tree nodes with token type ttype */
-- (AMutableArray *)find:(ANTLRCommonTree *)t Type:(NSInteger)ttype
-{
-#ifdef DONTUSENOMO
-    final List nodes = new ArrayList();
-    visit(t, ttype, new TreeWizard.Visitor() {
-        public void visit(Object t) {
-            [nodes addObject t];
-        }
-    } );
-#endif
-    AMutableArray *nodes = [AMutableArray arrayWithCapacity:100];
-    ANTLRVisitor *contextVisitor = [ANTLRVisitor newANTLRVisitor:3 Actor:self Object:(id)nodes Object:nil];
-    [self visit:t Type:ttype Visitor:contextVisitor];
-    return nodes;
-}
-
-/** Return a List of subtrees matching pattern. */
-- (AMutableArray *)find:(ANTLRCommonTree *)t Pattern:(NSString *)pattern
-{
-    AMutableArray *subtrees = [AMutableArray arrayWithCapacity:100];
-    // Create a TreePattern from the pattern
-    ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
-    ANTLRTreePatternParser *parser = [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer
-                                                                                     Wizard:self
-                                                                                    Adaptor:[ANTLRTreePatternTreeAdaptor newTreeAdaptor]];
-    ANTLRCommonTree *tpattern = (ANTLRCommonTree *)[parser pattern];
-    // don't allow invalid patterns
-    if ( tpattern == nil ||
-        [tpattern isNil] ||
-        [tpattern class] == [ANTLRWildcardTreePattern class] )
-    {
-        return nil;
-    }
-    int rootTokenType = [tpattern type];
-#ifdef DONTUSENOMO
-    visit(t, rootTokenType, new TreeWizard.ContextVisitor() {
-        public void visit(Object t, Object parent, int childIndex, Map labels) {
-            if ( _parse(t, tpattern, null) ) {
-                subtrees.add(t);
-            }
-        }
-    } );
-#endif
-    ANTLRVisitor *contextVisitor = [ANTLRVisitor newANTLRVisitor:1 Actor:self Object:tpattern Object:subtrees];
-    [self visit:t Type:rootTokenType Visitor:contextVisitor];
-    return subtrees;
-}
-
-- (ANTLRTreeWizard *)findFirst:(ANTLRCommonTree *) t Type:(NSInteger)ttype
-{
-    return nil;
-}
-
-- (ANTLRTreeWizard *)findFirst:(ANTLRCommonTree *) t Pattern:(NSString *)pattern
-{
-    return nil;
-}
-
-/** Visit every ttype node in t, invoking the visitor.  This is a quicker
- *  version of the general visit(t, pattern) method.  The labels arg
- *  of the visitor action method is never set (it's nil) since using
- *  a token type rather than a pattern doesn't let us set a label.
- */
-- (void) visit:(ANTLRCommonTree *)t Type:(NSInteger)ttype Visitor:(ANTLRVisitor *)visitor
-{
-    [self _visit:t Parent:nil ChildIndex:0 Type:ttype Visitor:visitor];
-}
-
-/** Do the recursive work for visit */
-- (void) _visit:(ANTLRCommonTree *)t
-         Parent:(ANTLRCommonTree *)parent
-     ChildIndex:(NSInteger)childIndex
-           Type:(NSInteger)ttype
-        Visitor:(ANTLRVisitor *)visitor
-{
-    if ( t == nil ) {
-        return;
-    }
-    if ( [adaptor getType:t] == ttype ) {
-        [visitor visit:t Parent:parent ChildIndex:childIndex Map:nil];
-    }
-    int n = [adaptor getChildCount:t];
-    for (int i=0; i<n; i++) {
-        ANTLRCommonTree * child = [adaptor getChild:t At:i];
-        [self _visit:child Parent:t ChildIndex:i Type:ttype Visitor:visitor];
-    }
-}
-
-/** For all subtrees that match the pattern, execute the visit action.
- *  The implementation uses the root node of the pattern in combination
- *  with visit(t, ttype, visitor) so nil-rooted patterns are not allowed.
- *  Patterns with wildcard roots are also not allowed.
- */
-- (void)visit:(ANTLRCommonTree *)t Pattern:(NSString *)pattern Visitor:(ANTLRVisitor *)visitor
-{
-    // Create a TreePattern from the pattern
-    ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
-    ANTLRTreePatternParser *parser =
-    [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer Wizard:self Adaptor:[ANTLRTreePatternTreeAdaptor newTreeAdaptor]];
-    ANTLRCommonTree *tpattern = [parser pattern];
-    // don't allow invalid patterns
-    if ( tpattern == nil ||
-        [tpattern isNil] ||
-        [tpattern class] == [ANTLRWildcardTreePattern class] )
-    {
-        return;
-    }
-    ANTLRMapElement *labels = [ANTLRMap newANTLRMap]; // reused for each _parse
-    int rootTokenType = [tpattern type];
-#pragma warning This is another one of those screwy nested constructs that I have to figure out
-#ifdef DONTUSENOMO
-    visit(t, rootTokenType, new TreeWizard.ContextVisitor() {
-        public void visit(Object t, Object parent, int childIndex, Map unusedlabels) {
-            // the unusedlabels arg is null as visit on token type doesn't set.
-            labels.clear();
-            if ( _parse(t, tpattern, labels) ) {
-                visitor.visit(t, parent, childIndex, labels);
-            }
-        }
-    });
-#endif
-    ANTLRVisitor *contextVisitor = [ANTLRVisitor newANTLRVisitor:0 Actor:self Object:tpattern Object:labels];
-    [self visit:t Type:rootTokenType Visitor:contextVisitor];
-}
-
-/** Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels
- *  on the various nodes and '.' (dot) as the node/subtree wildcard,
- *  return true if the pattern matches and fill the labels Map with
- *  the labels pointing at the appropriate nodes.  Return false if
- *  the pattern is malformed or the tree does not match.
- *
- *  If a node specifies a text arg in pattern, then that must match
- *  for that node in t.
- *
- *  TODO: what's a better way to indicate bad pattern? Exceptions are a hassle
- */
-- (BOOL)parse:(ANTLRCommonTree *)t Pattern:(NSString *)pattern Map:(ANTLRMap *)labels
-{
-#ifdef DONTUSENOMO
-    TreePatternLexer tokenizer = new TreePatternLexer(pattern);
-    TreePatternParser parser =
-    new TreePatternParser(tokenizer, this, new TreePatternTreeAdaptor());
-    TreePattern tpattern = (TreePattern)parser.pattern();
-    /*
-     System.out.println("t="+((Tree)t).toStringTree());
-     System.out.println("scant="+tpattern.toStringTree());
-     */
-    boolean matched = _parse(t, tpattern, labels);
-    return matched;
-#endif
-    ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
-    ANTLRTreePatternParser *parser = [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer
-                                                                                Wizard:self
-                                                                               Adaptor:[ANTLRTreePatternTreeAdaptor newTreeAdaptor]];
-    ANTLRCommonTree *tpattern = [parser pattern];
-    /*
-     System.out.println("t="+((Tree)t).toStringTree());
-     System.out.println("scant="+tpattern.toStringTree());
-     */
-    //BOOL matched = [self _parse:t Pattern:tpattern Map:labels];
-    //return matched;
-    return [self _parse:t Pattern:tpattern Map:labels];
-}
-
-- (BOOL) parse:(ANTLRCommonTree *)t Pattern:(NSString *)pattern
-{
-    return [self parse:t Pattern:pattern Map:nil];
-}
-
-/** Do the work for parse. Check to see if the t2 pattern fits the
- *  structure and token types in t1.  Check text if the pattern has
- *  text arguments on nodes.  Fill labels map with pointers to nodes
- *  in tree matched against nodes in pattern with labels.
- */
-- (BOOL) _parse:(ANTLRCommonTree *)t1 Pattern:(ANTLRCommonTree *)aTPattern Map:(ANTLRMap *)labels
-{
-    ANTLRTreePattern *tpattern;
-    // make sure both are non-nil
-    if ( t1 == nil || aTPattern == nil ) {
-        return NO;
-    }
-    if ( [aTPattern isKindOfClass:[ANTLRWildcardTreePattern class]] ) {
-        tpattern = (ANTLRTreePattern *)aTPattern;
-    }
-    // check roots (wildcard matches anything)
-    if ( [tpattern class] != [ANTLRWildcardTreePattern class] ) {
-        if ( [adaptor getType:t1] != [tpattern type] )
-            return NO;
-        // if pattern has text, check node text
-        if ( tpattern.hasTextArg && ![[adaptor getText:t1] isEqualToString:[tpattern text]] ) {
-            return NO;
-        }
-    }
-    if ( tpattern.label != nil && labels!=nil ) {
-        // map label in pattern to node in t1
-        [labels putName:tpattern.label Node:t1];
-    }
-    // check children
-    int n1 = [adaptor getChildCount:t1];
-    int n2 = [tpattern getChildCount];
-    if ( n1 != n2 ) {
-        return NO;
-    }
-    for (int i=0; i<n1; i++) {
-        ANTLRCommonTree * child1 = [adaptor getChild:t1 At:i];
-        ANTLRCommonTree *child2 = (ANTLRCommonTree *)[tpattern getChild:i];
-        if ( ![self _parse:child1 Pattern:child2 Map:labels] ) {
-            return NO;
-        }
-    }
-    return YES;
-}
-
-/** Create a tree or node from the indicated tree pattern that closely
- *  follows ANTLR tree grammar tree element syntax:
- *
- * 		(root child1 ... child2).
- *
- *  You can also just pass in a node: ID
- *
- *  Any node can have a text argument: ID[foo]
- *  (notice there are no quotes around foo--it's clear it's a string).
- *
- *  nil is a special name meaning "give me a nil node".  Useful for
- *  making lists: (nil A B C) is a list of A B C.
- */
-- (ANTLRCommonTree *) createTree:(NSString *)pattern
-{
-    ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
-    ANTLRTreePatternParser *parser = [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer Wizard:self Adaptor:adaptor];
-    ANTLRCommonTree * t = [parser pattern];
-    return t;
-}
-
-/** Compare t1 and t2; return true if token types/text, structure match exactly.
- *  The trees are examined in their entirety so that (A B) does not match
- *  (A B C) nor (A (B C)).
- // TODO: allow them to pass in a comparator
- *  TODO: have a version that is nonstatic so it can use instance adaptor
- *
- *  I cannot rely on the tree node's equals() implementation as I make
- *  no constraints at all on the node types nor interface etc...
- */
-- (BOOL)equals:(id)t1 O2:(id)t2 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    return [self _equals:t1 O2:t2 Adaptor:anAdaptor];
-}
-
-/** Compare type, structure, and text of two trees, assuming adaptor in
- *  this instance of a TreeWizard.
- */
-- (BOOL)equals:(id)t1 O2:(id)t2
-{
-    return [self _equals:t1 O2:t2 Adaptor:adaptor];
-}
-
-- (BOOL) _equals:(id)t1 O2:(id)t2 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor
-{
-    // make sure both are non-nil
-    if ( t1==nil || t2==nil ) {
-        return NO;
-    }
-    // check roots
-    if ( [anAdaptor getType:t1] != [anAdaptor getType:t2] ) {
-        return NO;
-    }
-    if ( ![[anAdaptor getText:t1] isEqualTo:[anAdaptor getText:t2]] ) {
-        return NO;
-    }
-    // check children
-    NSInteger n1 = [anAdaptor getChildCount:t1];
-    NSInteger n2 = [anAdaptor getChildCount:t2];
-    if ( n1 != n2 ) {
-        return NO;
-    }
-    for (int i=0; i<n1; i++) {
-        ANTLRCommonTree * child1 = [anAdaptor getChild:t1 At:i];
-        ANTLRCommonTree * child2 = [anAdaptor getChild:t2 At:i];
-        if ( ![self _equals:child1 O2:child2 Adaptor:anAdaptor] ) {
-            return NO;
-        }
-    }
-    return YES;
-}
-
-// TODO: next stuff taken from CommonTreeNodeStream
-
-/** Given a node, add this to the reverse index tokenTypeToStreamIndexesMap.
- *  You can override this method to alter how indexing occurs.  The
- *  default is to create a
- *
- *    Map<Integer token type,ArrayList<Integer stream index>>
- *
- *  This data structure allows you to find all nodes with type INT in order.
- *
- *  If you really need to find a node of type, say, FUNC quickly then perhaps
- *
- *    Map<Integertoken type, Map<Object tree node, Integer stream index>>
- *
- *  would be better for you.  The interior maps map a tree node to
- *  the index so you don't have to search linearly for a specific node.
- *
- *  If you change this method, you will likely need to change
- *  getNodeIndex(), which extracts information.
-- (void)fillReverseIndex:(ANTLRCommonTree *)node Index:(NSInteger)streamIndex
-{
-    //System.out.println("revIndex "+node+"@"+streamIndex);
-    if ( tokenTypesToReverseIndex == nil ) {
-        return; // no indexing if this is empty (nothing of interest)
-    }
-    if ( tokenTypeToStreamIndexesMap == nil ) {
-        tokenTypeToStreamIndexesMap = [ANTLRMap newANTLRMap]; // first indexing op
-    }
-    int tokenType = [adaptor getType:node];
-    Integer tokenTypeI = new Integer(tokenType);
-    if ( !(tokenTypesToReverseIndex == INDEX_ALL ||
-            [tokenTypesToReverseIndex contains:tokenTypeI]) ) {
-        return; // tokenType not of interest
-    }
-    NSInteger streamIndexI = streamIndex;
-    AMutableArray *indexes = (AMutableArray *)[tokenTypeToStreamIndexesMap objectAtIndex:tokenTypeI];
-    if ( indexes==nil ) {
-        indexes = [AMutableArray arrayWithCapacity:100]; // no list yet for this token type
-        indexes.add(streamIndexI); // not there yet, add
-        [tokenTypeToStreamIndexesMap put:tokenTypeI Idexes:indexes];
-    }
-    else {
-        if ( ![indexes contains:streamIndexI] ) {
-            [indexes add:streamIndexI]; // not there yet, add
-        }
-    }
-}
-
- ** Track the indicated token type in the reverse index.  Call this
- *  repeatedly for each type or use variant with Set argument to
- *  set all at once.
- * @param tokenType
-public void reverseIndex:(NSInteger)tokenType
-{
-    if ( tokenTypesToReverseIndex == nil ) {
-        tokenTypesToReverseIndex = [ANTLRMap newANTLRMap];
-    }
-    else if ( tokenTypesToReverseIndex == INDEX_ALL ) {
-        return;
-    }
-    tokenTypesToReverseIndex.add(new Integer(tokenType));
-}
-
-** Track the indicated token types in the reverse index. Set
- *  to INDEX_ALL to track all token types.
-public void reverseIndex(Set tokenTypes) {
-    tokenTypesToReverseIndex = tokenTypes;
-}
-
- ** Given a node pointer, return its index into the node stream.
- *  This is not its Token stream index.  If there is no reverse map
- *  from node to stream index or the map does not contain entries
- *  for node's token type, a linear search of entire stream is used.
- *
- *  Return -1 if exact node pointer not in stream.
-public int getNodeIndex(Object node) {
-    //System.out.println("get "+node);
-    if ( tokenTypeToStreamIndexesMap==nil ) {
-        return getNodeIndexLinearly(node);
-    }
-    int tokenType = adaptor.getType(node);
-    Integer tokenTypeI = new Integer(tokenType);
-    ArrayList indexes = (ArrayList)tokenTypeToStreamIndexesMap.get(tokenTypeI);
-    if ( indexes==nil ) {
-        //System.out.println("found linearly; stream index = "+getNodeIndexLinearly(node));
-        return getNodeIndexLinearly(node);
-    }
-    for (int i = 0; i < indexes.size(); i++) {
-        Integer streamIndexI = (Integer)indexes.get(i);
-        Object n = get(streamIndexI.intValue());
-        if ( n==node ) {
-            //System.out.println("found in index; stream index = "+streamIndexI);
-            return streamIndexI.intValue(); // found it!
-        }
-    }
-    return -1;
-}
-
-*/
-
-@synthesize adaptor;
-@synthesize tokenNameToTypeMap;
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStream.h b/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStream.h
deleted file mode 100644
index aa1f9c6..0000000
--- a/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStream.h
+++ /dev/null
@@ -1,122 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRTreeNodeStream.h"
-#import "ANTLRCommonTokenStream.h"
-#import "ANTLRCommonTree.h"
-#import "ANTLRCommonTreeAdaptor.h"
-
-@interface ANTLRUnbufferedCommonTreeNodeStream : NSObject < ANTLRTreeNodeStream > {
-
-	BOOL shouldUseUniqueNavigationNodes;
-
-	ANTLRCommonTree *root;
-	ANTLRCommonTree *currentNode;
-	ANTLRCommonTree *previousNode;
-
-	id<ANTLRTreeAdaptor> treeAdaptor;
-
-	id<ANTLRTokenStream> tokenStream;
-
-	NSMutableArray *nodeStack;
-	NSMutableArray *indexStack;
-	ANTLRPtrBuffer *markers;
-	NSInteger lastMarker;
-
-	NSInteger currentChildIndex;
-	NSInteger absoluteNodeIndex;
-
-	NSMutableArray *lookahead;
-	NSUInteger head;
-	NSUInteger tail;
-}
-
-@property (retain, getter=getRoot, setter=setRoot:) ANTLRCommonTree *root;
-@property (retain, getter=getCurrentNode, setter=setCurrentNode:) ANTLRCommonTree *currentNode;
-@property (retain, getter=getPreviousNode, setter=setPreviousNode:) ANTLRCommonTree *previousNode;
-@property (retain, getter=getTreeAdaptor, setter=setTreeAdaptor:) id<ANTLRTreeAdaptor> treeAdaptor;
-@property (retain, getter=getTokenStream, setter=setTokenStream:) id<ANTLRTokenStream> tokenStream;
-@property (retain, getter=getNodeStack, setter=setNodeStack:) NSMutableArray *nodeStack;
-@property (retain, getter=getIndexStack, setter=setIndexStackStack:) NSMutableArray *indexStack;
-@property (retain, getter=getMarkers, setter=setMarkers:) ANTLRPtrBuffer *markers;
-@property (assign, getter=getLastMarker, setter=setLastMarker:) NSInteger lastMarker;
-@property (assign, getter=getCurrentChildIndex, setter=setCurrentChildIndex:) NSInteger currentChildIndex;
-@property (assign, getter=getAbsoluteNodeIndex, setter=setAbsoluteNodeIndex:) NSInteger absoluteNodeIndex;
-@property (retain, getter=getLookahead, setter=setLookahead:) NSMutableArray *lookahead;
-@property (assign, getter=getHead, setter=setHead:) NSUInteger head;
-@property (assign, getter=getTail, setter=setTail:) NSUInteger tail;
-
-- (id) initWithTree:(ANTLRCommonTree *)theTree;
-- (id) initWithTree:(ANTLRCommonTree *)theTree treeAdaptor:(ANTLRCommonTreeAdaptor *)theAdaptor;
-
-- (void) reset;
-
-#pragma mark ANTLRTreeNodeStream conformance
-
-- (id) LT:(NSInteger)k;
-- (id) treeSource;
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-- (void)setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor;
-- (id<ANTLRTokenStream>) getTokenStream;
-- (void) setTokenStream:(id<ANTLRTokenStream>)aTokenStream;	///< Added by subclass, not in protocol
-- (void) setUsesUniqueNavigationNodes:(BOOL)flag;
-
-- (id) nodeAtIndex:(NSUInteger) idx;
-
-- (NSString *) toString;
-- (NSString *) toStringWithRange:(NSRange) aRange;
-- (NSString *) toStringFromNode:(id)startNode toNode:(id)stopNode;
-
-#pragma mark ANTLRIntStream conformance
-- (void) consume;
-- (NSInteger) LA:(NSUInteger) i;
-- (NSUInteger) mark;
-- (NSUInteger) getIndex;
-- (void) rewind:(NSUInteger) marker;
-- (void) rewind;
-- (void) release:(NSUInteger) marker;
-- (void) seek:(NSUInteger) index;
-- (NSUInteger) size;
-
-#pragma mark Lookahead Handling
-- (void) addLookahead:(id<ANTLRBaseTree>)aNode;
-- (NSUInteger) lookaheadSize;
-- (void) fillBufferWithLookahead:(NSInteger)k;
-- (id) nextObject;
-
-#pragma mark Node visiting
-- (ANTLRCommonTree *) handleRootNode;
-- (ANTLRCommonTree *) visitChild:(NSInteger)childNumber;
-- (void) walkBackToMostRecentNodeWithUnvisitedChildren;
-- (void) addNavigationNodeWithType:(NSInteger)tokenType;
-
-#pragma mark Accessors
-- (ANTLRCommonTree *) root;
-- (void) setRoot: (ANTLRCommonTree *) aRoot;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStream.m b/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStream.m
deleted file mode 100644
index 1ee1e4f..0000000
--- a/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStream.m
+++ /dev/null
@@ -1,432 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-
-#import "ANTLRUnbufferedCommonTreeNodeStream.h"
-#import "ANTLRUnbufferedCommonTreeNodeStreamState.h"
-#import "ANTLRBaseTree.h"
-#import "ANTLRToken.h"
-
-#define INITIAL_LOOKAHEAD_BUFFER_SIZE 5
-@implementation ANTLRUnbufferedCommonTreeNodeStream
-
-@synthesize root;
-@synthesize currentNode;
-@synthesize previousNode;
-@synthesize treeAdaptor;
-@synthesize tokenStream;
-@synthesize nodeStack;
-@synthesize indexStack;
-@synthesize markers;
-@synthesize lastMarker;
-@synthesize currentChildIndex;
-@synthesize absoluteNodeIndex;
-@synthesize lookahead;
-@synthesize head;
-@synthesize tail;
-
-- (id) initWithTree:(ANTLRCommonTree *)theTree
-{
-	return [self initWithTree:theTree treeAdaptor:nil];
-}
-
-- (id) initWithTree:(ANTLRCommonTree *)theTree treeAdaptor:(ANTLRCommonTreeAdaptor *)theAdaptor
-{
-	if ((self = [super init]) != nil) {
-		[self setRoot:theTree];
-		if ( theAdaptor == nil )
-			[self setTreeAdaptor:[ANTLRCommonTreeAdaptor newTreeAdaptor]];
-		else
-			[self setTreeAdaptor:theAdaptor];
-		nodeStack = [[NSMutableArray arrayWithCapacity:5] retain];
-		indexStack = [[NSMutableArray arrayWithCapacity:5] retain];
-		markers = [[ANTLRPtrBuffer newANTLRPtrBufferWithLen:100] retain];
-        // [markers insertObject:[NSNull null] atIndex:0];	// markers is one based - maybe fix this later
-		lookahead = [NSMutableArray arrayWithCapacity:INITIAL_LOOKAHEAD_BUFFER_SIZE];	// lookahead is filled with [NSNull null] in -reset
-        [lookahead retain];
-		[self reset];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-	[self setRoot:nil];
-	[self setTreeAdaptor:nil];
-
-	[nodeStack release];	nodeStack = nil;
-	[indexStack release];	indexStack = nil;
-	[markers release];		markers = nil;
-	[lookahead release];	lookahead = nil;
-
-	[super dealloc];
-}
-
-- (void) reset
-{
-	currentNode = root;
-	previousNode = nil;
-	currentChildIndex = -1;
-	absoluteNodeIndex = -1;
-	head = tail = 0;
-	[nodeStack removeAllObjects];
-	[indexStack removeAllObjects];
-	[markers removeAllObjects];
-    // [markers insertObject:[NSNull null] atIndex:0];	// markers is one based - maybe fix this later
-	[lookahead removeAllObjects];
-	// TODO: this is not ideal, but works for now. optimize later
-	int i;
-	for (i = 0; i < INITIAL_LOOKAHEAD_BUFFER_SIZE; i++)
-		[lookahead addObject:[NSNull null]];
-}
-
-
-#pragma mark ANTLRTreeNodeStream conformance
-
-- (id) LT:(NSInteger)k
-{
-	if (k == -1)
-		return previousNode;
-	if (k < 0)
-		@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-LT: looking back more than one node unsupported for unbuffered streams" userInfo:nil];
-	if (k == 0)
-		return ANTLRBaseTree.INVALID_NODE;
-	[self fillBufferWithLookahead:k];
-	return [lookahead objectAtIndex:(head+k-1) % [lookahead count]];
-}
-
-- (id) treeSource
-{
-	return [self root];
-}
-
-- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
-{
-	return treeAdaptor;
-}
-
-- (void)setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor
-{
-    if (treeAdaptor != aTreeAdaptor) {
-        [aTreeAdaptor retain];
-        [treeAdaptor release];
-        treeAdaptor = aTreeAdaptor;
-    }
-}
-
-- (id<ANTLRTokenStream>) getTokenStream
-{
-	return tokenStream;
-}
-
-- (void) setTokenStream:(id<ANTLRTokenStream>)aTokenStream
-{
-	if (tokenStream != aTokenStream) {
-		[tokenStream release];
-		[aTokenStream retain];
-		tokenStream = aTokenStream;
-	}
-}
-
-- (void) setUsesUniqueNavigationNodes:(BOOL)flag
-{
-	shouldUseUniqueNavigationNodes = flag;
-}
-
-- (id) nodeAtIndex:(NSUInteger) idx
-{
-	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-nodeAtIndex: unsupported for unbuffered streams" userInfo:nil];
-}
-
-- (NSString *) toString
-{
-	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-toString unsupported for unbuffered streams" userInfo:nil];
-}
-
-- (NSString *) toStringWithRange:(NSRange) aRange
-{
-	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-toString: unsupported for unbuffered streams" userInfo:nil];
-}
-
-- (NSString *) toStringFromNode:(id)startNode ToNode:(id)stopNode
-{
-	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-toStringFromNode:toNode: unsupported for unbuffered streams" userInfo:nil];
-}
-
-#pragma mark ANTLRIntStream conformance
-
-- (void) consume
-{
-	[self fillBufferWithLookahead:1];
-	absoluteNodeIndex++;
-	previousNode = [lookahead objectAtIndex:head];
-	head = (head+1) % [lookahead count];
-}
-
-- (NSInteger) LA:(NSUInteger) i
-{
-	ANTLRCommonTree *node = [self LT:i];
-	if (!node)
-		return ANTLRTokenTypeInvalid;
-	int ttype = [node getType];
-	return ttype;
-}
-
-- (NSUInteger) mark
-{
-	ANTLRUnbufferedCommonTreeNodeStreamState *state = [[[ANTLRUnbufferedCommonTreeNodeStreamState alloc] init] retain];
-	[state setCurrentNode:currentNode];
-	[state setPreviousNode:previousNode];
-	[state setIndexStackSize:[indexStack count]];
-	[state setNodeStackSize:[nodeStack count]];
-	[state setCurrentChildIndex:currentChildIndex];
-	[state setAbsoluteNodeIndex:absoluteNodeIndex];
-	unsigned int lookaheadSize = [self lookaheadSize];
-	unsigned int k;
-	for ( k = 0; k < lookaheadSize; k++) {
-		[state addToLookahead:[self LT:k+1]];
-	}
-	[markers addObject:state];
-	//[state release];
-	return [markers count];
-}
-
-- (NSUInteger) getIndex
-{
-	return absoluteNodeIndex + 1;
-}
-
-- (void) rewind:(NSUInteger) marker
-{
-	if ( [markers count] < marker ) {
-		return;
-	}
-	ANTLRUnbufferedCommonTreeNodeStreamState *state = [markers objectAtIndex:marker];
-	[markers removeObjectAtIndex:marker];
-
-	absoluteNodeIndex = [state absoluteNodeIndex];
-	currentChildIndex = [state currentChildIndex];
-	currentNode = [state currentNode];
-	previousNode = [state previousNode];
-	// drop node and index stacks back to old size
-	[nodeStack removeObjectsInRange:NSMakeRange([state nodeStackSize], [nodeStack count]-[state nodeStackSize])];
-	[indexStack removeObjectsInRange:NSMakeRange([state indexStackSize], [indexStack count]-[state indexStackSize])];
-
-	head = tail = 0; // wack lookahead buffer and then refill
-	[lookahead release];
-	lookahead = [[NSMutableArray alloc] initWithArray:[state lookahead]];
-	tail = [lookahead count];
-	// make some room after the restored lookahead, so that the above line is not a bug ;)
-	// this also ensures that a subsequent -addLookahead: will not immediately need to resize the buffer
-	[lookahead addObjectsFromArray:[NSArray arrayWithObjects:[NSNull null], [NSNull null], [NSNull null], [NSNull null], [NSNull null], nil]];
-}
-
-- (void) rewind
-{
-	[self rewind:[markers count]];
-}
-
-- (void) release:(NSUInteger) marker
-{
-	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-release: unsupported for unbuffered streams" userInfo:nil];
-}
-
-- (void) seek:(NSUInteger) anIndex
-{
-	if ( anIndex < (NSUInteger) index )
-		@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-seek: backwards unsupported for unbuffered streams" userInfo:nil];
-	while ( (NSUInteger) index < anIndex ) {
-		[self consume];
-	}
-}
-
-- (NSUInteger) size;
-{
-	return absoluteNodeIndex + 1;	// not entirely correct, but cheap.
-}
-
-
-#pragma mark Lookahead Handling
-- (void) addLookahead:(id<ANTLRBaseTree>)aNode
-{
-	[lookahead replaceObjectAtIndex:tail withObject:aNode];
-	tail = (tail+1) % [lookahead count];
-
-	if ( tail == head ) {
-		NSMutableArray *newLookahead = [[[NSMutableArray alloc] initWithCapacity:[lookahead count]*2] retain];
-
-		NSRange headRange = NSMakeRange(head, [lookahead count]-head);
-		NSRange tailRange = NSMakeRange(0, tail);
-
-		[newLookahead addObjectsFromArray:[lookahead objectsAtIndexes:[NSIndexSet indexSetWithIndexesInRange:headRange]]];
-		[newLookahead addObjectsFromArray:[lookahead objectsAtIndexes:[NSIndexSet indexSetWithIndexesInRange:tailRange]]];
-
-		unsigned int i;
-		unsigned int lookaheadCount = [newLookahead count];
-		for (i = 0; i < lookaheadCount; i++)
-			[newLookahead addObject:[NSNull null]];
-		[lookahead release];
-		lookahead = newLookahead;
-
-		head = 0;
-		tail = lookaheadCount;	// tail is the location the _next_ lookahead node will end up in, not the last element's idx itself!
-	}
-
-}
-
-- (NSUInteger) lookaheadSize
-{
-	return tail < head
-		? ([lookahead count] - head + tail)
-		: (tail - head);
-}
-
-- (void) fillBufferWithLookahead:(NSInteger)k
-{
-	unsigned int n = [self lookaheadSize];
-	unsigned int i;
-	id lookaheadObject = self; // any valid object would do.
-	for (i=1; i <= k-n && lookaheadObject != nil; i++) {
-		lookaheadObject = [self nextObject];
-	}
-}
-
-- (id) nextObject
-{
-	// NOTE: this could/should go into an NSEnumerator subclass for treenode streams.
-	if (currentNode == nil) {
-        if ( navigationNodeEOF == nil ) {
-            navigationNodeEOF = [[ANTLRTreeNavigationNodeEOF alloc] init];
-        }
-		[self addLookahead:navigationNodeEOF];
-		return nil;
-	}
-	if (currentChildIndex == -1) {
-		return [self handleRootNode];
-	}
-	if (currentChildIndex < (NSInteger)[currentNode getChildCount]) {
-		return [self visitChild:currentChildIndex];
-	}
-	[self walkBackToMostRecentNodeWithUnvisitedChildren];
-	if (currentNode != nil) {
-		return [self visitChild:currentChildIndex];
-	}
-
-	return nil;
-}
-
-#pragma mark Node visiting
-- (ANTLRCommonTree *) handleRootNode
-{
-	ANTLRCommonTree *node = currentNode;
-	currentChildIndex = 0;
-	if ([node isNil]) {
-		node = [self visitChild:currentChildIndex];
-	} else {
-		[self addLookahead:node];
-		if ([currentNode getChildCount] == 0) {
-			currentNode = nil;
-		}
-	}
-	return node;
-}
-
-- (ANTLRCommonTree *) visitChild:(NSInteger)childNumber
-{
-	ANTLRCommonTree *node = nil;
-
-	[nodeStack addObject:currentNode];
-	[indexStack addObject:[NSNumber numberWithInt:childNumber]];
-	if (childNumber == 0 && ![currentNode isNil])
-		[self addNavigationNodeWithType:ANTLRTokenTypeDOWN];
-
-	currentNode = [currentNode getChild:childNumber];
-	currentChildIndex = 0;
-	node = currentNode;  // record node to return
-	[self addLookahead:node];
-	[self walkBackToMostRecentNodeWithUnvisitedChildren];
-	return node;
-}
-
-- (void) walkBackToMostRecentNodeWithUnvisitedChildren
-{
-	while (currentNode != nil && currentChildIndex >= (NSInteger)[currentNode getChildCount])
-	{
-		currentNode = (ANTLRCommonTree *)[nodeStack lastObject];
-		[nodeStack removeLastObject];
-		currentChildIndex = [(NSNumber *)[indexStack lastObject] intValue];
-		[indexStack removeLastObject];
-		currentChildIndex++; // move to next child
-		if (currentChildIndex >= (NSInteger)[currentNode getChildCount]) {
-			if (![currentNode isNil]) {
-				[self addNavigationNodeWithType:ANTLRTokenTypeUP];
-			}
-			if (currentNode == root) { // we done yet?
-				currentNode = nil;
-			}
-		}
-	}
-
-}
-
-- (void) addNavigationNodeWithType:(NSInteger)tokenType
-{
-	// TODO: this currently ignores shouldUseUniqueNavigationNodes.
-	switch (tokenType) {
-		case ANTLRTokenTypeDOWN: {
-            if (navigationNodeDown == nil) {
-                navigationNodeDown = [[ANTLRTreeNavigationNodeDown alloc] init];
-            }
-			[self addLookahead:navigationNodeDown];
-			break;
-		}
-		case ANTLRTokenTypeUP: {
-            if (navigationNodeUp == nil) {
-                navigationNodeUp = [[ANTLRTreeNavigationNodeUp alloc] init];
-            }
-			[self addLookahead:navigationNodeUp];
-			break;
-		}
-	}
-}
-
-#pragma mark Accessors
-- (ANTLRCommonTree *) root
-{
-    return root;
-}
-
-- (void) setRoot: (ANTLRCommonTree *) aRoot
-{
-    if (root != aRoot) {
-        [aRoot retain];
-        [root release];
-        root = aRoot;
-    }
-}
-
-@end
-
diff --git a/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStreamState.h b/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStreamState.h
deleted file mode 100644
index f728952..0000000
--- a/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStreamState.h
+++ /dev/null
@@ -1,66 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRCommonTree.h"
-
-@interface ANTLRUnbufferedCommonTreeNodeStreamState : NSObject {
-	ANTLRCommonTree *currentNode;
-	ANTLRCommonTree *previousNode;
-
-	int currentChildIndex;
-	int absoluteNodeIndex;
-	unsigned int nodeStackSize;
-	unsigned int indexStackSize;
-
-	NSMutableArray *lookahead;
-}
-
-- (ANTLRCommonTree *) currentNode;
-- (void) setCurrentNode: (ANTLRCommonTree *) aCurrentNode;
-
-- (ANTLRCommonTree *) previousNode;
-- (void) setPreviousNode: (ANTLRCommonTree *) aPreviousNode;
-
-- (NSInteger) currentChildIndex;
-- (void) setCurrentChildIndex: (NSInteger) aCurrentChildIndex;
-
-- (NSInteger) absoluteNodeIndex;
-- (void) setAbsoluteNodeIndex: (NSInteger) anAbsoluteNodeIndex;
-
-- (NSUInteger) nodeStackSize;
-- (void) setNodeStackSize: (NSUInteger) aNodeStackSize;
-
-- (NSUInteger) indexStackSize;
-- (void) setIndexStackSize: (NSUInteger) anIndexStackSize;
-
-- (NSMutableArray *) lookahead;
-- (void) setLookahead: (NSMutableArray *) aLookahead;
-
-- (void) addToLookahead: (id)lookaheadObject;
-- (void) removeFromLookahead: (id)lookaheadObject;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStreamState.m b/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStreamState.m
deleted file mode 100644
index c46d28d..0000000
--- a/runtime/ObjC/Framework/ANTLRUnbufferedCommonTreeNodeStreamState.m
+++ /dev/null
@@ -1,140 +0,0 @@
-// [The "BSD licence"]
-// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRUnbufferedCommonTreeNodeStreamState.h"
-
-
-@implementation ANTLRUnbufferedCommonTreeNodeStreamState
-
-- (id) init
-{
-	if ((self = [super init]) != nil) {
-		lookahead = [[NSMutableArray alloc] init];
-	}
-	return self;
-}
-
-- (void) dealloc
-{
-	[self setLookahead:nil];
-	[self setCurrentNode:nil];
-	[self setPreviousNode:nil];
-	[super dealloc];
-}
-
-- (ANTLRCommonTree *) currentNode
-{
-    return currentNode;
-}
-
-- (void) setCurrentNode: (ANTLRCommonTree *) aCurrentNode
-{
-    if (currentNode != aCurrentNode) {
-        [aCurrentNode retain];
-        [currentNode release];
-        currentNode = aCurrentNode;
-    }
-}
-
-- (ANTLRCommonTree *) previousNode
-{
-    return previousNode;
-}
-
-- (void) setPreviousNode: (ANTLRCommonTree *) aPreviousNode
-{
-    if (previousNode != aPreviousNode) {
-        [aPreviousNode retain];
-        [previousNode release];
-        previousNode = aPreviousNode;
-    }
-}
-
-- (NSInteger) currentChildIndex
-{
-    return currentChildIndex;
-}
-
-- (void) setCurrentChildIndex: (NSInteger) aCurrentChildIndex
-{
-    currentChildIndex = aCurrentChildIndex;
-}
-
-- (NSInteger) absoluteNodeIndex
-{
-    return absoluteNodeIndex;
-}
-
-- (void) setAbsoluteNodeIndex: (NSInteger) anAbsoluteNodeIndex
-{
-    absoluteNodeIndex = anAbsoluteNodeIndex;
-}
-
-- (NSUInteger) nodeStackSize
-{
-    return nodeStackSize;
-}
-
-- (void) setNodeStackSize: (NSUInteger) aNodeStackSize
-{
-    nodeStackSize = aNodeStackSize;
-}
-
-- (NSUInteger) indexStackSize
-{
-    return indexStackSize;
-}
-
-- (void) setIndexStackSize: (NSUInteger) anIndexStackSize
-{
-    indexStackSize = anIndexStackSize;
-}
-
-- (NSMutableArray *) lookahead
-{
-    return lookahead;
-}
-
-- (void) setLookahead: (NSMutableArray *) aLookahead
-{
-    if (lookahead != aLookahead) {
-        [aLookahead retain];
-        [lookahead release];
-        lookahead = aLookahead;
-    }
-}
-
-- (void) addToLookahead: (id)lookaheadObject
-{
-    [[self lookahead] addObject: lookaheadObject];
-}
-- (void) removeFromLookahead: (id)lookaheadObject
-{
-    [[self lookahead] removeObject: lookaheadObject];
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUnbufferedTokenStream.h b/runtime/ObjC/Framework/ANTLRUnbufferedTokenStream.h
deleted file mode 100644
index 84d8f43..0000000
--- a/runtime/ObjC/Framework/ANTLRUnbufferedTokenStream.h
+++ /dev/null
@@ -1,62 +0,0 @@
-//
-//  ANTLRUnbufferedTokenStream.h
-//  ANTLR
-//
-//  Created by Alan Condit on 7/12/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRRuntimeException.h"
-#import "ANTLRTokenSource.h"
-#import "ANTLRLookaheadStream.h"
-#import "ANTLRToken.h"
-
-@interface ANTLRUnbufferedTokenStream : ANTLRLookaheadStream {
-	id<ANTLRTokenSource> tokenSource;
-    NSInteger tokenIndex; // simple counter to set token index in tokens
-    NSInteger channel;
-}
-
-@property (retain, getter=getTokenSource, setter=setTokenSource:) id<ANTLRTokenSource> tokenSource;
-@property (getter=getTokenIndex, setter=setTokenIndex:) NSInteger tokenIndex;
-@property (getter=channel, setter=setChannel:) NSInteger channel;
-
-+ (ANTLRUnbufferedTokenStream *)newANTLRUnbufferedTokenStream:(id<ANTLRTokenSource>)aTokenSource;
-- (id) init;
-- (id) initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource;
-
-- (id<ANTLRToken>)nextElement;
-- (BOOL)isEOF:(id<ANTLRToken>) aToken;
-- (id<ANTLRTokenSource>)getTokenSource;
-- (NSString *)toStringFromStart:(NSInteger)aStart ToEnd:(NSInteger)aStop;
-- (NSString *)toStringFromToken:(id<ANTLRToken>)aStart ToEnd:(id<ANTLRToken>)aStop;
-- (NSInteger)LA:(NSInteger)anIdx;
-- (id<ANTLRToken>)objectAtIndex:(NSInteger)anIdx;
-- (NSString *)getSourceName;
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUnbufferedTokenStream.m b/runtime/ObjC/Framework/ANTLRUnbufferedTokenStream.m
deleted file mode 100644
index 3b74e92..0000000
--- a/runtime/ObjC/Framework/ANTLRUnbufferedTokenStream.m
+++ /dev/null
@@ -1,118 +0,0 @@
-//
-//  ANTLRUnbufferedTokenStream.m
-//  ANTLR
-//
-//  Created by Alan Condit on 7/12/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRUnbufferedTokenStream.h"
-
-@implementation ANTLRUnbufferedTokenStream
-
-@synthesize tokenSource;
-@synthesize tokenIndex;
-@synthesize channel;
-
-+ (ANTLRUnbufferedTokenStream *)newANTLRUnbufferedTokenStream:(id<ANTLRTokenSource>)aTokenSource
-{
-    return [[ANTLRUnbufferedTokenStream alloc] initWithTokenSource:aTokenSource];
-}
-
-- (id) init
-{
-    if ((self = [super init]) != nil) {
-        tokenSource = nil;
-        tokenIndex = 0;
-        channel = ANTLRTokenChannelDefault;
-    }
-    return self;
-}
-
-- (id) initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource
-{
-    if ((self = [super init]) != nil) {
-        tokenSource = aTokenSource;
-        if ( tokenSource ) [tokenSource retain];
-        tokenIndex = 0;
-        channel = ANTLRTokenChannelDefault;
-    }
-    return self;
-}
-
-- (void) dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRUnbufferedTokenStream" );
-#endif
-    if ( tokenSource ) [tokenSource release];
-    [super dealloc];
-}
-
-- (id<ANTLRToken>)nextElement
-{
-    id<ANTLRToken> t = [tokenSource nextToken];
-    [t setTokenIndex:tokenIndex++];
-    return t;
-}
-
-- (BOOL)isEOF:(id<ANTLRToken>)aToken
-{
-    return (aToken.type == ANTLRTokenTypeEOF);
-}
-
-- (id<ANTLRTokenSource>)getTokenSource
-{
-    return tokenSource;
-}
-
-- (NSString *)toStringFromStart:(NSInteger)aStart ToEnd:(NSInteger)aStop
-{
-    return @"n/a";
-}
-
-- (NSString *)toStringFromToken:(id<ANTLRToken>)aStart ToEnd:(id<ANTLRToken>)aStop
-{
-    return @"n/a";
-}
-
-- (NSInteger)LA:(NSInteger)anIdx
-{
-    return [[self LT:anIdx] type];
-}
-
-- (id<ANTLRToken>)objectAtIndex:(NSInteger)anIdx
-{
-    @throw [ANTLRRuntimeException newException:@"Absolute token indexes are meaningless in an unbuffered stream"];
-}
-
-- (NSString *)getSourceName
-{
-    return [tokenSource getSourceName];
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUniqueIDMap.h b/runtime/ObjC/Framework/ANTLRUniqueIDMap.h
deleted file mode 100644
index 55c92d1..0000000
--- a/runtime/ObjC/Framework/ANTLRUniqueIDMap.h
+++ /dev/null
@@ -1,64 +0,0 @@
-//
-//  ANTLRUniqueIDMap.h
-//  ANTLR
-//
-//  Created by Alan Condit on 7/7/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRPtrBuffer.h"
-#import "ANTLRNodeMapElement.h"
-
-#define SUCCESS             0
-#define FAILURE             -1
-#define HASHSIZE            101
-#define HBUFSIZE            0x2000
-
-@interface ANTLRUniqueIDMap : ANTLRPtrBuffer {
-    NSInteger lastHash;
-}
-
-@property (getter=getLastHash, setter=setLastHash:) NSInteger lastHash;
-
-+ (id)newANTLRUniqueIDMap;
-+ (id)newANTLRUniqueIDMapWithLen:(NSInteger)aHashSize;
-
-- (id)init;
-- (id)initWithLen:(NSInteger)cnt;
-- (void)dealloc;
-// Instance Methods
-- (NSInteger)count;
-- (NSInteger)size;
-/* clear -- reinitialize the maplist array */
-- (void) clear;
-
-- (void)deleteANTLRUniqueIDMap:(ANTLRNodeMapElement *)np;
-- (void)delete_chain:(ANTLRNodeMapElement *)np;
-- (id)getNode:(id<ANTLRBaseTree>)aNode;
-- (void)putID:(id)anID Node:(id<ANTLRBaseTree>)aNode;
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUniqueIDMap.m b/runtime/ObjC/Framework/ANTLRUniqueIDMap.m
deleted file mode 100644
index 0d52092..0000000
--- a/runtime/ObjC/Framework/ANTLRUniqueIDMap.m
+++ /dev/null
@@ -1,184 +0,0 @@
-//
-//  ANTLRUniqueIDMap.m
-//  ANTLR
-//
-//  Created by Alan Condit on 7/7/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRUniqueIDMap.h"
-#import "ANTLRTree.h"
-
-@implementation ANTLRUniqueIDMap
-@synthesize lastHash;
-
-+(id)newANTLRUniqueIDMap
-{
-    ANTLRUniqueIDMap *aNewANTLRUniqueIDMap;
-
-    aNewANTLRUniqueIDMap = [[ANTLRUniqueIDMap alloc] init];
-	return( aNewANTLRUniqueIDMap );
-}
-
-+(id)newANTLRUniqueIDMapWithLen:(NSInteger)aBuffSize
-{
-    ANTLRUniqueIDMap *aNewANTLRUniqueIDMap;
-
-    aNewANTLRUniqueIDMap = [[ANTLRUniqueIDMap alloc] initWithLen:aBuffSize];
-	return( aNewANTLRUniqueIDMap );
-}
-
--(id)init
-{
-    NSInteger idx;
-
-	if ((self = [super initWithLen:HASHSIZE]) != nil) {
-		fNext = nil;
-        for( idx = 0; idx < HASHSIZE; idx++ ) {
-            ptrBuffer[idx] = nil;
-        }
-	}
-    return( self );
-}
-
--(id)initWithLen:(NSInteger)aBuffSize
-{
-	if ((self = [super initWithLen:aBuffSize]) != nil) {
-	}
-    return( self );
-}
-
--(void)dealloc
-{
-#ifdef DEBUG_DEALLOC
-    NSLog( @"called dealloc in ANTLRUniqueIDMap" );
-#endif
-    ANTLRNodeMapElement *tmp, *rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < HASHSIZE; idx++ ) {
-            tmp = ptrBuffer[idx];
-            while ( tmp ) {
-                rtmp = tmp;
-                tmp = (ANTLRNodeMapElement *)tmp.fNext;
-                [rtmp release];
-            }
-        }
-    }
-	[super dealloc];
-}
-
--(void)deleteANTLRUniqueIDMap:(ANTLRNodeMapElement *)np
-{
-    ANTLRNodeMapElement *tmp, *rtmp;
-    NSInteger idx;
-
-    if ( self.fNext != nil ) {
-        for( idx = 0; idx < HASHSIZE; idx++ ) {
-            tmp = ptrBuffer[idx];
-            while ( tmp ) {
-                rtmp = tmp;
-                tmp = tmp.fNext;
-                [rtmp release];
-            }
-        }
-    }
-}
-
-- (void)clear
-{
-    ANTLRNodeMapElement *tmp, *rtmp;
-    NSInteger idx;
-
-    for( idx = 0; idx < HASHSIZE; idx++ ) {
-        tmp = ptrBuffer[idx];
-        while ( tmp ) {
-            rtmp = tmp;
-            tmp = [tmp getfNext];
-            [rtmp release];
-        }
-        ptrBuffer[idx] = nil;
-    }
-}
-
-- (NSInteger)count
-{
-    id anElement;
-    NSInteger aCnt = 0;
-
-    for (int i = 0; i < BuffSize; i++) {
-        if ((anElement = ptrBuffer[i]) != nil) {
-            aCnt += (NSInteger)[anElement count];
-        }
-    }
-    return aCnt;
-}
-
-- (NSInteger)size
-{
-    return BuffSize;
-}
-
--(void)delete_chain:(ANTLRNodeMapElement *)np
-{
-    if ( np.fNext != nil )
-		[self delete_chain:np.fNext];
-	[np release];
-}
-
-- (id)getNode:(id<ANTLRBaseTree>)aNode
-{
-    ANTLRNodeMapElement *np;
-    NSInteger idx;
-
-    idx = [(id<ANTLRBaseTree>)aNode type];
-    np = ptrBuffer[idx];
-    while ( np != nil ) {
-        if (np.node == aNode) {
-            return( np.index );
-        }
-        np = np.fNext;
-    }
-    return( nil );
-}
-
-- (void)putID:(id)anID Node:(id<ANTLRBaseTree>)aNode
-{
-    ANTLRNodeMapElement *np, *np1;
-    NSInteger idx;
-
-    idx = [(id<ANTLRBaseTree>)aNode type];
-    idx %= HASHSIZE;
-    np = [[ANTLRNodeMapElement newANTLRNodeMapElementWithIndex:anID Node:aNode] retain];
-    np1 = ptrBuffer[idx];
-    np.fNext = np1;
-    ptrBuffer[idx] = np;
-    return;
-}
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUnwantedTokenException.h b/runtime/ObjC/Framework/ANTLRUnwantedTokenException.h
deleted file mode 100644
index fbb60e3..0000000
--- a/runtime/ObjC/Framework/ANTLRUnwantedTokenException.h
+++ /dev/null
@@ -1,47 +0,0 @@
-//
-//  ANTLRUnwantedTokenException.h
-//  ANTLR
-//
-//  Created by Alan Condit on 6/8/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import <Cocoa/Cocoa.h>
-#import "ANTLRMismatchedTokenException.h"
-
-@interface ANTLRUnwantedTokenException : ANTLRMismatchedTokenException {
-
-}
-+ (ANTLRUnwantedTokenException *)newException;
-+ (ANTLRUnwantedTokenException *)newException:(NSInteger)expected Stream:(id<ANTLRIntStream>)anInput;
-
-- (id) init;
-- (id) initWithStream:(id<ANTLRIntStream>)anInput And:(NSInteger)expected;
-- (id<ANTLRToken>)getUnexpectedToken;
-- (NSString *)toString;
-
-
-@end
diff --git a/runtime/ObjC/Framework/ANTLRUnwantedTokenException.m b/runtime/ObjC/Framework/ANTLRUnwantedTokenException.m
deleted file mode 100644
index b8b24f3..0000000
--- a/runtime/ObjC/Framework/ANTLRUnwantedTokenException.m
+++ /dev/null
@@ -1,80 +0,0 @@
-//
-//  ANTLRUnwantedTokenException.m
-//  ANTLR
-//
-//  Created by Alan Condit on 6/8/10.
-// [The "BSD licence"]
-// Copyright (c) 2010 Alan Condit
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-#import "ANTLRUnwantedTokenException.h"
-
-@implementation ANTLRUnwantedTokenException : ANTLRMismatchedTokenException
-	/** Used for remote debugger deserialization */
-+ (ANTLRUnwantedTokenException *)newException
-{
-    return [[ANTLRUnwantedTokenException alloc] init];
-}
-
-+ (ANTLRUnwantedTokenException *)newException:(NSInteger)expected Stream:(id<ANTLRIntStream>)anInput
-{
-    return [[ANTLRUnwantedTokenException alloc] initWithStream:anInput And:expected];
-}
-
-- (id) init
-{
-    self = [super initWithStream:input];
-    if (self) {
-    }
-    return self;
-}
-
-- (id) initWithStream:(id<ANTLRIntStream>)anInput And:(NSInteger)expected
-{
-    self = [super initWithStream:anInput];
-    if (self) {
-        expecting = expected;
-    }
-    return self;
-}
-
-- (id<ANTLRToken>)getUnexpectedToken
-{
-    return token;
-}
-
-- (NSString *)toString
-{
-    NSString *exp1 = [NSString stringWithFormat:@", expected %d", expecting];
-    if ( expecting == ANTLRTokenTypeInvalid ) {
-        exp1 = @"";
-    }
-    if ( token==nil ) {
-        return [NSString stringWithFormat:@"UnwantedTokenException(found=%@)", exp1];
-    }
-    return [NSString stringWithFormat:@"UnwantedTokenException(found=%@ %@", token.text, exp1];
-}
-
-@end
diff --git a/runtime/ObjC/Framework/FastQueue.h b/runtime/ObjC/Framework/FastQueue.h
new file mode 100644
index 0000000..f5ba582
--- /dev/null
+++ b/runtime/ObjC/Framework/FastQueue.h
@@ -0,0 +1,64 @@
+//
+//  ANTLRFastQueue.h
+//  ANTLR
+//
+//  Created by Ian Michell on 26/04/2010.
+// [The "BSD licence"]
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "AMutableArray.h"
+
+@interface ANTLRFastQueue : NSObject <NSCopying>
+{
+    __strong AMutableArray *data;
+    NSUInteger p;
+    NSUInteger range;
+}
+
+@property (retain) AMutableArray *data;
+@property (assign) NSUInteger p;
+@property (assign) NSUInteger range;
+
++ (id) newANTLRFastQueue;
+
+- (id) init;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (void) reset;
+- (id) remove;
+- (void) addObject:(id) obj;
+- (NSUInteger) count;
+- (NSUInteger) size;
+- (NSUInteger) range;
+- (id) head;
+- (id) objectAtIndex:(NSUInteger) i;
+- (void) clear;
+- (NSString *) toString;
+- (NSString *) description;
+
+@end
diff --git a/runtime/ObjC/Framework/FastQueue.m b/runtime/ObjC/Framework/FastQueue.m
new file mode 100644
index 0000000..6944b6d
--- /dev/null
+++ b/runtime/ObjC/Framework/FastQueue.m
@@ -0,0 +1,174 @@
+//
+//  ANTLRFastQueue.m
+//  ANTLR
+//
+//  Created by Ian Michell on 26/04/2010.
+// [The "BSD licence"]
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRFastQueue.h"
+#import "ANTLRError.h"
+#import "ANTLRRuntimeException.h"
+
+@implementation ANTLRFastQueue
+
+//@synthesize pool;
+@synthesize data;
+@synthesize p;
+@synthesize range;
+
++ (id) newANTLRFastQueue
+{
+    return [[ANTLRFastQueue alloc] init];
+}
+
+- (id) init
+{
+	self = [super init];
+	if ( self != nil ) {
+		data = [[AMutableArray arrayWithCapacity:100] retain];
+		p = 0;
+		range = -1;
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRFastQueue" );
+#endif
+	if ( data ) [data release];
+	[super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRFastQueue *copy;
+
+    copy = [[[self class] allocWithZone:aZone] init];
+    copy.data = [data copyWithZone:nil];
+    copy.p = p;
+    copy.range = range;
+    return copy;
+}
+
+// FIXME: Java code has this, it doesn't seem like it needs to be there... Then again a lot of the code in the java runtime is not great...
+- (void) reset
+{
+	[self clear];
+}
+
+- (void) clear
+{
+	p = 0;
+    if ( [data count] )
+        [data removeAllObjects];
+}
+
+- (id) remove
+{
+	id obj = [self objectAtIndex:0];
+	p++;
+	// check to see if we have hit the end of the buffer
+	if ( p == [data count] ) {
+		// if we have, then we need to clear it out
+		[self clear];
+	}
+	return obj;
+}
+
+- (void) addObject:(id) obj
+{
+    [data addObject:obj];
+}
+
+- (NSUInteger) count
+{
+	return [data count];
+}
+
+- (NSUInteger) size
+{
+	return [data count] - p;
+}
+
+- (NSUInteger) range
+{
+    return range;
+}
+
+- (id) head
+{
+	return [self objectAtIndex:0];
+}
+
+- (id) objectAtIndex:(NSUInteger) i
+{
+    NSUInteger absIndex;
+
+    absIndex = p + i;
+	if ( absIndex >= [data count] ) {
+		@throw [ANTLRNoSuchElementException newException:[NSString stringWithFormat:@"queue index %d > last index %d", absIndex, [data count]-1]];
+	}
+	if ( absIndex < 0 ) {
+	    @throw [ANTLRNoSuchElementException newException:[NSString stringWithFormat:@"queue index %d < 0", absIndex]];
+	}
+	if ( absIndex > range ) range = absIndex;
+	return [data objectAtIndex:absIndex];
+}
+
+- (NSString *) toString
+{
+    return [self description];
+}
+
+- (NSString *) description
+{
+	NSMutableString *buf = [NSMutableString stringWithCapacity:30];
+	NSInteger n = [self size];
+	for (NSInteger i = 0; i < n; i++) {
+		[buf appendString:[[self objectAtIndex:i] description]];
+		if ((i + 1) < n) {
+			[buf appendString:@" "];
+		}
+	}
+	return buf;
+}
+
+#ifdef DONTUSENOMO
+- (NSAutoreleasePool *)getPool
+{
+    return pool;
+}
+
+- (void)setPool:(NSAutoreleasePool *)aPool
+{
+    pool = aPool;
+}
+#endif
+
+@end
diff --git a/runtime/ObjC/Framework/HashMap.h b/runtime/ObjC/Framework/HashMap.h
new file mode 100644
index 0000000..113cb65
--- /dev/null
+++ b/runtime/ObjC/Framework/HashMap.h
@@ -0,0 +1,110 @@
+//
+//  ANTLRHashMap.h
+//  ANTLR
+//
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRLinkBase.h"
+#import "ANTLRMapElement.h"
+
+#define GLOBAL_SCOPE       0
+#define LOCAL_SCOPE        1
+#define HASHSIZE         101
+#define HBUFSIZE      0x2000
+
+@interface ANTLRHashMap : ANTLRLinkBase {
+    //    TStringPool *fPool;
+    NSInteger Scope;
+    NSInteger LastHash;
+    NSInteger BuffSize;
+    NSUInteger count;
+    NSUInteger ptr;
+    __strong NSMutableData *buffer;
+    __strong ANTLRMapElement **ptrBuffer;
+    NSInteger mode;
+}
+
+// Contruction/Destruction
++ (id)newANTLRHashMap;
++ (id)newANTLRHashMapWithLen:(NSInteger)aBuffSize;
+- (id)init;
+- (id)initWithLen:(NSInteger)aBuffSize;
+- (void)dealloc;
+- (ANTLRHashMap *)PushScope:( ANTLRHashMap **)map;
+- (ANTLRHashMap *)PopScope:( ANTLRHashMap **)map;
+
+- (NSInteger)count;
+- (NSInteger)size;
+
+// Instance Methods
+/*    form hash value for string s */
+- (NSInteger)hash:(NSString *)s;
+/*   look for s in ptrBuffer  */
+- (ANTLRHashMap *)findscope:(int)level;
+/*   look for s in ptrBuffer  */
+- (id)lookup:(NSString *)s Scope:(int)scope;
+/*   look for s in ptrBuffer  */
+- (id)install:(ANTLRMapElement *)sym Scope:(int)scope;
+/*   look for s in ptrBuffer  */
+- (void)deleteANTLRHashMap:(ANTLRMapElement *)np;
+- (int)RemoveSym:(NSString *)s;
+- (void)delete_chain:(ANTLRMapElement *)np;
+#ifdef DONTUSEYET
+- (int)bld_symtab:(KW_TABLE *)toknams;
+#endif
+- (ANTLRMapElement **)getptrBuffer;
+- (ANTLRMapElement *)getptrBufferEntry:(int)idx;
+- (void)setptrBuffer:(ANTLRMapElement *)np Index:(int)idx;
+- (NSInteger)getScope;
+- (void)setScope:(NSInteger)i;
+- (ANTLRMapElement *)getTType:(NSString *)name;
+- (ANTLRMapElement *)getNameInList:(NSInteger)ttype;
+- (void)putNode:(NSString *)name TokenType:(NSInteger)ttype;
+- (NSInteger)getMode;
+- (void)setMode:(NSInteger)aMode;
+- (void) insertObject:(id)aRule atIndex:(NSInteger)idx;
+- (id) objectAtIndex:(NSInteger)idx;
+- (void) setObject:(id)aRule atIndex:(NSInteger)idx;
+- (void)addObject:(id)anObject;
+- (ANTLRMapElement *) getName:(NSString *)aName;
+- (void) putName:(NSString *)name Node:(id)aNode;
+
+- (NSEnumerator *)objectEnumerator;
+- (BOOL) hasNext;
+- (ANTLRMapElement *)nextObject;
+
+//@property (copy) TStringPool *fPool;
+@property (getter=getScope, setter=setScope:) NSInteger Scope;
+@property (getter=getLastHash, setter=setLastHash:) NSInteger LastHash;
+
+@property (getter=getMode,setter=setMode:) NSInteger mode;
+@property NSInteger BuffSize;
+@property (getter=getCount, setter=setCount:) NSUInteger count;
+@property (assign) NSUInteger ptr;
+@property (retain, getter=getBuffer, setter=setBuffer:) NSMutableData *buffer;
+@property (assign, getter=getPtrBuffer, setter=setPtrBuffer:) ANTLRMapElement **ptrBuffer;
+@end
diff --git a/runtime/ObjC/Framework/HashMap.m b/runtime/ObjC/Framework/HashMap.m
new file mode 100644
index 0000000..ab025a9
--- /dev/null
+++ b/runtime/ObjC/Framework/HashMap.m
@@ -0,0 +1,529 @@
+//
+//  ANTLRHashMap.m
+//  ANTLR
+//
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#define SUCCESS (0)
+#define FAILURE (-1)
+
+#import "ANTLRHashMap.h"
+
+static NSInteger itIndex;
+
+/*
+ * Start of ANTLRHashMap
+ */
+@implementation ANTLRHashMap
+
+@synthesize Scope;
+@synthesize LastHash;
+
++(id)newANTLRHashMap
+{
+    return [[ANTLRHashMap alloc] init];
+}
+
++(id)newANTLRHashMapWithLen:(NSInteger)aBuffSize
+{
+    return [[ANTLRHashMap alloc] initWithLen:aBuffSize];
+}
+
+-(id)init
+{
+    NSInteger idx;
+
+    if ((self = [super init]) != nil) {
+        fNext = nil;
+        Scope = 0;
+        ptr = 0;
+        BuffSize = HASHSIZE;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
+        ptrBuffer = (ANTLRMapElement **) [buffer mutableBytes];
+        if ( fNext != nil ) {
+            Scope = ((ANTLRHashMap *)fNext)->Scope+1;
+            for( idx = 0; idx < BuffSize; idx++ ) {
+                ptrBuffer[idx] = ((ANTLRHashMap *)fNext)->ptrBuffer[idx];
+            }
+        }
+        mode = 0;
+    }
+    return( self );
+}
+
+-(id)initWithLen:(NSInteger)aBuffSize
+{
+    NSInteger idx;
+
+    if ((self = [super init]) != nil) {
+        fNext = nil;
+        BuffSize = aBuffSize;
+        Scope = 0;
+        ptr = 0;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
+        ptrBuffer = (ANTLRMapElement **) [buffer mutableBytes];
+        if ( fNext != nil ) {
+            Scope = ((ANTLRHashMap *)fNext)->Scope+1;
+            for( idx = 0; idx < BuffSize; idx++ ) {
+                ptrBuffer[idx] = ((ANTLRHashMap *)fNext)->ptrBuffer[idx];
+            }
+        }
+        mode = 0;
+    }
+    return( self );
+}
+
+-(void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRHashMap" );
+#endif
+    ANTLRMapElement *tmp, *rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            tmp = ptrBuffer[idx];
+            while ( tmp && tmp != [((ANTLRHashMap *)fNext) getptrBufferEntry:idx] ) {
+                rtmp = tmp;
+                // tmp = [tmp getfNext];
+                tmp = (ANTLRMapElement *)tmp.fNext;
+                [rtmp release];
+            }
+        }
+    }
+    if ( buffer ) [buffer release];
+    [super dealloc];
+}
+
+- (NSInteger)count
+{
+    NSInteger aCnt = 0;
+
+    for (NSInteger i = 0; i < BuffSize; i++) {
+        if ( ptrBuffer[i] != nil ) {
+            aCnt++;
+        }
+    }
+    return aCnt;
+}
+
+- (NSInteger) size
+{
+    NSInteger aSize = 0;
+
+    for (NSInteger i = 0; i < BuffSize; i++) {
+        if ( ptrBuffer[i] != nil ) {
+            aSize += sizeof(id);
+        }
+    }
+    return aSize;
+}
+
+
+-(void)deleteANTLRHashMap:(ANTLRMapElement *)np
+{
+    ANTLRMapElement *tmp, *rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            tmp = ptrBuffer[idx];
+            while ( tmp && tmp != (ANTLRLinkBase *)[((ANTLRHashMap *)fNext) getptrBufferEntry:idx] ) {
+                rtmp = tmp;
+                tmp = [tmp getfNext];
+                [rtmp release];
+            }
+        }
+    }
+}
+
+-(ANTLRHashMap *)PushScope:(ANTLRHashMap **)map
+{
+    NSInteger idx;
+    ANTLRHashMap *htmp;
+
+    htmp = [ANTLRHashMap newANTLRHashMap];
+    if ( *map != nil ) {
+        ((ANTLRHashMap *)htmp)->fNext = *map;
+        [htmp setScope:[((ANTLRHashMap *)htmp->fNext) getScope]+1];
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            htmp->ptrBuffer[idx] = ((ANTLRHashMap *)htmp->fNext)->ptrBuffer[idx];
+        }
+    }
+    //    gScopeLevel++;
+    *map = htmp;
+    return( htmp );
+}
+
+-(ANTLRHashMap *)PopScope:(ANTLRHashMap **)map
+{
+    NSInteger idx;
+    ANTLRMapElement *tmp;
+    ANTLRHashMap *htmp;
+
+    htmp = *map;
+    if ( (*map)->fNext != nil ) {
+        *map = (ANTLRHashMap *)htmp->fNext;
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            if ( htmp->ptrBuffer[idx] == nil ||
+                htmp->ptrBuffer[idx] == (*map)->ptrBuffer[idx] ) {
+                break;
+            }
+            tmp = htmp->ptrBuffer[idx];
+            /*
+             * must deal with parms, locals and labels at some point
+             * can not forget the debuggers
+             */
+            htmp->ptrBuffer[idx] = [tmp getfNext];
+            [tmp release];
+        }
+        *map = (ANTLRHashMap *)htmp->fNext;
+        //        gScopeLevel--;
+    }
+    return( htmp );
+}
+
+#ifdef USERDOC
+/*
+ *  HASH        hash entry to get index to table
+ *  NSInteger hash( ANTLRHashMap *self, char *s );
+ *
+ *     Inputs:  char *s             string to find
+ *
+ *     Returns: NSInteger                 hashed value
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(NSInteger)hash:(NSString *)s       /*    form hash value for string s */
+{
+    NSInteger hashval;
+    const char *tmp;
+
+    tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
+    for( hashval = 0; *tmp != '\0'; )
+        hashval += *tmp++;
+    self->LastHash = hashval % BuffSize;
+    return( self->LastHash );
+}
+
+#ifdef USERDOC
+/*
+ *  FINDSCOPE  search hashed list for entry
+ *  ANTLRHashMap *findscope( ANTLRHashMap *self, NSInteger scope );
+ *
+ *     Inputs:  NSInteger       scope -- scope level to find
+ *
+ *     Returns: ANTLRHashMap   pointer to ptrBuffer of proper scope level
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(ANTLRHashMap *)findscope:(NSInteger)scope
+{
+    if ( self->Scope == scope ) {
+        return( self );
+    }
+    else if ( fNext ) {
+        return( [((ANTLRHashMap *)fNext) findscope:scope] );
+    }
+    return( nil );              /*   not found      */
+}
+
+#ifdef USERDOC
+/*
+ *  LOOKUP  search hashed list for entry
+ *  ANTLRMapElement *lookup( ANTLRHashMap *self, char *s, NSInteger scope );
+ *
+ *     Inputs:  char     *s          string to find
+ *
+ *     Returns: ANTLRMapElement  *           pointer to entry
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(id)lookup:(NSString *)s Scope:(NSInteger)scope
+{
+    ANTLRMapElement *np;
+
+    for( np = self->ptrBuffer[[self hash:s]]; np != nil; np = [np getfNext] ) {
+        if ( [s isEqualToString:[np getName]] ) {
+            return( np );        /*   found it       */
+        }
+    }
+    return( nil );              /*   not found      */
+}
+
+#ifdef USERDOC
+/*
+ *  INSTALL search hashed list for entry
+ *  NSInteger install( ANTLRHashMap *self, ANTLRMapElement *sym, NSInteger scope );
+ *
+ *     Inputs:  ANTLRMapElement    *sym   -- symbol ptr to install
+ *              NSInteger         scope -- level to find
+ *
+ *     Returns: Boolean     TRUE   if installed
+ *                          FALSE  if already in table
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(ANTLRMapElement *)install:(ANTLRMapElement *)sym Scope:(NSInteger)scope
+{
+    ANTLRMapElement *np;
+
+    np = [self lookup:[sym getName] Scope:scope ];
+    if ( np == nil ) {
+        [sym retain];
+        [sym setFNext:self->ptrBuffer[ self->LastHash ]];
+        self->ptrBuffer[ self->LastHash ] = sym;
+        return( self->ptrBuffer[ self->LastHash ] );
+    }
+    return( nil );            /*   not found      */
+}
+
+#ifdef USERDOC
+/*
+ *  RemoveSym  search hashed list for entry
+ *  NSInteger RemoveSym( ANTLRHashMap *self, char *s );
+ *
+ *     Inputs:  char     *s          string to find
+ *
+ *     Returns: NSInteger      indicator of SUCCESS OR FAILURE
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(NSInteger)RemoveSym:(NSString *)s
+{
+    ANTLRMapElement *np, *tmp;
+    NSInteger idx;
+
+    idx = [self hash:s];
+    for ( tmp = self->ptrBuffer[idx], np = self->ptrBuffer[idx]; np != nil; np = [np getfNext] ) {
+        if ( [s isEqualToString:[np getName]] ) {
+            tmp = [np getfNext];             /* get the next link  */
+            [np release];
+            return( SUCCESS );            /* report SUCCESS     */
+        }
+        tmp = [np getfNext];              //  BAD!!!!!!
+    }
+    return( FAILURE );                    /*   not found      */
+}
+
+-(void)delete_chain:(ANTLRMapElement *)np
+{
+    if ( [np getfNext] != nil )
+        [self delete_chain:[np getfNext]];
+    [np dealloc];
+}
+
+#ifdef DONTUSEYET
+-(NSInteger)bld_symtab:(KW_TABLE *)toknams
+{
+    NSInteger i;
+    ANTLRMapElement *np;
+
+    for( i = 0; *(toknams[i].name) != '\0'; i++ ) {
+        // install symbol in ptrBuffer
+        np = [ANTLRMapElement newANTLRMapElement:[NSString stringWithFormat:@"%s", toknams[i].name]];
+        //        np->fType = toknams[i].toknum;
+        [self install:np Scope:0];
+    }
+    return( SUCCESS );
+}
+#endif
+
+-(ANTLRMapElement *)getptrBufferEntry:(NSInteger)idx
+{
+    return( ptrBuffer[idx] );
+}
+
+-(ANTLRMapElement **)getptrBuffer
+{
+    return( ptrBuffer );
+}
+
+-(void)setptrBuffer:(ANTLRMapElement *)np Index:(NSInteger)idx
+{
+    if ( idx < BuffSize ) {
+        [np retain];
+        ptrBuffer[idx] = np;
+    }
+}
+
+-(NSInteger)getScope
+{
+    return( Scope );
+}
+
+-(void)setScopeScope:(NSInteger)i
+{
+    Scope = i;
+}
+
+- (ANTLRMapElement *)getTType:(NSString *)name
+{
+    return [self lookup:name Scope:0];
+}
+
+/*
+ * works only for maplist indexed not by name but by TokenNumber
+ */
+- (ANTLRMapElement *)getNameInList:(NSInteger)ttype
+{
+    ANTLRMapElement *np;
+    NSInteger aTType;
+
+    aTType = ttype % BuffSize;
+    for( np = self->ptrBuffer[aTType]; np != nil; np = [np getfNext] ) {
+        if ( [(NSNumber *)np.node integerValue] == ttype ) {
+            return( np );        /*   found it       */
+        }
+    }
+    return( nil );              /*   not found      */
+}
+
+- (ANTLRLinkBase *)getName:(NSString *)name
+{
+    return [self lookup:name Scope:0]; /*  nil if not found      */
+}
+
+- (void)putNode:(NSString *)name TokenType:(NSInteger)ttype
+{
+    ANTLRMapElement *np;
+
+    // install symbol in ptrBuffer
+    np = [ANTLRMapElement newANTLRMapElementWithName:[NSString stringWithString:name] Type:ttype];
+    //        np->fType = toknams[i].toknum;
+    [self install:np Scope:0];
+}
+
+- (NSInteger)getMode
+{
+    return mode;
+}
+
+- (void)setMode:(NSInteger)aMode
+{
+    mode = aMode;
+}
+
+- (void) addObject:(id)aRule
+{
+    NSInteger idx;
+
+    idx = [self count];
+    if ( idx >= BuffSize ) {
+        idx %= BuffSize;
+    }
+    ptrBuffer[idx] = aRule;
+}
+
+/* this may have to handle linking into the chain
+ */
+- (void) insertObject:(id)aRule atIndex:(NSInteger)idx
+{
+    if ( idx >= BuffSize ) {
+        idx %= BuffSize;
+    }
+    if ( aRule != ptrBuffer[idx] ) {
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
+        [aRule retain];
+    }
+    ptrBuffer[idx] = aRule;
+}
+
+- (id)objectAtIndex:(NSInteger)idx
+{
+    if ( idx >= BuffSize ) {
+        idx %= BuffSize;
+    }
+    return ptrBuffer[idx];
+}
+
+/* this will never link into the chain
+ */
+- (void) setObject:(id)aRule atIndex:(NSInteger)idx
+{
+    if ( idx >= BuffSize ) {
+        idx %= BuffSize;
+    }
+    if ( aRule != ptrBuffer[idx] ) {
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
+        [aRule retain];
+    }
+    ptrBuffer[idx] = aRule;
+}
+
+- (void)putName:(NSString *)name Node:(id)aNode
+{
+    ANTLRMapElement *np;
+
+    np = [self lookup:name Scope:0 ];
+    if ( np == nil ) {
+        np = [ANTLRMapElement newANTLRMapElementWithName:name Node:aNode];
+        if ( ptrBuffer[LastHash] )
+            [ptrBuffer[LastHash] release];
+        [np retain];
+        np.fNext = ptrBuffer[ LastHash ];
+        ptrBuffer[ LastHash ] = np;
+    }
+    return;
+}
+
+- (NSEnumerator *)objectEnumerator
+{
+#pragma mark fix this its broken
+    NSEnumerator *anEnumerator;
+
+    itIndex = 0;
+    return anEnumerator;
+}
+
+- (BOOL)hasNext
+{
+    if (self && [self count] < BuffSize-1) {
+        return YES;
+    }
+    return NO;
+}
+
+- (ANTLRMapElement *)nextObject
+{
+    if (self && itIndex < BuffSize-1) {
+        return ptrBuffer[itIndex];
+    }
+    return nil;
+}
+
+@synthesize BuffSize;
+@synthesize count;
+@synthesize ptr;
+@synthesize ptrBuffer;
+@synthesize buffer;
+@end
diff --git a/runtime/ObjC/Framework/HashRule.h b/runtime/ObjC/Framework/HashRule.h
new file mode 100644
index 0000000..75ef581
--- /dev/null
+++ b/runtime/ObjC/Framework/HashRule.h
@@ -0,0 +1,70 @@
+//
+//  ANTLRHashRule.h
+//  ANTLR
+//
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRuleMemo.h"
+#import "ANTLRPtrBuffer.h"
+
+#define GLOBAL_SCOPE       0
+#define LOCAL_SCOPE        1
+#define HASHSIZE         101
+#define HBUFSIZE      0x2000
+
+@interface ANTLRHashRule : ANTLRPtrBuffer {
+    //    TStringPool *fPool;
+    NSInteger LastHash;
+    NSInteger mode;
+}
+
+// Contruction/Destruction
++ (id)newANTLRHashRule;
++ (id)newANTLRHashRuleWithLen:(NSInteger)aBuffSize;
+- (id)init;
+- (id)initWithLen:(NSInteger)aBuffSize;
+- (void)dealloc;
+
+- (NSInteger)count;
+- (NSInteger)length;
+- (NSInteger)size;
+
+// Instance Methods
+- (void)deleteANTLRHashRule:(ANTLRRuleMemo *)np;
+- (void)delete_chain:(ANTLRRuleMemo *)np;
+- (ANTLRRuleMemo **)getPtrBuffer;
+- (void)setPtrBuffer:(ANTLRRuleMemo **)np;
+- (NSNumber *)getRuleMemoStopIndex:(NSInteger)aStartIndex;
+- (void)putRuleMemoAtStartIndex:(NSInteger)aStartIndex StopIndex:(NSInteger)aStopIndex;
+- (NSInteger)getMode;
+- (void)setMode:(NSInteger)aMode;
+- (void) insertObject:(ANTLRRuleMemo *)aRule atIndex:(NSInteger)Index;
+- (ANTLRRuleMemo *) objectAtIndex:(NSInteger)Index;
+
+@property (getter=getLastHash, setter=setLastHash:) NSInteger LastHash;
+@property (getter=getMode,setter=setMode:) NSInteger mode;
+@end
diff --git a/runtime/ObjC/Framework/HashRule.m b/runtime/ObjC/Framework/HashRule.m
new file mode 100644
index 0000000..3bca78f
--- /dev/null
+++ b/runtime/ObjC/Framework/HashRule.m
@@ -0,0 +1,279 @@
+//
+//  ANTLRHashRule.m
+//  ANTLR
+//
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#define SUCCESS (0)
+#define FAILURE (-1)
+#define ANTLR_MEMO_RULE_UNKNOWN -1
+
+#import "ANTLRHashRule.h"
+
+/*
+ * Start of ANTLRHashRule
+ */
+@implementation ANTLRHashRule
+
+@synthesize LastHash;
+
++(id)newANTLRHashRule
+{
+    return [[ANTLRHashRule alloc] init];
+}
+
++(id)newANTLRHashRuleWithLen:(NSInteger)aBuffSize
+{
+    return [[ANTLRHashRule alloc] initWithLen:aBuffSize];
+}
+
+-(id)init
+{
+    self = [super initWithLen:HASHSIZE];
+    if ( self != nil ) {
+    }
+    return( self );
+}
+
+-(id)initWithLen:(NSInteger)aBuffSize
+{
+    self = [super initWithLen:aBuffSize];
+    if ( self != nil ) {
+        mode = 0;
+    }
+    return( self );
+}
+
+-(void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRHashRule" );
+#endif
+    ANTLRRuleMemo *tmp, *rtmp;
+    int Index;
+
+    if ( self.fNext != nil ) {
+        for( Index = 0; Index < BuffSize; Index++ ) {
+            tmp = ptrBuffer[Index];
+            while ( tmp && tmp != ptrBuffer[Index] ) {
+                rtmp = tmp;
+                if ([tmp isKindOfClass:[ANTLRLinkBase class]])
+                    tmp = (ANTLRRuleMemo *)tmp.fNext;
+                else
+                    tmp = nil;
+                [rtmp dealloc];
+            }
+        }
+    }
+    [super dealloc];
+}
+
+- (NSInteger)count
+{
+    NSInteger aCnt = 0;
+
+    for (int i = 0; i < BuffSize; i++) {
+        if ( ptrBuffer[i] != nil ) {
+            aCnt++;
+        }
+    }
+    return aCnt;
+}
+
+- (NSInteger) length
+{
+    return BuffSize;
+}
+
+- (NSInteger) size
+{
+    NSInteger aSize = 0;
+
+    for (int i = 0; i < BuffSize; i++) {
+        if ( ptrBuffer[i] != nil ) {
+            aSize += sizeof(id);
+        }
+    }
+    return aSize;
+}
+
+
+-(void)deleteANTLRHashRule:(ANTLRRuleMemo *)np
+{
+    ANTLRRuleMemo *tmp, *rtmp;
+    int Index;
+
+    if ( self.fNext != nil ) {
+        for( Index = 0; Index < BuffSize; Index++ ) {
+            tmp = ptrBuffer[Index];
+            while ( tmp && tmp != ptrBuffer[Index ] ) {
+                rtmp = tmp;
+                if ([tmp isKindOfClass:[ANTLRLinkBase class]])
+                    tmp = (ANTLRRuleMemo *)tmp.fNext;
+                else
+                    tmp = nil;
+                [rtmp release];
+            }
+        }
+    }
+}
+
+-(void)delete_chain:(ANTLRRuleMemo *)np
+{
+    if ( np.fNext != nil )
+        [self delete_chain:np.fNext];
+    [np dealloc];
+}
+
+-(ANTLRRuleMemo **)getPtrBuffer
+{
+    return( ptrBuffer );
+}
+
+-(void)setPtrBuffer:(ANTLRRuleMemo **)np
+{
+    ptrBuffer = np;
+}
+
+- (NSNumber *)getRuleMemoStopIndex:(NSInteger)aStartIndex
+{
+    ANTLRRuleMemo *aRule;
+    NSNumber *stopIndex;
+    NSInteger anIndex;
+
+    anIndex = ( aStartIndex >= BuffSize ) ? aStartIndex % BuffSize : aStartIndex;
+    if ((aRule = ptrBuffer[anIndex]) == nil) {
+        return nil;
+    }
+    stopIndex = [aRule getStopIndex:aStartIndex];
+    return stopIndex;
+}
+
+- (void)putRuleMemo:(ANTLRRuleMemo *)aRule AtStartIndex:(NSInteger)aStartIndex
+{
+    NSInteger anIndex;
+
+    anIndex = (aStartIndex >= BuffSize) ? aStartIndex %= BuffSize : aStartIndex;
+    if ( ptrBuffer[anIndex] == nil ) {
+        ptrBuffer[anIndex] = aRule;
+        [aRule retain];
+    }
+    else {
+        do {
+            if ( [aRule.startIndex integerValue] == aStartIndex ) {
+                [aRule setStartIndex:aRule.stopIndex];
+                return;
+            }
+            aRule = aRule.fNext;
+        } while ( aRule != nil );
+    }
+}
+
+- (void)putRuleMemoAtStartIndex:(NSInteger)aStartIndex StopIndex:(NSInteger)aStopIndex
+{
+    ANTLRRuleMemo *aRule, *newRule;
+    NSInteger anIndex;
+    NSInteger aMatchIndex;
+
+    anIndex = (aStartIndex >= BuffSize) ? aStartIndex % BuffSize : aStartIndex;
+    aRule = ptrBuffer[anIndex];
+    if ( aRule == nil ) {
+        aRule = [ANTLRRuleMemo newANTLRRuleMemoWithStartIndex:[NSNumber numberWithInteger:aStartIndex]
+                                                    StopIndex:[NSNumber numberWithInteger:aStopIndex]];
+        [aRule retain];
+        ptrBuffer[anIndex] = aRule;
+    }
+    else {
+        aMatchIndex = [aRule.startIndex integerValue];
+        if ( aStartIndex > aMatchIndex ) {
+            if ( aRule != ptrBuffer[anIndex] ) {
+                [aRule retain];
+            }
+            aRule.fNext = ptrBuffer[anIndex];
+            ptrBuffer[anIndex] = aRule;
+            return;
+        }
+        while (aRule.fNext != nil) {
+            aMatchIndex = [((ANTLRRuleMemo *)aRule.fNext).startIndex integerValue];
+            if ( aStartIndex > aMatchIndex ) {
+                newRule = [ANTLRRuleMemo newANTLRRuleMemoWithStartIndex:[NSNumber numberWithInteger:aStartIndex]
+                                                              StopIndex:[NSNumber numberWithInteger:aStopIndex]];
+                [newRule retain];
+                newRule.fNext = aRule.fNext;
+                aRule.fNext = newRule;
+                return;
+            }
+            if ( aMatchIndex == aStartIndex ) {
+                [aRule setStartIndex:aRule.stopIndex];
+                return;
+            }
+            aRule = aRule.fNext;
+        }
+    }
+}
+
+- (NSInteger)getLastHash
+{
+    return LastHash;
+}
+
+- (void)setLastHash:(NSInteger)aHash
+{
+    LastHash = aHash;
+}
+
+- (NSInteger)getMode
+{
+    return mode;
+}
+
+- (void)setMode:(NSInteger)aMode
+{
+    mode = aMode;
+}
+
+- (void) insertObject:(ANTLRRuleMemo *)aRule atIndex:(NSInteger)anIndex
+{
+    NSInteger Index;
+
+    Index = ( anIndex >= BuffSize ) ? anIndex % BuffSize : anIndex;
+    if (aRule != ptrBuffer[Index]) {
+        if ( ptrBuffer[Index] ) [ptrBuffer[Index] release];
+        [aRule retain];
+    }
+    ptrBuffer[Index] = aRule;
+}
+
+- (ANTLRRuleMemo *)objectAtIndex:(NSInteger)anIndex
+{
+    NSInteger anIdx;
+
+    anIdx = ( anIndex >= BuffSize ) ? anIndex % BuffSize : anIndex;
+    return ptrBuffer[anIdx];
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/IntArray.h b/runtime/ObjC/Framework/IntArray.h
new file mode 100644
index 0000000..9182377
--- /dev/null
+++ b/runtime/ObjC/Framework/IntArray.h
@@ -0,0 +1,74 @@
+//
+//  ANTLRIntArray.h
+//  ANTLR
+//
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+
+#define ANTLR_INT_ARRAY_INITIAL_SIZE 10
+
+@interface ANTLRIntArray : NSObject
+{
+    NSUInteger BuffSize;
+    NSUInteger count;
+    NSInteger idx;
+    NSMutableData *buffer;
+    __strong NSInteger *intBuffer;
+    BOOL SPARSE;
+}
+
++ (ANTLRIntArray *)newArray;
++ (ANTLRIntArray *)newArrayWithLen:(NSUInteger)aLen;
+
+- (id) init;
+- (id) initWithLen:(NSUInteger)aLen;
+
+- (void) dealloc;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (void) addInteger:(NSInteger) value;
+- (NSInteger) pop;
+- (void) push:(NSInteger) value;
+- (NSInteger) integerAtIndex:(NSUInteger) index;
+- (void) insertInteger:(NSInteger)anInteger AtIndex:(NSUInteger) anIndex;
+- (NSInteger)removeIntegerAtIndex:(NSUInteger) anIndex;
+- (void)replaceInteger:(NSInteger)aValue AtIndex:(NSUInteger)anIndex;
+- (void) reset;
+
+- (NSUInteger) count;
+- (NSUInteger) size;
+- (void) ensureCapacity:(NSUInteger) anIndex;
+
+@property (assign) NSUInteger BuffSize;
+@property (assign) NSUInteger count;
+@property (assign) NSInteger idx;
+@property (retain) NSMutableData *buffer;
+@property (assign) NSInteger *intBuffer;
+@property (assign) BOOL SPARSE;
+
+@end
diff --git a/runtime/ObjC/Framework/IntArray.m b/runtime/ObjC/Framework/IntArray.m
new file mode 100644
index 0000000..f715372
--- /dev/null
+++ b/runtime/ObjC/Framework/IntArray.m
@@ -0,0 +1,199 @@
+//
+//  ANTLRIntArray.m
+//  ANTLR
+//
+//  Created by Ian Michell on 27/04/2010.
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRIntArray.h"
+#import "ANTLRRuntimeException.h"
+
+@implementation ANTLRIntArray
+
+@synthesize BuffSize;
+@synthesize count;
+@synthesize idx;
+@synthesize buffer;
+@synthesize intBuffer;
+@synthesize SPARSE;
+
++ (ANTLRIntArray *)newArray
+{
+    return [[ANTLRIntArray alloc] init];
+}
+
++ (ANTLRIntArray *)newArrayWithLen:(NSUInteger)aLen
+{
+    return [[ANTLRIntArray alloc] initWithLen:aLen];
+}
+
+- (id)init
+{
+    self = [super init];
+    if ( self != nil ) {
+        BuffSize  = (ANTLR_INT_ARRAY_INITIAL_SIZE * (sizeof(NSInteger)/sizeof(id)));
+        count = 0;
+        idx = -1;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
+        intBuffer = (NSInteger *)[buffer mutableBytes];
+        SPARSE = NO;
+    }
+    return self;
+}
+
+- (id)initWithLen:(NSUInteger)aLen
+{
+    self = [super init];
+    if ( self != nil ) {
+        BuffSize  = (ANTLR_INT_ARRAY_INITIAL_SIZE * (sizeof(NSInteger)/sizeof(id)));
+        count = 0;
+        idx = -1;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
+        intBuffer = (NSInteger *)[buffer mutableBytes];
+        SPARSE = NO;
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRIntArray" );
+#endif
+    if ( buffer ) [buffer release];
+    [super dealloc];
+}
+
+- (id)copyWithZone:(NSZone *)aZone
+{
+    ANTLRIntArray *copy;
+
+    copy = [[[self class] alloc] initWithLen:BuffSize];
+    copy.idx = self.idx;
+    NSInteger anIndex;
+    for ( anIndex = 0; anIndex < BuffSize; anIndex++ ) {
+        [copy addInteger:intBuffer[anIndex]];
+    }
+    return copy;
+}
+
+- (NSUInteger)count
+{
+    return count;
+}
+
+// FIXME: Java runtime returns p, I'm not so sure it's right so have added p + 1 to show true size!
+- (NSUInteger)size
+{
+    if ( count > 0 )
+        return ( count * sizeof(NSInteger));
+    return 0;
+}
+
+- (void)addInteger:(NSInteger) value
+{
+    [self ensureCapacity:idx+1];
+    intBuffer[++idx] = (NSInteger) value;
+    count++;
+}
+
+- (NSInteger)pop
+{
+    if ( idx < 0 ) {
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Nothing to pop, count = %d", count]];
+    }
+    NSInteger value = (NSInteger) intBuffer[idx--];
+    count--;
+    return value;
+}
+
+- (void)push:(NSInteger)aValue
+{
+    [self addInteger:aValue];
+}
+
+- (NSInteger)integerAtIndex:(NSUInteger) anIndex
+{
+    if ( SPARSE==NO  && anIndex > idx ) {
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than count %d", anIndex, count]];
+    }
+    else if ( SPARSE == YES && anIndex >= BuffSize ) {
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than BuffSize %d", anIndex, BuffSize]];
+    }
+    return intBuffer[anIndex];
+}
+
+- (void)insertInteger:(NSInteger)aValue AtIndex:(NSUInteger)anIndex
+{
+    [self replaceInteger:aValue AtIndex:anIndex];
+    count++;
+}
+
+- (NSInteger)removeIntegerAtIndex:(NSUInteger) anIndex
+{
+    if ( SPARSE==NO && anIndex > idx ) {
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than count %d", anIndex, count]];
+        return (NSInteger)-1;
+    } else if ( SPARSE==YES && anIndex >= BuffSize ) {
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than BuffSize %d", anIndex, BuffSize]];
+    }
+    count--;
+    return intBuffer[anIndex];
+}
+
+- (void)replaceInteger:(NSInteger)aValue AtIndex:(NSUInteger)anIndex
+{
+    if ( SPARSE == NO && anIndex > idx ) {
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than count %d", anIndex, count]];
+    }
+    else if ( SPARSE == YES && anIndex >= BuffSize ) {
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"Index %d must be less than BuffSize %d", anIndex, BuffSize]];
+    }
+    intBuffer[anIndex] = aValue;
+}
+
+-(void) reset
+{
+    count = 0;
+    idx = -1;
+}
+
+- (void) ensureCapacity:(NSUInteger) anIndex
+{
+    if ( (anIndex * sizeof(NSUInteger)) >= [buffer length] )
+    {
+        NSUInteger newSize = ([buffer length] / sizeof(NSInteger)) * 2;
+        if (anIndex > newSize) {
+            newSize = anIndex + 1;
+        }
+        BuffSize = newSize;
+        [buffer setLength:(BuffSize * sizeof(NSUInteger))];
+        intBuffer = (NSInteger *)[buffer mutableBytes];
+    }
+}
+
+@end
+
diff --git a/runtime/ObjC/Framework/Lexer.h b/runtime/ObjC/Framework/Lexer.h
new file mode 100644
index 0000000..cd985cc
--- /dev/null
+++ b/runtime/ObjC/Framework/Lexer.h
@@ -0,0 +1,90 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTokenSource.h"
+#import "ANTLRBaseRecognizer.h"
+#import "ANTLRRecognizerSharedState.h"
+#import "ANTLRCharStream.h"
+#import "ANTLRToken.h"
+#import "ANTLRCommonToken.h"
+#import "ANTLRRecognitionException.h"
+#import "ANTLRMismatchedTokenException.h"
+#import "ANTLRMismatchedRangeException.h"
+
+@interface ANTLRLexer : ANTLRBaseRecognizer <ANTLRTokenSource> {
+	id<ANTLRCharStream> input;      ///< The character stream we pull tokens out of.
+	NSUInteger ruleNestingLevel;
+}
+
+@property (retain, getter=input, setter=setInput:) id<ANTLRCharStream> input;
+@property (getter=getRuleNestingLevel, setter=setRuleNestingLevel:) NSUInteger ruleNestingLevel;
+
+#pragma mark Initializer
+- (id) initWithCharStream:(id<ANTLRCharStream>) anInput;
+- (id) initWithCharStream:(id<ANTLRCharStream>)anInput State:(ANTLRRecognizerSharedState *)state;
+
+- (id) copyWithZone:(NSZone *)zone;
+
+- (void) reset;
+
+// - (ANTLRRecognizerSharedState *) state;
+
+#pragma mark Tokens
+- (id<ANTLRToken>)getToken;
+- (void) setToken: (id<ANTLRToken>) aToken;
+- (id<ANTLRToken>) nextToken;
+- (void) mTokens;		// abstract, defined in generated sources
+- (void) skip;
+- (id<ANTLRCharStream>) input;
+- (void) setInput:(id<ANTLRCharStream>)aCharStream;
+
+- (void) emit;
+- (void) emit:(id<ANTLRToken>)aToken;
+
+#pragma mark Matching
+- (void) matchString:(NSString *)aString;
+- (void) matchAny;
+- (void) matchChar:(unichar) aChar;
+- (void) matchRangeFromChar:(unichar)fromChar to:(unichar)toChar;
+
+#pragma mark Informational
+- (NSUInteger) line;
+- (NSUInteger) charPositionInLine;
+- (NSInteger) index;
+- (NSString *) text;
+- (void) setText:(NSString *) theText;
+
+// error handling
+- (void) reportError:(ANTLRRecognitionException *)e;
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)tokenNames;
+- (NSString *)getCharErrorDisplay:(NSInteger)c;
+- (void) recover:(ANTLRRecognitionException *)e;
+- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex;
+- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex;
+
+@end
diff --git a/runtime/ObjC/Framework/Lexer.m b/runtime/ObjC/Framework/Lexer.m
new file mode 100644
index 0000000..de1a0a3
--- /dev/null
+++ b/runtime/ObjC/Framework/Lexer.m
@@ -0,0 +1,428 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <ANTLR/antlr.h>
+#import "ANTLRLexer.h"
+
+@implementation ANTLRLexer
+
+@synthesize input;
+@synthesize ruleNestingLevel;
+#pragma mark Initializer
+
+- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
+{
+	self = [super initWithState:[[ANTLRRecognizerSharedState alloc] init]];
+	if ( self != nil ) {
+        input = [anInput retain];
+        if (state.token != nil)
+            [((ANTLRCommonToken *)state.token) setInput:anInput];
+		ruleNestingLevel = 0;
+	}
+	return self;
+}
+
+- (id) initWithCharStream:(id<ANTLRCharStream>)anInput State:(ANTLRRecognizerSharedState *)aState
+{
+	self = [super initWithState:aState];
+	if ( self != nil ) {
+        input = [anInput retain];
+        if (state.token != nil)
+            [((ANTLRCommonToken *)state.token) setInput:anInput];
+		ruleNestingLevel = 0;
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+    if ( input ) [input release];
+    [super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRLexer *copy;
+
+    copy = [[[self class] allocWithZone:aZone] init];
+    //    copy = [super copyWithZone:aZone]; // allocation occurs here
+    if ( input != nil )
+        copy.input = input;
+    copy.ruleNestingLevel = ruleNestingLevel;
+    return copy;
+}
+
+- (void) reset
+{
+    [super reset]; // reset all recognizer state variables
+                   // wack Lexer state variables
+    if ( input != nil ) {
+        [input seek:0]; // rewind the input
+    }
+    if ( state == nil ) {
+        return; // no shared state work to do
+    }
+    state.token = nil;
+    state.type = ANTLRCommonToken.INVALID_TOKEN_TYPE;
+    state.channel = ANTLRCommonToken.DEFAULT_CHANNEL;
+    state.tokenStartCharIndex = -1;
+    state.tokenStartCharPositionInLine = -1;
+    state.tokenStartLine = -1;
+    state.text = nil;
+}
+
+// token stuff
+#pragma mark Tokens
+
+- (id<ANTLRToken>)getToken
+{
+    return [state getToken];
+}
+
+- (void) setToken: (id<ANTLRToken>) aToken
+{
+    if (state.token != aToken) {
+        [aToken retain];
+        state.token = aToken;
+    }
+}
+
+
+// this method may be overridden in the generated lexer if we generate a filtering lexer.
+- (id<ANTLRToken>) nextToken
+{
+	while (YES) {
+        [self setToken:nil];
+        state.channel = ANTLRCommonToken.DEFAULT_CHANNEL;
+        state.tokenStartCharIndex = input.index;
+        state.tokenStartCharPositionInLine = input.charPositionInLine;
+        state.tokenStartLine = input.line;
+        state.text = nil;
+
+        // [self setText:[self text]];
+		if ([input LA:1] == ANTLRCharStreamEOF) {
+            ANTLRCommonToken *eof = [ANTLRCommonToken newToken:input
+                                                          Type:ANTLRTokenTypeEOF
+                                                       Channel:ANTLRCommonToken.DEFAULT_CHANNEL
+                                                         Start:input.index
+                                                          Stop:input.index];
+            [eof setLine:input.line];
+            [eof setCharPositionInLine:input.charPositionInLine];
+			return eof;
+		}
+		@try {
+			[self mTokens];
+            // SEL aMethod = @selector(mTokens);
+            // [[self class] instancesRespondToSelector:aMethod];
+            if ( state.token == nil)
+                [self emit];
+            else if ( state.token == [ANTLRCommonToken skipToken] ) {
+                continue;
+            }
+			return state.token;
+		}
+		@catch (ANTLRNoViableAltException *nva) {
+			[self reportError:nva];
+			[self recover:nva];
+		}
+		@catch (ANTLRRecognitionException *e) {
+			[self reportError:e];
+		}
+	}
+}
+
+- (void) mTokens
+{   // abstract, defined in generated source as a starting point for matching
+    [self doesNotRecognizeSelector:_cmd];
+}
+
+- (void) skip
+{
+    state.token = [ANTLRCommonToken skipToken];
+}
+
+- (id<ANTLRCharStream>) input
+{
+    return input;
+}
+
+- (void) setInput:(id<ANTLRCharStream>) anInput
+{
+    if ( anInput != input ) {
+        if ( input ) [input release];
+    }
+    input = nil;
+    [self reset];
+    input = anInput;
+    [input retain];
+}
+
+/** Currently does not support multiple emits per nextToken invocation
+ *  for efficiency reasons.  Subclass and override this method and
+ *  nextToken (to push tokens into a list and pull from that list rather
+ *  than a single variable as this implementation does).
+ */
+- (void) emit:(id<ANTLRToken>)aToken
+{
+	state.token = aToken;
+}
+
+/** The standard method called to automatically emit a token at the
+ *  outermost lexical rule.  The token object should point into the
+ *  char buffer start..stop.  If there is a text override in 'text',
+ *  use that to set the token's text.  Override this method to emit
+ *  custom Token objects.
+ *
+ *  If you are building trees, then you should also override
+ *  Parser or TreeParser.getMissingSymbol().
+ */
+- (void) emit
+{
+	id<ANTLRToken> aToken = [ANTLRCommonToken newToken:input
+                                                  Type:state.type
+                                               Channel:state.channel
+                                                 Start:state.tokenStartCharIndex
+                                                  Stop:input.index-1];
+	[aToken setLine:state.tokenStartLine];
+    aToken.text = [self text];
+	[aToken setCharPositionInLine:state.tokenStartCharPositionInLine];
+    [aToken retain];
+	[self emit:aToken];
+	// [aToken release];
+}
+
+// matching
+#pragma mark Matching
+- (void) matchString:(NSString *)aString
+{
+    unichar c;
+	unsigned int i = 0;
+	unsigned int stringLength = [aString length];
+	while ( i < stringLength ) {
+		c = [input LA:1];
+        if ( c != [aString characterAtIndex:i] ) {
+			if ([state getBacktracking] > 0) {
+				state.failed = YES;
+				return;
+			}
+			ANTLRMismatchedTokenException *mte = [ANTLRMismatchedTokenException newExceptionChar:[aString characterAtIndex:i] Stream:input];
+            mte.c = c;
+			[self recover:mte];
+			@throw mte;
+		}
+		i++;
+		[input consume];
+		state.failed = NO;
+	}
+}
+
+- (void) matchAny
+{
+	[input consume];
+}
+
+- (void) matchChar:(unichar) aChar
+{
+	// TODO: -LA: is returning an int because it sometimes is used in the generated parser to compare lookahead with a tokentype.
+	//		 try to change all those occurrences to -LT: if possible (i.e. if ANTLR can be made to generate LA only for lexer code)
+    unichar charLA;
+	charLA = [input LA:1];
+	if ( charLA != aChar) {
+		if ([state getBacktracking] > 0) {
+			state.failed = YES;
+			return;
+		}
+		ANTLRMismatchedTokenException  *mte = [ANTLRMismatchedTokenException newExceptionChar:aChar Stream:input];
+        mte.c = charLA;
+		[self recover:mte];
+		@throw mte;
+	}
+	[input consume];
+	state.failed = NO;
+}
+
+- (void) matchRangeFromChar:(unichar)fromChar to:(unichar)toChar
+{
+	unichar charLA = (unichar)[input LA:1];
+	if ( charLA < fromChar || charLA > toChar ) {
+		if ([state getBacktracking] > 0) {
+			state.failed = YES;
+			return;
+		}
+		ANTLRMismatchedRangeException  *mre = [ANTLRMismatchedRangeException
+					newException:NSMakeRange((NSUInteger)fromChar,(NSUInteger)toChar)
+							   stream:input];
+        mre.c = charLA;
+		[self recover:mre];
+		@throw mre;
+	}
+	[input consume];
+	state.failed = NO;
+}
+
+	// info
+#pragma mark Informational
+
+- (NSUInteger) line
+{
+	return input.line;
+}
+
+- (NSUInteger) charPositionInLine
+{
+	return input.charPositionInLine;
+}
+
+- (NSInteger) index
+{
+    return 0;
+}
+
+- (NSString *) text
+{
+    if (state.text != nil) {
+        return state.text;
+    }
+	return [input substringWithRange:NSMakeRange(state.tokenStartCharIndex, input.index-state.tokenStartCharIndex)];
+}
+
+- (void) setText:(NSString *) theText
+{
+    state.text = theText;
+}
+
+	// error handling
+- (void) reportError:(ANTLRRecognitionException *)e
+{
+    /** TODO: not thought about recovery in lexer yet.
+     *
+     // if we've already reported an error and have not matched a token
+     // yet successfully, don't report any errors.
+     if ( errorRecovery ) {
+     //System.err.print("[SPURIOUS] ");
+     return;
+     }
+     errorRecovery = true;
+     */
+
+    [self displayRecognitionError:[self getTokenNames] Exception:e];
+}
+
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *)tokenNames
+{
+/*    NSString *msg = [NSString stringWithFormat:@"Gotta fix getErrorMessage in ANTLRLexer.m--%@\n",
+                     e.name];
+ */
+    NSString *msg = nil;
+    if ( [e isKindOfClass:[ANTLRMismatchedTokenException class]] ) {
+        ANTLRMismatchedTokenException *mte = (ANTLRMismatchedTokenException *)e;
+        msg = [NSString stringWithFormat:@"mismatched character \"%@\" expecting \"%@\"",
+               [self getCharErrorDisplay:mte.c], [self getCharErrorDisplay:mte.expecting]];
+    }
+    else if ( [e isKindOfClass:[ANTLRNoViableAltException class]] ) {
+        ANTLRNoViableAltException *nvae = (ANTLRNoViableAltException *)e;
+        // for development, can add "decision=<<"+nvae.grammarDecisionDescription+">>"
+        // and "(decision="+nvae.decisionNumber+") and
+        // "state "+nvae.stateNumber
+        msg = [NSString stringWithFormat:@"no viable alternative at character \"%@\"",
+               [self getCharErrorDisplay:(nvae.c)]];
+    }
+    else if ( [e isKindOfClass:[ANTLREarlyExitException class]] ) {
+        ANTLREarlyExitException *eee = (ANTLREarlyExitException *)e;
+        // for development, can add "(decision="+eee.decisionNumber+")"
+        msg = [NSString stringWithFormat:@"required (...)+ loop did not match anything at character \"%@\"",
+               [self getCharErrorDisplay:(eee.c)]];
+    }
+    else if ( [e isKindOfClass:[ANTLRMismatchedNotSetException class]] ) {
+        ANTLRMismatchedNotSetException *mse = (ANTLRMismatchedNotSetException *)e;
+        msg = [NSString stringWithFormat:@"mismatched character \"%@\"  expecting set \"%@\"",
+               [self getCharErrorDisplay:(mse.c)], mse.expecting];
+    }
+    else if ( [e isKindOfClass:[ANTLRMismatchedSetException class]] ) {
+        ANTLRMismatchedSetException *mse = (ANTLRMismatchedSetException *)e;
+        msg = [NSString stringWithFormat:@"mismatched character \"%@\" expecting set \"%@\"",
+               [self getCharErrorDisplay:(mse.c)], mse.expecting];
+    }
+    else if ( [e isKindOfClass:[ANTLRMismatchedRangeException class]] ) {
+        ANTLRMismatchedRangeException *mre = (ANTLRMismatchedRangeException *)e;
+        msg = [NSString stringWithFormat:@"mismatched character \"%@\" \"%@..%@\"",
+               [self getCharErrorDisplay:(mre.c)], [self getCharErrorDisplay:(mre.range.location)],
+               [self getCharErrorDisplay:(mre.range.location+mre.range.length-1)]];
+    }
+    else {
+        msg = [super getErrorMessage:e TokenNames:[self getTokenNames]];
+    }
+    return msg;
+}
+
+- (NSString *)getCharErrorDisplay:(NSInteger)c
+{
+    NSString *s;
+    switch ( c ) {
+        case ANTLRTokenTypeEOF :
+            s = @"<EOF>";
+            break;
+        case '\n' :
+            s = @"\\n";
+            break;
+        case '\t' :
+            s = @"\\t";
+            break;
+        case '\r' :
+            s = @"\\r";
+            break;
+        default:
+            s = [NSString stringWithFormat:@"%c", (char)c];
+            break;
+    }
+    return s;
+}
+
+/** Lexers can normally match any char in it's vocabulary after matching
+ *  a token, so do the easy thing and just kill a character and hope
+ *  it all works out.  You can instead use the rule invocation stack
+ *  to do sophisticated error recovery if you are in a fragment rule.
+ */
+- (void)recover:(ANTLRRecognitionException *)re
+{
+    //System.out.println("consuming char "+(char)input.LA(1)+" during recovery");
+    //re.printStackTrace();
+    [input consume];
+}
+
+- (void)traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex
+{
+    NSString *inputSymbol = [NSString stringWithFormat:@"%c line=%d:%d\n", [input LT:1], input.line, input.charPositionInLine];
+    [super traceIn:ruleName Index:ruleIndex Object:inputSymbol];
+}
+
+- (void)traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex
+{
+    NSString *inputSymbol = [NSString stringWithFormat:@"%c line=%d:%d\n", [input LT:1], input.line, input.charPositionInLine];
+    [super traceOut:ruleName Index:ruleIndex Object:inputSymbol];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/LexerRuleReturnScope.h b/runtime/ObjC/Framework/LexerRuleReturnScope.h
new file mode 100644
index 0000000..27b8abc
--- /dev/null
+++ b/runtime/ObjC/Framework/LexerRuleReturnScope.h
@@ -0,0 +1,43 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+
+@interface ANTLRLexerRuleReturnScope : NSObject {
+	NSInteger start;
+	NSInteger stopToken;
+}
+
+- (NSInteger) getStart;
+- (void) setStart: (NSInteger) aStart;
+
+- (NSInteger) getStop;
+- (void) setStop: (NSInteger) aStop;
+
+@property (assign, getter=getStart, setter=setStart:) NSInteger start;
+@property (getter=getStop,setter=setStop:) NSInteger stopToken;
+
+@end
diff --git a/runtime/ObjC/Framework/LexerRuleReturnScope.m b/runtime/ObjC/Framework/LexerRuleReturnScope.m
new file mode 100644
index 0000000..ac69380
--- /dev/null
+++ b/runtime/ObjC/Framework/LexerRuleReturnScope.m
@@ -0,0 +1,62 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRLexerRuleReturnScope.h"
+
+
+@implementation ANTLRLexerRuleReturnScope
+
+@synthesize start;
+
+//----------------------------------------------------------
+//  start
+//----------------------------------------------------------
+- (NSInteger) getStart
+{
+    return start;
+}
+
+- (void) setStart: (NSInteger) aStart
+{
+    start = aStart;
+}
+
+//----------------------------------------------------------
+//  stop
+//----------------------------------------------------------
+- (NSInteger) getStop
+{
+    return stopToken;
+}
+
+- (void) setStop: (NSInteger) aStop
+{
+    stopToken = aStop;
+}
+
+
+
+@end
diff --git a/runtime/ObjC/Framework/LexerState.h b/runtime/ObjC/Framework/LexerState.h
new file mode 100644
index 0000000..7132a48
--- /dev/null
+++ b/runtime/ObjC/Framework/LexerState.h
@@ -0,0 +1,57 @@
+// [The "BSD licence"]
+// Copyright (c) 2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRToken.h"
+#import "ANTLRRecognizerSharedState.h"
+
+@interface ANTLRLexerState : ANTLRRecognizerSharedState {
+}
+
+- (void) reset;
+
+- (id<ANTLRToken>) getToken;
+- (void) setToken:(id<ANTLRToken>) theToken;
+
+- (NSUInteger) getTokenType;
+- (void) setTokenType:(unsigned int) theTokenType;
+
+- (NSUInteger) channel;
+- (void) setChannel:(unsigned int) theChannel;
+
+- (NSUInteger) getTokenStartLine;
+- (void) setTokenStartLine:(unsigned int) theTokenStartLine;
+
+- (NSUInteger) getTokenCharPositionInLine;
+- (void) setTokenCharPositionInLine:(unsigned int) theCharPosition;
+
+- (NSInteger) getTokenStartCharIndex;
+- (void) setTokenStartCharIndex:(int) theTokenStartCharIndex;
+
+- (NSString *) text;
+- (void) setText:(NSString *) theText;
+
+@end
diff --git a/runtime/ObjC/Framework/LexerState.m b/runtime/ObjC/Framework/LexerState.m
new file mode 100644
index 0000000..88284b7
--- /dev/null
+++ b/runtime/ObjC/Framework/LexerState.m
@@ -0,0 +1,139 @@
+// [The "BSD licence"]
+// Copyright (c) 2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRLexerState.h"
+
+
+@implementation ANTLRLexerState
+
+- (id) init
+{
+	self = [super init];
+	if (self) {
+		[self reset];
+	}
+	return self;
+}
+
+- (void) reset
+{
+	[self setToken:nil];
+	type = 0;
+	channel = 0;
+	tokenStartLine = 0;
+	tokenStartCharPositionInLine = 0;
+	tokenStartCharIndex = -1;
+	[self setText:nil];
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRLexerState" );
+#endif
+	[self setText:nil];
+	[self setToken:nil];
+	[super dealloc];
+}
+
+- (id<ANTLRToken>) getToken
+{
+	return token;
+}
+
+- (void) setToken:(id<ANTLRToken>) theToken
+{
+	if (theToken != token) {
+		if ( token ) [token release];
+		token = [theToken retain];
+	}
+}
+
+
+- (NSUInteger) getTokenType
+{
+	return type;
+}
+
+- (void) setTokenType:(NSUInteger) theTokenType
+{
+	type = theTokenType;
+}
+
+- (NSUInteger)channel
+{
+	return channel;
+}
+
+- (void) setChannel:(NSUInteger) theChannel
+{
+	channel = theChannel;
+}
+
+- (NSUInteger) getTokenStartLine
+{
+	return tokenStartLine;
+}
+
+- (void) setTokenStartLine:(NSUInteger) theTokenStartLine
+{
+	tokenStartLine = theTokenStartLine;
+}
+
+- (unsigned int) getTokenCharPositionInLine
+{
+	return tokenStartCharPositionInLine;
+}
+
+- (void) setTokenCharPositionInLine:(unsigned int) theCharPosition
+{
+	tokenStartCharPositionInLine = theCharPosition;
+}
+
+- (int) getTokenStartCharIndex
+{
+	return tokenStartCharIndex;
+}
+
+- (void) setTokenStartCharIndex:(int) theTokenStartCharIndex
+{
+	tokenStartCharIndex = theTokenStartCharIndex;
+}
+
+- (NSString *) text
+{
+	return text;
+}
+
+- (void) setText:(NSString *) theText
+{
+	if (text != theText) {
+		if ( text ) [text release];
+		text = [theText retain];
+	}
+}
+
+@end
diff --git a/runtime/ObjC/Framework/LinkBase.h b/runtime/ObjC/Framework/LinkBase.h
new file mode 100644
index 0000000..f4c337e
--- /dev/null
+++ b/runtime/ObjC/Framework/LinkBase.h
@@ -0,0 +1,80 @@
+//
+//  ANTLRLinkBase.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/14/10.
+//  [The "BSD licence"]
+//  Copyright (c) 2010 Alan Condit
+//  All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+
+#ifndef DEBUG_DEALLOC
+#define DEBUG_DEALLOC
+#endif
+
+@protocol ANTLRLinkList <NSObject>
+
++ (id<ANTLRLinkList>)newANTLRLinkBase;
++ (id<ANTLRLinkList>)newANTLRLinkBase:(id<ANTLRLinkList>)np Prev:(id<ANTLRLinkList>)pp;
+
+- (void) dealloc;
+
+- (id<ANTLRLinkList>) append:(id<ANTLRLinkList>)node;
+- (id<ANTLRLinkList>) insert:(id<ANTLRLinkList>)node;
+
+- (id<ANTLRLinkList>) getfNext;
+- (void) setFNext:(id<ANTLRLinkList>)np;
+- (id<ANTLRLinkList>)getfPrev;
+- (void) setFPrev:(id<ANTLRLinkList>)pp;
+
+@property (retain) id<ANTLRLinkList> fPrev;
+@property (retain) id<ANTLRLinkList> fNext;
+@end
+
+@interface ANTLRLinkBase : NSObject <ANTLRLinkList> {
+	id<ANTLRLinkList> fPrev;
+	id<ANTLRLinkList> fNext;
+}
+
+@property (retain) id<ANTLRLinkList> fPrev;
+@property (retain) id<ANTLRLinkList> fNext;
+
++ (id<ANTLRLinkList>)newANTLRLinkBase;
++ (id<ANTLRLinkList>)newANTLRLinkBase:(id<ANTLRLinkList>)np Prev:(id<ANTLRLinkList>)pp;
+- (id<ANTLRLinkList>)init;
+- (id<ANTLRLinkList>)initWithPtr:(id)np Prev:(id)pp;
+- (void)dealloc;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (id<ANTLRLinkList>)append:(id<ANTLRLinkList>)node;
+- (id<ANTLRLinkList>)insert:(id<ANTLRLinkList>)node;
+
+- (id<ANTLRLinkList>)getfNext;
+- (void)setfNext:(id<ANTLRLinkList>) np;
+- (id<ANTLRLinkList>)getfPrev;
+- (void)setfPrev:(id<ANTLRLinkList>) pp;
+@end
diff --git a/runtime/ObjC/Framework/LinkBase.m b/runtime/ObjC/Framework/LinkBase.m
new file mode 100644
index 0000000..d352993
--- /dev/null
+++ b/runtime/ObjC/Framework/LinkBase.m
@@ -0,0 +1,127 @@
+//
+//  ANTLRLinkBase.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/14/10.
+//  [The "BSD licence"]
+//  Copyright (c) 2010 Alan Condit
+//  All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRLinkBase.h"
+
+@implementation ANTLRLinkBase
+
+@synthesize fPrev;
+@synthesize fNext;
+
++(id<ANTLRLinkList>)newANTLRLinkBase
+{
+	return [[ANTLRLinkBase alloc] init];
+}
+
++(id<ANTLRLinkList>)newANTLRLinkBase:(id<ANTLRLinkList>)np Prev:(id<ANTLRLinkList>)pp
+{
+	return [[ANTLRLinkBase alloc] initWithPtr:np Prev:pp];
+}
+
+-(id<ANTLRLinkList>)init
+{
+	if ((self = [super init]) != nil) {
+		fNext = nil;
+		fPrev = nil;
+	}
+	return(self);
+}
+
+-(id<ANTLRLinkList>)initWithPtr:(id<ANTLRLinkList>)np Prev:(id<ANTLRLinkList>)pp
+{
+	if ((self = [super init]) != nil) {
+		fNext = np;
+		fPrev = pp;
+	}
+	return(self);
+}
+
+-(void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRLinkBase" );
+#endif
+	if (fNext) [fNext dealloc];
+	if (fPrev) [fPrev dealloc];
+	[super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRLinkBase *copy;
+
+    copy = [[self class] allocWithZone:aZone];
+    copy.fPrev = fPrev;
+    copy.fNext = fNext;
+    return( copy );
+}
+
+-(id<ANTLRLinkList>)append:(id<ANTLRLinkList>)node
+{
+	node.fPrev = (id<ANTLRLinkList>)self;
+	node.fNext = (id<ANTLRLinkList>)self.fNext;
+	if (node.fNext != nil)
+        node.fNext.fPrev = node;
+    self.fNext = node;
+    return( node );
+}
+
+-(id<ANTLRLinkList>)insert:(id<ANTLRLinkList>)node
+{
+	node.fNext = self;
+	node.fPrev = self.fPrev;
+    if (node.fPrev != nil)
+        node.fPrev.fNext = node;
+	self.fPrev = node;
+	return( node );
+}
+
+-(id<ANTLRLinkList>)getfNext
+{
+	return(fNext);
+}
+
+-(void)setfNext:(id<ANTLRLinkList>)np
+{
+	fNext = np;
+}
+
+-(id<ANTLRLinkList>)getfPrev
+{
+	return(fPrev);
+}
+
+-(void)setfPrev:(id<ANTLRLinkList>)pp
+{
+	fPrev = pp;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/LookaheadStream.h b/runtime/ObjC/Framework/LookaheadStream.h
new file mode 100644
index 0000000..3ec121e
--- /dev/null
+++ b/runtime/ObjC/Framework/LookaheadStream.h
@@ -0,0 +1,77 @@
+//
+//  ANTLRLookaheadStream.h
+//  ANTLR
+//
+//  Created by Ian Michell on 26/04/2010.
+//  [The "BSD licence"]
+//  Copyright (c) 2010 Ian Michell 2010 Alan Condit
+//  All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRFastQueue.h"
+
+#define UNITIALIZED_EOF_ELEMENT_INDEX NSIntegerMax
+
+@interface ANTLRLookaheadStream : ANTLRFastQueue
+{
+    NSInteger index;
+	NSInteger eofElementIndex;
+	NSInteger lastMarker;
+	NSInteger markDepth;
+	id prevElement;
+	id eof;
+}
+
+@property (readwrite, retain, getter=getEof, setter=setEof:) id eof;
+@property (assign) NSInteger index;
+@property (assign, getter=getEofElementIndex, setter=setEofElementIndex:) NSInteger eofElementIndex;
+@property (assign, getter=getLastMarker, setter=setLastMarker:) NSInteger lastMarker;
+@property (assign, getter=getMarkDepth, setter=setMarkDepth:) NSInteger markDepth;
+@property (retain) id prevElement;
+
+- (id) initWithEOF:(id) obj;
+- (id) nextElement;
+- (id) remove;
+- (void) consume;
+- (void) sync:(NSInteger) need;
+- (void) fill:(NSInteger) n;
+- (id) LT:(NSInteger) i;
+- (id) LB:(NSInteger) i;
+- (id) getCurrentSymbol;
+- (NSInteger) mark;
+- (void) release:(NSInteger) marker;
+- (void) rewind:(NSInteger) marker;
+- (void) rewind;
+- (void) seek:(NSInteger) i;
+- (id) getEof;
+- (void) setEof:(id) anID;
+- (NSInteger) getEofElementIndex;
+- (void) setEofElementIndex:(NSInteger) anInt;
+- (NSInteger) getLastMarker;
+- (void) setLastMarker:(NSInteger) anInt;
+- (NSInteger) getMarkDepth;
+- (void) setMarkDepth:(NSInteger) anInt;
+
+@end
diff --git a/runtime/ObjC/Framework/LookaheadStream.m b/runtime/ObjC/Framework/LookaheadStream.m
new file mode 100644
index 0000000..57e489e
--- /dev/null
+++ b/runtime/ObjC/Framework/LookaheadStream.m
@@ -0,0 +1,229 @@
+//
+//  ANTLRLookaheadStream.m
+//  ANTLR
+//
+//  Created by Ian Michell on 26/04/2010.
+// [The "BSD licence"]
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRLookaheadStream.h"
+#import "ANTLRError.h"
+#import "ANTLRRecognitionException.h"
+#import "ANTLRCommonToken.h"
+#import "ANTLRRuntimeException.h"
+
+@implementation ANTLRLookaheadStream
+
+@synthesize eof;
+@synthesize index;
+@synthesize eofElementIndex;
+@synthesize lastMarker;
+@synthesize markDepth;
+@synthesize prevElement;
+
+-(id) init
+{
+	self = [super init];
+	if ( self != nil ) {
+        eof = [[ANTLRCommonToken eofToken] retain];
+		eofElementIndex = UNITIALIZED_EOF_ELEMENT_INDEX;
+		markDepth = 0;
+        index = 0;
+	}
+	return self;
+}
+
+-(id) initWithEOF:(id)obj
+{
+	if ((self = [super init]) != nil) {
+		self.eof = obj;
+        if ( self.eof ) [self.eof retain];
+	}
+	return self;
+}
+
+- (void) reset
+{
+	[super reset];
+    index = 0;
+    p = 0;
+    prevElement = nil;
+	eofElementIndex = UNITIALIZED_EOF_ELEMENT_INDEX;
+}
+
+-(id) nextElement
+{
+//	[self doesNotRecognizeSelector:_cmd];
+	return nil;
+}
+
+- (id) remove
+{
+    id obj = [self objectAtIndex:0];
+    p++;
+    // have we hit end of buffer and not backtracking?
+    if ( p == [data count] && markDepth==0 ) {
+        // if so, it's an opportunity to start filling at index 0 again
+        [self clear]; // size goes to 0, but retains memory
+    }
+    [obj release];
+    return obj;
+}
+
+-(void) consume
+{
+	[self sync:1];
+	prevElement = [self remove];
+    index++;
+}
+
+-(void) sync:(NSInteger) need
+{
+	NSInteger n = (p + need - 1) - [data count] + 1;
+	if ( n > 0 ) {
+		[self fill:n];
+	}
+}
+
+-(void) fill:(NSInteger) n
+{
+    id obj;
+	for (NSInteger i = 1; i <= n; i++) {
+		obj = [self nextElement];
+		if ( obj == eof ) {
+			[data addObject:self.eof];
+			eofElementIndex = [data count] - 1;
+		}
+		else {
+			[data addObject:obj];
+		}
+	}
+}
+
+-(NSUInteger) count
+{
+	@throw [NSException exceptionWithName:@"ANTLRUnsupportedOperationException" reason:@"Streams have no defined size" userInfo:nil];
+}
+
+-(id) LT:(NSInteger) k
+{
+	if (k == 0) {
+		return nil;
+	}
+	if (k < 0) {
+		return [self LB:-k];
+	}
+	if ((p + k - 1) >= eofElementIndex) {
+		return self.eof;
+	}
+	[self sync:k];
+	return [self objectAtIndex:(k - 1)];
+}
+
+-(id) LB:(NSInteger) k
+{
+	if (k == 1) {
+		return prevElement;
+	}
+	@throw [ANTLRNoSuchElementException newException:@"can't look backwards more than one token in this stream"];
+}
+
+-(id) getCurrentSymbol
+{
+	return [self LT:1];
+}
+
+-(NSInteger) mark
+{
+	markDepth++;
+	lastMarker = p;
+	return lastMarker;
+}
+
+-(void) release:(NSInteger) marker
+{
+	// no resources to release
+}
+
+-(void) rewind:(NSInteger) marker
+{
+	markDepth--;
+	[self seek:marker];
+//    if (marker == 0) [self reset];
+}
+
+-(void) rewind
+{
+	[self seek:lastMarker];
+//    if (lastMarker == 0) [self reset];
+}
+
+-(void) seek:(NSInteger) anIndex
+{
+	p = anIndex;
+}
+
+- (id) getEof
+{
+    return eof;
+}
+
+- (void) setEof:(id) anID
+{
+    eof = anID;
+}
+
+- (NSInteger) getEofElementIndex
+{
+    return eofElementIndex;
+}
+
+- (void) setEofElementIndex:(NSInteger) anInt
+{
+    eofElementIndex = anInt;
+}
+
+- (NSInteger) getLastMarker
+{
+    return lastMarker;
+}
+
+- (void) setLastMarker:(NSInteger) anInt
+{
+    lastMarker = anInt;
+}
+
+- (NSInteger) getMarkDepthlastMarker
+{
+    return markDepth;
+}
+
+- (void) setMarkDepth:(NSInteger) anInt
+{
+    markDepth = anInt;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/Map.h b/runtime/ObjC/Framework/Map.h
new file mode 100644
index 0000000..80ad486
--- /dev/null
+++ b/runtime/ObjC/Framework/Map.h
@@ -0,0 +1,82 @@
+//
+//  ANTLRMap.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRPtrBuffer.h"
+#import "ANTLRMapElement.h"
+
+//#define GLOBAL_SCOPE      0
+//#define LOCAL_SCOPE       1
+#define HASHSIZE            101
+#define HBUFSIZE            0x2000
+
+@interface ANTLRMap : ANTLRPtrBuffer {
+	//ANTLRMap *fNext; // found in superclass
+    // TStringPool *fPool;
+    NSInteger lastHash;
+}
+
+//@property (copy) ANTLRMap *fNext;
+@property (getter=getLastHash, setter=setLastHash:) NSInteger lastHash;
+
+// Contruction/Destruction
++ (id)newANTLRMap;
++ (id)newANTLRMapWithLen:(NSInteger)aHashSize;
+
+- (id)init;
+- (id)initWithLen:(NSInteger)cnt;
+- (void)dealloc;
+// Instance Methods
+- (NSInteger)count;
+- (NSInteger)length;
+- (NSInteger)size;
+/* clear -- reinitialize the maplist array */
+- (void) clear;
+/* form hash value for string s */
+-(NSInteger)hash:(NSString *)s;
+/*   look for s in ptrBuffer  */
+-(id)lookup:(NSString *)s;
+/* look for s in ptrBuffer  */
+-(id)install:(ANTLRMapElement *)sym;
+/*
+ * delete entry from list
+ */
+- (void)deleteANTLRMap:(ANTLRMapElement *)np;
+- (NSInteger)RemoveSym:(NSString *)s;
+- (void)delete_chain:(ANTLRMapElement *)np;
+- (ANTLRMapElement *)getTType:(NSString *)name;
+- (ANTLRMapElement *)getName:(NSInteger)ttype;
+- (NSInteger)getNode:(ANTLRMapElement *)aNode;
+- (void)putNode:(NSInteger)aTType Node:(id)aNode;
+- (void)putName:(NSString *)name TType:(NSInteger)ttype;
+- (void)putName:(NSString *)name Node:(id)aNode;
+
+@end
diff --git a/runtime/ObjC/Framework/Map.m b/runtime/ObjC/Framework/Map.m
new file mode 100644
index 0000000..6bfb088
--- /dev/null
+++ b/runtime/ObjC/Framework/Map.m
@@ -0,0 +1,362 @@
+//
+//  ANTLRMap.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#define SUCCESS (0)
+#define FAILURE (-1)
+
+#import "ANTLRMap.h"
+#import "ANTLRBaseTree.h"
+
+/*
+ * Start of ANTLRMap
+ */
+@implementation ANTLRMap
+
+@synthesize lastHash;
+
++(id)newANTLRMap
+{
+    return [[ANTLRMap alloc] init];
+}
+
++(id)newANTLRMapWithLen:(NSInteger)aBuffSize
+{
+    return [[ANTLRMap alloc] initWithLen:aBuffSize];
+}
+
+-(id)init
+{
+    NSInteger idx;
+
+	self = [super initWithLen:HASHSIZE];
+    if ( self != nil ) {
+		fNext = nil;
+        for( idx = 0; idx < HASHSIZE; idx++ ) {
+            ptrBuffer[idx] = nil;
+        }
+	}
+    return( self );
+}
+
+-(id)initWithLen:(NSInteger)aBuffSize
+{
+	self = [super initWithLen:aBuffSize];
+    if ( self != nil ) {
+	}
+    return( self );
+}
+
+-(void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRMMap" );
+#endif
+    ANTLRMapElement *tmp, *rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            tmp = ptrBuffer[idx];
+            while ( tmp ) {
+                rtmp = tmp;
+                tmp = (ANTLRMapElement *)tmp.fNext;
+                [rtmp release];
+            }
+        }
+    }
+	[super dealloc];
+}
+
+-(void)deleteANTLRMap:(ANTLRMapElement *)np
+{
+    ANTLRMapElement *tmp, *rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            tmp = ptrBuffer[idx];
+            while ( tmp ) {
+                rtmp = tmp;
+                tmp = [tmp getfNext];
+                [rtmp release];
+            }
+        }
+    }
+}
+
+- (void)clear
+{
+    ANTLRMapElement *tmp, *rtmp;
+    NSInteger idx;
+
+    for( idx = 0; idx < BuffSize; idx++ ) {
+        tmp = ptrBuffer[idx];
+        while ( tmp ) {
+            rtmp = tmp;
+            tmp = [tmp getfNext];
+            [rtmp dealloc];
+        }
+        ptrBuffer[idx] = nil;
+    }
+}
+
+- (NSInteger)count
+{
+    NSInteger aCnt = 0;
+
+    for (int i = 0; i < BuffSize; i++) {
+        if (ptrBuffer[i] != nil) {
+            aCnt++;
+        }
+    }
+    return aCnt;
+}
+
+- (NSInteger)length
+{
+    return BuffSize;
+}
+
+- (NSInteger)size
+{
+    ANTLRMapElement *anElement;
+    NSInteger aSize = 0;
+
+    for (int i = 0; i < BuffSize; i++) {
+        if ((anElement = ptrBuffer[i]) != nil) {
+            aSize += (NSInteger)[anElement size];
+        }
+    }
+    return aSize;
+}
+
+#ifdef USERDOC
+/*
+ *  HASH        hash entry to get index to table
+ *  NSInteger hash( ANTLRMap *self, char *s );
+ *
+ *     Inputs:  NSString *s         string to find
+ *
+ *     Returns: NSInteger                 hashed value
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(NSInteger)hash:(NSString *)s       /*    form hash value for string s */
+{
+	NSInteger hashval;
+	const char *tmp;
+
+	tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
+	for( hashval = 0; *tmp != '\0'; )
+        hashval += *tmp++;
+	self->lastHash = hashval % HASHSIZE;
+	return( self->lastHash );
+}
+
+#ifdef USERDOC
+/*
+ *  LOOKUP  search hashed list for entry
+ *  ANTLRMapElement *lookup:(NSString *)s;
+ *
+ *     Inputs:  NSString  *s       string to find
+ *
+ *     Returns: ANTLRMapElement  *        pointer to entry
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(id)lookup:(NSString *)s
+{
+    ANTLRMapElement *np;
+
+    for( np = self->ptrBuffer[[self hash:s]]; np != nil; np = [np getfNext] ) {
+        if ( [s isEqualToString:[np getName]] ) {
+            return( np );        /*   found it       */
+        }
+    }
+    return( nil );              /*   not found      */
+}
+
+#ifdef USERDOC
+/*
+ *  INSTALL search hashed list for entry
+ *  NSInteger install( ANTLRMap *self, ANTLRMapElement *sym );
+ *
+ *     Inputs:  ANTLRMapElement    *sym   -- symbol ptr to install
+ *              NSInteger         scope -- level to find
+ *
+ *     Returns: Boolean     TRUE   if installed
+ *                          FALSE  if already in table
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(ANTLRMapElement *)install:(ANTLRMapElement *)sym
+{
+    ANTLRMapElement *np;
+
+    np = [self lookup:[sym getName]];
+    if ( np == nil ) {
+        [sym setFNext:ptrBuffer[ lastHash ]];
+        ptrBuffer[ lastHash ] = sym;
+        [sym retain];
+        return( ptrBuffer[ lastHash ] );
+    }
+    return( nil );            /*   not found      */
+}
+
+#ifdef USERDOC
+/*
+ *  RemoveSym  search hashed list for entry
+ *  NSInteger RemoveSym( ANTLRMap *self, char *s );
+ *
+ *     Inputs:  char     *s          string to find
+ *
+ *     Returns: NSInteger      indicator of SUCCESS OR FAILURE
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(NSInteger)RemoveSym:(NSString *)s
+{
+    ANTLRMapElement *np, *tmp;
+    NSInteger idx;
+
+    idx = [self hash:s];
+    for ( tmp = self->ptrBuffer[idx], np = self->ptrBuffer[idx]; np != nil; np = [np getfNext] ) {
+        if ( [s isEqualToString:[np getName]] ) {
+            tmp = [np getfNext];             /* get the next link  */
+            [np release];
+            return( SUCCESS );            /* report SUCCESS     */
+        }
+        tmp = [np getfNext];              //  BAD!!!!!!
+    }
+    return( FAILURE );                    /*   not found      */
+}
+
+-(void)delete_chain:(ANTLRMapElement *)np
+{
+    if ( [np getfNext] != nil )
+		[self delete_chain:[np getfNext]];
+	[np release];
+}
+
+#ifdef DONTUSEYET
+-(NSInteger)bld_symtab:(KW_TABLE *)toknams
+{
+    NSInteger i;
+    ANTLRMapElement *np;
+
+    for( i = 0; *(toknams[i].name) != '\0'; i++ ) {
+        // install symbol in ptrBuffer
+        np = [ANTLRMapElement newANTLRMapElement:[NSString stringWithFormat:@"%s", toknams[i].name]];
+        //        np->fType = toknams[i].toknum;
+        [self install:np Scope:0];
+    }
+    return( SUCCESS );
+}
+#endif
+
+/*
+ * works only for maplist indexed not by name but by TokenNumber
+ */
+- (ANTLRMapElement *)getName:(NSInteger)ttype
+{
+    ANTLRMapElement *np;
+    NSInteger aTType;
+
+    aTType = ttype % HASHSIZE;
+    for( np = self->ptrBuffer[ttype]; np != nil; np = [np getfNext] ) {
+        if ( [(NSNumber *)np.node integerValue] == ttype ) {
+            return( np );        /*   found it       */
+        }
+    }
+    return( nil );              /*   not found      */
+}
+
+- (NSInteger)getNode:(id<ANTLRBaseTree>)aNode
+{
+    ANTLRMapElement *np;
+    NSInteger idx;
+
+    idx = [(id<ANTLRBaseTree>)aNode type];
+    idx %= HASHSIZE;
+    np = ptrBuffer[idx];
+    return( [(NSNumber *)np.node integerValue] );
+}
+
+- (ANTLRMapElement *)getTType:(NSString *)name
+{
+    return [self lookup:name];
+}
+
+// create node and install node in ptrBuffer
+- (void)putName:(NSString *)name TType:(NSInteger)ttype
+{
+    ANTLRMapElement *np;
+
+    np = [ANTLRMapElement newANTLRMapElementWithName:[NSString stringWithString:name] Type:ttype];
+    [self install:np];
+}
+
+// create node and install node in ptrBuffer
+- (void)putName:(NSString *)name Node:(id)aNode
+{
+    ANTLRMapElement *np, *np1;
+    NSInteger idx;
+
+    idx = [self hash:name];
+    np1 = [ANTLRMapElement newANTLRMapElementWithName:[NSString stringWithString:name] Type:idx];
+    np = [self lookup:name];
+    if ( np == nil ) {
+        [np1 setFNext:self->ptrBuffer[ self->lastHash ]];
+        self->ptrBuffer[ self->lastHash ] = np1;
+        [np1 retain];
+    }
+    else {
+        // ptrBuffer[idx] = np;
+    }
+    return;
+}
+
+// create node and install node in ptrBuffer
+- (void)putNode:(NSInteger)aTType Node:(id)aNode
+{
+    ANTLRMapElement *np;
+    NSInteger ttype;
+
+    ttype = aTType % HASHSIZE;
+    np = [ANTLRMapElement newANTLRMapElementWithNode:ttype Node:(id)aNode];
+    ptrBuffer[ttype] = np;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/MapElement.h b/runtime/ObjC/Framework/MapElement.h
new file mode 100644
index 0000000..e20d01c
--- /dev/null
+++ b/runtime/ObjC/Framework/MapElement.h
@@ -0,0 +1,65 @@
+//
+//  ANTLRMapElement.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/8/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseMapElement.h"
+
+@interface ANTLRMapElement : ANTLRBaseMapElement {
+    NSString *name;
+    id        node;
+}
+@property (retain, getter=getName, setter=setName:) NSString *name;
+@property (retain, getter=getNode, setter=setNode:) id node;
+
++ (id) newANTLRMapElement;
++ (id) newANTLRMapElementWithName:(NSString *)aName Type:(NSInteger)aTType;
++ (id) newANTLRMapElementWithNode:(NSInteger)aTType Node:(id)aNode;
++ (id) newANTLRMapElementWithName:(NSString *)aName Node:(id)aNode;
++ (id) newANTLRMapElementWithObj1:(id)anObj1 Obj2:(id)anObj2;
+- (id) init;
+- (id) initWithName:(NSString *)aName Type:(NSInteger)aTType;
+- (id) initWithNode:(NSInteger)aTType Node:(id)aNode;
+- (id) initWithName:(NSString *)aName Node:(id)aNode;
+- (id) initWithObj1:(id)anObj1 Obj2:(id)anObj2;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (NSInteger) count;
+- (NSInteger) size;
+- (NSString *)getName;
+- (void)setName:(NSString *)aName;
+- (id)getNode;
+- (void)setNode:(id)aNode;
+- (void)putNode:(id)aNode;
+- (void)putNode:(id)aNode With:(NSInteger)uniqueID;
+//- (void)setObject:(id)aNode atIndex:anIndex;
+
+@end
diff --git a/runtime/ObjC/Framework/MapElement.m b/runtime/ObjC/Framework/MapElement.m
new file mode 100644
index 0000000..bce1c9f
--- /dev/null
+++ b/runtime/ObjC/Framework/MapElement.m
@@ -0,0 +1,207 @@
+//
+//  ANTLRMapElement.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/8/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRMapElement.h"
+
+
+@implementation ANTLRMapElement
+
+@synthesize name;
+@synthesize node;
+
++ (id) newANTLRMapElement
+{
+    return [[ANTLRMapElement alloc] init];
+}
+
++ (id) newANTLRMapElementWithName:(NSString *)aName Type:(NSInteger)aTType
+{
+    return [[ANTLRMapElement alloc] initWithName:aName Type:aTType];
+}
+
++ (id) newANTLRMapElementWithNode:(NSInteger)aTType Node:(id)aNode
+{
+    return [[ANTLRMapElement alloc] initWithNode:aTType Node:aNode];
+}
+
++ (id) newANTLRMapElementWithName:(NSString *)aName Node:(id)aNode
+{
+    return [[ANTLRMapElement alloc] initWithName:aName Node:aNode];
+}
+
++ (id) newANTLRMapElementWithObj1:(id)anObj1 Obj2:(id)anObj2
+{
+    return [[ANTLRMapElement alloc] initWithObj1:anObj1 Obj2:anObj2];
+}
+
+- (id) init
+{
+    self = [super init];
+    if ( self != nil ) {
+        index = nil;
+        name  = nil;
+    }
+    return self;
+}
+
+- (id) initWithName:(NSString *)aName Type:(NSInteger)aTType
+{
+    self = [super init];
+    if ( self != nil ) {
+        index = [[NSNumber numberWithInteger: aTType] retain];
+        name  = [[NSString stringWithString:aName] retain];
+    }
+    return self;
+}
+
+- (id) initWithNode:(NSInteger)aTType Node:(id)aNode
+{
+    self = [super initWithAnIndex:[NSNumber numberWithInteger:aTType]];
+    if ( self != nil ) {
+        node  = aNode;
+        if ( node ) [node retain];
+    }
+    return self;
+}
+
+- (id) initWithName:(NSString *)aName Node:(id)aNode
+{
+    self = [super init];
+    if ( self != nil ) {
+        name  = [[NSString stringWithString:aName] retain];
+        node = aNode;
+        if ( node ) [node retain];
+    }
+    return self;
+}
+
+- (id) initWithObj1:(id)anIndex Obj2:(id)aNode
+{
+    self = [super initWithAnIndex:anIndex];
+    if ( self != nil ) {
+        node = aNode;
+        if ( node ) [node retain];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRMapElement" );
+#endif
+    if ( name ) [name release];
+    if ( node ) [node release];
+    [super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRMapElement *copy;
+
+    copy = [super copyWithZone:aZone];
+    if (name) copy.name = name;
+    if (node) copy.node = node;
+    return( copy );
+}
+
+- (NSInteger) count
+{
+    NSInteger aCnt = 0;
+    if (name != nil) aCnt++;;
+    if (node != nil) aCnt++;;
+    return aCnt;
+}
+
+- (NSInteger)size
+{
+    NSInteger aSize = 0;
+    if ( name ) aSize += sizeof(id);
+    if ( node ) aSize += sizeof(id);
+    return aSize;
+}
+
+
+- (NSString *)getName
+{
+    return name;
+}
+
+- (void)setName:(NSString *)aName
+{
+    if ( aName != name ) {
+        if ( name ) [name release];
+        [aName retain];
+    }
+    name = aName;
+}
+
+- (id)getNode
+{
+    return node;
+}
+
+- (void)setNode:(id)aNode
+{   if ( aNode != node ) {
+        if ( node ) [node release];
+        [aNode retain];
+    }
+    node = aNode;
+}
+
+- (void)putNode:(id)aNode
+{
+    index = ((ANTLRMapElement *)aNode).index;
+    if (((ANTLRMapElement *)aNode).name) {
+        name = [((ANTLRMapElement *)aNode).name retain];
+        node = nil;
+    }
+    if (((ANTLRMapElement *)aNode).node) {
+        name = nil;
+        node = [((ANTLRMapElement *)aNode).node retain];
+    }
+}
+
+- (void)putNode:(id)aNode With:(NSInteger)uniqueID
+{
+    index = ((ANTLRMapElement *)aNode).index;
+    if (((ANTLRMapElement *)aNode).name) {
+        name = [((ANTLRMapElement *)aNode).name retain];
+        node = nil;
+    }
+    if (((ANTLRMapElement *)aNode).node) {
+        name = nil;
+        node = [((ANTLRMapElement *)aNode).node retain];
+    }
+}
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedNotSetException.h b/runtime/ObjC/Framework/MismatchedNotSetException.h
new file mode 100644
index 0000000..95d191d
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedNotSetException.h
@@ -0,0 +1,51 @@
+//
+//  ANTLRMismatchedNotSetException.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/13/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRecognitionException.h"
+#import "ANTLRBitSet.h"
+
+@interface ANTLRMismatchedNotSetException : ANTLRRecognitionException
+{
+    NSString *expecting;
+}
+@property (retain, getter=getExpecting, setter=setExpecting:) NSString *expecting;
+
+- (ANTLRMismatchedNotSetException *)newException;
+- (ANTLRMismatchedNotSetException *)newException:(id<ANTLRIntStream>)anInput
+                                                               Follow:(NSString *)expecting;
+
+- (id) init;
+- (id) initWithStream:(id<ANTLRIntStream>)anInput Follow:(NSString *)expecting;
+
+- (NSString *)toString;
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedNotSetException.m b/runtime/ObjC/Framework/MismatchedNotSetException.m
new file mode 100644
index 0000000..e43e1b1
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedNotSetException.m
@@ -0,0 +1,69 @@
+//
+//  ANTLRMismatchedNotSetException.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/13/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRMismatchedNotSetException.h"
+
+@implementation ANTLRMismatchedNotSetException
+
+@synthesize expecting;
+
+- (ANTLRMismatchedNotSetException *)newException
+{
+    return [[ANTLRMismatchedNotSetException alloc] init];
+}
+
+- (ANTLRMismatchedNotSetException *)newException:(id<ANTLRIntStream>)anInput
+                                                               Follow:(NSString *)expected
+{
+    return [[ANTLRMismatchedNotSetException alloc] initWithStream:anInput Follow:(NSString *)expected];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil ) {
+    }
+    return(self);
+}
+
+- (id) initWithStream:(id<ANTLRIntStream>)anInput Follow:(NSString *)expected
+{
+    if ((self = [super initWithStream:anInput]) != nil ) {
+        expecting = expected;
+    }
+    return(self);
+}
+
+- (NSString *)toString
+{
+    return [NSString stringWithFormat:@"MismatchedNotSetException( %d != %@ )", [self unexpectedType], expecting];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedRangeException.h b/runtime/ObjC/Framework/MismatchedRangeException.h
new file mode 100644
index 0000000..678af61
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedRangeException.h
@@ -0,0 +1,42 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRecognitionException.h"
+
+@protocol ANTLRIntStream;
+
+
+@interface ANTLRMismatchedRangeException : ANTLRRecognitionException {
+	NSRange range;
+}
+
+@property (assign) NSRange range;
+
++ (id) newException:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput;
+- (id) initWithRange:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput;
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedRangeException.m b/runtime/ObjC/Framework/MismatchedRangeException.m
new file mode 100644
index 0000000..0647254
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedRangeException.m
@@ -0,0 +1,55 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRMismatchedRangeException.h"
+
+
+@implementation ANTLRMismatchedRangeException
+
+@synthesize range;
+
++ (id) newException:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput
+{
+	return [[ANTLRMismatchedRangeException alloc] initWithRange:aRange stream:theInput];
+}
+
+- (id) initWithRange:(NSRange) aRange stream:(id<ANTLRIntStream>) theInput
+{
+	if ((self = [super initWithStream:theInput]) != nil) {
+		range = aRange;
+	}
+	return self;
+}
+
+- (NSString *) description
+{
+	NSMutableString *desc = (NSMutableString *)[super description];
+	[desc appendFormat:@" range:%@", NSStringFromRange(range)];
+	return desc;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedSetException.h b/runtime/ObjC/Framework/MismatchedSetException.h
new file mode 100644
index 0000000..0610973
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedSetException.h
@@ -0,0 +1,44 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRecognitionException.h"
+
+@interface ANTLRMismatchedSetException : ANTLRRecognitionException {
+	NSString *expecting;
+}
+
+@property (retain, getter=getExpecting, setter=setExpecting:) NSString *expecting;
+
++ (id) newException:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream;
+- (id) initWithSet:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream;
+
+- (NSString *) getExpecting;
+- (void) setExpecting: (NSString *) anExpectedSet;
+
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedSetException.m b/runtime/ObjC/Framework/MismatchedSetException.m
new file mode 100644
index 0000000..b5248d2
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedSetException.m
@@ -0,0 +1,79 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRMismatchedSetException.h"
+
+
+@implementation ANTLRMismatchedSetException
+
+@synthesize expecting;
+
++ (id) newException:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream
+{
+	return [[ANTLRMismatchedSetException alloc] initWithSet:theExpectedSet stream:theStream];
+}
+
+- (id) initWithSet:(NSString *) theExpectedSet stream:(id<ANTLRIntStream>) theStream
+{
+	if ((self = [super initWithStream:theStream]) != nil) {
+		[self setExpecting:theExpectedSet];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+	[self setExpecting:nil];
+	[super dealloc];
+}
+
+- (NSString *) description
+{
+	NSMutableString *desc =(NSMutableString *)[super description];
+	[desc appendFormat:@" set:%@", expecting];
+	return desc;
+}
+
+
+//----------------------------------------------------------
+//  expectedSet
+//----------------------------------------------------------
+- (NSString *) getExpecting
+{
+    return expecting;
+}
+
+- (void) setExpecting: (NSString *) anExpectedSet
+{
+    if ( expecting != anExpectedSet ) {
+        if ( expecting ) [expecting release];
+        [anExpectedSet retain];
+        expecting = anExpectedSet;
+    }
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedTokenException.h b/runtime/ObjC/Framework/MismatchedTokenException.h
new file mode 100644
index 0000000..8e28dcc
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedTokenException.h
@@ -0,0 +1,58 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRecognitionException.h"
+#import "ANTLRBitSet.h"
+
+@protocol ANTLRIntStream;
+
+@interface ANTLRMismatchedTokenException : ANTLRRecognitionException {
+	NSInteger expecting;
+	unichar expectingChar;
+	BOOL isTokenType;
+}
+
+@property (assign, getter=getExpecting, setter=setExpecting:) NSInteger expecting;
+@property (assign, getter=getExpectingChar, setter=setExpectingChar:) unichar expectingChar;
+@property (assign, getter=getIsTokenType, setter=setIsTokenType:) BOOL isTokenType;
+
++ (id) newException:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput;
++ (id) newExceptionMissing:(NSInteger)expectedTokenType
+                                        Stream:(id<ANTLRIntStream>)anInput
+                                         Token:(id<ANTLRToken>)inserted;
++ (id) newExceptionChar:(unichar)expectedCharacter Stream:(id<ANTLRIntStream>)anInput;
++ (id) newExceptionStream:(id<ANTLRIntStream>)anInput
+                                    Exception:(NSException *)e
+                                       Follow:(ANTLRBitSet *)follow;
+- (id) initWithTokenType:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput;
+-(id) initWithTokenType:(NSInteger)expectedTokenType
+                 Stream:(id<ANTLRIntStream>)anInput
+                  Token:(id<ANTLRToken>)inserted;
+- (id) initWithCharacter:(unichar)expectedCharacter Stream:(id<ANTLRIntStream>)anInput;
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedTokenException.m b/runtime/ObjC/Framework/MismatchedTokenException.m
new file mode 100644
index 0000000..a8807fa
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedTokenException.m
@@ -0,0 +1,99 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRMismatchedTokenException.h"
+
+
+@implementation ANTLRMismatchedTokenException
+
+@synthesize expecting;
+@synthesize expectingChar;
+@synthesize isTokenType;
+
+
++ (id) newException:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput
+{
+	return [[ANTLRMismatchedTokenException alloc] initWithTokenType:expectedTokenType Stream:anInput];
+}
+
++ (id) newExceptionMissing:(NSInteger)expectedTokenType
+                                        Stream:(id<ANTLRIntStream>)anInput
+                                         Token:(id<ANTLRToken>)inserted
+{
+	return [[ANTLRMismatchedTokenException alloc] initWithTokenType:expectedTokenType Stream:anInput Token:inserted];
+}
+
++ (id) newExceptionChar:(unichar) expectedCharacter Stream:(id<ANTLRIntStream>)anInput
+{
+	return [[ANTLRMismatchedTokenException alloc] initWithCharacter:expectedCharacter Stream:anInput];
+}
+
++ (id) newExceptionStream:(id<ANTLRIntStream>)anInput Exception:(NSException *)e Follow:(ANTLRBitSet *) follow
+{
+	return [[ANTLRMismatchedTokenException alloc] initWithStream:anInput];
+}
+
+-(id) initWithTokenType:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput
+{
+	if ((self = [super initWithStream:anInput]) != nil) {
+		expecting = expectedTokenType;
+		isTokenType = YES;
+	}
+	return self;
+}
+
+-(id) initWithTokenType:(NSInteger)expectedTokenType
+                 Stream:(id<ANTLRIntStream>)anInput
+                  Token:(id<ANTLRToken>)inserted
+{
+	if ((self = [super initWithStream:anInput]) != nil) {
+		expecting = expectedTokenType;
+		isTokenType = YES;
+	}
+	return self;
+}
+
+- (id) initWithCharacter:(unichar) expectedCharacter Stream:(id<ANTLRIntStream>)anInput
+{
+	if ((self = [super initWithStream:anInput]) != nil) {
+		expectingChar = expectedCharacter;
+		isTokenType = NO;
+	}
+	return self;
+}
+
+- (NSString *) description
+{
+	NSMutableString *desc = (NSMutableString *)[super description];
+	if (isTokenType) {
+		[desc appendFormat:@" expected:%d got:%d", expecting, [self unexpectedType]];
+	} else {
+		[desc appendFormat:@" expected:%c got:%c", expectingChar, (unichar)[self unexpectedType]];
+	}
+	return desc;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedTreeNodeException.h b/runtime/ObjC/Framework/MismatchedTreeNodeException.h
new file mode 100644
index 0000000..3528cba
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedTreeNodeException.h
@@ -0,0 +1,42 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRecognitionException.h"
+
+@protocol ANTLRIntStream;
+
+@interface ANTLRMismatchedTreeNodeException : ANTLRRecognitionException {
+	NSInteger expecting;
+}
+
+@property (getter=getExpecting, setter=setExpecting:) NSInteger expecting;
+
++ (id) newException:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput;
+- (id) initWithTokenType:(NSInteger) expectedTokenType Stream:(id<ANTLRIntStream>)anInput;
+
+
+@end
diff --git a/runtime/ObjC/Framework/MismatchedTreeNodeException.m b/runtime/ObjC/Framework/MismatchedTreeNodeException.m
new file mode 100644
index 0000000..60d5184
--- /dev/null
+++ b/runtime/ObjC/Framework/MismatchedTreeNodeException.m
@@ -0,0 +1,54 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRMismatchedTreeNodeException.h"
+
+
+@implementation ANTLRMismatchedTreeNodeException
+
+@synthesize expecting;
+
++ (id) newException:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput
+{
+	return [[ANTLRMismatchedTreeNodeException alloc] initWithTokenType:expectedTokenType Stream:anInput];
+}
+
+-(id) initWithTokenType:(NSInteger)expectedTokenType Stream:(id<ANTLRIntStream>)anInput
+{
+	if ((self = [super initWithStream:anInput]) != nil) {
+		expecting = expectedTokenType;
+	}
+	return self;
+}
+
+- (NSString *) description
+{
+	NSMutableString *desc = (NSMutableString *)[super description];
+	[desc appendFormat:@" expected:%d got:%d", expecting, [self unexpectedType]];
+	return desc;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/MissingTokenException.h b/runtime/ObjC/Framework/MissingTokenException.h
new file mode 100644
index 0000000..1ae8103
--- /dev/null
+++ b/runtime/ObjC/Framework/MissingTokenException.h
@@ -0,0 +1,52 @@
+//
+//  ANTLRMissingTokenException.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/8/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRMismatchedTokenException.h"
+#import "ANTLRToken.h"
+
+@interface ANTLRMissingTokenException : ANTLRMismatchedTokenException {
+    id<ANTLRToken> inserted;
+}
+/** Used for remote debugger deserialization */
++ (id) newException;
++ (id) newException:(NSInteger)expected
+             Stream:(id<ANTLRIntStream>)anInput
+               With:(id<ANTLRToken>)insertedToken;
+- (id) init;
+- (id) init:(NSInteger)expected Stream:(id<ANTLRIntStream>)anInput With:(id<ANTLRToken>)insertedToken;
+
+- (NSInteger) getMissingType;
+
+- (NSString *)toString;
+
+@property (retain) id<ANTLRToken> inserted;
+@end
diff --git a/runtime/ObjC/Framework/MissingTokenException.m b/runtime/ObjC/Framework/MissingTokenException.m
new file mode 100644
index 0000000..35bd130
--- /dev/null
+++ b/runtime/ObjC/Framework/MissingTokenException.m
@@ -0,0 +1,83 @@
+//
+//  ANTLRMissingTokenException.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/8/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRMissingTokenException.h"
+
+
+@implementation ANTLRMissingTokenException
+/** Used for remote debugger deserialization */
++ (id) newException
+{
+    return [[ANTLRMissingTokenException alloc] init];
+}
+
++ (id) newException:(NSInteger)expected
+             Stream:(id<ANTLRIntStream>)anInput
+               With:(id<ANTLRToken>)insertedToken
+{
+    return [[ANTLRMissingTokenException alloc] init:expected Stream:anInput With:insertedToken];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil) {
+    }
+    return self;
+}
+
+- (id) init:(NSInteger)expected Stream:(id<ANTLRIntStream>)anInput With:(id<ANTLRToken>)insertedToken
+{
+    if ((self = [super initWithStream:anInput]) != nil) {
+        expecting = expected;
+        input = anInput;
+        inserted = insertedToken;
+    }
+    return self;
+}
+
+- (NSInteger) getMissingType
+{
+    return expecting;
+}
+
+- (NSString *)toString
+{
+    if ( inserted != nil && token != nil ) {
+        return [NSString stringWithFormat:@"MissingTokenException(inserted %@ at %@)", inserted, token.text];
+    }
+    if ( token!=nil ) {
+        return [NSString stringWithFormat:@"MissingTokenException(at %@)", token.text ];
+    }
+    return @"MissingTokenException";
+}
+
+@synthesize inserted;
+@end
diff --git a/runtime/ObjC/Framework/NoViableAltException.h b/runtime/ObjC/Framework/NoViableAltException.h
new file mode 100644
index 0000000..9b2e521
--- /dev/null
+++ b/runtime/ObjC/Framework/NoViableAltException.h
@@ -0,0 +1,45 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRecognitionException.h"
+#import "ANTLRIntStream.h"
+
+@interface ANTLRNoViableAltException : ANTLRRecognitionException {
+	int decisionNumber;
+	int stateNumber;
+}
+
++ (ANTLRNoViableAltException *) newException:(NSInteger)theDecisionNumber state:(NSInteger)theStateNumber stream:(id<ANTLRIntStream>)theStream;
+- (ANTLRNoViableAltException *) initWithDecision:(NSInteger)theDecisionNumber state:(NSInteger)theStateNumber stream:(id<ANTLRIntStream>)theStream;
+
+- (void)setDecisionNumber:(NSInteger)decisionNumber;
+- (void)setStateNumber:(NSInteger)stateNumber;
+
+
+@property (getter=decisionNumber,setter=setDecisionNumber:) NSInteger decisionNumber;
+@property (getter=stateNumber,setter=setStateNumber:) NSInteger stateNumber;
+@end
diff --git a/runtime/ObjC/Framework/NoViableAltException.m b/runtime/ObjC/Framework/NoViableAltException.m
new file mode 100644
index 0000000..e519581
--- /dev/null
+++ b/runtime/ObjC/Framework/NoViableAltException.m
@@ -0,0 +1,83 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRNoViableAltException.h"
+
+
+@implementation ANTLRNoViableAltException
+
+
++ (ANTLRNoViableAltException *) newException:(NSInteger)theDecisionNumber state:(NSInteger)theStateNumber stream:(id<ANTLRIntStream>)theStream
+{
+	return [[self alloc] initWithDecision:theDecisionNumber state:theStateNumber stream:theStream];
+}
+
+
+- (ANTLRNoViableAltException *) initWithDecision:(NSInteger)theDecisionNumber state:(NSInteger)theStateNumber stream:(id<ANTLRIntStream>)theStream
+{
+	if ((self = [super initWithStream:theStream]) != nil) {
+		decisionNumber = theDecisionNumber;
+		stateNumber = theStateNumber;
+	}
+	return self;
+}
+
+- (NSString *) description
+{
+	NSMutableString *desc = (NSMutableString *)[super description];
+	[desc appendFormat:@" decision:%d state:%d", decisionNumber, stateNumber];
+	return desc;
+}
+
+//----------------------------------------------------------
+//  decisionNumber
+//----------------------------------------------------------
+- (NSInteger) decisionNumber
+{
+    return decisionNumber;
+}
+
+- (void) setDecisionNumber: (NSInteger) aDecisionNumber
+{
+    decisionNumber = aDecisionNumber;
+}
+
+//----------------------------------------------------------
+//  stateNumber
+//----------------------------------------------------------
+- (NSInteger) stateNumber
+{
+    return stateNumber;
+}
+
+- (void) setStateNumber: (NSInteger) aStateNumber
+{
+    stateNumber = aStateNumber;
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/NodeMapElement.h b/runtime/ObjC/Framework/NodeMapElement.h
new file mode 100644
index 0000000..3bbf7b7
--- /dev/null
+++ b/runtime/ObjC/Framework/NodeMapElement.h
@@ -0,0 +1,56 @@
+//
+//  ANTLRRuleMapElement.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseMapElement.h"
+#import "ANTLRBaseTree.h"
+
+@interface ANTLRNodeMapElement : ANTLRBaseMapElement {
+    id<ANTLRBaseTree> node;
+}
+
+@property (retain, getter=getNode, setter=setNode:) id<ANTLRBaseTree> node;
+
++ (void)initialize;
+
++ (id) newANTLRNodeMapElement;
++ (id) newANTLRNodeMapElementWithIndex:(id)anIndex Node:(id<ANTLRBaseTree>)aNode;
+- (id) init;
+- (id) initWithAnIndex:(id)anIndex Node:(id)aNode;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (id<ANTLRBaseTree>)getNode;
+- (void)setNode:(id<ANTLRBaseTree>)aNode;
+
+- (NSInteger)size;
+
+@end
diff --git a/runtime/ObjC/Framework/NodeMapElement.m b/runtime/ObjC/Framework/NodeMapElement.m
new file mode 100644
index 0000000..06f35cc
--- /dev/null
+++ b/runtime/ObjC/Framework/NodeMapElement.m
@@ -0,0 +1,108 @@
+//
+//  ANTLRNodeMapElement.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRNodeMapElement.h"
+
+static NSInteger _aUniqueID;
+
+@implementation ANTLRNodeMapElement
+
+@synthesize node;
+
++ (void)initialize
+{
+    _aUniqueID = 0;
+}
+
++ (ANTLRNodeMapElement *)newANTLRNodeMapElement
+{
+    return [[ANTLRNodeMapElement alloc] init];
+}
+
++ (ANTLRNodeMapElement *)newANTLRNodeMapElementWithIndex:(id)anIndex Node:(id<ANTLRBaseTree>)aNode
+{
+    return [[ANTLRNodeMapElement alloc] initWithAnIndex:anIndex Node:aNode];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil ) {
+        index = nil;
+        node = nil;
+    }
+    return (self);
+}
+
+- (id) initWithAnIndex:(id)anIndex Node:(id)aNode
+{
+    self = [super initWithAnIndex:anIndex];
+    if ( self ) {
+        if ( aNode != node ) {
+            if ( node ) [node release];
+            [aNode retain];
+        }
+        node = aNode;
+    }
+    return (self);
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRNodeMapElement *copy;
+
+    copy = [super copyWithZone:aZone];
+    copy.node = node;
+    return( copy );
+}
+
+- (id<ANTLRBaseTree>)getNode
+{
+    return node;
+}
+
+- (void)setNode:(id<ANTLRBaseTree>)aNode
+{
+    if ( aNode != node ) {
+        if ( node ) [node release];
+        [aNode retain];
+    }
+    node = aNode;
+}
+
+- (NSInteger)size
+{
+    NSInteger aSize = 0;
+    if (node != nil) aSize += sizeof(id);
+    if (index != nil) aSize += sizeof(id);
+    return( aSize );
+}
+
+@end
diff --git a/runtime/ObjC/Framework/ParseTree.h b/runtime/ObjC/Framework/ParseTree.h
new file mode 100644
index 0000000..5331005
--- /dev/null
+++ b/runtime/ObjC/Framework/ParseTree.h
@@ -0,0 +1,64 @@
+//
+//  ANTLRParseTree.h
+//  ANTLR
+//
+//  Created by Alan Condit on 7/12/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseTree.h"
+#import "ANTLRCommonToken.h"
+#import "AMutableArray.h"
+
+@interface ANTLRParseTree : ANTLRBaseTree <ANTLRBaseTree> {
+	__strong id<ANTLRToken> payload;
+	__strong AMutableArray *hiddenTokens;
+}
+/** A record of the rules used to match a token sequence.  The tokens
+ *  end up as the leaves of this tree and rule nodes are the interior nodes.
+ *  This really adds no functionality, it is just an alias for CommonTree
+ *  that is more meaningful (specific) and holds a String to display for a node.
+ */
++ (id<ANTLRBaseTree>)newANTLRParseTree:(id<ANTLRToken>)label;
+- (id)initWithLabel:(id<ANTLRToken>)label;
+
+- (id<ANTLRBaseTree>)dupNode;
+- (NSInteger)type;
+- (NSString *)text;
+- (NSInteger)getTokenStartIndex;
+- (void)setTokenStartIndex:(NSInteger)index;
+- (NSInteger)getTokenStopIndex;
+- (void)setTokenStopIndex:(NSInteger)index;
+- (NSString *)description;
+- (NSString *)toString;
+- (NSString *)toStringWithHiddenTokens;
+- (NSString *)toInputString;
+- (void)_toStringLeaves:(NSMutableString *)buf;
+
+@property (retain) id<ANTLRToken> payload;
+@property (retain) AMutableArray *hiddenTokens;
+@end
diff --git a/runtime/ObjC/Framework/ParseTree.m b/runtime/ObjC/Framework/ParseTree.m
new file mode 100644
index 0000000..8339640
--- /dev/null
+++ b/runtime/ObjC/Framework/ParseTree.m
@@ -0,0 +1,149 @@
+//
+//  ANTLRParseTree.m
+//  ANTLR
+//
+//  Created by Alan Condit on 7/12/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRParseTree.h"
+
+/** A record of the rules used to match a token sequence.  The tokens
+ *  end up as the leaves of this tree and rule nodes are the interior nodes.
+ *  This really adds no functionality, it is just an alias for CommonTree
+ *  that is more meaningful (specific) and holds a String to display for a node.
+ */
+@implementation ANTLRParseTree
++ (ANTLRParseTree *)newANTLRParseTree:(id<ANTLRToken>)label
+{
+    return [[ANTLRParseTree alloc] initWithLabel:label];
+}
+
+- (id)initWithLabel:(id<ANTLRToken>)label
+{
+    self = [super init];
+    if ( self != nil) {
+        payload = [label retain];
+    }
+    return self;
+}
+
+- (id<ANTLRBaseTree>)dupNode
+{
+    return nil;
+}
+
+- (NSInteger)type
+{
+    return 0;
+}
+
+- (NSString *)text
+{
+    return [self toString];
+}
+
+- (NSInteger)getTokenStartIndex
+{
+    return 0;
+}
+
+- (void)setTokenStartIndex:(NSInteger)anIndex
+{
+}
+
+- (NSInteger)getTokenStopIndex
+{
+    return 0;
+}
+
+- (void)setTokenStopIndex:(NSInteger)anIndex
+{
+}
+
+- (NSString *)description
+{
+    if ( [payload isKindOfClass:[ANTLRCommonToken class]] ) {
+        id<ANTLRToken> t = (id<ANTLRToken>)payload;
+        if ( t.type == ANTLRTokenTypeEOF ) {
+            return @"<EOF>";
+        }
+        return [t text];
+    }
+    return [payload description];
+}
+
+- (NSString *)toString
+{
+    return [self description];
+}
+
+/** Emit a token and all hidden nodes before.  EOF node holds all
+ *  hidden tokens after last real token.
+ */
+- (NSString *)toStringWithHiddenTokens
+{
+    NSMutableString *buf = [NSMutableString stringWithCapacity:25];
+    if ( hiddenTokens!=nil ) {
+        for (NSUInteger i = 0; i < [hiddenTokens count]; i++) {
+            id<ANTLRToken>  hidden = (id<ANTLRToken> ) [hiddenTokens objectAtIndex:i];
+            [buf appendString:[hidden text]];
+        }
+    }
+    NSString *nodeText = [self toString];
+    if ( ![nodeText isEqualTo:@"<EOF>"] )
+        [buf appendString:nodeText];
+    return buf;
+}
+
+/** Print out the leaves of this tree, which means printing original
+ *  input back out.
+ */
+- (NSString *)toInputString
+{
+    NSMutableString *buf = [NSMutableString stringWithCapacity:25];
+    [self _toStringLeaves:buf];
+    return buf;
+}
+
+- (void)_toStringLeaves:(NSMutableString *)buf
+{
+    if ( [payload isKindOfClass:[ANTLRCommonToken class]] ) { // leaf node token?
+        [buf appendString:[self toStringWithHiddenTokens]];
+        return;
+    }
+    for (int i = 0; children!=nil && i < [children count]; i++) {
+        ANTLRParseTree *t = (ANTLRParseTree *) [children objectAtIndex:i];
+        [t _toStringLeaves:buf];
+    }
+}
+
+@synthesize payload;
+@synthesize hiddenTokens;
+@synthesize children;
+@synthesize anException;
+
+@end
diff --git a/runtime/ObjC/Framework/Parser.h b/runtime/ObjC/Framework/Parser.h
new file mode 100644
index 0000000..067b313
--- /dev/null
+++ b/runtime/ObjC/Framework/Parser.h
@@ -0,0 +1,59 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseRecognizer.h"
+#import "ANTLRCommonToken.h"
+#import "ANTLRTokenStream.h"
+
+@interface ANTLRParser : ANTLRBaseRecognizer {
+	id<ANTLRTokenStream> input;
+}
++ (ANTLRParser *)newANTLRParser:(id<ANTLRTokenStream>)anInput;
++ (ANTLRParser *)newANTLRParser:(id<ANTLRTokenStream>)anInput State:(ANTLRRecognizerSharedState *)aState;
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream;
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream State:(ANTLRRecognizerSharedState *)aState;
+
+- (id<ANTLRTokenStream>) input;
+- (void) setInput: (id<ANTLRTokenStream>) anInput;
+
+- (void) reset;
+
+- (id) getCurrentInputSymbol:(id<ANTLRTokenStream>)anInput;
+- (ANTLRCommonToken *)getMissingSymbol:(id<ANTLRTokenStream>)input
+                             Exception:(ANTLRRecognitionException *)e
+                                 TType:(NSInteger)expectedTokenType
+                                BitSet:(ANTLRBitSet *)follow;
+- (void) setTokenStream:(id<ANTLRTokenStream>)anInput;
+- (id<ANTLRTokenStream>)getTokenStream;
+- (NSString *)getSourceName;
+
+- (void) traceIn:(NSString *)ruleName Index:(int)ruleIndex;
+- (void) traceOut:(NSString *)ruleName Index:(NSInteger) ruleIndex;
+
+@end
diff --git a/runtime/ObjC/Framework/Parser.m b/runtime/ObjC/Framework/Parser.m
new file mode 100644
index 0000000..df559b2
--- /dev/null
+++ b/runtime/ObjC/Framework/Parser.m
@@ -0,0 +1,147 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRParser.h"
+
+
+@implementation ANTLRParser
+
++ (ANTLRParser *)newANTLRParser:(id<ANTLRTokenStream>)anInput
+{
+    return [[ANTLRParser alloc] initWithTokenStream:anInput];
+}
+
++ (ANTLRParser *)newANTLRParser:(id<ANTLRTokenStream>)anInput State:(ANTLRRecognizerSharedState *)aState
+{
+    return [[ANTLRParser alloc] initWithTokenStream:anInput State:aState];
+}
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream
+{
+	if ((self = [super init]) != nil) {
+		input = theStream;
+	}
+	return self;
+}
+
+- (id) initWithTokenStream:(id<ANTLRTokenStream>)theStream State:(ANTLRRecognizerSharedState *)aState
+{
+	if ((self = [super initWithState:aState]) != nil) {
+        input = theStream;
+	}
+	return self;
+}
+
+- (void) reset
+{
+    [super reset]; // reset all recognizer state variables
+    if ( input!=nil ) {
+        [input seek:0]; // rewind the input
+    }
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRParser" );
+#endif
+	[self setInput:nil];
+	[super dealloc];
+}
+
+//----------------------------------------------------------
+//  input
+//----------------------------------------------------------
+- (id<ANTLRTokenStream>) input
+{
+    return input;
+}
+
+- (void) setInput: (id<ANTLRTokenStream>) anInput
+{
+    if (input != anInput) {
+        if ( input ) [input release];
+        [anInput retain];
+    }
+    input = anInput;
+}
+
+- (id) getCurrentInputSymbol:(id<ANTLRTokenStream>)anInput
+{
+    state.token = [input LT:1];
+    return state.token;
+}
+
+- (ANTLRCommonToken *)getMissingSymbol:(id<ANTLRTokenStream>)anInput
+                             Exception:(ANTLRRecognitionException *)e
+                                 TType:(NSInteger)expectedTokenType
+                                BitSet:(ANTLRBitSet *)follow
+{
+    NSString *tokenText = nil;
+    if ( expectedTokenType == ANTLRTokenTypeEOF )
+        tokenText = @"<missing EOF>";
+    else
+        tokenText = [NSString stringWithFormat:@"<missing %@>\n",[[ANTLRBaseRecognizer getTokenNames] objectAtIndex:expectedTokenType]];
+    ANTLRCommonToken *t = [[ANTLRCommonToken newToken:expectedTokenType Text:tokenText] retain];
+    ANTLRCommonToken *current = [anInput LT:1];
+    if ( current.type == ANTLRTokenTypeEOF ) {
+        current = [anInput LT:-1];
+    }
+    t.line = current.line;
+    t.charPositionInLine = current.charPositionInLine;
+    t.channel = ANTLRTokenChannelDefault;
+    return t;
+}
+
+/** Set the token stream and reset the parser */
+- (void) setTokenStream:(id<ANTLRTokenStream>)anInput
+{
+    input = nil;
+    [self reset];
+    input = anInput;
+}
+
+- (id<ANTLRTokenStream>)getTokenStream
+{
+    return input;
+}
+
+- (NSString *)getSourceName
+{
+    return [input getSourceName];
+}
+
+- (void) traceIn:(NSString *)ruleName Index:(int)ruleIndex
+{
+    [super traceIn:ruleName Index:ruleIndex Object:[input LT:1]];
+}
+
+- (void) traceOut:(NSString *)ruleName Index:(NSInteger) ruleIndex
+{
+    [super traceOut:ruleName Index:ruleIndex Object:[input LT:1]];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/ParserRuleReturnScope.h b/runtime/ObjC/Framework/ParserRuleReturnScope.h
new file mode 100644
index 0000000..d788c21
--- /dev/null
+++ b/runtime/ObjC/Framework/ParserRuleReturnScope.h
@@ -0,0 +1,46 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRToken.h"
+#import "ANTLRRuleReturnScope.h"
+
+@interface ANTLRParserRuleReturnScope : ANTLRRuleReturnScope {
+	id<ANTLRToken> start;
+	id<ANTLRToken> stopToken;
+}
+@property (retain, getter=getStart, setter=setStart:) id<ANTLRToken> start;
+@property (retain, getter=getStop, setter=setStop:)   id<ANTLRToken> stopToken;
+
+- (id<ANTLRToken>) getStart;
+- (void) setStart: (id<ANTLRToken>) aStart;
+
+- (id<ANTLRToken>) getStop;
+- (void) setStop: (id<ANTLRToken>) aStop;
+
+- (id) copyWithZone:(NSZone *)theZone;
+
+@end
diff --git a/runtime/ObjC/Framework/ParserRuleReturnScope.m b/runtime/ObjC/Framework/ParserRuleReturnScope.m
new file mode 100644
index 0000000..2bc2392
--- /dev/null
+++ b/runtime/ObjC/Framework/ParserRuleReturnScope.m
@@ -0,0 +1,80 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRParserRuleReturnScope.h"
+
+
+@implementation ANTLRParserRuleReturnScope
+
+@synthesize start;
+@synthesize stopToken;
+
+- (void) dealloc
+{
+    [self setStart:nil];
+    [self setStop:nil];
+    [super dealloc];
+}
+
+- (id<ANTLRToken>) getStart
+{
+    return start;
+}
+
+- (void) setStart: (id<ANTLRToken>) aStart
+{
+    if (start != aStart) {
+        [aStart retain];
+        if ( start ) [start release];
+        start = aStart;
+    }
+}
+
+- (id<ANTLRToken>) getStop
+{
+    return stopToken;
+}
+
+- (void) setStop: (id<ANTLRToken>) aStop
+{
+    if (stopToken != aStop) {
+        [aStop retain];
+        if ( stopToken ) [stopToken release];
+        stopToken = aStop;
+    }
+}
+
+// create a copy, including the text if available
+// the input stream is *not* copied!
+- (id) copyWithZone:(NSZone *)theZone
+{
+    ANTLRParserRuleReturnScope *copy = [super copyWithZone:theZone];
+    copy.start = start;
+    copy.stopToken = stopToken;
+    return copy;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/PtrBuffer.h b/runtime/ObjC/Framework/PtrBuffer.h
new file mode 100644
index 0000000..baf929b
--- /dev/null
+++ b/runtime/ObjC/Framework/PtrBuffer.h
@@ -0,0 +1,93 @@
+//
+//  ANTLRPtrBuffer.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRLinkBase.h"
+
+//#define GLOBAL_SCOPE       0
+//#define LOCAL_SCOPE        1
+#define BUFFSIZE         101
+
+@interface ANTLRPtrBuffer : ANTLRLinkBase {
+    NSUInteger BuffSize;
+    NSUInteger count;
+    NSUInteger ptr;
+    __strong NSMutableData *buffer;
+    __strong id *ptrBuffer;
+}
+
+@property (getter=getBuffSize, setter=setBuffSize:) NSUInteger BuffSize;
+@property (getter=getCount, setter=setCount:) NSUInteger count;
+@property (getter=getPtr, setter=setPtr:) NSUInteger ptr;
+@property (retain, getter=getBuffer, setter=setBuffer:) NSMutableData *buffer;
+@property (assign, getter=getPtrBuffer, setter=setPtrBuffer:) id *ptrBuffer;
+
+// Contruction/Destruction
++(ANTLRPtrBuffer *)newANTLRPtrBuffer;
++(ANTLRPtrBuffer *)newANTLRPtrBufferWithLen:(NSInteger)cnt;
+-(id)init;
+-(id)initWithLen:(NSUInteger)cnt;
+-(void)dealloc;
+
+// Instance Methods
+- (id) copyWithZone:(NSZone *)aZone;
+/* clear -- reinitialize the maplist array */
+- (void) clear;
+
+- (NSUInteger)count;
+- (NSUInteger)length;
+- (NSUInteger)size;
+
+- (NSMutableData *)getBuffer;
+- (void)setBuffer:(NSMutableData *)np;
+- (NSUInteger)getCount;
+- (void)setCount:(NSUInteger)aCount;
+- (id *)getPtrBuffer;
+- (void)setPtrBuffer:(id *)np;
+- (NSUInteger)getPtr;
+- (void)setPtr:(NSUInteger)np;
+
+- (void) push:(id) v;
+- (id) pop;
+- (id) peek;
+
+- (void) addObject:(id) v;
+- (void) addObjectsFromArray:(ANTLRPtrBuffer *)anArray;
+- (void) insertObject:(id)aRule atIndex:(NSUInteger)idx;
+- (id)   objectAtIndex:(NSUInteger)idx;
+- (void) removeAllObjects;
+- (void)removeObjectAtIndex:(NSInteger)idx;
+
+- (void) ensureCapacity:(NSUInteger) index;
+- (NSString *) description;
+- (NSString *) toString;
+
+@end
diff --git a/runtime/ObjC/Framework/PtrBuffer.m b/runtime/ObjC/Framework/PtrBuffer.m
new file mode 100644
index 0000000..392a7b7
--- /dev/null
+++ b/runtime/ObjC/Framework/PtrBuffer.m
@@ -0,0 +1,353 @@
+//
+//  ANTLRPtrBuffer.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#define SUCCESS (0)
+#define FAILURE (-1)
+
+#import "ANTLRPtrBuffer.h"
+#import "ANTLRTree.h"
+
+/*
+ * Start of ANTLRPtrBuffer
+ */
+@implementation ANTLRPtrBuffer
+
+@synthesize BuffSize;
+@synthesize buffer;
+@synthesize ptrBuffer;
+@synthesize count;
+@synthesize ptr;
+
++(ANTLRPtrBuffer *)newANTLRPtrBuffer
+{
+    return [[ANTLRPtrBuffer alloc] init];
+}
+
++(ANTLRPtrBuffer *)newANTLRPtrBufferWithLen:(NSInteger)cnt
+{
+    return [[ANTLRPtrBuffer alloc] initWithLen:cnt];
+}
+
+-(id)init
+{
+    NSUInteger idx;
+
+    self = [super init];
+    if ( self != nil ) {
+        BuffSize  = BUFFSIZE;
+        ptr = 0;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
+        ptrBuffer = (id *) [buffer mutableBytes];
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            ptrBuffer[idx] = nil;
+        }
+        count = 0;
+    }
+    return( self );
+}
+
+-(id)initWithLen:(NSUInteger)cnt
+{
+    NSUInteger idx;
+
+    self = [super init];
+    if ( self != nil ) {
+        BuffSize  = cnt;
+        ptr = 0;
+        buffer = [[NSMutableData dataWithLength:(NSUInteger)BuffSize * sizeof(id)] retain];
+        ptrBuffer = (id *)[buffer mutableBytes];
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            ptrBuffer[idx] = nil;
+        }
+        count = 0;
+    }
+    return( self );
+}
+
+-(void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRPtrBuffer" );
+#endif
+    ANTLRLinkBase *tmp, *rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            tmp = ptrBuffer[idx];
+            while ( tmp ) {
+                rtmp = tmp;
+                if ([tmp isKindOfClass:[ANTLRLinkBase class]])
+                    tmp = (id)tmp.fNext;
+                else
+                    tmp = nil;
+                [rtmp release];
+            }
+        }
+    }
+    [buffer release];
+    [super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRPtrBuffer *copy;
+
+    copy = [[[self class] allocWithZone:aZone] init];
+    if ( buffer )
+        copy.buffer = [buffer copyWithZone:aZone];
+    copy.ptrBuffer = ptrBuffer;
+    copy.ptr = ptr;
+    return copy;
+}
+
+- (void)clear
+{
+    ANTLRLinkBase *tmp, *rtmp;
+    NSInteger idx;
+
+    for( idx = 0; idx < BuffSize; idx++ ) {
+        tmp = ptrBuffer[idx];
+        while ( tmp ) {
+            rtmp = tmp;
+            if ([tmp isKindOfClass:[ANTLRLinkBase class]])
+                tmp = (id)tmp.fNext;
+            else
+                tmp = nil;
+            [rtmp dealloc];
+        }
+        ptrBuffer[idx] = nil;
+    }
+    count = 0;
+}
+
+- (NSMutableData *)getBuffer
+{
+    return( buffer );
+}
+
+- (void)setBuffer:(NSMutableData *)np
+{
+    buffer = np;
+}
+
+- (NSUInteger)getCount
+{
+    return( count );
+}
+
+- (void)setCount:(NSUInteger)aCount
+{
+    count = aCount;
+}
+
+- (id *)getPtrBuffer
+{
+    return( ptrBuffer );
+}
+
+- (void)setPtrBuffer:(id *)np
+{
+    ptrBuffer = np;
+}
+
+- (NSUInteger)getPtr
+{
+    return( ptr );
+}
+
+- (void)setPtr:(NSUInteger)aPtr
+{
+    ptr = aPtr;
+}
+
+- (void) addObject:(id) v
+{
+    [self ensureCapacity:ptr];
+    if ( v ) [v retain];
+    ptrBuffer[ptr++] = v;
+    count++;
+}
+
+- (void) push:(id) v
+{
+    if ( ptr >= BuffSize - 1 ) {
+        [self ensureCapacity:ptr];
+    }
+    if ( v ) [v retain];
+    ptrBuffer[ptr++] = v;
+    count++;
+}
+
+- (id) pop
+{
+    id v = nil;
+    if ( ptr > 0 ) {
+        v = ptrBuffer[--ptr];
+        ptrBuffer[ptr] = nil;
+    }
+    count--;
+    if ( v ) [v release];
+    return v;
+}
+
+- (id) peek
+{
+    id v = nil;
+    if ( ptr > 0 ) {
+        v = ptrBuffer[ptr-1];
+    }
+    return v;
+}
+
+- (NSUInteger)count
+{
+#ifdef DONTUSENOMO
+    int cnt = 0;
+
+    for (NSInteger i = 0; i < BuffSize; i++ ) {
+        if ( ptrBuffer[i] != nil ) {
+            cnt++;
+        }
+    }
+    if ( cnt != count ) count = cnt;
+#endif
+    return count;
+}
+
+- (NSUInteger)length
+{
+    return BuffSize;
+}
+
+- (NSUInteger)size
+{
+    NSUInteger aSize = 0;
+    for (int i = 0; i < BuffSize; i++ ) {
+        if (ptrBuffer[i] != nil) {
+            aSize += sizeof(id);
+        }
+    }
+    return aSize;
+}
+
+- (void) insertObject:(id)aRule atIndex:(NSUInteger)idx
+{
+    if ( idx >= BuffSize ) {
+        [self ensureCapacity:idx];
+    }
+    if ( aRule != ptrBuffer[idx] ) {
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
+        if ( aRule ) [aRule retain];
+    }
+    ptrBuffer[idx] = aRule;
+    count++;
+}
+
+- (id)objectAtIndex:(NSUInteger)idx
+{
+    if ( idx < BuffSize ) {
+        return ptrBuffer[idx];
+    }
+    return nil;
+}
+
+- (void)addObjectsFromArray:(ANTLRPtrBuffer *)anArray
+{
+    NSInteger cnt, i;
+    cnt = [anArray count];
+    for( i = 0; i < cnt; i++) {
+        id tmp = [anArray objectAtIndex:i];
+        if ( tmp ) [tmp retain];
+        [self insertObject:tmp atIndex:i];
+    }
+    count += cnt;
+    return;
+}
+
+- (void)removeAllObjects
+{
+    int i;
+    for ( i = 0; i < BuffSize; i++ ) {
+        if ( ptrBuffer[i] ) [ptrBuffer[i] release];
+        ptrBuffer[i] = nil;
+    }
+    count = 0;
+    ptr = 0;
+}
+
+- (void)removeObjectAtIndex:(NSInteger)idx
+{
+    int i;
+    if ( idx >= 0 && idx < count ) {
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
+        for ( i = idx; i < count-1; i++ ) {
+            ptrBuffer[i] = ptrBuffer[i+1];
+        }
+        ptrBuffer[i] = nil;
+        count--;
+    }
+}
+
+- (void) ensureCapacity:(NSUInteger) anIndex
+{
+    if ((anIndex * sizeof(id)) >= [buffer length])
+    {
+        NSInteger newSize = ([buffer length] / sizeof(id)) * 2;
+        if (anIndex > newSize) {
+            newSize = anIndex + 1;
+        }
+        BuffSize = newSize;
+        [buffer setLength:(BuffSize * sizeof(id))];
+        ptrBuffer = [buffer mutableBytes];
+    }
+}
+
+- (NSString *) description
+{
+    NSMutableString *str;
+    NSInteger idx, cnt;
+    cnt = [self count];
+    str = [NSMutableString stringWithCapacity:30];
+    [str appendString:@"["];
+    for (idx = 0; idx < cnt; idx++ ) {
+        [str appendString:[[self objectAtIndex:idx] description]];
+    }
+    [str appendString:@"]"];
+    return str;
+}
+
+- (NSString *) toString
+{
+    return [self description];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/PtrStack.h b/runtime/ObjC/Framework/PtrStack.h
new file mode 100644
index 0000000..7aa65a9
--- /dev/null
+++ b/runtime/ObjC/Framework/PtrStack.h
@@ -0,0 +1,51 @@
+//
+//  ANTLRPtrStack.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+//  Copyright 2010 Alan's MachineWorks. All rights reserved.
+//ptrBuffer
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseStack.h"
+#import "ANTLRRuleMemo.h"
+
+//#define GLOBAL_SCOPE       0
+//#define LOCAL_SCOPE        1
+#define HASHSIZE         101
+#define HBUFSIZE      0x2000
+
+@interface ANTLRPtrStack : ANTLRBaseStack {
+	//ANTLRPtrStack *fNext;
+    // TStringPool *fPool;
+}
+
+//@property (copy) ANTLRPtrStack *fNext;
+//@property (copy) TStringPool *fPool;
+
+// Contruction/Destruction
++ (ANTLRPtrStack *)newANTLRPtrStack;
++ (ANTLRPtrStack *)newANTLRPtrStack:(NSInteger)cnt;
+- (id)init;
+- (id)initWithLen:(NSInteger)aLen;
+- (void)dealloc;
+
+// Instance Methods
+- (id) copyWithZone:(NSZone *)aZone;
+/* clear -- reinitialize the maplist array */
+
+#ifdef DONTUSENOMO
+/* form hash value for string s */
+- (NSInteger)hash:(NSString *)s;
+/*   look for s in ptrBuffer  */
+- (id)lookup:(NSString *)s;
+/* look for s in ptrBuffer  */
+- (id)install:(id)sym;
+#endif
+
+#ifdef DONTUSENOMO
+- (id)getTType:(NSString *)name;
+- (id)getName:(NSInteger)ttype;
+#endif
+
+@end
diff --git a/runtime/ObjC/Framework/PtrStack.m b/runtime/ObjC/Framework/PtrStack.m
new file mode 100644
index 0000000..5b180f2
--- /dev/null
+++ b/runtime/ObjC/Framework/PtrStack.m
@@ -0,0 +1,191 @@
+//
+//  ANTLRPtrStack.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+//  Copyright 2010 Alan's MachineWorks. All rights reserved.
+//
+#define SUCCESS (0)
+#define FAILURE (-1)
+
+#import "ANTLRPtrStack.h"
+#import "ANTLRTree.h"
+
+/*
+ * Start of ANTLRPtrStack
+ */
+@implementation ANTLRPtrStack
+
++(ANTLRPtrStack *)newANTLRPtrStack
+{
+    return [[ANTLRPtrStack alloc] init];
+}
+
++(ANTLRPtrStack *)newANTLRPtrStack:(NSInteger)cnt
+{
+    return [[ANTLRPtrStack alloc] initWithLen:cnt];
+}
+
+-(id)init
+{
+	self = [super initWithLen:HASHSIZE];
+	if ( self != nil ) {
+	}
+    return( self );
+}
+
+-(id)initWithLen:(NSInteger)cnt
+{
+	self = [super initWithLen:cnt];
+	if ( self != nil ) {
+	}
+    return( self );
+}
+
+-(void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRPtrStack" );
+#endif
+	[super dealloc];
+}
+
+-(void)deleteANTLRPtrStack:(ANTLRPtrStack *)np
+{
+    ANTLRLinkBase *tmp, *rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < BuffSize; idx++ ) {
+            tmp = ptrBuffer[idx];
+            while ( tmp ) {
+                rtmp = tmp;
+                tmp = [tmp getfNext];
+                [rtmp release];
+            }
+        }
+    }
+}
+
+#ifdef DONTUSENOMO
+#ifdef USERDOC
+/*
+ *  HASH        hash entry to get index to table
+ *  NSInteger hash( ANTLRPtrStack *self, char *s );
+ *
+ *     Inputs:  NSString *s         string to find
+ *
+ *     Returns: NSInteger                 hashed value
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(NSInteger)hash:(NSString *)s       /*    form hash value for string s */
+{
+	NSInteger hashval;
+	const char *tmp;
+
+	tmp = [s cStringUsingEncoding:NSASCIIStringEncoding];
+	for( hashval = 0; *tmp != '\0'; )
+        hashval += *tmp++;
+	LastHash = hashval % HashSize;
+	return( LastHash );
+}
+
+#ifdef USERDOC
+/*
+ *  LOOKUP  search hashed list for entry
+ *  id lookup:(NSString *)s;
+ *
+ *     Inputs:  NSString  *s       string to find
+ *
+ *     Returns: ANTLRRuleMemo  *        pointer to entry
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(id)lookup:(NSString *)s
+{
+    ANTLRLinkBase *np;
+
+    for( np = ptrBuffer[[self hash:s]]; np != nil; np = [np getfNext] ) {
+        if ( [s isEqualToString:[np getName]] ) {
+            return( np );        /*   found it       */
+        }
+    }
+    return( nil );              /*   not found      */
+}
+
+#ifdef USERDOC
+/*
+ *  INSTALL search hashed list for entry
+ *  NSInteger install( ANTLRPtrStack *self, id sym );
+ *
+ *     Inputs:  ANTLRRuleMemo    *sym   -- symbol ptr to install
+ *              NSInteger         scope -- level to find
+ *
+ *     Returns: Boolean     TRUE   if installed
+ *                          FALSE  if already in table
+ *
+ *  Last Revision 9/03/90
+ */
+#endif
+-(id)install:(id)sym
+{
+    ANTLRLinkBase *np;
+
+    np = [self lookup:[sym getName]];
+    if ( np == nil ) {
+        [sym setFNext:ptrBuffer[ LastHash ]];
+        ptrBuffer[ LastHash ] = [sym retain];
+        return( ptrBuffer[ LastHash ] );
+    }
+    return( nil );            /*   not found      */
+}
+#endif
+
+-(id)getptrBufferEntry:(NSInteger)idx
+{
+	return( ptrBuffer[idx] );
+}
+
+-(id *)getptrBuffer
+{
+	return( ptrBuffer );
+}
+
+-(void)setptrBuffer:(id *)np
+{
+    ptrBuffer = np;
+}
+
+#ifdef DONTUSENOMO
+/*
+ * works only for maplist indexed not by name but by TokenNumber
+ */
+- (id)getName:(NSInteger)ttype
+{
+    id np;
+    NSInteger aTType;
+
+    aTType = ttype % HashSize;
+    for( np = ptrBuffer[ttype]; np != nil; np = [np getfNext] ) {
+        if ( np.index == ttype ) {
+            return( np );        /*   found it       */
+        }
+    }
+    return( nil );              /*   not found      */
+}
+
+- (id)getTType:(NSString *)name
+{
+    return [self lookup:name];
+}
+#endif
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    return [super copyWithZone:aZone];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RecognitionException.h b/runtime/ObjC/Framework/RecognitionException.h
new file mode 100644
index 0000000..9bd799d
--- /dev/null
+++ b/runtime/ObjC/Framework/RecognitionException.h
@@ -0,0 +1,74 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRuntimeException.h"
+#import "ANTLRToken.h"
+#import "ANTLRIntStream.h"
+#import "ANTLRBaseTree.h"
+
+@interface ANTLRRecognitionException : ANTLRRuntimeException {
+	id<ANTLRIntStream> input;
+	NSInteger index;
+	id<ANTLRToken> token;
+	id<ANTLRBaseTree> node;
+	unichar c;
+	NSUInteger line;
+	NSUInteger charPositionInLine;
+}
+
+@property (retain, getter=getStream, setter=setStream:) id<ANTLRIntStream> input;
+@property (assign) NSInteger index;
+@property (retain, getter=getToken, setter=setToken:) id<ANTLRToken>token;
+@property (retain, getter=getNode, setter=setNode:) id<ANTLRBaseTree>node;
+@property (assign) unichar c;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;
+
++ (id) newException;
++ (id) newException:(id<ANTLRIntStream>) anInputStream;
+- (id) init;
+- (id) initWithStream:(id<ANTLRIntStream>)anInputStream;
+- (id) initWithStream:(id<ANTLRIntStream>)anInputStream reason:(NSString *)aReason;
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (NSInteger) unexpectedType;
+- (id<ANTLRToken>)getUnexpectedToken;
+
+- (id<ANTLRIntStream>) getStream;
+- (void) setStream: (id<ANTLRIntStream>) aStream;
+
+- (id<ANTLRToken>) getToken;
+- (void) setToken: (id<ANTLRToken>) aToken;
+
+- (id<ANTLRBaseTree>) getNode;
+- (void) setNode: (id<ANTLRBaseTree>) aNode;
+
+- (NSString *)getMessage;
+
+
+@end
diff --git a/runtime/ObjC/Framework/RecognitionException.m b/runtime/ObjC/Framework/RecognitionException.m
new file mode 100644
index 0000000..0d0e11f
--- /dev/null
+++ b/runtime/ObjC/Framework/RecognitionException.m
@@ -0,0 +1,215 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRecognitionException.h"
+#import "ANTLRTokenStream.h"
+#import "ANTLRTreeNodeStream.h"
+
+@implementation ANTLRRecognitionException
+
+@synthesize input;
+@synthesize token;
+@synthesize node;
+@synthesize line;
+@synthesize charPositionInLine;
+
++ (id) newException
+{
+	return [[ANTLRRecognitionException alloc] init];
+}
+
++ (id) newException:(id<ANTLRIntStream>) anInputStream
+{
+	return [[ANTLRRecognitionException alloc] initWithStream:anInputStream];
+}
+
++ (id) newException:(id<ANTLRIntStream>) anInputStream reason:(NSString *)aReason
+{
+	return [[ANTLRRecognitionException alloc] initWithStream:anInputStream reason:aReason];
+}
+
+- (id) init
+{
+	self = [super initWithName:@"Recognition Exception" reason:@"Recognition Exception" userInfo:nil];
+	if ( self != nil ) {
+	}
+	return self;
+}
+
+- (id) initWithStream:(id<ANTLRIntStream>)anInputStream reason:(NSString *)aReason
+{
+	self = [super initWithName:NSStringFromClass([self class]) reason:aReason userInfo:nil];
+	if ( self != nil ) {
+		[self setStream:anInputStream];
+		index = input.index;
+
+		Class inputClass = [input class];
+		if ([inputClass conformsToProtocol:@protocol(ANTLRTokenStream)]) {
+			[self setToken:[(id<ANTLRTokenStream>)input LT:1]];
+			line = token.line;
+			charPositionInLine = token.charPositionInLine;
+		} else if ([inputClass conformsToProtocol:@protocol(ANTLRCharStream)]) {
+			c = (unichar)[input LA:1];
+			line = ((id<ANTLRCharStream>)input).line;
+			charPositionInLine = ((id<ANTLRCharStream>)input).charPositionInLine;
+		} else if ([inputClass conformsToProtocol:@protocol(ANTLRTreeNodeStream)]) {
+			[self setNode:[(id<ANTLRTreeNodeStream>)input LT:1]];
+			line = [node line];
+			charPositionInLine = [node charPositionInLine];
+		} else {
+			c = (unichar)[input LA:1];
+		}
+	}
+	return self;
+}
+
+- (id) initWithStream:(id<ANTLRIntStream>)anInputStream
+{
+	self = [super initWithName:NSStringFromClass([self class]) reason:@"Runtime Exception" userInfo:nil];
+	if ( self != nil ) {
+	}
+	return self;
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+	self = [super initWithName:aName reason:aReason userInfo:aUserInfo];
+	if ( self != nil ) {
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRRecognitionException" );
+#endif
+	if ( input ) [input release];
+	if ( token ) [token release];
+	if ( node ) [node release];
+	[super dealloc];
+}
+
+- (NSInteger) unexpectedType
+{
+	if (token) {
+		return token.type;
+    } else if (node) {
+        return [node type];
+	} else {
+		return c;
+	}
+}
+
+- (id<ANTLRToken>)getUnexpectedToken
+{
+    return token;
+}
+
+- (NSString *) description
+{
+	//NSMutableString *desc = [[NSMutableString alloc] initWithString:NSStringFromClass([self class])];
+	NSMutableString *desc = [NSMutableString stringWithString:[self className]];
+	if (token) {
+		[desc appendFormat:@" token:%@", token];
+	} else if (node) {
+		[desc appendFormat:@" node:%@", node];
+	} else {
+		[desc appendFormat:@" char:%c", c];
+	}
+	[desc appendFormat:@" line:%d position:%d", line, charPositionInLine];
+	return desc;
+}
+
+//----------------------------------------------------------
+//  input
+//----------------------------------------------------------
+- (id<ANTLRIntStream>) getStream
+{
+    return input;
+}
+
+- (void) setStream: (id<ANTLRIntStream>) aStream
+{
+    if ( input != aStream ) {
+        if ( input ) [input release];
+        if ( aStream ) [aStream retain];
+        input = aStream;
+    }
+}
+
+//----------------------------------------------------------
+//  token
+//----------------------------------------------------------
+- (id<ANTLRToken>) getToken
+{
+    return token;
+}
+
+- (void) setToken: (id<ANTLRToken>) aToken
+{
+    if (token != aToken) {
+        if ( token ) [token release];
+        if ( aToken ) [aToken retain];
+        token = aToken;
+    }
+}
+
+//----------------------------------------------------------
+//  node
+//----------------------------------------------------------
+- (id<ANTLRBaseTree>) getNode
+{
+    return node;
+}
+
+- (void) setNode: (id<ANTLRBaseTree>) aNode
+{
+    if (node != aNode) {
+        if ( node ) [node release];
+        if ( aNode ) [aNode retain];
+        node = aNode;
+    }
+}
+
+- (NSString *)getMessage
+{
+    return @"Fix getMessage in ANTLRRecognitionException";
+}
+
+- (NSUInteger)charPositionInLine
+{
+    return charPositionInLine;
+}
+
+- (void)setCharPositionInLine:(NSUInteger)aPos
+{
+    charPositionInLine = aPos;
+}
+
+@synthesize index;
+@synthesize c;
+@end
diff --git a/runtime/ObjC/Framework/RecognizerSharedState.h b/runtime/ObjC/Framework/RecognizerSharedState.h
new file mode 100755
index 0000000..0878dba
--- /dev/null
+++ b/runtime/ObjC/Framework/RecognizerSharedState.h
@@ -0,0 +1,117 @@
+// [The "BSD licence"]
+// Copyright (c) 2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRToken.h"
+#import "ANTLRBitSet.h"
+#import "ANTLRRuleStack.h"
+#import "AMutableArray.h"
+
+@interface ANTLRRecognizerSharedState : NSObject {
+	__strong AMutableArray *following;  // a stack of FOLLOW bitsets used for context sensitive prediction and recovery
+    NSInteger _fsp;                     // Follow stack pointer
+	BOOL errorRecovery;                 // are we recovering?
+	NSInteger lastErrorIndex;
+	BOOL failed;                        // indicate that some match failed
+    NSInteger syntaxErrors;
+	NSInteger backtracking;             // the level of backtracking
+	__strong ANTLRRuleStack *ruleMemo;	// store previous results of matching rules so we don't have to do it again. Hook in incremental stuff here, too.
+
+	__strong id<ANTLRToken> token;
+	NSInteger  tokenStartCharIndex;
+	NSUInteger tokenStartLine;
+	NSUInteger tokenStartCharPositionInLine;
+	NSUInteger channel;
+	NSUInteger type;
+	NSString   *text;
+}
+
+@property (retain, getter=getFollowing, setter=setFollowing:) AMutableArray *following;
+@property (assign) NSInteger _fsp;
+@property (assign) BOOL errorRecovery;
+@property (assign) NSInteger lastErrorIndex;
+@property (assign, getter=getFailed, setter=setFailed:) BOOL failed;
+@property (assign) NSInteger syntaxErrors;
+@property (assign, getter=getBacktracking, setter=setBacktracking:) NSInteger backtracking;
+@property (retain, getter=getRuleMemo, setter=setRuleMemo:) ANTLRRuleStack *ruleMemo;
+@property (copy, getter=getToken, setter=setToken:) id<ANTLRToken> token;
+@property (getter=type,setter=setType:) NSUInteger type;
+@property (getter=channel,setter=setChannel:) NSUInteger channel;
+@property (getter=getTokenStartLine,setter=setTokenStartLine:) NSUInteger tokenStartLine;
+@property (getter=charPositionInLine,setter=setCharPositionInLine:) NSUInteger tokenStartCharPositionInLine;
+@property (getter=getTokenStartCharIndex,setter=setTokenStartCharIndex:) NSInteger tokenStartCharIndex;
+@property (retain, getter=text, setter=setText:) NSString *text;
+
++ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState;
++ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedStateWithRuleLen:(NSInteger)aLen;
++ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState:(ANTLRRecognizerSharedState *)aState;
+
+- (id) init;
+- (id) initWithRuleLen:(NSInteger)aLen;
+- (id) initWithState:(ANTLRRecognizerSharedState *)state;
+
+- (id<ANTLRToken>) getToken;
+- (void) setToken:(id<ANTLRToken>) theToken;
+
+- (NSUInteger)type;
+- (void) setType:(NSUInteger) theTokenType;
+
+- (NSUInteger)channel;
+- (void) setChannel:(NSUInteger) theChannel;
+
+- (NSUInteger) getTokenStartLine;
+- (void) setTokenStartLine:(NSUInteger) theTokenStartLine;
+
+- (NSUInteger) charPositionInLine;
+- (void) setCharPositionInLine:(NSUInteger) theCharPosition;
+
+- (NSInteger) getTokenStartCharIndex;
+- (void) setTokenStartCharIndex:(NSInteger) theTokenStartCharIndex;
+
+- (NSString *)text;
+- (void) setText:(NSString *) theText;
+
+
+- (AMutableArray *) getFollowing;
+- (void)setFollowing:(AMutableArray *)aFollow;
+- (ANTLRRuleStack *) getRuleMemo;
+- (void)setRuleMemo:(ANTLRRuleStack *)aRuleMemo;
+- (BOOL) isErrorRecovery;
+- (void) setIsErrorRecovery: (BOOL) flag;
+
+- (BOOL) getFailed;
+- (void) setFailed: (BOOL) flag;
+
+- (NSInteger)  getBacktracking;
+- (void) setBacktracking:(NSInteger) value;
+- (void) increaseBacktracking;
+- (void) decreaseBacktracking;
+- (BOOL) isBacktracking;
+
+- (NSInteger) lastErrorIndex;
+- (void) setLastErrorIndex:(NSInteger) value;
+
+@end
diff --git a/runtime/ObjC/Framework/RecognizerSharedState.m b/runtime/ObjC/Framework/RecognizerSharedState.m
new file mode 100755
index 0000000..79dda2d
--- /dev/null
+++ b/runtime/ObjC/Framework/RecognizerSharedState.m
@@ -0,0 +1,331 @@
+// [The "BSD licence"]
+// Copyright (c) 2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRecognizerSharedState.h"
+#import "ANTLRCharStream.h"
+#import "ANTLRCommonToken.h"
+#import "ANTLRMismatchedTokenException.h"
+#import "ANTLRMismatchedRangeException.h"
+
+@implementation ANTLRRecognizerSharedState
+
+@synthesize following;
+@synthesize _fsp;
+@synthesize errorRecovery;
+@synthesize lastErrorIndex;
+@synthesize failed;
+@synthesize syntaxErrors;
+@synthesize backtracking;
+@synthesize ruleMemo;
+@synthesize token;
+@synthesize type;
+@synthesize channel;
+@synthesize tokenStartLine;
+@synthesize tokenStartCharPositionInLine;
+@synthesize tokenStartCharIndex;
+@synthesize text;
+
++ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState
+{
+    return [[[ANTLRRecognizerSharedState alloc] init] retain];
+}
+
++ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedStateWithRuleLen:(NSInteger)aLen
+{
+    return [[[ANTLRRecognizerSharedState alloc] initWithRuleLen:aLen] retain];
+}
+
++ (ANTLRRecognizerSharedState *) newANTLRRecognizerSharedState:(ANTLRRecognizerSharedState *)aState
+{
+    return [[[ANTLRRecognizerSharedState alloc] initWithState:aState] retain];
+}
+
+- (id) init
+{
+    ANTLRHashRule *aHashRule;
+	if ((self = [super init]) != nil ) {
+        following = [[AMutableArray arrayWithCapacity:10] retain];
+        _fsp = -1;
+        errorRecovery = NO;			// are we recovering?
+        lastErrorIndex = -1;
+        failed = NO;				// indicate that some match failed
+        syntaxErrors = 0;
+        backtracking = 0;			// the level of backtracking
+        tokenStartCharIndex = -1;
+        tokenStartLine = 0;
+        int cnt = 200;
+		ruleMemo = [[ANTLRRuleStack newANTLRRuleStack:cnt] retain];
+        for (int i = 0; i < cnt; i++ ) {
+            aHashRule = [[ANTLRHashRule newANTLRHashRuleWithLen:17] retain];
+            [ruleMemo addObject:aHashRule];
+        }
+#ifdef DONTUSEYET
+        token = state.token;
+        tokenStartCharIndex = state.tokenStartCharIndex;
+        tokenStartCharPositionInLine = state.tokenStartCharPositionInLine;
+        channel = state.channel;
+        type = state.type;
+        text = state.text;
+#endif
+	}
+	return self;
+}
+
+- (id) initWithRuleLen:(NSInteger)aLen
+{
+    ANTLRHashRule *aHashRule;
+	if ((self = [super init]) != nil ) {
+        following = [[AMutableArray arrayWithCapacity:10] retain];
+        _fsp = -1;
+        errorRecovery = NO;			// are we recovering?
+        lastErrorIndex = -1;
+        failed = NO;				// indicate that some match failed
+        syntaxErrors = 0;
+        backtracking = 0;			// the level of backtracking
+        tokenStartCharIndex = -1;
+        tokenStartLine = 0;
+		ruleMemo = [[ANTLRRuleStack newANTLRRuleStack:aLen] retain];
+        for (int i = 0; i < aLen; i++ ) {
+            aHashRule = [[ANTLRHashRule newANTLRHashRuleWithLen:17] retain];
+            [ruleMemo addObject:aHashRule];
+        }
+#ifdef DONTUSEYET
+        token = state.token;
+        tokenStartCharIndex = state.tokenStartCharIndex;
+        tokenStartCharPositionInLine = state.tokenStartCharPositionInLine;
+        channel = state.channel;
+        type = state.type;
+        text = state.text;
+#endif
+	}
+	return self;
+}
+
+- (id) initWithState:(ANTLRRecognizerSharedState *)aState
+{
+    ANTLRHashRule *aHashRule;
+    if ( [following count] < [aState.following count] ) {
+        //        following = new BitSet[state.following.size];
+    }
+    [following setArray:aState.following];
+    _fsp = aState._fsp;
+    errorRecovery = aState.errorRecovery;
+    lastErrorIndex = aState.lastErrorIndex;
+    failed = aState.failed;
+    syntaxErrors = aState.syntaxErrors;
+    backtracking = aState.backtracking;
+    if ( aState.ruleMemo == nil ) {
+        int cnt = 200;
+        ruleMemo = [[ANTLRRuleStack newANTLRRuleStack:cnt] retain];
+        for (int i = 0; i < cnt; i++ ) {
+            aHashRule = [[ANTLRHashRule newANTLRHashRuleWithLen:17] retain];
+            [ruleMemo addObject:aHashRule];
+        }
+    }
+    else {
+        ruleMemo = aState.ruleMemo;
+        if ( [ruleMemo count] == 0 ) {
+            int cnt = [ruleMemo length];
+            for (int i = 0; i < cnt; i++ ) {
+                [ruleMemo addObject:[[ANTLRHashRule newANTLRHashRuleWithLen:17] retain]];
+            }
+        }
+        else {
+            [ruleMemo addObjectsFromArray:aState.ruleMemo];
+        }
+    }
+    token = aState.token;
+    tokenStartCharIndex = aState.tokenStartCharIndex;
+    tokenStartCharPositionInLine = aState.tokenStartCharPositionInLine;
+    tokenStartLine = aState.tokenStartLine;
+    channel = aState.channel;
+    type = aState.type;
+    text = aState.text;
+    return( self );
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRRecognizerSharedState" );
+#endif
+    if ( token ) [token release];
+	if ( following ) [following release];
+	if ( ruleMemo ) [ruleMemo release];
+	[super dealloc];
+}
+
+// token stuff
+#pragma mark Tokens
+
+- (id<ANTLRToken>)getToken
+{
+    return token;
+}
+
+- (void) setToken: (id<ANTLRToken>) aToken
+{
+    if (token != aToken) {
+        [aToken retain];
+        if ( token ) [token release];
+        token = aToken;
+    }
+}
+
+- (NSUInteger)channel
+{
+    return channel;
+}
+
+- (void) setChannel:(NSUInteger) theChannel
+{
+    channel = theChannel;
+}
+
+- (NSUInteger) getTokenStartLine
+{
+    return tokenStartLine;
+}
+
+- (void) setTokenStartLine:(NSUInteger) theTokenStartLine
+{
+    tokenStartLine = theTokenStartLine;
+}
+
+- (NSUInteger) charPositionInLine
+{
+    return tokenStartCharPositionInLine;
+}
+
+- (void) setCharPositionInLine:(NSUInteger) theCharPosition
+{
+    tokenStartCharPositionInLine = theCharPosition;
+}
+
+- (NSInteger) getTokenStartCharIndex;
+{
+    return tokenStartCharIndex;
+}
+
+- (void) setTokenStartCharIndex:(NSInteger) theTokenStartCharIndex
+{
+    tokenStartCharIndex = theTokenStartCharIndex;
+}
+
+// error handling
+- (void) reportError:(ANTLRRecognitionException *)e
+{
+	NSLog(@"%@", e.name);
+}
+
+- (AMutableArray *) getFollowing
+{
+	return following;
+}
+
+- (void)setFollowing:(AMutableArray *)aFollow
+{
+    if ( following != aFollow ) {
+        if ( following ) [following release];
+        [aFollow retain];
+    }
+    following = aFollow;
+}
+
+- (ANTLRRuleStack *) getRuleMemo
+{
+	return ruleMemo;
+}
+
+- (void)setRuleMemo:(ANTLRRuleStack *)aRuleMemo
+{
+    if ( ruleMemo != aRuleMemo ) {
+        if ( ruleMemo ) [ruleMemo release];
+        [aRuleMemo retain];
+    }
+    ruleMemo = aRuleMemo;
+}
+
+- (BOOL) isErrorRecovery
+{
+	return errorRecovery;
+}
+
+- (void) setIsErrorRecovery: (BOOL) flag
+{
+	errorRecovery = flag;
+}
+
+
+- (BOOL) getFailed
+{
+	return failed;
+}
+
+- (void) setFailed:(BOOL)flag
+{
+	failed = flag;
+}
+
+
+- (NSInteger) backtracking
+{
+	return backtracking;
+}
+
+- (void) setBacktracking:(NSInteger) value
+{
+	backtracking = value;
+}
+
+- (void) increaseBacktracking
+{
+	backtracking++;
+}
+
+- (void) decreaseBacktracking
+{
+	backtracking--;
+}
+
+- (BOOL) isBacktracking
+{
+	return backtracking > 0;
+}
+
+
+- (NSInteger) lastErrorIndex
+{
+    return lastErrorIndex;
+}
+
+- (void) setLastErrorIndex:(NSInteger) value
+{
+	lastErrorIndex = value;
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/RewriteRuleElementStream.h b/runtime/ObjC/Framework/RewriteRuleElementStream.h
new file mode 100644
index 0000000..46e0190
--- /dev/null
+++ b/runtime/ObjC/Framework/RewriteRuleElementStream.h
@@ -0,0 +1,82 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTreeAdaptor.h"
+
+// TODO: this should be separated into stream and enumerator classes
+@interface ANTLRRewriteRuleElementStream : NSObject {
+    NSInteger cursor;
+    BOOL dirty;        ///< indicates whether the stream should return copies of its elements, set to true after a call to -reset
+    BOOL isSingleElement;
+    id singleElement;
+    __strong AMutableArray *elements;
+
+    __strong NSString *elementDescription;
+    __strong id<ANTLRTreeAdaptor> treeAdaptor;
+}
+
+@property (assign) NSInteger cursor;
+@property (assign) BOOL dirty;
+@property (assign) BOOL isSingleElement;
+@property (assign) id singleElement;
+@property (assign) AMutableArray *elements;
+@property (assign) NSString *elementDescription;
+@property (retain) id<ANTLRTreeAdaptor> treeAdaptor;
+
++ (ANTLRRewriteRuleElementStream*) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                        description:(NSString *)anElementDescription;
++ (ANTLRRewriteRuleElementStream*) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                        description:(NSString *)anElementDescription
+                                                            element:(id)anElement;
++ (ANTLRRewriteRuleElementStream*) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                        description:(NSString *)anElementDescription
+                                                           elements:(NSArray *)theElements;
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
+
+- (void)reset;
+
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
+- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor;
+
+- (void) addElement:(id)anElement;
+- (NSInteger) size;
+
+- (BOOL) hasNext;
+- (id<ANTLRBaseTree>) nextTree;
+- (id<ANTLRBaseTree>) _next;       // internal: TODO: redesign if necessary. maybe delegate
+
+- (id) copyElement:(id)element;
+- (id) toTree:(id)element;
+
+- (NSString *) getDescription;
+- (void) setDescription:(NSString *)description;
+
+@end
+
diff --git a/runtime/ObjC/Framework/RewriteRuleElementStream.m b/runtime/ObjC/Framework/RewriteRuleElementStream.m
new file mode 100644
index 0000000..138163c
--- /dev/null
+++ b/runtime/ObjC/Framework/RewriteRuleElementStream.m
@@ -0,0 +1,258 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRewriteRuleElementStream.h"
+
+@implementation ANTLRRewriteRuleElementStream
+
+@synthesize cursor;
+@synthesize dirty;
+@synthesize isSingleElement;
+@synthesize singleElement;
+@synthesize elements;
+@synthesize elementDescription;
+@synthesize treeAdaptor;
+
++ (ANTLRRewriteRuleElementStream *) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                         description:(NSString *)anElementDescription
+{
+    return [[ANTLRRewriteRuleElementStream alloc] initWithTreeAdaptor:aTreeAdaptor
+                                                          description:anElementDescription];
+}
+
++ (ANTLRRewriteRuleElementStream *) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                         description:(NSString *)anElementDescription
+                                                             element:(id)anElement
+{
+    return [[ANTLRRewriteRuleElementStream alloc] initWithTreeAdaptor:aTreeAdaptor
+                                                          description:anElementDescription
+                                                              element:anElement];
+}
+
++ (ANTLRRewriteRuleElementStream *) newANTLRRewriteRuleElementStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                         description:(NSString *)anElementDescription
+                                                            elements:(NSArray *)theElements;
+{
+    return [[ANTLRRewriteRuleElementStream alloc] initWithTreeAdaptor:aTreeAdaptor
+                                                          description:anElementDescription
+                                                             elements:theElements];
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription
+{
+    if ((self = [super init]) != nil) {
+        cursor = 0;
+        dirty = NO;
+        [self setDescription:anElementDescription];
+        [self setTreeAdaptor:aTreeAdaptor];
+        dirty = NO;
+        isSingleElement = YES;
+        singleElement = nil;
+        elements = nil;
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement
+{
+    if ((self = [super init]) != nil) {
+        cursor = 0;
+        dirty = NO;
+        [self setDescription:anElementDescription];
+        [self setTreeAdaptor:aTreeAdaptor];
+        dirty = NO;
+        isSingleElement = YES;
+        singleElement = nil;
+        elements = nil;
+        [self addElement:anElement];
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements
+{
+    self = [super init];
+    if (self) {
+        cursor = 0;
+        dirty = NO;
+        [self setDescription:anElementDescription];
+        [self setTreeAdaptor:aTreeAdaptor];
+        dirty = NO;
+        singleElement = nil;
+        isSingleElement = NO;
+        elements = [[AMutableArray arrayWithArray:theElements] retain];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRRewriteRuleElementStream" );
+#endif
+    if ( singleElement && isSingleElement ) [singleElement release];
+    else if ( elements && !isSingleElement ) [elements release];
+    [self setDescription:nil];
+    [self setTreeAdaptor:nil];
+    [super dealloc];
+}
+
+- (void)reset
+{
+    cursor = 0;
+    dirty = YES;
+}
+
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor
+{
+    return treeAdaptor;
+}
+
+- (void) setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+{
+    if (treeAdaptor != aTreeAdaptor) {
+        if ( treeAdaptor ) [treeAdaptor release];
+        treeAdaptor = aTreeAdaptor;
+        [treeAdaptor retain];
+    }
+}
+
+- (void) addElement: (id)anElement
+{
+    if (anElement == nil)
+        return;
+    if (elements != nil) {
+        [elements addObject:anElement];
+        return;
+        }
+    if (singleElement == nil) {
+        singleElement = anElement;
+        singleElement = [anElement retain];
+        return;
+    }
+    isSingleElement = NO;
+    elements = [[AMutableArray arrayWithCapacity:5] retain];
+    [elements addObject:singleElement];
+    singleElement = nil;  // balance previous retain in initializer/addElement
+    [elements addObject:anElement];
+}
+
+- (void) setElement: (id)anElement
+{
+    if (anElement == nil)
+        return;
+    if (elements != nil) {
+        [elements addObject:anElement];
+        return;
+        }
+    if (singleElement == nil) {
+        singleElement = anElement;
+        singleElement = [anElement retain];
+        return;
+    }
+    isSingleElement = NO;
+    elements = [[AMutableArray arrayWithCapacity:5] retain];
+    [elements addObject:singleElement];
+    singleElement = nil;  // balance previous retain in initializer/addElement
+    [elements addObject:anElement];
+}
+
+- (id<ANTLRBaseTree>) nextTree
+{
+    NSInteger n = [self size];
+    if ( dirty && (cursor >= 0 && n == 1)) {
+        // if out of elements and size is 1, dup
+        id element = [self _next];
+        return [self copyElement:element];
+    }
+    // test size above then fetch
+    id element = [self _next];
+    return element;
+}
+
+- (id) _next       // internal: TODO: redesign if necessary. maybe delegate
+{
+    NSInteger n = [self size];
+    if (n == 0) {
+        @throw [NSException exceptionWithName:@"RewriteEmptyStreamException" reason:nil userInfo:nil];// TODO: fill in real exception
+    }
+    if ( cursor >= n ) {
+        if ( n == 1 ) {
+            return [self toTree:singleElement]; // will be dup'ed in -next
+        }
+        @throw [NSException exceptionWithName:@"RewriteCardinalityException" reason:nil userInfo:nil];// TODO: fill in real exception
+    }
+    if (singleElement != nil) {
+        cursor++;
+        return [self toTree:singleElement];
+    }
+    id el = [elements objectAtIndex:cursor];
+    cursor++;
+    return [self toTree:el];
+}
+
+- (BOOL) hasNext
+{
+    return (singleElement != nil && cursor < 1) ||
+            (elements != nil && cursor < [elements count]);
+}
+
+- (NSInteger) size
+{
+    NSInteger n = 0;
+    if (singleElement != nil)
+        n = 1;
+    if (elements != nil)
+        return [elements count];
+    return n;
+}
+
+- (id) copyElement:(id)element
+{
+    [self doesNotRecognizeSelector:_cmd];   // subclass responsibility
+    return nil;
+}
+
+- (id<ANTLRBaseTree>) toTree:(id)element
+{
+    return element;
+}
+
+- (NSString *) getDescription
+{
+    return elementDescription;
+}
+
+- (void) setDescription:(NSString *) description
+{
+    if ( description != nil && description != elementDescription ) {
+        if (elementDescription != nil) [elementDescription release];
+        elementDescription = [NSString stringWithString:description];
+        [elementDescription retain];
+    }
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RewriteRuleNodeStream.h b/runtime/ObjC/Framework/RewriteRuleNodeStream.h
new file mode 100755
index 0000000..2789e45
--- /dev/null
+++ b/runtime/ObjC/Framework/RewriteRuleNodeStream.h
@@ -0,0 +1,46 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRewriteRuleElementStream.h"
+
+@interface ANTLRRewriteRuleNodeStream : ANTLRRewriteRuleElementStream {
+
+}
+
++ (ANTLRRewriteRuleNodeStream *) newANTLRRewriteRuleNodeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
++ (ANTLRRewriteRuleNodeStream *) newANTLRRewriteRuleNodeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
++ (ANTLRRewriteRuleNodeStream *) newANTLRRewriteRuleNode:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
+
+- (id) nextNode;
+- (id) toTree:(id<ANTLRBaseTree>)element;
+- (id) dup:(id)element;
+
+@end
diff --git a/runtime/ObjC/Framework/RewriteRuleNodeStream.m b/runtime/ObjC/Framework/RewriteRuleNodeStream.m
new file mode 100755
index 0000000..8dfedd7
--- /dev/null
+++ b/runtime/ObjC/Framework/RewriteRuleNodeStream.m
@@ -0,0 +1,74 @@
+//
+//  ANTLRRewriteRuleNodeStream.m
+//  ANTLR
+//
+//  Created by Kay Röpke on 7/16/07.
+//  Copyright 2007 classDump. All rights reserved.
+//
+
+#import "ANTLRRewriteRuleNodeStream.h"
+#import "ANTLRRuntimeException.h"
+
+@implementation ANTLRRewriteRuleNodeStream
+
++ (ANTLRRewriteRuleNodeStream*) newANTLRRewriteRuleNodeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
+{
+    return [[ANTLRRewriteRuleNodeStream alloc] initWithTreeAdaptor:aTreeAdaptor description:anElementDescription];
+}
+
++ (ANTLRRewriteRuleNodeStream*) newANTLRRewriteRuleNodeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
+{
+    return [[ANTLRRewriteRuleNodeStream alloc] initWithTreeAdaptor:aTreeAdaptor description:anElementDescription element:anElement];
+}
+
++ (ANTLRRewriteRuleNodeStream*) newANTLRRewriteRuleNode:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
+{
+    return [[ANTLRRewriteRuleNodeStream alloc] initWithTreeAdaptor:aTreeAdaptor description:anElementDescription elements:theElements];
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription
+{
+    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription]) != nil) {
+        dirty = NO;
+        isSingleElement = YES;
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement
+{
+    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription element:anElement]) != nil) {
+        dirty = NO;
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements
+{
+    if ((self = [super init]) != nil) {
+        dirty = NO;
+    }
+    return self;
+}
+
+
+- (id) nextNode
+{
+    if (dirty || (cursor >= [self size] && [self size] == 1))
+        return [treeAdaptor dupNode:[self _next]];
+    else
+        return [self _next];
+}
+
+- (id<ANTLRBaseTree>) toTree:(id<ANTLRBaseTree>)element
+{
+    return [treeAdaptor dupNode:element];
+}
+
+- (id) dup:(id)element
+{
+    return [treeAdaptor dupTree:element];
+    @throw [ANTLRRuntimeException newException:@"ANTLRUnsupportedOperationException" reason:@"dup can't be called for a node stream."];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RewriteRuleSubtreeStream.h b/runtime/ObjC/Framework/RewriteRuleSubtreeStream.h
new file mode 100644
index 0000000..1d18b24
--- /dev/null
+++ b/runtime/ObjC/Framework/RewriteRuleSubtreeStream.h
@@ -0,0 +1,50 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRewriteRuleElementStream.h"
+
+@interface ANTLRRewriteRuleSubtreeStream : ANTLRRewriteRuleElementStream {
+
+}
+
++ (ANTLRRewriteRuleSubtreeStream *) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                         description:(NSString *)anElementDescription;
++ (ANTLRRewriteRuleSubtreeStream *) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                         description:(NSString *)anElementDescription
+                                                             element:(id)anElement;
++ (ANTLRRewriteRuleSubtreeStream *) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                         description:(NSString *)anElementDescription
+                                                            elements:(NSArray *)theElements;
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements;
+
+- (id) nextNode;
+- (id) dup:(id)element;
+
+@end
diff --git a/runtime/ObjC/Framework/RewriteRuleSubtreeStream.m b/runtime/ObjC/Framework/RewriteRuleSubtreeStream.m
new file mode 100644
index 0000000..48910bd
--- /dev/null
+++ b/runtime/ObjC/Framework/RewriteRuleSubtreeStream.m
@@ -0,0 +1,101 @@
+//
+//  ANTLRRewriteRuleSubtreeStream.m
+//  ANTLR
+//
+//  Created by Kay Röpke on 7/16/07.
+// [The "BSD licence"]
+// Copyright (c) 2007 Kay Röpke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRewriteRuleSubtreeStream.h"
+
+
+@implementation ANTLRRewriteRuleSubtreeStream
+
++ (ANTLRRewriteRuleSubtreeStream*) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                        description:(NSString *)anElementDescription;
+{
+    return [[ANTLRRewriteRuleSubtreeStream alloc] initWithTreeAdaptor:aTreeAdaptor
+                                                          description:anElementDescription];
+}
+
++ (ANTLRRewriteRuleSubtreeStream*) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                        description:(NSString *)anElementDescription
+                                                            element:(id)anElement;
+{
+    return [[ANTLRRewriteRuleSubtreeStream alloc] initWithTreeAdaptor:aTreeAdaptor
+                                                          description:anElementDescription
+                                                              element:anElement];
+}
+
++ (ANTLRRewriteRuleSubtreeStream*) newANTLRRewriteRuleSubtreeStream:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+                                                        description:(NSString *)anElementDescription
+                                                           elements:(NSArray *)theElements;
+{
+    return [[ANTLRRewriteRuleSubtreeStream alloc] initWithTreeAdaptor:aTreeAdaptor
+                                                          description:anElementDescription
+                                                             elements:theElements];
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription
+{
+    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription]) != nil) {
+        dirty = NO;
+        isSingleElement = YES;
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription element:(id)anElement
+{
+    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription element:anElement]) != nil) {
+        dirty = NO;
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor description:(NSString *)anElementDescription elements:(NSArray *)theElements
+{
+    if ((self = [super initWithTreeAdaptor:aTreeAdaptor description:anElementDescription elements:theElements]) != nil) {
+        dirty = NO;
+    }
+    return self;
+}
+
+
+- (id) nextNode
+{
+    if (dirty || (cursor >= [self size] && [self size] == 1))
+        return [treeAdaptor dupNode:[self _next]];
+    else
+        return [self _next];
+}
+
+- (id) dup:(id)element
+{
+    return [treeAdaptor dupTree:element];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RewriteRuleTokenStream.h b/runtime/ObjC/Framework/RewriteRuleTokenStream.h
new file mode 100644
index 0000000..620a0bd
--- /dev/null
+++ b/runtime/ObjC/Framework/RewriteRuleTokenStream.h
@@ -0,0 +1,66 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRewriteRuleElementStream.h"
+
+
+@interface ANTLRRewriteRuleTokenStream : ANTLRRewriteRuleElementStream {
+
+}
+
++ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)anAdaptor
+                          description:(NSString *)elementDescription;
+/** Create a stream with one element */
++ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
+                          description:(NSString *)elementDescription
+                              element:(id) oneElement;
+/** Create a stream, but feed off an existing list */
++ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
+                          description:(NSString *)elementDescription
+                             elements:(AMutableArray *)elements;
+
+- (id) init;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+               description:(NSString *)aDescription;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+               description:(NSString *)aDescription
+                   element:(id)element;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+               description:(NSString *)aDescription
+                  elements:(AMutableArray *)elements;
+
+/** Get next token from stream and make a node for it */
+- (id) nextNode;
+
+- (id) nextToken;
+
+/** Don't convert to a tree unless they explicitly call nextTree.
+ *  This way we can do hetero tree nodes in rewrite.
+ */
+- (id<ANTLRBaseTree>) toTree:(id<ANTLRToken>)element;
+
+@end
diff --git a/runtime/ObjC/Framework/RewriteRuleTokenStream.m b/runtime/ObjC/Framework/RewriteRuleTokenStream.m
new file mode 100644
index 0000000..5aea3f8
--- /dev/null
+++ b/runtime/ObjC/Framework/RewriteRuleTokenStream.m
@@ -0,0 +1,128 @@
+//
+//  ANTLRRewriteRuleTokenStream.m
+//  ANTLR
+//
+//  Created by Kay Röpke on 7/16/07.
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRewriteRuleTokenStream.h"
+#import "ANTLRRuntimeException.h"
+#import "ANTLRHashMap.h"
+#import "ANTLRMapElement.h"
+
+@implementation ANTLRRewriteRuleTokenStream
+
++ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)anAdaptor
+                          description:(NSString *)elementDescription
+{
+    return [[ANTLRRewriteRuleTokenStream alloc] initWithTreeAdaptor:anAdaptor
+                                                        description:elementDescription];
+}
+
+/** Create a stream with one element */
++ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
+                          description:(NSString *)elementDescription
+                              element:(id) oneElement
+{
+    return [[ANTLRRewriteRuleTokenStream alloc] initWithTreeAdaptor:adaptor
+                                                        description:elementDescription
+                                                            element:oneElement];
+}
+
+/** Create a stream, but feed off an existing list */
++ (id) newANTLRRewriteRuleTokenStream:(id<ANTLRTreeAdaptor>)adaptor
+                          description:(NSString *)elementDescription
+                             elements:(AMutableArray *)elements
+{
+    return [[ANTLRRewriteRuleTokenStream alloc] initWithTreeAdaptor:adaptor
+                                                        description:elementDescription
+                                                           elements:elements];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil ) {
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+               description:(NSString *)aDescription
+{
+    if ((self = [super initWithTreeAdaptor:anAdaptor
+                               description:aDescription]) != nil ) {
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+               description:(NSString *)aDescription
+                   element:(id)anElement
+{
+    if ((self = [super initWithTreeAdaptor:anAdaptor
+                               description:aDescription
+                                   element:anElement]) != nil ) {
+    }
+    return self;
+}
+
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+               description:(NSString *)aDescription
+                  elements:(AMutableArray *)elementList
+{
+    if ((self = [super initWithTreeAdaptor:anAdaptor
+                               description:aDescription
+                                  elements:elementList]) != nil ) {
+    }
+    return self;
+}
+
+- (id<ANTLRBaseTree>) nextNode
+{
+    id<ANTLRToken> t = [self _next];
+    return [treeAdaptor create:t];
+}
+
+- (id) nextToken
+{
+    return [self _next];
+}
+
+/** Don't convert to a tree unless they explicitly call nextTree.
+ *  This way we can do hetero tree nodes in rewrite.
+ */
+- (id<ANTLRBaseTree>) toTree:(id<ANTLRToken>)element
+{
+    return element;
+}
+
+- (id) copyElement:(id)element
+{
+    @throw [ANTLRRuntimeException newException:@"copy can't be called for a token stream."];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RuleMapElement.h b/runtime/ObjC/Framework/RuleMapElement.h
new file mode 100644
index 0000000..e040b18
--- /dev/null
+++ b/runtime/ObjC/Framework/RuleMapElement.h
@@ -0,0 +1,55 @@
+//
+//  ANTLRRuleMapElement.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseMapElement.h"
+
+@interface ANTLRRuleMapElement : ANTLRBaseMapElement {
+    NSNumber *ruleNum;
+}
+
+@property (retain, getter=getRuleNum, setter=setRuleNum:) NSNumber *ruleNum;
+
++ (ANTLRRuleMapElement *) newANTLRRuleMapElement;
++ (ANTLRRuleMapElement *) newANTLRRuleMapElementWithIndex:(NSNumber *)anIdx;
++ (ANTLRRuleMapElement *) newANTLRRuleMapElementWithIndex:(NSNumber *)anIdx RuleNum:(NSNumber *)aRuleNum;
+- (id) init;
+- (id) initWithAnIndex:(NSNumber *)anIdx;
+- (id) initWithAnIndex:(NSNumber *)anIdx RuleNum:(NSNumber *)aRuleNum;
+
+- (id) copyWithZone:(NSZone *)aZone;
+
+- (NSNumber *)getRuleNum;
+- (void)setRuleNum:(NSNumber *)aRuleNum;
+
+- (NSInteger)size;
+
+@end
diff --git a/runtime/ObjC/Framework/RuleMapElement.m b/runtime/ObjC/Framework/RuleMapElement.m
new file mode 100644
index 0000000..0e8c463
--- /dev/null
+++ b/runtime/ObjC/Framework/RuleMapElement.m
@@ -0,0 +1,111 @@
+//
+//  ANTLRRuleMapElement.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRuleMapElement.h"
+
+
+@implementation ANTLRRuleMapElement
+
+@synthesize ruleNum;
+
++ (ANTLRRuleMapElement *)newANTLRRuleMapElement
+{
+    return [[ANTLRRuleMapElement alloc] init];
+}
+
++ (ANTLRRuleMapElement *)newANTLRRuleMapElementWithIndex:(NSNumber *)aNumber
+{
+    return [[ANTLRRuleMapElement alloc] initWithAnIndex:(NSNumber *)aNumber];
+}
+
++ (ANTLRRuleMapElement *)newANTLRRuleMapElementWithIndex:(NSNumber *)aNumber RuleNum:(NSNumber *)aRuleNum
+{
+    return [[ANTLRRuleMapElement alloc] initWithAnIndex:aNumber RuleNum:aRuleNum];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil ) {
+        index = nil;
+        ruleNum = nil;
+    }
+    return (self);
+}
+
+- (id) initWithAnIndex:(NSNumber *)aNumber
+{
+    if ((self = [super initWithAnIndex:aNumber]) != nil ) {
+        ruleNum = nil;
+    }
+    return (self);
+}
+
+- (id) initWithAnIndex:(NSNumber *)aNumber RuleNum:(NSNumber *)aRuleNum
+{
+    if ((self = [super initWithAnIndex:aNumber]) != nil ) {
+        [aRuleNum retain];
+        ruleNum = aRuleNum;
+    }
+    return (self);
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRRuleMapElement *copy;
+
+    copy = [super copyWithZone:aZone];
+    copy.ruleNum = ruleNum;
+    return( copy );
+}
+
+- (id)getRuleNum
+{
+    return ruleNum;
+}
+
+- (void)setRuleNum:(id)aRuleNum
+{
+    if ( aRuleNum != ruleNum ) {
+        if ( ruleNum ) [ruleNum release];
+        [aRuleNum retain];
+    }
+    ruleNum = aRuleNum;
+}
+
+- (NSInteger)size
+{
+    NSInteger aSize = 0;
+    if (ruleNum != nil) aSize++;
+    if (index != nil) aSize++;
+    return( aSize );
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RuleMemo.h b/runtime/ObjC/Framework/RuleMemo.h
new file mode 100644
index 0000000..ed95af6
--- /dev/null
+++ b/runtime/ObjC/Framework/RuleMemo.h
@@ -0,0 +1,60 @@
+//
+//  ANTLRRuleMemo.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRLinkBase.h"
+
+@interface ANTLRRuleMemo : ANTLRLinkBase {
+    NSNumber *startIndex;
+    NSNumber *stopIndex;
+}
+
+@property (retain, getter=getStartIndex, setter=setStartIndex:) NSNumber *startIndex;
+@property (retain, getter=getStopIndex, setter=setStopIndex:) NSNumber *stopIndex;
+
++ (ANTLRRuleMemo *)newANTLRRuleMemo;
++ (ANTLRRuleMemo *)newANTLRRuleMemoWithStartIndex:(NSNumber *)aStartIndex StopIndex:(NSNumber *)aStopIndex;
+
+- (id) init;
+- (id) initWithStartIndex:(NSNumber *)aStartIndex StopIndex:(NSNumber *)aStopIndex;
+
+- (NSInteger)count;
+- (NSInteger)size;
+
+- (ANTLRRuleMemo *)getRuleWithStartIndex:(NSInteger)aStartIndex;
+- (NSNumber *)getStartIndex:(NSInteger)aStartIndex;
+- (NSNumber *)getStopIndex:(NSInteger)aStartIndex;
+- (NSNumber *)getStartIndex;
+- (void)setStartIndex:(NSNumber *)aStartIndex;
+- (NSNumber *)getStopIndex;
+- (void)setStopIndex:(NSNumber *)aStopIndex;
+
+@end
diff --git a/runtime/ObjC/Framework/RuleMemo.m b/runtime/ObjC/Framework/RuleMemo.m
new file mode 100644
index 0000000..836d355
--- /dev/null
+++ b/runtime/ObjC/Framework/RuleMemo.m
@@ -0,0 +1,158 @@
+//
+//  ANTLRRuleMemo.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/16/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRuleMemo.h"
+
+
+@implementation ANTLRRuleMemo
+
+@synthesize startIndex;
+@synthesize stopIndex;
+
++ (ANTLRRuleMemo *)newANTLRRuleMemo
+{
+    return [[ANTLRRuleMemo alloc] init];
+}
+
++ (ANTLRRuleMemo *)newANTLRRuleMemoWithStartIndex:(NSNumber *)anIndex StopIndex:(NSNumber *)aStopIndex
+{
+    return [[ANTLRRuleMemo alloc] initWithStartIndex:anIndex StopIndex:aStopIndex];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil ) {
+        startIndex = nil;
+        stopIndex = nil;
+    }
+    return (self);
+}
+
+- (id) initWithStartIndex:(NSNumber *)aStartIndex StopIndex:(NSNumber *)aStopIndex
+{
+    if ((self = [super init]) != nil ) {
+        [aStartIndex retain];
+        startIndex = aStartIndex;
+        [aStopIndex retain];
+        stopIndex = aStopIndex;
+    }
+    return (self);
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    ANTLRRuleMemo *copy;
+
+    copy = [super copyWithZone:aZone];
+    copy.startIndex = startIndex;
+    copy.stopIndex = stopIndex;
+    return( copy );
+}
+
+- (NSInteger)count
+{
+    NSInteger aCnt = 0;
+
+    if (startIndex != nil) aCnt++;
+    if (stopIndex != nil) aCnt++;
+    return aCnt;
+}
+
+- (NSInteger) size
+{
+    return (2 * sizeof(id));
+}
+
+- (ANTLRRuleMemo *)getRuleWithStartIndex:(NSInteger)aStartIndex
+{
+    ANTLRRuleMemo *aMatchMemo = self;
+    do {
+        if (aStartIndex == [aMatchMemo.startIndex integerValue] ) {
+            return aMatchMemo;
+        }
+        aMatchMemo = aMatchMemo.fNext;
+    } while ( aMatchMemo != nil );
+    return nil;
+}
+
+- (NSNumber *)getStartIndex:(NSInteger)aStartIndex
+{
+    ANTLRRuleMemo *aMatchMemo = self;
+    do {
+        if (aStartIndex == [aMatchMemo.startIndex integerValue] ) {
+            return aMatchMemo.stopIndex;
+        }
+        aMatchMemo = aMatchMemo.fNext;
+    } while ( aMatchMemo != nil );
+    return nil;
+}
+
+- (NSNumber *)getStopIndex:(NSInteger)aStartIndex
+{
+    ANTLRRuleMemo *aMatchMemo = self;
+    do {
+        if (aStartIndex == [aMatchMemo.startIndex integerValue] ) {
+            return aMatchMemo.stopIndex;
+        }
+        aMatchMemo = aMatchMemo.fNext;
+    } while ( aMatchMemo != nil );
+    return nil;
+}
+
+- (NSNumber *)getStartIndex;
+{
+    return startIndex;
+}
+
+- (void)setStartIndex:(NSNumber *)aStartIndex
+{
+    if ( aStartIndex != startIndex ) {
+        if ( startIndex ) [startIndex release];
+        [aStartIndex retain];
+    }
+    startIndex = aStartIndex;
+}
+
+- (NSNumber *)getStopIndex;
+{
+    return stopIndex;
+}
+
+- (void)setStopIndex:(NSNumber *)aStopIndex
+{
+    if ( aStopIndex != stopIndex ) {
+        if ( stopIndex ) [stopIndex release];
+        [aStopIndex retain];
+    }
+    stopIndex = aStopIndex;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RuleReturnScope.h b/runtime/ObjC/Framework/RuleReturnScope.h
new file mode 100644
index 0000000..b9313ed
--- /dev/null
+++ b/runtime/ObjC/Framework/RuleReturnScope.h
@@ -0,0 +1,55 @@
+//
+//  ANTLRRuleReturnScope.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/17/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRToken.h"
+
+@interface ANTLRRuleReturnScope : NSObject <NSCopying> {
+
+}
+
+/** Return the start token or tree */
+- (id<ANTLRToken>) getStart;
+
+/** Return the stop token or tree */
+- (id<ANTLRToken>) getStop;
+
+/** Has a value potentially if output=AST; */
+- (id) getTree;
+
+/** Has a value potentially if output=template; Don't use StringTemplate
+ *  type as it then causes a dependency with ST lib.
+ */
+- (id) getTemplate;
+
+- (id) copyWithZone:(NSZone *)theZone;
+
+@end
diff --git a/runtime/ObjC/Framework/RuleReturnScope.m b/runtime/ObjC/Framework/RuleReturnScope.m
new file mode 100644
index 0000000..70878a3
--- /dev/null
+++ b/runtime/ObjC/Framework/RuleReturnScope.m
@@ -0,0 +1,71 @@
+//
+//  ANTLRRuleReturnScope.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/17/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRuleReturnScope.h"
+
+
+@implementation ANTLRRuleReturnScope
+
+/** Return the start token or tree */
+- (id) getStart
+{
+    return nil;
+}
+
+/** Return the stop token or tree */
+- (id) getStop
+{
+    return nil;
+}
+
+/** Has a value potentially if output=AST; */
+- (id) getTree
+{
+    return nil;
+}
+
+/** Has a value potentially if output=template; Don't use StringTemplate
+ *  type as it then causes a dependency with ST lib.
+ */
+- (id) getTemplate
+{
+    return nil;
+}
+
+// create a copy, including the text if available
+// the input stream is *not* copied!
+- (id) copyWithZone:(NSZone *)theZone
+{
+    ANTLRRuleReturnScope *copy = [[[self class] allocWithZone:theZone] init];
+    return copy;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RuleStack.h b/runtime/ObjC/Framework/RuleStack.h
new file mode 100644
index 0000000..12d450b
--- /dev/null
+++ b/runtime/ObjC/Framework/RuleStack.h
@@ -0,0 +1,63 @@
+//
+//  ANTLRRuleStack.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseStack.h"
+#import "ANTLRHashRule.h"
+
+//#define GLOBAL_SCOPE       0
+//#define LOCAL_SCOPE        1
+#define HASHSIZE         101
+#define HBUFSIZE      0x2000
+
+@interface ANTLRRuleStack : ANTLRBaseStack {
+}
+
+// Contruction/Destruction
++(ANTLRRuleStack *)newANTLRRuleStack;
++(ANTLRRuleStack *)newANTLRRuleStack:(NSInteger)cnt;
+-(id)init;
+-(id)initWithLen:(NSInteger)cnt;
+-(void)dealloc;
+
+// Instance Methods
+- (id) copyWithZone:(NSZone *)aZone;
+/* clear -- reinitialize the maplist array */
+
+- (NSInteger)count;
+- (NSInteger)size;
+
+- (ANTLRHashRule *) pop;
+
+- (void) insertObject:(ANTLRHashRule *)aHashRule atIndex:(NSInteger)idx;
+- (ANTLRHashRule *)objectAtIndex:(NSInteger)idx;
+- (void)putHashRuleAtRuleIndex:(NSInteger)aRuleIndex StartIndex:(NSInteger)aStartIndex StopIndex:(NSInteger)aStopIndex;
+@end
diff --git a/runtime/ObjC/Framework/RuleStack.m b/runtime/ObjC/Framework/RuleStack.m
new file mode 100644
index 0000000..39e93b2
--- /dev/null
+++ b/runtime/ObjC/Framework/RuleStack.m
@@ -0,0 +1,152 @@
+//
+//  ANTLRRuleStack.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#define SUCCESS (0)
+#define FAILURE (-1)
+
+extern NSInteger debug;
+
+#import "ANTLRRuleStack.h"
+#import "ANTLRTree.h"
+
+/*
+ * Start of ANTLRRuleStack
+ */
+@implementation ANTLRRuleStack
+
++ (ANTLRRuleStack *)newANTLRRuleStack
+{
+    return [[ANTLRRuleStack alloc] init];
+}
+
++ (ANTLRRuleStack *)newANTLRRuleStack:(NSInteger)cnt
+{
+    return [[ANTLRRuleStack alloc] initWithLen:cnt];
+}
+
+- (id)init
+{
+	if ((self = [super init]) != nil) {
+	}
+    return( self );
+}
+
+- (id)initWithLen:(NSInteger)cnt
+{
+	if ((self = [super initWithLen:cnt]) != nil) {
+	}
+    return( self );
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRRuleStack" );
+#endif
+	[super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    return [super copyWithZone:aZone];
+}
+
+- (NSInteger)count
+{
+    ANTLRRuleMemo *anElement;
+    NSInteger aCnt = 0;
+    for( int i = 0; i < BuffSize; i++ ) {
+        if ((anElement = ptrBuffer[i]) != nil)
+            aCnt++;
+    }
+    return aCnt;
+}
+
+- (NSInteger)size
+{
+    ANTLRRuleMemo *anElement;
+    NSInteger aSize = 0;
+    for( int i = 0; i < BuffSize; i++ ) {
+        if ((anElement = ptrBuffer[i]) != nil) {
+            aSize++;
+        }
+    }
+    return aSize;
+}
+
+- (ANTLRHashRule *)pop
+{
+    return (ANTLRHashRule *)[super pop];
+}
+
+- (void) insertObject:(ANTLRHashRule *)aRule atIndex:(NSInteger)idx
+{
+    if ( idx >= BuffSize ) {
+        if ( debug > 2 ) NSLog( @"In ANTLRRuleStack attempting to insert aRule at Index %d, but Buffer is only %d long\n", idx, BuffSize );
+        [self ensureCapacity:idx];
+    }
+    if ( aRule != ptrBuffer[idx] ) {
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
+        [aRule retain];
+    }
+    ptrBuffer[idx] = aRule;
+}
+
+- (ANTLRHashRule *)objectAtIndex:(NSInteger)idx
+{
+    if (idx < BuffSize) {
+        return ptrBuffer[idx];
+    }
+    return nil;
+}
+
+- (void)putHashRuleAtRuleIndex:(NSInteger)aRuleIndex StartIndex:(NSInteger)aStartIndex StopIndex:(NSInteger)aStopIndex
+{
+    ANTLRHashRule *aHashRule;
+    ANTLRRuleMemo *aRuleMemo;
+
+    if (aRuleIndex >= BuffSize) {
+        if ( debug) NSLog( @"putHashRuleAtRuleIndex attempting to insert aRule at Index %d, but Buffer is only %d long\n", aRuleIndex, BuffSize );
+        [self ensureCapacity:aRuleIndex];
+    }
+    if ((aHashRule = ptrBuffer[aRuleIndex]) == nil) {
+        aHashRule = [[ANTLRHashRule newANTLRHashRuleWithLen:17] retain];
+        ptrBuffer[aRuleIndex] = aHashRule;
+    }
+    if (( aRuleMemo = [aHashRule objectAtIndex:aStartIndex] ) == nil ) {
+        aRuleMemo = [[ANTLRRuleMemo newANTLRRuleMemo] retain];
+        [aHashRule insertObject:aRuleMemo atIndex:aStartIndex];
+    }
+    [aRuleMemo setStartIndex:[NSNumber numberWithInteger:aStartIndex]];
+    [aRuleMemo setStopIndex:[NSNumber numberWithInteger:aStopIndex]];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/RuntimeException.h b/runtime/ObjC/Framework/RuntimeException.h
new file mode 100644
index 0000000..47834d2
--- /dev/null
+++ b/runtime/ObjC/Framework/RuntimeException.h
@@ -0,0 +1,111 @@
+//
+//  ANTLRRuntimeException.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/5/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+
+@interface ANTLRRuntimeException : NSException {
+}
+
++ (ANTLRRuntimeException *) newException;
++ (ANTLRRuntimeException *) newException:(NSString *)aReason;
++ (ANTLRRuntimeException *) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
++ (ANTLRRuntimeException *) newException:(NSString *)aName reason:(NSString *)aReason;
++ (ANTLRRuntimeException *) newException:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (id) init;
+- (id) init:(NSString *)aReason;
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason;
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (NSString *) Description;
+- (id) stackTrace:(NSException *)e;
+
+@end
+
+@interface ANTLRIllegalArgumentException : ANTLRRuntimeException {
+}
+
++ (id) newException;
++ (id) newException:(NSString *)aReason;
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (id) init;
+- (id)init:(NSString *)aReason;
+- (id)init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+@end
+
+@interface ANTLRIllegalStateException : ANTLRRuntimeException {
+}
+
++ (id) newException;
++ (id) newException:(NSString *)aReason;
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (id) init;
+- (id)init:(NSString *)aReason;
+- (id)init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+@end
+
+@interface ANTLRNoSuchElementException : ANTLRRuntimeException {
+}
+
++ (id) newException;
++ (id) newException:(NSString *)aReason;
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+- (id) init;
+- (id) init:(NSString *)aReason;
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+@end
+
+@interface ANTLRRewriteEarlyExitException : ANTLRRuntimeException {
+}
+
++ (id) newException;
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+
+@end
+
+@interface ANTLRUnsupportedOperationException : ANTLRRuntimeException {
+}
+
++ (id) newException:(NSString *)aReason;
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason;
+- (id) initWithName:(NSString *)aMsg reason:(NSString *)aCause userInfo:(NSDictionary *)userInfo;
+
+@end
+
diff --git a/runtime/ObjC/Framework/RuntimeException.m b/runtime/ObjC/Framework/RuntimeException.m
new file mode 100644
index 0000000..827fc43
--- /dev/null
+++ b/runtime/ObjC/Framework/RuntimeException.m
@@ -0,0 +1,279 @@
+//
+//  ANTLRRuntimeException.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/5/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRRuntimeException.h"
+
+
+@implementation ANTLRRuntimeException
+
++ (id) newException
+{
+    return [[ANTLRRuntimeException alloc] init];
+}
+
++ (id) newException:(NSString *)aReason
+{
+    return [[ANTLRRuntimeException alloc] init:aReason];
+}
+
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    return [[ANTLRRuntimeException alloc] init:aReason userInfo:aUserInfo];
+}
+
++ (id) newException:(NSString *)aName reason:(NSString *)aReason;
+{
+    return [[ANTLRRuntimeException alloc] initWithName:aName reason:aReason];
+}
+
++ (id) newException:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo;
+{
+    return [[ANTLRRuntimeException alloc] initWithName:aName reason:aReason userInfo:aUserInfo];
+}
+
+
+- (id) init
+{
+    self = [super initWithName:@"ANTLRRuntimeException" reason:@"UnknownException" userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason
+{
+    self = [super initWithName:(NSString *)@"ANTLRRuntimeException" reason:(NSString *)aReason userInfo:(NSDictionary *)nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:@"ANTLRRuntimeException" reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason
+{
+    self = [super initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)nil];
+    return(self);
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo];
+    return(self);
+}
+
+- (NSString *) Description
+{
+    return [super reason];
+}
+
+- (id) stackTrace:(NSException *)e
+{
+    NSArray *addrs = [e callStackReturnAddresses];
+    NSArray *trace = [e callStackSymbols];
+
+    for (NSString *traceStr in trace) {
+        NSLog( @"%@", traceStr);
+        // TODO: remove special after testing
+        if ([traceStr hasPrefix:@"main("] > 0)
+            return traceStr;
+        if (![traceStr hasPrefix:@"org.stringtemplate"])
+            return traceStr;
+    }
+    return trace;
+}
+
+@end
+
+@implementation ANTLRIllegalArgumentException
+
++ (id) newException
+{
+    return [[ANTLRIllegalArgumentException alloc] init];
+}
+
++ (id) newException:(NSString *)aReason
+{
+    return [[ANTLRIllegalArgumentException alloc] init:aReason];
+}
+
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    return [[ANTLRIllegalArgumentException alloc] init:aReason userInfo:aUserInfo];
+}
+
+- (id) init
+{
+    self = [super initWithName:@"ANTLRIllegalArgumentException" reason:@"UnknownException" userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason
+{
+    self = [super initWithName:@"ANTLRIllegalArgumentException" reason:(NSString *)aReason userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:@"ANTLRIllegalArgumentException" reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+@end
+
+@implementation ANTLRIllegalStateException
+
++ (id) newException
+{
+    return [[ANTLRIllegalStateException alloc] init];
+}
+
++ (id) newException:(NSString *)aReason
+{
+    return [[ANTLRIllegalStateException alloc] init:aReason];
+}
+
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    return [[ANTLRIllegalStateException alloc] init:aReason userInfo:aUserInfo];
+}
+
+- (id) init
+{
+    self = [super initWithName:@"ANTLRIllegalStateException" reason:@"UnknownException" userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason
+{
+    self = [super initWithName:@"ANTLRIllegalStateException" reason:(NSString *)aReason userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:@"ANTLRIllegalStateException" reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+@end
+
+@implementation ANTLRNoSuchElementException
+
++ (id) newException
+{
+    return [[ANTLRNoSuchElementException alloc] init];
+}
+
++ (id) newException:(NSString *)aReason
+{
+    return [[ANTLRNoSuchElementException alloc] init:aReason];
+}
+
++ (id) newException:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    return [[ANTLRNoSuchElementException alloc] init:aReason userInfo:(NSDictionary *)aUserInfo];
+}
+
+- (id) init
+{
+    self = [super initWithName:@"ANTLRNoSuchElementException" reason:@"UnknownException" userInfo:nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason
+{
+    self = [super initWithName:@"ANTLRNoSuchElementException" reason:(NSString *)aReason userInfo:(NSDictionary *)nil];
+    return(self);
+}
+
+- (id) init:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:@"ANTLRNoSuchElementException" reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:aName reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+@end
+
+@implementation ANTLRRewriteEarlyExitException
+
++ (id) newException
+{
+	return [[self alloc] init];
+}
+
+- (id) init
+{
+	self = [super initWithName:@"RewriteEarlyExitException" reason:nil userInfo:nil];
+	return self;
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)aUserInfo
+{
+    self = [super initWithName:aName reason:aReason userInfo:aUserInfo];
+    return(self);
+}
+
+- (NSString *) description
+{
+	return [self name];
+}
+
+@end
+
+@implementation ANTLRUnsupportedOperationException
+
++ (id) newException:(NSString *)aReason
+{
+    return [[ANTLRRuntimeException alloc] initWithName:@"Unsupported Operation Exception" reason:aReason userInfo:nil];
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason
+{
+    self=[super initWithName:aName reason:aReason userInfo:nil];
+    return self;
+}
+
+- (id) initWithName:(NSString *)aName reason:(NSString *)aReason userInfo:(NSDictionary *)userInfo
+{
+    self=[super initWithName:aName reason:aReason userInfo:userInfo];
+    return self;
+}
+
+@end
+
diff --git a/runtime/ObjC/Framework/StreamEnumerator.h b/runtime/ObjC/Framework/StreamEnumerator.h
new file mode 100644
index 0000000..9e102f2
--- /dev/null
+++ b/runtime/ObjC/Framework/StreamEnumerator.h
@@ -0,0 +1,48 @@
+//
+//  ANTLRStreamEnumertor.h
+//  ANTLR
+//
+//  Created by Ian Michell on 29/04/2010.
+// [The "BSD licence"]
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "AMutableArray.h"
+
+@interface ANTLRStreamEnumerator : NSEnumerator
+{
+	NSInteger i;
+	id eof;
+	AMutableArray *nodes;
+}
+
+-(id) initWithNodes:(AMutableArray *) n andEOF:(id) obj;
+-(BOOL) hasNext;
+
+@property NSInteger i;
+@property (retain) id eof;
+@property (retain) AMutableArray *nodes;
+@end
diff --git a/runtime/ObjC/Framework/StreamEnumerator.m b/runtime/ObjC/Framework/StreamEnumerator.m
new file mode 100644
index 0000000..103646e
--- /dev/null
+++ b/runtime/ObjC/Framework/StreamEnumerator.m
@@ -0,0 +1,77 @@
+//
+//  ANTLRStreamEnumertor.m
+//  ANTLR
+//
+//  Created by Ian Michell on 29/04/2010.
+// [The "BSD licence"]
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRStreamEnumerator.h"
+
+
+@implementation ANTLRStreamEnumerator
+
+-(id) init
+{
+	self = [super init];
+	if (self)
+	{
+		i = 0;
+	}
+	return self;
+}
+
+-(id) initWithNodes:(AMutableArray *) n andEOF:(id) obj
+{
+	self = [self init];
+	if (self)
+	{
+		nodes = n;
+		eof = obj;
+	}
+	return self;
+}
+
+-(BOOL) hasNext
+{
+	return i < [nodes count];
+}
+
+-(id) nextObject
+{
+	NSUInteger current = i;
+	i++;
+	if (current < [nodes count])
+	{
+		return [nodes objectAtIndex:current];
+	}
+	return eof;
+}
+
+@synthesize i;
+@synthesize eof;
+@synthesize nodes;
+@end
diff --git a/runtime/ObjC/Framework/StringStreamState.h b/runtime/ObjC/Framework/StringStreamState.h
new file mode 100644
index 0000000..eda483b
--- /dev/null
+++ b/runtime/ObjC/Framework/StringStreamState.h
@@ -0,0 +1,58 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRCharStream.h"
+
+// encapsulates a stream's state, so we can put it into an NSArray.
+// No magic is happening here.
+
+@interface ANTLRCharStreamState : NSObject <ANTLRCharStream>
+{
+	NSUInteger index;
+	NSUInteger line;
+	NSUInteger charPositionInLine;
+}
+
++ newANTLRCharStreamState;
+
+- (id) init;
+
+- (NSUInteger) getIndex;
+- (void) setIndex: (NSUInteger) anIndex;
+
+- (NSUInteger) getLine;
+- (void) setLine: (NSUInteger) aLine;
+
+- (NSUInteger) getCharPositionInLine;
+- (void) setCharPositionInLine: (NSUInteger) aCharPositionInLine;
+
+
+@property (assign) NSUInteger index;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;
+
+@end
diff --git a/runtime/ObjC/Framework/SymbolStack.h b/runtime/ObjC/Framework/SymbolStack.h
new file mode 100644
index 0000000..169df9f
--- /dev/null
+++ b/runtime/ObjC/Framework/SymbolStack.h
@@ -0,0 +1,75 @@
+//
+//  ANTLRSymbolStack.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseStack.h"
+// #import "ANTLRSymbolScope.h"
+
+//#define GLOBAL_SCOPE       0
+//#define LOCAL_SCOPE        1
+#define HASHSIZE         101
+#define HBUFSIZE      0x2000
+
+@interface ANTLRSymbolsScope : NSObject
+{
+
+}
+
++ (ANTLRSymbolsScope *)newANTLRSymbolsScope;
+
+- (id)init;
+@end
+
+
+@interface ANTLRSymbolStack : ANTLRBaseStack {
+}
+
+// Contruction/Destruction
++(ANTLRSymbolStack *)newANTLRSymbolStack;
++(ANTLRSymbolStack *)newANTLRSymbolStackWithLen:(NSInteger)cnt;
+-(id)init;
+-(id)initWithLen:(NSInteger)cnt;
+-(void)dealloc;
+
+// Instance Methods
+- (id) copyWithZone:(NSZone *)aZone;
+/* clear -- reinitialize the maplist array */
+
+-(ANTLRSymbolsScope *)getHashMapEntry:(NSInteger)idx;
+
+-(ANTLRSymbolsScope **)getHashMap;
+
+-(ANTLRSymbolsScope *) pop;
+
+- (void) insertObject:(ANTLRSymbolsScope *)aScope atIndex:(NSInteger)idx;
+- (ANTLRSymbolsScope *)objectAtIndex:(NSInteger)idx;
+
+@end
diff --git a/runtime/ObjC/Framework/SymbolStack.m b/runtime/ObjC/Framework/SymbolStack.m
new file mode 100644
index 0000000..3c43ebb
--- /dev/null
+++ b/runtime/ObjC/Framework/SymbolStack.m
@@ -0,0 +1,126 @@
+//
+//  ANTLRSymbolStack.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/9/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#define SUCCESS (0)
+#define FAILURE (-1)
+
+#import "ANTLRSymbolStack.h"
+#import "ANTLRTree.h"
+
+
+@implementation ANTLRSymbolsScope
+
++ (ANTLRSymbolsScope *)newANTLRSymbolsScope
+{
+    return( [[ANTLRSymbolsScope alloc] init] );
+}
+
+- (id)init
+{
+    if ((self = [super init]) != nil) {
+    }
+    return (self);
+}
+
+@end
+
+/*
+ * Start of ANTLRSymbolStack
+ */
+@implementation ANTLRSymbolStack
+
++(ANTLRSymbolStack *)newANTLRSymbolStack
+{
+    return [[ANTLRSymbolStack alloc] initWithLen:30];
+}
+
++(ANTLRSymbolStack *)newANTLRSymbolStackWithLen:(NSInteger)cnt
+{
+    return [[ANTLRSymbolStack alloc] initWithLen:cnt];
+}
+
+-(id)init
+{
+	if ((self = [super init]) != nil) {
+	}
+    return( self );
+}
+
+-(id)initWithLen:(NSInteger)cnt
+{
+	if ((self = [super initWithLen:cnt]) != nil) {
+	}
+    return( self );
+}
+
+-(void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRSymbolStack" );
+#endif
+	[super dealloc];
+}
+
+- (id) copyWithZone:(NSZone *)aZone
+{
+    return [super copyWithZone:aZone];
+}
+
+-(ANTLRSymbolsScope *)getHashMapEntry:(NSInteger)idx
+{
+	return( (ANTLRSymbolsScope *)[super objectAtIndex:idx] );
+}
+
+-(ANTLRSymbolsScope **)getHashMap
+{
+	return( (ANTLRSymbolsScope **)ptrBuffer );
+}
+
+-(ANTLRSymbolsScope *) pop
+{
+    return (ANTLRSymbolsScope *)[super pop];
+}
+
+- (void) insertObject:(ANTLRSymbolsScope *)aRule atIndex:(NSInteger)idx
+{
+    if ( aRule != ptrBuffer[idx] ) {
+        if ( ptrBuffer[idx] ) [ptrBuffer[idx] release];
+        [aRule retain];
+    }
+    ptrBuffer[idx] = aRule;
+}
+
+- (ANTLRSymbolsScope *)objectAtIndex:(NSInteger)idx
+{
+    return (ANTLRSymbolsScope *)[super objectAtIndex:idx];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/Token+DebuggerSupport.h b/runtime/ObjC/Framework/Token+DebuggerSupport.h
new file mode 100644
index 0000000..659e763
--- /dev/null
+++ b/runtime/ObjC/Framework/Token+DebuggerSupport.h
@@ -0,0 +1,41 @@
+//
+//  ANTLRToken+DebuggerSupport.h
+//  ANTLR
+//
+//  Created by Kay Röpke on 03.12.2006.
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+//
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRToken.h"
+#import "ANTLRCommonToken.h"
+
+@interface ANTLRCommonToken(DebuggerSupport)
+
+- (NSString *)debuggerDescription;
+
+@end
diff --git a/runtime/ObjC/Framework/Token+DebuggerSupport.m b/runtime/ObjC/Framework/Token+DebuggerSupport.m
new file mode 100644
index 0000000..114b236
--- /dev/null
+++ b/runtime/ObjC/Framework/Token+DebuggerSupport.m
@@ -0,0 +1,61 @@
+//
+//  ANTLRToken+DebuggerSupport.m
+//  ANTLR
+//
+//  Created by Kay Röpke on 03.12.2006.
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRToken+DebuggerSupport.h"
+
+
+@implementation ANTLRCommonToken(DebuggerSupport)
+
+- (NSString *)debuggerDescription
+{
+	NSString *_text = self.text;
+	NSMutableString *escapedText;
+	if (_text) {
+		escapedText = [_text copyWithZone:nil];
+		NSRange wholeString = NSMakeRange(0,[escapedText length]);
+		[escapedText replaceOccurrencesOfString:@"%" withString:@"%25" options:0 range:wholeString];
+		[escapedText replaceOccurrencesOfString:@"\n" withString:@"%0A" options:0 range:wholeString];
+		[escapedText replaceOccurrencesOfString:@"\r" withString:@"%0D" options:0 range:wholeString];
+	} else {
+		escapedText = [NSMutableString stringWithString:@""];
+	}
+	// format is tokenIndex, type, channel, line, col, (escaped)text
+	return [NSString stringWithFormat:@"%u %d %u %u %u \"%@",
+		[self getTokenIndex],
+		self.type,
+		self.channel,
+		self.line,
+		self.charPositionInLine,
+		escapedText
+		];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/Token.h b/runtime/ObjC/Framework/Token.h
new file mode 100644
index 0000000..04724bd
--- /dev/null
+++ b/runtime/ObjC/Framework/Token.h
@@ -0,0 +1,89 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+
+#ifndef DEBUG_DEALLOC
+#define DEBUG_DEALLOC
+#endif
+
+typedef enum {
+    ANTLRTokenTypeEOF = -1,
+    ANTLRTokenTypeInvalid,
+    ANTLRTokenTypeEOR,
+    ANTLRTokenTypeDOWN,
+    ANTLRTokenTypeUP,
+    ANTLRTokenTypeMIN
+} ANTLRTokenType;
+
+typedef enum {
+    ANTLRTokenChannelDefault = 0,
+    ANTLRTokenChannelHidden = 99
+} ANTLRTokenChannel;
+
+#define HIDDEN 99
+
+@protocol ANTLRToken < NSObject, NSCopying >
+
+@property (retain, getter = text, setter = setText:) NSString *text;
+@property (assign) NSInteger type;
+@property (assign) NSUInteger line;
+@property (assign) NSUInteger charPositionInLine;
+
+// The singleton eofToken instance.
++ (id<ANTLRToken>) eofToken;
+// The default channel for this class of Tokens
++ (ANTLRTokenChannel) defaultChannel;
+
+// provide hooks to explicitely set the text as opposed to use the indices into the CharStream
+- (NSString *) text;
+- (void) setText:(NSString *)theText;
+
+- (NSInteger)type;
+- (void) setType: (NSInteger) aType;
+
+// ANTLR v3 provides automatic line and position tracking. Subclasses do not need to
+// override these, if they do not want to store line/pos tracking information
+- (NSUInteger)line;
+- (void) setLine: (NSUInteger) aLine;
+
+- (NSUInteger)charPositionInLine;
+- (void) setCharPositionInLine:(NSUInteger)aCharPositionInLine;
+
+// explicitely change the channel this Token is on. The default parser implementation
+// just sees the defaultChannel
+// Common idiom is to put whitespace tokens on channel 99.
+- (NSUInteger)channel;
+- (void) setChannel: (NSUInteger) aChannel;
+
+// the index of this Token into the TokenStream
+- (NSInteger) getTokenIndex;
+- (void) setTokenIndex: (NSInteger) aTokenIndex;
+- (NSString *)toString;
+
+@end
+
diff --git a/runtime/ObjC/Framework/TokenRewriteStream.h b/runtime/ObjC/Framework/TokenRewriteStream.h
new file mode 100644
index 0000000..7b97168
--- /dev/null
+++ b/runtime/ObjC/Framework/TokenRewriteStream.h
@@ -0,0 +1,170 @@
+//
+//  ANTLRTokenRewriteStream.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/19/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRCommonTokenStream.h"
+#import "ANTLRLinkBase.h"
+#import "ANTLRHashMap.h"
+#import "ANTLRMapElement.h"
+#import "ANTLRTokenSource.h"
+
+// Define the rewrite operation hierarchy
+
+@interface ANTLRRewriteOperation : ANTLRCommonTokenStream
+{
+/** What rwIndex into rewrites List are we? */
+NSInteger instructionIndex;
+/** Token buffer rwIndex. */
+NSInteger rwIndex;
+NSString *text;
+}
+
+@property (getter=getInstructionIndex, setter=setInstructionIndex:) NSInteger instructionIndex;
+@property (assign) NSInteger rwIndex;
+@property (retain, getter=text, setter=setText:) NSString *text;
+
++ (ANTLRRewriteOperation *) newANTLRRewriteOperation:(NSInteger)anIndex Text:(NSString *)text;
+
+- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText;
+
+/** Execute the rewrite operation by possibly adding to the buffer.
+ *  Return the rwIndex of the next token to operate on.
+ */
+- (NSInteger) execute:(NSString *)buf;
+
+- (NSString *)toString;
+- (NSInteger) indexOf:(char)aChar inString:(NSString *)aString;
+@end
+
+@interface ANTLRInsertBeforeOp : ANTLRRewriteOperation {
+}
+
++ (ANTLRInsertBeforeOp *) newANTLRInsertBeforeOp:(NSInteger)anIndex Text:(NSString *)theText;
+- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText;
+
+@end
+
+/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
+ *  instructions.
+ */
+@interface ANTLRReplaceOp : ANTLRRewriteOperation {
+    NSInteger lastIndex;
+}
+
+@property (assign) NSInteger lastIndex;
+
++ (ANTLRReplaceOp *) newANTLRReplaceOp:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString*)theText;
+- (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText;
+
+- (NSInteger) execute:(NSString *)buf;
+- (NSString *)toString;
+
+@end
+
+@interface ANTLRDeleteOp : ANTLRReplaceOp {
+}
++ (ANTLRDeleteOp *) newANTLRDeleteOp:(NSInteger)from ToIndex:(NSInteger)to;
+
+- (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to;
+
+- (NSString *)toString;
+
+@end
+
+
+@interface ANTLRTokenRewriteStream : ANTLRCommonTokenStream {
+/** You may have multiple, named streams of rewrite operations.
+ *  I'm calling these things "programs."
+ *  Maps String (name) -> rewrite (List)
+ */
+ANTLRHashMap *programs;
+
+/** Map String (program name) -> Integer rwIndex */
+ANTLRHashMap *lastRewriteTokenIndexes;
+}
+
+@property (retain, getter=getPrograms, setter=setPrograms:) ANTLRHashMap *programs;
+@property (retain, getter=getLastRewriteTokenIndexes, setter=setLastRewriteTokenIndexes:) ANTLRHashMap *lastRewriteTokenIndexes;
+
++ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream;
++ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream:(id<ANTLRTokenSource>) aTokenSource;
++ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream:(id<ANTLRTokenSource>) aTokenSource Channel:(NSInteger)aChannel;
+
+- (id) init;
+- (id)initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource;
+- (id)initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource Channel:(NSInteger)aChannel;
+
+- (ANTLRHashMap *)getPrograms;
+- (void)setPrograms:(ANTLRHashMap *)aProgList;
+
+- (void) rollback:(NSInteger)instructionIndex;
+- (void) rollback:(NSString *)programName Index:(NSInteger)anInstructionIndex;
+- (void) deleteProgram;
+- (void) deleteProgram:(NSString *)programName;
+- (void) insertAfterToken:(id<ANTLRToken>)t Text:(NSString *)theText;
+- (void) insertAfterIndex:(NSInteger)anIndex Text:(NSString *)theText;
+- (void) insertAfterProgNam:(NSString *)programName Index:(NSInteger)anIndex Text:(NSString *)theText;
+
+
+- (void) insertBeforeToken:(id<ANTLRToken>)t Text:(NSString *)theText;
+- (void) insertBeforeIndex:(NSInteger)anIndex Text:(NSString *)theText;
+- (void) insertBeforeProgName:(NSString *)programName Index:(NSInteger)anIndex Text:(NSString *)theText;
+- (void) replaceFromIndex:(NSInteger)anIndex Text:(NSString *)theText;
+- (void) replaceFromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText;
+- (void) replaceFromToken:(id<ANTLRToken>)indexT Text:(NSString *)theText;
+- (void) replaceFromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to Text:(NSString *)theText;
+- (void) replaceProgNam:(NSString *)programName Token:(id<ANTLRToken>)from Token:(id<ANTLRToken>)to Text:(NSString *)theText;
+- (void) replaceProgNam:(NSString *)programName FromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText;
+- (void) delete:(NSInteger)anIndex;
+- (void) delete:(NSInteger)from ToIndex:(NSInteger)to;
+- (void) deleteToken:(id<ANTLRToken>)indexT;
+- (void) deleteFromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to;
+- (void) delete:(NSString *)programName FromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to;
+- (void) delete:(NSString *)programName FromIndex:(NSInteger)from ToIndex:(NSInteger)to;
+- (NSInteger)getLastRewriteTokenIndex;
+- (NSInteger)getLastRewriteTokenIndex:(NSString *)programName;
+- (void)setLastRewriteTokenIndex:(NSString *)programName Index:(NSInteger)anInt;
+- (ANTLRHashMap *) getProgram:(NSString *)name;
+- (ANTLRHashMap *) initializeProgram:(NSString *)name;
+- (NSString *)toOriginalString;
+- (NSString *)toOriginalString:(NSInteger)start End:(NSInteger)end;
+- (NSString *)toString;
+- (NSString *)toString:(NSString *)programName;
+- (NSString *)toStringFromStart:(NSInteger)start ToEnd:(NSInteger)end;
+- (NSString *)toString:(NSString *)programName FromStart:(NSInteger)start ToEnd:(NSInteger)end;
+- (ANTLRHashMap *)reduceToSingleOperationPerIndex:(ANTLRHashMap *)rewrites;
+- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind;
+- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind Index:(NSInteger)before;
+- (NSString *)catOpText:(id)a PrevText:(id)b;
+- (NSMutableString *)toDebugString;
+- (NSMutableString *)toDebugStringFromStart:(NSInteger)start ToEnd:(NSInteger)end;
+
+@end
diff --git a/runtime/ObjC/Framework/TokenRewriteStream.m b/runtime/ObjC/Framework/TokenRewriteStream.m
new file mode 100644
index 0000000..e94f885
--- /dev/null
+++ b/runtime/ObjC/Framework/TokenRewriteStream.m
@@ -0,0 +1,692 @@
+//
+//  ANTLRTokenRewriteStream.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/19/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTokenRewriteStream.h"
+#import "ANTLRRuntimeException.h"
+
+static NSString *DEFAULT_PROGRAM_NAME = @"default";
+static NSInteger PROGRAM_INIT_SIZE = 100;
+static NSInteger MIN_TOKEN_INDEX = 0;
+
+extern NSInteger debug;
+
+// Define the rewrite operation hierarchy
+
+@implementation ANTLRRewriteOperation
+
+@synthesize instructionIndex;
+@synthesize rwIndex;
+@synthesize text;
+
++ (ANTLRRewriteOperation *) newANTLRRewriteOperation:(NSInteger)anIndex Text:(NSString *)theText
+{
+    return [[ANTLRRewriteOperation alloc] initWithIndex:anIndex Text:theText];
+}
+
+- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText
+{
+    if ((self = [super init]) != nil) {
+        rwIndex = anIndex;
+        text = theText;
+    }
+    return self;
+}
+
+/** Execute the rewrite operation by possibly adding to the buffer.
+ *  Return the rwIndex of the next token to operate on.
+ */
+- (NSInteger) execute:(NSString *)buf
+{
+    return rwIndex;
+}
+
+- (NSString *)toString
+{
+    NSString *opName = [self className];
+    int $index = [self indexOf:'$' inString:opName];
+    opName = [opName substringWithRange:NSMakeRange($index+1, [opName length])];
+    return [NSString stringWithFormat:@"<%@%d:\"%@\">", opName, rwIndex, opName];
+}
+
+- (NSInteger) indexOf:(char)aChar inString:(NSString *)aString
+{
+    char indexedChar;
+
+    for( int i = 0; i < [aString length]; i++ ) {
+        indexedChar = [aString characterAtIndex:i];
+        if (indexedChar == aChar) {
+            return i;
+        }
+    }
+    return -1;
+}
+
+@end
+
+@implementation ANTLRInsertBeforeOp
+
++ (ANTLRInsertBeforeOp *) newANTLRInsertBeforeOp:(NSInteger) anIndex Text:(NSString *)theText
+{
+    return [[ANTLRInsertBeforeOp alloc] initWithIndex:anIndex Text:theText];
+}
+
+- (id) initWithIndex:(NSInteger)anIndex Text:(NSString *)theText
+{
+    if ((self = [super initWithIndex:anIndex Text:theText]) != nil) {
+        rwIndex = anIndex;
+        text = theText;
+    }
+    return self;
+}
+
+
+- (NSInteger) execute:(NSMutableString *)buf
+{
+    [buf appendString:text];
+    if ( ((ANTLRCommonToken *)[tokens objectAtIndex:rwIndex]).type != ANTLRTokenTypeEOF ) {
+        [buf appendString:[[tokens objectAtIndex:rwIndex] text]];
+    }
+    return rwIndex+1;
+}
+
+@end
+
+/** I'm going to try replacing range from x..y with (y-x)+1 ANTLRReplaceOp
+ *  instructions.
+ */
+@implementation ANTLRReplaceOp
+
+@synthesize lastIndex;
+
++ (ANTLRReplaceOp *) newANTLRReplaceOp:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString*)theText
+{
+    return [[ANTLRReplaceOp alloc] initWithIndex:from ToIndex:to Text:theText];
+}
+
+- (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText
+{
+    if ((self = [super initWithIndex:from Text:theText]) != nil) {
+        lastIndex = to;
+    }
+    return self;
+}
+
+
+- (NSInteger) execute:(NSMutableString *)buf
+{
+    if ( text!=nil ) {
+        [buf appendString:text];
+    }
+        return lastIndex+1;
+}
+
+- (NSString *)toString
+{
+    return [NSString stringWithFormat:@"<ANTLRReplaceOp@ %d..%d :>%@\n", rwIndex, lastIndex, text];
+}
+
+@end
+
+@implementation ANTLRDeleteOp
+
++ (ANTLRDeleteOp *) newANTLRDeleteOp:(NSInteger)from ToIndex:(NSInteger)to
+{
+    // super(from To:to, null);
+    return [[ANTLRDeleteOp alloc] initWithIndex:from ToIndex:to];
+}
+
+ - (id) initWithIndex:(NSInteger)from ToIndex:(NSInteger)to
+{
+    if ((self = [super initWithIndex:from ToIndex:to Text:nil]) != nil) {
+        lastIndex = to;
+    }
+    return self;
+}
+
+- (NSString *)toString
+{
+    return [NSString stringWithFormat:@"<DeleteOp@ %d..%d\n",  rwIndex, lastIndex];
+}
+
+@end
+
+
+@implementation ANTLRTokenRewriteStream
+
+@synthesize programs;
+@synthesize lastRewriteTokenIndexes;
+
++ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream
+{
+    return [[ANTLRTokenRewriteStream alloc] init];
+}
+
++ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream:(id<ANTLRTokenSource>) aTokenSource
+{
+    return [[ANTLRTokenRewriteStream alloc] initWithTokenSource:aTokenSource];
+}
+
++ (ANTLRTokenRewriteStream *)newANTLRTokenRewriteStream:(id<ANTLRTokenSource>) aTokenSource Channel:(NSInteger)aChannel
+{
+    return [[ANTLRTokenRewriteStream alloc] initWithTokenSource:aTokenSource Channel:aChannel];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil) {
+        programs = [ANTLRHashMap newANTLRHashMap];
+        [programs addObject:[ANTLRMapElement newANTLRMapElementWithName:DEFAULT_PROGRAM_NAME Node:[ANTLRHashMap newANTLRHashMapWithLen:PROGRAM_INIT_SIZE]]];
+        lastRewriteTokenIndexes = [ANTLRHashMap newANTLRHashMap];
+    }
+    return self;
+}
+
+- (id)initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource
+{
+    if ((self = [super init]) != nil) {
+        programs = [ANTLRHashMap newANTLRHashMap];
+        [programs addObject:[ANTLRMapElement newANTLRMapElementWithName:DEFAULT_PROGRAM_NAME Node:[ANTLRHashMap newANTLRHashMapWithLen:PROGRAM_INIT_SIZE]]];
+        lastRewriteTokenIndexes = [ANTLRHashMap newANTLRHashMap];
+        tokenSource = aTokenSource;
+    }
+    return self;
+}
+
+- (id)initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource Channel:(NSInteger)aChannel
+{
+    if ((self = [super init]) != nil) {
+        programs = [ANTLRHashMap newANTLRHashMap];
+        [programs addObject:[ANTLRMapElement newANTLRMapElementWithName:DEFAULT_PROGRAM_NAME Node:[ANTLRHashMap newANTLRHashMapWithLen:PROGRAM_INIT_SIZE]]];
+        lastRewriteTokenIndexes = [ANTLRHashMap newANTLRHashMap];
+        tokenSource = aTokenSource;
+        channel = aChannel;
+    }
+    return self;
+}
+
+- (ANTLRHashMap *)getPrograms
+{
+    return programs;
+}
+
+- (void)setPrograms:(ANTLRHashMap *)aProgList
+{
+    programs = aProgList;
+}
+
+- (void) rollback:(NSInteger)instructionIndex
+{
+    [self rollback:DEFAULT_PROGRAM_NAME Index:instructionIndex];
+}
+
+/** Rollback the instruction stream for a program so that
+ *  the indicated instruction (via instructionIndex) is no
+ *  longer in the stream.  UNTESTED!
+ */
+- (void) rollback:(NSString *)programName Index:(NSInteger)anInstructionIndex
+{
+    id object;
+    ANTLRHashMap *is;
+
+    //    AMutableArray *is = [programs get(programName)];
+    is = [self getPrograms];
+    object = [is getName:programName];
+    if ( is != nil ) {
+#pragma warning this has to be fixed
+        [programs insertObject:programName  atIndex:anInstructionIndex];
+    }
+}
+
+- (void) deleteProgram
+{
+    [self deleteProgram:DEFAULT_PROGRAM_NAME];
+}
+
+/** Reset the program so that no instructions exist */
+- (void) deleteProgram:(NSString *)programName
+{
+    [self rollback:programName Index:MIN_TOKEN_INDEX];
+}
+
+- (void) insertAfterToken:(id<ANTLRToken>)t Text:(NSString *)theText
+{
+    [self insertAfterProgNam:DEFAULT_PROGRAM_NAME Index:[t getTokenIndex] Text:theText];
+}
+
+- (void) insertAfterIndex:(NSInteger)anIndex Text:(NSString *)theText
+{
+    [self insertAfterProgNam:DEFAULT_PROGRAM_NAME Index:(NSInteger)anIndex Text:(NSString *)theText];
+}
+
+- (void) insertAfterProgNam:(NSString *)programName Index:(NSInteger)anIndex Text:(NSString *)theText
+{
+    // to insert after, just insert before next rwIndex (even if past end)
+    [self insertBeforeProgName:programName Index:anIndex+1 Text:theText];
+    //addToSortedRewriteList(programName, new InsertAfterOp(rwIndex,text));
+}
+
+
+
+
+
+
+
+
+
+- (void) insertBeforeToken:(id<ANTLRToken>)t Text:(NSString *)theText
+{
+    [self insertBeforeProgName:DEFAULT_PROGRAM_NAME Index:[t getTokenIndex] Text:theText];
+}
+
+- (void) insertBeforeIndex:(NSInteger)anIndex Text:(NSString *)theText
+{
+    [self insertBeforeProgName:DEFAULT_PROGRAM_NAME Index:anIndex Text:theText];
+}
+
+- (void) insertBeforeProgName:(NSString *)programName Index:(NSInteger)rwIndex Text:(NSString *)theText
+{
+    //addToSortedRewriteList(programName, new ANTLRInsertBeforeOp(rwIndex,text));
+    ANTLRRewriteOperation *op = [ANTLRInsertBeforeOp newANTLRInsertBeforeOp:rwIndex Text:theText];
+    ANTLRHashMap *rewrites = [self getProgram:programName];
+    op.instructionIndex = [rewrites count];
+    [rewrites addObject:op];
+}
+
+- (void) replaceFromIndex:(NSInteger)anIndex Text:(NSString *)theText
+{
+    [self replaceProgNam:DEFAULT_PROGRAM_NAME FromIndex:anIndex ToIndex:anIndex Text:theText];
+}
+
+- (void) replaceFromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText
+{
+    [self replaceProgNam:DEFAULT_PROGRAM_NAME FromIndex:from ToIndex:to Text:theText];
+}
+
+- (void) replaceFromToken:(id<ANTLRToken>)anIndexT Text:(NSString *)theText
+{
+    [self replaceProgNam:DEFAULT_PROGRAM_NAME FromIndex:[anIndexT getTokenIndex] ToIndex:[anIndexT getTokenIndex] Text:theText];
+}
+
+- (void) replaceFromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to Text:(NSString *)theText
+{
+    [self replaceProgNam:DEFAULT_PROGRAM_NAME FromIndex:[from getTokenIndex] ToIndex:[to getTokenIndex] Text:theText];
+}
+
+- (void) replaceProgNam:(NSString *)programName Token:(id<ANTLRToken>)from Token:(id<ANTLRToken>)to Text:(NSString *)theText
+{
+    [self replaceProgNam:programName FromIndex:[from getTokenIndex] ToIndex:[to getTokenIndex] Text:theText];
+}
+
+- (void) replaceProgNam:(NSString *)programName FromIndex:(NSInteger)from ToIndex:(NSInteger)to Text:(NSString *)theText
+{
+    if ( from > to || from < 0 || to < 0 || to >= [tokens count] ) {
+        @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"replace: range invalid: %d..%d size=%d\n", from, to, [tokens count]]];
+    }
+    ANTLRRewriteOperation *op = [ANTLRReplaceOp newANTLRReplaceOp:from ToIndex:to Text:theText];
+    ANTLRHashMap *rewrites = (ANTLRHashMap *)[lastRewriteTokenIndexes getName:programName];
+    op.instructionIndex = [rewrites count];
+    [rewrites addObject:op];
+}
+
+- (void) delete:(NSInteger)anIndex
+{
+    [self delete:DEFAULT_PROGRAM_NAME  FromIndex:(NSInteger)anIndex  ToIndex:(NSInteger)anIndex];
+}
+
+- (void) delete:(NSInteger)from ToIndex:(NSInteger)to
+{
+    [self delete:DEFAULT_PROGRAM_NAME FromIndex:from ToIndex:to];
+}
+
+- (void) deleteToken:(id<ANTLRToken>)anIndexT
+{
+    [self delete:DEFAULT_PROGRAM_NAME FromIndex:[anIndexT getTokenIndex] ToIndex:[anIndexT getTokenIndex]];
+}
+
+- (void) deleteFromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to
+{
+    [self delete:DEFAULT_PROGRAM_NAME FromIndex:[from getTokenIndex] ToIndex:[to getTokenIndex]];
+}
+
+- (void) delete:(NSString *)programName FromToken:(id<ANTLRToken>)from ToToken:(id<ANTLRToken>)to
+{
+    [self replaceProgNam:programName FromIndex:[from getTokenIndex] ToIndex:[to getTokenIndex] Text:nil];
+}
+
+- (void) delete:(NSString *)programName FromIndex:(NSInteger)from ToIndex:(NSInteger)to
+{
+    [self replaceProgNam:programName FromIndex:from ToIndex:to Text:nil];
+}
+
+- (NSInteger)getLastRewriteTokenIndex
+{
+    return [self getLastRewriteTokenIndex:DEFAULT_PROGRAM_NAME];
+}
+
+- (NSInteger)getLastRewriteTokenIndex:(NSString *)programName
+{
+#pragma warning fix this to look up the hashed name
+    NSInteger anInt = -1;
+    ANTLRMapElement *node = [lastRewriteTokenIndexes lookup:programName Scope:0];
+    if ( node != nil ) {
+        anInt = [lastRewriteTokenIndexes hash:programName];
+    }
+    return anInt;
+}
+
+- (void)setLastRewriteTokenIndex:(NSString *)programName Index:(NSInteger)anInt
+{
+    [lastRewriteTokenIndexes insertObject:programName atIndex:anInt];
+}
+
+-(ANTLRHashMap *) getProgram:(NSString *)name
+{
+   ANTLRHashMap *is = (ANTLRHashMap *)[programs getName:name];
+    if ( is == nil ) {
+        is = [self initializeProgram:name];
+    }
+    return is;
+}
+
+-(ANTLRHashMap *) initializeProgram:(NSString *)name
+{
+    ANTLRHashMap *is = [ANTLRHashMap newANTLRHashMapWithLen:PROGRAM_INIT_SIZE];
+    [is putName:name Node:nil];
+    return is;
+}
+
+- (NSString *)toOriginalString
+{
+    [super fill];
+    return [self toOriginalString:MIN_TOKEN_INDEX End:[tokens count]-1];
+}
+
+- (NSString *)toOriginalString:(NSInteger)start End:(NSInteger)end
+{
+    NSMutableString *buf = [NSMutableString stringWithCapacity:100];
+    for (int i = start; i >= MIN_TOKEN_INDEX && i <= end && i< [tokens count]; i++) {
+        if ( [[lastRewriteTokenIndexes objectAtIndex:i] type] != ANTLRTokenTypeEOF )
+            [buf appendString:[[tokens objectAtIndex:i] text]];
+    }
+    return [NSString stringWithString:buf];
+}
+
+- (NSString *)toString
+{
+    [super fill];
+    return [self toStringFromStart:MIN_TOKEN_INDEX ToEnd:[tokens count]-1];
+}
+
+- (NSString *)toString:(NSString *)programName
+{
+    [super fill];
+    return [self toString:programName FromStart:MIN_TOKEN_INDEX ToEnd:[[programs objectAtIndex:MIN_TOKEN_INDEX] count]-1];
+}
+
+- (NSString *)toStringFromStart:(NSInteger)start ToEnd:(NSInteger)end
+{
+    return [self toString:DEFAULT_PROGRAM_NAME FromStart:start ToEnd:end];
+}
+
+- (NSString *)toString:(NSString *)programName FromStart:(NSInteger)start ToEnd:(NSInteger)end
+{
+    ANTLRHashMap *rewrites = (ANTLRHashMap *)[programs getName:programName];
+
+    // ensure start/end are in range
+    if ( end > [tokens count]-1 ) end = [tokens count]-1;
+    if ( start < 0 )
+        start = 0;
+
+    if ( rewrites == nil || [rewrites count] == 0 ) {
+        return [self toOriginalString:start End:end]; // no instructions to execute
+    }
+    NSMutableString *buf = [NSMutableString stringWithCapacity:100];
+
+    // First, optimize instruction stream
+    ANTLRHashMap *indexToOp = [self reduceToSingleOperationPerIndex:rewrites];
+
+    // Walk buffer, executing instructions and emitting tokens
+    int i = start;
+    while ( i <= end && i < [tokens count] ) {
+        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[indexToOp objectAtIndex:i];
+        [indexToOp setObject:nil atIndex:i]; // remove so any left have rwIndex size-1
+        id<ANTLRToken>t = (id<ANTLRToken>) [tokens objectAtIndex:i];
+        if ( op == nil ) {
+            // no operation at that rwIndex, just dump token
+            if ( t.type != ANTLRTokenTypeEOF )
+                [buf appendString:t.text];
+            i++; // move to next token
+        }
+        else {
+            i = [op execute:buf]; // execute operation and skip
+        }
+    }
+
+    // include stuff after end if it's last rwIndex in buffer
+    // So, if they did an insertAfter(lastValidIndex, "foo"), include
+    // foo if end==lastValidIndex.
+    //if ( end == [tokens size]-1 ) {
+    if ( end == [tokens count]-1 ) {
+        // Scan any remaining operations after last token
+        // should be included (they will be inserts).
+        int i2 = 0;
+        while ( i2 < [indexToOp count] - 1 ) {
+            ANTLRRewriteOperation *op = [indexToOp objectAtIndex:i2];
+            if ( op.rwIndex >= [tokens count]-1 ) {
+                [buf appendString:op.text];
+            }
+        }
+    }
+    return [NSString stringWithString:buf];
+}
+
+/** We need to combine operations and report invalid operations (like
+ *  overlapping replaces that are not completed nested).  Inserts to
+ *  same rwIndex need to be combined etc...   Here are the cases:
+ *
+ *  I.i.u I.j.v								leave alone, nonoverlapping
+ *  I.i.u I.i.v								combine: Iivu
+ *
+ *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
+ *  R.i-j.u R.i-j.v							delete first R
+ *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
+ *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
+ *
+ *  I.i.u R.x-y.v | i in x-y				delete I
+ *  I.i.u R.x-y.v | i not in x-y			leave alone, nonoverlapping
+ *  R.x-y.v I.i.u | i in x-y				ERROR
+ *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
+ *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
+ *
+ *  I.i.u = insert u before op @ rwIndex i
+ *  R.x-y.u = replace x-y indexed tokens with u
+ *
+ *  First we need to examine replaces.  For any replace op:
+ *
+ * 		1. wipe out any insertions before op within that range.
+ *		2. Drop any replace op before that is contained completely within
+ *         that range.
+ *		3. Throw exception upon boundary overlap with any previous replace.
+ *
+ *  Then we can deal with inserts:
+ *
+ * 		1. for any inserts to same rwIndex, combine even if not adjacent.
+ * 		2. for any prior replace with same left boundary, combine this
+ *         insert with replace and delete this replace.
+ * 		3. throw exception if rwIndex in same range as previous replace
+ *
+ *  Don't actually delete; make op null in list. Easier to walk list.
+ *  Later we can throw as we add to rwIndex -> op map.
+ *
+ *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
+ *  inserted stuff would be before the replace range.  But, if you
+ *  add tokens in front of a method body '{' and then delete the method
+ *  body, I think the stuff before the '{' you added should disappear too.
+ *
+ *  Return a map from token rwIndex to operation.
+ */
+- (ANTLRHashMap *)reduceToSingleOperationPerIndex:(ANTLRHashMap *)rewrites
+{
+    //System.out.println("rewrites="+rewrites);
+    if (debug > 1) NSLog(@"rewrites=%@\n", [rewrites getName:DEFAULT_PROGRAM_NAME]);
+    // WALK REPLACES
+    for (int i = 0; i < [rewrites count]; i++) {
+        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
+        if ( op==nil )
+            continue;
+        if ( !([[op class] isKindOfClass:[ANTLRReplaceOp class]]) )
+            continue;
+        ANTLRReplaceOp *rop = (ANTLRReplaceOp *)[rewrites objectAtIndex:i];
+        // Wipe prior inserts within range
+        //List inserts = getKindOfOps(rewrites, ANTLRInsertBeforeOp.class, i);
+        ANTLRHashMap *inserts = [self getKindOfOps:rewrites KindOfClass:[ANTLRInsertBeforeOp class] Index:i];
+        for (int j = 0; j < [inserts size]; j++) {
+            ANTLRInsertBeforeOp *iop = (ANTLRInsertBeforeOp *)[inserts objectAtIndex:j];
+            if ( iop.rwIndex >= rop.rwIndex && iop.rwIndex <= rop.lastIndex ) {
+                // delete insert as it's a no-op.
+                [rewrites insertObject:nil atIndex:iop.instructionIndex];
+            }
+        }
+        // Drop any prior replaces contained within
+        ANTLRHashMap *prevReplaces = [self getKindOfOps:rewrites KindOfClass:[ANTLRReplaceOp class] Index:i];
+        for (int j = 0; j < [prevReplaces count]; j++) {
+            ANTLRReplaceOp *prevRop = (ANTLRReplaceOp *) [prevReplaces objectAtIndex:j];
+            if ( prevRop.rwIndex>=rop.rwIndex && prevRop.lastIndex <= rop.lastIndex ) {
+                // delete replace as it's a no-op.
+                [rewrites setObject:nil atIndex:prevRop.instructionIndex];
+                continue;
+            }
+            // throw exception unless disjoint or identical
+            BOOL disjoint = prevRop.lastIndex<rop.rwIndex || prevRop.rwIndex > rop.lastIndex;
+            BOOL same = prevRop.rwIndex==rop.rwIndex && prevRop.lastIndex==rop.lastIndex;
+            if ( !disjoint && !same ) {
+                @throw [ANTLRIllegalArgumentException newException:
+                        [NSString stringWithFormat:@"replace op boundaries of %@, overlap with previous %@\n", rop, prevRop]];
+            }
+        }
+    }
+
+    // WALK INSERTS
+    for (int i = 0; i < [rewrites count]; i++) {
+        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
+        if ( op == nil )
+            continue;
+        if ( !([[op class] isKindOfClass:[ANTLRInsertBeforeOp class]]) )
+            continue;
+        ANTLRInsertBeforeOp *iop = (ANTLRInsertBeforeOp *)[rewrites objectAtIndex:i];
+        // combine current insert with prior if any at same rwIndex
+        ANTLRHashMap *prevInserts = (ANTLRHashMap *)[self getKindOfOps:rewrites KindOfClass:[ANTLRInsertBeforeOp class] Index:i];
+        for (int j = 0; j < [prevInserts count]; j++) {
+            ANTLRInsertBeforeOp *prevIop = (ANTLRInsertBeforeOp *) [prevInserts objectAtIndex:j];
+            if ( prevIop.rwIndex == iop.rwIndex ) { // combine objects
+                                                // convert to strings...we're in process of toString'ing
+                                                // whole token buffer so no lazy eval issue with any templates
+                iop.text = [self catOpText:iop.text PrevText:prevIop.text];
+                // delete redundant prior insert
+                [rewrites setObject:nil atIndex:prevIop.instructionIndex];
+            }
+        }
+        // look for replaces where iop.rwIndex is in range; error
+        ANTLRHashMap *prevReplaces = (ANTLRHashMap *)[self getKindOfOps:rewrites KindOfClass:[ANTLRReplaceOp class] Index:i];
+        for (int j = 0; j < [prevReplaces count]; j++) {
+            ANTLRReplaceOp *rop = (ANTLRReplaceOp *) [prevReplaces objectAtIndex:j];
+            if ( iop.rwIndex == rop.rwIndex ) {
+                rop.text = [self catOpText:iop.text PrevText:rop.text];
+                [rewrites setObject:nil atIndex:i];  // delete current insert
+                continue;
+            }
+            if ( iop.rwIndex >= rop.rwIndex && iop.rwIndex <= rop.lastIndex ) {
+                @throw [ANTLRIllegalArgumentException newException:[NSString stringWithFormat:@"insert op %d within boundaries of previous %d", iop, rop]];
+            }
+        }
+    }
+    // System.out.println("rewrites after="+rewrites);
+    ANTLRHashMap *m = [ANTLRHashMap newANTLRHashMapWithLen:15];
+    for (int i = 0; i < [rewrites count]; i++) {
+        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
+        if ( op == nil )
+            continue; // ignore deleted ops
+        if ( [m objectAtIndex:op.rwIndex] != nil ) {
+            @throw [ANTLRRuntimeException newException:@"should only be one op per rwIndex\n"];
+        }
+        //[m put(new Integer(op.rwIndex), op);
+        [m setObject:op atIndex:op.rwIndex];
+    }
+    //System.out.println("rwIndex to op: "+m);
+    if (debug > 1) NSLog(@"rwIndex to  op %d\n", (NSInteger)m);
+    return m;
+}
+
+- (NSString *)catOpText:(id)a PrevText:(id)b
+{
+    NSString *x = @"";
+    NSString *y = @"";
+    if ( a != nil )
+        x = [a toString];
+    if ( b != nil )
+        y = [b toString];
+    return [NSString stringWithFormat:@"%@%@",x, y];
+}
+
+- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind
+{
+    return [self getKindOfOps:rewrites KindOfClass:kind Index:[rewrites count]];
+}
+
+/** Get all operations before an rwIndex of a particular kind */
+- (ANTLRHashMap *)getKindOfOps:(ANTLRHashMap *)rewrites KindOfClass:(Class)kind Index:(NSInteger)before
+{
+    ANTLRHashMap *ops = [ANTLRHashMap newANTLRHashMapWithLen:15];
+    for (int i = 0; i < before && i < [rewrites count]; i++) {
+        ANTLRRewriteOperation *op = (ANTLRRewriteOperation *)[rewrites objectAtIndex:i];
+        if ( op == nil )
+            continue; // ignore deleted
+        if ( [op isKindOfClass:(Class)kind] )
+            [ops addObject:op];
+    }
+    return ops;
+}
+
+- (NSMutableString *)toDebugString
+{
+    return [self toDebugStringFromStart:MIN_TOKEN_INDEX ToEnd:[tokens count]-1];
+}
+
+- (NSMutableString *)toDebugStringFromStart:(NSInteger)start ToEnd:(NSInteger)end
+{
+    NSMutableString *buf = [NSMutableString stringWithCapacity:100];
+    for (int i = start; i >= MIN_TOKEN_INDEX && i <= end && i < [tokens count]; i++) {
+        [buf appendString:[[tokens objectAtIndex:i] text]];
+    }
+    return [NSString stringWithString:buf];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/TokenSource.h b/runtime/ObjC/Framework/TokenSource.h
new file mode 100644
index 0000000..ca1fa2b
--- /dev/null
+++ b/runtime/ObjC/Framework/TokenSource.h
@@ -0,0 +1,38 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRToken.h"
+
+// Anything that responds to -nextToken can be treated as a lexer.
+// For instance this can be a flex lexer or a handwritten one or even
+// a proxy for a remotely running token source (database, lexer, whatever).
+@protocol ANTLRTokenSource <NSObject, NSCopying>
+
+- (id<ANTLRToken>) nextToken;
+- (NSString *)getSourceName;
+
+@end
diff --git a/runtime/ObjC/Framework/TokenStream.h b/runtime/ObjC/Framework/TokenStream.h
new file mode 100644
index 0000000..c104578
--- /dev/null
+++ b/runtime/ObjC/Framework/TokenStream.h
@@ -0,0 +1,62 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRIntStream.h"
+#import "ANTLRToken.h"
+
+@protocol ANTLRTokenStream < ANTLRIntStream >
+
+// Get Token at current input pointer + i ahead where i=1 is next Token.
+// i<0 indicates tokens in the past.  So -1 is previous token and -2 is
+// two tokens ago. LT:0 is undefined.  For i>=n, return Token.EOFToken.
+// Return null for LT:0 and any index that results in an absolute address
+// that is negative.
+
+- (id<ANTLRToken>) LT:(NSInteger) i;
+
+- (id<ANTLRToken>) getToken:(NSUInteger) i;
+
+- (id) getTokenSource;
+
+- (NSString *) toString;
+/** Return the text of all tokens from start to stop, inclusive.
+ *  If the stream does not buffer all the tokens then it can just
+ *  return "" or null;  Users should not access $ruleLabel.text in
+ *  an action of course in that case.
+ */
+- (NSString *)toStringFromStart:(NSInteger)startIdx ToEnd:(NSInteger)stopIdx;
+
+/** Because the user is not required to use a token with an index stored
+ *  in it, we must provide a means for two token objects themselves to
+ *  indicate the start/end location.  Most often this will just delegate
+ *  to the other toString(int,int).  This is also parallel with
+ *  the TreeNodeStream.toString(Object,Object).
+ */
+- (NSString *) toStringFromToken:(id<ANTLRToken>)startToken ToToken:(id<ANTLRToken>)stopToken;
+
+
+@end
diff --git a/runtime/ObjC/Framework/Tree.h b/runtime/ObjC/Framework/Tree.h
new file mode 100644
index 0000000..32f603a
--- /dev/null
+++ b/runtime/ObjC/Framework/Tree.h
@@ -0,0 +1,129 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#ifndef DEBUG_DEALLOC
+#define DEBUG_DEALLOC
+#endif
+
+#import "AMutableArray.h"
+
+@protocol ANTLRTree < NSObject, NSCopying >
+
+//+ (id<ANTLRTree>) invalidNode;
+
+- (id<ANTLRTree>) getChild:(NSUInteger)index;
+- (NSUInteger) getChildCount;
+
+// Tree tracks parent and child index now > 3.0
+
+- (id<ANTLRTree>)getParent;
+
+- (void) setParent:(id<ANTLRTree>)t;
+
+/** Is there is a node above with token type ttype? */
+- (BOOL) hasAncestor:(NSInteger)ttype;
+
+/** Walk upwards and get first ancestor with this token type. */
+- (id<ANTLRTree>) getAncestor:(NSInteger) ttype;
+
+/** Return a list of all ancestors of this node.  The first node of
+ *  list is the root and the last is the parent of this node.
+ */
+- (AMutableArray *) getAncestors;
+
+/** This node is what child index? 0..n-1 */
+- (NSInteger) getChildIndex;
+
+- (void) setChildIndex:(NSInteger) index;
+
+/** Set the parent and child index values for all children */
+- (void) freshenParentAndChildIndexes;
+
+/** Add t as a child to this node.  If t is null, do nothing.  If t
+ *  is nil, add all children of t to this' children.
+ */
+- (void) addChild:(id<ANTLRTree>) t;
+
+/** Set ith child (0..n-1) to t; t must be non-null and non-nil node */
+- (void) setChild:(NSInteger)i With:(id<ANTLRTree>) t;
+
+- (id) deleteChild:(NSInteger) i;
+
+/** Delete children from start to stop and replace with t even if t is
+ *  a list (nil-root tree).  num of children can increase or decrease.
+ *  For huge child lists, inserting children can force walking rest of
+ *  children to set their childindex; could be slow.
+ */
+- (void) replaceChildrenFrom:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t;
+
+- (NSArray *) children;
+// Add t as a child to this node.  If t is null, do nothing.  If t
+//  is nil, add all children of t to this' children.
+
+- (void) addChildren:(NSArray *) theChildren;
+//- (void) removeAllChildren;
+
+// Indicates the node is a nil node but may still have children, meaning
+// the tree is a flat list.
+
+- (BOOL) isNil;
+
+/**  What is the smallest token index (indexing from 0) for this node
+ *   and its children?
+ */
+- (NSInteger) getTokenStartIndex;
+
+- (void) setTokenStartIndex:(NSInteger) index;
+
+/**  What is the largest token index (indexing from 0) for this node
+ *   and its children?
+ */
+- (NSInteger) getTokenStopIndex;
+- (void) setTokenStopIndex:(NSInteger) index;
+
+- (id<ANTLRTree>) dupNode;
+
+- (NSString *) toString;
+
+#pragma mark Copying
+- (id) copyWithZone:(NSZone *)aZone;	// the children themselves are not copied here!
+- (id) deepCopy;					// performs a deepCopyWithZone: with the default zone
+- (id) deepCopyWithZone:(NSZone *)aZone;
+
+#pragma mark Tree Parser support
+- (NSInteger)type;
+- (NSString *)text;
+// In case we don't have a token payload, what is the line for errors?
+- (NSUInteger)line;
+- (NSUInteger)charPositionInLine;
+- (void) setCharPositionInLine:(NSUInteger)pos;
+
+#pragma mark Informational
+- (NSString *) treeDescription;
+- (NSString *) description;
+
+@end
+
diff --git a/runtime/ObjC/Framework/Tree.m b/runtime/ObjC/Framework/Tree.m
new file mode 100644
index 0000000..4d9edaa
--- /dev/null
+++ b/runtime/ObjC/Framework/Tree.m
@@ -0,0 +1,149 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTree.h"
+#import "ANTLRToken.h"
+// TODO: this shouldn't be here...but needed for invalidNode
+#import "ANTLRCommonTree.h"
+
+@implementation ANTLRTree
+
+@synthesize isEmpty;
+@synthesize isEmptyNode;
+@synthesize invalidNode;
+@synthesize children;
+
+#pragma mark ANTLRTree protocol conformance
+
++ (id<ANTLRTree>) invalidNode
+{
+	static id<ANTLRTree> invalidNode = nil;
+	if (!invalidNode) {
+		invalidNode = [[ANTLRCommonTree alloc] initWithTokenType:ANTLRTokenTypeInvalid];
+	}
+	return invalidNode;
+}
+
+- (id<ANTLRTree>) init
+{
+	self = [super init];
+	if ( self != nil ) {
+		isEmptyNode = NO;
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+	[super dealloc];
+}
+
+- (id<ANTLRTree>) getChild:(NSUInteger) index
+{
+	return nil;
+}
+
+- (NSUInteger) getChildCount
+{
+	return 0;
+}
+
+- (NSArray *) getChildren
+{
+	return nil;
+}
+
+	// Add tree as a child to this node.  If tree is nil, do nothing.  If tree
+	// is an empty node, add all children of tree to our children.
+
+- (void) addChild:(id<ANTLRTree>) tree
+{
+}
+
+- (void) addChildren:(NSArray *) theChildren
+{
+}
+
+- (void) removeAllChildren
+{
+}
+
+	// Indicates the node is an empty node but may still have children, meaning
+	// the tree is a flat list.
+
+- (BOOL) isEmpty
+{
+	return isEmptyNode;
+}
+
+- (void) setIsEmpty:(BOOL)emptyFlag
+{
+	isEmptyNode = emptyFlag;
+}
+
+#pragma mark ANTLRTree abstract base class
+
+	// Return a token type; needed for tree parsing
+- (NSInteger) getType
+{
+	return 0;
+}
+
+- (NSString *) getText
+{
+	return [self description];
+}
+
+	// In case we don't have a token payload, what is the line for errors?
+- (NSInteger) getLine
+{
+	return 0;
+}
+
+- (NSInteger) getCharPositionInLine
+{
+	return 0;
+}
+
+- (NSString *) treeDescription
+{
+	return @"";
+}
+
+- (NSString *) description
+{
+	return @"";
+}
+
+- (void) _createChildrenList
+{
+	if ( children == nil )
+		children = [[NSMutableArray alloc] init];
+}
+
+@end
+
+@end
\ No newline at end of file
diff --git a/runtime/ObjC/Framework/TreeAdaptor.h b/runtime/ObjC/Framework/TreeAdaptor.h
new file mode 100644
index 0000000..e0d94e0
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeAdaptor.h
@@ -0,0 +1,157 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRToken.h"
+#import "ANTLRBaseTree.h"
+#import "ANTLRTokenStream.h"
+
+#pragma warning tree/node diction is broken.
+
+@protocol ANTLRTreeAdaptor <NSObject, NSCopying>
+
+#pragma mark Construction
+
+#pragma mark ANTLRTreeAdaptor implementation
+- (id)dupNode:(id)aNode;	// copies just the node
+- (id)dupTree:(id)aTree;	// copies the entire subtree, recursively
+
+/** Return a nil node (an empty but non-null node) that can hold
+ *  a list of element as the children.  If you want a flat tree (a list)
+ *  use "t=adaptor.nil(); t.addChild(x); t.addChild(y);"
+ */
+- (id) emptyNode;
+
+/** Return a tree node representing an error.  This node records the
+ *  tokens consumed during error recovery.  The start token indicates the
+ *  input symbol at which the error was detected.  The stop token indicates
+ *  the last symbol consumed during recovery.
+ *
+ *  You must specify the input stream so that the erroneous text can
+ *  be packaged up in the error node.  The exception could be useful
+ *  to some applications; default implementation stores ptr to it in
+ *  the CommonErrorNode.
+ *
+ *  This only makes sense during token parsing, not tree parsing.
+ *  Tree parsing should happen only when parsing and tree construction
+ *  succeed.
+ */
+- (id) errorNode:(id<ANTLRTokenStream>)anInput
+            From:(id<ANTLRToken>)aStartToken
+              To:(id<ANTLRToken>)aStopToken
+       Exception:(NSException *) e;
+
+/** Is tree considered a nil node used to make lists of child nodes? */
+- (BOOL) isNil:(id)aTree;
+
+
+- (void) addChild:(id)child toTree:(id)aTree;
+
+/** If oldRoot is a nil root, just copy or move the children to newRoot.
+ *  If not a nil root, make oldRoot a child of newRoot.
+ *
+ *    old=^(nil a b c), new=r yields ^(r a b c)
+ *    old=^(a b c), new=r yields ^(r ^(a b c))
+ *
+ *  If newRoot is a nil-rooted single child tree, use the single
+ *  child as the new root node.
+ *
+ *    old=^(nil a b c), new=^(nil r) yields ^(r a b c)
+ *    old=^(a b c), new=^(nil r) yields ^(r ^(a b c))
+ *
+ *  If oldRoot was null, it's ok, just return newRoot (even if isNil).
+ *
+ *    old=null, new=r yields r
+ *    old=null, new=^(nil r) yields ^(nil r)
+ *
+ *  Return newRoot.  Throw an exception if newRoot is not a
+ *  simple node or nil root with a single child node--it must be a root
+ *  node.  If newRoot is ^(nil x) return x as newRoot.
+ *
+ *  Be advised that it's ok for newRoot to point at oldRoot's
+ *  children; i.e., you don't have to copy the list.  We are
+ *  constructing these nodes so we should have this control for
+ *  efficiency.
+ */
+- (id) becomeRoot:(id)newRoot old:(id)oldRoot;
+
+- (id) rulePostProcessing:(id)root;
+
+#pragma mark Rewrite Rules
+
+- (NSUInteger) getUniqueID:(id)aNode;
+
+- (id) create:(id<ANTLRToken>)payload;
+- (id) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken;
+- (id) createTree:(NSInteger)tokenType FromToken:(id<ANTLRToken>)fromToken Text:(NSString *)text;
+- (id) createTree:(NSInteger)tokenType Text:(NSString *)text;
+
+#pragma mark Content
+
+- (id)dupNode:(id)aNode;
+- (id)dupTree:(id)aTree;
+
+- (NSInteger) getType:(id)aNode;
+- (void) setType:(id)aNode Type:(NSInteger)tokenType;
+
+- (NSString *) getText:(id)aNode;
+- (void) setText:(id)aNode Text:(NSString *)tokenText;
+
+//- (id<ANTLRToken>) getToken:(id)t;
+
+- (void) setTokenBoundaries:(id)aTree From:(id<ANTLRToken>)startToken To:(id<ANTLRToken>)stopToken;
+- (NSInteger) getTokenStartIndex:(id)aTree;
+- (NSInteger) getTokenStopIndex:(id)aTree;
+
+#pragma mark Navigation / Tree Parsing
+
+/** Get a child 0..n-1 node */
+- (id) getChild:(id)aNode At:(NSInteger) i;
+/** Set ith child (0..n-1) to t; t must be non-null and non-nil node */
+- (void) setChild:(id)aTree At:(NSInteger)index Child:(id)child;
+/** Remove ith child and shift children down from right. */
+- (id) deleteChild:(id)t Index:(NSInteger)index;
+
+/** How many children?  If 0, then this is a leaf node */
+- (NSInteger) getChildCount:(id) aTree;
+
+/** Who is the parent node of this node; if null, implies node is root.
+ *  If your node type doesn't handle this, it's ok but the tree rewrites
+ *  in tree parsers need this functionality.
+ */
+- (id)getParent:(id)t;
+- (void) setParent:(id)t With:(id)parent;
+
+/** What index is this node in the child list? Range: 0..n-1
+ *  If your node type doesn't handle this, it's ok but the tree rewrites
+ *  in tree parsers need this functionality.
+ */
+- (NSInteger) getChildIndex:(id)t;
+- (void) setChildIndex:(id)t With:(NSInteger)index;
+
+- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id)t;
+
+@end
+
diff --git a/runtime/ObjC/Framework/TreeAdaptor.m b/runtime/ObjC/Framework/TreeAdaptor.m
new file mode 100644
index 0000000..d852e02
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeAdaptor.m
@@ -0,0 +1,238 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreeAdaptor.h"
+#import "ANTLRTreeException.h"
+#import "ANTLRBaseTree.h"
+
+@implementation ANTLRTreeAdaptor
+
+
++ (id) newEmptyTree
+{
+	return [ANTLRTreeAdaptor newTreeWithToken:nil];
+}
+
++ (id) newAdaptor
+{
+    return [[ANTLRTreeAdaptor alloc] init];
+}
+
+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
+- (id) initWithPayload:(id<ANTLRToken>)payload
+{
+    self = [super init];
+    return self;
+}
+
+#pragma mark Rewrite Rules
+
+/** Create a tree node from Token object; for CommonTree type trees,
+ *  then the token just becomes the payload.  This is the most
+ *  common create call.
+ *
+ *  Override if you want another kind of node to be built.
+ */
+- (id) create:(id<ANTLRToken>) payload
+{
+    return nil;
+}
+
+/** Create a new node derived from a token, with a new token type.
+ *  This is invoked from an imaginary node ref on right side of a
+ *  rewrite rule as IMAG[$tokenLabel].
+ *
+ *  This should invoke createToken(Token).
+ */
+- (id) createTree:(NSInteger)tokenType fromToken:(id<ANTLRToken>)fromToken
+{
+	id<ANTLRToken> newToken = [self createToken:fromToken];
+	[newToken setType:tokenType];
+
+	id newTree = [self create:newToken];
+	[newToken release];
+	return newTree;
+}
+
+/** Create a new node derived from a token, with a new token type.
+ *  This is invoked from an imaginary node ref on right side of a
+ *  rewrite rule as IMAG[$tokenLabel].
+ *
+ *  This should invoke createToken(Token).
+ */
+- (id) createTree:(NSInteger)tokenType fromToken:(id<ANTLRToken>)fromToken text:(NSString *)tokenText
+{
+	id<ANTLRToken> newToken = [self createToken:fromToken];
+	[newToken setText:tokenText];
+
+	id newTree = [self create:newToken];
+	[newToken release];
+	return newTree;
+}
+
+/** Create a new node derived from a token, with a new token type.
+ *  This is invoked from an imaginary node ref on right side of a
+ *  rewrite rule as IMAG["IMAG"].
+ *
+ *  This should invoke createToken(int,String).
+ */
+- (id) createTree:(NSInteger)tokenType text:(NSString *)tokenText
+{
+	id<ANTLRToken> newToken = [self createToken:tokenType text:tokenText];
+
+	id newTree = [self create:newToken];
+	[newToken release];
+	return newTree;
+}
+
+- (id) copyNode:(id)aNode
+{
+	return [aNode copyWithZone:nil];	// not -copy: to silence warnings
+}
+
+- (id) copyTree:(id)aTree
+{
+	return [aTree deepCopy];
+}
+
+
+- (void) addChild:(id)child toTree:(id)aTree
+{
+	[aTree addChild:child];
+}
+
+- (id) makeNode:(id)newRoot parentOf:(id)oldRoot
+{
+	id newRootNode = newRoot;
+
+	if (oldRoot == nil)
+		return newRootNode;
+    // handles ^(nil real-node) case
+	if ([newRootNode isNil]) {
+		if ([newRootNode getChildCount] > 1) {
+#warning TODO: Find a way to the current input stream here!
+			@throw [ANTLRTreeException exceptionWithOldRoot:oldRoot newRoot:newRootNode stream:nil];
+		}
+#warning TODO: double check memory management with respect to code generation
+		// remove the empty node, placing its sole child in its role.
+		id tmpRootNode = [[newRootNode childAtIndex:0] retain];
+		[newRootNode release];
+		newRootNode = tmpRootNode;
+	}
+	// the handling of an empty node at the root of oldRoot happens in addChild:
+	[newRootNode addChild:oldRoot];
+    // this release relies on the fact that the ANTLR code generator always assigns the return value of this method
+    // to the variable originally holding oldRoot. If we don't release we leak the reference.
+    // FIXME: this is totally non-obvious. maybe do it in calling code by comparing pointers and conditionally releasing
+    // the old object
+    [oldRoot release];
+
+    // what happens to newRootNode's retain count? Should we be autoreleasing this one? Probably.
+	return [newRootNode retain];
+}
+
+
+- (id) postProcessTree:(id)aTree
+{
+	id processedNode = aTree;
+	if (aTree != nil && [aTree isNil] != NO && [aTree getChildCount] == 1) {
+		processedNode = [aTree childAtIndex:0];
+	}
+	return processedNode;
+}
+
+
+- (NSUInteger) uniqueIdForTree:(id)aNode
+{
+	// TODO: is hash appropriate here?
+	return [aNode hash];
+}
+
+
+#pragma mark Content
+
+- (NSInteger) tokenTypeForNode:(id)aNode
+{
+	return [aNode getType];
+}
+
+- (void) setTokenType:(NSInteger)tokenType forNode:(id)aNode
+{
+	// currently unimplemented
+}
+
+
+- (NSString *) textForNode:(id)aNode
+{
+	return [aNode getText];
+}
+
+- (void) setText:(NSString *)tokenText forNode:(id)aNode
+{
+	// currently unimplemented
+}
+
+
+#pragma mark Navigation / Tree Parsing
+
+- (id) childForNode:(id) aNode atIndex:(NSInteger) i
+{
+	// currently unimplemented
+	return nil;
+}
+
+- (NSInteger) childCountForTree:(id) aTree
+{
+	// currently unimplemented
+	return 0;
+}
+
+#pragma mark Subclass Responsibilties
+
+- (void) setBoundariesForTree:(id)aTree fromToken:(id<ANTLRToken>)startToken toToken:(id<ANTLRToken>)stopToken
+{
+	// subclass responsibility
+}
+
+- (NSInteger) tokenStartIndexForTree:(id)aTree
+{
+	// subclass responsibility
+	return 0;
+}
+
+- (NSInteger) tokenStopIndexForTree:(id)aTree
+{
+	// subclass responsibility
+	return 0;
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/TreeException.h b/runtime/ObjC/Framework/TreeException.h
new file mode 100644
index 0000000..28330af
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeException.h
@@ -0,0 +1,42 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTree.h"
+#import "ANTLRRecognitionException.h"
+
+@interface ANTLRTreeException : ANTLRRecognitionException {
+	id<ANTLRBaseTree> oldRoot;
+	id<ANTLRBaseTree> newRoot;
+}
+
++ (id) newException:(id<ANTLRBaseTree>)theOldRoot newRoot:(id<ANTLRBaseTree>)theNewRoot stream:(id<ANTLRIntStream>)aStream;
+- (id) initWithOldRoot:(id<ANTLRBaseTree>)theOldRoot newRoot:(id<ANTLRBaseTree>)theNewRoot stream:(id<ANTLRIntStream>)aStream;
+
+- (void) setOldRoot:(id<ANTLRBaseTree>)aTree;
+- (void) setNewRoot:(id<ANTLRBaseTree>)aTree;
+
+@end
diff --git a/runtime/ObjC/Framework/TreeException.m b/runtime/ObjC/Framework/TreeException.m
new file mode 100644
index 0000000..b61d29c
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeException.m
@@ -0,0 +1,85 @@
+//
+//  ANTLRTreeException.m
+//  ANTLR
+//
+//  Created by Kay Röpke on 24.10.2006.
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRTreeException.h"
+
+
+@implementation ANTLRTreeException
+
++ (id) newException:(id<ANTLRBaseTree>)theOldRoot newRoot:(id<ANTLRBaseTree>)theNewRoot stream:(id<ANTLRIntStream>)aStream;
+{
+	return [[ANTLRTreeException alloc] initWithOldRoot:theOldRoot newRoot:theNewRoot stream:aStream];
+}
+
+- (id) initWithOldRoot:(id<ANTLRBaseTree>)theOldRoot newRoot:(id<ANTLRBaseTree>)theNewRoot stream:(id<ANTLRIntStream>)aStream;
+{
+	if ((self = [super initWithStream:aStream reason:@"The new root has more than one child. Cannot make it the root node."]) != nil ) {
+		[self setOldRoot:theOldRoot];
+		[self setNewRoot:theNewRoot];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreeException" );
+#endif
+	[self setOldRoot:nil];
+	[self setNewRoot:nil];
+	[super dealloc];
+}
+
+- (void) setNewRoot:(id<ANTLRBaseTree>)aTree
+{
+	if (newRoot != aTree) {
+		[aTree retain];
+		if ( newRoot ) [newRoot release];
+		newRoot = aTree;
+	}
+}
+
+- (void) setOldRoot:(id<ANTLRBaseTree>)aTree
+{
+	if (oldRoot != aTree) {
+		[aTree retain];
+		if ( oldRoot ) [oldRoot release];
+		oldRoot = aTree;
+	}
+}
+
+- (NSString *) description
+{
+	 return [NSMutableString stringWithFormat:@"%@ old root: <%@> new root: <%@>", [super description], [oldRoot treeDescription], [newRoot treeDescription]];
+}
+
+@end
diff --git a/runtime/ObjC/Framework/TreeIterator.h b/runtime/ObjC/Framework/TreeIterator.h
new file mode 100644
index 0000000..b5cf8c3
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeIterator.h
@@ -0,0 +1,72 @@
+//
+//  ANTLRTreeIterator.h
+//  ANTLR
+//
+//  Created by Ian Michell on 26/04/2010.
+// [The "BSD licence"]
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRCommonTreeAdaptor.h"
+#import "ANTLRFastQueue.h"
+#import "ANTLRTreeAdaptor.h"
+#import "ANTLRTree.h"
+
+@interface ANTLRTreeIterator : NSObject
+{
+	BOOL firstTime;
+	__strong id<ANTLRTreeAdaptor> adaptor;
+	__strong id<ANTLRBaseTree> root;
+	__strong id<ANTLRBaseTree> tree;
+
+	__strong ANTLRFastQueue *nodes;
+	__strong id<ANTLRBaseTree> up;
+	__strong id<ANTLRBaseTree> down;
+	__strong id<ANTLRBaseTree> eof;
+}
+
+@property BOOL firstTime;
+@property(retain) id<ANTLRTreeAdaptor> adaptor;
+@property(retain) id<ANTLRBaseTree> root;
+@property(retain) id<ANTLRBaseTree> tree;
+@property(retain) ANTLRFastQueue *nodes;
+@property(retain, readwrite) id<ANTLRBaseTree> up;
+@property(retain, readwrite) id<ANTLRBaseTree> down;
+@property(retain, readwrite) id<ANTLRBaseTree> eof;
+
++ newANTRLTreeIterator;
++ (ANTLRTreeIterator *) newANTRLTreeIteratorWithAdaptor:(ANTLRCommonTreeAdaptor *)adaptor
+                                                andTree:(id<ANTLRBaseTree>)tree;
+- (id) init;
+- (id) initWithTree:(id<ANTLRBaseTree>) t;
+- (id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>) a andTree:(id<ANTLRBaseTree>) t;
+
+- (void) reset;
+- (BOOL) hasNext;
+- (id) nextObject;
+- (NSArray *) allObjects;
+
+@end
diff --git a/runtime/ObjC/Framework/TreeIterator.m b/runtime/ObjC/Framework/TreeIterator.m
new file mode 100644
index 0000000..b760f88
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeIterator.m
@@ -0,0 +1,202 @@
+//
+//  ANTLRTreeIterator.m
+//  ANTLR
+//
+//  Created by Ian Michell on 26/04/2010.
+// Copyright (c) 2010 Ian Michell 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRTreeIterator.h"
+#import "ANTLRCommonTreeAdaptor.h"
+
+@implementation ANTLRTreeIterator
+
++ (ANTLRTreeIterator *) newANTRLTreeIterator
+{
+    return [[ANTLRTreeIterator alloc] init];
+}
+
++ (ANTLRTreeIterator *) newANTRLTreeIteratorWithAdaptor:(ANTLRCommonTreeAdaptor *)adaptor
+                                                andTree:(id<ANTLRBaseTree>)tree
+{
+    return [[ANTLRTreeIterator alloc] initWithTreeAdaptor:adaptor andTree:tree];
+}
+
+- (id) init
+{
+    self = [super init];
+    if ( self != nil ) {
+        firstTime = YES;
+        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+        tree = eof;
+        root = eof;
+    }
+    return self;
+}
+
+-(id) initWithTree:(id<ANTLRBaseTree>) t
+{
+    self = [super init];
+    if ( self != nil ) {
+        firstTime = YES;
+        adaptor = [[ANTLRCommonTreeAdaptor newTreeAdaptor] retain];
+        tree = [t retain];
+        root = t;
+        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+    }
+    return self;
+}
+
+-(id) initWithTreeAdaptor:(id<ANTLRTreeAdaptor>)a andTree:(id<ANTLRBaseTree>)t
+{
+    self = [super init];
+    if ( self != nil ) {
+        firstTime = YES;
+        adaptor = [a retain];
+        tree = [t retain];
+        root = t;
+        nodes = [[ANTLRFastQueue newANTLRFastQueue] retain];
+        down = [[adaptor createTree:ANTLRTokenTypeDOWN Text:@"DOWN"] retain];
+        up = [[adaptor createTree:ANTLRTokenTypeUP Text:@"UP"] retain];
+        eof = [[adaptor createTree:ANTLRTokenTypeEOF Text:@"EOF"] retain];
+    }
+    return self;
+}
+
+- (void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreeIterator" );
+#endif
+    if ( adaptor ) [adaptor release];
+    if ( nodes ) [nodes release];
+    if ( tree && tree != eof ) [tree release];
+    if ( root && root != eof && root != tree ) [root release];
+    if ( down ) [down release];
+    if ( up ) [up release];
+    if ( eof ) [eof release];
+    [super dealloc];
+}
+
+- (void)reset
+{
+    firstTime = YES;
+    tree = root;
+    [nodes clear];
+}
+
+-(BOOL) hasNext
+{
+    if ( firstTime ) {
+        return root != nil;
+    }
+    if ( nodes && [nodes size] > 0) {
+        return YES;
+    }
+    if ( tree == nil ) {
+        return NO;
+    }
+    if ( [adaptor getChildCount:tree] > 0 ) {
+        return YES;
+    }
+    return [adaptor getParent:tree] != nil;
+}
+
+-(id) nextObject
+{
+    // is this the first time we are using this method?
+    if ( firstTime ) {
+        firstTime = NO;
+        if ( [adaptor getChildCount:tree] == 0 ) {
+            [nodes addObject:eof];
+            return tree;
+        }
+        return tree;
+    }
+    // do we have any objects queued up?
+    if ( nodes && [nodes size] > 0 ) {
+        return [nodes remove];
+    }
+    // no nodes left?
+    if ( tree == nil ) {
+        return eof;
+    }
+    if ( [adaptor getChildCount:tree] > 0 ) {
+        tree = [adaptor getChild:tree At:0];
+        [nodes addObject:tree]; // real node is next after down
+        return self.down;
+    }
+    // if no children, look for next sibling of ancestor
+    id<ANTLRBaseTree> parent = [adaptor getParent:tree];
+    while (parent != nil && ([adaptor getChildIndex:tree] + 1) >= [adaptor getChildCount:parent]) {
+        [nodes addObject:up];
+        tree = parent;
+        parent = [adaptor getParent:tree];
+    }
+    if ( parent == nil ) {
+        tree = nil;
+        [nodes addObject:self.eof];
+        return [nodes remove];
+    }
+    // must have found a node with an unvisited sibling
+    // move to it and return it
+    NSInteger nextSiblingIndex = [adaptor getChildIndex:tree] + 1;
+    tree = [adaptor getChild:parent At:nextSiblingIndex];
+    [nodes addObject:tree];
+    return [nodes remove];
+}
+
+-(NSArray *) allObjects
+{
+    AMutableArray *array = [AMutableArray arrayWithCapacity:10];
+    while ( [self hasNext] ) {
+        [array addObject:[self nextObject]];
+    }
+    return array;
+}
+
+- (void)remove
+{
+    @throw [ANTLRRuntimeException newException:@"ANTLRUnsupportedOperationException"];
+}
+
+@synthesize firstTime;
+@synthesize adaptor;
+@synthesize root;
+@synthesize tree;
+@synthesize nodes;
+
+@synthesize up;
+@synthesize down;
+@synthesize eof;
+
+@end
diff --git a/runtime/ObjC/Framework/TreeNodeStream.h b/runtime/ObjC/Framework/TreeNodeStream.h
new file mode 100644
index 0000000..8d10aaa
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeNodeStream.h
@@ -0,0 +1,52 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRIntStream.h"
+#import "ANTLRCharStream.h"
+#import "ANTLRTokenStream.h"
+#import "ANTLRCommonTree.h"
+#import "ANTLRCommonTreeAdaptor.h"
+
+@protocol ANTLRTreeNodeStream < ANTLRIntStream >
+
+- (id) initWithTree:(ANTLRCommonTree *)theTree;
+
+- (id) getTree:(NSInteger) idx;
+- (id) LT:(NSInteger)k;
+- (id) getTreeSource;
+- (id<ANTLRTokenStream>) getTokenStream;
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
+- (void) setUniqueNavigationNodes:(BOOL)flag;
+- (void) reset;
+
+- (NSString *) toStringFromNode:(id)startNode ToNode:(id)stopNode;
+
+- (void) replaceChildren:(id)parent From:(NSInteger)startChildIndex To:(NSInteger)stopChildIndex With:(id) t;
+
+
+@end
diff --git a/runtime/ObjC/Framework/TreeParser.h b/runtime/ObjC/Framework/TreeParser.h
new file mode 100644
index 0000000..9d2d5c6
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeParser.h
@@ -0,0 +1,87 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRBaseRecognizer.h"
+#import "ANTLRTreeNodeStream.h"
+#import "ANTLRCommonTreeAdaptor.h"
+#import "ANTLRMismatchedTreeNodeException.h"
+
+@interface ANTLRTreeParser : ANTLRBaseRecognizer {
+	id<ANTLRTreeNodeStream> input;
+}
+
+@property (retain, getter=input, setter=setInput:) id<ANTLRTreeNodeStream> input;
+
++ (id) newANTLRTreeParser:(id<ANTLRTreeNodeStream>)anInput;
++ (id) newANTLRTreeParser:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)state;
+
+- (id) initWithStream:(id<ANTLRTreeNodeStream>)theInput;
+- (id) initWithStream:(id<ANTLRTreeNodeStream>)theInput
+                State:(ANTLRRecognizerSharedState *)state;
+
+
+- (id<ANTLRTreeNodeStream>)input;
+- (void) setInput:(id<ANTLRTreeNodeStream>)anInput;
+
+- (void) setTreeNodeStream:(id<ANTLRTreeNodeStream>) anInput;
+- (id<ANTLRTreeNodeStream>) getTreeNodeStream;
+
+- (NSString *)getSourceName;
+
+- (id) getCurrentInputSymbol:(id<ANTLRIntStream>) anInput;
+
+- (id) getMissingSymbol:(id<ANTLRIntStream>)input
+              Exception:(ANTLRRecognitionException *) e
+          ExpectedToken:(NSInteger) expectedTokenType
+                 BitSet:(ANTLRBitSet *)follow;
+
+/** Match '.' in tree parser has special meaning.  Skip node or
+ *  entire tree if node has children.  If children, scan until
+ *  corresponding UP node.
+ */
+- (void) matchAny:(id<ANTLRIntStream>)ignore;
+
+/** We have DOWN/UP nodes in the stream that have no line info; override.
+ *  plus we want to alter the exception type.  Don't try to recover
+ *  from tree parser errors inline...
+ */
+- (id) recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput
+                             Type:(NSInteger)ttype
+                           Follow:(ANTLRBitSet *)follow;
+
+/** Prefix error message with the grammar name because message is
+ *  always intended for the programmer because the parser built
+ *  the input tree not the user.
+ */
+- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e;
+
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e TokenNames:(AMutableArray *) tokenNames;
+
+- (void) traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex;
+- (void) traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex;
+
+@end
diff --git a/runtime/ObjC/Framework/TreeParser.m b/runtime/ObjC/Framework/TreeParser.m
new file mode 100644
index 0000000..599ec7c
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeParser.m
@@ -0,0 +1,192 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreeParser.h"
+
+@implementation ANTLRTreeParser
+
+@synthesize input;
+
++ (id) newANTLRTreeParser:(id<ANTLRTreeNodeStream>)anInput
+{
+    return [[ANTLRTreeParser alloc] initWithStream:anInput];
+}
+
++ (id) newANTLRTreeParser:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)theState
+{
+    return [[ANTLRTreeParser alloc] initWithStream:anInput State:theState];
+}
+
+- (id) initWithStream:(id<ANTLRTreeNodeStream>)theInput
+{
+	if ((self = [super init]) != nil) {
+		[self setInput:theInput];
+	}
+	return self;
+}
+
+- (id) initWithStream:(id<ANTLRTreeNodeStream>)theInput State:(ANTLRRecognizerSharedState *)theState
+{
+	if ((self = [super init]) != nil) {
+		[self setInput:theInput];
+        state = theState;
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreeParser" );
+#endif
+	if ( input ) [input release];
+	[super dealloc];
+}
+
+- (void) reset
+{
+    [super reset]; // reset all recognizer state variables
+    if ( input != nil ) {
+        [input seek:0]; // rewind the input
+    }
+}
+
+- (void) mismatch:(id<ANTLRIntStream>)aStream tokenType:(ANTLRTokenType)aTType follow:(ANTLRBitSet *)aBitset
+{
+	ANTLRMismatchedTreeNodeException *mte = [ANTLRMismatchedTreeNodeException newException:aTType Stream:aStream];
+    [mte setNode:[((id<ANTLRTreeNodeStream>)aStream) LT:1]];
+	[self recoverFromMismatchedToken:aStream Type:aTType Follow:aBitset];
+}
+
+- (void) setTreeNodeStream:(id<ANTLRTreeNodeStream>) anInput
+{
+    input = anInput;
+}
+
+- (id<ANTLRTreeNodeStream>) getTreeNodeStream
+{
+    return input;
+}
+
+- (NSString *)getSourceName
+{
+    return [input getSourceName];
+}
+
+- (id) getCurrentInputSymbol:(id<ANTLRIntStream>) anInput
+{
+    return [(id<ANTLRTreeNodeStream>)anInput LT:1];
+}
+
+- (id) getMissingSymbol:(id<ANTLRIntStream>)anInput
+              Exception:(ANTLRRecognitionException *)e
+          ExpectedToken:(NSInteger)expectedTokenType
+                 BitSet:(ANTLRBitSet *)follow
+{
+    NSString *tokenText =[NSString stringWithFormat:@"<missing %@ %d>", [self getTokenNames], expectedTokenType];
+    //id<ANTLRTreeAdaptor> anAdaptor = (id<ANTLRTreeAdaptor>)[((id<ANTLRTreeNodeStream>)e.input) getTreeAdaptor];
+    //return [anAdaptor createToken:expectedTokenType Text:tokenText];
+    return [ANTLRCommonToken newToken:expectedTokenType Text:tokenText];
+}
+
+/** Match '.' in tree parser has special meaning.  Skip node or
+ *  entire tree if node has children.  If children, scan until
+ *  corresponding UP node.
+ */
+- (void) matchAny:(id<ANTLRIntStream>)ignore
+{ // ignore stream, copy of input
+    state.errorRecovery = NO;
+    state.failed = NO;
+    id look = [input LT:1];
+    if ( [((ANTLRCommonTreeAdaptor *)[input getTreeAdaptor]) getChildCount:look] == 0) {
+        [input consume]; // not subtree, consume 1 node and return
+        return;
+    }
+    // current node is a subtree, skip to corresponding UP.
+    // must count nesting level to get right UP
+    int level=0;
+    int tokenType = [((id<ANTLRTreeAdaptor>)[input getTreeAdaptor]) getType:look];
+    while ( tokenType != ANTLRTokenTypeEOF && !( tokenType == ANTLRTokenTypeUP && level == 0) ) {
+        [input consume];
+        look = [input LT:1];
+        tokenType = [((id<ANTLRTreeAdaptor>)[input getTreeAdaptor]) getType:look];
+        if ( tokenType == ANTLRTokenTypeDOWN ) {
+            level++;
+        }
+        else if ( tokenType == ANTLRTokenTypeUP ) {
+            level--;
+        }
+    }
+    [input consume]; // consume UP
+}
+
+/** We have DOWN/UP nodes in the stream that have no line info; override.
+ *  plus we want to alter the exception type.  Don't try to recover
+ *  from tree parser errors inline...
+ */
+- (id) recoverFromMismatchedToken:(id<ANTLRIntStream>)anInput Type:(NSInteger)ttype Follow:(ANTLRBitSet *)follow
+{
+    @throw [ANTLRMismatchedTreeNodeException newException:ttype Stream:anInput];
+}
+
+/** Prefix error message with the grammar name because message is
+ *  always intended for the programmer because the parser built
+ *  the input tree not the user.
+ */
+- (NSString *)getErrorHeader:(ANTLRRecognitionException *)e
+{
+     return [NSString stringWithFormat:@"%@: node after line %@:%@",
+            [self getGrammarFileName], e.line, e.charPositionInLine];
+}
+
+/** Tree parsers parse nodes they usually have a token object as
+ *  payload. Set the exception token and do the default behavior.
+ */
+- (NSString *)getErrorMessage:(ANTLRRecognitionException *)e  TokenNames:(AMutableArray *) theTokNams
+{
+    if ( [self isKindOfClass:[ANTLRTreeParser class]] ) {
+        ANTLRCommonTreeAdaptor *adaptor = (ANTLRCommonTreeAdaptor *)[((id<ANTLRTreeNodeStream>)e.input) getTreeAdaptor];
+        e.token = [adaptor getToken:((id<ANTLRBaseTree>)e.node)];
+        if ( e.token == nil ) { // could be an UP/DOWN node
+            e.token = [ANTLRCommonToken newToken:[adaptor getType:e.node]
+                                                        Text:[adaptor getText:e.node]];
+        }
+    }
+    return [super getErrorMessage:e TokenNames:theTokNams];
+}
+
+- (void) traceIn:(NSString *)ruleName Index:(NSInteger)ruleIndex
+{
+    [super traceIn:ruleName Index:ruleIndex Object:[input LT:1]];
+}
+
+- (void) traceOut:(NSString *)ruleName Index:(NSInteger)ruleIndex
+{
+    [super traceOut:ruleName Index:ruleIndex  Object:[input LT:1]];
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/TreePatternLexer.h b/runtime/ObjC/Framework/TreePatternLexer.h
new file mode 100644
index 0000000..430bc83
--- /dev/null
+++ b/runtime/ObjC/Framework/TreePatternLexer.h
@@ -0,0 +1,89 @@
+//
+//  ANTLRTreePatternLexer.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+
+typedef enum {
+	ANTLRLexerTokenTypeEOF = -1,
+	ANTLRLexerTokenTypeInvalid,
+	ANTLRLexerTokenTypeBEGIN,
+	ANTLRLexerTokenTypeEND,
+	ANTLRLexerTokenTypeID,
+	ANTLRLexerTokenTypeARG,
+	ANTLRLexerTokenTypePERCENT,
+	ANTLRLexerTokenTypeCOLON,
+	ANTLRLexerTokenTypeDOT,
+} ANTLRLexerTokenType;
+
+
+@interface ANTLRTreePatternLexer : NSObject {
+
+/** The tree pattern to lex like "(A B C)" */
+NSString *pattern;
+
+/** Index into input string */
+NSInteger p;
+
+/** Current char */
+NSInteger c;
+
+/** How long is the pattern in char? */
+NSInteger n;
+
+/** Set when token type is ID or ARG (name mimics Java's StreamTokenizer) */
+NSMutableData *sval;
+__strong char *data;
+
+BOOL error;
+
+}
+
+@property (retain) NSString *pattern;
+@property (assign) NSInteger p;
+@property (assign) NSInteger c;
+@property (assign) NSInteger n;
+@property (retain, getter=getSval, setter=setSval:) NSMutableData *sval;
+@property (assign) char *data;
+@property (assign) BOOL error;
+
++ (ANTLRTreePatternLexer *)newANTLRTreePatternLexer:(NSString *)aPattern;
+- (id) init;
+- (id) initWithPattern:(NSString *)aPattern;
+
+- (void) dealloc;
+- (NSInteger) nextToken;
+- (void) consume;
+- (NSString *)toString;
+
+- (NSMutableData *)getSval;
+- (void) setSval:(NSMutableData *)aSval;
+
+@end
diff --git a/runtime/ObjC/Framework/TreePatternLexer.m b/runtime/ObjC/Framework/TreePatternLexer.m
new file mode 100644
index 0000000..cdf969f
--- /dev/null
+++ b/runtime/ObjC/Framework/TreePatternLexer.m
@@ -0,0 +1,191 @@
+//
+//  ANTLRTreePatternLexer.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreePatternLexer.h"
+
+@implementation ANTLRTreePatternLexer
+
+@synthesize pattern;
+@synthesize p;
+@synthesize c;
+@synthesize n;
+@synthesize sval;
+@synthesize data;
+@synthesize error;
+
++ (ANTLRTreePatternLexer *)newANTLRTreePatternLexer:(NSString *)aPattern
+{
+    return [[ANTLRTreePatternLexer alloc] initWithPattern:aPattern];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil ) {
+        p = -1;
+        n = 0;
+        error = NO;
+        sval = [[NSMutableData dataWithLength:1000] retain];
+        data = [sval mutableBytes];
+        pattern = @"";
+        n = [pattern length];
+        if ( pattern ) [pattern retain];
+        [self consume];
+    }
+    return self;
+}
+
+- (id) initWithPattern:(NSString *)aPattern
+{
+    if ((self = [super init]) != nil ) {
+        p = -1;
+        n = 0;
+        error = NO;
+        sval = [[NSMutableData dataWithLength:1000] retain];
+        data = [sval mutableBytes];
+        pattern = [aPattern retain];
+        n = [pattern length];
+        [self consume];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreePatternLexer" );
+#endif
+	if ( pattern ) [pattern release];
+	if ( sval ) [sval release];
+	[super dealloc];
+}
+
+- (NSInteger) nextToken
+{
+    n = 0; // reset, but reuse buffer
+    while ( c != ANTLRLexerTokenTypeEOF ) {
+        if ( c==' ' || c=='\n' || c=='\r' || c=='\t' ) {
+            [self consume];
+            continue;
+        }
+        if ( (c>='a' && c<='z') || (c>='A' && c<='Z') || c=='_' ) {
+            data[n++] = (char)c;
+            [self consume];
+            while ( (c>='a' && c<='z') || (c>='A' && c<='Z') ||
+                   (c>='0' && c<='9') || c=='_' )
+            {
+                data[n++] = (char)c;
+                [self consume];
+            }
+            return ANTLRLexerTokenTypeID;
+        }
+        if ( c == '(' ) {
+            [self consume];
+            return ANTLRLexerTokenTypeBEGIN;
+        }
+        if ( c==')' ) {
+            [self consume];
+            return ANTLRLexerTokenTypeEND;
+        }
+        if ( c=='%' ) {
+            [self consume];
+            return ANTLRLexerTokenTypePERCENT;
+        }
+        if ( c==':' ) {
+            [self consume];
+            return ANTLRLexerTokenTypeCOLON;
+        }
+        if ( c=='.' ) {
+            [self consume];
+            return ANTLRLexerTokenTypeDOT;
+        }
+        if ( c=='[' ) { // grab [x] as a string, returning x
+            [self consume];
+            while ( c!=']' ) {
+                if ( c=='\\' ) {
+                    [self consume];
+                    if ( c!=']' ) {
+                        data[n++] = (char)'\\';
+                    }
+                    data[n++] = (char)c;
+                }
+                else {
+                    data[n++] = (char)c;
+                }
+                [self consume];
+            }
+            [self consume];
+            return ANTLRLexerTokenTypeARG;
+        }
+        [self consume];
+        error = true;
+        return ANTLRLexerTokenTypeEOF;
+    }
+    return ANTLRLexerTokenTypeEOF;
+}
+
+- (void) consume
+{
+    p++;
+    if ( p >= n ) {
+        c = ANTLRLexerTokenTypeEOF;
+    }
+    else {
+        c = [pattern characterAtIndex:p];
+    }
+}
+
+- (NSString *)toString
+{
+    char buf[100];
+
+    NSInteger idx = 0;
+    for( NSInteger i = p; i < n; i++ ){
+        buf[idx++] = data[i];
+    }
+    buf[idx] = '\0';
+    return [NSString stringWithFormat:@"%s", buf];
+}
+
+- (NSMutableData *)getSval
+{
+    return sval;
+}
+
+- (void)setSval:(NSMutableData *)aSval
+{
+    if ( sval != aSval ) {
+        if ( sval ) [sval release];
+        [aSval retain];
+    }
+    sval = aSval;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/TreePatternParser.h b/runtime/ObjC/Framework/TreePatternParser.h
new file mode 100644
index 0000000..2051b5e
--- /dev/null
+++ b/runtime/ObjC/Framework/TreePatternParser.h
@@ -0,0 +1,63 @@
+//
+//  ANTLRTreePatternParser.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTreePatternLexer.h"
+#import "ANTLRTreeWizard.h"
+#import "ANTLRTreeAdaptor.h"
+
+@interface ANTLRTreePatternParser : NSObject {
+
+ANTLRTreePatternLexer *tokenizer;
+NSInteger ttype;
+ANTLRTreeWizard *wizard;
+id<ANTLRTreeAdaptor> adaptor;
+
+}
+
++ (ANTLRTreePatternParser *)newANTLRTreePatternParser:(ANTLRTreePatternLexer *)aTokenizer
+                                               Wizard:(ANTLRTreeWizard *)aWizard
+                                              Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
+- (id) init;
+- (id) initWithTokenizer:(ANTLRTreePatternLexer *)tokenizer
+                  Wizard:(ANTLRTreeWizard *)aWizard
+                 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
+
+- (void) dealloc;
+- (id<ANTLRBaseTree>) pattern;
+- (id<ANTLRBaseTree>) parseTree;
+- (id<ANTLRBaseTree>) parseNode;
+
+@property (retain) ANTLRTreePatternLexer *tokenizer;
+@property NSInteger ttype;
+@property (retain) ANTLRTreeWizard *wizard;
+@property (retain) id<ANTLRTreeAdaptor> adaptor;
+@end
diff --git a/runtime/ObjC/Framework/TreePatternParser.m b/runtime/ObjC/Framework/TreePatternParser.m
new file mode 100644
index 0000000..c95d995
--- /dev/null
+++ b/runtime/ObjC/Framework/TreePatternParser.m
@@ -0,0 +1,197 @@
+//
+//  ANTLRTreePatternParser.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreePatternParser.h"
+#import "ANTLRTreePatternLexer.h"
+
+@implementation ANTLRTreePatternParser
+
++ (ANTLRTreePatternParser *)newANTLRTreePatternParser:(ANTLRTreePatternLexer *)aTokenizer
+                                               Wizard:(ANTLRTreeWizard *)aWizard
+                                              Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    return [[ANTLRTreePatternParser alloc] initWithTokenizer:aTokenizer Wizard:aWizard Adaptor:anAdaptor];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil) {
+        //tokenizer = aTokenizer;
+        //wizard = aWizard;
+        //adaptor = anAdaptor;
+        //ttype = [tokenizer nextToken]; // kickstart
+    }
+    return self;
+}
+
+- (id) initWithTokenizer:(ANTLRTreePatternLexer *)aTokenizer
+                  Wizard:(ANTLRTreeWizard *)aWizard
+                 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    if ((self = [super init]) != nil) {
+        adaptor = anAdaptor;
+        if ( adaptor ) [adaptor retain];
+        tokenizer = aTokenizer;
+        if ( tokenizer ) [tokenizer retain];
+        wizard = aWizard;
+        if ( wizard ) [wizard retain];
+        ttype = [aTokenizer nextToken]; // kickstart
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreePatternParser" );
+#endif
+	if ( adaptor ) [adaptor release];
+	if ( tokenizer ) [tokenizer release];
+	if ( wizard ) [wizard release];
+	[super dealloc];
+}
+
+- (id<ANTLRBaseTree>)pattern
+{
+    if ( ttype==ANTLRLexerTokenTypeBEGIN ) {
+        return [self parseTree];
+    }
+    else if ( ttype==ANTLRLexerTokenTypeID ) {
+        id<ANTLRBaseTree> node = [self parseNode];
+        if ( ttype==ANTLRLexerTokenTypeEOF ) {
+            return node;
+        }
+        return nil; // extra junk on end
+    }
+    return nil;
+}
+
+- (id<ANTLRBaseTree>) parseTree
+{
+    if ( ttype != ANTLRLexerTokenTypeBEGIN ) {
+        @throw [ANTLRRuntimeException newException:@"no BEGIN"];
+    }
+    ttype = [tokenizer nextToken];
+    id<ANTLRBaseTree> root = [self parseNode];
+    if ( root==nil ) {
+        return nil;
+    }
+    while ( ttype==ANTLRLexerTokenTypeBEGIN  ||
+           ttype==ANTLRLexerTokenTypeID      ||
+           ttype==ANTLRLexerTokenTypePERCENT ||
+           ttype==ANTLRLexerTokenTypeDOT )
+    {
+        if ( ttype==ANTLRLexerTokenTypeBEGIN ) {
+            id<ANTLRBaseTree> subtree = [self parseTree];
+            [adaptor addChild:subtree toTree:root];
+        }
+        else {
+            id<ANTLRBaseTree> child = [self parseNode];
+            if ( child == nil ) {
+                return nil;
+            }
+            [adaptor addChild:child toTree:root];
+        }
+    }
+    if ( ttype != ANTLRLexerTokenTypeEND ) {
+        @throw [ANTLRRuntimeException newException:@"no END"];
+    }
+    ttype = [tokenizer nextToken];
+    return root;
+}
+
+- (id<ANTLRBaseTree>) parseNode
+{
+    // "%label:" prefix
+    NSString *label = nil;
+    ANTLRTreePattern *node;
+    if ( ttype == ANTLRLexerTokenTypePERCENT ) {
+        ttype = [tokenizer nextToken];
+        if ( ttype != ANTLRLexerTokenTypeID ) {
+            return nil;
+        }
+        label = [tokenizer toString];
+        ttype = [tokenizer nextToken];
+        if ( ttype != ANTLRLexerTokenTypeCOLON ) {
+            return nil;
+        }
+        ttype = [tokenizer nextToken]; // move to ID following colon
+    }
+
+    // Wildcard?
+    if ( ttype == ANTLRLexerTokenTypeDOT ) {
+        ttype = [tokenizer nextToken];
+        id<ANTLRToken> wildcardPayload = [ANTLRCommonToken newToken:0 Text:@"."];
+        node = [ANTLRWildcardTreePattern newANTLRWildcardTreePattern:wildcardPayload];
+        if ( label != nil ) {
+            node.label = label;
+        }
+        return node;
+    }
+
+    // "ID" or "ID[arg]"
+    if ( ttype != ANTLRLexerTokenTypeID ) {
+        return nil;
+    }
+    NSString *tokenName = [tokenizer toString];
+    ttype = [tokenizer nextToken];
+    if ( [tokenName isEqualToString:@"nil"] ) {
+        return [adaptor emptyNode];
+    }
+    NSString *text = tokenName;
+    // check for arg
+    NSString *arg = nil;
+    if ( ttype == ANTLRLexerTokenTypeARG ) {
+        arg = [tokenizer toString];
+        text = arg;
+        ttype = [tokenizer nextToken];
+    }
+
+    // create node
+    int treeNodeType = [wizard getTokenType:tokenName];
+    if ( treeNodeType==ANTLRTokenTypeInvalid ) {
+        return nil;
+    }
+    node = [adaptor createTree:treeNodeType Text:text];
+    if ( label!=nil && [node class] == [ANTLRTreePattern class] ) {
+        ((ANTLRTreePattern *)node).label = label;
+    }
+    if ( arg!=nil && [node class] == [ANTLRTreePattern class] ) {
+        ((ANTLRTreePattern *)node).hasTextArg = YES;
+    }
+    return node;
+}
+
+@synthesize tokenizer;
+@synthesize ttype;
+@synthesize wizard;
+@synthesize adaptor;
+@end
diff --git a/runtime/ObjC/Framework/TreeRewriter.h b/runtime/ObjC/Framework/TreeRewriter.h
new file mode 100644
index 0000000..5ab5700
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeRewriter.h
@@ -0,0 +1,78 @@
+//
+//  ANTLRTreeRewriter.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/17/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTreeParser.h"
+
+@interface ANTLRfptr : NSObject {
+    id  actor;
+    SEL ruleSEL;
+}
+
++ (ANTLRfptr *)newANTLRfptrWithRule:(SEL)aRuleAction withObject:(id)anObject;
+-initWithRule:(SEL)ruleAction withObject:(id)anObject;
+
+- (id)rule;
+
+@property (retain) id  actor;
+@property SEL ruleSEL;
+@end
+
+@interface ANTLRTreeRewriter : ANTLRTreeParser {
+    BOOL showTransformations;
+    id<ANTLRTokenStream> originalTokenStream;
+    id<ANTLRTreeAdaptor> originalAdaptor;
+    ANTLRfptr *rule;
+    ANTLRfptr *topdown_fptr;
+    ANTLRfptr *bottomup_ftpr;
+}
+
++ (ANTLRTreeRewriter *) newANTLRTreeRewriter:(id<ANTLRTreeNodeStream>)anInput;
++ (ANTLRTreeRewriter *) newANTLRTreeRewriter:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)aState;
+- (id)initWithStream:(id<ANTLRTreeNodeStream>)anInput;
+- (id)initWithStream:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)aState;
+- (id) applyOnce:(ANTLRCommonTree *)t Rule:(ANTLRfptr *)whichRule;
+- (id) applyRepeatedly:(ANTLRCommonTree *)t Rule:(ANTLRfptr *)whichRule;
+- (id) downup:(ANTLRCommonTree *)t;
+- (id) pre:(ANTLRCommonTree *)t;
+- (id) post:(ANTLRCommonTree *)t;
+- (id) downup:(ANTLRCommonTree *)t XForm:(BOOL)aShowTransformations;
+- (void)reportTransformation:(ANTLRCommonTree *)oldTree Tree:(ANTLRCommonTree *)newTree;
+- (id) topdown_fptr;
+- (id) bottomup_ftpr;
+- (id) topdown;
+- (id) bottomup;
+
+@property BOOL showTransformations;
+@property (retain) id<ANTLRTokenStream> originalTokenStream;
+@property (retain) id<ANTLRTreeAdaptor> originalAdaptor;
+@property (retain) ANTLRfptr *rule;
+@end
diff --git a/runtime/ObjC/Framework/TreeRewriter.m b/runtime/ObjC/Framework/TreeRewriter.m
new file mode 100644
index 0000000..8495436
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeRewriter.m
@@ -0,0 +1,250 @@
+//
+//  ANTLRTreeRewriter.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/17/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreeRewriter.h"
+#import "ANTLRCommonTreeNodeStream.h"
+#import "ANTLRTreeRuleReturnScope.h"
+#import "ANTLRCommonTreeAdaptor.h"
+#import "ANTLRTreeVisitor.h"
+
+@implementation ANTLRfptr
+
++ (ANTLRfptr *)newANTLRfptrWithRule:(SEL)aRuleAction withObject:(id)anObject
+{
+    return [[ANTLRfptr alloc] initWithRule:aRuleAction withObject:(id)anObject];
+}
+
+-initWithRule:(SEL)aRuleAction withObject:(id)anObject
+{
+    if ((self = [super init]) != nil) {
+        actor = anObject;
+        ruleSEL = aRuleAction;
+    }
+    return self;
+}
+
+- (id)rule
+{
+	if ( [actor respondsToSelector:ruleSEL] )
+		return [actor performSelector:ruleSEL];
+    else
+        @throw [ANTLRRuntimeException newException:@"Unknown Rewrite exception"];
+    return nil;
+}
+
+@synthesize actor;
+@synthesize ruleSEL;
+@end
+
+@implementation ANTLRTreeRewriter
+
++ (ANTLRTreeRewriter *) newANTLRTreeRewriter:(id<ANTLRTreeNodeStream>)anInput
+{
+    return [[ANTLRTreeRewriter alloc] initWithStream:anInput State:[ANTLRRecognizerSharedState newANTLRRecognizerSharedState]];
+}
+
++ (ANTLRTreeRewriter *) newANTLRTreeRewriter:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)aState
+{
+    return [[ANTLRTreeRewriter alloc] initWithStream:anInput State:aState];
+}
+
+- (id)initWithStream:(id<ANTLRTreeNodeStream>)anInput
+{
+    SEL aRuleSel;
+
+    if ((self = [super initWithStream:anInput]) != nil) {
+        showTransformations = NO;
+        state = [[ANTLRRecognizerSharedState newANTLRRecognizerSharedState] retain];
+        originalAdaptor = [input getTreeAdaptor];
+        if ( originalAdaptor ) [originalAdaptor retain];
+        originalTokenStream = [input getTokenStream];
+        if ( originalTokenStream ) [originalTokenStream retain];
+        aRuleSel = @selector(topdown);
+        topdown_fptr = [ANTLRfptr newANTLRfptrWithRule:(SEL)aRuleSel withObject:self];
+        aRuleSel = @selector(bottomup);
+        bottomup_ftpr = [ANTLRfptr newANTLRfptrWithRule:(SEL)aRuleSel withObject:self];
+    }
+    return self;
+}
+
+- (id)initWithStream:(id<ANTLRTreeNodeStream>)anInput State:(ANTLRRecognizerSharedState *)aState
+{
+    SEL aRuleSel;
+
+    if ((self = [super initWithStream:anInput]) != nil) {
+        showTransformations = NO;
+        state = aState;
+        if ( state ) [state retain];
+        originalAdaptor = [input getTreeAdaptor];
+        if ( originalAdaptor ) [originalAdaptor retain];
+        originalTokenStream = [input getTokenStream];
+        if ( originalTokenStream ) [originalTokenStream retain];
+        aRuleSel = @selector(topdown);
+        topdown_fptr = [ANTLRfptr newANTLRfptrWithRule:(SEL)aRuleSel withObject:self];
+        aRuleSel = @selector(bottomup);
+        bottomup_ftpr = [ANTLRfptr newANTLRfptrWithRule:(SEL)aRuleSel withObject:self];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreeRewriter" );
+#endif
+	if ( state ) [state release];
+	if ( originalAdaptor ) [originalAdaptor release];
+	if ( originalTokenStream ) [originalTokenStream release];
+	[super dealloc];
+}
+
+- (id) applyOnce:(ANTLRCommonTree *)t Rule:(ANTLRfptr *)whichRule
+{
+    if ( t == nil ) return nil;
+    @try {
+        // share TreeParser object but not parsing-related state
+        state = [ANTLRRecognizerSharedState newANTLRRecognizerSharedState];
+        input = [ANTLRCommonTreeNodeStream newANTLRCommonTreeNodeStream:(ANTLRCommonTreeAdaptor *)originalAdaptor Tree:t];
+        [(ANTLRCommonTreeNodeStream *)input setTokenStream:originalTokenStream];
+        [self setBacktrackingLevel:1];
+        ANTLRTreeRuleReturnScope *r = [(ANTLRfptr *)whichRule rule];
+        [self setBacktrackingLevel:0];
+        if ( [self getFailed] )
+            return t;
+        if ( showTransformations &&
+            r != nil && !(t == r.start) && r.start != nil ) {
+            [self reportTransformation:t Tree:r.start];
+        }
+        if ( r != nil && r.start != nil )
+            return r.start;
+        else
+            return t;
+    }
+    @catch (ANTLRRecognitionException *e) {
+        return t;
+    }
+    return t;
+}
+
+- (id) applyRepeatedly:(ANTLRCommonTree *)t Rule:(ANTLRfptr *)whichRule
+{
+    BOOL treeChanged = true;
+    while ( treeChanged ) {
+        ANTLRTreeRewriter *u = [self applyOnce:t Rule:whichRule];
+        treeChanged = !(t == u);
+        t = u;
+    }
+    return t;
+}
+
+- (id) downup:(ANTLRCommonTree *)t
+{
+    return [self downup:t XForm:NO];
+}
+
+- (id) pre:(ANTLRCommonTree *)t
+{
+    return [self applyOnce:t Rule:topdown_fptr];
+}
+
+- (id)post:(ANTLRCommonTree *)t
+{
+    return [self applyRepeatedly:t Rule:bottomup_ftpr];
+}
+
+#ifdef DONTUSENOMO
+public Object downup(Object t, boolean showTransformations) {
+    this.showTransformations = showTransformations;
+    TreeVisitor v = new TreeVisitor(new CommonTreeAdaptor());
+    TreeVisitorAction actions = new TreeVisitorAction() {
+        public Object pre(Object t)  { return applyOnce(t, topdown_fptr); }
+        public Object post(Object t) { return applyRepeatedly(t, bottomup_ftpr); }
+    };
+    t = v.visit(t, actions);
+    return t;
+}
+#endif
+
+- (id) downup:(ANTLRCommonTree *)t XForm:(BOOL)aShowTransformations
+{
+    showTransformations = aShowTransformations;
+    ANTLRTreeVisitor *v = [ANTLRTreeVisitor newANTLRTreeVisitor:[[originalAdaptor class] newTreeAdaptor]];
+    ANTLRTreeVisitorAction *actions = [ANTLRTreeVisitorAction newANTLRTreeVisitorAction];
+    {
+        //public Object pre(Object t)  { return applyOnce(t, topdown_fptr); }
+        [self pre:t];
+        //public Object post(Object t) { return applyRepeatedly(t, bottomup_ftpr); }
+        [self post:t];
+    };
+    t = [v visit:t Action:actions];
+    return t;
+}
+
+/** Override this if you need transformation tracing to go somewhere
+ *  other than stdout or if you're not using Tree-derived trees.
+ */
+- (void)reportTransformation:(ANTLRCommonTree *)oldTree Tree:(ANTLRCommonTree *)newTree
+{
+    //System.out.println(((Tree)oldTree).toStringTree()+" -> "+ ((Tree)newTree).toStringTree());
+}
+
+- (id)topdown_fptr
+{
+    return [self topdown];
+}
+
+- (id)bottomup_ftpr
+{
+    return [self bottomup];
+}
+
+// methods the downup strategy uses to do the up and down rules.
+// to override, just define tree grammar rule topdown and turn on
+// filter=true.
+- (id) topdown
+// @throws RecognitionException
+{
+    @throw [ANTLRRecognitionException newException:@"TopDown exception"];
+    return nil;
+}
+
+- (id) bottomup
+//@throws RecognitionException
+{
+    @throw [ANTLRRecognitionException newException:@"BottomUp exception"];
+    return nil;
+}
+
+@synthesize showTransformations;
+@synthesize originalTokenStream;
+@synthesize originalAdaptor;
+@synthesize rule;
+@end
diff --git a/runtime/ObjC/Framework/TreeRuleReturnScope.h b/runtime/ObjC/Framework/TreeRuleReturnScope.h
new file mode 100644
index 0000000..9937052
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeRuleReturnScope.h
@@ -0,0 +1,52 @@
+//
+//  ANTLRTreeRuleReturnScope.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/17/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRuleReturnScope.h"
+#import "ANTLRCommonTree.h"
+
+@interface ANTLRTreeRuleReturnScope : ANTLRRuleReturnScope {
+    ANTLRCommonTree *start;
+}
+
+@property (retain, getter=getStart, setter=setStart:) ANTLRCommonTree *start;
+
+/** First node or root node of tree matched for this rule. */
+
++ (id) newReturnScope;
+- (id) init;
+- (void) dealloc;
+- (ANTLRCommonTree *)getStart;
+- (void)setStart:(ANTLRCommonTree *)aStart;
+
+- (id) copyWithZone:(NSZone *)theZone;
+
+@end
diff --git a/runtime/ObjC/Framework/TreeRuleReturnScope.m b/runtime/ObjC/Framework/TreeRuleReturnScope.m
new file mode 100644
index 0000000..0043314
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeRuleReturnScope.m
@@ -0,0 +1,81 @@
+//
+//  ANTLRTreeRuleReturnScope.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/17/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreeRuleReturnScope.h"
+
+
+@implementation ANTLRTreeRuleReturnScope
+@synthesize start;
+
++ (id) newReturnScope
+{
+    return [[ANTLRTreeRuleReturnScope alloc] init];
+}
+
+- (id) init
+{
+    self = [super init];
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreeRuleReturnScope" );
+#endif
+	if ( start ) [start release];
+	[super dealloc];
+}
+
+- (ANTLRCommonTree *)getStart
+{
+    return start;
+}
+
+- (void)setStart:(ANTLRCommonTree *)aStart
+{
+    if ( start != aStart ) {
+        if ( start ) [start release];
+        [aStart retain];
+    }
+    start = aStart;
+}
+
+// create a copy, including the text if available
+// the input stream is *not* copied!
+- (id) copyWithZone:(NSZone *)theZone
+{
+    ANTLRTreeRuleReturnScope *copy = [super copyWithZone:theZone];
+    copy.start = start;
+    return copy;
+}
+
+@end
diff --git a/runtime/ObjC/Framework/TreeVisitor.h b/runtime/ObjC/Framework/TreeVisitor.h
new file mode 100644
index 0000000..e8af0d0
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeVisitor.h
@@ -0,0 +1,47 @@
+//
+//  ANTLRTreeVisitor.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTreeAdaptor.h"
+#import "ANTLRTreeVisitorAction.h"
+
+@interface ANTLRTreeVisitor : NSObject {
+   id<ANTLRTreeAdaptor> adaptor;
+}
++ (ANTLRTreeVisitor *)newANTLRTreeVisitor:(id<ANTLRTreeAdaptor>) anAdaptor;
++ (ANTLRTreeVisitor *)newANTLRTreeVisitor;
+- (id)init;
+- (id)initWithAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
+- (void) dealloc;
+- (ANTLRTreeVisitor *)visit:(id<ANTLRBaseTree>)t Action:(ANTLRTreeVisitorAction *)action;
+
+@property (retain) id<ANTLRTreeAdaptor> adaptor;
+@end
diff --git a/runtime/ObjC/Framework/TreeVisitor.m b/runtime/ObjC/Framework/TreeVisitor.m
new file mode 100644
index 0000000..f500d6d
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeVisitor.m
@@ -0,0 +1,103 @@
+//
+//  ANTLRTreeVisitor.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreeVisitor.h"
+#import "ANTLRCommonTreeAdaptor.h"
+
+@implementation ANTLRTreeVisitor
+
++ (ANTLRTreeVisitor *)newANTLRTreeVisitor:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    return [[ANTLRTreeVisitor alloc] initWithAdaptor:anAdaptor];
+}
+
++ (ANTLRTreeVisitor *)newANTLRTreeVisitor
+{
+    return [[ANTLRTreeVisitor alloc] init];
+}
+
+
+- (id)init
+{
+    if ((self = [super init]) != nil) {
+        adaptor = [[ANTLRCommonTreeAdaptor newTreeAdaptor] retain];
+    }
+    return self;
+}
+
+- (id)initWithAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    if ((self = [super init]) != nil) {
+        adaptor = [anAdaptor retain];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreeVisitor" );
+#endif
+    if ( adaptor ) [adaptor release];
+    [super dealloc];
+}
+
+/** Visit every node in tree t and trigger an action for each node
+ *  before/after having visited all of its children.
+ *  Execute both actions even if t has no children.
+ *  If a child visit yields a new child, it can update its
+ *  parent's child list or just return the new child.  The
+ *  child update code works even if the child visit alters its parent
+ *  and returns the new tree.
+ *
+ *  Return result of applying post action to this node.
+ */
+- (ANTLRTreeVisitor *)visit:(ANTLRCommonTree *)t Action:(ANTLRTreeVisitorAction *)action
+{
+    // System.out.println("visit "+((Tree)t).toStringTree());
+    BOOL isNil = [adaptor isNil:t];
+    if ( action != nil && !isNil ) {
+        t = [action pre:(ANTLRTreeVisitorAction *)t]; // if rewritten, walk children of new t
+    }
+    for (int i=0; i < [adaptor getChildCount:t]; i++) {
+        ANTLRCommonTree *child = [adaptor getChild:t At:i];
+        ANTLRCommonTree *visitResult = [self visit:child Action:action];
+        ANTLRCommonTree *childAfterVisit = [adaptor getChild:t At:i];
+        if ( visitResult !=  childAfterVisit ) { // result & child differ?
+            [adaptor setChild:t At:i Child:visitResult];
+        }
+    }
+    if ( action != nil && !isNil ) t = [action post:(ANTLRTreeVisitorAction *)t];
+    return t;
+}
+
+@synthesize adaptor;
+@end
diff --git a/runtime/ObjC/Framework/TreeVisitorAction.h b/runtime/ObjC/Framework/TreeVisitorAction.h
new file mode 100644
index 0000000..c9c0856
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeVisitorAction.h
@@ -0,0 +1,56 @@
+//
+//  ANTLRTreeVisitorAction.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+
+
+@interface ANTLRTreeVisitorAction : NSObject
+{
+
+}
+
++ (ANTLRTreeVisitorAction *)newANTLRTreeVisitorAction;
+- (id) init;
+
+/** Execute an action before visiting children of t.  Return t or
+ *  a rewritten t.  It is up to the visitor to decide what to do
+ *  with the return value.  Children of returned value will be
+ *  visited if using TreeVisitor.visit().
+ */
+- (ANTLRTreeVisitorAction *)pre:(ANTLRTreeVisitorAction *) t;
+
+/** Execute an action after visiting children of t.  Return t or
+ *  a rewritten t.  It is up to the visitor to decide what to do
+ *  with the return value.
+ */
+- (ANTLRTreeVisitorAction *)post:(ANTLRTreeVisitorAction *) t;
+
+@end
diff --git a/runtime/ObjC/Framework/TreeVisitorAction.m b/runtime/ObjC/Framework/TreeVisitorAction.m
new file mode 100644
index 0000000..09a5920
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeVisitorAction.m
@@ -0,0 +1,69 @@
+//
+//  ANTLRTreeVisitorAction.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreeVisitorAction.h"
+
+
+@implementation ANTLRTreeVisitorAction
+
++ (ANTLRTreeVisitorAction *)newANTLRTreeVisitorAction
+{
+    return [[ANTLRTreeVisitorAction alloc] init];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil ) {
+    }
+    return self;
+}
+
+/** Execute an action before visiting children of t.  Return t or
+ *  a rewritten t.  It is up to the visitor to decide what to do
+ *  with the return value.  Children of returned value will be
+ *  visited if using TreeVisitor.visit().
+ */
+- (ANTLRTreeVisitorAction *)pre:(ANTLRTreeVisitorAction *) t
+{
+    return nil;
+}
+
+/** Execute an action after visiting children of t.  Return t or
+ *  a rewritten t.  It is up to the visitor to decide what to do
+ *  with the return value.
+ */
+- (ANTLRTreeVisitorAction *)post:(ANTLRTreeVisitorAction *) t
+{
+    return nil;
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/TreeWizard.h b/runtime/ObjC/Framework/TreeWizard.h
new file mode 100644
index 0000000..7a57c1e
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeWizard.h
@@ -0,0 +1,136 @@
+//
+//  ANTLRTreeWizard.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRCommonTreeAdaptor.h"
+#import "ANTLRCommonTree.h"
+#import "ANTLRMapElement.h"
+#import "ANTLRMap.h"
+#import "AMutableArray.h"
+
+@class ANTLRVisitor;
+
+@protocol ANTLRContextVisitor <NSObject>
+// TODO: should this be called visit or something else?
+- (void) visit:(ANTLRCommonTree *)t Parent:(ANTLRCommonTree *)parent ChildIndex:(NSInteger)childIndex Map:(ANTLRMap *)labels;
+
+@end
+
+@interface ANTLRVisitor : NSObject <ANTLRContextVisitor> {
+    NSInteger action;
+    id actor;
+    id object1;
+    id object2;
+}
++ (ANTLRVisitor *)newANTLRVisitor:(NSInteger)anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2;
+- (id) initWithAction:(NSInteger)anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2;
+
+- (void) visit:(ANTLRCommonTree *)t;
+- (void) visit:(ANTLRCommonTree *)t Parent:(ANTLRCommonTree *)parent ChildIndex:(NSInteger)childIndex Map:(ANTLRMap *)labels;
+
+@property NSInteger action;
+@property (retain) id actor;
+@property (retain) id object1;
+@property (retain) id object2;
+@end
+
+/** When using %label:TOKENNAME in a tree for parse(), we must
+ *  track the label.
+ */
+@interface ANTLRTreePattern : ANTLRCommonTree {
+    NSString *label;
+    BOOL      hasTextArg;
+}
+@property (retain, getter=getLabel, setter=setLabel:) NSString *label;
+@property (assign, getter=getHasTextArg, setter=setHasTextArg:) BOOL hasTextArg;
+
++ (ANTLRCommonTree *)newANTLRTreePattern:(id<ANTLRToken>)payload;
+
+- (id) initWithToken:(id<ANTLRToken>)payload;
+- (NSString *)toString;
+@end
+
+@interface ANTLRWildcardTreePattern : ANTLRTreePattern {
+}
+
++ (ANTLRWildcardTreePattern *)newANTLRWildcardTreePattern:(id<ANTLRToken>)payload;
+- (id) initWithToken:(id<ANTLRToken>)payload;
+@end
+
+/** This adaptor creates TreePattern objects for use during scan() */
+@interface ANTLRTreePatternTreeAdaptor : ANTLRCommonTreeAdaptor {
+}
++ (ANTLRTreePatternTreeAdaptor *)newTreeAdaptor;
+- (id) init;
+- (ANTLRCommonTree *)createTreePattern:(id<ANTLRToken>)payload;
+
+@end
+
+@interface ANTLRTreeWizard : NSObject {
+	id<ANTLRTreeAdaptor> adaptor;
+	ANTLRMap *tokenNameToTypeMap;
+}
++ (ANTLRTreeWizard *) newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)anAdaptor;
++ (ANTLRTreeWizard *)newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)adaptor Map:(ANTLRMap *)aTokenNameToTypeMap;
++ (ANTLRTreeWizard *)newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)adaptor TokenNames:(NSArray *)theTokNams;
++ (ANTLRTreeWizard *)newANTLRTreeWizardWithTokenNames:(NSArray *)theTokNams;
+- (id) init;
+- (id) initWithAdaptor:(id<ANTLRTreeAdaptor>)adaptor;
+- (id) initWithAdaptor:(id<ANTLRTreeAdaptor>)adaptor Map:(ANTLRMap *)tokenNameToTypeMap;
+- (id) initWithTokenNames:(NSArray *)theTokNams;
+- (id) initWithTokenNames:(id<ANTLRTreeAdaptor>)anAdaptor TokenNames:(NSArray *)theTokNams;
+- (void) dealloc;
+- (ANTLRMap *)computeTokenTypes:(NSArray *)theTokNams;
+- (NSInteger)getTokenType:(NSString *)tokenName;
+- (ANTLRMap *)index:(ANTLRCommonTree *)t;
+- (void) _index:(ANTLRCommonTree *)t Map:(ANTLRMap *)m;
+- (AMutableArray *)find:(ANTLRCommonTree *) t Pattern:(NSString *)pattern;
+- (ANTLRTreeWizard *)findFirst:(ANTLRCommonTree *) t Type:(NSInteger)ttype;
+- (ANTLRTreeWizard *)findFirst:(ANTLRCommonTree *) t Pattern:(NSString *)pattern;
+- (void) visit:(ANTLRCommonTree *)t Type:(NSInteger)ttype Visitor:(ANTLRVisitor *)visitor;
+- (void) _visit:(ANTLRCommonTree *)t
+         Parent:(ANTLRCommonTree *)parent
+     ChildIndex:(NSInteger)childIndex
+           Type:(NSInteger)ttype
+        Visitor:(ANTLRVisitor *)visitor;
+- (void)visit:(ANTLRCommonTree *)t Pattern:(NSString *)pattern Visitor:(ANTLRVisitor *)visitor;
+- (BOOL)parse:(ANTLRCommonTree *)t Pattern:(NSString *)pattern Map:(ANTLRMap *)labels;
+- (BOOL) parse:(ANTLRCommonTree *) t Pattern:(NSString *)pattern;
+- (BOOL) _parse:(ANTLRCommonTree *)t1 Pattern:(ANTLRCommonTree *)tpattern Map:(ANTLRMap *)labels;
+- (ANTLRCommonTree *) createTree:(NSString *)pattern;
+- (BOOL)equals:(id)t1 O2:(id)t2 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
+- (BOOL)equals:(id)t1 O2:(id)t2;
+- (BOOL) _equals:(id)t1 O2:(id)t2 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor;
+
+@property (retain) id<ANTLRTreeAdaptor> adaptor;
+@property (retain) ANTLRMap *tokenNameToTypeMap;
+@end
+
diff --git a/runtime/ObjC/Framework/TreeWizard.m b/runtime/ObjC/Framework/TreeWizard.m
new file mode 100644
index 0000000..78131a8
--- /dev/null
+++ b/runtime/ObjC/Framework/TreeWizard.m
@@ -0,0 +1,735 @@
+//
+//  ANTLRTreeWizard.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/18/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRTreeWizard.h"
+#import "ANTLRTreePatternLexer.h"
+#import "ANTLRTreePatternParser.h"
+#import "ANTLRIntArray.h"
+
+@implementation ANTLRVisitor
+
++ (ANTLRVisitor *)newANTLRVisitor:(NSInteger)anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2
+{
+    return [[ANTLRVisitor alloc] initWithAction:anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2];
+}
+
+- (id) initWithAction:(NSInteger)anAction Actor:(id)anActor Object:(id)anObject1 Object:(id)anObject2
+{
+    if ((self = [super init]) != nil) {
+        action = anAction;
+        actor = anActor;
+        if ( actor ) [actor retain];
+        object1 = anObject1;
+        if ( object1 ) [object1 retain];
+        object2 = anObject2;
+        if ( object2 ) [object2 retain];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRVisitor" );
+#endif
+    if ( actor ) [actor release];
+    if ( object1 ) [object1 release];
+    if ( object2 ) [object2 release];
+    [super dealloc];
+}
+
+- (void) visit:(ANTLRCommonTree *)t Parent:(ANTLRCommonTree *)parent ChildIndex:(NSInteger)childIndex Map:(ANTLRMap *)labels
+{
+    switch (action) {
+        case 0:
+            [(ANTLRMap *)object2 /* labels */ clear];
+            if ( [(ANTLRTreeWizard *)actor _parse:t Pattern:object1/* tpattern */ Map:object2 /* labels */] ) {
+                [self visit:t Parent:parent ChildIndex:childIndex Map:object2 /* labels */];
+            }
+            break;
+        case 1:
+            if ( [(ANTLRTreeWizard *)actor _parse:t Pattern:object1/* tpattern */ Map:nil] ) {
+                [(AMutableArray *)object2/* subtrees */ addObject:t];
+            }
+            break;
+    }
+    // [self visit:t];
+    return;
+}
+
+- (void) visit:(ANTLRCommonTree *)t
+{
+    [object1 addObject:t];
+    return;
+}
+
+@synthesize action;
+@synthesize actor;
+@synthesize object1;
+@synthesize object2;
+@end
+
+/** When using %label:TOKENNAME in a tree for parse(), we must
+ *  track the label.
+ */
+@implementation ANTLRTreePattern
+
+@synthesize label;
+@synthesize hasTextArg;
+
++ (ANTLRCommonTree *)newANTLRTreePattern:(id<ANTLRToken>)payload
+{
+    return (ANTLRCommonTree *)[[ANTLRTreePattern alloc] initWithToken:payload];
+}
+
+- (id) initWithToken:(id<ANTLRToken>)payload
+{
+    self = [super initWithToken:payload];
+    if ( self != nil ) {
+    }
+    return (ANTLRCommonTree *)self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreePattern" );
+#endif
+    if ( label ) [label release];
+    [super dealloc];
+}
+
+- (NSString *)toString
+{
+    if ( label != nil ) {
+        return [NSString stringWithFormat:@"\% %@ : %@", label, [super toString]];
+    }
+    else {
+        return [super toString];
+    }
+}
+
+@end
+
+@implementation ANTLRWildcardTreePattern
+
++ (ANTLRWildcardTreePattern *)newANTLRWildcardTreePattern:(id<ANTLRToken>)payload
+{
+    return(ANTLRWildcardTreePattern *)[[ANTLRWildcardTreePattern alloc] initWithToken:(id<ANTLRToken>)payload];
+}
+
+- (id) initWithToken:(id<ANTLRToken>)payload
+{
+    self = [super initWithToken:payload];
+    if ( self != nil ) {
+    }
+    return self;
+}
+
+@end
+
+/** This adaptor creates TreePattern objects for use during scan() */
+@implementation ANTLRTreePatternTreeAdaptor
+
++ (ANTLRTreePatternTreeAdaptor *)newTreeAdaptor
+{
+    return [[ANTLRTreePatternTreeAdaptor alloc] init];
+}
+
+- (id) init
+{
+    self = [super init];
+    if ( self != nil ) {
+    }
+    return self;
+}
+
+- (ANTLRCommonTree *)createTreePattern:(id<ANTLRToken>)payload
+{
+    return (ANTLRCommonTree *)[super create:payload];
+}
+
+@end
+
+@implementation ANTLRTreeWizard
+
+// TODO: build indexes for the wizard
+
+/** During fillBuffer(), we can make a reverse index from a set
+ *  of token types of interest to the list of indexes into the
+ *  node stream.  This lets us convert a node pointer to a
+ *  stream index semi-efficiently for a list of interesting
+ *  nodes such as function definition nodes (you'll want to seek
+ *  to their bodies for an interpreter).  Also useful for doing
+ *  dynamic searches; i.e., go find me all PLUS nodes.
+ protected Map tokenTypeToStreamIndexesMap;
+
+ ** If tokenTypesToReverseIndex set to INDEX_ALL then indexing
+ *  occurs for all token types.
+ public static final Set INDEX_ALL = new HashSet();
+
+ ** A set of token types user would like to index for faster lookup.
+ *  If this is INDEX_ALL, then all token types are tracked.  If nil,
+ *  then none are indexed.
+ protected Set tokenTypesToReverseIndex = nil;
+ */
+
++ (ANTLRTreeWizard *) newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    return [[ANTLRTreeWizard alloc] initWithAdaptor:anAdaptor];
+}
+
++ (ANTLRTreeWizard *)newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)anAdaptor Map:(ANTLRMap *)aTokenNameToTypeMap
+{
+    return [[ANTLRTreeWizard alloc] initWithAdaptor:anAdaptor Map:aTokenNameToTypeMap];
+}
+
++ (ANTLRTreeWizard *)newANTLRTreeWizard:(id<ANTLRTreeAdaptor>)anAdaptor TokenNames:(NSArray *)theTokNams
+{
+    return [[ANTLRTreeWizard alloc] initWithTokenNames:anAdaptor TokenNames:theTokNams];
+}
+
++ (ANTLRTreeWizard *)newANTLRTreeWizardWithTokenNames:(NSArray *)theTokNams
+{
+    return [[ANTLRTreeWizard alloc] initWithTokenNames:theTokNams];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil) {
+    }
+    return self;
+}
+
+- (id) initWithAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    if ((self = [super init]) != nil) {
+        adaptor = anAdaptor;
+        if ( adaptor ) [adaptor retain];
+    }
+    return self;
+}
+
+- (id) initWithAdaptor:(id<ANTLRTreeAdaptor>)anAdaptor Map:(ANTLRMap *)aTokenNameToTypeMap
+{
+    if ((self = [super init]) != nil) {
+        adaptor = anAdaptor;
+        if ( adaptor ) [adaptor retain];
+        tokenNameToTypeMap = aTokenNameToTypeMap;
+   }
+    return self;
+}
+
+- (id) initWithTokenNames:(NSArray *)theTokNams
+{
+    if ((self = [super init]) != nil) {
+#pragma warning Fix initWithTokenNames.
+        // adaptor = anAdaptor;
+        //tokenNameToTypeMap = aTokenNameToTypeMap;
+        tokenNameToTypeMap = [[self computeTokenTypes:theTokNams] retain];
+    }
+    return self;
+}
+
+- (id) initWithTokenNames:(id<ANTLRTreeAdaptor>)anAdaptor TokenNames:(NSArray *)theTokNams
+{
+    if ((self = [super init]) != nil) {
+        adaptor = anAdaptor;
+        if ( adaptor ) [adaptor retain];
+        // tokenNameToTypeMap = aTokenNameToTypeMap;
+        tokenNameToTypeMap = [[self computeTokenTypes:theTokNams] retain];
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRTreePatternTreeAdaptor" );
+#endif
+    if ( adaptor ) [adaptor release];
+    if ( tokenNameToTypeMap ) [tokenNameToTypeMap release];
+    [super dealloc];
+}
+
+/** Compute a Map<String, Integer> that is an inverted index of
+ *  tokenNames (which maps int token types to names).
+ */
+- (ANTLRMap *)computeTokenTypes:(NSArray *)theTokNams
+{
+    ANTLRMap *m = [ANTLRMap newANTLRMap];
+    if ( theTokNams == nil ) {
+        return m;
+    }
+    for (int ttype = ANTLRTokenTypeMIN; ttype < [theTokNams count]; ttype++) {
+        NSString *name = (NSString *) [theTokNams objectAtIndex:ttype];
+        [m putName:name TType:ttype];
+    }
+    return m;
+}
+
+/** Using the map of token names to token types, return the type. */
+- (NSInteger)getTokenType:(NSString *)tokenName
+{
+    if ( tokenNameToTypeMap == nil ) {
+        return ANTLRTokenTypeInvalid;
+    }
+    NSInteger aTType = (NSInteger)[tokenNameToTypeMap getTType:tokenName];
+    if ( aTType != -1 ) {
+        return aTType;
+    }
+    return ANTLRTokenTypeInvalid;
+}
+
+/** Walk the entire tree and make a node name to nodes mapping.
+ *  For now, use recursion but later nonrecursive version may be
+ *  more efficient.  Returns Map<Integer, List> where the List is
+ *  of your AST node type.  The Integer is the token type of the node.
+ *
+ *  TODO: save this index so that find and visit are faster
+ */
+- (ANTLRMap *)index:(ANTLRCommonTree *)t
+{
+    ANTLRMap *m = [ANTLRMap newANTLRMap];
+    [self _index:t Map:m];
+    return m;
+}
+
+/** Do the work for index */
+- (void) _index:(ANTLRCommonTree *)t Map:(ANTLRMap *)m
+{
+    if ( t==nil ) {
+        return;
+    }
+#pragma warning Fix _index use of ANTLRMap.
+    NSInteger ttype = [adaptor getType:t];
+    ANTLRMap *elements = (ANTLRMap *)[m getName:ttype];
+    if ( elements == nil ) {
+        elements = [ANTLRMap newANTLRMapWithLen:100];
+        [m putNode:ttype Node:elements];
+    }
+    [elements addObject:t];
+    int n = [adaptor getChildCount:t];
+    for (int i=0; i<n; i++) {
+        ANTLRCommonTree * child = [adaptor getChild:t At:i];
+        [self _index:child Map:m];
+    }
+}
+
+/** Return a List of tree nodes with token type ttype */
+- (AMutableArray *)find:(ANTLRCommonTree *)t Type:(NSInteger)ttype
+{
+#ifdef DONTUSENOMO
+    final List nodes = new ArrayList();
+    visit(t, ttype, new TreeWizard.Visitor() {
+        public void visit(Object t) {
+            [nodes addObject t];
+        }
+    } );
+#endif
+    AMutableArray *nodes = [AMutableArray arrayWithCapacity:100];
+    ANTLRVisitor *contextVisitor = [ANTLRVisitor newANTLRVisitor:3 Actor:self Object:(id)nodes Object:nil];
+    [self visit:t Type:ttype Visitor:contextVisitor];
+    return nodes;
+}
+
+/** Return a List of subtrees matching pattern. */
+- (AMutableArray *)find:(ANTLRCommonTree *)t Pattern:(NSString *)pattern
+{
+    AMutableArray *subtrees = [AMutableArray arrayWithCapacity:100];
+    // Create a TreePattern from the pattern
+    ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
+    ANTLRTreePatternParser *parser = [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer
+                                                                                     Wizard:self
+                                                                                    Adaptor:[ANTLRTreePatternTreeAdaptor newTreeAdaptor]];
+    ANTLRCommonTree *tpattern = (ANTLRCommonTree *)[parser pattern];
+    // don't allow invalid patterns
+    if ( tpattern == nil ||
+        [tpattern isNil] ||
+        [tpattern class] == [ANTLRWildcardTreePattern class] )
+    {
+        return nil;
+    }
+    int rootTokenType = [tpattern type];
+#ifdef DONTUSENOMO
+    visit(t, rootTokenType, new TreeWizard.ContextVisitor() {
+        public void visit(Object t, Object parent, int childIndex, Map labels) {
+            if ( _parse(t, tpattern, null) ) {
+                subtrees.add(t);
+            }
+        }
+    } );
+#endif
+    ANTLRVisitor *contextVisitor = [ANTLRVisitor newANTLRVisitor:1 Actor:self Object:tpattern Object:subtrees];
+    [self visit:t Type:rootTokenType Visitor:contextVisitor];
+    return subtrees;
+}
+
+- (ANTLRTreeWizard *)findFirst:(ANTLRCommonTree *) t Type:(NSInteger)ttype
+{
+    return nil;
+}
+
+- (ANTLRTreeWizard *)findFirst:(ANTLRCommonTree *) t Pattern:(NSString *)pattern
+{
+    return nil;
+}
+
+/** Visit every ttype node in t, invoking the visitor.  This is a quicker
+ *  version of the general visit(t, pattern) method.  The labels arg
+ *  of the visitor action method is never set (it's nil) since using
+ *  a token type rather than a pattern doesn't let us set a label.
+ */
+- (void) visit:(ANTLRCommonTree *)t Type:(NSInteger)ttype Visitor:(ANTLRVisitor *)visitor
+{
+    [self _visit:t Parent:nil ChildIndex:0 Type:ttype Visitor:visitor];
+}
+
+/** Do the recursive work for visit */
+- (void) _visit:(ANTLRCommonTree *)t
+         Parent:(ANTLRCommonTree *)parent
+     ChildIndex:(NSInteger)childIndex
+           Type:(NSInteger)ttype
+        Visitor:(ANTLRVisitor *)visitor
+{
+    if ( t == nil ) {
+        return;
+    }
+    if ( [adaptor getType:t] == ttype ) {
+        [visitor visit:t Parent:parent ChildIndex:childIndex Map:nil];
+    }
+    int n = [adaptor getChildCount:t];
+    for (int i=0; i<n; i++) {
+        ANTLRCommonTree * child = [adaptor getChild:t At:i];
+        [self _visit:child Parent:t ChildIndex:i Type:ttype Visitor:visitor];
+    }
+}
+
+/** For all subtrees that match the pattern, execute the visit action.
+ *  The implementation uses the root node of the pattern in combination
+ *  with visit(t, ttype, visitor) so nil-rooted patterns are not allowed.
+ *  Patterns with wildcard roots are also not allowed.
+ */
+- (void)visit:(ANTLRCommonTree *)t Pattern:(NSString *)pattern Visitor:(ANTLRVisitor *)visitor
+{
+    // Create a TreePattern from the pattern
+    ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
+    ANTLRTreePatternParser *parser =
+    [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer Wizard:self Adaptor:[ANTLRTreePatternTreeAdaptor newTreeAdaptor]];
+    ANTLRCommonTree *tpattern = [parser pattern];
+    // don't allow invalid patterns
+    if ( tpattern == nil ||
+        [tpattern isNil] ||
+        [tpattern class] == [ANTLRWildcardTreePattern class] )
+    {
+        return;
+    }
+    ANTLRMapElement *labels = [ANTLRMap newANTLRMap]; // reused for each _parse
+    int rootTokenType = [tpattern type];
+#pragma warning This is another one of those screwy nested constructs that I have to figure out
+#ifdef DONTUSENOMO
+    visit(t, rootTokenType, new TreeWizard.ContextVisitor() {
+        public void visit(Object t, Object parent, int childIndex, Map unusedlabels) {
+            // the unusedlabels arg is null as visit on token type doesn't set.
+            labels.clear();
+            if ( _parse(t, tpattern, labels) ) {
+                visitor.visit(t, parent, childIndex, labels);
+            }
+        }
+    });
+#endif
+    ANTLRVisitor *contextVisitor = [ANTLRVisitor newANTLRVisitor:0 Actor:self Object:tpattern Object:labels];
+    [self visit:t Type:rootTokenType Visitor:contextVisitor];
+}
+
+/** Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels
+ *  on the various nodes and '.' (dot) as the node/subtree wildcard,
+ *  return true if the pattern matches and fill the labels Map with
+ *  the labels pointing at the appropriate nodes.  Return false if
+ *  the pattern is malformed or the tree does not match.
+ *
+ *  If a node specifies a text arg in pattern, then that must match
+ *  for that node in t.
+ *
+ *  TODO: what's a better way to indicate bad pattern? Exceptions are a hassle
+ */
+- (BOOL)parse:(ANTLRCommonTree *)t Pattern:(NSString *)pattern Map:(ANTLRMap *)labels
+{
+#ifdef DONTUSENOMO
+    TreePatternLexer tokenizer = new TreePatternLexer(pattern);
+    TreePatternParser parser =
+    new TreePatternParser(tokenizer, this, new TreePatternTreeAdaptor());
+    TreePattern tpattern = (TreePattern)parser.pattern();
+    /*
+     System.out.println("t="+((Tree)t).toStringTree());
+     System.out.println("scant="+tpattern.toStringTree());
+     */
+    boolean matched = _parse(t, tpattern, labels);
+    return matched;
+#endif
+    ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
+    ANTLRTreePatternParser *parser = [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer
+                                                                                Wizard:self
+                                                                               Adaptor:[ANTLRTreePatternTreeAdaptor newTreeAdaptor]];
+    ANTLRCommonTree *tpattern = [parser pattern];
+    /*
+     System.out.println("t="+((Tree)t).toStringTree());
+     System.out.println("scant="+tpattern.toStringTree());
+     */
+    //BOOL matched = [self _parse:t Pattern:tpattern Map:labels];
+    //return matched;
+    return [self _parse:t Pattern:tpattern Map:labels];
+}
+
+- (BOOL) parse:(ANTLRCommonTree *)t Pattern:(NSString *)pattern
+{
+    return [self parse:t Pattern:pattern Map:nil];
+}
+
+/** Do the work for parse. Check to see if the t2 pattern fits the
+ *  structure and token types in t1.  Check text if the pattern has
+ *  text arguments on nodes.  Fill labels map with pointers to nodes
+ *  in tree matched against nodes in pattern with labels.
+ */
+- (BOOL) _parse:(ANTLRCommonTree *)t1 Pattern:(ANTLRCommonTree *)aTPattern Map:(ANTLRMap *)labels
+{
+    ANTLRTreePattern *tpattern;
+    // make sure both are non-nil
+    if ( t1 == nil || aTPattern == nil ) {
+        return NO;
+    }
+    if ( [aTPattern isKindOfClass:[ANTLRWildcardTreePattern class]] ) {
+        tpattern = (ANTLRTreePattern *)aTPattern;
+    }
+    // check roots (wildcard matches anything)
+    if ( [tpattern class] != [ANTLRWildcardTreePattern class] ) {
+        if ( [adaptor getType:t1] != [tpattern type] )
+            return NO;
+        // if pattern has text, check node text
+        if ( tpattern.hasTextArg && ![[adaptor getText:t1] isEqualToString:[tpattern text]] ) {
+            return NO;
+        }
+    }
+    if ( tpattern.label != nil && labels!=nil ) {
+        // map label in pattern to node in t1
+        [labels putName:tpattern.label Node:t1];
+    }
+    // check children
+    int n1 = [adaptor getChildCount:t1];
+    int n2 = [tpattern getChildCount];
+    if ( n1 != n2 ) {
+        return NO;
+    }
+    for (int i=0; i<n1; i++) {
+        ANTLRCommonTree * child1 = [adaptor getChild:t1 At:i];
+        ANTLRCommonTree *child2 = (ANTLRCommonTree *)[tpattern getChild:i];
+        if ( ![self _parse:child1 Pattern:child2 Map:labels] ) {
+            return NO;
+        }
+    }
+    return YES;
+}
+
+/** Create a tree or node from the indicated tree pattern that closely
+ *  follows ANTLR tree grammar tree element syntax:
+ *
+ * 		(root child1 ... child2).
+ *
+ *  You can also just pass in a node: ID
+ *
+ *  Any node can have a text argument: ID[foo]
+ *  (notice there are no quotes around foo--it's clear it's a string).
+ *
+ *  nil is a special name meaning "give me a nil node".  Useful for
+ *  making lists: (nil A B C) is a list of A B C.
+ */
+- (ANTLRCommonTree *) createTree:(NSString *)pattern
+{
+    ANTLRTreePatternLexer *tokenizer = [ANTLRTreePatternLexer newANTLRTreePatternLexer:pattern];
+    ANTLRTreePatternParser *parser = [ANTLRTreePatternParser newANTLRTreePatternParser:tokenizer Wizard:self Adaptor:adaptor];
+    ANTLRCommonTree * t = [parser pattern];
+    return t;
+}
+
+/** Compare t1 and t2; return true if token types/text, structure match exactly.
+ *  The trees are examined in their entirety so that (A B) does not match
+ *  (A B C) nor (A (B C)).
+ // TODO: allow them to pass in a comparator
+ *  TODO: have a version that is nonstatic so it can use instance adaptor
+ *
+ *  I cannot rely on the tree node's equals() implementation as I make
+ *  no constraints at all on the node types nor interface etc...
+ */
+- (BOOL)equals:(id)t1 O2:(id)t2 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    return [self _equals:t1 O2:t2 Adaptor:anAdaptor];
+}
+
+/** Compare type, structure, and text of two trees, assuming adaptor in
+ *  this instance of a TreeWizard.
+ */
+- (BOOL)equals:(id)t1 O2:(id)t2
+{
+    return [self _equals:t1 O2:t2 Adaptor:adaptor];
+}
+
+- (BOOL) _equals:(id)t1 O2:(id)t2 Adaptor:(id<ANTLRTreeAdaptor>)anAdaptor
+{
+    // make sure both are non-nil
+    if ( t1==nil || t2==nil ) {
+        return NO;
+    }
+    // check roots
+    if ( [anAdaptor getType:t1] != [anAdaptor getType:t2] ) {
+        return NO;
+    }
+    if ( ![[anAdaptor getText:t1] isEqualTo:[anAdaptor getText:t2]] ) {
+        return NO;
+    }
+    // check children
+    NSInteger n1 = [anAdaptor getChildCount:t1];
+    NSInteger n2 = [anAdaptor getChildCount:t2];
+    if ( n1 != n2 ) {
+        return NO;
+    }
+    for (int i=0; i<n1; i++) {
+        ANTLRCommonTree * child1 = [anAdaptor getChild:t1 At:i];
+        ANTLRCommonTree * child2 = [anAdaptor getChild:t2 At:i];
+        if ( ![self _equals:child1 O2:child2 Adaptor:anAdaptor] ) {
+            return NO;
+        }
+    }
+    return YES;
+}
+
+// TODO: next stuff taken from CommonTreeNodeStream
+
+/** Given a node, add this to the reverse index tokenTypeToStreamIndexesMap.
+ *  You can override this method to alter how indexing occurs.  The
+ *  default is to create a
+ *
+ *    Map<Integer token type,ArrayList<Integer stream index>>
+ *
+ *  This data structure allows you to find all nodes with type INT in order.
+ *
+ *  If you really need to find a node of type, say, FUNC quickly then perhaps
+ *
+ *    Map<Integertoken type, Map<Object tree node, Integer stream index>>
+ *
+ *  would be better for you.  The interior maps map a tree node to
+ *  the index so you don't have to search linearly for a specific node.
+ *
+ *  If you change this method, you will likely need to change
+ *  getNodeIndex(), which extracts information.
+- (void)fillReverseIndex:(ANTLRCommonTree *)node Index:(NSInteger)streamIndex
+{
+    //System.out.println("revIndex "+node+"@"+streamIndex);
+    if ( tokenTypesToReverseIndex == nil ) {
+        return; // no indexing if this is empty (nothing of interest)
+    }
+    if ( tokenTypeToStreamIndexesMap == nil ) {
+        tokenTypeToStreamIndexesMap = [ANTLRMap newANTLRMap]; // first indexing op
+    }
+    int tokenType = [adaptor getType:node];
+    Integer tokenTypeI = new Integer(tokenType);
+    if ( !(tokenTypesToReverseIndex == INDEX_ALL ||
+            [tokenTypesToReverseIndex contains:tokenTypeI]) ) {
+        return; // tokenType not of interest
+    }
+    NSInteger streamIndexI = streamIndex;
+    AMutableArray *indexes = (AMutableArray *)[tokenTypeToStreamIndexesMap objectAtIndex:tokenTypeI];
+    if ( indexes==nil ) {
+        indexes = [AMutableArray arrayWithCapacity:100]; // no list yet for this token type
+        indexes.add(streamIndexI); // not there yet, add
+        [tokenTypeToStreamIndexesMap put:tokenTypeI Idexes:indexes];
+    }
+    else {
+        if ( ![indexes contains:streamIndexI] ) {
+            [indexes add:streamIndexI]; // not there yet, add
+        }
+    }
+}
+
+ ** Track the indicated token type in the reverse index.  Call this
+ *  repeatedly for each type or use variant with Set argument to
+ *  set all at once.
+ * @param tokenType
+public void reverseIndex:(NSInteger)tokenType
+{
+    if ( tokenTypesToReverseIndex == nil ) {
+        tokenTypesToReverseIndex = [ANTLRMap newANTLRMap];
+    }
+    else if ( tokenTypesToReverseIndex == INDEX_ALL ) {
+        return;
+    }
+    tokenTypesToReverseIndex.add(new Integer(tokenType));
+}
+
+** Track the indicated token types in the reverse index. Set
+ *  to INDEX_ALL to track all token types.
+public void reverseIndex(Set tokenTypes) {
+    tokenTypesToReverseIndex = tokenTypes;
+}
+
+ ** Given a node pointer, return its index into the node stream.
+ *  This is not its Token stream index.  If there is no reverse map
+ *  from node to stream index or the map does not contain entries
+ *  for node's token type, a linear search of entire stream is used.
+ *
+ *  Return -1 if exact node pointer not in stream.
+public int getNodeIndex(Object node) {
+    //System.out.println("get "+node);
+    if ( tokenTypeToStreamIndexesMap==nil ) {
+        return getNodeIndexLinearly(node);
+    }
+    int tokenType = adaptor.getType(node);
+    Integer tokenTypeI = new Integer(tokenType);
+    ArrayList indexes = (ArrayList)tokenTypeToStreamIndexesMap.get(tokenTypeI);
+    if ( indexes==nil ) {
+        //System.out.println("found linearly; stream index = "+getNodeIndexLinearly(node));
+        return getNodeIndexLinearly(node);
+    }
+    for (int i = 0; i < indexes.size(); i++) {
+        Integer streamIndexI = (Integer)indexes.get(i);
+        Object n = get(streamIndexI.intValue());
+        if ( n==node ) {
+            //System.out.println("found in index; stream index = "+streamIndexI);
+            return streamIndexI.intValue(); // found it!
+        }
+    }
+    return -1;
+}
+
+*/
+
+@synthesize adaptor;
+@synthesize tokenNameToTypeMap;
+@end
diff --git a/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStream.h b/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStream.h
new file mode 100644
index 0000000..aa1f9c6
--- /dev/null
+++ b/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStream.h
@@ -0,0 +1,122 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRTreeNodeStream.h"
+#import "ANTLRCommonTokenStream.h"
+#import "ANTLRCommonTree.h"
+#import "ANTLRCommonTreeAdaptor.h"
+
+@interface ANTLRUnbufferedCommonTreeNodeStream : NSObject < ANTLRTreeNodeStream > {
+
+	BOOL shouldUseUniqueNavigationNodes;
+
+	ANTLRCommonTree *root;
+	ANTLRCommonTree *currentNode;
+	ANTLRCommonTree *previousNode;
+
+	id<ANTLRTreeAdaptor> treeAdaptor;
+
+	id<ANTLRTokenStream> tokenStream;
+
+	NSMutableArray *nodeStack;
+	NSMutableArray *indexStack;
+	ANTLRPtrBuffer *markers;
+	NSInteger lastMarker;
+
+	NSInteger currentChildIndex;
+	NSInteger absoluteNodeIndex;
+
+	NSMutableArray *lookahead;
+	NSUInteger head;
+	NSUInteger tail;
+}
+
+@property (retain, getter=getRoot, setter=setRoot:) ANTLRCommonTree *root;
+@property (retain, getter=getCurrentNode, setter=setCurrentNode:) ANTLRCommonTree *currentNode;
+@property (retain, getter=getPreviousNode, setter=setPreviousNode:) ANTLRCommonTree *previousNode;
+@property (retain, getter=getTreeAdaptor, setter=setTreeAdaptor:) id<ANTLRTreeAdaptor> treeAdaptor;
+@property (retain, getter=getTokenStream, setter=setTokenStream:) id<ANTLRTokenStream> tokenStream;
+@property (retain, getter=getNodeStack, setter=setNodeStack:) NSMutableArray *nodeStack;
+@property (retain, getter=getIndexStack, setter=setIndexStackStack:) NSMutableArray *indexStack;
+@property (retain, getter=getMarkers, setter=setMarkers:) ANTLRPtrBuffer *markers;
+@property (assign, getter=getLastMarker, setter=setLastMarker:) NSInteger lastMarker;
+@property (assign, getter=getCurrentChildIndex, setter=setCurrentChildIndex:) NSInteger currentChildIndex;
+@property (assign, getter=getAbsoluteNodeIndex, setter=setAbsoluteNodeIndex:) NSInteger absoluteNodeIndex;
+@property (retain, getter=getLookahead, setter=setLookahead:) NSMutableArray *lookahead;
+@property (assign, getter=getHead, setter=setHead:) NSUInteger head;
+@property (assign, getter=getTail, setter=setTail:) NSUInteger tail;
+
+- (id) initWithTree:(ANTLRCommonTree *)theTree;
+- (id) initWithTree:(ANTLRCommonTree *)theTree treeAdaptor:(ANTLRCommonTreeAdaptor *)theAdaptor;
+
+- (void) reset;
+
+#pragma mark ANTLRTreeNodeStream conformance
+
+- (id) LT:(NSInteger)k;
+- (id) treeSource;
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
+- (void)setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor;
+- (id<ANTLRTokenStream>) getTokenStream;
+- (void) setTokenStream:(id<ANTLRTokenStream>)aTokenStream;	///< Added by subclass, not in protocol
+- (void) setUsesUniqueNavigationNodes:(BOOL)flag;
+
+- (id) nodeAtIndex:(NSUInteger) idx;
+
+- (NSString *) toString;
+- (NSString *) toStringWithRange:(NSRange) aRange;
+- (NSString *) toStringFromNode:(id)startNode toNode:(id)stopNode;
+
+#pragma mark ANTLRIntStream conformance
+- (void) consume;
+- (NSInteger) LA:(NSUInteger) i;
+- (NSUInteger) mark;
+- (NSUInteger) getIndex;
+- (void) rewind:(NSUInteger) marker;
+- (void) rewind;
+- (void) release:(NSUInteger) marker;
+- (void) seek:(NSUInteger) index;
+- (NSUInteger) size;
+
+#pragma mark Lookahead Handling
+- (void) addLookahead:(id<ANTLRBaseTree>)aNode;
+- (NSUInteger) lookaheadSize;
+- (void) fillBufferWithLookahead:(NSInteger)k;
+- (id) nextObject;
+
+#pragma mark Node visiting
+- (ANTLRCommonTree *) handleRootNode;
+- (ANTLRCommonTree *) visitChild:(NSInteger)childNumber;
+- (void) walkBackToMostRecentNodeWithUnvisitedChildren;
+- (void) addNavigationNodeWithType:(NSInteger)tokenType;
+
+#pragma mark Accessors
+- (ANTLRCommonTree *) root;
+- (void) setRoot: (ANTLRCommonTree *) aRoot;
+
+@end
diff --git a/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStream.m b/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStream.m
new file mode 100644
index 0000000..1ee1e4f
--- /dev/null
+++ b/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStream.m
@@ -0,0 +1,432 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+
+#import "ANTLRUnbufferedCommonTreeNodeStream.h"
+#import "ANTLRUnbufferedCommonTreeNodeStreamState.h"
+#import "ANTLRBaseTree.h"
+#import "ANTLRToken.h"
+
+#define INITIAL_LOOKAHEAD_BUFFER_SIZE 5
+@implementation ANTLRUnbufferedCommonTreeNodeStream
+
+@synthesize root;
+@synthesize currentNode;
+@synthesize previousNode;
+@synthesize treeAdaptor;
+@synthesize tokenStream;
+@synthesize nodeStack;
+@synthesize indexStack;
+@synthesize markers;
+@synthesize lastMarker;
+@synthesize currentChildIndex;
+@synthesize absoluteNodeIndex;
+@synthesize lookahead;
+@synthesize head;
+@synthesize tail;
+
+- (id) initWithTree:(ANTLRCommonTree *)theTree
+{
+	return [self initWithTree:theTree treeAdaptor:nil];
+}
+
+- (id) initWithTree:(ANTLRCommonTree *)theTree treeAdaptor:(ANTLRCommonTreeAdaptor *)theAdaptor
+{
+	if ((self = [super init]) != nil) {
+		[self setRoot:theTree];
+		if ( theAdaptor == nil )
+			[self setTreeAdaptor:[ANTLRCommonTreeAdaptor newTreeAdaptor]];
+		else
+			[self setTreeAdaptor:theAdaptor];
+		nodeStack = [[NSMutableArray arrayWithCapacity:5] retain];
+		indexStack = [[NSMutableArray arrayWithCapacity:5] retain];
+		markers = [[ANTLRPtrBuffer newANTLRPtrBufferWithLen:100] retain];
+        // [markers insertObject:[NSNull null] atIndex:0];	// markers is one based - maybe fix this later
+		lookahead = [NSMutableArray arrayWithCapacity:INITIAL_LOOKAHEAD_BUFFER_SIZE];	// lookahead is filled with [NSNull null] in -reset
+        [lookahead retain];
+		[self reset];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+	[self setRoot:nil];
+	[self setTreeAdaptor:nil];
+
+	[nodeStack release];	nodeStack = nil;
+	[indexStack release];	indexStack = nil;
+	[markers release];		markers = nil;
+	[lookahead release];	lookahead = nil;
+
+	[super dealloc];
+}
+
+- (void) reset
+{
+	currentNode = root;
+	previousNode = nil;
+	currentChildIndex = -1;
+	absoluteNodeIndex = -1;
+	head = tail = 0;
+	[nodeStack removeAllObjects];
+	[indexStack removeAllObjects];
+	[markers removeAllObjects];
+    // [markers insertObject:[NSNull null] atIndex:0];	// markers is one based - maybe fix this later
+	[lookahead removeAllObjects];
+	// TODO: this is not ideal, but works for now. optimize later
+	int i;
+	for (i = 0; i < INITIAL_LOOKAHEAD_BUFFER_SIZE; i++)
+		[lookahead addObject:[NSNull null]];
+}
+
+
+#pragma mark ANTLRTreeNodeStream conformance
+
+- (id) LT:(NSInteger)k
+{
+	if (k == -1)
+		return previousNode;
+	if (k < 0)
+		@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-LT: looking back more than one node unsupported for unbuffered streams" userInfo:nil];
+	if (k == 0)
+		return ANTLRBaseTree.INVALID_NODE;
+	[self fillBufferWithLookahead:k];
+	return [lookahead objectAtIndex:(head+k-1) % [lookahead count]];
+}
+
+- (id) treeSource
+{
+	return [self root];
+}
+
+- (id<ANTLRTreeAdaptor>) getTreeAdaptor;
+{
+	return treeAdaptor;
+}
+
+- (void)setTreeAdaptor:(id<ANTLRTreeAdaptor>)aTreeAdaptor
+{
+    if (treeAdaptor != aTreeAdaptor) {
+        [aTreeAdaptor retain];
+        [treeAdaptor release];
+        treeAdaptor = aTreeAdaptor;
+    }
+}
+
+- (id<ANTLRTokenStream>) getTokenStream
+{
+	return tokenStream;
+}
+
+- (void) setTokenStream:(id<ANTLRTokenStream>)aTokenStream
+{
+	if (tokenStream != aTokenStream) {
+		[tokenStream release];
+		[aTokenStream retain];
+		tokenStream = aTokenStream;
+	}
+}
+
+- (void) setUsesUniqueNavigationNodes:(BOOL)flag
+{
+	shouldUseUniqueNavigationNodes = flag;
+}
+
+- (id) nodeAtIndex:(NSUInteger) idx
+{
+	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-nodeAtIndex: unsupported for unbuffered streams" userInfo:nil];
+}
+
+- (NSString *) toString
+{
+	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-toString unsupported for unbuffered streams" userInfo:nil];
+}
+
+- (NSString *) toStringWithRange:(NSRange) aRange
+{
+	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-toString: unsupported for unbuffered streams" userInfo:nil];
+}
+
+- (NSString *) toStringFromNode:(id)startNode ToNode:(id)stopNode
+{
+	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-toStringFromNode:toNode: unsupported for unbuffered streams" userInfo:nil];
+}
+
+#pragma mark ANTLRIntStream conformance
+
+- (void) consume
+{
+	[self fillBufferWithLookahead:1];
+	absoluteNodeIndex++;
+	previousNode = [lookahead objectAtIndex:head];
+	head = (head+1) % [lookahead count];
+}
+
+- (NSInteger) LA:(NSUInteger) i
+{
+	ANTLRCommonTree *node = [self LT:i];
+	if (!node)
+		return ANTLRTokenTypeInvalid;
+	int ttype = [node getType];
+	return ttype;
+}
+
+- (NSUInteger) mark
+{
+	ANTLRUnbufferedCommonTreeNodeStreamState *state = [[[ANTLRUnbufferedCommonTreeNodeStreamState alloc] init] retain];
+	[state setCurrentNode:currentNode];
+	[state setPreviousNode:previousNode];
+	[state setIndexStackSize:[indexStack count]];
+	[state setNodeStackSize:[nodeStack count]];
+	[state setCurrentChildIndex:currentChildIndex];
+	[state setAbsoluteNodeIndex:absoluteNodeIndex];
+	unsigned int lookaheadSize = [self lookaheadSize];
+	unsigned int k;
+	for ( k = 0; k < lookaheadSize; k++) {
+		[state addToLookahead:[self LT:k+1]];
+	}
+	[markers addObject:state];
+	//[state release];
+	return [markers count];
+}
+
+- (NSUInteger) getIndex
+{
+	return absoluteNodeIndex + 1;
+}
+
+- (void) rewind:(NSUInteger) marker
+{
+	if ( [markers count] < marker ) {
+		return;
+	}
+	ANTLRUnbufferedCommonTreeNodeStreamState *state = [markers objectAtIndex:marker];
+	[markers removeObjectAtIndex:marker];
+
+	absoluteNodeIndex = [state absoluteNodeIndex];
+	currentChildIndex = [state currentChildIndex];
+	currentNode = [state currentNode];
+	previousNode = [state previousNode];
+	// drop node and index stacks back to old size
+	[nodeStack removeObjectsInRange:NSMakeRange([state nodeStackSize], [nodeStack count]-[state nodeStackSize])];
+	[indexStack removeObjectsInRange:NSMakeRange([state indexStackSize], [indexStack count]-[state indexStackSize])];
+
+	head = tail = 0; // wack lookahead buffer and then refill
+	[lookahead release];
+	lookahead = [[NSMutableArray alloc] initWithArray:[state lookahead]];
+	tail = [lookahead count];
+	// make some room after the restored lookahead, so that the above line is not a bug ;)
+	// this also ensures that a subsequent -addLookahead: will not immediately need to resize the buffer
+	[lookahead addObjectsFromArray:[NSArray arrayWithObjects:[NSNull null], [NSNull null], [NSNull null], [NSNull null], [NSNull null], nil]];
+}
+
+- (void) rewind
+{
+	[self rewind:[markers count]];
+}
+
+- (void) release:(NSUInteger) marker
+{
+	@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-release: unsupported for unbuffered streams" userInfo:nil];
+}
+
+- (void) seek:(NSUInteger) anIndex
+{
+	if ( anIndex < (NSUInteger) index )
+		@throw [NSException exceptionWithName:@"ANTLRTreeException" reason:@"-seek: backwards unsupported for unbuffered streams" userInfo:nil];
+	while ( (NSUInteger) index < anIndex ) {
+		[self consume];
+	}
+}
+
+- (NSUInteger) size;
+{
+	return absoluteNodeIndex + 1;	// not entirely correct, but cheap.
+}
+
+
+#pragma mark Lookahead Handling
+- (void) addLookahead:(id<ANTLRBaseTree>)aNode
+{
+	[lookahead replaceObjectAtIndex:tail withObject:aNode];
+	tail = (tail+1) % [lookahead count];
+
+	if ( tail == head ) {
+		NSMutableArray *newLookahead = [[[NSMutableArray alloc] initWithCapacity:[lookahead count]*2] retain];
+
+		NSRange headRange = NSMakeRange(head, [lookahead count]-head);
+		NSRange tailRange = NSMakeRange(0, tail);
+
+		[newLookahead addObjectsFromArray:[lookahead objectsAtIndexes:[NSIndexSet indexSetWithIndexesInRange:headRange]]];
+		[newLookahead addObjectsFromArray:[lookahead objectsAtIndexes:[NSIndexSet indexSetWithIndexesInRange:tailRange]]];
+
+		unsigned int i;
+		unsigned int lookaheadCount = [newLookahead count];
+		for (i = 0; i < lookaheadCount; i++)
+			[newLookahead addObject:[NSNull null]];
+		[lookahead release];
+		lookahead = newLookahead;
+
+		head = 0;
+		tail = lookaheadCount;	// tail is the location the _next_ lookahead node will end up in, not the last element's idx itself!
+	}
+
+}
+
+- (NSUInteger) lookaheadSize
+{
+	return tail < head
+		? ([lookahead count] - head + tail)
+		: (tail - head);
+}
+
+- (void) fillBufferWithLookahead:(NSInteger)k
+{
+	unsigned int n = [self lookaheadSize];
+	unsigned int i;
+	id lookaheadObject = self; // any valid object would do.
+	for (i=1; i <= k-n && lookaheadObject != nil; i++) {
+		lookaheadObject = [self nextObject];
+	}
+}
+
+- (id) nextObject
+{
+	// NOTE: this could/should go into an NSEnumerator subclass for treenode streams.
+	if (currentNode == nil) {
+        if ( navigationNodeEOF == nil ) {
+            navigationNodeEOF = [[ANTLRTreeNavigationNodeEOF alloc] init];
+        }
+		[self addLookahead:navigationNodeEOF];
+		return nil;
+	}
+	if (currentChildIndex == -1) {
+		return [self handleRootNode];
+	}
+	if (currentChildIndex < (NSInteger)[currentNode getChildCount]) {
+		return [self visitChild:currentChildIndex];
+	}
+	[self walkBackToMostRecentNodeWithUnvisitedChildren];
+	if (currentNode != nil) {
+		return [self visitChild:currentChildIndex];
+	}
+
+	return nil;
+}
+
+#pragma mark Node visiting
+- (ANTLRCommonTree *) handleRootNode
+{
+	ANTLRCommonTree *node = currentNode;
+	currentChildIndex = 0;
+	if ([node isNil]) {
+		node = [self visitChild:currentChildIndex];
+	} else {
+		[self addLookahead:node];
+		if ([currentNode getChildCount] == 0) {
+			currentNode = nil;
+		}
+	}
+	return node;
+}
+
+- (ANTLRCommonTree *) visitChild:(NSInteger)childNumber
+{
+	ANTLRCommonTree *node = nil;
+
+	[nodeStack addObject:currentNode];
+	[indexStack addObject:[NSNumber numberWithInt:childNumber]];
+	if (childNumber == 0 && ![currentNode isNil])
+		[self addNavigationNodeWithType:ANTLRTokenTypeDOWN];
+
+	currentNode = [currentNode getChild:childNumber];
+	currentChildIndex = 0;
+	node = currentNode;  // record node to return
+	[self addLookahead:node];
+	[self walkBackToMostRecentNodeWithUnvisitedChildren];
+	return node;
+}
+
+- (void) walkBackToMostRecentNodeWithUnvisitedChildren
+{
+	while (currentNode != nil && currentChildIndex >= (NSInteger)[currentNode getChildCount])
+	{
+		currentNode = (ANTLRCommonTree *)[nodeStack lastObject];
+		[nodeStack removeLastObject];
+		currentChildIndex = [(NSNumber *)[indexStack lastObject] intValue];
+		[indexStack removeLastObject];
+		currentChildIndex++; // move to next child
+		if (currentChildIndex >= (NSInteger)[currentNode getChildCount]) {
+			if (![currentNode isNil]) {
+				[self addNavigationNodeWithType:ANTLRTokenTypeUP];
+			}
+			if (currentNode == root) { // we done yet?
+				currentNode = nil;
+			}
+		}
+	}
+
+}
+
+- (void) addNavigationNodeWithType:(NSInteger)tokenType
+{
+	// TODO: this currently ignores shouldUseUniqueNavigationNodes.
+	switch (tokenType) {
+		case ANTLRTokenTypeDOWN: {
+            if (navigationNodeDown == nil) {
+                navigationNodeDown = [[ANTLRTreeNavigationNodeDown alloc] init];
+            }
+			[self addLookahead:navigationNodeDown];
+			break;
+		}
+		case ANTLRTokenTypeUP: {
+            if (navigationNodeUp == nil) {
+                navigationNodeUp = [[ANTLRTreeNavigationNodeUp alloc] init];
+            }
+			[self addLookahead:navigationNodeUp];
+			break;
+		}
+	}
+}
+
+#pragma mark Accessors
+- (ANTLRCommonTree *) root
+{
+    return root;
+}
+
+- (void) setRoot: (ANTLRCommonTree *) aRoot
+{
+    if (root != aRoot) {
+        [aRoot retain];
+        [root release];
+        root = aRoot;
+    }
+}
+
+@end
+
diff --git a/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStreamState.h b/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStreamState.h
new file mode 100644
index 0000000..f728952
--- /dev/null
+++ b/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStreamState.h
@@ -0,0 +1,66 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRCommonTree.h"
+
+@interface ANTLRUnbufferedCommonTreeNodeStreamState : NSObject {
+	ANTLRCommonTree *currentNode;
+	ANTLRCommonTree *previousNode;
+
+	int currentChildIndex;
+	int absoluteNodeIndex;
+	unsigned int nodeStackSize;
+	unsigned int indexStackSize;
+
+	NSMutableArray *lookahead;
+}
+
+- (ANTLRCommonTree *) currentNode;
+- (void) setCurrentNode: (ANTLRCommonTree *) aCurrentNode;
+
+- (ANTLRCommonTree *) previousNode;
+- (void) setPreviousNode: (ANTLRCommonTree *) aPreviousNode;
+
+- (NSInteger) currentChildIndex;
+- (void) setCurrentChildIndex: (NSInteger) aCurrentChildIndex;
+
+- (NSInteger) absoluteNodeIndex;
+- (void) setAbsoluteNodeIndex: (NSInteger) anAbsoluteNodeIndex;
+
+- (NSUInteger) nodeStackSize;
+- (void) setNodeStackSize: (NSUInteger) aNodeStackSize;
+
+- (NSUInteger) indexStackSize;
+- (void) setIndexStackSize: (NSUInteger) anIndexStackSize;
+
+- (NSMutableArray *) lookahead;
+- (void) setLookahead: (NSMutableArray *) aLookahead;
+
+- (void) addToLookahead: (id)lookaheadObject;
+- (void) removeFromLookahead: (id)lookaheadObject;
+
+@end
diff --git a/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStreamState.m b/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStreamState.m
new file mode 100644
index 0000000..c46d28d
--- /dev/null
+++ b/runtime/ObjC/Framework/UnbufferedCommonTreeNodeStreamState.m
@@ -0,0 +1,140 @@
+// [The "BSD licence"]
+// Copyright (c) 2006-2007 Kay Roepke 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRUnbufferedCommonTreeNodeStreamState.h"
+
+
+@implementation ANTLRUnbufferedCommonTreeNodeStreamState
+
+- (id) init
+{
+	if ((self = [super init]) != nil) {
+		lookahead = [[NSMutableArray alloc] init];
+	}
+	return self;
+}
+
+- (void) dealloc
+{
+	[self setLookahead:nil];
+	[self setCurrentNode:nil];
+	[self setPreviousNode:nil];
+	[super dealloc];
+}
+
+- (ANTLRCommonTree *) currentNode
+{
+    return currentNode;
+}
+
+- (void) setCurrentNode: (ANTLRCommonTree *) aCurrentNode
+{
+    if (currentNode != aCurrentNode) {
+        [aCurrentNode retain];
+        [currentNode release];
+        currentNode = aCurrentNode;
+    }
+}
+
+- (ANTLRCommonTree *) previousNode
+{
+    return previousNode;
+}
+
+- (void) setPreviousNode: (ANTLRCommonTree *) aPreviousNode
+{
+    if (previousNode != aPreviousNode) {
+        [aPreviousNode retain];
+        [previousNode release];
+        previousNode = aPreviousNode;
+    }
+}
+
+- (NSInteger) currentChildIndex
+{
+    return currentChildIndex;
+}
+
+- (void) setCurrentChildIndex: (NSInteger) aCurrentChildIndex
+{
+    currentChildIndex = aCurrentChildIndex;
+}
+
+- (NSInteger) absoluteNodeIndex
+{
+    return absoluteNodeIndex;
+}
+
+- (void) setAbsoluteNodeIndex: (NSInteger) anAbsoluteNodeIndex
+{
+    absoluteNodeIndex = anAbsoluteNodeIndex;
+}
+
+- (NSUInteger) nodeStackSize
+{
+    return nodeStackSize;
+}
+
+- (void) setNodeStackSize: (NSUInteger) aNodeStackSize
+{
+    nodeStackSize = aNodeStackSize;
+}
+
+- (NSUInteger) indexStackSize
+{
+    return indexStackSize;
+}
+
+- (void) setIndexStackSize: (NSUInteger) anIndexStackSize
+{
+    indexStackSize = anIndexStackSize;
+}
+
+- (NSMutableArray *) lookahead
+{
+    return lookahead;
+}
+
+- (void) setLookahead: (NSMutableArray *) aLookahead
+{
+    if (lookahead != aLookahead) {
+        [aLookahead retain];
+        [lookahead release];
+        lookahead = aLookahead;
+    }
+}
+
+- (void) addToLookahead: (id)lookaheadObject
+{
+    [[self lookahead] addObject: lookaheadObject];
+}
+- (void) removeFromLookahead: (id)lookaheadObject
+{
+    [[self lookahead] removeObject: lookaheadObject];
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/UnbufferedTokenStream.h b/runtime/ObjC/Framework/UnbufferedTokenStream.h
new file mode 100644
index 0000000..84d8f43
--- /dev/null
+++ b/runtime/ObjC/Framework/UnbufferedTokenStream.h
@@ -0,0 +1,62 @@
+//
+//  ANTLRUnbufferedTokenStream.h
+//  ANTLR
+//
+//  Created by Alan Condit on 7/12/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRRuntimeException.h"
+#import "ANTLRTokenSource.h"
+#import "ANTLRLookaheadStream.h"
+#import "ANTLRToken.h"
+
+@interface ANTLRUnbufferedTokenStream : ANTLRLookaheadStream {
+	id<ANTLRTokenSource> tokenSource;
+    NSInteger tokenIndex; // simple counter to set token index in tokens
+    NSInteger channel;
+}
+
+@property (retain, getter=getTokenSource, setter=setTokenSource:) id<ANTLRTokenSource> tokenSource;
+@property (getter=getTokenIndex, setter=setTokenIndex:) NSInteger tokenIndex;
+@property (getter=channel, setter=setChannel:) NSInteger channel;
+
++ (ANTLRUnbufferedTokenStream *)newANTLRUnbufferedTokenStream:(id<ANTLRTokenSource>)aTokenSource;
+- (id) init;
+- (id) initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource;
+
+- (id<ANTLRToken>)nextElement;
+- (BOOL)isEOF:(id<ANTLRToken>) aToken;
+- (id<ANTLRTokenSource>)getTokenSource;
+- (NSString *)toStringFromStart:(NSInteger)aStart ToEnd:(NSInteger)aStop;
+- (NSString *)toStringFromToken:(id<ANTLRToken>)aStart ToEnd:(id<ANTLRToken>)aStop;
+- (NSInteger)LA:(NSInteger)anIdx;
+- (id<ANTLRToken>)objectAtIndex:(NSInteger)anIdx;
+- (NSString *)getSourceName;
+
+
+@end
diff --git a/runtime/ObjC/Framework/UnbufferedTokenStream.m b/runtime/ObjC/Framework/UnbufferedTokenStream.m
new file mode 100644
index 0000000..3b74e92
--- /dev/null
+++ b/runtime/ObjC/Framework/UnbufferedTokenStream.m
@@ -0,0 +1,118 @@
+//
+//  ANTLRUnbufferedTokenStream.m
+//  ANTLR
+//
+//  Created by Alan Condit on 7/12/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRUnbufferedTokenStream.h"
+
+@implementation ANTLRUnbufferedTokenStream
+
+@synthesize tokenSource;
+@synthesize tokenIndex;
+@synthesize channel;
+
++ (ANTLRUnbufferedTokenStream *)newANTLRUnbufferedTokenStream:(id<ANTLRTokenSource>)aTokenSource
+{
+    return [[ANTLRUnbufferedTokenStream alloc] initWithTokenSource:aTokenSource];
+}
+
+- (id) init
+{
+    if ((self = [super init]) != nil) {
+        tokenSource = nil;
+        tokenIndex = 0;
+        channel = ANTLRTokenChannelDefault;
+    }
+    return self;
+}
+
+- (id) initWithTokenSource:(id<ANTLRTokenSource>)aTokenSource
+{
+    if ((self = [super init]) != nil) {
+        tokenSource = aTokenSource;
+        if ( tokenSource ) [tokenSource retain];
+        tokenIndex = 0;
+        channel = ANTLRTokenChannelDefault;
+    }
+    return self;
+}
+
+- (void) dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRUnbufferedTokenStream" );
+#endif
+    if ( tokenSource ) [tokenSource release];
+    [super dealloc];
+}
+
+- (id<ANTLRToken>)nextElement
+{
+    id<ANTLRToken> t = [tokenSource nextToken];
+    [t setTokenIndex:tokenIndex++];
+    return t;
+}
+
+- (BOOL)isEOF:(id<ANTLRToken>)aToken
+{
+    return (aToken.type == ANTLRTokenTypeEOF);
+}
+
+- (id<ANTLRTokenSource>)getTokenSource
+{
+    return tokenSource;
+}
+
+- (NSString *)toStringFromStart:(NSInteger)aStart ToEnd:(NSInteger)aStop
+{
+    return @"n/a";
+}
+
+- (NSString *)toStringFromToken:(id<ANTLRToken>)aStart ToEnd:(id<ANTLRToken>)aStop
+{
+    return @"n/a";
+}
+
+- (NSInteger)LA:(NSInteger)anIdx
+{
+    return [[self LT:anIdx] type];
+}
+
+- (id<ANTLRToken>)objectAtIndex:(NSInteger)anIdx
+{
+    @throw [ANTLRRuntimeException newException:@"Absolute token indexes are meaningless in an unbuffered stream"];
+}
+
+- (NSString *)getSourceName
+{
+    return [tokenSource getSourceName];
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/UniqueIDMap.h b/runtime/ObjC/Framework/UniqueIDMap.h
new file mode 100644
index 0000000..55c92d1
--- /dev/null
+++ b/runtime/ObjC/Framework/UniqueIDMap.h
@@ -0,0 +1,64 @@
+//
+//  ANTLRUniqueIDMap.h
+//  ANTLR
+//
+//  Created by Alan Condit on 7/7/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRPtrBuffer.h"
+#import "ANTLRNodeMapElement.h"
+
+#define SUCCESS             0
+#define FAILURE             -1
+#define HASHSIZE            101
+#define HBUFSIZE            0x2000
+
+@interface ANTLRUniqueIDMap : ANTLRPtrBuffer {
+    NSInteger lastHash;
+}
+
+@property (getter=getLastHash, setter=setLastHash:) NSInteger lastHash;
+
++ (id)newANTLRUniqueIDMap;
++ (id)newANTLRUniqueIDMapWithLen:(NSInteger)aHashSize;
+
+- (id)init;
+- (id)initWithLen:(NSInteger)cnt;
+- (void)dealloc;
+// Instance Methods
+- (NSInteger)count;
+- (NSInteger)size;
+/* clear -- reinitialize the maplist array */
+- (void) clear;
+
+- (void)deleteANTLRUniqueIDMap:(ANTLRNodeMapElement *)np;
+- (void)delete_chain:(ANTLRNodeMapElement *)np;
+- (id)getNode:(id<ANTLRBaseTree>)aNode;
+- (void)putID:(id)anID Node:(id<ANTLRBaseTree>)aNode;
+
+@end
diff --git a/runtime/ObjC/Framework/UniqueIDMap.m b/runtime/ObjC/Framework/UniqueIDMap.m
new file mode 100644
index 0000000..0d52092
--- /dev/null
+++ b/runtime/ObjC/Framework/UniqueIDMap.m
@@ -0,0 +1,184 @@
+//
+//  ANTLRUniqueIDMap.m
+//  ANTLR
+//
+//  Created by Alan Condit on 7/7/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRUniqueIDMap.h"
+#import "ANTLRTree.h"
+
+@implementation ANTLRUniqueIDMap
+@synthesize lastHash;
+
++(id)newANTLRUniqueIDMap
+{
+    ANTLRUniqueIDMap *aNewANTLRUniqueIDMap;
+
+    aNewANTLRUniqueIDMap = [[ANTLRUniqueIDMap alloc] init];
+	return( aNewANTLRUniqueIDMap );
+}
+
++(id)newANTLRUniqueIDMapWithLen:(NSInteger)aBuffSize
+{
+    ANTLRUniqueIDMap *aNewANTLRUniqueIDMap;
+
+    aNewANTLRUniqueIDMap = [[ANTLRUniqueIDMap alloc] initWithLen:aBuffSize];
+	return( aNewANTLRUniqueIDMap );
+}
+
+-(id)init
+{
+    NSInteger idx;
+
+	if ((self = [super initWithLen:HASHSIZE]) != nil) {
+		fNext = nil;
+        for( idx = 0; idx < HASHSIZE; idx++ ) {
+            ptrBuffer[idx] = nil;
+        }
+	}
+    return( self );
+}
+
+-(id)initWithLen:(NSInteger)aBuffSize
+{
+	if ((self = [super initWithLen:aBuffSize]) != nil) {
+	}
+    return( self );
+}
+
+-(void)dealloc
+{
+#ifdef DEBUG_DEALLOC
+    NSLog( @"called dealloc in ANTLRUniqueIDMap" );
+#endif
+    ANTLRNodeMapElement *tmp, *rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < HASHSIZE; idx++ ) {
+            tmp = ptrBuffer[idx];
+            while ( tmp ) {
+                rtmp = tmp;
+                tmp = (ANTLRNodeMapElement *)tmp.fNext;
+                [rtmp release];
+            }
+        }
+    }
+	[super dealloc];
+}
+
+-(void)deleteANTLRUniqueIDMap:(ANTLRNodeMapElement *)np
+{
+    ANTLRNodeMapElement *tmp, *rtmp;
+    NSInteger idx;
+
+    if ( self.fNext != nil ) {
+        for( idx = 0; idx < HASHSIZE; idx++ ) {
+            tmp = ptrBuffer[idx];
+            while ( tmp ) {
+                rtmp = tmp;
+                tmp = tmp.fNext;
+                [rtmp release];
+            }
+        }
+    }
+}
+
+- (void)clear
+{
+    ANTLRNodeMapElement *tmp, *rtmp;
+    NSInteger idx;
+
+    for( idx = 0; idx < HASHSIZE; idx++ ) {
+        tmp = ptrBuffer[idx];
+        while ( tmp ) {
+            rtmp = tmp;
+            tmp = [tmp getfNext];
+            [rtmp release];
+        }
+        ptrBuffer[idx] = nil;
+    }
+}
+
+- (NSInteger)count
+{
+    id anElement;
+    NSInteger aCnt = 0;
+
+    for (int i = 0; i < BuffSize; i++) {
+        if ((anElement = ptrBuffer[i]) != nil) {
+            aCnt += (NSInteger)[anElement count];
+        }
+    }
+    return aCnt;
+}
+
+- (NSInteger)size
+{
+    return BuffSize;
+}
+
+-(void)delete_chain:(ANTLRNodeMapElement *)np
+{
+    if ( np.fNext != nil )
+		[self delete_chain:np.fNext];
+	[np release];
+}
+
+- (id)getNode:(id<ANTLRBaseTree>)aNode
+{
+    ANTLRNodeMapElement *np;
+    NSInteger idx;
+
+    idx = [(id<ANTLRBaseTree>)aNode type];
+    np = ptrBuffer[idx];
+    while ( np != nil ) {
+        if (np.node == aNode) {
+            return( np.index );
+        }
+        np = np.fNext;
+    }
+    return( nil );
+}
+
+- (void)putID:(id)anID Node:(id<ANTLRBaseTree>)aNode
+{
+    ANTLRNodeMapElement *np, *np1;
+    NSInteger idx;
+
+    idx = [(id<ANTLRBaseTree>)aNode type];
+    idx %= HASHSIZE;
+    np = [[ANTLRNodeMapElement newANTLRNodeMapElementWithIndex:anID Node:aNode] retain];
+    np1 = ptrBuffer[idx];
+    np.fNext = np1;
+    ptrBuffer[idx] = np;
+    return;
+}
+
+
+@end
diff --git a/runtime/ObjC/Framework/UnwantedTokenException.h b/runtime/ObjC/Framework/UnwantedTokenException.h
new file mode 100644
index 0000000..fbb60e3
--- /dev/null
+++ b/runtime/ObjC/Framework/UnwantedTokenException.h
@@ -0,0 +1,47 @@
+//
+//  ANTLRUnwantedTokenException.h
+//  ANTLR
+//
+//  Created by Alan Condit on 6/8/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import <Cocoa/Cocoa.h>
+#import "ANTLRMismatchedTokenException.h"
+
+@interface ANTLRUnwantedTokenException : ANTLRMismatchedTokenException {
+
+}
++ (ANTLRUnwantedTokenException *)newException;
++ (ANTLRUnwantedTokenException *)newException:(NSInteger)expected Stream:(id<ANTLRIntStream>)anInput;
+
+- (id) init;
+- (id) initWithStream:(id<ANTLRIntStream>)anInput And:(NSInteger)expected;
+- (id<ANTLRToken>)getUnexpectedToken;
+- (NSString *)toString;
+
+
+@end
diff --git a/runtime/ObjC/Framework/UnwantedTokenException.m b/runtime/ObjC/Framework/UnwantedTokenException.m
new file mode 100644
index 0000000..b8b24f3
--- /dev/null
+++ b/runtime/ObjC/Framework/UnwantedTokenException.m
@@ -0,0 +1,80 @@
+//
+//  ANTLRUnwantedTokenException.m
+//  ANTLR
+//
+//  Created by Alan Condit on 6/8/10.
+// [The "BSD licence"]
+// Copyright (c) 2010 Alan Condit
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+#import "ANTLRUnwantedTokenException.h"
+
+@implementation ANTLRUnwantedTokenException : ANTLRMismatchedTokenException
+	/** Used for remote debugger deserialization */
++ (ANTLRUnwantedTokenException *)newException
+{
+    return [[ANTLRUnwantedTokenException alloc] init];
+}
+
++ (ANTLRUnwantedTokenException *)newException:(NSInteger)expected Stream:(id<ANTLRIntStream>)anInput
+{
+    return [[ANTLRUnwantedTokenException alloc] initWithStream:anInput And:expected];
+}
+
+- (id) init
+{
+    self = [super initWithStream:input];
+    if (self) {
+    }
+    return self;
+}
+
+- (id) initWithStream:(id<ANTLRIntStream>)anInput And:(NSInteger)expected
+{
+    self = [super initWithStream:anInput];
+    if (self) {
+        expecting = expected;
+    }
+    return self;
+}
+
+- (id<ANTLRToken>)getUnexpectedToken
+{
+    return token;
+}
+
+- (NSString *)toString
+{
+    NSString *exp1 = [NSString stringWithFormat:@", expected %d", expecting];
+    if ( expecting == ANTLRTokenTypeInvalid ) {
+        exp1 = @"";
+    }
+    if ( token==nil ) {
+        return [NSString stringWithFormat:@"UnwantedTokenException(found=%@)", exp1];
+    }
+    return [NSString stringWithFormat:@"UnwantedTokenException(found=%@ %@", token.text, exp1];
+}
+
+@end

